{
  "files": {
    "SDL_stdinc.h": {
      "name": "SDL_stdinc.h",
      "entries": {
        "SDL_stdinc_h_": {
          "doc": "",
          "begin": 47,
          "declPos": 47,
          "end": 48,
          "name": "SDL_stdinc_h_",
          "kind": "def"
        },
        "SDL_INCLUDE_STDBOOL_H": {
          "doc": "",
          "begin": 64,
          "declPos": 64,
          "end": 65,
          "name": "SDL_INCLUDE_STDBOOL_H",
          "kind": "def"
        },
        "bool": {
          "doc": "",
          "begin": 72,
          "declPos": 72,
          "end": 73,
          "name": "bool",
          "kind": "def"
        },
        "false": {
          "doc": "",
          "begin": 73,
          "declPos": 73,
          "end": 74,
          "name": "false",
          "kind": "def"
        },
        "true": {
          "doc": "",
          "begin": 74,
          "declPos": 74,
          "end": 75,
          "name": "true",
          "kind": "def"
        },
        "__bool_true_false_are_defined": {
          "doc": "",
          "begin": 75,
          "declPos": 75,
          "end": 76,
          "name": "__bool_true_false_are_defined",
          "kind": "def"
        },
        "SDL_NOLONGLONG": {
          "doc": "Don't let SDL use \"long long\" C types.\n\nSDL will define this if it believes the compiler doesn't understand the\n\"long long\" syntax for C datatypes. This can happen on older compilers.\n\nIf _your_ compiler doesn't support \"long long\" but SDL doesn't know it, it\nis safe to define this yourself to build against the SDL headers.\n\nIf this is defined, it will remove access to some C runtime support\nfunctions, like SDL_ulltoa and SDL_strtoll that refer to this datatype\nexplicitly. The rest of SDL will still be available.\n\nSDL's own source code cannot be built with a compiler that has this\ndefined, for various technical reasons.",
          "begin": 113,
          "declPos": 129,
          "end": 130,
          "name": "SDL_NOLONGLONG",
          "kind": "def"
        },
        "SDL_SIZE_MAX": {
          "doc": "The largest value that a `size_t` can hold for the target platform.\n\n`size_t` is generally the same size as a pointer in modern times, but this\ncan get weird on very old and very esoteric machines. For example, on a\n16-bit Intel 286, you might have a 32-bit \"far\" pointer (16-bit segment\nplus 16-bit offset), but `size_t` is 16 bits, because it can only deal with\nthe offset into an individual segment.\n\nIn modern times, it's generally expected to cover an entire linear address\nspace. But be careful!\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 138,
          "declPos": 152,
          "end": 153,
          "name": "SDL_SIZE_MAX",
          "kind": "def"
        },
        "SDL_COMPILE_TIME_ASSERT": {
          "doc": "A compile-time assertion.\n\nThis can check constant values _known to the compiler at build time_ for\ncorrectness, and end the compile with the error if they fail.\n\nOften times these are used to verify basic truths, like the size of a\ndatatype is what is expected:\n\n```c\nSDL_COMPILE_TIME_ASSERT(uint32_size, sizeof(Uint32) == 4);\n```\n\nThe `name` parameter must be a valid C symbol, and must be unique across\nall compile-time asserts in the same compilation unit (one run of the\ncompiler), or the build might fail with cryptic errors on some targets.\nThis is used with a C language trick that works on older compilers that\ndon't support better assertion techniques.\n\nIf you need an assertion that operates at runtime, on variable data, you\nshould try SDL_assert instead.\n\n\\param name a unique identifier for this assertion.\n\\param x the value to test. Must be a boolean value.\n\n\\threadsafety This macro doesn't generate any code to run.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_assert",
          "begin": 163,
          "declPos": 194,
          "end": 195,
          "name": "SDL_COMPILE_TIME_ASSERT",
          "kind": "def",
          "parameters": [
            "name",
            "x"
          ]
        },
        "SDL_arraysize": {
          "doc": "The number of elements in a static array.\n\nThis will compile but return incorrect results for a pointer to an array;\nit has to be an array the compiler knows the size of.\n\nThis macro looks like it double-evaluates the argument, but it does so\ninside of `sizeof`, so there are no side-effects here, as expressions do\nnot actually run any code in these cases.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 213,
          "declPos": 225,
          "end": 226,
          "name": "SDL_arraysize",
          "kind": "def",
          "parameters": [
            "array"
          ]
        },
        "SDL_STRINGIFY_ARG": {
          "doc": "Macro useful for building other macros with strings in them.\n\nFor example:\n\n```c\n#define LOG_ERROR(X) OutputDebugString(SDL_STRINGIFY_ARG(__FUNCTION__) \": \" X \"\\n\")`\n```\n\n\\param arg the text to turn into a string literal.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 227,
          "declPos": 240,
          "end": 241,
          "name": "SDL_STRINGIFY_ARG",
          "kind": "def",
          "parameters": [
            "arg"
          ]
        },
        "SDL_reinterpret_cast": {
          "doc": "Handle a Reinterpret Cast properly whether using C or C++.\n\nIf compiled as C++, this macro offers a proper C++ reinterpret_cast<>.\n\nIf compiled as C, this macro does a normal C-style cast.\n\nThis is helpful to avoid compiler warnings in C++.\n\n\\param type the type to cast the expression to.\n\\param expression the expression to cast to a different type.\n\\returns `expression`, cast to `type`.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_static_cast\n\\sa SDL_const_cast",
          "begin": 252,
          "declPos": 272,
          "end": 273,
          "name": "SDL_reinterpret_cast",
          "kind": "def",
          "parameters": [
            "type",
            "expression"
          ]
        },
        "SDL_static_cast": {
          "doc": "Handle a Static Cast properly whether using C or C++.\n\nIf compiled as C++, this macro offers a proper C++ static_cast<>.\n\nIf compiled as C, this macro does a normal C-style cast.\n\nThis is helpful to avoid compiler warnings in C++.\n\n\\param type the type to cast the expression to.\n\\param expression the expression to cast to a different type.\n\\returns `expression`, cast to `type`.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_reinterpret_cast\n\\sa SDL_const_cast",
          "begin": 274,
          "declPos": 294,
          "end": 295,
          "name": "SDL_static_cast",
          "kind": "def",
          "parameters": [
            "type",
            "expression"
          ]
        },
        "SDL_const_cast": {
          "doc": "Handle a Const Cast properly whether using C or C++.\n\nIf compiled as C++, this macro offers a proper C++ const_cast<>.\n\nIf compiled as C, this macro does a normal C-style cast.\n\nThis is helpful to avoid compiler warnings in C++.\n\n\\param type the type to cast the expression to.\n\\param expression the expression to cast to a different type.\n\\returns `expression`, cast to `type`.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_reinterpret_cast\n\\sa SDL_static_cast",
          "begin": 296,
          "declPos": 316,
          "end": 317,
          "name": "SDL_const_cast",
          "kind": "def",
          "parameters": [
            "type",
            "expression"
          ]
        },
        "SDL_FOURCC": {
          "doc": "Define a four character code as a Uint32.\n\n\\param A the first ASCII character.\n\\param B the second ASCII character.\n\\param C the third ASCII character.\n\\param D the fourth ASCII character.\n\\returns the four characters converted into a Uint32, one character\n         per-byte.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 330,
          "declPos": 344,
          "end": 349,
          "name": "SDL_FOURCC",
          "kind": "def",
          "parameters": [
            "A",
            "B",
            "C",
            "D"
          ]
        },
        "SDL_SINT64_C": {
          "doc": "Append the 64 bit integer suffix to a signed integer literal.\n\nThis helps compilers that might believe a integer literal larger than\n0xFFFFFFFF is overflowing a 32-bit value. Use `SDL_SINT64_C(0xFFFFFFFF1)`\ninstead of `0xFFFFFFFF1` by itself.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_UINT64_C",
          "begin": 352,
          "declPos": 363,
          "end": 364,
          "name": "SDL_SINT64_C",
          "kind": "def",
          "parameters": [
            "c"
          ]
        },
        "SDL_UINT64_C": {
          "doc": "Append the 64 bit integer suffix to an unsigned integer literal.\n\nThis helps compilers that might believe a integer literal larger than\n0xFFFFFFFF is overflowing a 32-bit value. Use `SDL_UINT64_C(0xFFFFFFFF1)`\ninstead of `0xFFFFFFFF1` by itself.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_SINT64_C",
          "begin": 365,
          "declPos": 376,
          "end": 377,
          "name": "SDL_UINT64_C",
          "kind": "def",
          "parameters": [
            "c"
          ]
        },
        "Sint8": {
          "doc": "A signed 8-bit integer type.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 411,
          "declPos": 416,
          "end": 417,
          "name": "Sint8",
          "kind": "alias",
          "type": "int8_t"
        },
        "SDL_MAX_SINT8": {
          "doc": "",
          "begin": 417,
          "declPos": 417,
          "end": 418,
          "name": "SDL_MAX_SINT8",
          "kind": "def"
        },
        "SDL_MIN_SINT8": {
          "doc": "",
          "begin": 418,
          "declPos": 418,
          "end": 419,
          "name": "SDL_MIN_SINT8",
          "kind": "def"
        },
        "Uint8": {
          "doc": "An unsigned 8-bit integer type.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 420,
          "declPos": 425,
          "end": 426,
          "name": "Uint8",
          "kind": "alias",
          "type": "uint8_t"
        },
        "SDL_MAX_UINT8": {
          "doc": "",
          "begin": 426,
          "declPos": 426,
          "end": 427,
          "name": "SDL_MAX_UINT8",
          "kind": "def"
        },
        "SDL_MIN_UINT8": {
          "doc": "",
          "begin": 427,
          "declPos": 427,
          "end": 428,
          "name": "SDL_MIN_UINT8",
          "kind": "def"
        },
        "Sint16": {
          "doc": "A signed 16-bit integer type.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 429,
          "declPos": 434,
          "end": 435,
          "name": "Sint16",
          "kind": "alias",
          "type": "int16_t"
        },
        "SDL_MAX_SINT16": {
          "doc": "",
          "begin": 435,
          "declPos": 435,
          "end": 436,
          "name": "SDL_MAX_SINT16",
          "kind": "def"
        },
        "SDL_MIN_SINT16": {
          "doc": "",
          "begin": 436,
          "declPos": 436,
          "end": 437,
          "name": "SDL_MIN_SINT16",
          "kind": "def"
        },
        "Uint16": {
          "doc": "An unsigned 16-bit integer type.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 438,
          "declPos": 443,
          "end": 444,
          "name": "Uint16",
          "kind": "alias",
          "type": "uint16_t"
        },
        "SDL_MAX_UINT16": {
          "doc": "",
          "begin": 444,
          "declPos": 444,
          "end": 445,
          "name": "SDL_MAX_UINT16",
          "kind": "def"
        },
        "SDL_MIN_UINT16": {
          "doc": "",
          "begin": 445,
          "declPos": 445,
          "end": 446,
          "name": "SDL_MIN_UINT16",
          "kind": "def"
        },
        "Sint32": {
          "doc": "A signed 32-bit integer type.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 447,
          "declPos": 452,
          "end": 453,
          "name": "Sint32",
          "kind": "alias",
          "type": "int32_t"
        },
        "SDL_MAX_SINT32": {
          "doc": "",
          "begin": 453,
          "declPos": 453,
          "end": 454,
          "name": "SDL_MAX_SINT32",
          "kind": "def"
        },
        "SDL_MIN_SINT32": {
          "doc": "",
          "begin": 454,
          "declPos": 454,
          "end": 455,
          "name": "SDL_MIN_SINT32",
          "kind": "def"
        },
        "Uint32": {
          "doc": "An unsigned 32-bit integer type.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 456,
          "declPos": 461,
          "end": 462,
          "name": "Uint32",
          "kind": "alias",
          "type": "uint32_t"
        },
        "SDL_MAX_UINT32": {
          "doc": "",
          "begin": 462,
          "declPos": 462,
          "end": 463,
          "name": "SDL_MAX_UINT32",
          "kind": "def"
        },
        "SDL_MIN_UINT32": {
          "doc": "",
          "begin": 463,
          "declPos": 463,
          "end": 464,
          "name": "SDL_MIN_UINT32",
          "kind": "def"
        },
        "Sint64": {
          "doc": "A signed 64-bit integer type.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_SINT64_C",
          "begin": 465,
          "declPos": 472,
          "end": 473,
          "name": "Sint64",
          "kind": "alias",
          "type": "int64_t"
        },
        "SDL_MAX_SINT64": {
          "doc": "",
          "begin": 473,
          "declPos": 473,
          "end": 474,
          "name": "SDL_MAX_SINT64",
          "kind": "def"
        },
        "SDL_MIN_SINT64": {
          "doc": "",
          "begin": 474,
          "declPos": 474,
          "end": 475,
          "name": "SDL_MIN_SINT64",
          "kind": "def"
        },
        "Uint64": {
          "doc": "An unsigned 64-bit integer type.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_UINT64_C",
          "begin": 476,
          "declPos": 483,
          "end": 484,
          "name": "Uint64",
          "kind": "alias",
          "type": "uint64_t"
        },
        "SDL_MAX_UINT64": {
          "doc": "",
          "begin": 484,
          "declPos": 484,
          "end": 485,
          "name": "SDL_MAX_UINT64",
          "kind": "def"
        },
        "SDL_MIN_UINT64": {
          "doc": "",
          "begin": 485,
          "declPos": 485,
          "end": 486,
          "name": "SDL_MIN_UINT64",
          "kind": "def"
        },
        "SDL_Time": {
          "doc": "SDL times are signed, 64-bit integers representing nanoseconds since the\nUnix epoch (Jan 1, 1970).\n\nThey can be converted between POSIX time_t values with SDL_NS_TO_SECONDS()\nand SDL_SECONDS_TO_NS(), and between Windows FILETIME values with\nSDL_TimeToWindows() and SDL_TimeFromWindows().\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_MAX_SINT64\n\\sa SDL_MIN_SINT64",
          "begin": 487,
          "declPos": 500,
          "end": 501,
          "name": "SDL_Time",
          "kind": "alias",
          "type": "Sint64"
        },
        "SDL_MAX_TIME": {
          "doc": "",
          "begin": 501,
          "declPos": 501,
          "end": 502,
          "name": "SDL_MAX_TIME",
          "kind": "def"
        },
        "SDL_MIN_TIME": {
          "doc": "",
          "begin": 502,
          "declPos": 502,
          "end": 503,
          "name": "SDL_MIN_TIME",
          "kind": "def"
        },
        "SDL_FLT_EPSILON": {
          "doc": "Epsilon constant, used for comparing floating-point numbers.\n\nEquals by default to platform-defined `FLT_EPSILON`, or\n`1.1920928955078125e-07F` if that's not available.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 515,
          "declPos": 523,
          "end": 524,
          "name": "SDL_FLT_EPSILON",
          "kind": "def"
        },
        "SDL_PRIs64": {
          "doc": "A printf-formatting string for an Sint64 value.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRIs64 \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 530,
          "declPos": 541,
          "end": 542,
          "name": "SDL_PRIs64",
          "kind": "def"
        },
        "SDL_PRIu64": {
          "doc": "A printf-formatting string for a Uint64 value.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRIu64 \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 543,
          "declPos": 554,
          "end": 555,
          "name": "SDL_PRIu64",
          "kind": "def"
        },
        "SDL_PRIx64": {
          "doc": "A printf-formatting string for a Uint64 value as lower-case hexadecimal.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRIx64 \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 556,
          "declPos": 567,
          "end": 568,
          "name": "SDL_PRIx64",
          "kind": "def"
        },
        "SDL_PRIX64": {
          "doc": "A printf-formatting string for a Uint64 value as upper-case hexadecimal.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRIX64 \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 569,
          "declPos": 580,
          "end": 581,
          "name": "SDL_PRIX64",
          "kind": "def"
        },
        "SDL_PRIs32": {
          "doc": "A printf-formatting string for an Sint32 value.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRIs32 \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 582,
          "declPos": 593,
          "end": 594,
          "name": "SDL_PRIs32",
          "kind": "def"
        },
        "SDL_PRIu32": {
          "doc": "A printf-formatting string for a Uint32 value.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRIu32 \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 595,
          "declPos": 606,
          "end": 607,
          "name": "SDL_PRIu32",
          "kind": "def"
        },
        "SDL_PRIx32": {
          "doc": "A printf-formatting string for a Uint32 value as lower-case hexadecimal.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRIx32 \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 608,
          "declPos": 619,
          "end": 620,
          "name": "SDL_PRIx32",
          "kind": "def"
        },
        "SDL_PRIX32": {
          "doc": "A printf-formatting string for a Uint32 value as upper-case hexadecimal.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRIX32 \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 621,
          "declPos": 632,
          "end": 633,
          "name": "SDL_PRIX32",
          "kind": "def"
        },
        "SDL_PRILL_PREFIX": {
          "doc": "A printf-formatting string prefix for a `long long` value.\n\nThis is just the prefix! You probably actually want SDL_PRILLd, SDL_PRILLu,\nSDL_PRILLx, or SDL_PRILLX instead.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRILL_PREFIX \"d bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 634,
          "declPos": 648,
          "end": 649,
          "name": "SDL_PRILL_PREFIX",
          "kind": "def"
        },
        "SDL_PRILLd": {
          "doc": "A printf-formatting string for a `long long` value.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRILLd \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 650,
          "declPos": 661,
          "end": 662,
          "name": "SDL_PRILLd",
          "kind": "def"
        },
        "SDL_PRILLu": {
          "doc": "A printf-formatting string for a `unsigned long long` value.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRILLu \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 663,
          "declPos": 674,
          "end": 675,
          "name": "SDL_PRILLu",
          "kind": "def"
        },
        "SDL_PRILLx": {
          "doc": "A printf-formatting string for an `unsigned long long` value as lower-case\nhexadecimal.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRILLx \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 676,
          "declPos": 688,
          "end": 689,
          "name": "SDL_PRILLx",
          "kind": "def"
        },
        "SDL_PRILLX": {
          "doc": "A printf-formatting string for an `unsigned long long` value as upper-case\nhexadecimal.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRILLX \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 690,
          "declPos": 702,
          "end": 703,
          "name": "SDL_PRILLX",
          "kind": "def"
        },
        "SDL_IN_BYTECAP": {
          "doc": "Macro that annotates function params with input buffer size.\n\nIf we were to annotate `memcpy`:\n\n```c\nvoid *memcpy(void *dst, SDL_IN_BYTECAP(len) const void *src, size_t len);\n```\n\nThis notes that `src` should be `len` bytes in size and is only read by the\nfunction. The compiler or other analysis tools can warn when this doesn't\nappear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 805,
          "declPos": 822,
          "end": 823,
          "name": "SDL_IN_BYTECAP",
          "kind": "def",
          "parameters": [
            "x"
          ]
        },
        "SDL_INOUT_Z_CAP": {
          "doc": "Macro that annotates function params with input/output string buffer size.\n\nIf we were to annotate `strlcat`:\n\n```c\nsize_t strlcat(SDL_INOUT_Z_CAP(maxlen) char *dst, const char *src, size_t maxlen);\n```\n\nThis notes that `dst` is a null-terminated C string, should be `maxlen`\nbytes in size, and is both read from and written to by the function. The\ncompiler or other analysis tools can warn when this doesn't appear to be\nthe case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 824,
          "declPos": 842,
          "end": 843,
          "name": "SDL_INOUT_Z_CAP",
          "kind": "def",
          "parameters": [
            "x"
          ]
        },
        "SDL_OUT_Z_CAP": {
          "doc": "Macro that annotates function params with output string buffer size.\n\nIf we were to annotate `snprintf`:\n\n```c\nint snprintf(SDL_OUT_Z_CAP(maxlen) char *text, size_t maxlen, const char *fmt, ...);\n```\n\nThis notes that `text` is a null-terminated C string, should be `maxlen`\nbytes in size, and is only written to by the function. The compiler or\nother analysis tools can warn when this doesn't appear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 844,
          "declPos": 861,
          "end": 862,
          "name": "SDL_OUT_Z_CAP",
          "kind": "def",
          "parameters": [
            "x"
          ]
        },
        "SDL_OUT_CAP": {
          "doc": "Macro that annotates function params with output buffer size.\n\nIf we were to annotate `wcsncpy`:\n\n```c\nchar *wcscpy(SDL_OUT_CAP(bufsize) wchar_t *dst, const wchar_t *src, size_t bufsize);\n```\n\nThis notes that `dst` should have a capacity of `bufsize` wchar_t in size,\nand is only written to by the function. The compiler or other analysis\ntools can warn when this doesn't appear to be the case.\n\nThis operates on counts of objects, not bytes. Use SDL_OUT_BYTECAP for\nbytes.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 863,
          "declPos": 883,
          "end": 884,
          "name": "SDL_OUT_CAP",
          "kind": "def",
          "parameters": [
            "x"
          ]
        },
        "SDL_OUT_BYTECAP": {
          "doc": "Macro that annotates function params with output buffer size.\n\nIf we were to annotate `memcpy`:\n\n```c\nvoid *memcpy(SDL_OUT_BYTECAP(bufsize) void *dst, const void *src, size_t bufsize);\n```\n\nThis notes that `dst` should have a capacity of `bufsize` bytes in size,\nand is only written to by the function. The compiler or other analysis\ntools can warn when this doesn't appear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 885,
          "declPos": 902,
          "end": 903,
          "name": "SDL_OUT_BYTECAP",
          "kind": "def",
          "parameters": [
            "x"
          ]
        },
        "SDL_OUT_Z_BYTECAP": {
          "doc": "Macro that annotates function params with output buffer string size.\n\nIf we were to annotate `strcpy`:\n\n```c\nchar *strcpy(SDL_OUT_Z_BYTECAP(bufsize) char *dst, const char *src, size_t bufsize);\n```\n\nThis notes that `dst` should have a capacity of `bufsize` bytes in size,\nand a zero-terminated string is written to it by the function. The compiler\nor other analysis tools can warn when this doesn't appear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 904,
          "declPos": 921,
          "end": 922,
          "name": "SDL_OUT_Z_BYTECAP",
          "kind": "def",
          "parameters": [
            "x"
          ]
        },
        "SDL_PRINTF_FORMAT_STRING": {
          "doc": "Macro that annotates function params as printf-style format strings.\n\nIf we were to annotate `fprintf`:\n\n```c\nint fprintf(FILE *f, SDL_PRINTF_FORMAT_STRING const char *fmt, ...);\n```\n\nThis notes that `fmt` should be a printf-style format string. The compiler\nor other analysis tools can warn when this doesn't appear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 923,
          "declPos": 939,
          "end": 940,
          "name": "SDL_PRINTF_FORMAT_STRING",
          "kind": "def"
        },
        "SDL_SCANF_FORMAT_STRING": {
          "doc": "Macro that annotates function params as scanf-style format strings.\n\nIf we were to annotate `fscanf`:\n\n```c\nint fscanf(FILE *f, SDL_SCANF_FORMAT_STRING const char *fmt, ...);\n```\n\nThis notes that `fmt` should be a scanf-style format string. The compiler\nor other analysis tools can warn when this doesn't appear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 941,
          "declPos": 957,
          "end": 958,
          "name": "SDL_SCANF_FORMAT_STRING",
          "kind": "def"
        },
        "SDL_PRINTF_VARARG_FUNC": {
          "doc": "Macro that annotates a vararg function that operates like printf.\n\nIf we were to annotate `fprintf`:\n\n```c\nint fprintf(FILE *f, const char *fmt, ...) SDL_PRINTF_VARARG_FUNC(2);\n```\n\nThis notes that the second parameter should be a printf-style format\nstring, followed by `...`. The compiler or other analysis tools can warn\nwhen this doesn't appear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\nThis can (and should) be used with SDL_PRINTF_FORMAT_STRING as well, which\nbetween them will cover at least Visual Studio, GCC, and Clang.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 959,
          "declPos": 979,
          "end": 980,
          "name": "SDL_PRINTF_VARARG_FUNC",
          "kind": "def",
          "parameters": [
            "fmtargnumber"
          ]
        },
        "SDL_PRINTF_VARARG_FUNCV": {
          "doc": "Macro that annotates a va_list function that operates like printf.\n\nIf we were to annotate `vfprintf`:\n\n```c\nint vfprintf(FILE *f, const char *fmt, va_list ap) SDL_PRINTF_VARARG_FUNCV(2);\n```\n\nThis notes that the second parameter should be a printf-style format\nstring, followed by a va_list. The compiler or other analysis tools can\nwarn when this doesn't appear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\nThis can (and should) be used with SDL_PRINTF_FORMAT_STRING as well, which\nbetween them will cover at least Visual Studio, GCC, and Clang.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 981,
          "declPos": 1001,
          "end": 1002,
          "name": "SDL_PRINTF_VARARG_FUNCV",
          "kind": "def",
          "parameters": [
            "fmtargnumber"
          ]
        },
        "SDL_SCANF_VARARG_FUNC": {
          "doc": "Macro that annotates a vararg function that operates like scanf.\n\nIf we were to annotate `fscanf`:\n\n```c\nint fscanf(FILE *f, const char *fmt, ...) SDL_PRINTF_VARARG_FUNCV(2);\n```\n\nThis notes that the second parameter should be a scanf-style format string,\nfollowed by `...`. The compiler or other analysis tools can warn when this\ndoesn't appear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\nThis can (and should) be used with SDL_SCANF_FORMAT_STRING as well, which\nbetween them will cover at least Visual Studio, GCC, and Clang.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 1003,
          "declPos": 1023,
          "end": 1024,
          "name": "SDL_SCANF_VARARG_FUNC",
          "kind": "def",
          "parameters": [
            "fmtargnumber"
          ]
        },
        "SDL_SCANF_VARARG_FUNCV": {
          "doc": "Macro that annotates a va_list function that operates like scanf.\n\nIf we were to annotate `vfscanf`:\n\n```c\nint vfscanf(FILE *f, const char *fmt, va_list ap) SDL_PRINTF_VARARG_FUNCV(2);\n```\n\nThis notes that the second parameter should be a scanf-style format string,\nfollowed by a va_list. The compiler or other analysis tools can warn when\nthis doesn't appear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\nThis can (and should) be used with SDL_SCANF_FORMAT_STRING as well, which\nbetween them will cover at least Visual Studio, GCC, and Clang.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 1025,
          "declPos": 1045,
          "end": 1046,
          "name": "SDL_SCANF_VARARG_FUNCV",
          "kind": "def",
          "parameters": [
            "fmtargnumber"
          ]
        },
        "SDL_WPRINTF_VARARG_FUNC": {
          "doc": "Macro that annotates a vararg function that operates like wprintf.\n\nIf we were to annotate `fwprintf`:\n\n```c\nint fwprintf(FILE *f, const wchar_t *fmt, ...) SDL_WPRINTF_VARARG_FUNC(2);\n```\n\nThis notes that the second parameter should be a wprintf-style format wide\nstring, followed by `...`. The compiler or other analysis tools can warn\nwhen this doesn't appear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\nThis can (and should) be used with SDL_PRINTF_FORMAT_STRING as well, which\nbetween them will cover at least Visual Studio, GCC, and Clang.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 1047,
          "declPos": 1067,
          "end": 1068,
          "name": "SDL_WPRINTF_VARARG_FUNC",
          "kind": "def",
          "parameters": [
            "fmtargnumber"
          ]
        },
        "SDL_WPRINTF_VARARG_FUNCV": {
          "doc": "Macro that annotates a va_list function that operates like wprintf.\n\nIf we were to annotate `vfwprintf`:\n\n```c\nint vfwprintf(FILE *f, const wchar_t *fmt, va_list ap) SDL_WPRINTF_VARARG_FUNC(2);\n```\n\nThis notes that the second parameter should be a wprintf-style format wide\nstring, followed by a va_list. The compiler or other analysis tools can\nwarn when this doesn't appear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\nThis can (and should) be used with SDL_PRINTF_FORMAT_STRING as well, which\nbetween them will cover at least Visual Studio, GCC, and Clang.\n\n\\since This macro is available since SDL 3.2.0.",
          "begin": 1069,
          "declPos": 1089,
          "end": 1090,
          "name": "SDL_WPRINTF_VARARG_FUNCV",
          "kind": "def",
          "parameters": [
            "fmtargnumber"
          ]
        },
        "SDL_alignment_test": {
          "doc": "",
          "begin": 1161,
          "declPos": 1161,
          "end": 1166,
          "name": "SDL_alignment_test",
          "kind": "struct",
          "parameters": [
            {
              "name": "a",
              "type": "Uint8"
            },
            {
              "name": "*b",
              "type": "void"
            }
          ]
        },
        "SDL_DUMMY_ENUM": {
          "doc": "",
          "begin": 1181,
          "declPos": 1181,
          "end": 1185,
          "name": "SDL_DUMMY_ENUM",
          "kind": "enum",
          "parameters": [
            "DUMMY_ENUM_VALUE"
          ]
        },
        "SDL_INIT_INTERFACE": {
          "doc": "A macro to initialize an SDL interface.\n\nThis macro will initialize an SDL interface structure and should be called\nbefore you fill out the fields with your implementation.\n\nYou can use it like this:\n\n```c\nSDL_IOStreamInterface iface;\n\nSDL_INIT_INTERFACE(&iface);\n\n// Fill in the interface function pointers with your implementation\niface.seek = ...\n\nstream = SDL_OpenIO(&iface, NULL);\n```\n\nIf you are using designated initializers, you can use the size of the\ninterface as the version, e.g.\n\n```c\nSDL_IOStreamInterface iface = {\n    .version = sizeof(iface),\n    .seek = ...\n};\nstream = SDL_OpenIO(&iface, NULL);\n```\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_IOStreamInterface\n\\sa SDL_StorageInterface\n\\sa SDL_VirtualJoystickDesc",
          "begin": 1197,
          "declPos": 1235,
          "end": 1240,
          "name": "SDL_INIT_INTERFACE",
          "kind": "def",
          "parameters": [
            "iface"
          ]
        },
        "SDL_stack_alloc": {
          "doc": "Allocate memory on the stack (maybe).\n\nIf SDL knows how to access alloca() on the current platform, it will use it\nto stack-allocate memory here. If it doesn't, it will use SDL_malloc() to\nheap-allocate memory.\n\nSince this might not be stack memory at all, it's important that you check\nthe returned pointer for NULL, and that you call SDL_stack_free on the\nmemory when done with it. Since this might be stack memory, it's important\nthat you don't allocate large amounts of it, or allocate in a loop without\nreturning from the function, so the stack doesn't overflow.\n\n\\param type the datatype of the memory to allocate.\n\\param count the number of `type` objects to allocate.\n\\returns newly-allocated memory, or NULL on failure.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_stack_free",
          "begin": 1244,
          "declPos": 1267,
          "end": 1268,
          "name": "SDL_stack_alloc",
          "kind": "def",
          "parameters": [
            "type",
            "count"
          ]
        },
        "SDL_stack_free": {
          "doc": "Free memory previously allocated with SDL_stack_alloc.\n\nIf SDL used alloca() to allocate this memory, this macro does nothing and\nthe allocated memory will be automatically released when the function that\ncalled SDL_stack_alloc() returns. If SDL used SDL_malloc(), it will\nSDL_free the memory immediately.\n\n\\param data the pointer, from SDL_stack_alloc(), to free.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_stack_alloc",
          "begin": 1269,
          "declPos": 1285,
          "end": 1286,
          "name": "SDL_stack_free",
          "kind": "def",
          "parameters": [
            "data"
          ]
        },
        "SDL_malloc": {
          "doc": "Allocate uninitialized memory.\n\nThe allocated memory returned by this function must be freed with\nSDL_free().\n\nIf `size` is 0, it will be set to 1.\n\nIf you want to allocate memory aligned to a specific alignment, consider\nusing SDL_aligned_alloc().\n\n\\param size the size to allocate.\n\\returns a pointer to the allocated memory, or NULL if allocation failed.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_free\n\\sa SDL_calloc\n\\sa SDL_realloc\n\\sa SDL_aligned_alloc",
          "begin": 1294,
          "declPos": 1317,
          "end": 1318,
          "name": "SDL_malloc",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "size",
              "type": "size_t"
            }
          ]
        },
        "SDL_calloc": {
          "doc": "Allocate a zero-initialized array.\n\nThe memory returned by this function must be freed with SDL_free().\n\nIf either of `nmemb` or `size` is 0, they will both be set to 1.\n\n\\param nmemb the number of elements in the array.\n\\param size the size of each element of the array.\n\\returns a pointer to the allocated array, or NULL if allocation failed.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_free\n\\sa SDL_malloc\n\\sa SDL_realloc",
          "begin": 1319,
          "declPos": 1338,
          "end": 1339,
          "name": "SDL_calloc",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "nmemb",
              "type": "size_t"
            },
            {
              "name": "size",
              "type": "size_t"
            }
          ]
        },
        "SDL_realloc": {
          "doc": "Change the size of allocated memory.\n\nThe memory returned by this function must be freed with SDL_free().\n\nIf `size` is 0, it will be set to 1. Note that this is unlike some other C\nruntime `realloc` implementations, which may treat `realloc(mem, 0)` the\nsame way as `free(mem)`.\n\nIf `mem` is NULL, the behavior of this function is equivalent to\nSDL_malloc(). Otherwise, the function can have one of three possible\noutcomes:\n\n- If it returns the same pointer as `mem`, it means that `mem` was resized\n  in place without freeing.\n- If it returns a different non-NULL pointer, it means that `mem` was freed\n  and cannot be dereferenced anymore.\n- If it returns NULL (indicating failure), then `mem` will remain valid and\n  must still be freed with SDL_free().\n\n\\param mem a pointer to allocated memory to reallocate, or NULL.\n\\param size the new size of the memory.\n\\returns a pointer to the newly allocated memory, or NULL if allocation\n         failed.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_free\n\\sa SDL_malloc\n\\sa SDL_calloc",
          "begin": 1340,
          "declPos": 1373,
          "end": 1374,
          "name": "SDL_realloc",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "*mem",
              "type": "void"
            },
            {
              "name": "size",
              "type": "size_t"
            }
          ]
        },
        "SDL_free": {
          "doc": "Free allocated memory.\n\nThe pointer is no longer valid after this call and cannot be dereferenced\nanymore.\n\nIf `mem` is NULL, this function does nothing.\n\n\\param mem a pointer to allocated memory, or NULL.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_malloc\n\\sa SDL_calloc\n\\sa SDL_realloc",
          "begin": 1375,
          "declPos": 1393,
          "end": 1394,
          "name": "SDL_free",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "*mem",
              "type": "void"
            }
          ]
        },
        "SDL_malloc_func": {
          "doc": "A callback used to implement SDL_malloc().\n\nSDL will always ensure that the passed `size` is greater than 0.\n\n\\param size the size to allocate.\n\\returns a pointer to the allocated memory, or NULL if allocation failed.\n\n\\threadsafety It should be safe to call this callback from any thread.\n\n\\since This datatype is available since SDL 3.2.0.\n\n\\sa SDL_malloc\n\\sa SDL_GetOriginalMemoryFunctions\n\\sa SDL_GetMemoryFunctions\n\\sa SDL_SetMemoryFunctions",
          "begin": 1395,
          "declPos": 1412,
          "end": 1413,
          "name": "SDL_malloc_func",
          "kind": "callback",
          "type": "void *",
          "parameters": [
            {
              "name": "size",
              "type": "size_t"
            }
          ]
        },
        "SDL_calloc_func": {
          "doc": "A callback used to implement SDL_calloc().\n\nSDL will always ensure that the passed `nmemb` and `size` are both greater\nthan 0.\n\n\\param nmemb the number of elements in the array.\n\\param size the size of each element of the array.\n\\returns a pointer to the allocated array, or NULL if allocation failed.\n\n\\threadsafety It should be safe to call this callback from any thread.\n\n\\since This datatype is available since SDL 3.2.0.\n\n\\sa SDL_calloc\n\\sa SDL_GetOriginalMemoryFunctions\n\\sa SDL_GetMemoryFunctions\n\\sa SDL_SetMemoryFunctions",
          "begin": 1414,
          "declPos": 1433,
          "end": 1434,
          "name": "SDL_calloc_func",
          "kind": "callback",
          "type": "void *",
          "parameters": [
            {
              "name": "nmemb",
              "type": "size_t"
            },
            {
              "name": "size",
              "type": "size_t"
            }
          ]
        },
        "SDL_realloc_func": {
          "doc": "A callback used to implement SDL_realloc().\n\nSDL will always ensure that the passed `size` is greater than 0.\n\n\\param mem a pointer to allocated memory to reallocate, or NULL.\n\\param size the new size of the memory.\n\\returns a pointer to the newly allocated memory, or NULL if allocation\n         failed.\n\n\\threadsafety It should be safe to call this callback from any thread.\n\n\\since This datatype is available since SDL 3.2.0.\n\n\\sa SDL_realloc\n\\sa SDL_GetOriginalMemoryFunctions\n\\sa SDL_GetMemoryFunctions\n\\sa SDL_SetMemoryFunctions",
          "begin": 1435,
          "declPos": 1454,
          "end": 1455,
          "name": "SDL_realloc_func",
          "kind": "callback",
          "type": "void *",
          "parameters": [
            {
              "name": "*mem",
              "type": "void"
            },
            {
              "name": "size",
              "type": "size_t"
            }
          ]
        },
        "SDL_free_func": {
          "doc": "A callback used to implement SDL_free().\n\nSDL will always ensure that the passed `mem` is a non-NULL pointer.\n\n\\param mem a pointer to allocated memory.\n\n\\threadsafety It should be safe to call this callback from any thread.\n\n\\since This datatype is available since SDL 3.2.0.\n\n\\sa SDL_free\n\\sa SDL_GetOriginalMemoryFunctions\n\\sa SDL_GetMemoryFunctions\n\\sa SDL_SetMemoryFunctions",
          "begin": 1456,
          "declPos": 1472,
          "end": 1473,
          "name": "SDL_free_func",
          "kind": "callback",
          "type": "void",
          "parameters": [
            {
              "name": "*mem",
              "type": "void"
            }
          ]
        },
        "SDL_GetOriginalMemoryFunctions": {
          "doc": "Get the original set of SDL memory functions.\n\nThis is what SDL_malloc and friends will use by default, if there has been\nno call to SDL_SetMemoryFunctions. This is not necessarily using the C\nruntime's `malloc` functions behind the scenes! Different platforms and\nbuild configurations might do any number of unexpected things.\n\n\\param malloc_func filled with malloc function.\n\\param calloc_func filled with calloc function.\n\\param realloc_func filled with realloc function.\n\\param free_func filled with free function.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "begin": 1474,
          "declPos": 1491,
          "end": 6039,
          "name": "SDL_GetOriginalMemoryFunctions",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "*malloc_func",
              "type": "SDL_malloc_func"
            },
            {
              "name": "*calloc_func",
              "type": "SDL_calloc_func"
            },
            {
              "name": "*realloc_func",
              "type": "SDL_realloc_func"
            },
            ");"
          ]
        },
        "SDL_size_mul_check_overflow_builtin": {
          "doc": "",
          "begin": 6045,
          "declPos": 6045,
          "end": 6049,
          "name": "SDL_size_mul_check_overflow_builtin",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "a",
              "type": "size_t"
            },
            {
              "name": "b",
              "type": "size_t"
            },
            {
              "name": "*ret",
              "type": "size_t"
            }
          ]
        },
        "SDL_size_mul_check_overflow": {
          "doc": "",
          "begin": 6049,
          "declPos": 6049,
          "end": 6050,
          "name": "SDL_size_mul_check_overflow",
          "kind": "def",
          "parameters": [
            "a",
            "b",
            "ret"
          ]
        },
        "SDL_size_add_check_overflow": [
          {
            "doc": "Add two integers, checking for overflow.\n\nIf `a + b` would overflow, return false.\n\nOtherwise store `a + b` via ret and return true.\n\n\\param a the first addend.\n\\param b the second addend.\n\\param ret on non-overflow output, stores the addition result, may not be\n           NULL.\n\\returns false on overflow, true if result is added without overflow.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
            "begin": 6053,
            "declPos": 6070,
            "end": 6078,
            "name": "SDL_size_add_check_overflow",
            "kind": "function",
            "type": "bool",
            "parameters": [
              {
                "name": "a",
                "type": "size_t"
              },
              {
                "name": "b",
                "type": "size_t"
              },
              {
                "name": "*ret",
                "type": "size_t"
              }
            ]
          },
          {
            "doc": "",
            "begin": 6087,
            "declPos": 6087,
            "end": 6088,
            "name": "SDL_size_add_check_overflow",
            "kind": "def",
            "parameters": [
              "a",
              "b",
              "ret"
            ]
          }
        ],
        "SDL_size_add_check_overflow_builtin": {
          "doc": "",
          "begin": 6083,
          "declPos": 6083,
          "end": 6087,
          "name": "SDL_size_add_check_overflow_builtin",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "a",
              "type": "size_t"
            },
            {
              "name": "b",
              "type": "size_t"
            },
            {
              "name": "*ret",
              "type": "size_t"
            }
          ]
        },
        "SDL_FunctionPointer": {
          "doc": "A generic function pointer.\n\nIn theory, generic function pointers should use this, instead of `void *`,\nsince some platforms could treat code addresses differently than data\naddresses. Although in current times no popular platforms make this\ndistinction, it is more correct and portable to use the correct type for a\ngeneric pointer.\n\nIf for some reason you need to force this typedef to be an actual `void *`,\nperhaps to work around a compiler or existing code, you can define\n`SDL_FUNCTION_POINTER_IS_VOID_POINTER` before including any SDL headers.\n\n\\since This datatype is available since SDL 3.2.0.",
          "begin": 6094,
          "declPos": 6109,
          "end": 6110,
          "name": "SDL_FunctionPointer",
          "kind": "callback",
          "type": "void",
          "parameters": []
        }
      }
    }
  }
}