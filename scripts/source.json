{
  "files": {
    "SDL_stdinc.h": {
      "name": "SDL_stdinc.h",
      "doc": "# CategoryStdinc\n\nSDL provides its own implementation of some of the most important C runtime\nfunctions.\n\nUsing these functions allows an app to have access to common C\nfunctionality without depending on a specific C runtime (or a C runtime at\nall). More importantly, the SDL implementations work identically across\nplatforms, so apps can avoid surprises like snprintf() behaving differently\nbetween Windows and Linux builds, or itoa() only existing on some\nplatforms.\n\nFor many of the most common functions, like SDL_memcpy, SDL might just call\nthrough to the usual C runtime behind the scenes, if it makes sense to do\nso (if it's faster and always available/reliable on a given platform),\nreducing library size and offering the most optimized option.\n\nSDL also offers other C-runtime-adjacent functionality in this header that\neither isn't, strictly speaking, part of any C runtime standards, like\nSDL_crc32() and SDL_reinterpret_cast, etc. It also offers a few better\noptions, like SDL_strlcpy(), which functions as a safer form of strcpy().",
      "entries": {
        "SDL_INCLUDE_STDBOOL_H": {
          "doc": "",
          "name": "SDL_INCLUDE_STDBOOL_H",
          "kind": "def"
        },
        "bool": {
          "doc": "",
          "name": "bool",
          "kind": "def"
        },
        "false": {
          "doc": "",
          "name": "false",
          "kind": "def"
        },
        "true": {
          "doc": "",
          "name": "true",
          "kind": "def"
        },
        "__bool_true_false_are_defined": {
          "doc": "",
          "name": "__bool_true_false_are_defined",
          "kind": "def"
        },
        "SDL_NOLONGLONG": {
          "doc": "Don't let SDL use \"long long\" C types.\n\nSDL will define this if it believes the compiler doesn't understand the\n\"long long\" syntax for C datatypes. This can happen on older compilers.\n\nIf _your_ compiler doesn't support \"long long\" but SDL doesn't know it, it\nis safe to define this yourself to build against the SDL headers.\n\nIf this is defined, it will remove access to some C runtime support\nfunctions, like SDL_ulltoa and SDL_strtoll that refer to this datatype\nexplicitly. The rest of SDL will still be available.\n\nSDL's own source code cannot be built with a compiler that has this\ndefined, for various technical reasons.",
          "name": "SDL_NOLONGLONG",
          "kind": "def"
        },
        "SDL_SIZE_MAX": {
          "doc": "The largest value that a `size_t` can hold for the target platform.\n\n`size_t` is generally the same size as a pointer in modern times, but this\ncan get weird on very old and very esoteric machines. For example, on a\n16-bit Intel 286, you might have a 32-bit \"far\" pointer (16-bit segment\nplus 16-bit offset), but `size_t` is 16 bits, because it can only deal with\nthe offset into an individual segment.\n\nIn modern times, it's generally expected to cover an entire linear address\nspace. But be careful!\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_SIZE_MAX",
          "kind": "def"
        },
        "SDL_COMPILE_TIME_ASSERT": {
          "doc": "A compile-time assertion.\n\nThis can check constant values _known to the compiler at build time_ for\ncorrectness, and end the compile with the error if they fail.\n\nOften times these are used to verify basic truths, like the size of a\ndatatype is what is expected:\n\n```c\nSDL_COMPILE_TIME_ASSERT(uint32_size, sizeof(Uint32) == 4);\n```\n\nThe `name` parameter must be a valid C symbol, and must be unique across\nall compile-time asserts in the same compilation unit (one run of the\ncompiler), or the build might fail with cryptic errors on some targets.\nThis is used with a C language trick that works on older compilers that\ndon't support better assertion techniques.\n\nIf you need an assertion that operates at runtime, on variable data, you\nshould try SDL_assert instead.\n\n\\param name a unique identifier for this assertion.\n\\param x the value to test. Must be a boolean value.\n\n\\threadsafety This macro doesn't generate any code to run.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_assert",
          "name": "SDL_COMPILE_TIME_ASSERT",
          "kind": "def",
          "parameters": [
            "name",
            "x"
          ]
        },
        "SDL_arraysize": {
          "doc": "The number of elements in a static array.\n\nThis will compile but return incorrect results for a pointer to an array;\nit has to be an array the compiler knows the size of.\n\nThis macro looks like it double-evaluates the argument, but it does so\ninside of `sizeof`, so there are no side-effects here, as expressions do\nnot actually run any code in these cases.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_arraysize",
          "kind": "def",
          "parameters": [
            "array"
          ]
        },
        "SDL_STRINGIFY_ARG": {
          "doc": "Macro useful for building other macros with strings in them.\n\nFor example:\n\n```c\n#define LOG_ERROR(X) OutputDebugString(SDL_STRINGIFY_ARG(__FUNCTION__) \": \" X \"\\n\")`\n```\n\n\\param arg the text to turn into a string literal.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_STRINGIFY_ARG",
          "kind": "def",
          "parameters": [
            "arg"
          ]
        },
        "SDL_reinterpret_cast": {
          "doc": "Handle a Reinterpret Cast properly whether using C or C++.\n\nIf compiled as C++, this macro offers a proper C++ reinterpret_cast<>.\n\nIf compiled as C, this macro does a normal C-style cast.\n\nThis is helpful to avoid compiler warnings in C++.\n\n\\param type the type to cast the expression to.\n\\param expression the expression to cast to a different type.\n\\returns `expression`, cast to `type`.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_static_cast\n\\sa SDL_const_cast",
          "name": "SDL_reinterpret_cast",
          "kind": "def",
          "parameters": [
            "type",
            "expression"
          ]
        },
        "SDL_static_cast": {
          "doc": "Handle a Static Cast properly whether using C or C++.\n\nIf compiled as C++, this macro offers a proper C++ static_cast<>.\n\nIf compiled as C, this macro does a normal C-style cast.\n\nThis is helpful to avoid compiler warnings in C++.\n\n\\param type the type to cast the expression to.\n\\param expression the expression to cast to a different type.\n\\returns `expression`, cast to `type`.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_reinterpret_cast\n\\sa SDL_const_cast",
          "name": "SDL_static_cast",
          "kind": "def",
          "parameters": [
            "type",
            "expression"
          ]
        },
        "SDL_const_cast": {
          "doc": "Handle a Const Cast properly whether using C or C++.\n\nIf compiled as C++, this macro offers a proper C++ const_cast<>.\n\nIf compiled as C, this macro does a normal C-style cast.\n\nThis is helpful to avoid compiler warnings in C++.\n\n\\param type the type to cast the expression to.\n\\param expression the expression to cast to a different type.\n\\returns `expression`, cast to `type`.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_reinterpret_cast\n\\sa SDL_static_cast",
          "name": "SDL_const_cast",
          "kind": "def",
          "parameters": [
            "type",
            "expression"
          ]
        },
        "SDL_FOURCC": {
          "doc": "Define a four character code as a Uint32.\n\n\\param A the first ASCII character.\n\\param B the second ASCII character.\n\\param C the third ASCII character.\n\\param D the fourth ASCII character.\n\\returns the four characters converted into a Uint32, one character\n         per-byte.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_FOURCC",
          "kind": "def",
          "parameters": [
            "A",
            "B",
            "C",
            "D"
          ]
        },
        "SDL_SINT64_C": {
          "doc": "Append the 64 bit integer suffix to a signed integer literal.\n\nThis helps compilers that might believe a integer literal larger than\n0xFFFFFFFF is overflowing a 32-bit value. Use `SDL_SINT64_C(0xFFFFFFFF1)`\ninstead of `0xFFFFFFFF1` by itself.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_UINT64_C",
          "name": "SDL_SINT64_C",
          "kind": "def",
          "parameters": [
            "c"
          ]
        },
        "SDL_UINT64_C": {
          "doc": "Append the 64 bit integer suffix to an unsigned integer literal.\n\nThis helps compilers that might believe a integer literal larger than\n0xFFFFFFFF is overflowing a 32-bit value. Use `SDL_UINT64_C(0xFFFFFFFF1)`\ninstead of `0xFFFFFFFF1` by itself.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_SINT64_C",
          "name": "SDL_UINT64_C",
          "kind": "def",
          "parameters": [
            "c"
          ]
        },
        "Sint8": {
          "doc": "A signed 8-bit integer type.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "Sint8",
          "kind": "alias",
          "type": "int8_t"
        },
        "SDL_MAX_SINT8": {
          "doc": "",
          "name": "SDL_MAX_SINT8",
          "kind": "def"
        },
        "SDL_MIN_SINT8": {
          "doc": "",
          "name": "SDL_MIN_SINT8",
          "kind": "def"
        },
        "Uint8": {
          "doc": "An unsigned 8-bit integer type.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "Uint8",
          "kind": "alias",
          "type": "uint8_t"
        },
        "SDL_MAX_UINT8": {
          "doc": "",
          "name": "SDL_MAX_UINT8",
          "kind": "def"
        },
        "SDL_MIN_UINT8": {
          "doc": "",
          "name": "SDL_MIN_UINT8",
          "kind": "def"
        },
        "Sint16": {
          "doc": "A signed 16-bit integer type.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "Sint16",
          "kind": "alias",
          "type": "int16_t"
        },
        "SDL_MAX_SINT16": {
          "doc": "",
          "name": "SDL_MAX_SINT16",
          "kind": "def"
        },
        "SDL_MIN_SINT16": {
          "doc": "",
          "name": "SDL_MIN_SINT16",
          "kind": "def"
        },
        "Uint16": {
          "doc": "An unsigned 16-bit integer type.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "Uint16",
          "kind": "alias",
          "type": "uint16_t"
        },
        "SDL_MAX_UINT16": {
          "doc": "",
          "name": "SDL_MAX_UINT16",
          "kind": "def"
        },
        "SDL_MIN_UINT16": {
          "doc": "",
          "name": "SDL_MIN_UINT16",
          "kind": "def"
        },
        "Sint32": {
          "doc": "A signed 32-bit integer type.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "Sint32",
          "kind": "alias",
          "type": "int32_t"
        },
        "SDL_MAX_SINT32": {
          "doc": "",
          "name": "SDL_MAX_SINT32",
          "kind": "def"
        },
        "SDL_MIN_SINT32": {
          "doc": "",
          "name": "SDL_MIN_SINT32",
          "kind": "def"
        },
        "Uint32": {
          "doc": "An unsigned 32-bit integer type.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "Uint32",
          "kind": "alias",
          "type": "uint32_t"
        },
        "SDL_MAX_UINT32": {
          "doc": "",
          "name": "SDL_MAX_UINT32",
          "kind": "def"
        },
        "SDL_MIN_UINT32": {
          "doc": "",
          "name": "SDL_MIN_UINT32",
          "kind": "def"
        },
        "Sint64": {
          "doc": "A signed 64-bit integer type.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_SINT64_C",
          "name": "Sint64",
          "kind": "alias",
          "type": "int64_t"
        },
        "SDL_MAX_SINT64": {
          "doc": "",
          "name": "SDL_MAX_SINT64",
          "kind": "def"
        },
        "SDL_MIN_SINT64": {
          "doc": "",
          "name": "SDL_MIN_SINT64",
          "kind": "def"
        },
        "Uint64": {
          "doc": "An unsigned 64-bit integer type.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_UINT64_C",
          "name": "Uint64",
          "kind": "alias",
          "type": "uint64_t"
        },
        "SDL_MAX_UINT64": {
          "doc": "",
          "name": "SDL_MAX_UINT64",
          "kind": "def"
        },
        "SDL_MIN_UINT64": {
          "doc": "",
          "name": "SDL_MIN_UINT64",
          "kind": "def"
        },
        "SDL_Time": {
          "doc": "SDL times are signed, 64-bit integers representing nanoseconds since the\nUnix epoch (Jan 1, 1970).\n\nThey can be converted between POSIX time_t values with SDL_NS_TO_SECONDS()\nand SDL_SECONDS_TO_NS(), and between Windows FILETIME values with\nSDL_TimeToWindows() and SDL_TimeFromWindows().\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_MAX_SINT64\n\\sa SDL_MIN_SINT64",
          "name": "SDL_Time",
          "kind": "alias",
          "type": "Sint64"
        },
        "SDL_MAX_TIME": {
          "doc": "",
          "name": "SDL_MAX_TIME",
          "kind": "def"
        },
        "SDL_MIN_TIME": {
          "doc": "",
          "name": "SDL_MIN_TIME",
          "kind": "def"
        },
        "SDL_FLT_EPSILON": {
          "doc": "Epsilon constant, used for comparing floating-point numbers.\n\nEquals by default to platform-defined `FLT_EPSILON`, or\n`1.1920928955078125e-07F` if that's not available.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_FLT_EPSILON",
          "kind": "def"
        },
        "SDL_PRIs64": {
          "doc": "A printf-formatting string for an Sint64 value.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRIs64 \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_PRIs64",
          "kind": "def"
        },
        "SDL_PRIu64": {
          "doc": "A printf-formatting string for a Uint64 value.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRIu64 \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_PRIu64",
          "kind": "def"
        },
        "SDL_PRIx64": {
          "doc": "A printf-formatting string for a Uint64 value as lower-case hexadecimal.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRIx64 \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_PRIx64",
          "kind": "def"
        },
        "SDL_PRIX64": {
          "doc": "A printf-formatting string for a Uint64 value as upper-case hexadecimal.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRIX64 \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_PRIX64",
          "kind": "def"
        },
        "SDL_PRIs32": {
          "doc": "A printf-formatting string for an Sint32 value.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRIs32 \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_PRIs32",
          "kind": "def"
        },
        "SDL_PRIu32": {
          "doc": "A printf-formatting string for a Uint32 value.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRIu32 \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_PRIu32",
          "kind": "def"
        },
        "SDL_PRIx32": {
          "doc": "A printf-formatting string for a Uint32 value as lower-case hexadecimal.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRIx32 \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_PRIx32",
          "kind": "def"
        },
        "SDL_PRIX32": {
          "doc": "A printf-formatting string for a Uint32 value as upper-case hexadecimal.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRIX32 \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_PRIX32",
          "kind": "def"
        },
        "SDL_PRILL_PREFIX": {
          "doc": "A printf-formatting string prefix for a `long long` value.\n\nThis is just the prefix! You probably actually want SDL_PRILLd, SDL_PRILLu,\nSDL_PRILLx, or SDL_PRILLX instead.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRILL_PREFIX \"d bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_PRILL_PREFIX",
          "kind": "def"
        },
        "SDL_PRILLd": {
          "doc": "A printf-formatting string for a `long long` value.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRILLd \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_PRILLd",
          "kind": "def"
        },
        "SDL_PRILLu": {
          "doc": "A printf-formatting string for a `unsigned long long` value.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRILLu \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_PRILLu",
          "kind": "def"
        },
        "SDL_PRILLx": {
          "doc": "A printf-formatting string for an `unsigned long long` value as lower-case\nhexadecimal.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRILLx \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_PRILLx",
          "kind": "def"
        },
        "SDL_PRILLX": {
          "doc": "A printf-formatting string for an `unsigned long long` value as upper-case\nhexadecimal.\n\nUse it like this:\n\n```c\nSDL_Log(\"There are %\" SDL_PRILLX \" bottles of beer on the wall.\", bottles);\n```\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_PRILLX",
          "kind": "def"
        },
        "SDL_IN_BYTECAP": {
          "doc": "Macro that annotates function params with input buffer size.\n\nIf we were to annotate `memcpy`:\n\n```c\nvoid *memcpy(void *dst, SDL_IN_BYTECAP(len) const void *src, size_t len);\n```\n\nThis notes that `src` should be `len` bytes in size and is only read by the\nfunction. The compiler or other analysis tools can warn when this doesn't\nappear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_IN_BYTECAP",
          "kind": "def",
          "parameters": [
            "x"
          ]
        },
        "SDL_INOUT_Z_CAP": {
          "doc": "Macro that annotates function params with input/output string buffer size.\n\nIf we were to annotate `strlcat`:\n\n```c\nsize_t strlcat(SDL_INOUT_Z_CAP(maxlen) char *dst, const char *src, size_t maxlen);\n```\n\nThis notes that `dst` is a null-terminated C string, should be `maxlen`\nbytes in size, and is both read from and written to by the function. The\ncompiler or other analysis tools can warn when this doesn't appear to be\nthe case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_INOUT_Z_CAP",
          "kind": "def",
          "parameters": [
            "x"
          ]
        },
        "SDL_OUT_Z_CAP": {
          "doc": "Macro that annotates function params with output string buffer size.\n\nIf we were to annotate `snprintf`:\n\n```c\nint snprintf(SDL_OUT_Z_CAP(maxlen) char *text, size_t maxlen, const char *fmt, ...);\n```\n\nThis notes that `text` is a null-terminated C string, should be `maxlen`\nbytes in size, and is only written to by the function. The compiler or\nother analysis tools can warn when this doesn't appear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_OUT_Z_CAP",
          "kind": "def",
          "parameters": [
            "x"
          ]
        },
        "SDL_OUT_CAP": {
          "doc": "Macro that annotates function params with output buffer size.\n\nIf we were to annotate `wcsncpy`:\n\n```c\nchar *wcscpy(SDL_OUT_CAP(bufsize) wchar_t *dst, const wchar_t *src, size_t bufsize);\n```\n\nThis notes that `dst` should have a capacity of `bufsize` wchar_t in size,\nand is only written to by the function. The compiler or other analysis\ntools can warn when this doesn't appear to be the case.\n\nThis operates on counts of objects, not bytes. Use SDL_OUT_BYTECAP for\nbytes.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_OUT_CAP",
          "kind": "def",
          "parameters": [
            "x"
          ]
        },
        "SDL_OUT_BYTECAP": {
          "doc": "Macro that annotates function params with output buffer size.\n\nIf we were to annotate `memcpy`:\n\n```c\nvoid *memcpy(SDL_OUT_BYTECAP(bufsize) void *dst, const void *src, size_t bufsize);\n```\n\nThis notes that `dst` should have a capacity of `bufsize` bytes in size,\nand is only written to by the function. The compiler or other analysis\ntools can warn when this doesn't appear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_OUT_BYTECAP",
          "kind": "def",
          "parameters": [
            "x"
          ]
        },
        "SDL_OUT_Z_BYTECAP": {
          "doc": "Macro that annotates function params with output buffer string size.\n\nIf we were to annotate `strcpy`:\n\n```c\nchar *strcpy(SDL_OUT_Z_BYTECAP(bufsize) char *dst, const char *src, size_t bufsize);\n```\n\nThis notes that `dst` should have a capacity of `bufsize` bytes in size,\nand a zero-terminated string is written to it by the function. The compiler\nor other analysis tools can warn when this doesn't appear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_OUT_Z_BYTECAP",
          "kind": "def",
          "parameters": [
            "x"
          ]
        },
        "SDL_PRINTF_FORMAT_STRING": {
          "doc": "Macro that annotates function params as printf-style format strings.\n\nIf we were to annotate `fprintf`:\n\n```c\nint fprintf(FILE *f, SDL_PRINTF_FORMAT_STRING const char *fmt, ...);\n```\n\nThis notes that `fmt` should be a printf-style format string. The compiler\nor other analysis tools can warn when this doesn't appear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_PRINTF_FORMAT_STRING",
          "kind": "def"
        },
        "SDL_SCANF_FORMAT_STRING": {
          "doc": "Macro that annotates function params as scanf-style format strings.\n\nIf we were to annotate `fscanf`:\n\n```c\nint fscanf(FILE *f, SDL_SCANF_FORMAT_STRING const char *fmt, ...);\n```\n\nThis notes that `fmt` should be a scanf-style format string. The compiler\nor other analysis tools can warn when this doesn't appear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_SCANF_FORMAT_STRING",
          "kind": "def"
        },
        "SDL_PRINTF_VARARG_FUNC": {
          "doc": "Macro that annotates a vararg function that operates like printf.\n\nIf we were to annotate `fprintf`:\n\n```c\nint fprintf(FILE *f, const char *fmt, ...) SDL_PRINTF_VARARG_FUNC(2);\n```\n\nThis notes that the second parameter should be a printf-style format\nstring, followed by `...`. The compiler or other analysis tools can warn\nwhen this doesn't appear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\nThis can (and should) be used with SDL_PRINTF_FORMAT_STRING as well, which\nbetween them will cover at least Visual Studio, GCC, and Clang.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_PRINTF_VARARG_FUNC",
          "kind": "def",
          "parameters": [
            "fmtargnumber"
          ]
        },
        "SDL_PRINTF_VARARG_FUNCV": {
          "doc": "Macro that annotates a va_list function that operates like printf.\n\nIf we were to annotate `vfprintf`:\n\n```c\nint vfprintf(FILE *f, const char *fmt, va_list ap) SDL_PRINTF_VARARG_FUNCV(2);\n```\n\nThis notes that the second parameter should be a printf-style format\nstring, followed by a va_list. The compiler or other analysis tools can\nwarn when this doesn't appear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\nThis can (and should) be used with SDL_PRINTF_FORMAT_STRING as well, which\nbetween them will cover at least Visual Studio, GCC, and Clang.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_PRINTF_VARARG_FUNCV",
          "kind": "def",
          "parameters": [
            "fmtargnumber"
          ]
        },
        "SDL_SCANF_VARARG_FUNC": {
          "doc": "Macro that annotates a vararg function that operates like scanf.\n\nIf we were to annotate `fscanf`:\n\n```c\nint fscanf(FILE *f, const char *fmt, ...) SDL_PRINTF_VARARG_FUNCV(2);\n```\n\nThis notes that the second parameter should be a scanf-style format string,\nfollowed by `...`. The compiler or other analysis tools can warn when this\ndoesn't appear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\nThis can (and should) be used with SDL_SCANF_FORMAT_STRING as well, which\nbetween them will cover at least Visual Studio, GCC, and Clang.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_SCANF_VARARG_FUNC",
          "kind": "def",
          "parameters": [
            "fmtargnumber"
          ]
        },
        "SDL_SCANF_VARARG_FUNCV": {
          "doc": "Macro that annotates a va_list function that operates like scanf.\n\nIf we were to annotate `vfscanf`:\n\n```c\nint vfscanf(FILE *f, const char *fmt, va_list ap) SDL_PRINTF_VARARG_FUNCV(2);\n```\n\nThis notes that the second parameter should be a scanf-style format string,\nfollowed by a va_list. The compiler or other analysis tools can warn when\nthis doesn't appear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\nThis can (and should) be used with SDL_SCANF_FORMAT_STRING as well, which\nbetween them will cover at least Visual Studio, GCC, and Clang.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_SCANF_VARARG_FUNCV",
          "kind": "def",
          "parameters": [
            "fmtargnumber"
          ]
        },
        "SDL_WPRINTF_VARARG_FUNC": {
          "doc": "Macro that annotates a vararg function that operates like wprintf.\n\nIf we were to annotate `fwprintf`:\n\n```c\nint fwprintf(FILE *f, const wchar_t *fmt, ...) SDL_WPRINTF_VARARG_FUNC(2);\n```\n\nThis notes that the second parameter should be a wprintf-style format wide\nstring, followed by `...`. The compiler or other analysis tools can warn\nwhen this doesn't appear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\nThis can (and should) be used with SDL_PRINTF_FORMAT_STRING as well, which\nbetween them will cover at least Visual Studio, GCC, and Clang.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_WPRINTF_VARARG_FUNC",
          "kind": "def",
          "parameters": [
            "fmtargnumber"
          ]
        },
        "SDL_WPRINTF_VARARG_FUNCV": {
          "doc": "Macro that annotates a va_list function that operates like wprintf.\n\nIf we were to annotate `vfwprintf`:\n\n```c\nint vfwprintf(FILE *f, const wchar_t *fmt, va_list ap) SDL_WPRINTF_VARARG_FUNC(2);\n```\n\nThis notes that the second parameter should be a wprintf-style format wide\nstring, followed by a va_list. The compiler or other analysis tools can\nwarn when this doesn't appear to be the case.\n\nOn compilers without this annotation mechanism, this is defined to nothing.\n\nThis can (and should) be used with SDL_PRINTF_FORMAT_STRING as well, which\nbetween them will cover at least Visual Studio, GCC, and Clang.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_WPRINTF_VARARG_FUNCV",
          "kind": "def",
          "parameters": [
            "fmtargnumber"
          ]
        },
        "SDL_alignment_test": {
          "doc": "",
          "name": "SDL_alignment_test",
          "kind": "struct",
          "entries": {
            "a": {
              "doc": "",
              "name": "a",
              "kind": "var",
              "type": "Uint8"
            },
            "b": {
              "doc": "",
              "name": "b",
              "kind": "var",
              "type": "void *"
            }
          }
        },
        "SDL_DUMMY_ENUM": {
          "doc": "",
          "name": "SDL_DUMMY_ENUM",
          "kind": "enum"
        },
        "SDL_INIT_INTERFACE": {
          "doc": "A macro to initialize an SDL interface.\n\nThis macro will initialize an SDL interface structure and should be called\nbefore you fill out the fields with your implementation.\n\nYou can use it like this:\n\n```c\nSDL_IOStreamInterface iface;\n\nSDL_INIT_INTERFACE(&iface);\n\n// Fill in the interface function pointers with your implementation\niface.seek = ...\n\nstream = SDL_OpenIO(&iface, NULL);\n```\n\nIf you are using designated initializers, you can use the size of the\ninterface as the version, e.g.\n\n```c\nSDL_IOStreamInterface iface = {\n    .version = sizeof(iface),\n    .seek = ...\n};\nstream = SDL_OpenIO(&iface, NULL);\n```\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_IOStreamInterface\n\\sa SDL_StorageInterface\n\\sa SDL_VirtualJoystickDesc",
          "name": "SDL_INIT_INTERFACE",
          "kind": "def",
          "parameters": [
            "iface"
          ]
        },
        "SDL_stack_alloc": {
          "doc": "Allocate memory on the stack (maybe).\n\nIf SDL knows how to access alloca() on the current platform, it will use it\nto stack-allocate memory here. If it doesn't, it will use SDL_malloc() to\nheap-allocate memory.\n\nSince this might not be stack memory at all, it's important that you check\nthe returned pointer for NULL, and that you call SDL_stack_free on the\nmemory when done with it. Since this might be stack memory, it's important\nthat you don't allocate large amounts of it, or allocate in a loop without\nreturning from the function, so the stack doesn't overflow.\n\n\\param type the datatype of the memory to allocate.\n\\param count the number of `type` objects to allocate.\n\\returns newly-allocated memory, or NULL on failure.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_stack_free",
          "name": "SDL_stack_alloc",
          "kind": "def",
          "parameters": [
            "type",
            "count"
          ]
        },
        "SDL_stack_free": {
          "doc": "Free memory previously allocated with SDL_stack_alloc.\n\nIf SDL used alloca() to allocate this memory, this macro does nothing and\nthe allocated memory will be automatically released when the function that\ncalled SDL_stack_alloc() returns. If SDL used SDL_malloc(), it will\nSDL_free the memory immediately.\n\n\\param data the pointer, from SDL_stack_alloc(), to free.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_stack_alloc",
          "name": "SDL_stack_free",
          "kind": "def",
          "parameters": [
            "data"
          ]
        },
        "SDL_malloc": {
          "doc": "Allocate uninitialized memory.\n\nThe allocated memory returned by this function must be freed with\nSDL_free().\n\nIf `size` is 0, it will be set to 1.\n\nIf you want to allocate memory aligned to a specific alignment, consider\nusing SDL_aligned_alloc().\n\n\\param size the size to allocate.\n\\returns a pointer to the allocated memory, or NULL if allocation failed.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_free\n\\sa SDL_calloc\n\\sa SDL_realloc\n\\sa SDL_aligned_alloc",
          "name": "SDL_malloc",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "size",
              "type": "size_t"
            }
          ]
        },
        "SDL_calloc": {
          "doc": "Allocate a zero-initialized array.\n\nThe memory returned by this function must be freed with SDL_free().\n\nIf either of `nmemb` or `size` is 0, they will both be set to 1.\n\n\\param nmemb the number of elements in the array.\n\\param size the size of each element of the array.\n\\returns a pointer to the allocated array, or NULL if allocation failed.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_free\n\\sa SDL_malloc\n\\sa SDL_realloc",
          "name": "SDL_calloc",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "nmemb",
              "type": "size_t"
            },
            {
              "name": "size",
              "type": "size_t"
            }
          ]
        },
        "SDL_realloc": {
          "doc": "Change the size of allocated memory.\n\nThe memory returned by this function must be freed with SDL_free().\n\nIf `size` is 0, it will be set to 1. Note that this is unlike some other C\nruntime `realloc` implementations, which may treat `realloc(mem, 0)` the\nsame way as `free(mem)`.\n\nIf `mem` is NULL, the behavior of this function is equivalent to\nSDL_malloc(). Otherwise, the function can have one of three possible\noutcomes:\n\n- If it returns the same pointer as `mem`, it means that `mem` was resized\n  in place without freeing.\n- If it returns a different non-NULL pointer, it means that `mem` was freed\n  and cannot be dereferenced anymore.\n- If it returns NULL (indicating failure), then `mem` will remain valid and\n  must still be freed with SDL_free().\n\n\\param mem a pointer to allocated memory to reallocate, or NULL.\n\\param size the new size of the memory.\n\\returns a pointer to the newly allocated memory, or NULL if allocation\n         failed.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_free\n\\sa SDL_malloc\n\\sa SDL_calloc",
          "name": "SDL_realloc",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "mem",
              "type": "void *"
            },
            {
              "name": "size",
              "type": "size_t"
            }
          ]
        },
        "SDL_free": {
          "doc": "Free allocated memory.\n\nThe pointer is no longer valid after this call and cannot be dereferenced\nanymore.\n\nIf `mem` is NULL, this function does nothing.\n\n\\param mem a pointer to allocated memory, or NULL.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_malloc\n\\sa SDL_calloc\n\\sa SDL_realloc",
          "name": "SDL_free",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "mem",
              "type": "void *"
            }
          ]
        },
        "SDL_malloc_func": {
          "doc": "A callback used to implement SDL_malloc().\n\nSDL will always ensure that the passed `size` is greater than 0.\n\n\\param size the size to allocate.\n\\returns a pointer to the allocated memory, or NULL if allocation failed.\n\n\\threadsafety It should be safe to call this callback from any thread.\n\n\\since This datatype is available since SDL 3.2.0.\n\n\\sa SDL_malloc\n\\sa SDL_GetOriginalMemoryFunctions\n\\sa SDL_GetMemoryFunctions\n\\sa SDL_SetMemoryFunctions",
          "name": "SDL_malloc_func",
          "kind": "callback",
          "type": "void *",
          "parameters": [
            {
              "name": "size",
              "type": "size_t"
            }
          ]
        },
        "SDL_calloc_func": {
          "doc": "A callback used to implement SDL_calloc().\n\nSDL will always ensure that the passed `nmemb` and `size` are both greater\nthan 0.\n\n\\param nmemb the number of elements in the array.\n\\param size the size of each element of the array.\n\\returns a pointer to the allocated array, or NULL if allocation failed.\n\n\\threadsafety It should be safe to call this callback from any thread.\n\n\\since This datatype is available since SDL 3.2.0.\n\n\\sa SDL_calloc\n\\sa SDL_GetOriginalMemoryFunctions\n\\sa SDL_GetMemoryFunctions\n\\sa SDL_SetMemoryFunctions",
          "name": "SDL_calloc_func",
          "kind": "callback",
          "type": "void *",
          "parameters": [
            {
              "name": "nmemb",
              "type": "size_t"
            },
            {
              "name": "size",
              "type": "size_t"
            }
          ]
        },
        "SDL_realloc_func": {
          "doc": "A callback used to implement SDL_realloc().\n\nSDL will always ensure that the passed `size` is greater than 0.\n\n\\param mem a pointer to allocated memory to reallocate, or NULL.\n\\param size the new size of the memory.\n\\returns a pointer to the newly allocated memory, or NULL if allocation\n         failed.\n\n\\threadsafety It should be safe to call this callback from any thread.\n\n\\since This datatype is available since SDL 3.2.0.\n\n\\sa SDL_realloc\n\\sa SDL_GetOriginalMemoryFunctions\n\\sa SDL_GetMemoryFunctions\n\\sa SDL_SetMemoryFunctions",
          "name": "SDL_realloc_func",
          "kind": "callback",
          "type": "void *",
          "parameters": [
            {
              "name": "mem",
              "type": "void *"
            },
            {
              "name": "size",
              "type": "size_t"
            }
          ]
        },
        "SDL_free_func": {
          "doc": "A callback used to implement SDL_free().\n\nSDL will always ensure that the passed `mem` is a non-NULL pointer.\n\n\\param mem a pointer to allocated memory.\n\n\\threadsafety It should be safe to call this callback from any thread.\n\n\\since This datatype is available since SDL 3.2.0.\n\n\\sa SDL_free\n\\sa SDL_GetOriginalMemoryFunctions\n\\sa SDL_GetMemoryFunctions\n\\sa SDL_SetMemoryFunctions",
          "name": "SDL_free_func",
          "kind": "callback",
          "type": "void",
          "parameters": [
            {
              "name": "mem",
              "type": "void *"
            }
          ]
        },
        "SDL_GetOriginalMemoryFunctions": {
          "doc": "Get the original set of SDL memory functions.\n\nThis is what SDL_malloc and friends will use by default, if there has been\nno call to SDL_SetMemoryFunctions. This is not necessarily using the C\nruntime's `malloc` functions behind the scenes! Different platforms and\nbuild configurations might do any number of unexpected things.\n\n\\param malloc_func filled with malloc function.\n\\param calloc_func filled with calloc function.\n\\param realloc_func filled with realloc function.\n\\param free_func filled with free function.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_GetOriginalMemoryFunctions",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "malloc_func",
              "type": "SDL_malloc_func *"
            },
            {
              "name": "calloc_func",
              "type": "SDL_calloc_func *"
            },
            {
              "name": "realloc_func",
              "type": "SDL_realloc_func *"
            },
            {
              "name": "free_func",
              "type": "SDL_free_func *"
            }
          ]
        },
        "SDL_GetMemoryFunctions": {
          "doc": "Get the current set of SDL memory functions.\n\n\\param malloc_func filled with malloc function.\n\\param calloc_func filled with calloc function.\n\\param realloc_func filled with realloc function.\n\\param free_func filled with free function.\n\n\\threadsafety This does not hold a lock, so do not call this in the\n              unlikely event of a background thread calling\n              SDL_SetMemoryFunctions simultaneously.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_SetMemoryFunctions\n\\sa SDL_GetOriginalMemoryFunctions",
          "name": "SDL_GetMemoryFunctions",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "malloc_func",
              "type": "SDL_malloc_func *"
            },
            {
              "name": "calloc_func",
              "type": "SDL_calloc_func *"
            },
            {
              "name": "realloc_func",
              "type": "SDL_realloc_func *"
            },
            {
              "name": "free_func",
              "type": "SDL_free_func *"
            }
          ]
        },
        "SDL_SetMemoryFunctions": {
          "doc": "Replace SDL's memory allocation functions with a custom set.\n\nIt is not safe to call this function once any allocations have been made,\nas future calls to SDL_free will use the new allocator, even if they came\nfrom an SDL_malloc made with the old one!\n\nIf used, usually this needs to be the first call made into the SDL library,\nif not the very first thing done at program startup time.\n\n\\param malloc_func custom malloc function.\n\\param calloc_func custom calloc function.\n\\param realloc_func custom realloc function.\n\\param free_func custom free function.\n\\returns true on success or false on failure; call SDL_GetError() for more\n         information.\n\n\\threadsafety It is safe to call this function from any thread, but one\n              should not replace the memory functions once any allocations\n              are made!\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetMemoryFunctions\n\\sa SDL_GetOriginalMemoryFunctions",
          "name": "SDL_SetMemoryFunctions",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "malloc_func",
              "type": "SDL_malloc_func"
            },
            {
              "name": "calloc_func",
              "type": "SDL_calloc_func"
            },
            {
              "name": "realloc_func",
              "type": "SDL_realloc_func"
            },
            {
              "name": "free_func",
              "type": "SDL_free_func"
            }
          ]
        },
        "SDL_aligned_alloc": {
          "doc": "Allocate memory aligned to a specific alignment.\n\nThe memory returned by this function must be freed with SDL_aligned_free(),\n_not_ SDL_free().\n\nIf `alignment` is less than the size of `void *`, it will be increased to\nmatch that.\n\nThe returned memory address will be a multiple of the alignment value, and\nthe size of the memory allocated will be a multiple of the alignment value.\n\n\\param alignment the alignment of the memory.\n\\param size the size to allocate.\n\\returns a pointer to the aligned memory, or NULL if allocation failed.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_aligned_free",
          "name": "SDL_aligned_alloc",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "alignment",
              "type": "size_t"
            },
            {
              "name": "size",
              "type": "size_t"
            }
          ]
        },
        "SDL_aligned_free": {
          "doc": "Free memory allocated by SDL_aligned_alloc().\n\nThe pointer is no longer valid after this call and cannot be dereferenced\nanymore.\n\nIf `mem` is NULL, this function does nothing.\n\n\\param mem a pointer previously returned by SDL_aligned_alloc(), or NULL.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_aligned_alloc",
          "name": "SDL_aligned_free",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "mem",
              "type": "void *"
            }
          ]
        },
        "SDL_GetNumAllocations": {
          "doc": "Get the number of outstanding (unfreed) allocations.\n\n\\returns the number of allocations or -1 if allocation counting is\n         disabled.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_GetNumAllocations",
          "kind": "function",
          "type": "int",
          "parameters": []
        },
        "SDL_Environment": {
          "doc": "A thread-safe set of environment variables\n\n\\since This struct is available since SDL 3.2.0.\n\n\\sa SDL_GetEnvironment\n\\sa SDL_CreateEnvironment\n\\sa SDL_GetEnvironmentVariable\n\\sa SDL_GetEnvironmentVariables\n\\sa SDL_SetEnvironmentVariable\n\\sa SDL_UnsetEnvironmentVariable\n\\sa SDL_DestroyEnvironment",
          "name": "SDL_Environment",
          "kind": "alias",
          "type": "struct SDL_Environment"
        },
        "SDL_GetEnvironment": {
          "doc": "Get the process environment.\n\nThis is initialized at application start and is not affected by setenv()\nand unsetenv() calls after that point. Use SDL_SetEnvironmentVariable() and\nSDL_UnsetEnvironmentVariable() if you want to modify this environment, or\nSDL_setenv_unsafe() or SDL_unsetenv_unsafe() if you want changes to persist\nin the C runtime environment after SDL_Quit().\n\n\\returns a pointer to the environment for the process or NULL on failure;\n         call SDL_GetError() for more information.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetEnvironmentVariable\n\\sa SDL_GetEnvironmentVariables\n\\sa SDL_SetEnvironmentVariable\n\\sa SDL_UnsetEnvironmentVariable",
          "name": "SDL_GetEnvironment",
          "kind": "function",
          "type": "SDL_Environment *",
          "parameters": []
        },
        "SDL_CreateEnvironment": {
          "doc": "Create a set of environment variables\n\n\\param populated true to initialize it from the C runtime environment,\n                 false to create an empty environment.\n\\returns a pointer to the new environment or NULL on failure; call\n         SDL_GetError() for more information.\n\n\\threadsafety If `populated` is false, it is safe to call this function\n              from any thread, otherwise it is safe if no other threads are\n              calling setenv() or unsetenv()\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetEnvironmentVariable\n\\sa SDL_GetEnvironmentVariables\n\\sa SDL_SetEnvironmentVariable\n\\sa SDL_UnsetEnvironmentVariable\n\\sa SDL_DestroyEnvironment",
          "name": "SDL_CreateEnvironment",
          "kind": "function",
          "type": "SDL_Environment *",
          "parameters": [
            {
              "name": "populated",
              "type": "bool"
            }
          ]
        },
        "SDL_GetEnvironmentVariable": {
          "doc": "Get the value of a variable in the environment.\n\n\\param env the environment to query.\n\\param name the name of the variable to get.\n\\returns a pointer to the value of the variable or NULL if it can't be\n         found.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetEnvironment\n\\sa SDL_CreateEnvironment\n\\sa SDL_GetEnvironmentVariables\n\\sa SDL_SetEnvironmentVariable\n\\sa SDL_UnsetEnvironmentVariable",
          "name": "SDL_GetEnvironmentVariable",
          "kind": "function",
          "type": "const char *",
          "parameters": [
            {
              "name": "env",
              "type": "SDL_Environment *"
            },
            {
              "name": "name",
              "type": "const char *"
            }
          ]
        },
        "SDL_GetEnvironmentVariables": {
          "doc": "Get all variables in the environment.\n\n\\param env the environment to query.\n\\returns a NULL terminated array of pointers to environment variables in\n         the form \"variable=value\" or NULL on failure; call SDL_GetError()\n         for more information. This is a single allocation that should be\n         freed with SDL_free() when it is no longer needed.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetEnvironment\n\\sa SDL_CreateEnvironment\n\\sa SDL_GetEnvironmentVariables\n\\sa SDL_SetEnvironmentVariable\n\\sa SDL_UnsetEnvironmentVariable",
          "name": "SDL_GetEnvironmentVariables",
          "kind": "function",
          "type": "char **",
          "parameters": [
            {
              "name": "env",
              "type": "SDL_Environment *"
            }
          ]
        },
        "SDL_SetEnvironmentVariable": {
          "doc": "Set the value of a variable in the environment.\n\n\\param env the environment to modify.\n\\param name the name of the variable to set.\n\\param value the value of the variable to set.\n\\param overwrite true to overwrite the variable if it exists, false to\n                 return success without setting the variable if it already\n                 exists.\n\\returns true on success or false on failure; call SDL_GetError() for more\n         information.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetEnvironment\n\\sa SDL_CreateEnvironment\n\\sa SDL_GetEnvironmentVariable\n\\sa SDL_GetEnvironmentVariables\n\\sa SDL_UnsetEnvironmentVariable",
          "name": "SDL_SetEnvironmentVariable",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "env",
              "type": "SDL_Environment *"
            },
            {
              "name": "name",
              "type": "const char *"
            },
            {
              "name": "value",
              "type": "const char *"
            },
            {
              "name": "overwrite",
              "type": "bool"
            }
          ]
        },
        "SDL_UnsetEnvironmentVariable": {
          "doc": "Clear a variable from the environment.\n\n\\param env the environment to modify.\n\\param name the name of the variable to unset.\n\\returns true on success or false on failure; call SDL_GetError() for more\n         information.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetEnvironment\n\\sa SDL_CreateEnvironment\n\\sa SDL_GetEnvironmentVariable\n\\sa SDL_GetEnvironmentVariables\n\\sa SDL_SetEnvironmentVariable\n\\sa SDL_UnsetEnvironmentVariable",
          "name": "SDL_UnsetEnvironmentVariable",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "env",
              "type": "SDL_Environment *"
            },
            {
              "name": "name",
              "type": "const char *"
            }
          ]
        },
        "SDL_DestroyEnvironment": {
          "doc": "Destroy a set of environment variables.\n\n\\param env the environment to destroy.\n\n\\threadsafety It is safe to call this function from any thread, as long as\n              the environment is no longer in use.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_CreateEnvironment",
          "name": "SDL_DestroyEnvironment",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "env",
              "type": "SDL_Environment *"
            }
          ]
        },
        "SDL_getenv": {
          "doc": "Get the value of a variable in the environment.\n\nThis function uses SDL's cached copy of the environment and is thread-safe.\n\n\\param name the name of the variable to get.\n\\returns a pointer to the value of the variable or NULL if it can't be\n         found.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_getenv",
          "kind": "function",
          "type": "const char *",
          "parameters": [
            {
              "name": "name",
              "type": "const char *"
            }
          ]
        },
        "SDL_getenv_unsafe": {
          "doc": "Get the value of a variable in the environment.\n\nThis function bypasses SDL's cached copy of the environment and is not\nthread-safe.\n\n\\param name the name of the variable to get.\n\\returns a pointer to the value of the variable or NULL if it can't be\n         found.\n\n\\threadsafety This function is not thread safe, consider using SDL_getenv()\n              instead.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_getenv",
          "name": "SDL_getenv_unsafe",
          "kind": "function",
          "type": "const char *",
          "parameters": [
            {
              "name": "name",
              "type": "const char *"
            }
          ]
        },
        "SDL_setenv_unsafe": {
          "doc": "Set the value of a variable in the environment.\n\n\\param name the name of the variable to set.\n\\param value the value of the variable to set.\n\\param overwrite 1 to overwrite the variable if it exists, 0 to return\n                 success without setting the variable if it already exists.\n\\returns 0 on success, -1 on error.\n\n\\threadsafety This function is not thread safe, consider using\n              SDL_SetEnvironmentVariable() instead.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_SetEnvironmentVariable",
          "name": "SDL_setenv_unsafe",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "name",
              "type": "const char *"
            },
            {
              "name": "value",
              "type": "const char *"
            },
            {
              "name": "overwrite",
              "type": "int"
            }
          ]
        },
        "SDL_unsetenv_unsafe": {
          "doc": "Clear a variable from the environment.\n\n\\param name the name of the variable to unset.\n\\returns 0 on success, -1 on error.\n\n\\threadsafety This function is not thread safe, consider using\n              SDL_UnsetEnvironmentVariable() instead.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_UnsetEnvironmentVariable",
          "name": "SDL_unsetenv_unsafe",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "name",
              "type": "const char *"
            }
          ]
        },
        "SDL_CompareCallback": {
          "doc": "A callback used with SDL sorting and binary search functions.\n\n\\param a a pointer to the first element being compared.\n\\param b a pointer to the second element being compared.\n\\returns -1 if `a` should be sorted before `b`, 1 if `b` should be sorted\n         before `a`, 0 if they are equal. If two elements are equal, their\n         order in the sorted array is undefined.\n\n\\since This callback is available since SDL 3.2.0.\n\n\\sa SDL_bsearch\n\\sa SDL_qsort",
          "name": "SDL_CompareCallback",
          "kind": "callback",
          "type": "int",
          "parameters": [
            {
              "name": "a",
              "type": "const void *"
            },
            {
              "name": "b",
              "type": "const void *"
            }
          ]
        },
        "SDL_qsort": {
          "doc": "Sort an array.\n\nFor example:\n\n```c\ntypedef struct {\n    int key;\n    const char *string;\n} data;\n\nint SDLCALL compare(const void *a, const void *b)\n{\n    const data *A = (const data *)a;\n    const data *B = (const data *)b;\n\n    if (A->n < B->n) {\n        return -1;\n    } else if (B->n < A->n) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\ndata values[] = {\n    { 3, \"third\" }, { 1, \"first\" }, { 2, \"second\" }\n};\n\nSDL_qsort(values, SDL_arraysize(values), sizeof(values[0]), compare);\n```\n\n\\param base a pointer to the start of the array.\n\\param nmemb the number of elements in the array.\n\\param size the size of the elements in the array.\n\\param compare a function used to compare elements in the array.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_bsearch\n\\sa SDL_qsort_r",
          "name": "SDL_qsort",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "base",
              "type": "void *"
            },
            {
              "name": "nmemb",
              "type": "size_t"
            },
            {
              "name": "size",
              "type": "size_t"
            },
            {
              "name": "compare",
              "type": "SDL_CompareCallback"
            }
          ]
        },
        "SDL_bsearch": {
          "doc": "Perform a binary search on a previously sorted array.\n\nFor example:\n\n```c\ntypedef struct {\n    int key;\n    const char *string;\n} data;\n\nint SDLCALL compare(const void *a, const void *b)\n{\n    const data *A = (const data *)a;\n    const data *B = (const data *)b;\n\n    if (A->n < B->n) {\n        return -1;\n    } else if (B->n < A->n) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\ndata values[] = {\n    { 1, \"first\" }, { 2, \"second\" }, { 3, \"third\" }\n};\ndata key = { 2, NULL };\n\ndata *result = SDL_bsearch(&key, values, SDL_arraysize(values), sizeof(values[0]), compare);\n```\n\n\\param key a pointer to a key equal to the element being searched for.\n\\param base a pointer to the start of the array.\n\\param nmemb the number of elements in the array.\n\\param size the size of the elements in the array.\n\\param compare a function used to compare elements in the array.\n\\returns a pointer to the matching element in the array, or NULL if not\n         found.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_bsearch_r\n\\sa SDL_qsort",
          "name": "SDL_bsearch",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "key",
              "type": "const void *"
            },
            {
              "name": "base",
              "type": "const void *"
            },
            {
              "name": "nmemb",
              "type": "size_t"
            },
            {
              "name": "size",
              "type": "size_t"
            },
            {
              "name": "compare",
              "type": "SDL_CompareCallback"
            }
          ]
        },
        "SDL_CompareCallback_r": {
          "doc": "A callback used with SDL sorting and binary search functions.\n\n\\param userdata the `userdata` pointer passed to the sort function.\n\\param a a pointer to the first element being compared.\n\\param b a pointer to the second element being compared.\n\\returns -1 if `a` should be sorted before `b`, 1 if `b` should be sorted\n         before `a`, 0 if they are equal. If two elements are equal, their\n         order in the sorted array is undefined.\n\n\\since This callback is available since SDL 3.2.0.\n\n\\sa SDL_qsort_r\n\\sa SDL_bsearch_r",
          "name": "SDL_CompareCallback_r",
          "kind": "callback",
          "type": "int",
          "parameters": [
            {
              "name": "userdata",
              "type": "void *"
            },
            {
              "name": "a",
              "type": "const void *"
            },
            {
              "name": "b",
              "type": "const void *"
            }
          ]
        },
        "SDL_qsort_r": {
          "doc": "Sort an array, passing a userdata pointer to the compare function.\n\nFor example:\n\n```c\ntypedef enum {\n    sort_increasing,\n    sort_decreasing,\n} sort_method;\n\ntypedef struct {\n    int key;\n    const char *string;\n} data;\n\nint SDLCALL compare(const void *userdata, const void *a, const void *b)\n{\n    sort_method method = (sort_method)(uintptr_t)userdata;\n    const data *A = (const data *)a;\n    const data *B = (const data *)b;\n\n    if (A->key < B->key) {\n        return (method == sort_increasing) ? -1 : 1;\n    } else if (B->key < A->key) {\n        return (method == sort_increasing) ? 1 : -1;\n    } else {\n        return 0;\n    }\n}\n\ndata values[] = {\n    { 3, \"third\" }, { 1, \"first\" }, { 2, \"second\" }\n};\n\nSDL_qsort_r(values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);\n```\n\n\\param base a pointer to the start of the array.\n\\param nmemb the number of elements in the array.\n\\param size the size of the elements in the array.\n\\param compare a function used to compare elements in the array.\n\\param userdata a pointer to pass to the compare function.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_bsearch_r\n\\sa SDL_qsort",
          "name": "SDL_qsort_r",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "base",
              "type": "void *"
            },
            {
              "name": "nmemb",
              "type": "size_t"
            },
            {
              "name": "size",
              "type": "size_t"
            },
            {
              "name": "compare",
              "type": "SDL_CompareCallback_r"
            },
            {
              "name": "userdata",
              "type": "void *"
            }
          ]
        },
        "SDL_bsearch_r": {
          "doc": "Perform a binary search on a previously sorted array, passing a userdata\npointer to the compare function.\n\nFor example:\n\n```c\ntypedef enum {\n    sort_increasing,\n    sort_decreasing,\n} sort_method;\n\ntypedef struct {\n    int key;\n    const char *string;\n} data;\n\nint SDLCALL compare(const void *userdata, const void *a, const void *b)\n{\n    sort_method method = (sort_method)(uintptr_t)userdata;\n    const data *A = (const data *)a;\n    const data *B = (const data *)b;\n\n    if (A->key < B->key) {\n        return (method == sort_increasing) ? -1 : 1;\n    } else if (B->key < A->key) {\n        return (method == sort_increasing) ? 1 : -1;\n    } else {\n        return 0;\n    }\n}\n\ndata values[] = {\n    { 1, \"first\" }, { 2, \"second\" }, { 3, \"third\" }\n};\ndata key = { 2, NULL };\n\ndata *result = SDL_bsearch_r(&key, values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);\n```\n\n\\param key a pointer to a key equal to the element being searched for.\n\\param base a pointer to the start of the array.\n\\param nmemb the number of elements in the array.\n\\param size the size of the elements in the array.\n\\param compare a function used to compare elements in the array.\n\\param userdata a pointer to pass to the compare function.\n\\returns a pointer to the matching element in the array, or NULL if not\n         found.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_bsearch\n\\sa SDL_qsort_r",
          "name": "SDL_bsearch_r",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "key",
              "type": "const void *"
            },
            {
              "name": "base",
              "type": "const void *"
            },
            {
              "name": "nmemb",
              "type": "size_t"
            },
            {
              "name": "size",
              "type": "size_t"
            },
            {
              "name": "compare",
              "type": "SDL_CompareCallback_r"
            },
            {
              "name": "userdata",
              "type": "void *"
            }
          ]
        },
        "SDL_abs": {
          "doc": "Compute the absolute value of `x`.\n\n\\param x an integer value.\n\\returns the absolute value of x.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_abs",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ]
        },
        "SDL_min": {
          "doc": "Return the lesser of two values.\n\nThis is a helper macro that might be more clear than writing out the\ncomparisons directly, and works with any type that can be compared with the\n`<` operator. However, it double-evaluates both its parameters, so do not\nuse expressions with side-effects here.\n\n\\param x the first value to compare.\n\\param y the second value to compare.\n\\returns the lesser of `x` and `y`.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_min",
          "kind": "def",
          "parameters": [
            "x",
            "y"
          ]
        },
        "SDL_max": {
          "doc": "Return the greater of two values.\n\nThis is a helper macro that might be more clear than writing out the\ncomparisons directly, and works with any type that can be compared with the\n`>` operator. However, it double-evaluates both its parameters, so do not\nuse expressions with side-effects here.\n\n\\param x the first value to compare.\n\\param y the second value to compare.\n\\returns the lesser of `x` and `y`.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_max",
          "kind": "def",
          "parameters": [
            "x",
            "y"
          ]
        },
        "SDL_clamp": {
          "doc": "Return a value clamped to a range.\n\nIf `x` is outside the range a values between `a` and `b`, the returned\nvalue will be `a` or `b` as appropriate. Otherwise, `x` is returned.\n\nThis macro will produce incorrect results if `b` is less than `a`.\n\nThis is a helper macro that might be more clear than writing out the\ncomparisons directly, and works with any type that can be compared with the\n`<` and `>` operators. However, it double-evaluates all its parameters, so\ndo not use expressions with side-effects here.\n\n\\param x the value to compare.\n\\param a the low end value.\n\\param b the high end value.\n\\returns x, clamped between a and b.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_clamp",
          "kind": "def",
          "parameters": [
            "x",
            "a",
            "b"
          ]
        },
        "SDL_isalpha": {
          "doc": "Query if a character is alphabetic (a letter).\n\n**WARNING**: Regardless of system locale, this will only treat ASCII values\nfor English 'a-z' and 'A-Z' as true.\n\n\\param x character value to check.\n\\returns non-zero if x falls within the character class, zero otherwise.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_isalpha",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ]
        },
        "SDL_isalnum": {
          "doc": "Query if a character is alphabetic (a letter) or a number.\n\n**WARNING**: Regardless of system locale, this will only treat ASCII values\nfor English 'a-z', 'A-Z', and '0-9' as true.\n\n\\param x character value to check.\n\\returns non-zero if x falls within the character class, zero otherwise.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_isalnum",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ]
        },
        "SDL_isblank": {
          "doc": "Report if a character is blank (a space or tab).\n\n**WARNING**: Regardless of system locale, this will only treat ASCII values\n0x20 (space) or 0x9 (tab) as true.\n\n\\param x character value to check.\n\\returns non-zero if x falls within the character class, zero otherwise.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_isblank",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ]
        },
        "SDL_iscntrl": {
          "doc": "Report if a character is a control character.\n\n**WARNING**: Regardless of system locale, this will only treat ASCII values\n0 through 0x1F, and 0x7F, as true.\n\n\\param x character value to check.\n\\returns non-zero if x falls within the character class, zero otherwise.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_iscntrl",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ]
        },
        "SDL_isdigit": {
          "doc": "Report if a character is a numeric digit.\n\n**WARNING**: Regardless of system locale, this will only treat ASCII values\n'0' (0x30) through '9' (0x39), as true.\n\n\\param x character value to check.\n\\returns non-zero if x falls within the character class, zero otherwise.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_isdigit",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ]
        },
        "SDL_isxdigit": {
          "doc": "Report if a character is a hexadecimal digit.\n\n**WARNING**: Regardless of system locale, this will only treat ASCII values\n'A' through 'F', 'a' through 'f', and '0' through '9', as true.\n\n\\param x character value to check.\n\\returns non-zero if x falls within the character class, zero otherwise.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_isxdigit",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ]
        },
        "SDL_ispunct": {
          "doc": "Report if a character is a punctuation mark.\n\n**WARNING**: Regardless of system locale, this is equivalent to\n`((SDL_isgraph(x)) && (!SDL_isalnum(x)))`.\n\n\\param x character value to check.\n\\returns non-zero if x falls within the character class, zero otherwise.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_isgraph\n\\sa SDL_isalnum",
          "name": "SDL_ispunct",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ]
        },
        "SDL_isspace": {
          "doc": "Report if a character is whitespace.\n\n**WARNING**: Regardless of system locale, this will only treat the\nfollowing ASCII values as true:\n\n- space (0x20)\n- tab (0x09)\n- newline (0x0A)\n- vertical tab (0x0B)\n- form feed (0x0C)\n- return (0x0D)\n\n\\param x character value to check.\n\\returns non-zero if x falls within the character class, zero otherwise.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_isspace",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ]
        },
        "SDL_isupper": {
          "doc": "Report if a character is upper case.\n\n**WARNING**: Regardless of system locale, this will only treat ASCII values\n'A' through 'Z' as true.\n\n\\param x character value to check.\n\\returns non-zero if x falls within the character class, zero otherwise.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_isupper",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ]
        },
        "SDL_islower": {
          "doc": "Report if a character is lower case.\n\n**WARNING**: Regardless of system locale, this will only treat ASCII values\n'a' through 'z' as true.\n\n\\param x character value to check.\n\\returns non-zero if x falls within the character class, zero otherwise.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_islower",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ]
        },
        "SDL_isprint": {
          "doc": "Report if a character is \"printable\".\n\nBe advised that \"printable\" has a definition that goes back to text\nterminals from the dawn of computing, making this a sort of special case\nfunction that is not suitable for Unicode (or most any) text management.\n\n**WARNING**: Regardless of system locale, this will only treat ASCII values\n' ' (0x20) through '~' (0x7E) as true.\n\n\\param x character value to check.\n\\returns non-zero if x falls within the character class, zero otherwise.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_isprint",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ]
        },
        "SDL_isgraph": {
          "doc": "Report if a character is any \"printable\" except space.\n\nBe advised that \"printable\" has a definition that goes back to text\nterminals from the dawn of computing, making this a sort of special case\nfunction that is not suitable for Unicode (or most any) text management.\n\n**WARNING**: Regardless of system locale, this is equivalent to\n`(SDL_isprint(x)) && ((x) != ' ')`.\n\n\\param x character value to check.\n\\returns non-zero if x falls within the character class, zero otherwise.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_isprint",
          "name": "SDL_isgraph",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ]
        },
        "SDL_toupper": {
          "doc": "Convert low-ASCII English letters to uppercase.\n\n**WARNING**: Regardless of system locale, this will only convert ASCII\nvalues 'a' through 'z' to uppercase.\n\nThis function returns the uppercase equivalent of `x`. If a character\ncannot be converted, or is already uppercase, this function returns `x`.\n\n\\param x character value to check.\n\\returns capitalized version of x, or x if no conversion available.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_toupper",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ]
        },
        "SDL_tolower": {
          "doc": "Convert low-ASCII English letters to lowercase.\n\n**WARNING**: Regardless of system locale, this will only convert ASCII\nvalues 'A' through 'Z' to lowercase.\n\nThis function returns the lowercase equivalent of `x`. If a character\ncannot be converted, or is already lowercase, this function returns `x`.\n\n\\param x character value to check.\n\\returns lowercase version of x, or x if no conversion available.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_tolower",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ]
        },
        "SDL_crc16": {
          "doc": "Calculate a CRC-16 value.\n\nhttps://en.wikipedia.org/wiki/Cyclic_redundancy_check\n\nThis function can be called multiple times, to stream data to be\nchecksummed in blocks. Each call must provide the previous CRC-16 return\nvalue to be updated with the next block. The first call to this function\nfor a set of blocks should pass in a zero CRC value.\n\n\\param crc the current checksum for this data set, or 0 for a new data set.\n\\param data a new block of data to add to the checksum.\n\\param len the size, in bytes, of the new block of data.\n\\returns a CRC-16 checksum value of all blocks in the data set.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_crc16",
          "kind": "function",
          "type": "Uint16",
          "parameters": [
            {
              "name": "crc",
              "type": "Uint16"
            },
            {
              "name": "data",
              "type": "const void *"
            },
            {
              "name": "len",
              "type": "size_t"
            }
          ]
        },
        "SDL_crc32": {
          "doc": "Calculate a CRC-32 value.\n\nhttps://en.wikipedia.org/wiki/Cyclic_redundancy_check\n\nThis function can be called multiple times, to stream data to be\nchecksummed in blocks. Each call must provide the previous CRC-32 return\nvalue to be updated with the next block. The first call to this function\nfor a set of blocks should pass in a zero CRC value.\n\n\\param crc the current checksum for this data set, or 0 for a new data set.\n\\param data a new block of data to add to the checksum.\n\\param len the size, in bytes, of the new block of data.\n\\returns a CRC-32 checksum value of all blocks in the data set.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_crc32",
          "kind": "function",
          "type": "Uint32",
          "parameters": [
            {
              "name": "crc",
              "type": "Uint32"
            },
            {
              "name": "data",
              "type": "const void *"
            },
            {
              "name": "len",
              "type": "size_t"
            }
          ]
        },
        "SDL_murmur3_32": {
          "doc": "Calculate a 32-bit MurmurHash3 value for a block of data.\n\nhttps://en.wikipedia.org/wiki/MurmurHash\n\nA seed may be specified, which changes the final results consistently, but\nthis does not work like SDL_crc16 and SDL_crc32: you can't feed a previous\nresult from this function back into itself as the next seed value to\ncalculate a hash in chunks; it won't produce the same hash as it would if\nthe same data was provided in a single call.\n\nIf you aren't sure what to provide for a seed, zero is fine. Murmur3 is not\ncryptographically secure, so it shouldn't be used for hashing top-secret\ndata.\n\n\\param data the data to be hashed.\n\\param len the size of data, in bytes.\n\\param seed a value that alters the final hash value.\n\\returns a Murmur3 32-bit hash value.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_murmur3_32",
          "kind": "function",
          "type": "Uint32",
          "parameters": [
            {
              "name": "data",
              "type": "const void *"
            },
            {
              "name": "len",
              "type": "size_t"
            },
            {
              "name": "seed",
              "type": "Uint32"
            }
          ]
        },
        "SDL_memcpy": {
          "doc": "Copy non-overlapping memory.\n\nThe memory regions must not overlap. If they do, use SDL_memmove() instead.\n\n\\param dst The destination memory region. Must not be NULL, and must not\n           overlap with `src`.\n\\param src The source memory region. Must not be NULL, and must not overlap\n           with `dst`.\n\\param len The length in bytes of both `dst` and `src`.\n\\returns `dst`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_memmove",
          "name": "SDL_memcpy",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "dst",
              "type": "void *"
            },
            {
              "name": "src",
              "type": "const void *"
            },
            {
              "name": "len",
              "type": "size_t"
            }
          ]
        },
        "SDL_copyp": {
          "doc": "A macro to copy memory between objects, with basic type checking.\n\nSDL_memcpy and SDL_memmove do not care where you copy memory to and from,\nwhich can lead to bugs. This macro aims to avoid most of those bugs by\nmaking sure that the source and destination are both pointers to objects\nthat are the same size. It does not check that the objects are the same\n_type_, just that the copy will not overflow either object.\n\nThe size check happens at compile time, and the compiler will throw an\nerror if the objects are different sizes.\n\nGenerally this is intended to copy a single object, not an array.\n\nThis macro looks like it double-evaluates its parameters, but the extras\nthem are in `sizeof` sections, which generate no code nor side-effects.\n\n\\param dst a pointer to the destination object. Must not be NULL.\n\\param src a pointer to the source object. Must not be NULL.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_copyp",
          "kind": "def",
          "parameters": [
            "dst",
            "src"
          ]
        },
        "SDL_memmove": {
          "doc": "Copy memory ranges that might overlap.\n\nIt is okay for the memory regions to overlap. If you are confident that the\nregions never overlap, using SDL_memcpy() may improve performance.\n\n\\param dst The destination memory region. Must not be NULL.\n\\param src The source memory region. Must not be NULL.\n\\param len The length in bytes of both `dst` and `src`.\n\\returns `dst`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_memcpy",
          "name": "SDL_memmove",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "dst",
              "type": "void *"
            },
            {
              "name": "src",
              "type": "const void *"
            },
            {
              "name": "len",
              "type": "size_t"
            }
          ]
        },
        "SDL_memset": {
          "doc": "Initialize all bytes of buffer of memory to a specific value.\n\nThis function will set `len` bytes, pointed to by `dst`, to the value\nspecified in `c`.\n\nDespite `c` being an `int` instead of a `char`, this only operates on\nbytes; `c` must be a value between 0 and 255, inclusive.\n\n\\param dst the destination memory region. Must not be NULL.\n\\param c the byte value to set.\n\\param len the length, in bytes, to set in `dst`.\n\\returns `dst`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_memset",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "dst",
              "type": "void *"
            },
            {
              "name": "c",
              "type": "int"
            },
            {
              "name": "len",
              "type": "size_t"
            }
          ]
        },
        "SDL_memset4": {
          "doc": "Initialize all 32-bit words of buffer of memory to a specific value.\n\nThis function will set a buffer of `dwords` Uint32 values, pointed to by\n`dst`, to the value specified in `val`.\n\nUnlike SDL_memset, this sets 32-bit values, not bytes, so it's not limited\nto a range of 0-255.\n\n\\param dst the destination memory region. Must not be NULL.\n\\param val the Uint32 value to set.\n\\param dwords the number of Uint32 values to set in `dst`.\n\\returns `dst`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_memset4",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "dst",
              "type": "void *"
            },
            {
              "name": "val",
              "type": "Uint32"
            },
            {
              "name": "dwords",
              "type": "size_t"
            }
          ]
        },
        "SDL_zero": {
          "doc": "Clear an object's memory to zero.\n\nThis is wrapper over SDL_memset that handles calculating the object size,\nso there's no chance of copy/paste errors, and the code is cleaner.\n\nThis requires an object, not a pointer to an object, nor an array.\n\n\\param x the object to clear.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_zerop\n\\sa SDL_zeroa",
          "name": "SDL_zero",
          "kind": "def",
          "parameters": [
            "x"
          ]
        },
        "SDL_zerop": {
          "doc": "Clear an object's memory to zero, using a pointer.\n\nThis is wrapper over SDL_memset that handles calculating the object size,\nso there's no chance of copy/paste errors, and the code is cleaner.\n\nThis requires a pointer to an object, not an object itself, nor an array.\n\n\\param x a pointer to the object to clear.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_zero\n\\sa SDL_zeroa",
          "name": "SDL_zerop",
          "kind": "def",
          "parameters": [
            "x"
          ]
        },
        "SDL_zeroa": {
          "doc": "Clear an array's memory to zero.\n\nThis is wrapper over SDL_memset that handles calculating the array size, so\nthere's no chance of copy/paste errors, and the code is cleaner.\n\nThis requires an array, not an object, nor a pointer to an object.\n\n\\param x an array to clear.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_zero\n\\sa SDL_zeroa",
          "name": "SDL_zeroa",
          "kind": "def",
          "parameters": [
            "x"
          ]
        },
        "SDL_memcmp": {
          "doc": "Compare two buffers of memory.\n\n\\param s1 the first buffer to compare. NULL is not permitted!\n\\param s2 the second buffer to compare. NULL is not permitted!\n\\param len the number of bytes to compare between the buffers.\n\\returns less than zero if s1 is \"less than\" s2, greater than zero if s1 is\n         \"greater than\" s2, and zero if the buffers match exactly for `len`\n         bytes.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_memcmp",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "s1",
              "type": "const void *"
            },
            {
              "name": "s2",
              "type": "const void *"
            },
            {
              "name": "len",
              "type": "size_t"
            }
          ]
        },
        "SDL_wcslen": {
          "doc": "This works exactly like wcslen() but doesn't require access to a C runtime.\n\nCounts the number of wchar_t values in `wstr`, excluding the null\nterminator.\n\nLike SDL_strlen only counts bytes and not codepoints in a UTF-8 string,\nthis counts wchar_t values in a string, even if the string's encoding is of\nvariable width, like UTF-16.\n\nAlso be aware that wchar_t is different sizes on different platforms (4\nbytes on Linux, 2 on Windows, etc).\n\n\\param wstr The null-terminated wide string to read. Must not be NULL.\n\\returns the length (in wchar_t values, excluding the null terminator) of\n         `wstr`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_wcsnlen\n\\sa SDL_utf8strlen\n\\sa SDL_utf8strnlen",
          "name": "SDL_wcslen",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "wstr",
              "type": "const wchar_t *"
            }
          ]
        },
        "SDL_wcsnlen": {
          "doc": "This works exactly like wcsnlen() but doesn't require access to a C\nruntime.\n\nCounts up to a maximum of `maxlen` wchar_t values in `wstr`, excluding the\nnull terminator.\n\nLike SDL_strnlen only counts bytes and not codepoints in a UTF-8 string,\nthis counts wchar_t values in a string, even if the string's encoding is of\nvariable width, like UTF-16.\n\nAlso be aware that wchar_t is different sizes on different platforms (4\nbytes on Linux, 2 on Windows, etc).\n\nAlso, `maxlen` is a count of wide characters, not bytes!\n\n\\param wstr The null-terminated wide string to read. Must not be NULL.\n\\param maxlen The maximum amount of wide characters to count.\n\\returns the length (in wide characters, excluding the null terminator) of\n         `wstr` but never more than `maxlen`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_wcslen\n\\sa SDL_utf8strlen\n\\sa SDL_utf8strnlen",
          "name": "SDL_wcsnlen",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "wstr",
              "type": "const wchar_t *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ]
        },
        "SDL_wcslcpy": {
          "doc": "Copy a wide string.\n\nThis function copies `maxlen` - 1 wide characters from `src` to `dst`, then\nappends a null terminator.\n\n`src` and `dst` must not overlap.\n\nIf `maxlen` is 0, no wide characters are copied and no null terminator is\nwritten.\n\n\\param dst The destination buffer. Must not be NULL, and must not overlap\n           with `src`.\n\\param src The null-terminated wide string to copy. Must not be NULL, and\n           must not overlap with `dst`.\n\\param maxlen The length (in wide characters) of the destination buffer.\n\\returns the length (in wide characters, excluding the null terminator) of\n         `src`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_wcslcat",
          "name": "SDL_wcslcpy",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "dst",
              "type": "wchar_t *"
            },
            {
              "name": "src",
              "type": "const wchar_t *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ]
        },
        "SDL_wcslcat": {
          "doc": "Concatenate wide strings.\n\nThis function appends up to `maxlen` - SDL_wcslen(dst) - 1 wide characters\nfrom `src` to the end of the wide string in `dst`, then appends a null\nterminator.\n\n`src` and `dst` must not overlap.\n\nIf `maxlen` - SDL_wcslen(dst) - 1 is less than or equal to 0, then `dst` is\nunmodified.\n\n\\param dst The destination buffer already containing the first\n           null-terminated wide string. Must not be NULL and must not\n           overlap with `src`.\n\\param src The second null-terminated wide string. Must not be NULL, and\n           must not overlap with `dst`.\n\\param maxlen The length (in wide characters) of the destination buffer.\n\\returns the length (in wide characters, excluding the null terminator) of\n         the string in `dst` plus the length of `src`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_wcslcpy",
          "name": "SDL_wcslcat",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "dst",
              "type": "wchar_t *"
            },
            {
              "name": "src",
              "type": "const wchar_t *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ]
        },
        "SDL_wcsdup": {
          "doc": "Allocate a copy of a wide string.\n\nThis allocates enough space for a null-terminated copy of `wstr`, using\nSDL_malloc, and then makes a copy of the string into this space.\n\nThe returned string is owned by the caller, and should be passed to\nSDL_free when no longer needed.\n\n\\param wstr the string to copy.\n\\returns a pointer to the newly-allocated wide string.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_wcsdup",
          "kind": "function",
          "type": "wchar_t *",
          "parameters": [
            {
              "name": "wstr",
              "type": "const wchar_t *"
            }
          ]
        },
        "SDL_wcsstr": {
          "doc": "Search a wide string for the first instance of a specific substring.\n\nThe search ends once it finds the requested substring, or a null terminator\nbyte to end the string.\n\nNote that this looks for strings of _wide characters_, not _codepoints_, so\nit's legal to search for malformed and incomplete UTF-16 sequences.\n\n\\param haystack the wide string to search. Must not be NULL.\n\\param needle the wide string to search for. Must not be NULL.\n\\returns a pointer to the first instance of `needle` in the string, or NULL\n         if not found.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_wcsstr",
          "kind": "function",
          "type": "wchar_t *",
          "parameters": [
            {
              "name": "haystack",
              "type": "const wchar_t *"
            },
            {
              "name": "needle",
              "type": "const wchar_t *"
            }
          ]
        },
        "SDL_wcsnstr": {
          "doc": "Search a wide string, up to n wide chars, for the first instance of a\nspecific substring.\n\nThe search ends once it finds the requested substring, or a null terminator\nvalue to end the string, or `maxlen` wide character have been examined. It\nis possible to use this function on a wide string without a null\nterminator.\n\nNote that this looks for strings of _wide characters_, not _codepoints_, so\nit's legal to search for malformed and incomplete UTF-16 sequences.\n\n\\param haystack the wide string to search. Must not be NULL.\n\\param needle the wide string to search for. Must not be NULL.\n\\param maxlen the maximum number of wide characters to search in\n              `haystack`.\n\\returns a pointer to the first instance of `needle` in the string, or NULL\n         if not found.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_wcsnstr",
          "kind": "function",
          "type": "wchar_t *",
          "parameters": [
            {
              "name": "haystack",
              "type": "const wchar_t *"
            },
            {
              "name": "needle",
              "type": "const wchar_t *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ]
        },
        "SDL_wcscmp": {
          "doc": "Compare two null-terminated wide strings.\n\nThis only compares wchar_t values until it hits a null-terminating\ncharacter; it does not care if the string is well-formed UTF-16 (or UTF-32,\ndepending on your platform's wchar_t size), or uses valid Unicode values.\n\n\\param str1 the first string to compare. NULL is not permitted!\n\\param str2 the second string to compare. NULL is not permitted!\n\\returns less than zero if str1 is \"less than\" str2, greater than zero if\n         str1 is \"greater than\" str2, and zero if the strings match\n         exactly.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_wcscmp",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "str1",
              "type": "const wchar_t *"
            },
            {
              "name": "str2",
              "type": "const wchar_t *"
            }
          ]
        },
        "SDL_wcsncmp": {
          "doc": "Compare two wide strings up to a number of wchar_t values.\n\nThis only compares wchar_t values; it does not care if the string is\nwell-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),\nor uses valid Unicode values.\n\nNote that while this function is intended to be used with UTF-16 (or\nUTF-32, depending on your platform's definition of wchar_t), it is\ncomparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies\na wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16\nsequence, it will only compare a portion of the final character.\n\n`maxlen` specifies a maximum number of wchar_t to compare; if the strings\nmatch to this number of wide chars (or both have matched to a\nnull-terminator character before this count), they will be considered\nequal.\n\n\\param str1 the first string to compare. NULL is not permitted!\n\\param str2 the second string to compare. NULL is not permitted!\n\\param maxlen the maximum number of wchar_t to compare.\n\\returns less than zero if str1 is \"less than\" str2, greater than zero if\n         str1 is \"greater than\" str2, and zero if the strings match\n         exactly.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_wcsncmp",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "str1",
              "type": "const wchar_t *"
            },
            {
              "name": "str2",
              "type": "const wchar_t *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ]
        },
        "SDL_wcscasecmp": {
          "doc": "Compare two null-terminated wide strings, case-insensitively.\n\nThis will work with Unicode strings, using a technique called\n\"case-folding\" to handle the vast majority of case-sensitive human\nlanguages regardless of system locale. It can deal with expanding values: a\nGerman Eszett character can compare against two ASCII 's' chars and be\nconsidered a match, for example. A notable exception: it does not handle\nthe Turkish 'i' character; human language is complicated!\n\nDepending on your platform, \"wchar_t\" might be 2 bytes, and expected to be\nUTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this\nhandles Unicode, it expects the string to be well-formed and not a\nnull-terminated string of arbitrary bytes. Characters that are not valid\nUTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT\nCHARACTER), which is to say two strings of random bits may turn out to\nmatch if they convert to the same amount of replacement characters.\n\n\\param str1 the first string to compare. NULL is not permitted!\n\\param str2 the second string to compare. NULL is not permitted!\n\\returns less than zero if str1 is \"less than\" str2, greater than zero if\n         str1 is \"greater than\" str2, and zero if the strings match\n         exactly.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_wcscasecmp",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "str1",
              "type": "const wchar_t *"
            },
            {
              "name": "str2",
              "type": "const wchar_t *"
            }
          ]
        },
        "SDL_wcsncasecmp": {
          "doc": "Compare two wide strings, case-insensitively, up to a number of wchar_t.\n\nThis will work with Unicode strings, using a technique called\n\"case-folding\" to handle the vast majority of case-sensitive human\nlanguages regardless of system locale. It can deal with expanding values: a\nGerman Eszett character can compare against two ASCII 's' chars and be\nconsidered a match, for example. A notable exception: it does not handle\nthe Turkish 'i' character; human language is complicated!\n\nDepending on your platform, \"wchar_t\" might be 2 bytes, and expected to be\nUTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this\nhandles Unicode, it expects the string to be well-formed and not a\nnull-terminated string of arbitrary bytes. Characters that are not valid\nUTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT\nCHARACTER), which is to say two strings of random bits may turn out to\nmatch if they convert to the same amount of replacement characters.\n\nNote that while this function might deal with variable-sized characters,\n`maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a\nmulti-byte UTF-16 sequence, it may convert a portion of the final character\nto one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not\nto overflow a buffer.\n\n`maxlen` specifies a maximum number of wchar_t values to compare; if the\nstrings match to this number of wchar_t (or both have matched to a\nnull-terminator character before this number of bytes), they will be\nconsidered equal.\n\n\\param str1 the first string to compare. NULL is not permitted!\n\\param str2 the second string to compare. NULL is not permitted!\n\\param maxlen the maximum number of wchar_t values to compare.\n\\returns less than zero if str1 is \"less than\" str2, greater than zero if\n         str1 is \"greater than\" str2, and zero if the strings match\n         exactly.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_wcsncasecmp",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "str1",
              "type": "const wchar_t *"
            },
            {
              "name": "str2",
              "type": "const wchar_t *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ]
        },
        "SDL_wcstol": {
          "doc": "Parse a `long` from a wide string.\n\nIf `str` starts with whitespace, then those whitespace characters are\nskipped before attempting to parse the number.\n\nIf the parsed number does not fit inside a `long`, the result is clamped to\nthe minimum and maximum representable `long` values.\n\n\\param str The null-terminated wide string to read. Must not be NULL.\n\\param endp If not NULL, the address of the first invalid wide character\n            (i.e. the next character after the parsed number) will be\n            written to this pointer.\n\\param base The base of the integer to read. Supported values are 0 and 2\n            to 36 inclusive. If 0, the base will be inferred from the\n            number's prefix (0x for hexadecimal, 0 for octal, decimal\n            otherwise).\n\\returns the parsed `long`, or 0 if no number could be parsed.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_strtol",
          "name": "SDL_wcstol",
          "kind": "function",
          "type": "long",
          "parameters": [
            {
              "name": "str",
              "type": "const wchar_t *"
            },
            {
              "name": "endp",
              "type": "wchar_t **"
            },
            {
              "name": "base",
              "type": "int"
            }
          ]
        },
        "SDL_strlen": {
          "doc": "This works exactly like strlen() but doesn't require access to a C runtime.\n\nCounts the bytes in `str`, excluding the null terminator.\n\nIf you need the length of a UTF-8 string, consider using SDL_utf8strlen().\n\n\\param str The null-terminated string to read. Must not be NULL.\n\\returns the length (in bytes, excluding the null terminator) of `src`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_strnlen\n\\sa SDL_utf8strlen\n\\sa SDL_utf8strnlen",
          "name": "SDL_strlen",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "str",
              "type": "const char *"
            }
          ]
        },
        "SDL_strnlen": {
          "doc": "This works exactly like strnlen() but doesn't require access to a C\nruntime.\n\nCounts up to a maximum of `maxlen` bytes in `str`, excluding the null\nterminator.\n\nIf you need the length of a UTF-8 string, consider using SDL_utf8strnlen().\n\n\\param str The null-terminated string to read. Must not be NULL.\n\\param maxlen The maximum amount of bytes to count.\n\\returns the length (in bytes, excluding the null terminator) of `src` but\n         never more than `maxlen`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_strlen\n\\sa SDL_utf8strlen\n\\sa SDL_utf8strnlen",
          "name": "SDL_strnlen",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "str",
              "type": "const char *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ]
        },
        "SDL_strlcpy": {
          "doc": "Copy a string.\n\nThis function copies up to `maxlen` - 1 characters from `src` to `dst`,\nthen appends a null terminator.\n\nIf `maxlen` is 0, no characters are copied and no null terminator is\nwritten.\n\nIf you want to copy an UTF-8 string but need to ensure that multi-byte\nsequences are not truncated, consider using SDL_utf8strlcpy().\n\n\\param dst The destination buffer. Must not be NULL, and must not overlap\n           with `src`.\n\\param src The null-terminated string to copy. Must not be NULL, and must\n           not overlap with `dst`.\n\\param maxlen The length (in characters) of the destination buffer.\n\\returns the length (in characters, excluding the null terminator) of\n         `src`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_strlcat\n\\sa SDL_utf8strlcpy",
          "name": "SDL_strlcpy",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "dst",
              "type": "char *"
            },
            {
              "name": "src",
              "type": "const char *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ]
        },
        "SDL_utf8strlcpy": {
          "doc": "Copy an UTF-8 string.\n\nThis function copies up to `dst_bytes` - 1 bytes from `src` to `dst` while\nalso ensuring that the string written to `dst` does not end in a truncated\nmulti-byte sequence. Finally, it appends a null terminator.\n\n`src` and `dst` must not overlap.\n\nNote that unlike SDL_strlcpy(), this function returns the number of bytes\nwritten, not the length of `src`.\n\n\\param dst The destination buffer. Must not be NULL, and must not overlap\n           with `src`.\n\\param src The null-terminated UTF-8 string to copy. Must not be NULL, and\n           must not overlap with `dst`.\n\\param dst_bytes The length (in bytes) of the destination buffer. Must not\n                 be 0.\n\\returns the number of bytes written, excluding the null terminator.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_strlcpy",
          "name": "SDL_utf8strlcpy",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "dst",
              "type": "char *"
            },
            {
              "name": "src",
              "type": "const char *"
            },
            {
              "name": "dst_bytes",
              "type": "size_t"
            }
          ]
        },
        "SDL_strlcat": {
          "doc": "Concatenate strings.\n\nThis function appends up to `maxlen` - SDL_strlen(dst) - 1 characters from\n`src` to the end of the string in `dst`, then appends a null terminator.\n\n`src` and `dst` must not overlap.\n\nIf `maxlen` - SDL_strlen(dst) - 1 is less than or equal to 0, then `dst` is\nunmodified.\n\n\\param dst The destination buffer already containing the first\n           null-terminated string. Must not be NULL and must not overlap\n           with `src`.\n\\param src The second null-terminated string. Must not be NULL, and must\n           not overlap with `dst`.\n\\param maxlen The length (in characters) of the destination buffer.\n\\returns the length (in characters, excluding the null terminator) of the\n         string in `dst` plus the length of `src`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_strlcpy",
          "name": "SDL_strlcat",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "dst",
              "type": "char *"
            },
            {
              "name": "src",
              "type": "const char *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ]
        },
        "SDL_strdup": {
          "doc": "Allocate a copy of a string.\n\nThis allocates enough space for a null-terminated copy of `str`, using\nSDL_malloc, and then makes a copy of the string into this space.\n\nThe returned string is owned by the caller, and should be passed to\nSDL_free when no longer needed.\n\n\\param str the string to copy.\n\\returns a pointer to the newly-allocated string.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_strdup",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "str",
              "type": "const char *"
            }
          ]
        },
        "SDL_strndup": {
          "doc": "Allocate a copy of a string, up to n characters.\n\nThis allocates enough space for a null-terminated copy of `str`, up to\n`maxlen` bytes, using SDL_malloc, and then makes a copy of the string into\nthis space.\n\nIf the string is longer than `maxlen` bytes, the returned string will be\n`maxlen` bytes long, plus a null-terminator character that isn't included\nin the count.\n\nThe returned string is owned by the caller, and should be passed to\nSDL_free when no longer needed.\n\n\\param str the string to copy.\n\\param maxlen the maximum length of the copied string, not counting the\n              null-terminator character.\n\\returns a pointer to the newly-allocated string.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_strndup",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "str",
              "type": "const char *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ]
        },
        "SDL_strrev": {
          "doc": "Reverse a string's contents.\n\nThis reverses a null-terminated string in-place. Only the content of the\nstring is reversed; the null-terminator character remains at the end of the\nreversed string.\n\n**WARNING**: This function reverses the _bytes_ of the string, not the\ncodepoints. If `str` is a UTF-8 string with Unicode codepoints > 127, this\nwill ruin the string data. You should only use this function on strings\nthat are completely comprised of low ASCII characters.\n\n\\param str the string to reverse.\n\\returns `str`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_strrev",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "str",
              "type": "char *"
            }
          ]
        },
        "SDL_strupr": {
          "doc": "Convert a string to uppercase.\n\n**WARNING**: Regardless of system locale, this will only convert ASCII\nvalues 'A' through 'Z' to uppercase.\n\nThis function operates on a null-terminated string of bytes--even if it is\nmalformed UTF-8!--and converts ASCII characters 'a' through 'z' to their\nuppercase equivalents in-place, returning the original `str` pointer.\n\n\\param str the string to convert in-place. Can not be NULL.\n\\returns the `str` pointer passed into this function.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_strlwr",
          "name": "SDL_strupr",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "str",
              "type": "char *"
            }
          ]
        },
        "SDL_strlwr": {
          "doc": "Convert a string to lowercase.\n\n**WARNING**: Regardless of system locale, this will only convert ASCII\nvalues 'A' through 'Z' to lowercase.\n\nThis function operates on a null-terminated string of bytes--even if it is\nmalformed UTF-8!--and converts ASCII characters 'A' through 'Z' to their\nlowercase equivalents in-place, returning the original `str` pointer.\n\n\\param str the string to convert in-place. Can not be NULL.\n\\returns the `str` pointer passed into this function.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_strupr",
          "name": "SDL_strlwr",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "str",
              "type": "char *"
            }
          ]
        },
        "SDL_strchr": {
          "doc": "Search a string for the first instance of a specific byte.\n\nThe search ends once it finds the requested byte value, or a null\nterminator byte to end the string.\n\nNote that this looks for _bytes_, not _characters_, so you cannot match\nagainst a Unicode codepoint > 255, regardless of character encoding.\n\n\\param str the string to search. Must not be NULL.\n\\param c the byte value to search for.\n\\returns a pointer to the first instance of `c` in the string, or NULL if\n         not found.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_strchr",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "str",
              "type": "const char *"
            },
            {
              "name": "c",
              "type": "int"
            }
          ]
        },
        "SDL_strrchr": {
          "doc": "Search a string for the last instance of a specific byte.\n\nThe search must go until it finds a null terminator byte to end the string.\n\nNote that this looks for _bytes_, not _characters_, so you cannot match\nagainst a Unicode codepoint > 255, regardless of character encoding.\n\n\\param str the string to search. Must not be NULL.\n\\param c the byte value to search for.\n\\returns a pointer to the last instance of `c` in the string, or NULL if\n         not found.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_strrchr",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "str",
              "type": "const char *"
            },
            {
              "name": "c",
              "type": "int"
            }
          ]
        },
        "SDL_strstr": {
          "doc": "Search a string for the first instance of a specific substring.\n\nThe search ends once it finds the requested substring, or a null terminator\nbyte to end the string.\n\nNote that this looks for strings of _bytes_, not _characters_, so it's\nlegal to search for malformed and incomplete UTF-8 sequences.\n\n\\param haystack the string to search. Must not be NULL.\n\\param needle the string to search for. Must not be NULL.\n\\returns a pointer to the first instance of `needle` in the string, or NULL\n         if not found.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_strstr",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "haystack",
              "type": "const char *"
            },
            {
              "name": "needle",
              "type": "const char *"
            }
          ]
        },
        "SDL_strnstr": {
          "doc": "Search a string, up to n bytes, for the first instance of a specific\nsubstring.\n\nThe search ends once it finds the requested substring, or a null terminator\nbyte to end the string, or `maxlen` bytes have been examined. It is\npossible to use this function on a string without a null terminator.\n\nNote that this looks for strings of _bytes_, not _characters_, so it's\nlegal to search for malformed and incomplete UTF-8 sequences.\n\n\\param haystack the string to search. Must not be NULL.\n\\param needle the string to search for. Must not be NULL.\n\\param maxlen the maximum number of bytes to search in `haystack`.\n\\returns a pointer to the first instance of `needle` in the string, or NULL\n         if not found.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_strnstr",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "haystack",
              "type": "const char *"
            },
            {
              "name": "needle",
              "type": "const char *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ]
        },
        "SDL_strcasestr": {
          "doc": "Search a UTF-8 string for the first instance of a specific substring,\ncase-insensitively.\n\nThis will work with Unicode strings, using a technique called\n\"case-folding\" to handle the vast majority of case-sensitive human\nlanguages regardless of system locale. It can deal with expanding values: a\nGerman Eszett character can compare against two ASCII 's' chars and be\nconsidered a match, for example. A notable exception: it does not handle\nthe Turkish 'i' character; human language is complicated!\n\nSince this handles Unicode, it expects the strings to be well-formed UTF-8\nand not a null-terminated string of arbitrary bytes. Bytes that are not\nvalid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT\nCHARACTER), which is to say two strings of random bits may turn out to\nmatch if they convert to the same amount of replacement characters.\n\n\\param haystack the string to search. Must not be NULL.\n\\param needle the string to search for. Must not be NULL.\n\\returns a pointer to the first instance of `needle` in the string, or NULL\n         if not found.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_strcasestr",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "haystack",
              "type": "const char *"
            },
            {
              "name": "needle",
              "type": "const char *"
            }
          ]
        },
        "SDL_strtok_r": {
          "doc": "This works exactly like strtok_r() but doesn't require access to a C\nruntime.\n\nBreak a string up into a series of tokens.\n\nTo start tokenizing a new string, `str` should be the non-NULL address of\nthe string to start tokenizing. Future calls to get the next token from the\nsame string should specify a NULL.\n\nNote that this function will overwrite pieces of `str` with null chars to\nsplit it into tokens. This function cannot be used with const/read-only\nstrings!\n\n`saveptr` just needs to point to a `char *` that can be overwritten; SDL\nwill use this to save tokenizing state between calls. It is initialized if\n`str` is non-NULL, and used to resume tokenizing when `str` is NULL.\n\n\\param str the string to tokenize, or NULL to continue tokenizing.\n\\param delim the delimiter string that separates tokens.\n\\param saveptr pointer to a char *, used for ongoing state.\n\\returns A pointer to the next token, or NULL if no tokens remain.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_strtok_r",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "str",
              "type": "char *"
            },
            {
              "name": "delim",
              "type": "const char *"
            },
            {
              "name": "saveptr",
              "type": "char **"
            }
          ]
        },
        "SDL_utf8strlen": {
          "doc": "Count the number of codepoints in a UTF-8 string.\n\nCounts the _codepoints_, not _bytes_, in `str`, excluding the null\nterminator.\n\nIf you need to count the bytes in a string instead, consider using\nSDL_strlen().\n\nSince this handles Unicode, it expects the strings to be well-formed UTF-8\nand not a null-terminated string of arbitrary bytes. Bytes that are not\nvalid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT\nCHARACTER), so a malformed or incomplete UTF-8 sequence might increase the\ncount by several replacement characters.\n\n\\param str The null-terminated UTF-8 string to read. Must not be NULL.\n\\returns The length (in codepoints, excluding the null terminator) of\n         `src`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_utf8strnlen\n\\sa SDL_strlen",
          "name": "SDL_utf8strlen",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "str",
              "type": "const char *"
            }
          ]
        },
        "SDL_utf8strnlen": {
          "doc": "Count the number of codepoints in a UTF-8 string, up to n bytes.\n\nCounts the _codepoints_, not _bytes_, in `str`, excluding the null\nterminator.\n\nIf you need to count the bytes in a string instead, consider using\nSDL_strnlen().\n\nThe counting stops at `bytes` bytes (not codepoints!). This seems\ncounterintuitive, but makes it easy to express the total size of the\nstring's buffer.\n\nSince this handles Unicode, it expects the strings to be well-formed UTF-8\nand not a null-terminated string of arbitrary bytes. Bytes that are not\nvalid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT\nCHARACTER), so a malformed or incomplete UTF-8 sequence might increase the\ncount by several replacement characters.\n\n\\param str The null-terminated UTF-8 string to read. Must not be NULL.\n\\param bytes The maximum amount of bytes to count.\n\\returns The length (in codepoints, excluding the null terminator) of `src`\n         but never more than `maxlen`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_utf8strlen\n\\sa SDL_strnlen",
          "name": "SDL_utf8strnlen",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "str",
              "type": "const char *"
            },
            {
              "name": "bytes",
              "type": "size_t"
            }
          ]
        },
        "SDL_itoa": {
          "doc": "Convert an integer into a string.\n\nThis requires a radix to specified for string format. Specifying 10\nproduces a decimal number, 16 hexidecimal, etc. Must be in the range of 2\nto 36.\n\nNote that this function will overflow a buffer if `str` is not large enough\nto hold the output! It may be safer to use SDL_snprintf to clamp output, or\nSDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate\nmuch more space than you expect to use (and don't forget possible negative\nsigns, null terminator bytes, etc).\n\n\\param value the integer to convert.\n\\param str the buffer to write the string into.\n\\param radix the radix to use for string generation.\n\\returns `str`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_uitoa\n\\sa SDL_ltoa\n\\sa SDL_lltoa",
          "name": "SDL_itoa",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "value",
              "type": "int"
            },
            {
              "name": "str",
              "type": "char *"
            },
            {
              "name": "radix",
              "type": "int"
            }
          ]
        },
        "SDL_uitoa": {
          "doc": "Convert an unsigned integer into a string.\n\nThis requires a radix to specified for string format. Specifying 10\nproduces a decimal number, 16 hexidecimal, etc. Must be in the range of 2\nto 36.\n\nNote that this function will overflow a buffer if `str` is not large enough\nto hold the output! It may be safer to use SDL_snprintf to clamp output, or\nSDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate\nmuch more space than you expect to use (and don't forget null terminator\nbytes, etc).\n\n\\param value the unsigned integer to convert.\n\\param str the buffer to write the string into.\n\\param radix the radix to use for string generation.\n\\returns `str`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_itoa\n\\sa SDL_ultoa\n\\sa SDL_ulltoa",
          "name": "SDL_uitoa",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "value",
              "type": "unsigned int"
            },
            {
              "name": "str",
              "type": "char *"
            },
            {
              "name": "radix",
              "type": "int"
            }
          ]
        },
        "SDL_ltoa": {
          "doc": "Convert a long integer into a string.\n\nThis requires a radix to specified for string format. Specifying 10\nproduces a decimal number, 16 hexidecimal, etc. Must be in the range of 2\nto 36.\n\nNote that this function will overflow a buffer if `str` is not large enough\nto hold the output! It may be safer to use SDL_snprintf to clamp output, or\nSDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate\nmuch more space than you expect to use (and don't forget possible negative\nsigns, null terminator bytes, etc).\n\n\\param value the long integer to convert.\n\\param str the buffer to write the string into.\n\\param radix the radix to use for string generation.\n\\returns `str`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_ultoa\n\\sa SDL_itoa\n\\sa SDL_lltoa",
          "name": "SDL_ltoa",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "value",
              "type": "long"
            },
            {
              "name": "str",
              "type": "char *"
            },
            {
              "name": "radix",
              "type": "int"
            }
          ]
        },
        "SDL_ultoa": {
          "doc": "Convert an unsigned long integer into a string.\n\nThis requires a radix to specified for string format. Specifying 10\nproduces a decimal number, 16 hexidecimal, etc. Must be in the range of 2\nto 36.\n\nNote that this function will overflow a buffer if `str` is not large enough\nto hold the output! It may be safer to use SDL_snprintf to clamp output, or\nSDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate\nmuch more space than you expect to use (and don't forget null terminator\nbytes, etc).\n\n\\param value the unsigned long integer to convert.\n\\param str the buffer to write the string into.\n\\param radix the radix to use for string generation.\n\\returns `str`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_ltoa\n\\sa SDL_uitoa\n\\sa SDL_ulltoa",
          "name": "SDL_ultoa",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "value",
              "type": "unsigned long"
            },
            {
              "name": "str",
              "type": "char *"
            },
            {
              "name": "radix",
              "type": "int"
            }
          ]
        },
        "SDL_lltoa": {
          "doc": "Convert a long long integer into a string.\n\nThis requires a radix to specified for string format. Specifying 10\nproduces a decimal number, 16 hexidecimal, etc. Must be in the range of 2\nto 36.\n\nNote that this function will overflow a buffer if `str` is not large enough\nto hold the output! It may be safer to use SDL_snprintf to clamp output, or\nSDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate\nmuch more space than you expect to use (and don't forget possible negative\nsigns, null terminator bytes, etc).\n\n\\param value the long long integer to convert.\n\\param str the buffer to write the string into.\n\\param radix the radix to use for string generation.\n\\returns `str`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_ulltoa\n\\sa SDL_itoa\n\\sa SDL_ltoa",
          "name": "SDL_lltoa",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "value",
              "type": "long long"
            },
            {
              "name": "str",
              "type": "char *"
            },
            {
              "name": "radix",
              "type": "int"
            }
          ]
        },
        "SDL_ulltoa": {
          "doc": "Convert an unsigned long long integer into a string.\n\nThis requires a radix to specified for string format. Specifying 10\nproduces a decimal number, 16 hexidecimal, etc. Must be in the range of 2\nto 36.\n\nNote that this function will overflow a buffer if `str` is not large enough\nto hold the output! It may be safer to use SDL_snprintf to clamp output, or\nSDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate\nmuch more space than you expect to use (and don't forget null terminator\nbytes, etc).\n\n\\param value the unsigned long long integer to convert.\n\\param str the buffer to write the string into.\n\\param radix the radix to use for string generation.\n\\returns `str`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_lltoa\n\\sa SDL_uitoa\n\\sa SDL_ultoa",
          "name": "SDL_ulltoa",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "value",
              "type": "unsigned long long"
            },
            {
              "name": "str",
              "type": "char *"
            },
            {
              "name": "radix",
              "type": "int"
            }
          ]
        },
        "SDL_atoi": {
          "doc": "Parse an `int` from a string.\n\nThe result of calling `SDL_atoi(str)` is equivalent to\n`(int)SDL_strtol(str, NULL, 10)`.\n\n\\param str The null-terminated string to read. Must not be NULL.\n\\returns the parsed `int`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_atof\n\\sa SDL_strtol\n\\sa SDL_strtoul\n\\sa SDL_strtoll\n\\sa SDL_strtoull\n\\sa SDL_strtod\n\\sa SDL_itoa",
          "name": "SDL_atoi",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "str",
              "type": "const char *"
            }
          ]
        },
        "SDL_atof": {
          "doc": "Parse a `double` from a string.\n\nThe result of calling `SDL_atof(str)` is equivalent to `SDL_strtod(str,\nNULL)`.\n\n\\param str The null-terminated string to read. Must not be NULL.\n\\returns the parsed `double`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_atoi\n\\sa SDL_strtol\n\\sa SDL_strtoul\n\\sa SDL_strtoll\n\\sa SDL_strtoull\n\\sa SDL_strtod",
          "name": "SDL_atof",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "str",
              "type": "const char *"
            }
          ]
        },
        "SDL_strtol": {
          "doc": "Parse a `long` from a string.\n\nIf `str` starts with whitespace, then those whitespace characters are\nskipped before attempting to parse the number.\n\nIf the parsed number does not fit inside a `long`, the result is clamped to\nthe minimum and maximum representable `long` values.\n\n\\param str The null-terminated string to read. Must not be NULL.\n\\param endp If not NULL, the address of the first invalid character (i.e.\n            the next character after the parsed number) will be written to\n            this pointer.\n\\param base The base of the integer to read. Supported values are 0 and 2\n            to 36 inclusive. If 0, the base will be inferred from the\n            number's prefix (0x for hexadecimal, 0 for octal, decimal\n            otherwise).\n\\returns the parsed `long`, or 0 if no number could be parsed.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_atoi\n\\sa SDL_atof\n\\sa SDL_strtoul\n\\sa SDL_strtoll\n\\sa SDL_strtoull\n\\sa SDL_strtod\n\\sa SDL_ltoa\n\\sa SDL_wcstol",
          "name": "SDL_strtol",
          "kind": "function",
          "type": "long",
          "parameters": [
            {
              "name": "str",
              "type": "const char *"
            },
            {
              "name": "endp",
              "type": "char **"
            },
            {
              "name": "base",
              "type": "int"
            }
          ]
        },
        "SDL_strtoul": {
          "doc": "Parse an `unsigned long` from a string.\n\nIf `str` starts with whitespace, then those whitespace characters are\nskipped before attempting to parse the number.\n\nIf the parsed number does not fit inside an `unsigned long`, the result is\nclamped to the maximum representable `unsigned long` value.\n\n\\param str The null-terminated string to read. Must not be NULL.\n\\param endp If not NULL, the address of the first invalid character (i.e.\n            the next character after the parsed number) will be written to\n            this pointer.\n\\param base The base of the integer to read. Supported values are 0 and 2\n            to 36 inclusive. If 0, the base will be inferred from the\n            number's prefix (0x for hexadecimal, 0 for octal, decimal\n            otherwise).\n\\returns the parsed `unsigned long`, or 0 if no number could be parsed.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_atoi\n\\sa SDL_atof\n\\sa SDL_strtol\n\\sa SDL_strtoll\n\\sa SDL_strtoull\n\\sa SDL_strtod\n\\sa SDL_ultoa",
          "name": "SDL_strtoul",
          "kind": "function",
          "type": "unsigned long",
          "parameters": [
            {
              "name": "str",
              "type": "const char *"
            },
            {
              "name": "endp",
              "type": "char **"
            },
            {
              "name": "base",
              "type": "int"
            }
          ]
        },
        "SDL_strtoll": {
          "doc": "Parse a `long long` from a string.\n\nIf `str` starts with whitespace, then those whitespace characters are\nskipped before attempting to parse the number.\n\nIf the parsed number does not fit inside a `long long`, the result is\nclamped to the minimum and maximum representable `long long` values.\n\n\\param str The null-terminated string to read. Must not be NULL.\n\\param endp If not NULL, the address of the first invalid character (i.e.\n            the next character after the parsed number) will be written to\n            this pointer.\n\\param base The base of the integer to read. Supported values are 0 and 2\n            to 36 inclusive. If 0, the base will be inferred from the\n            number's prefix (0x for hexadecimal, 0 for octal, decimal\n            otherwise).\n\\returns the parsed `long long`, or 0 if no number could be parsed.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_atoi\n\\sa SDL_atof\n\\sa SDL_strtol\n\\sa SDL_strtoul\n\\sa SDL_strtoull\n\\sa SDL_strtod\n\\sa SDL_lltoa",
          "name": "SDL_strtoll",
          "kind": "function",
          "type": "long long",
          "parameters": [
            {
              "name": "str",
              "type": "const char *"
            },
            {
              "name": "endp",
              "type": "char **"
            },
            {
              "name": "base",
              "type": "int"
            }
          ]
        },
        "SDL_strtoull": {
          "doc": "Parse an `unsigned long long` from a string.\n\nIf `str` starts with whitespace, then those whitespace characters are\nskipped before attempting to parse the number.\n\nIf the parsed number does not fit inside an `unsigned long long`, the\nresult is clamped to the maximum representable `unsigned long long` value.\n\n\\param str The null-terminated string to read. Must not be NULL.\n\\param endp If not NULL, the address of the first invalid character (i.e.\n            the next character after the parsed number) will be written to\n            this pointer.\n\\param base The base of the integer to read. Supported values are 0 and 2\n            to 36 inclusive. If 0, the base will be inferred from the\n            number's prefix (0x for hexadecimal, 0 for octal, decimal\n            otherwise).\n\\returns the parsed `unsigned long long`, or 0 if no number could be\n         parsed.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_atoi\n\\sa SDL_atof\n\\sa SDL_strtol\n\\sa SDL_strtoll\n\\sa SDL_strtoul\n\\sa SDL_strtod\n\\sa SDL_ulltoa",
          "name": "SDL_strtoull",
          "kind": "function",
          "type": "unsigned long long",
          "parameters": [
            {
              "name": "str",
              "type": "const char *"
            },
            {
              "name": "endp",
              "type": "char **"
            },
            {
              "name": "base",
              "type": "int"
            }
          ]
        },
        "SDL_strtod": {
          "doc": "Parse a `double` from a string.\n\nThis function makes fewer guarantees than the C runtime `strtod`:\n\n- Only decimal notation is guaranteed to be supported. The handling of\n  scientific and hexadecimal notation is unspecified.\n- Whether or not INF and NAN can be parsed is unspecified.\n- The precision of the result is unspecified.\n\n\\param str the null-terminated string to read. Must not be NULL.\n\\param endp if not NULL, the address of the first invalid character (i.e.\n            the next character after the parsed number) will be written to\n            this pointer.\n\\returns the parsed `double`, or 0 if no number could be parsed.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_atoi\n\\sa SDL_atof\n\\sa SDL_strtol\n\\sa SDL_strtoll\n\\sa SDL_strtoul\n\\sa SDL_strtoull",
          "name": "SDL_strtod",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "str",
              "type": "const char *"
            },
            {
              "name": "endp",
              "type": "char **"
            }
          ]
        },
        "SDL_strcmp": {
          "doc": "Compare two null-terminated UTF-8 strings.\n\nDue to the nature of UTF-8 encoding, this will work with Unicode strings,\nsince effectively this function just compares bytes until it hits a\nnull-terminating character. Also due to the nature of UTF-8, this can be\nused with SDL_qsort() to put strings in (roughly) alphabetical order.\n\n\\param str1 the first string to compare. NULL is not permitted!\n\\param str2 the second string to compare. NULL is not permitted!\n\\returns less than zero if str1 is \"less than\" str2, greater than zero if\n         str1 is \"greater than\" str2, and zero if the strings match\n         exactly.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_strcmp",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "str1",
              "type": "const char *"
            },
            {
              "name": "str2",
              "type": "const char *"
            }
          ]
        },
        "SDL_strncmp": {
          "doc": "Compare two UTF-8 strings up to a number of bytes.\n\nDue to the nature of UTF-8 encoding, this will work with Unicode strings,\nsince effectively this function just compares bytes until it hits a\nnull-terminating character. Also due to the nature of UTF-8, this can be\nused with SDL_qsort() to put strings in (roughly) alphabetical order.\n\nNote that while this function is intended to be used with UTF-8, it is\ndoing a bytewise comparison, and `maxlen` specifies a _byte_ limit! If the\nlimit lands in the middle of a multi-byte UTF-8 sequence, it will only\ncompare a portion of the final character.\n\n`maxlen` specifies a maximum number of bytes to compare; if the strings\nmatch to this number of bytes (or both have matched to a null-terminator\ncharacter before this number of bytes), they will be considered equal.\n\n\\param str1 the first string to compare. NULL is not permitted!\n\\param str2 the second string to compare. NULL is not permitted!\n\\param maxlen the maximum number of _bytes_ to compare.\n\\returns less than zero if str1 is \"less than\" str2, greater than zero if\n         str1 is \"greater than\" str2, and zero if the strings match\n         exactly.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_strncmp",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "str1",
              "type": "const char *"
            },
            {
              "name": "str2",
              "type": "const char *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ]
        },
        "SDL_strcasecmp": {
          "doc": "Compare two null-terminated UTF-8 strings, case-insensitively.\n\nThis will work with Unicode strings, using a technique called\n\"case-folding\" to handle the vast majority of case-sensitive human\nlanguages regardless of system locale. It can deal with expanding values: a\nGerman Eszett character can compare against two ASCII 's' chars and be\nconsidered a match, for example. A notable exception: it does not handle\nthe Turkish 'i' character; human language is complicated!\n\nSince this handles Unicode, it expects the string to be well-formed UTF-8\nand not a null-terminated string of arbitrary bytes. Bytes that are not\nvalid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT\nCHARACTER), which is to say two strings of random bits may turn out to\nmatch if they convert to the same amount of replacement characters.\n\n\\param str1 the first string to compare. NULL is not permitted!\n\\param str2 the second string to compare. NULL is not permitted!\n\\returns less than zero if str1 is \"less than\" str2, greater than zero if\n         str1 is \"greater than\" str2, and zero if the strings match\n         exactly.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_strcasecmp",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "str1",
              "type": "const char *"
            },
            {
              "name": "str2",
              "type": "const char *"
            }
          ]
        },
        "SDL_strncasecmp": {
          "doc": "Compare two UTF-8 strings, case-insensitively, up to a number of bytes.\n\nThis will work with Unicode strings, using a technique called\n\"case-folding\" to handle the vast majority of case-sensitive human\nlanguages regardless of system locale. It can deal with expanding values: a\nGerman Eszett character can compare against two ASCII 's' chars and be\nconsidered a match, for example. A notable exception: it does not handle\nthe Turkish 'i' character; human language is complicated!\n\nSince this handles Unicode, it expects the string to be well-formed UTF-8\nand not a null-terminated string of arbitrary bytes. Bytes that are not\nvalid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT\nCHARACTER), which is to say two strings of random bits may turn out to\nmatch if they convert to the same amount of replacement characters.\n\nNote that while this function is intended to be used with UTF-8, `maxlen`\nspecifies a _byte_ limit! If the limit lands in the middle of a multi-byte\nUTF-8 sequence, it may convert a portion of the final character to one or\nmore Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not to overflow\na buffer.\n\n`maxlen` specifies a maximum number of bytes to compare; if the strings\nmatch to this number of bytes (or both have matched to a null-terminator\ncharacter before this number of bytes), they will be considered equal.\n\n\\param str1 the first string to compare. NULL is not permitted!\n\\param str2 the second string to compare. NULL is not permitted!\n\\param maxlen the maximum number of bytes to compare.\n\\returns less than zero if str1 is \"less than\" str2, greater than zero if\n         str1 is \"greater than\" str2, and zero if the strings match\n         exactly.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_strncasecmp",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "str1",
              "type": "const char *"
            },
            {
              "name": "str2",
              "type": "const char *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ]
        },
        "SDL_strpbrk": {
          "doc": "Searches a string for the first occurence of any character contained in a\nbreakset, and returns a pointer from the string to that character.\n\n\\param str The null-terminated string to be searched. Must not be NULL, and\n           must not overlap with `breakset`.\n\\param breakset A null-terminated string containing the list of characters\n                to look for. Must not be NULL, and must not overlap with\n                `str`.\n\\returns A pointer to the location, in str, of the first occurence of a\n         character present in the breakset, or NULL if none is found.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_strpbrk",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "str",
              "type": "const char *"
            },
            {
              "name": "breakset",
              "type": "const char *"
            }
          ]
        },
        "SDL_INVALID_UNICODE_CODEPOINT": {
          "doc": "The Unicode REPLACEMENT CHARACTER codepoint.\n\nSDL_StepUTF8() and SDL_StepBackUTF8() report this codepoint when they\nencounter a UTF-8 string with encoding errors.\n\nThis tends to render as something like a question mark in most places.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_StepBackUTF8\n\\sa SDL_StepUTF8",
          "name": "SDL_INVALID_UNICODE_CODEPOINT",
          "kind": "def"
        },
        "SDL_StepUTF8": {
          "doc": "Decode a UTF-8 string, one Unicode codepoint at a time.\n\nThis will return the first Unicode codepoint in the UTF-8 encoded string in\n`*pstr`, and then advance `*pstr` past any consumed bytes before returning.\n\nIt will not access more than `*pslen` bytes from the string. `*pslen` will\nbe adjusted, as well, subtracting the number of bytes consumed.\n\n`pslen` is allowed to be NULL, in which case the string _must_ be\nNULL-terminated, as the function will blindly read until it sees the NULL\nchar.\n\nif `*pslen` is zero, it assumes the end of string is reached and returns a\nzero codepoint regardless of the contents of the string buffer.\n\nIf the resulting codepoint is zero (a NULL terminator), or `*pslen` is\nzero, it will not advance `*pstr` or `*pslen` at all.\n\nGenerally this function is called in a loop until it returns zero,\nadjusting its parameters each iteration.\n\nIf an invalid UTF-8 sequence is encountered, this function returns\nSDL_INVALID_UNICODE_CODEPOINT and advances the string/length by one byte\n(which is to say, a multibyte sequence might produce several\nSDL_INVALID_UNICODE_CODEPOINT returns before it syncs to the next valid\nUTF-8 sequence).\n\nSeveral things can generate invalid UTF-8 sequences, including overlong\nencodings, the use of UTF-16 surrogate values, and truncated data. Please\nrefer to\n[RFC3629](https://www.ietf.org/rfc/rfc3629.txt)\nfor details.\n\n\\param pstr a pointer to a UTF-8 string pointer to be read and adjusted.\n\\param pslen a pointer to the number of bytes in the string, to be read and\n             adjusted. NULL is allowed.\n\\returns the first Unicode codepoint in the string.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_StepUTF8",
          "kind": "function",
          "type": "Uint32",
          "parameters": [
            {
              "name": "pstr",
              "type": "const char **"
            },
            {
              "name": "pslen",
              "type": "size_t *"
            }
          ]
        },
        "SDL_StepBackUTF8": {
          "doc": "Decode a UTF-8 string in reverse, one Unicode codepoint at a time.\n\nThis will go to the start of the previous Unicode codepoint in the string,\nmove `*pstr` to that location and return that codepoint.\n\nIf `*pstr` is already at the start of the string), it will not advance\n`*pstr` at all.\n\nGenerally this function is called in a loop until it returns zero,\nadjusting its parameter each iteration.\n\nIf an invalid UTF-8 sequence is encountered, this function returns\nSDL_INVALID_UNICODE_CODEPOINT.\n\nSeveral things can generate invalid UTF-8 sequences, including overlong\nencodings, the use of UTF-16 surrogate values, and truncated data. Please\nrefer to\n[RFC3629](https://www.ietf.org/rfc/rfc3629.txt)\nfor details.\n\n\\param start a pointer to the beginning of the UTF-8 string.\n\\param pstr a pointer to a UTF-8 string pointer to be read and adjusted.\n\\returns the previous Unicode codepoint in the string.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_StepBackUTF8",
          "kind": "function",
          "type": "Uint32",
          "parameters": [
            {
              "name": "start",
              "type": "const char *"
            },
            {
              "name": "pstr",
              "type": "const char **"
            }
          ]
        },
        "SDL_UCS4ToUTF8": {
          "doc": "Convert a single Unicode codepoint to UTF-8.\n\nThe buffer pointed to by `dst` must be at least 4 bytes long, as this\nfunction may generate between 1 and 4 bytes of output.\n\nThis function returns the first byte _after_ the newly-written UTF-8\nsequence, which is useful for encoding multiple codepoints in a loop, or\nknowing where to write a NULL-terminator character to end the string (in\neither case, plan to have a buffer of _more_ than 4 bytes!).\n\nIf `codepoint` is an invalid value (outside the Unicode range, or a UTF-16\nsurrogate value, etc), this will use U+FFFD (REPLACEMENT CHARACTER) for the\ncodepoint instead, and not set an error.\n\nIf `dst` is NULL, this returns NULL immediately without writing to the\npointer and without setting an error.\n\n\\param codepoint a Unicode codepoint to convert to UTF-8.\n\\param dst the location to write the encoded UTF-8. Must point to at least\n           4 bytes!\n\\returns the first byte past the newly-written UTF-8 sequence.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_UCS4ToUTF8",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "codepoint",
              "type": "Uint32"
            },
            {
              "name": "dst",
              "type": "char *"
            }
          ]
        },
        "SDL_sscanf": {
          "doc": "This works exactly like sscanf() but doesn't require access to a C runtime.\n\nScan a string, matching a format string, converting each '%' item and\nstoring it to pointers provided through variable arguments.\n\n\\param text the string to scan. Must not be NULL.\n\\param fmt a printf-style format string. Must not be NULL.\n\\param ... a list of pointers to values to be filled in with scanned items.\n\\returns the number of items that matched the format string.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_sscanf",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "text",
              "type": "const char *"
            },
            {
              "name": "fmt",
              "type": "SDL_SCANF_FORMAT_STRING const char *"
            },
            "..."
          ]
        },
        "SDL_vsscanf": {
          "doc": "This works exactly like vsscanf() but doesn't require access to a C\nruntime.\n\nFunctions identically to SDL_sscanf(), except it takes a `va_list` instead\nof using `...` variable arguments.\n\n\\param text the string to scan. Must not be NULL.\n\\param fmt a printf-style format string. Must not be NULL.\n\\param ap a `va_list` of pointers to values to be filled in with scanned\n          items.\n\\returns the number of items that matched the format string.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_vsscanf",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "text",
              "type": "const char *"
            },
            {
              "name": "fmt",
              "type": "SDL_SCANF_FORMAT_STRING const char *"
            },
            {
              "name": "ap",
              "type": "va_list"
            }
          ]
        },
        "SDL_snprintf": {
          "doc": "This works exactly like snprintf() but doesn't require access to a C\nruntime.\n\nFormat a string of up to `maxlen`-1 bytes, converting each '%' item with\nvalues provided through variable arguments.\n\nWhile some C runtimes differ on how to deal with too-large strings, this\nfunction null-terminates the output, by treating the null-terminator as\npart of the `maxlen` count. Note that if `maxlen` is zero, however, no\nbytes will be written at all.\n\nThis function returns the number of _bytes_ (not _characters_) that should\nbe written, excluding the null-terminator character. If this returns a\nnumber >= `maxlen`, it means the output string was truncated. A negative\nreturn value means an error occurred.\n\nReferencing the output string's pointer with a format item is undefined\nbehavior.\n\n\\param text the buffer to write the string into. Must not be NULL.\n\\param maxlen the maximum bytes to write, including the null-terminator.\n\\param fmt a printf-style format string. Must not be NULL.\n\\param ... a list of values to be used with the format string.\n\\returns the number of bytes that should be written, not counting the\n         null-terminator char, or a negative value on error.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_snprintf",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "text",
              "type": "char *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            },
            {
              "name": "fmt",
              "type": "SDL_PRINTF_FORMAT_STRING const char *"
            },
            "..."
          ]
        },
        "SDL_swprintf": {
          "doc": "This works exactly like swprintf() but doesn't require access to a C\nruntime.\n\nFormat a wide string of up to `maxlen`-1 wchar_t values, converting each\n'%' item with values provided through variable arguments.\n\nWhile some C runtimes differ on how to deal with too-large strings, this\nfunction null-terminates the output, by treating the null-terminator as\npart of the `maxlen` count. Note that if `maxlen` is zero, however, no wide\ncharacters will be written at all.\n\nThis function returns the number of _wide characters_ (not _codepoints_)\nthat should be written, excluding the null-terminator character. If this\nreturns a number >= `maxlen`, it means the output string was truncated. A\nnegative return value means an error occurred.\n\nReferencing the output string's pointer with a format item is undefined\nbehavior.\n\n\\param text the buffer to write the wide string into. Must not be NULL.\n\\param maxlen the maximum wchar_t values to write, including the\n              null-terminator.\n\\param fmt a printf-style format string. Must not be NULL.\n\\param ... a list of values to be used with the format string.\n\\returns the number of wide characters that should be written, not counting\n         the null-terminator char, or a negative value on error.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_swprintf",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "text",
              "type": "wchar_t *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            },
            {
              "name": "fmt",
              "type": "SDL_PRINTF_FORMAT_STRING const wchar_t *"
            },
            "..."
          ]
        },
        "SDL_vsnprintf": {
          "doc": "This works exactly like vsnprintf() but doesn't require access to a C\nruntime.\n\nFunctions identically to SDL_snprintf(), except it takes a `va_list`\ninstead of using `...` variable arguments.\n\n\\param text the buffer to write the string into. Must not be NULL.\n\\param maxlen the maximum bytes to write, including the null-terminator.\n\\param fmt a printf-style format string. Must not be NULL.\n\\param ap a `va_list` values to be used with the format string.\n\\returns the number of bytes that should be written, not counting the\n         null-terminator char, or a negative value on error.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_vsnprintf",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "text",
              "type": "char *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            },
            {
              "name": "fmt",
              "type": "SDL_PRINTF_FORMAT_STRING const char *"
            },
            {
              "name": "ap",
              "type": "va_list"
            }
          ]
        },
        "SDL_vswprintf": {
          "doc": "This works exactly like vswprintf() but doesn't require access to a C\nruntime.\n\nFunctions identically to SDL_swprintf(), except it takes a `va_list`\ninstead of using `...` variable arguments.\n\n\\param text the buffer to write the string into. Must not be NULL.\n\\param maxlen the maximum wide characters to write, including the\n              null-terminator.\n\\param fmt a printf-style format wide string. Must not be NULL.\n\\param ap a `va_list` values to be used with the format string.\n\\returns the number of wide characters that should be written, not counting\n         the null-terminator char, or a negative value on error.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_vswprintf",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "text",
              "type": "wchar_t *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            },
            {
              "name": "fmt",
              "type": "SDL_PRINTF_FORMAT_STRING const wchar_t *"
            },
            {
              "name": "ap",
              "type": "va_list"
            }
          ]
        },
        "SDL_asprintf": {
          "doc": "This works exactly like asprintf() but doesn't require access to a C\nruntime.\n\nFunctions identically to SDL_snprintf(), except it allocates a buffer large\nenough to hold the output string on behalf of the caller.\n\nOn success, this function returns the number of bytes (not characters)\ncomprising the output string, not counting the null-terminator character,\nand sets `*strp` to the newly-allocated string.\n\nOn error, this function returns a negative number, and the value of `*strp`\nis undefined.\n\nThe returned string is owned by the caller, and should be passed to\nSDL_free when no longer needed.\n\n\\param strp on output, is set to the new string. Must not be NULL.\n\\param fmt a printf-style format string. Must not be NULL.\n\\param ... a list of values to be used with the format string.\n\\returns the number of bytes in the newly-allocated string, not counting\n         the null-terminator char, or a negative value on error.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_asprintf",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "strp",
              "type": "char **"
            },
            {
              "name": "fmt",
              "type": "SDL_PRINTF_FORMAT_STRING const char *"
            },
            "..."
          ]
        },
        "SDL_vasprintf": {
          "doc": "This works exactly like vasprintf() but doesn't require access to a C\nruntime.\n\nFunctions identically to SDL_asprintf(), except it takes a `va_list`\ninstead of using `...` variable arguments.\n\n\\param strp on output, is set to the new string. Must not be NULL.\n\\param fmt a printf-style format string. Must not be NULL.\n\\param ap a `va_list` values to be used with the format string.\n\\returns the number of bytes in the newly-allocated string, not counting\n         the null-terminator char, or a negative value on error.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_vasprintf",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "strp",
              "type": "char **"
            },
            {
              "name": "fmt",
              "type": "SDL_PRINTF_FORMAT_STRING const char *"
            },
            {
              "name": "ap",
              "type": "va_list"
            }
          ]
        },
        "SDL_srand": {
          "doc": "Seeds the pseudo-random number generator.\n\nReusing the seed number will cause SDL_rand_*() to repeat the same stream\nof 'random' numbers.\n\n\\param seed the value to use as a random number seed, or 0 to use\n            SDL_GetPerformanceCounter().\n\n\\threadsafety This should be called on the same thread that calls\n              SDL_rand*()\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_rand\n\\sa SDL_rand_bits\n\\sa SDL_randf",
          "name": "SDL_srand",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "seed",
              "type": "Uint64"
            }
          ]
        },
        "SDL_rand": {
          "doc": "Generate a pseudo-random number less than n for positive n\n\nThe method used is faster and of better quality than `rand() % n`. Odds are\nroughly 99.9% even for n = 1 million. Evenness is better for smaller n, and\nmuch worse as n gets bigger.\n\nExample: to simulate a d6 use `SDL_rand(6) + 1` The +1 converts 0..5 to\n1..6\n\nIf you want to generate a pseudo-random number in the full range of Sint32,\nyou should use: (Sint32)SDL_rand_bits()\n\nIf you want reproducible output, be sure to initialize with SDL_srand()\nfirst.\n\nThere are no guarantees as to the quality of the random sequence produced,\nand this should not be used for security (cryptography, passwords) or where\nmoney is on the line (loot-boxes, casinos). There are many random number\nlibraries available with different characteristics and you should pick one\nof those to meet any serious needs.\n\n\\param n the number of possible outcomes. n must be positive.\n\\returns a random value in the range of [0 .. n-1].\n\n\\threadsafety All calls should be made from a single thread\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_srand\n\\sa SDL_randf",
          "name": "SDL_rand",
          "kind": "function",
          "type": "Sint32",
          "parameters": [
            {
              "name": "n",
              "type": "Sint32"
            }
          ]
        },
        "SDL_randf": {
          "doc": "Generate a uniform pseudo-random floating point number less than 1.0\n\nIf you want reproducible output, be sure to initialize with SDL_srand()\nfirst.\n\nThere are no guarantees as to the quality of the random sequence produced,\nand this should not be used for security (cryptography, passwords) or where\nmoney is on the line (loot-boxes, casinos). There are many random number\nlibraries available with different characteristics and you should pick one\nof those to meet any serious needs.\n\n\\returns a random value in the range of [0.0, 1.0).\n\n\\threadsafety All calls should be made from a single thread\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_srand\n\\sa SDL_rand",
          "name": "SDL_randf",
          "kind": "function",
          "type": "float",
          "parameters": []
        },
        "SDL_rand_bits": {
          "doc": "Generate 32 pseudo-random bits.\n\nYou likely want to use SDL_rand() to get a psuedo-random number instead.\n\nThere are no guarantees as to the quality of the random sequence produced,\nand this should not be used for security (cryptography, passwords) or where\nmoney is on the line (loot-boxes, casinos). There are many random number\nlibraries available with different characteristics and you should pick one\nof those to meet any serious needs.\n\n\\returns a random value in the range of [0-SDL_MAX_UINT32].\n\n\\threadsafety All calls should be made from a single thread\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_rand\n\\sa SDL_randf\n\\sa SDL_srand",
          "name": "SDL_rand_bits",
          "kind": "function",
          "type": "Uint32",
          "parameters": []
        },
        "SDL_rand_r": {
          "doc": "Generate a pseudo-random number less than n for positive n\n\nThe method used is faster and of better quality than `rand() % n`. Odds are\nroughly 99.9% even for n = 1 million. Evenness is better for smaller n, and\nmuch worse as n gets bigger.\n\nExample: to simulate a d6 use `SDL_rand_r(state, 6) + 1` The +1 converts\n0..5 to 1..6\n\nIf you want to generate a pseudo-random number in the full range of Sint32,\nyou should use: (Sint32)SDL_rand_bits_r(state)\n\nThere are no guarantees as to the quality of the random sequence produced,\nand this should not be used for security (cryptography, passwords) or where\nmoney is on the line (loot-boxes, casinos). There are many random number\nlibraries available with different characteristics and you should pick one\nof those to meet any serious needs.\n\n\\param state a pointer to the current random number state, this may not be\n             NULL.\n\\param n the number of possible outcomes. n must be positive.\n\\returns a random value in the range of [0 .. n-1].\n\n\\threadsafety This function is thread-safe, as long as the state pointer\n              isn't shared between threads.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_rand\n\\sa SDL_rand_bits_r\n\\sa SDL_randf_r",
          "name": "SDL_rand_r",
          "kind": "function",
          "type": "Sint32",
          "parameters": [
            {
              "name": "state",
              "type": "Uint64 *"
            },
            {
              "name": "n",
              "type": "Sint32"
            }
          ]
        },
        "SDL_randf_r": {
          "doc": "Generate a uniform pseudo-random floating point number less than 1.0\n\nIf you want reproducible output, be sure to initialize with SDL_srand()\nfirst.\n\nThere are no guarantees as to the quality of the random sequence produced,\nand this should not be used for security (cryptography, passwords) or where\nmoney is on the line (loot-boxes, casinos). There are many random number\nlibraries available with different characteristics and you should pick one\nof those to meet any serious needs.\n\n\\param state a pointer to the current random number state, this may not be\n             NULL.\n\\returns a random value in the range of [0.0, 1.0).\n\n\\threadsafety This function is thread-safe, as long as the state pointer\n              isn't shared between threads.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_rand_bits_r\n\\sa SDL_rand_r\n\\sa SDL_randf",
          "name": "SDL_randf_r",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "state",
              "type": "Uint64 *"
            }
          ]
        },
        "SDL_rand_bits_r": {
          "doc": "Generate 32 pseudo-random bits.\n\nYou likely want to use SDL_rand_r() to get a psuedo-random number instead.\n\nThere are no guarantees as to the quality of the random sequence produced,\nand this should not be used for security (cryptography, passwords) or where\nmoney is on the line (loot-boxes, casinos). There are many random number\nlibraries available with different characteristics and you should pick one\nof those to meet any serious needs.\n\n\\param state a pointer to the current random number state, this may not be\n             NULL.\n\\returns a random value in the range of [0-SDL_MAX_UINT32].\n\n\\threadsafety This function is thread-safe, as long as the state pointer\n              isn't shared between threads.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_rand_r\n\\sa SDL_randf_r",
          "name": "SDL_rand_bits_r",
          "kind": "function",
          "type": "Uint32",
          "parameters": [
            {
              "name": "state",
              "type": "Uint64 *"
            }
          ]
        },
        "SDL_PI_D": {
          "doc": "The value of Pi, as a double-precision floating point literal.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_PI_F",
          "name": "SDL_PI_D",
          "kind": "def"
        },
        "SDL_PI_F": {
          "doc": "The value of Pi, as a single-precision floating point literal.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_PI_D",
          "name": "SDL_PI_F",
          "kind": "def"
        },
        "SDL_acos": {
          "doc": "Compute the arc cosine of `x`.\n\nThe definition of `y = acos(x)` is `x = cos(y)`.\n\nDomain: `-1 <= x <= 1`\n\nRange: `0 <= y <= Pi`\n\nThis function operates on double-precision floating point values, use\nSDL_acosf for single-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param x floating point value.\n\\returns arc cosine of `x`, in radians.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_acosf\n\\sa SDL_asin\n\\sa SDL_cos",
          "name": "SDL_acos",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ]
        },
        "SDL_acosf": {
          "doc": "Compute the arc cosine of `x`.\n\nThe definition of `y = acos(x)` is `x = cos(y)`.\n\nDomain: `-1 <= x <= 1`\n\nRange: `0 <= y <= Pi`\n\nThis function operates on single-precision floating point values, use\nSDL_acos for double-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param x floating point value.\n\\returns arc cosine of `x`, in radians.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_acos\n\\sa SDL_asinf\n\\sa SDL_cosf",
          "name": "SDL_acosf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ]
        },
        "SDL_asin": {
          "doc": "Compute the arc sine of `x`.\n\nThe definition of `y = asin(x)` is `x = sin(y)`.\n\nDomain: `-1 <= x <= 1`\n\nRange: `-Pi/2 <= y <= Pi/2`\n\nThis function operates on double-precision floating point values, use\nSDL_asinf for single-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param x floating point value.\n\\returns arc sine of `x`, in radians.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_asinf\n\\sa SDL_acos\n\\sa SDL_sin",
          "name": "SDL_asin",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ]
        },
        "SDL_asinf": {
          "doc": "Compute the arc sine of `x`.\n\nThe definition of `y = asin(x)` is `x = sin(y)`.\n\nDomain: `-1 <= x <= 1`\n\nRange: `-Pi/2 <= y <= Pi/2`\n\nThis function operates on single-precision floating point values, use\nSDL_asin for double-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param x floating point value.\n\\returns arc sine of `x`, in radians.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_asin\n\\sa SDL_acosf\n\\sa SDL_sinf",
          "name": "SDL_asinf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ]
        },
        "SDL_atan": {
          "doc": "Compute the arc tangent of `x`.\n\nThe definition of `y = atan(x)` is `x = tan(y)`.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-Pi/2 <= y <= Pi/2`\n\nThis function operates on double-precision floating point values, use\nSDL_atanf for single-precision floats.\n\nTo calculate the arc tangent of y / x, use SDL_atan2.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param x floating point value.\n\\returns arc tangent of of `x` in radians, or 0 if `x = 0`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_atanf\n\\sa SDL_atan2\n\\sa SDL_tan",
          "name": "SDL_atan",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ]
        },
        "SDL_atanf": {
          "doc": "Compute the arc tangent of `x`.\n\nThe definition of `y = atan(x)` is `x = tan(y)`.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-Pi/2 <= y <= Pi/2`\n\nThis function operates on single-precision floating point values, use\nSDL_atan for dboule-precision floats.\n\nTo calculate the arc tangent of y / x, use SDL_atan2f.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param x floating point value.\n\\returns arc tangent of of `x` in radians, or 0 if `x = 0`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_atan\n\\sa SDL_atan2f\n\\sa SDL_tanf",
          "name": "SDL_atanf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ]
        },
        "SDL_atan2": {
          "doc": "Compute the arc tangent of `y / x`, using the signs of x and y to adjust\nthe result's quadrant.\n\nThe definition of `z = atan2(x, y)` is `y = x tan(z)`, where the quadrant\nof z is determined based on the signs of x and y.\n\nDomain: `-INF <= x <= INF`, `-INF <= y <= INF`\n\nRange: `-Pi/2 <= y <= Pi/2`\n\nThis function operates on double-precision floating point values, use\nSDL_atan2f for single-precision floats.\n\nTo calculate the arc tangent of a single value, use SDL_atan.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param y floating point value of the numerator (y coordinate).\n\\param x floating point value of the denominator (x coordinate).\n\\returns arc tangent of of `y / x` in radians, or, if `x = 0`, either\n         `-Pi/2`, `0`, or `Pi/2`, depending on the value of `y`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_atan2f\n\\sa SDL_atan\n\\sa SDL_tan",
          "name": "SDL_atan2",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "y",
              "type": "double"
            },
            {
              "name": "x",
              "type": "double"
            }
          ]
        },
        "SDL_atan2f": {
          "doc": "Compute the arc tangent of `y / x`, using the signs of x and y to adjust\nthe result's quadrant.\n\nThe definition of `z = atan2(x, y)` is `y = x tan(z)`, where the quadrant\nof z is determined based on the signs of x and y.\n\nDomain: `-INF <= x <= INF`, `-INF <= y <= INF`\n\nRange: `-Pi/2 <= y <= Pi/2`\n\nThis function operates on single-precision floating point values, use\nSDL_atan2 for double-precision floats.\n\nTo calculate the arc tangent of a single value, use SDL_atanf.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param y floating point value of the numerator (y coordinate).\n\\param x floating point value of the denominator (x coordinate).\n\\returns arc tangent of of `y / x` in radians, or, if `x = 0`, either\n         `-Pi/2`, `0`, or `Pi/2`, depending on the value of `y`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_atan2f\n\\sa SDL_atan\n\\sa SDL_tan",
          "name": "SDL_atan2f",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "y",
              "type": "float"
            },
            {
              "name": "x",
              "type": "float"
            }
          ]
        },
        "SDL_ceil": {
          "doc": "Compute the ceiling of `x`.\n\nThe ceiling of `x` is the smallest integer `y` such that `y > x`, i.e `x`\nrounded up to the nearest integer.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-INF <= y <= INF`, y integer\n\nThis function operates on double-precision floating point values, use\nSDL_ceilf for single-precision floats.\n\n\\param x floating point value.\n\\returns the ceiling of `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_ceilf\n\\sa SDL_floor\n\\sa SDL_trunc\n\\sa SDL_round\n\\sa SDL_lround",
          "name": "SDL_ceil",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ]
        },
        "SDL_ceilf": {
          "doc": "Compute the ceiling of `x`.\n\nThe ceiling of `x` is the smallest integer `y` such that `y > x`, i.e `x`\nrounded up to the nearest integer.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-INF <= y <= INF`, y integer\n\nThis function operates on single-precision floating point values, use\nSDL_ceil for double-precision floats.\n\n\\param x floating point value.\n\\returns the ceiling of `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_ceil\n\\sa SDL_floorf\n\\sa SDL_truncf\n\\sa SDL_roundf\n\\sa SDL_lroundf",
          "name": "SDL_ceilf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ]
        },
        "SDL_copysign": {
          "doc": "Copy the sign of one floating-point value to another.\n\nThe definition of copysign is that ``copysign(x, y) = abs(x) * sign(y)``.\n\nDomain: `-INF <= x <= INF`, ``-INF <= y <= f``\n\nRange: `-INF <= z <= INF`\n\nThis function operates on double-precision floating point values, use\nSDL_copysignf for single-precision floats.\n\n\\param x floating point value to use as the magnitude.\n\\param y floating point value to use as the sign.\n\\returns the floating point value with the sign of y and the magnitude of\n         x.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_copysignf\n\\sa SDL_fabs",
          "name": "SDL_copysign",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            },
            {
              "name": "y",
              "type": "double"
            }
          ]
        },
        "SDL_copysignf": {
          "doc": "Copy the sign of one floating-point value to another.\n\nThe definition of copysign is that ``copysign(x, y) = abs(x) * sign(y)``.\n\nDomain: `-INF <= x <= INF`, ``-INF <= y <= f``\n\nRange: `-INF <= z <= INF`\n\nThis function operates on single-precision floating point values, use\nSDL_copysign for double-precision floats.\n\n\\param x floating point value to use as the magnitude.\n\\param y floating point value to use as the sign.\n\\returns the floating point value with the sign of y and the magnitude of\n         x.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_copysignf\n\\sa SDL_fabsf",
          "name": "SDL_copysignf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            },
            {
              "name": "y",
              "type": "float"
            }
          ]
        },
        "SDL_cos": {
          "doc": "Compute the cosine of `x`.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-1 <= y <= 1`\n\nThis function operates on double-precision floating point values, use\nSDL_cosf for single-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param x floating point value, in radians.\n\\returns cosine of `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_cosf\n\\sa SDL_acos\n\\sa SDL_sin",
          "name": "SDL_cos",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ]
        },
        "SDL_cosf": {
          "doc": "Compute the cosine of `x`.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-1 <= y <= 1`\n\nThis function operates on single-precision floating point values, use\nSDL_cos for double-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param x floating point value, in radians.\n\\returns cosine of `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_cos\n\\sa SDL_acosf\n\\sa SDL_sinf",
          "name": "SDL_cosf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ]
        },
        "SDL_exp": {
          "doc": "Compute the exponential of `x`.\n\nThe definition of `y = exp(x)` is `y = e^x`, where `e` is the base of the\nnatural logarithm. The inverse is the natural logarithm, SDL_log.\n\nDomain: `-INF <= x <= INF`\n\nRange: `0 <= y <= INF`\n\nThe output will overflow if `exp(x)` is too large to be represented.\n\nThis function operates on double-precision floating point values, use\nSDL_expf for single-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param x floating point value.\n\\returns value of `e^x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_expf\n\\sa SDL_log",
          "name": "SDL_exp",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ]
        },
        "SDL_expf": {
          "doc": "Compute the exponential of `x`.\n\nThe definition of `y = exp(x)` is `y = e^x`, where `e` is the base of the\nnatural logarithm. The inverse is the natural logarithm, SDL_logf.\n\nDomain: `-INF <= x <= INF`\n\nRange: `0 <= y <= INF`\n\nThe output will overflow if `exp(x)` is too large to be represented.\n\nThis function operates on single-precision floating point values, use\nSDL_exp for double-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param x floating point value.\n\\returns value of `e^x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_exp\n\\sa SDL_logf",
          "name": "SDL_expf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ]
        },
        "SDL_fabs": {
          "doc": "Compute the absolute value of `x`\n\nDomain: `-INF <= x <= INF`\n\nRange: `0 <= y <= INF`\n\nThis function operates on double-precision floating point values, use\nSDL_copysignf for single-precision floats.\n\n\\param x floating point value to use as the magnitude.\n\\returns the absolute value of `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_fabsf",
          "name": "SDL_fabs",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ]
        },
        "SDL_fabsf": {
          "doc": "Compute the absolute value of `x`\n\nDomain: `-INF <= x <= INF`\n\nRange: `0 <= y <= INF`\n\nThis function operates on single-precision floating point values, use\nSDL_copysignf for double-precision floats.\n\n\\param x floating point value to use as the magnitude.\n\\returns the absolute value of `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_fabs",
          "name": "SDL_fabsf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ]
        },
        "SDL_floor": {
          "doc": "Compute the floor of `x`.\n\nThe floor of `x` is the largest integer `y` such that `y > x`, i.e `x`\nrounded down to the nearest integer.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-INF <= y <= INF`, y integer\n\nThis function operates on double-precision floating point values, use\nSDL_floorf for single-precision floats.\n\n\\param x floating point value.\n\\returns the floor of `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_floorf\n\\sa SDL_ceil\n\\sa SDL_trunc\n\\sa SDL_round\n\\sa SDL_lround",
          "name": "SDL_floor",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ]
        },
        "SDL_floorf": {
          "doc": "Compute the floor of `x`.\n\nThe floor of `x` is the largest integer `y` such that `y > x`, i.e `x`\nrounded down to the nearest integer.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-INF <= y <= INF`, y integer\n\nThis function operates on single-precision floating point values, use\nSDL_floorf for double-precision floats.\n\n\\param x floating point value.\n\\returns the floor of `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_floor\n\\sa SDL_ceilf\n\\sa SDL_truncf\n\\sa SDL_roundf\n\\sa SDL_lroundf",
          "name": "SDL_floorf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ]
        },
        "SDL_trunc": {
          "doc": "Truncate `x` to an integer.\n\nRounds `x` to the next closest integer to 0. This is equivalent to removing\nthe fractional part of `x`, leaving only the integer part.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-INF <= y <= INF`, y integer\n\nThis function operates on double-precision floating point values, use\nSDL_truncf for single-precision floats.\n\n\\param x floating point value.\n\\returns `x` truncated to an integer.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_truncf\n\\sa SDL_fmod\n\\sa SDL_ceil\n\\sa SDL_floor\n\\sa SDL_round\n\\sa SDL_lround",
          "name": "SDL_trunc",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ]
        },
        "SDL_truncf": {
          "doc": "Truncate `x` to an integer.\n\nRounds `x` to the next closest integer to 0. This is equivalent to removing\nthe fractional part of `x`, leaving only the integer part.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-INF <= y <= INF`, y integer\n\nThis function operates on single-precision floating point values, use\nSDL_truncf for double-precision floats.\n\n\\param x floating point value.\n\\returns `x` truncated to an integer.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_trunc\n\\sa SDL_fmodf\n\\sa SDL_ceilf\n\\sa SDL_floorf\n\\sa SDL_roundf\n\\sa SDL_lroundf",
          "name": "SDL_truncf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ]
        },
        "SDL_fmod": {
          "doc": "Return the floating-point remainder of `x / y`\n\nDivides `x` by `y`, and returns the remainder.\n\nDomain: `-INF <= x <= INF`, `-INF <= y <= INF`, `y != 0`\n\nRange: `-y <= z <= y`\n\nThis function operates on double-precision floating point values, use\nSDL_fmodf for single-precision floats.\n\n\\param x the numerator.\n\\param y the denominator. Must not be 0.\n\\returns the remainder of `x / y`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_fmodf\n\\sa SDL_modf\n\\sa SDL_trunc\n\\sa SDL_ceil\n\\sa SDL_floor\n\\sa SDL_round\n\\sa SDL_lround",
          "name": "SDL_fmod",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            },
            {
              "name": "y",
              "type": "double"
            }
          ]
        },
        "SDL_fmodf": {
          "doc": "Return the floating-point remainder of `x / y`\n\nDivides `x` by `y`, and returns the remainder.\n\nDomain: `-INF <= x <= INF`, `-INF <= y <= INF`, `y != 0`\n\nRange: `-y <= z <= y`\n\nThis function operates on single-precision floating point values, use\nSDL_fmod for single-precision floats.\n\n\\param x the numerator.\n\\param y the denominator. Must not be 0.\n\\returns the remainder of `x / y`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_fmod\n\\sa SDL_truncf\n\\sa SDL_modff\n\\sa SDL_ceilf\n\\sa SDL_floorf\n\\sa SDL_roundf\n\\sa SDL_lroundf",
          "name": "SDL_fmodf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            },
            {
              "name": "y",
              "type": "float"
            }
          ]
        },
        "SDL_isinf": {
          "doc": "Return whether the value is infinity.\n\n\\param x double-precision floating point value.\n\\returns non-zero if the value is infinity, 0 otherwise.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_isinff",
          "name": "SDL_isinf",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ]
        },
        "SDL_isinff": {
          "doc": "Return whether the value is infinity.\n\n\\param x floating point value.\n\\returns non-zero if the value is infinity, 0 otherwise.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_isinf",
          "name": "SDL_isinff",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ]
        },
        "SDL_isnan": {
          "doc": "Return whether the value is NaN.\n\n\\param x double-precision floating point value.\n\\returns non-zero if the value is NaN, 0 otherwise.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_isnanf",
          "name": "SDL_isnan",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ]
        },
        "SDL_isnanf": {
          "doc": "Return whether the value is NaN.\n\n\\param x floating point value.\n\\returns non-zero if the value is NaN, 0 otherwise.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_isnan",
          "name": "SDL_isnanf",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ]
        },
        "SDL_log": {
          "doc": "Compute the natural logarithm of `x`.\n\nDomain: `0 < x <= INF`\n\nRange: `-INF <= y <= INF`\n\nIt is an error for `x` to be less than or equal to 0.\n\nThis function operates on double-precision floating point values, use\nSDL_logf for single-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param x floating point value. Must be greater than 0.\n\\returns the natural logarithm of `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_logf\n\\sa SDL_log10\n\\sa SDL_exp",
          "name": "SDL_log",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ]
        },
        "SDL_logf": {
          "doc": "Compute the natural logarithm of `x`.\n\nDomain: `0 < x <= INF`\n\nRange: `-INF <= y <= INF`\n\nIt is an error for `x` to be less than or equal to 0.\n\nThis function operates on single-precision floating point values, use\nSDL_log for double-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param x floating point value. Must be greater than 0.\n\\returns the natural logarithm of `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_log\n\\sa SDL_expf",
          "name": "SDL_logf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ]
        },
        "SDL_log10": {
          "doc": "Compute the base-10 logarithm of `x`.\n\nDomain: `0 < x <= INF`\n\nRange: `-INF <= y <= INF`\n\nIt is an error for `x` to be less than or equal to 0.\n\nThis function operates on double-precision floating point values, use\nSDL_log10f for single-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param x floating point value. Must be greater than 0.\n\\returns the logarithm of `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_log10f\n\\sa SDL_log\n\\sa SDL_pow",
          "name": "SDL_log10",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ]
        },
        "SDL_log10f": {
          "doc": "Compute the base-10 logarithm of `x`.\n\nDomain: `0 < x <= INF`\n\nRange: `-INF <= y <= INF`\n\nIt is an error for `x` to be less than or equal to 0.\n\nThis function operates on single-precision floating point values, use\nSDL_log10 for double-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param x floating point value. Must be greater than 0.\n\\returns the logarithm of `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_log10\n\\sa SDL_logf\n\\sa SDL_powf",
          "name": "SDL_log10f",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ]
        },
        "SDL_modf": {
          "doc": "Split `x` into integer and fractional parts\n\nThis function operates on double-precision floating point values, use\nSDL_modff for single-precision floats.\n\n\\param x floating point value.\n\\param y output pointer to store the integer part of `x`.\n\\returns the fractional part of `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_modff\n\\sa SDL_trunc\n\\sa SDL_fmod",
          "name": "SDL_modf",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            },
            {
              "name": "y",
              "type": "double *"
            }
          ]
        },
        "SDL_modff": {
          "doc": "Split `x` into integer and fractional parts\n\nThis function operates on single-precision floating point values, use\nSDL_modf for double-precision floats.\n\n\\param x floating point value.\n\\param y output pointer to store the integer part of `x`.\n\\returns the fractional part of `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_modf\n\\sa SDL_truncf\n\\sa SDL_fmodf",
          "name": "SDL_modff",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            },
            {
              "name": "y",
              "type": "float *"
            }
          ]
        },
        "SDL_pow": {
          "doc": "Raise `x` to the power `y`\n\nDomain: `-INF <= x <= INF`, `-INF <= y <= INF`\n\nRange: `-INF <= z <= INF`\n\nIf `y` is the base of the natural logarithm (e), consider using SDL_exp\ninstead.\n\nThis function operates on double-precision floating point values, use\nSDL_powf for single-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param x the base.\n\\param y the exponent.\n\\returns `x` raised to the power `y`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_powf\n\\sa SDL_exp\n\\sa SDL_log",
          "name": "SDL_pow",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            },
            {
              "name": "y",
              "type": "double"
            }
          ]
        },
        "SDL_powf": {
          "doc": "Raise `x` to the power `y`\n\nDomain: `-INF <= x <= INF`, `-INF <= y <= INF`\n\nRange: `-INF <= z <= INF`\n\nIf `y` is the base of the natural logarithm (e), consider using SDL_exp\ninstead.\n\nThis function operates on single-precision floating point values, use\nSDL_powf for double-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param x the base.\n\\param y the exponent.\n\\returns `x` raised to the power `y`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_pow\n\\sa SDL_expf\n\\sa SDL_logf",
          "name": "SDL_powf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            },
            {
              "name": "y",
              "type": "float"
            }
          ]
        },
        "SDL_round": {
          "doc": "Round `x` to the nearest integer.\n\nRounds `x` to the nearest integer. Values halfway between integers will be\nrounded away from zero.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-INF <= y <= INF`, y integer\n\nThis function operates on double-precision floating point values, use\nSDL_roundf for single-precision floats. To get the result as an integer\ntype, use SDL_lround.\n\n\\param x floating point value.\n\\returns the nearest integer to `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_roundf\n\\sa SDL_lround\n\\sa SDL_floor\n\\sa SDL_ceil\n\\sa SDL_trunc",
          "name": "SDL_round",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ]
        },
        "SDL_roundf": {
          "doc": "Round `x` to the nearest integer.\n\nRounds `x` to the nearest integer. Values halfway between integers will be\nrounded away from zero.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-INF <= y <= INF`, y integer\n\nThis function operates on double-precision floating point values, use\nSDL_roundf for single-precision floats. To get the result as an integer\ntype, use SDL_lroundf.\n\n\\param x floating point value.\n\\returns the nearest integer to `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_round\n\\sa SDL_lroundf\n\\sa SDL_floorf\n\\sa SDL_ceilf\n\\sa SDL_truncf",
          "name": "SDL_roundf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ]
        },
        "SDL_lround": {
          "doc": "Round `x` to the nearest integer representable as a long\n\nRounds `x` to the nearest integer. Values halfway between integers will be\nrounded away from zero.\n\nDomain: `-INF <= x <= INF`\n\nRange: `MIN_LONG <= y <= MAX_LONG`\n\nThis function operates on double-precision floating point values, use\nSDL_lround for single-precision floats. To get the result as a\nfloating-point type, use SDL_round.\n\n\\param x floating point value.\n\\returns the nearest integer to `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_lroundf\n\\sa SDL_round\n\\sa SDL_floor\n\\sa SDL_ceil\n\\sa SDL_trunc",
          "name": "SDL_lround",
          "kind": "function",
          "type": "long",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ]
        },
        "SDL_lroundf": {
          "doc": "Round `x` to the nearest integer representable as a long\n\nRounds `x` to the nearest integer. Values halfway between integers will be\nrounded away from zero.\n\nDomain: `-INF <= x <= INF`\n\nRange: `MIN_LONG <= y <= MAX_LONG`\n\nThis function operates on single-precision floating point values, use\nSDL_lroundf for double-precision floats. To get the result as a\nfloating-point type, use SDL_roundf,\n\n\\param x floating point value.\n\\returns the nearest integer to `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_lround\n\\sa SDL_roundf\n\\sa SDL_floorf\n\\sa SDL_ceilf\n\\sa SDL_truncf",
          "name": "SDL_lroundf",
          "kind": "function",
          "type": "long",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ]
        },
        "SDL_scalbn": {
          "doc": "Scale `x` by an integer power of two.\n\nMultiplies `x` by the `n`th power of the floating point radix (always 2).\n\nDomain: `-INF <= x <= INF`, `n` integer\n\nRange: `-INF <= y <= INF`\n\nThis function operates on double-precision floating point values, use\nSDL_scalbnf for single-precision floats.\n\n\\param x floating point value to be scaled.\n\\param n integer exponent.\n\\returns `x * 2^n`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_scalbnf\n\\sa SDL_pow",
          "name": "SDL_scalbn",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            },
            {
              "name": "n",
              "type": "int"
            }
          ]
        },
        "SDL_scalbnf": {
          "doc": "Scale `x` by an integer power of two.\n\nMultiplies `x` by the `n`th power of the floating point radix (always 2).\n\nDomain: `-INF <= x <= INF`, `n` integer\n\nRange: `-INF <= y <= INF`\n\nThis function operates on single-precision floating point values, use\nSDL_scalbn for double-precision floats.\n\n\\param x floating point value to be scaled.\n\\param n integer exponent.\n\\returns `x * 2^n`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_scalbn\n\\sa SDL_powf",
          "name": "SDL_scalbnf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            },
            {
              "name": "n",
              "type": "int"
            }
          ]
        },
        "SDL_sin": {
          "doc": "Compute the sine of `x`.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-1 <= y <= 1`\n\nThis function operates on double-precision floating point values, use\nSDL_sinf for single-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param x floating point value, in radians.\n\\returns sine of `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_sinf\n\\sa SDL_asin\n\\sa SDL_cos",
          "name": "SDL_sin",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ]
        },
        "SDL_sinf": {
          "doc": "Compute the sine of `x`.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-1 <= y <= 1`\n\nThis function operates on single-precision floating point values, use\nSDL_sin for double-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param x floating point value, in radians.\n\\returns sine of `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_sin\n\\sa SDL_asinf\n\\sa SDL_cosf",
          "name": "SDL_sinf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ]
        },
        "SDL_sqrt": {
          "doc": "Compute the square root of `x`.\n\nDomain: `0 <= x <= INF`\n\nRange: `0 <= y <= INF`\n\nThis function operates on double-precision floating point values, use\nSDL_sqrtf for single-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param x floating point value. Must be greater than or equal to 0.\n\\returns square root of `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_sqrtf",
          "name": "SDL_sqrt",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ]
        },
        "SDL_sqrtf": {
          "doc": "Compute the square root of `x`.\n\nDomain: `0 <= x <= INF`\n\nRange: `0 <= y <= INF`\n\nThis function operates on single-precision floating point values, use\nSDL_sqrt for double-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param x floating point value. Must be greater than or equal to 0.\n\\returns square root of `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_sqrt",
          "name": "SDL_sqrtf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ]
        },
        "SDL_tan": {
          "doc": "Compute the tangent of `x`.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-INF <= y <= INF`\n\nThis function operates on double-precision floating point values, use\nSDL_tanf for single-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param x floating point value, in radians.\n\\returns tangent of `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_tanf\n\\sa SDL_sin\n\\sa SDL_cos\n\\sa SDL_atan\n\\sa SDL_atan2",
          "name": "SDL_tan",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ]
        },
        "SDL_tanf": {
          "doc": "Compute the tangent of `x`.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-INF <= y <= INF`\n\nThis function operates on single-precision floating point values, use\nSDL_tanf for double-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n\\param x floating point value, in radians.\n\\returns tangent of `x`.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_tan\n\\sa SDL_sinf\n\\sa SDL_cosf\n\\sa SDL_atanf\n\\sa SDL_atan2f",
          "name": "SDL_tanf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ]
        },
        "SDL_iconv_t": {
          "doc": "An opaque handle representing string encoding conversion state.\n\n\\since This datatype is available since SDL 3.2.0.\n\n\\sa SDL_iconv_open",
          "name": "SDL_iconv_t",
          "kind": "alias",
          "type": "struct SDL_iconv_data_t *"
        },
        "SDL_iconv_open": {
          "doc": "This function allocates a context for the specified character set\nconversion.\n\n\\param tocode The target character encoding, must not be NULL.\n\\param fromcode The source character encoding, must not be NULL.\n\\returns a handle that must be freed with SDL_iconv_close, or\n         SDL_ICONV_ERROR on failure.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_iconv\n\\sa SDL_iconv_close\n\\sa SDL_iconv_string",
          "name": "SDL_iconv_open",
          "kind": "function",
          "type": "SDL_iconv_t",
          "parameters": [
            {
              "name": "tocode",
              "type": "const char *"
            },
            {
              "name": "fromcode",
              "type": "const char *"
            }
          ]
        },
        "SDL_iconv_close": {
          "doc": "This function frees a context used for character set conversion.\n\n\\param cd The character set conversion handle.\n\\returns 0 on success, or -1 on failure.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_iconv\n\\sa SDL_iconv_open\n\\sa SDL_iconv_string",
          "name": "SDL_iconv_close",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "cd",
              "type": "SDL_iconv_t"
            }
          ]
        },
        "SDL_iconv": {
          "doc": "This function converts text between encodings, reading from and writing to\na buffer.\n\nIt returns the number of succesful conversions on success. On error,\nSDL_ICONV_E2BIG is returned when the output buffer is too small, or\nSDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,\nor SDL_ICONV_EINVAL is returned when an incomplete input sequence is\nencountered.\n\nOn exit:\n\n- inbuf will point to the beginning of the next multibyte sequence. On\n  error, this is the location of the problematic input sequence. On\n  success, this is the end of the input sequence.\n- inbytesleft will be set to the number of bytes left to convert, which\n  will be 0 on success.\n- outbuf will point to the location where to store the next output byte.\n- outbytesleft will be set to the number of bytes left in the output\n  buffer.\n\n\\param cd The character set conversion context, created in\n          SDL_iconv_open().\n\\param inbuf Address of variable that points to the first character of the\n             input sequence.\n\\param inbytesleft The number of bytes in the input buffer.\n\\param outbuf Address of variable that points to the output buffer.\n\\param outbytesleft The number of bytes in the output buffer.\n\\returns the number of conversions on success, or a negative error code.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_iconv_open\n\\sa SDL_iconv_close\n\\sa SDL_iconv_string",
          "name": "SDL_iconv",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "cd",
              "type": "SDL_iconv_t"
            },
            {
              "name": "inbuf",
              "type": "const char **"
            },
            {
              "name": "inbytesleft",
              "type": "size_t *"
            },
            {
              "name": "outbuf",
              "type": "char **"
            },
            {
              "name": "outbytesleft",
              "type": "size_t *"
            }
          ]
        },
        "SDL_ICONV_ERROR": {
          "doc": "",
          "name": "SDL_ICONV_ERROR",
          "kind": "def"
        },
        "SDL_ICONV_E2BIG": {
          "doc": "",
          "name": "SDL_ICONV_E2BIG",
          "kind": "def"
        },
        "SDL_ICONV_EILSEQ": {
          "doc": "",
          "name": "SDL_ICONV_EILSEQ",
          "kind": "def"
        },
        "SDL_ICONV_EINVAL": {
          "doc": "",
          "name": "SDL_ICONV_EINVAL",
          "kind": "def"
        },
        "SDL_iconv_string": {
          "doc": "Helper function to convert a string's encoding in one call.\n\nThis function converts a buffer or string between encodings in one pass.\n\nThe string does not need to be NULL-terminated; this function operates on\nthe number of bytes specified in `inbytesleft` whether there is a NULL\ncharacter anywhere in the buffer.\n\nThe returned string is owned by the caller, and should be passed to\nSDL_free when no longer needed.\n\n\\param tocode the character encoding of the output string. Examples are\n              \"UTF-8\", \"UCS-4\", etc.\n\\param fromcode the character encoding of data in `inbuf`.\n\\param inbuf the string to convert to a different encoding.\n\\param inbytesleft the size of the input string _in bytes_.\n\\returns a new string, converted to the new encoding, or NULL on error.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_iconv_open\n\\sa SDL_iconv_close\n\\sa SDL_iconv",
          "name": "SDL_iconv_string",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "tocode",
              "type": "const char *"
            },
            {
              "name": "fromcode",
              "type": "const char *"
            },
            {
              "name": "inbuf",
              "type": "const char *"
            },
            {
              "name": "inbytesleft",
              "type": "size_t"
            }
          ]
        },
        "SDL_iconv_utf8_locale": {
          "doc": "Convert a UTF-8 string to the current locale's character encoding.\n\nThis is a helper macro that might be more clear than calling\nSDL_iconv_string directly. However, it double-evaluates its parameter, so\ndo not use an expression with side-effects here.\n\n\\param S the string to convert.\n\\returns a new string, converted to the new encoding, or NULL on error.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_iconv_utf8_locale",
          "kind": "def",
          "parameters": [
            "S"
          ]
        },
        "SDL_iconv_utf8_ucs2": {
          "doc": "Convert a UTF-8 string to UCS-2.\n\nThis is a helper macro that might be more clear than calling\nSDL_iconv_string directly. However, it double-evaluates its parameter, so\ndo not use an expression with side-effects here.\n\n\\param S the string to convert.\n\\returns a new string, converted to the new encoding, or NULL on error.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_iconv_utf8_ucs2",
          "kind": "def",
          "parameters": [
            "S"
          ]
        },
        "SDL_iconv_utf8_ucs4": {
          "doc": "Convert a UTF-8 string to UCS-4.\n\nThis is a helper macro that might be more clear than calling\nSDL_iconv_string directly. However, it double-evaluates its parameter, so\ndo not use an expression with side-effects here.\n\n\\param S the string to convert.\n\\returns a new string, converted to the new encoding, or NULL on error.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_iconv_utf8_ucs4",
          "kind": "def",
          "parameters": [
            "S"
          ]
        },
        "SDL_iconv_wchar_utf8": {
          "doc": "Convert a wchar_t string to UTF-8.\n\nThis is a helper macro that might be more clear than calling\nSDL_iconv_string directly. However, it double-evaluates its parameter, so\ndo not use an expression with side-effects here.\n\n\\param S the string to convert.\n\\returns a new string, converted to the new encoding, or NULL on error.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_iconv_wchar_utf8",
          "kind": "def",
          "parameters": [
            "S"
          ]
        },
        "SDL_size_mul_check_overflow": {
          "doc": "Multiply two integers, checking for overflow.\n\nIf `a * b` would overflow, return false.\n\nOtherwise store `a * b` via ret and return true.\n\n\\param a the multiplicand.\n\\param b the multiplier.\n\\param ret on non-overflow output, stores the multiplication result, may\n           not be NULL.\n\\returns false on overflow, true if result is multiplied without overflow.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_size_mul_check_overflow",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "a",
              "type": "size_t"
            },
            {
              "name": "b",
              "type": "size_t"
            },
            {
              "name": "ret",
              "type": "size_t *"
            }
          ]
        },
        "SDL_size_mul_check_overflow_builtin": {
          "doc": "",
          "name": "SDL_size_mul_check_overflow_builtin",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "a",
              "type": "size_t"
            },
            {
              "name": "b",
              "type": "size_t"
            },
            {
              "name": "ret",
              "type": "size_t *"
            }
          ]
        },
        "SDL_size_add_check_overflow": {
          "doc": "Add two integers, checking for overflow.\n\nIf `a + b` would overflow, return false.\n\nOtherwise store `a + b` via ret and return true.\n\n\\param a the first addend.\n\\param b the second addend.\n\\param ret on non-overflow output, stores the addition result, may not be\n           NULL.\n\\returns false on overflow, true if result is added without overflow.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_size_add_check_overflow",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "a",
              "type": "size_t"
            },
            {
              "name": "b",
              "type": "size_t"
            },
            {
              "name": "ret",
              "type": "size_t *"
            }
          ]
        },
        "SDL_size_add_check_overflow_builtin": {
          "doc": "",
          "name": "SDL_size_add_check_overflow_builtin",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "a",
              "type": "size_t"
            },
            {
              "name": "b",
              "type": "size_t"
            },
            {
              "name": "ret",
              "type": "size_t *"
            }
          ]
        },
        "SDL_FunctionPointer": {
          "doc": "A generic function pointer.\n\nIn theory, generic function pointers should use this, instead of `void *`,\nsince some platforms could treat code addresses differently than data\naddresses. Although in current times no popular platforms make this\ndistinction, it is more correct and portable to use the correct type for a\ngeneric pointer.\n\nIf for some reason you need to force this typedef to be an actual `void *`,\nperhaps to work around a compiler or existing code, you can define\n`SDL_FUNCTION_POINTER_IS_VOID_POINTER` before including any SDL headers.\n\n\\since This datatype is available since SDL 3.2.0.",
          "name": "SDL_FunctionPointer",
          "kind": "callback",
          "type": "void",
          "parameters": []
        }
      }
    },
    "SDL_pixels.h": {
      "name": "SDL_pixels.h",
      "doc": "# CategoryPixels\n\nSDL offers facilities for pixel management.\n\nLargely these facilities deal with pixel _format_: what does this set of\nbits represent?\n\nIf you mostly want to think of a pixel as some combination of red, green,\nblue, and maybe alpha intensities, this is all pretty straightforward, and\nin many cases, is enough information to build a perfectly fine game.\n\nHowever, the actual definition of a pixel is more complex than that:\n\nPixels are a representation of a color in a particular color space.\n\nThe first characteristic of a color space is the color type. SDL\nunderstands two different color types, RGB and YCbCr, or in SDL also\nreferred to as YUV.\n\nRGB colors consist of red, green, and blue channels of color that are added\ntogether to represent the colors we see on the screen.\n\nhttps://en.wikipedia.org/wiki/RGB_color_model\n\nYCbCr colors represent colors as a Y luma brightness component and red and\nblue chroma color offsets. This color representation takes advantage of the\nfact that the human eye is more sensitive to brightness than the color in\nan image. The Cb and Cr components are often compressed and have lower\nresolution than the luma component.\n\nhttps://en.wikipedia.org/wiki/YCbCr\n\nWhen the color information in YCbCr is compressed, the Y pixels are left at\nfull resolution and each Cr and Cb pixel represents an average of the color\ninformation in a block of Y pixels. The chroma location determines where in\nthat block of pixels the color information is coming from.\n\nThe color range defines how much of the pixel to use when converting a\npixel into a color on the display. When the full color range is used, the\nentire numeric range of the pixel bits is significant. When narrow color\nrange is used, for historical reasons, the pixel uses only a portion of the\nnumeric range to represent colors.\n\nThe color primaries and white point are a definition of the colors in the\ncolor space relative to the standard XYZ color space.\n\nhttps://en.wikipedia.org/wiki/CIE_1931_color_space\n\nThe transfer characteristic, or opto-electrical transfer function (OETF),\nis the way a color is converted from mathematically linear space into a\nnon-linear output signals.\n\nhttps://en.wikipedia.org/wiki/Rec._709#Transfer_characteristics\n\nThe matrix coefficients are used to convert between YCbCr and RGB colors.",
      "entries": {
        "SDL_ALPHA_OPAQUE": {
          "doc": "A fully opaque 8-bit alpha value.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_ALPHA_TRANSPARENT",
          "name": "SDL_ALPHA_OPAQUE",
          "kind": "def"
        },
        "SDL_ALPHA_OPAQUE_FLOAT": {
          "doc": "A fully opaque floating point alpha value.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_ALPHA_TRANSPARENT_FLOAT",
          "name": "SDL_ALPHA_OPAQUE_FLOAT",
          "kind": "def"
        },
        "SDL_ALPHA_TRANSPARENT": {
          "doc": "A fully transparent 8-bit alpha value.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_ALPHA_OPAQUE",
          "name": "SDL_ALPHA_TRANSPARENT",
          "kind": "def"
        },
        "SDL_ALPHA_TRANSPARENT_FLOAT": {
          "doc": "A fully transparent floating point alpha value.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_ALPHA_OPAQUE_FLOAT",
          "name": "SDL_ALPHA_TRANSPARENT_FLOAT",
          "kind": "def"
        },
        "SDL_PixelType": {
          "doc": "Pixel type.\n\n\\since This enum is available since SDL 3.2.0.",
          "name": "SDL_PixelType",
          "kind": "enum"
        },
        "SDL_BitmapOrder": {
          "doc": "Bitmap pixel order, high bit -> low bit.\n\n\\since This enum is available since SDL 3.2.0.",
          "name": "SDL_BitmapOrder",
          "kind": "enum"
        },
        "SDL_PackedOrder": {
          "doc": "Packed component order, high bit -> low bit.\n\n\\since This enum is available since SDL 3.2.0.",
          "name": "SDL_PackedOrder",
          "kind": "enum"
        },
        "SDL_ArrayOrder": {
          "doc": "Array component order, low byte -> high byte.\n\n\\since This enum is available since SDL 3.2.0.",
          "name": "SDL_ArrayOrder",
          "kind": "enum"
        },
        "SDL_PackedLayout": {
          "doc": "Packed component layout.\n\n\\since This enum is available since SDL 3.2.0.",
          "name": "SDL_PackedLayout",
          "kind": "enum"
        },
        "SDL_DEFINE_PIXELFOURCC": {
          "doc": "A macro for defining custom FourCC pixel formats.\n\nFor example, defining SDL_PIXELFORMAT_YV12 looks like this:\n\n```c\nSDL_DEFINE_PIXELFOURCC('Y', 'V', '1', '2')\n```\n\n\\param A the first character of the FourCC code.\n\\param B the second character of the FourCC code.\n\\param C the third character of the FourCC code.\n\\param D the fourth character of the FourCC code.\n\\returns a format value in the style of SDL_PixelFormat.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_DEFINE_PIXELFOURCC",
          "kind": "def",
          "parameters": [
            "A",
            "B",
            "C",
            "D"
          ]
        },
        "SDL_DEFINE_PIXELFORMAT": {
          "doc": "A macro for defining custom non-FourCC pixel formats.\n\nFor example, defining SDL_PIXELFORMAT_RGBA8888 looks like this:\n\n```c\nSDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED32, SDL_PACKEDORDER_RGBA, SDL_PACKEDLAYOUT_8888, 32, 4)\n```\n\n\\param type the type of the new format, probably a SDL_PixelType value.\n\\param order the order of the new format, probably a SDL_BitmapOrder,\n             SDL_PackedOrder, or SDL_ArrayOrder value.\n\\param layout the layout of the new format, probably an SDL_PackedLayout\n              value or zero.\n\\param bits the number of bits per pixel of the new format.\n\\param bytes the number of bytes per pixel of the new format.\n\\returns a format value in the style of SDL_PixelFormat.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_DEFINE_PIXELFORMAT",
          "kind": "def",
          "parameters": [
            "type",
            "order",
            "layout",
            "bits",
            "bytes"
          ]
        },
        "SDL_PIXELFLAG": {
          "doc": "A macro to retrieve the flags of an SDL_PixelFormat.\n\nThis macro is generally not needed directly by an app, which should use\nspecific tests, like SDL_ISPIXELFORMAT_FOURCC, instead.\n\n\\param format an SDL_PixelFormat to check.\n\\returns the flags of `format`.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_PIXELFLAG",
          "kind": "def",
          "parameters": [
            "format"
          ]
        },
        "SDL_PIXELTYPE": {
          "doc": "A macro to retrieve the type of an SDL_PixelFormat.\n\nThis is usually a value from the SDL_PixelType enumeration.\n\n\\param format an SDL_PixelFormat to check.\n\\returns the type of `format`.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_PIXELTYPE",
          "kind": "def",
          "parameters": [
            "format"
          ]
        },
        "SDL_PIXELORDER": {
          "doc": "A macro to retrieve the order of an SDL_PixelFormat.\n\nThis is usually a value from the SDL_BitmapOrder, SDL_PackedOrder, or\nSDL_ArrayOrder enumerations, depending on the format type.\n\n\\param format an SDL_PixelFormat to check.\n\\returns the order of `format`.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_PIXELORDER",
          "kind": "def",
          "parameters": [
            "format"
          ]
        },
        "SDL_PIXELLAYOUT": {
          "doc": "A macro to retrieve the layout of an SDL_PixelFormat.\n\nThis is usually a value from the SDL_PackedLayout enumeration, or zero if a\nlayout doesn't make sense for the format type.\n\n\\param format an SDL_PixelFormat to check.\n\\returns the layout of `format`.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_PIXELLAYOUT",
          "kind": "def",
          "parameters": [
            "format"
          ]
        },
        "SDL_BITSPERPIXEL": {
          "doc": "A macro to determine an SDL_PixelFormat's bits per pixel.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\nFourCC formats will report zero here, as it rarely makes sense to measure\nthem per-pixel.\n\n\\param format an SDL_PixelFormat to check.\n\\returns the bits-per-pixel of `format`.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_BYTESPERPIXEL",
          "name": "SDL_BITSPERPIXEL",
          "kind": "def",
          "parameters": [
            "format"
          ]
        },
        "SDL_BYTESPERPIXEL": {
          "doc": "A macro to determine an SDL_PixelFormat's bytes per pixel.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\nFourCC formats do their best here, but many of them don't have a meaningful\nmeasurement of bytes per pixel.\n\n\\param format an SDL_PixelFormat to check.\n\\returns the bytes-per-pixel of `format`.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.\n\n\\sa SDL_BITSPERPIXEL",
          "name": "SDL_BYTESPERPIXEL",
          "kind": "def",
          "parameters": [
            "format"
          ]
        },
        "SDL_ISPIXELFORMAT_INDEXED": {
          "doc": "A macro to determine if an SDL_PixelFormat is an indexed format.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n\\param format an SDL_PixelFormat to check.\n\\returns true if the format is indexed, false otherwise.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISPIXELFORMAT_INDEXED",
          "kind": "def",
          "parameters": [
            "format"
          ]
        },
        "SDL_ISPIXELFORMAT_PACKED": {
          "doc": "A macro to determine if an SDL_PixelFormat is a packed format.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n\\param format an SDL_PixelFormat to check.\n\\returns true if the format is packed, false otherwise.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISPIXELFORMAT_PACKED",
          "kind": "def",
          "parameters": [
            "format"
          ]
        },
        "SDL_ISPIXELFORMAT_ARRAY": {
          "doc": "A macro to determine if an SDL_PixelFormat is an array format.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n\\param format an SDL_PixelFormat to check.\n\\returns true if the format is an array, false otherwise.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISPIXELFORMAT_ARRAY",
          "kind": "def",
          "parameters": [
            "format"
          ]
        },
        "SDL_ISPIXELFORMAT_10BIT": {
          "doc": "A macro to determine if an SDL_PixelFormat is a 10-bit format.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n\\param format an SDL_PixelFormat to check.\n\\returns true if the format is 10-bit, false otherwise.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISPIXELFORMAT_10BIT",
          "kind": "def",
          "parameters": [
            "format"
          ]
        },
        "SDL_ISPIXELFORMAT_FLOAT": {
          "doc": "A macro to determine if an SDL_PixelFormat is a floating point format.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n\\param format an SDL_PixelFormat to check.\n\\returns true if the format is 10-bit, false otherwise.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISPIXELFORMAT_FLOAT",
          "kind": "def",
          "parameters": [
            "format"
          ]
        },
        "SDL_ISPIXELFORMAT_ALPHA": {
          "doc": "A macro to determine if an SDL_PixelFormat has an alpha channel.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n\\param format an SDL_PixelFormat to check.\n\\returns true if the format has alpha, false otherwise.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISPIXELFORMAT_ALPHA",
          "kind": "def",
          "parameters": [
            "format"
          ]
        },
        "SDL_ISPIXELFORMAT_FOURCC": {
          "doc": "A macro to determine if an SDL_PixelFormat is a \"FourCC\" format.\n\nThis covers custom and other unusual formats.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n\\param format an SDL_PixelFormat to check.\n\\returns true if the format has alpha, false otherwise.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISPIXELFORMAT_FOURCC",
          "kind": "def",
          "parameters": [
            "format"
          ]
        },
        "SDL_PixelFormat": {
          "doc": "Pixel format.\n\nSDL's pixel formats have the following naming convention:\n\n- Names with a list of components and a single bit count, such as RGB24 and\n  ABGR32, define a platform-independent encoding into bytes in the order\n  specified. For example, in RGB24 data, each pixel is encoded in 3 bytes\n  (red, green, blue) in that order, and in ABGR32 data, each pixel is\n  encoded in 4 bytes alpha, blue, green, red) in that order. Use these\n  names if the property of a format that is important to you is the order\n  of the bytes in memory or on disk.\n- Names with a bit count per component, such as ARGB8888 and XRGB1555, are\n  \"packed\" into an appropriately-sized integer in the platform's native\n  endianness. For example, ARGB8888 is a sequence of 32-bit integers; in\n  each integer, the most significant bits are alpha, and the least\n  significant bits are blue. On a little-endian CPU such as x86, the least\n  significant bits of each integer are arranged first in memory, but on a\n  big-endian CPU such as s390x, the most significant bits are arranged\n  first. Use these names if the property of a format that is important to\n  you is the meaning of each bit position within a native-endianness\n  integer.\n- In indexed formats such as INDEX4LSB, each pixel is represented by\n  encoding an index into the palette into the indicated number of bits,\n  with multiple pixels packed into each byte if appropriate. In LSB\n  formats, the first (leftmost) pixel is stored in the least-significant\n  bits of the byte; in MSB formats, it's stored in the most-significant\n  bits. INDEX8 does not need LSB/MSB variants, because each pixel exactly\n  fills one byte.\n\nThe 32-bit byte-array encodings such as RGBA32 are aliases for the\nappropriate 8888 encoding for the current platform. For example, RGBA32 is\nan alias for ABGR8888 on little-endian CPUs like x86, or an alias for\nRGBA8888 on big-endian CPUs.\n\n\\since This enum is available since SDL 3.2.0.",
          "name": "SDL_PixelFormat",
          "kind": "enum"
        },
        "SDL_ColorType": {
          "doc": "Colorspace color type.\n\n\\since This enum is available since SDL 3.2.0.",
          "name": "SDL_ColorType",
          "kind": "enum"
        },
        "SDL_ColorRange": {
          "doc": "Colorspace color range, as described by\nhttps://www.itu.int/rec/R-REC-BT.2100-2-201807-I/en\n\n\\since This enum is available since SDL 3.2.0.",
          "name": "SDL_ColorRange",
          "kind": "enum"
        },
        "SDL_ColorPrimaries": {
          "doc": "Colorspace color primaries, as described by\nhttps://www.itu.int/rec/T-REC-H.273-201612-S/en\n\n\\since This enum is available since SDL 3.2.0.",
          "name": "SDL_ColorPrimaries",
          "kind": "enum"
        },
        "SDL_TransferCharacteristics": {
          "doc": "Colorspace transfer characteristics.\n\nThese are as described by https://www.itu.int/rec/T-REC-H.273-201612-S/en\n\n\\since This enum is available since SDL 3.2.0.",
          "name": "SDL_TransferCharacteristics",
          "kind": "enum"
        },
        "SDL_MatrixCoefficients": {
          "doc": "Colorspace matrix coefficients.\n\nThese are as described by https://www.itu.int/rec/T-REC-H.273-201612-S/en\n\n\\since This enum is available since SDL 3.2.0.",
          "name": "SDL_MatrixCoefficients",
          "kind": "enum"
        },
        "SDL_ChromaLocation": {
          "doc": "Colorspace chroma sample location.\n\n\\since This enum is available since SDL 3.2.0.",
          "name": "SDL_ChromaLocation",
          "kind": "enum"
        },
        "SDL_DEFINE_COLORSPACE": {
          "doc": "A macro for defining custom SDL_Colorspace formats.\n\nFor example, defining SDL_COLORSPACE_SRGB looks like this:\n\n```c\nSDL_DEFINE_COLORSPACE(SDL_COLOR_TYPE_RGB,\n                      SDL_COLOR_RANGE_FULL,\n                      SDL_COLOR_PRIMARIES_BT709,\n                      SDL_TRANSFER_CHARACTERISTICS_SRGB,\n                      SDL_MATRIX_COEFFICIENTS_IDENTITY,\n                      SDL_CHROMA_LOCATION_NONE)\n```\n\n\\param type the type of the new format, probably an SDL_ColorType value.\n\\param range the range of the new format, probably a SDL_ColorRange value.\n\\param primaries the primaries of the new format, probably an\n                 SDL_ColorPrimaries value.\n\\param transfer the transfer characteristics of the new format, probably an\n                SDL_TransferCharacteristics value.\n\\param matrix the matrix coefficients of the new format, probably an\n              SDL_MatrixCoefficients value.\n\\param chroma the chroma sample location of the new format, probably an\n              SDL_ChromaLocation value.\n\\returns a format value in the style of SDL_Colorspace.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_DEFINE_COLORSPACE",
          "kind": "def",
          "parameters": [
            "type",
            "range",
            "primaries",
            "transfer",
            "matrix",
            "chroma"
          ]
        },
        "SDL_COLORSPACETYPE": {
          "doc": "A macro to retrieve the type of an SDL_Colorspace.\n\n\\param cspace an SDL_Colorspace to check.\n\\returns the SDL_ColorType for `cspace`.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_COLORSPACETYPE",
          "kind": "def",
          "parameters": [
            "cspace"
          ]
        },
        "SDL_COLORSPACERANGE": {
          "doc": "A macro to retrieve the range of an SDL_Colorspace.\n\n\\param cspace an SDL_Colorspace to check.\n\\returns the SDL_ColorRange of `cspace`.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_COLORSPACERANGE",
          "kind": "def",
          "parameters": [
            "cspace"
          ]
        },
        "SDL_COLORSPACECHROMA": {
          "doc": "A macro to retrieve the chroma sample location of an SDL_Colorspace.\n\n\\param cspace an SDL_Colorspace to check.\n\\returns the SDL_ChromaLocation of `cspace`.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_COLORSPACECHROMA",
          "kind": "def",
          "parameters": [
            "cspace"
          ]
        },
        "SDL_COLORSPACEPRIMARIES": {
          "doc": "A macro to retrieve the primaries of an SDL_Colorspace.\n\n\\param cspace an SDL_Colorspace to check.\n\\returns the SDL_ColorPrimaries of `cspace`.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_COLORSPACEPRIMARIES",
          "kind": "def",
          "parameters": [
            "cspace"
          ]
        },
        "SDL_COLORSPACETRANSFER": {
          "doc": "A macro to retrieve the transfer characteristics of an SDL_Colorspace.\n\n\\param cspace an SDL_Colorspace to check.\n\\returns the SDL_TransferCharacteristics of `cspace`.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_COLORSPACETRANSFER",
          "kind": "def",
          "parameters": [
            "cspace"
          ]
        },
        "SDL_COLORSPACEMATRIX": {
          "doc": "A macro to retrieve the matrix coefficients of an SDL_Colorspace.\n\n\\param cspace an SDL_Colorspace to check.\n\\returns the SDL_MatrixCoefficients of `cspace`.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_COLORSPACEMATRIX",
          "kind": "def",
          "parameters": [
            "cspace"
          ]
        },
        "SDL_ISCOLORSPACE_MATRIX_BT601": {
          "doc": "A macro to determine if an SDL_Colorspace uses BT601 (or BT470BG) matrix\ncoefficients.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n\\param cspace an SDL_Colorspace to check.\n\\returns true if BT601 or BT470BG, false otherwise.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISCOLORSPACE_MATRIX_BT601",
          "kind": "def",
          "parameters": [
            "cspace"
          ]
        },
        "SDL_ISCOLORSPACE_MATRIX_BT709": {
          "doc": "A macro to determine if an SDL_Colorspace uses BT709 matrix coefficients.\n\n\\param cspace an SDL_Colorspace to check.\n\\returns true if BT709, false otherwise.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISCOLORSPACE_MATRIX_BT709",
          "kind": "def",
          "parameters": [
            "cspace"
          ]
        },
        "SDL_ISCOLORSPACE_MATRIX_BT2020_NCL": {
          "doc": "A macro to determine if an SDL_Colorspace uses BT2020_NCL matrix\ncoefficients.\n\n\\param cspace an SDL_Colorspace to check.\n\\returns true if BT2020_NCL, false otherwise.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISCOLORSPACE_MATRIX_BT2020_NCL",
          "kind": "def",
          "parameters": [
            "cspace"
          ]
        },
        "SDL_ISCOLORSPACE_LIMITED_RANGE": {
          "doc": "A macro to determine if an SDL_Colorspace has a limited range.\n\n\\param cspace an SDL_Colorspace to check.\n\\returns true if limited range, false otherwise.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISCOLORSPACE_LIMITED_RANGE",
          "kind": "def",
          "parameters": [
            "cspace"
          ]
        },
        "SDL_ISCOLORSPACE_FULL_RANGE": {
          "doc": "A macro to determine if an SDL_Colorspace has a full range.\n\n\\param cspace an SDL_Colorspace to check.\n\\returns true if full range, false otherwise.\n\n\\threadsafety It is safe to call this macro from any thread.\n\n\\since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISCOLORSPACE_FULL_RANGE",
          "kind": "def",
          "parameters": [
            "cspace"
          ]
        },
        "SDL_Colorspace": {
          "doc": "Colorspace definitions.\n\nSince similar colorspaces may vary in their details (matrix, transfer\nfunction, etc.), this is not an exhaustive list, but rather a\nrepresentative sample of the kinds of colorspaces supported in SDL.\n\n\\since This enum is available since SDL 3.2.0.\n\n\\sa SDL_ColorPrimaries\n\\sa SDL_ColorRange\n\\sa SDL_ColorType\n\\sa SDL_MatrixCoefficients\n\\sa SDL_TransferCharacteristics",
          "name": "SDL_Colorspace",
          "kind": "enum"
        },
        "SDL_Color": {
          "doc": "A structure that represents a color as RGBA components.\n\nThe bits of this structure can be directly reinterpreted as an\ninteger-packed color which uses the SDL_PIXELFORMAT_RGBA32 format\n(SDL_PIXELFORMAT_ABGR8888 on little-endian systems and\nSDL_PIXELFORMAT_RGBA8888 on big-endian systems).\n\n\\since This struct is available since SDL 3.2.0.",
          "name": "SDL_Color",
          "kind": "struct",
          "entries": {
            "r": {
              "doc": "",
              "name": "r",
              "kind": "var",
              "type": "Uint8"
            },
            "g": {
              "doc": "",
              "name": "g",
              "kind": "var",
              "type": "Uint8"
            },
            "b": {
              "doc": "",
              "name": "b",
              "kind": "var",
              "type": "Uint8"
            },
            "a": {
              "doc": "",
              "name": "a",
              "kind": "var",
              "type": "Uint8"
            }
          }
        },
        "SDL_FColor": {
          "doc": "The bits of this structure can be directly reinterpreted as a float-packed\ncolor which uses the SDL_PIXELFORMAT_RGBA128_FLOAT format\n\n\\since This struct is available since SDL 3.2.0.",
          "name": "SDL_FColor",
          "kind": "struct",
          "entries": {
            "r": {
              "doc": "",
              "name": "r",
              "kind": "var",
              "type": "float"
            },
            "g": {
              "doc": "",
              "name": "g",
              "kind": "var",
              "type": "float"
            },
            "b": {
              "doc": "",
              "name": "b",
              "kind": "var",
              "type": "float"
            },
            "a": {
              "doc": "",
              "name": "a",
              "kind": "var",
              "type": "float"
            }
          }
        },
        "SDL_Palette": {
          "doc": "A set of indexed colors representing a palette.\n\n\\since This struct is available since SDL 3.2.0.\n\n\\sa SDL_SetPaletteColors",
          "name": "SDL_Palette",
          "kind": "struct",
          "entries": {
            "ncolors": {
              "doc": "",
              "name": "ncolors",
              "kind": "var",
              "type": "int"
            },
            "colors": {
              "doc": "",
              "name": "colors",
              "kind": "var",
              "type": "SDL_Color *"
            },
            "version": {
              "doc": "",
              "name": "version",
              "kind": "var",
              "type": "Uint32"
            },
            "refcount": {
              "doc": "",
              "name": "refcount",
              "kind": "var",
              "type": "int"
            }
          }
        },
        "SDL_PixelFormatDetails": {
          "doc": "Details about the format of a pixel.\n\n\\since This struct is available since SDL 3.2.0.",
          "name": "SDL_PixelFormatDetails",
          "kind": "struct",
          "entries": {
            "format": {
              "doc": "",
              "name": "format",
              "kind": "var",
              "type": "SDL_PixelFormat"
            },
            "bits_per_pixel": {
              "doc": "",
              "name": "bits_per_pixel",
              "kind": "var",
              "type": "Uint8"
            },
            "bytes_per_pixel": {
              "doc": "",
              "name": "bytes_per_pixel",
              "kind": "var",
              "type": "Uint8"
            },
            "padding": {
              "doc": "",
              "name": "padding",
              "kind": "var",
              "type": "Uint8"
            },
            "Rmask": {
              "doc": "",
              "name": "Rmask",
              "kind": "var",
              "type": "Uint32"
            },
            "Gmask": {
              "doc": "",
              "name": "Gmask",
              "kind": "var",
              "type": "Uint32"
            },
            "Bmask": {
              "doc": "",
              "name": "Bmask",
              "kind": "var",
              "type": "Uint32"
            },
            "Amask": {
              "doc": "",
              "name": "Amask",
              "kind": "var",
              "type": "Uint32"
            },
            "Rbits": {
              "doc": "",
              "name": "Rbits",
              "kind": "var",
              "type": "Uint8"
            },
            "Gbits": {
              "doc": "",
              "name": "Gbits",
              "kind": "var",
              "type": "Uint8"
            },
            "Bbits": {
              "doc": "",
              "name": "Bbits",
              "kind": "var",
              "type": "Uint8"
            },
            "Abits": {
              "doc": "",
              "name": "Abits",
              "kind": "var",
              "type": "Uint8"
            },
            "Rshift": {
              "doc": "",
              "name": "Rshift",
              "kind": "var",
              "type": "Uint8"
            },
            "Gshift": {
              "doc": "",
              "name": "Gshift",
              "kind": "var",
              "type": "Uint8"
            },
            "Bshift": {
              "doc": "",
              "name": "Bshift",
              "kind": "var",
              "type": "Uint8"
            },
            "Ashift": {
              "doc": "",
              "name": "Ashift",
              "kind": "var",
              "type": "Uint8"
            }
          }
        },
        "SDL_GetPixelFormatName": {
          "doc": "Get the human readable name of a pixel format.\n\n\\param format the pixel format to query.\n\\returns the human readable name of the specified pixel format or\n         \"SDL_PIXELFORMAT_UNKNOWN\" if the format isn't recognized.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_GetPixelFormatName",
          "kind": "function",
          "type": "const char *",
          "parameters": [
            {
              "name": "format",
              "type": "SDL_PixelFormat"
            }
          ]
        },
        "SDL_GetMasksForPixelFormat": {
          "doc": "Convert one of the enumerated pixel formats to a bpp value and RGBA masks.\n\n\\param format one of the SDL_PixelFormat values.\n\\param bpp a bits per pixel value; usually 15, 16, or 32.\n\\param Rmask a pointer filled in with the red mask for the format.\n\\param Gmask a pointer filled in with the green mask for the format.\n\\param Bmask a pointer filled in with the blue mask for the format.\n\\param Amask a pointer filled in with the alpha mask for the format.\n\\returns true on success or false on failure; call SDL_GetError() for more\n         information.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetPixelFormatForMasks",
          "name": "SDL_GetMasksForPixelFormat",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "format",
              "type": "SDL_PixelFormat"
            },
            {
              "name": "bpp",
              "type": "int *"
            },
            {
              "name": "Rmask",
              "type": "Uint32 *"
            },
            {
              "name": "Gmask",
              "type": "Uint32 *"
            },
            {
              "name": "Bmask",
              "type": "Uint32 *"
            },
            {
              "name": "Amask",
              "type": "Uint32 *"
            }
          ]
        },
        "SDL_GetPixelFormatForMasks": {
          "doc": "Convert a bpp value and RGBA masks to an enumerated pixel format.\n\nThis will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't\npossible.\n\n\\param bpp a bits per pixel value; usually 15, 16, or 32.\n\\param Rmask the red mask for the format.\n\\param Gmask the green mask for the format.\n\\param Bmask the blue mask for the format.\n\\param Amask the alpha mask for the format.\n\\returns the SDL_PixelFormat value corresponding to the format masks, or\n         SDL_PIXELFORMAT_UNKNOWN if there isn't a match.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetMasksForPixelFormat",
          "name": "SDL_GetPixelFormatForMasks",
          "kind": "function",
          "type": "SDL_PixelFormat",
          "parameters": [
            {
              "name": "bpp",
              "type": "int"
            },
            {
              "name": "Rmask",
              "type": "Uint32"
            },
            {
              "name": "Gmask",
              "type": "Uint32"
            },
            {
              "name": "Bmask",
              "type": "Uint32"
            },
            {
              "name": "Amask",
              "type": "Uint32"
            }
          ]
        },
        "SDL_GetPixelFormatDetails": {
          "doc": "Create an SDL_PixelFormatDetails structure corresponding to a pixel format.\n\nReturned structure may come from a shared global cache (i.e. not newly\nallocated), and hence should not be modified, especially the palette. Weird\nerrors such as `Blit combination not supported` may occur.\n\n\\param format one of the SDL_PixelFormat values.\n\\returns a pointer to a SDL_PixelFormatDetails structure or NULL on\n         failure; call SDL_GetError() for more information.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_GetPixelFormatDetails",
          "kind": "function",
          "type": "const SDL_PixelFormatDetails *",
          "parameters": [
            {
              "name": "format",
              "type": "SDL_PixelFormat"
            }
          ]
        },
        "SDL_CreatePalette": {
          "doc": "Create a palette structure with the specified number of color entries.\n\nThe palette entries are initialized to white.\n\n\\param ncolors represents the number of color entries in the color palette.\n\\returns a new SDL_Palette structure on success or NULL on failure (e.g. if\n         there wasn't enough memory); call SDL_GetError() for more\n         information.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_DestroyPalette\n\\sa SDL_SetPaletteColors\n\\sa SDL_SetSurfacePalette",
          "name": "SDL_CreatePalette",
          "kind": "function",
          "type": "SDL_Palette *",
          "parameters": [
            {
              "name": "ncolors",
              "type": "int"
            }
          ]
        },
        "SDL_SetPaletteColors": {
          "doc": "Set a range of colors in a palette.\n\n\\param palette the SDL_Palette structure to modify.\n\\param colors an array of SDL_Color structures to copy into the palette.\n\\param firstcolor the index of the first palette entry to modify.\n\\param ncolors the number of entries to modify.\n\\returns true on success or false on failure; call SDL_GetError() for more\n         information.\n\n\\threadsafety It is safe to call this function from any thread, as long as\n              the palette is not modified or destroyed in another thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_SetPaletteColors",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "palette",
              "type": "SDL_Palette *"
            },
            {
              "name": "colors",
              "type": "const SDL_Color *"
            },
            {
              "name": "firstcolor",
              "type": "int"
            },
            {
              "name": "ncolors",
              "type": "int"
            }
          ]
        },
        "SDL_DestroyPalette": {
          "doc": "Free a palette created with SDL_CreatePalette().\n\n\\param palette the SDL_Palette structure to be freed.\n\n\\threadsafety It is safe to call this function from any thread, as long as\n              the palette is not modified or destroyed in another thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_CreatePalette",
          "name": "SDL_DestroyPalette",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "palette",
              "type": "SDL_Palette *"
            }
          ]
        },
        "SDL_MapRGB": {
          "doc": "Map an RGB triple to an opaque pixel value for a given pixel format.\n\nThis function maps the RGB color value to the specified pixel format and\nreturns the pixel value best approximating the given RGB color value for\nthe given pixel format.\n\nIf the format has a palette (8-bit) the index of the closest matching color\nin the palette will be returned.\n\nIf the specified pixel format has an alpha component it will be returned as\nall 1 bits (fully opaque).\n\nIf the pixel format bpp (color depth) is less than 32-bpp then the unused\nupper bits of the return value can safely be ignored (e.g., with a 16-bpp\nformat the return value can be assigned to a Uint16, and similarly a Uint8\nfor an 8-bpp format).\n\n\\param format a pointer to SDL_PixelFormatDetails describing the pixel\n              format.\n\\param palette an optional palette for indexed formats, may be NULL.\n\\param r the red component of the pixel in the range 0-255.\n\\param g the green component of the pixel in the range 0-255.\n\\param b the blue component of the pixel in the range 0-255.\n\\returns a pixel value.\n\n\\threadsafety It is safe to call this function from any thread, as long as\n              the palette is not modified.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetPixelFormatDetails\n\\sa SDL_GetRGB\n\\sa SDL_MapRGBA\n\\sa SDL_MapSurfaceRGB",
          "name": "SDL_MapRGB",
          "kind": "function",
          "type": "Uint32",
          "parameters": [
            {
              "name": "format",
              "type": "const SDL_PixelFormatDetails *"
            },
            {
              "name": "palette",
              "type": "const SDL_Palette *"
            },
            {
              "name": "r",
              "type": "Uint8"
            },
            {
              "name": "g",
              "type": "Uint8"
            },
            {
              "name": "b",
              "type": "Uint8"
            }
          ]
        },
        "SDL_MapRGBA": {
          "doc": "Map an RGBA quadruple to a pixel value for a given pixel format.\n\nThis function maps the RGBA color value to the specified pixel format and\nreturns the pixel value best approximating the given RGBA color value for\nthe given pixel format.\n\nIf the specified pixel format has no alpha component the alpha value will\nbe ignored (as it will be in formats with a palette).\n\nIf the format has a palette (8-bit) the index of the closest matching color\nin the palette will be returned.\n\nIf the pixel format bpp (color depth) is less than 32-bpp then the unused\nupper bits of the return value can safely be ignored (e.g., with a 16-bpp\nformat the return value can be assigned to a Uint16, and similarly a Uint8\nfor an 8-bpp format).\n\n\\param format a pointer to SDL_PixelFormatDetails describing the pixel\n              format.\n\\param palette an optional palette for indexed formats, may be NULL.\n\\param r the red component of the pixel in the range 0-255.\n\\param g the green component of the pixel in the range 0-255.\n\\param b the blue component of the pixel in the range 0-255.\n\\param a the alpha component of the pixel in the range 0-255.\n\\returns a pixel value.\n\n\\threadsafety It is safe to call this function from any thread, as long as\n              the palette is not modified.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetPixelFormatDetails\n\\sa SDL_GetRGBA\n\\sa SDL_MapRGB\n\\sa SDL_MapSurfaceRGBA",
          "name": "SDL_MapRGBA",
          "kind": "function",
          "type": "Uint32",
          "parameters": [
            {
              "name": "format",
              "type": "const SDL_PixelFormatDetails *"
            },
            {
              "name": "palette",
              "type": "const SDL_Palette *"
            },
            {
              "name": "r",
              "type": "Uint8"
            },
            {
              "name": "g",
              "type": "Uint8"
            },
            {
              "name": "b",
              "type": "Uint8"
            },
            {
              "name": "a",
              "type": "Uint8"
            }
          ]
        },
        "SDL_GetRGB": {
          "doc": "Get RGB values from a pixel in the specified format.\n\nThis function uses the entire 8-bit [0..255] range when converting color\ncomponents from pixel formats with less than 8-bits per RGB component\n(e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,\n0xff, 0xff] not [0xf8, 0xfc, 0xf8]).\n\n\\param pixel a pixel value.\n\\param format a pointer to SDL_PixelFormatDetails describing the pixel\n              format.\n\\param palette an optional palette for indexed formats, may be NULL.\n\\param r a pointer filled in with the red component, may be NULL.\n\\param g a pointer filled in with the green component, may be NULL.\n\\param b a pointer filled in with the blue component, may be NULL.\n\n\\threadsafety It is safe to call this function from any thread, as long as\n              the palette is not modified.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetPixelFormatDetails\n\\sa SDL_GetRGBA\n\\sa SDL_MapRGB\n\\sa SDL_MapRGBA",
          "name": "SDL_GetRGB",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "pixel",
              "type": "Uint32"
            },
            {
              "name": "format",
              "type": "const SDL_PixelFormatDetails *"
            },
            {
              "name": "palette",
              "type": "const SDL_Palette *"
            },
            {
              "name": "r",
              "type": "Uint8 *"
            },
            {
              "name": "g",
              "type": "Uint8 *"
            },
            {
              "name": "b",
              "type": "Uint8 *"
            }
          ]
        },
        "SDL_GetRGBA": {
          "doc": "Get RGBA values from a pixel in the specified format.\n\nThis function uses the entire 8-bit [0..255] range when converting color\ncomponents from pixel formats with less than 8-bits per RGB component\n(e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,\n0xff, 0xff] not [0xf8, 0xfc, 0xf8]).\n\nIf the surface has no alpha component, the alpha will be returned as 0xff\n(100% opaque).\n\n\\param pixel a pixel value.\n\\param format a pointer to SDL_PixelFormatDetails describing the pixel\n              format.\n\\param palette an optional palette for indexed formats, may be NULL.\n\\param r a pointer filled in with the red component, may be NULL.\n\\param g a pointer filled in with the green component, may be NULL.\n\\param b a pointer filled in with the blue component, may be NULL.\n\\param a a pointer filled in with the alpha component, may be NULL.\n\n\\threadsafety It is safe to call this function from any thread, as long as\n              the palette is not modified.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetPixelFormatDetails\n\\sa SDL_GetRGB\n\\sa SDL_MapRGB\n\\sa SDL_MapRGBA",
          "name": "SDL_GetRGBA",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "pixel",
              "type": "Uint32"
            },
            {
              "name": "format",
              "type": "const SDL_PixelFormatDetails *"
            },
            {
              "name": "palette",
              "type": "const SDL_Palette *"
            },
            {
              "name": "r",
              "type": "Uint8 *"
            },
            {
              "name": "g",
              "type": "Uint8 *"
            },
            {
              "name": "b",
              "type": "Uint8 *"
            },
            {
              "name": "a",
              "type": "Uint8 *"
            }
          ]
        }
      }
    },
    "SDL_blendmode.h": {
      "name": "SDL_blendmode.h",
      "doc": "# CategoryBlendmode\n\nBlend modes decide how two colors will mix together. There are both\nstandard modes for basic needs and a means to create custom modes,\ndictating what sort of math to do on what color components.",
      "entries": {
        "SDL_BlendMode": {
          "doc": "A set of blend modes used in drawing operations.\n\nThese predefined blend modes are supported everywhere.\n\nAdditional values may be obtained from SDL_ComposeCustomBlendMode.\n\n\\since This datatype is available since SDL 3.2.0.\n\n\\sa SDL_ComposeCustomBlendMode",
          "name": "SDL_BlendMode",
          "kind": "alias",
          "type": "Uint32"
        },
        "SDL_BLENDMODE_NONE": {
          "doc": "",
          "name": "SDL_BLENDMODE_NONE",
          "kind": "def"
        },
        "SDL_BLENDMODE_BLEND": {
          "doc": "",
          "name": "SDL_BLENDMODE_BLEND",
          "kind": "def"
        },
        "SDL_BLENDMODE_BLEND_PREMULTIPLIED": {
          "doc": "",
          "name": "SDL_BLENDMODE_BLEND_PREMULTIPLIED",
          "kind": "def"
        },
        "SDL_BLENDMODE_ADD": {
          "doc": "",
          "name": "SDL_BLENDMODE_ADD",
          "kind": "def"
        },
        "SDL_BLENDMODE_ADD_PREMULTIPLIED": {
          "doc": "",
          "name": "SDL_BLENDMODE_ADD_PREMULTIPLIED",
          "kind": "def"
        },
        "SDL_BLENDMODE_MOD": {
          "doc": "",
          "name": "SDL_BLENDMODE_MOD",
          "kind": "def"
        },
        "SDL_BLENDMODE_MUL": {
          "doc": "",
          "name": "SDL_BLENDMODE_MUL",
          "kind": "def"
        },
        "SDL_BLENDMODE_INVALID": {
          "doc": "",
          "name": "SDL_BLENDMODE_INVALID",
          "kind": "def"
        },
        "SDL_BlendOperation": {
          "doc": "The blend operation used when combining source and destination pixel\ncomponents.\n\n\\since This enum is available since SDL 3.2.0.",
          "name": "SDL_BlendOperation",
          "kind": "enum"
        },
        "SDL_BlendFactor": {
          "doc": "The normalized factor used to multiply pixel components.\n\nThe blend factors are multiplied with the pixels from a drawing operation\n(src) and the pixels from the render target (dst) before the blend\noperation. The comma-separated factors listed above are always applied in\nthe component order red, green, blue, and alpha.\n\n\\since This enum is available since SDL 3.2.0.",
          "name": "SDL_BlendFactor",
          "kind": "enum"
        },
        "SDL_ComposeCustomBlendMode": {
          "doc": "Compose a custom blend mode for renderers.\n\nThe functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept\nthe SDL_BlendMode returned by this function if the renderer supports it.\n\nA blend mode controls how the pixels from a drawing operation (source) get\ncombined with the pixels from the render target (destination). First, the\ncomponents of the source and destination pixels get multiplied with their\nblend factors. Then, the blend operation takes the two products and\ncalculates the result that will get stored in the render target.\n\nExpressed in pseudocode, it would look like this:\n\n```c\ndstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);\ndstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);\n```\n\nWhere the functions `colorOperation(src, dst)` and `alphaOperation(src,\ndst)` can return one of the following:\n\n- `src + dst`\n- `src - dst`\n- `dst - src`\n- `min(src, dst)`\n- `max(src, dst)`\n\nThe red, green, and blue components are always multiplied with the first,\nsecond, and third components of the SDL_BlendFactor, respectively. The\nfourth component is not used.\n\nThe alpha component is always multiplied with the fourth component of the\nSDL_BlendFactor. The other components are not used in the alpha\ncalculation.\n\nSupport for these blend modes varies for each renderer. To check if a\nspecific SDL_BlendMode is supported, create a renderer and pass it to\neither SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will\nreturn with an error if the blend mode is not supported.\n\nThis list describes the support of custom blend modes for each renderer.\nAll renderers support the four blend modes listed in the SDL_BlendMode\nenumeration.\n\n- **direct3d**: Supports all operations with all factors. However, some\n  factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and\n  `SDL_BLENDOPERATION_MAXIMUM`.\n- **direct3d11**: Same as Direct3D 9.\n- **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all\n  factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly here.\n- **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,\n  `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`\n  operations with all factors.\n- **psp**: No custom blend mode support.\n- **software**: No custom blend mode support.\n\nSome renderers do not provide an alpha component for the default render\ntarget. The `SDL_BLENDFACTOR_DST_ALPHA` and\n`SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this\ncase.\n\n\\param srcColorFactor the SDL_BlendFactor applied to the red, green, and\n                      blue components of the source pixels.\n\\param dstColorFactor the SDL_BlendFactor applied to the red, green, and\n                      blue components of the destination pixels.\n\\param colorOperation the SDL_BlendOperation used to combine the red,\n                      green, and blue components of the source and\n                      destination pixels.\n\\param srcAlphaFactor the SDL_BlendFactor applied to the alpha component of\n                      the source pixels.\n\\param dstAlphaFactor the SDL_BlendFactor applied to the alpha component of\n                      the destination pixels.\n\\param alphaOperation the SDL_BlendOperation used to combine the alpha\n                      component of the source and destination pixels.\n\\returns an SDL_BlendMode that represents the chosen factors and\n         operations.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_SetRenderDrawBlendMode\n\\sa SDL_GetRenderDrawBlendMode\n\\sa SDL_SetTextureBlendMode\n\\sa SDL_GetTextureBlendMode",
          "name": "SDL_ComposeCustomBlendMode",
          "kind": "function",
          "type": "SDL_BlendMode",
          "parameters": [
            {
              "name": "srcColorFactor",
              "type": "SDL_BlendFactor"
            },
            {
              "name": "dstColorFactor",
              "type": "SDL_BlendFactor"
            },
            {
              "name": "colorOperation",
              "type": "SDL_BlendOperation"
            },
            {
              "name": "srcAlphaFactor",
              "type": "SDL_BlendFactor"
            },
            {
              "name": "dstAlphaFactor",
              "type": "SDL_BlendFactor"
            },
            {
              "name": "alphaOperation",
              "type": "SDL_BlendOperation"
            }
          ]
        }
      }
    },
    "SDL_properties.h": {
      "name": "SDL_properties.h",
      "doc": "# CategoryProperties\n\nA property is a variable that can be created and retrieved by name at\nruntime.\n\nAll properties are part of a property group (SDL_PropertiesID). A property\ngroup can be created with the SDL_CreateProperties function and destroyed\nwith the SDL_DestroyProperties function.\n\nProperties can be added to and retrieved from a property group through the\nfollowing functions:\n\n- SDL_SetPointerProperty and SDL_GetPointerProperty operate on `void*`\n  pointer types.\n- SDL_SetStringProperty and SDL_GetStringProperty operate on string types.\n- SDL_SetNumberProperty and SDL_GetNumberProperty operate on signed 64-bit\n  integer types.\n- SDL_SetFloatProperty and SDL_GetFloatProperty operate on floating point\n  types.\n- SDL_SetBooleanProperty and SDL_GetBooleanProperty operate on boolean\n  types.\n\nProperties can be removed from a group by using SDL_ClearProperty.",
      "entries": {
        "SDL_PropertiesID": {
          "doc": "SDL properties ID\n\n\\since This datatype is available since SDL 3.2.0.",
          "name": "SDL_PropertiesID",
          "kind": "alias",
          "type": "Uint32"
        },
        "SDL_PropertyType": {
          "doc": "SDL property type\n\n\\since This enum is available since SDL 3.2.0.",
          "name": "SDL_PropertyType",
          "kind": "enum"
        },
        "SDL_GetGlobalProperties": {
          "doc": "Get the global SDL properties.\n\n\\returns a valid property ID on success or 0 on failure; call\n         SDL_GetError() for more information.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_GetGlobalProperties",
          "kind": "function",
          "type": "SDL_PropertiesID",
          "parameters": []
        },
        "SDL_CreateProperties": {
          "doc": "Create a group of properties.\n\nAll properties are automatically destroyed when SDL_Quit() is called.\n\n\\returns an ID for a new group of properties, or 0 on failure; call\n         SDL_GetError() for more information.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_DestroyProperties",
          "name": "SDL_CreateProperties",
          "kind": "function",
          "type": "SDL_PropertiesID",
          "parameters": []
        },
        "SDL_CopyProperties": {
          "doc": "Copy a group of properties.\n\nCopy all the properties from one group of properties to another, with the\nexception of properties requiring cleanup (set using\nSDL_SetPointerPropertyWithCleanup()), which will not be copied. Any\nproperty that already exists on `dst` will be overwritten.\n\n\\param src the properties to copy.\n\\param dst the destination properties.\n\\returns true on success or false on failure; call SDL_GetError() for more\n         information.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_CopyProperties",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "src",
              "type": "SDL_PropertiesID"
            },
            {
              "name": "dst",
              "type": "SDL_PropertiesID"
            }
          ]
        },
        "SDL_LockProperties": {
          "doc": "Lock a group of properties.\n\nObtain a multi-threaded lock for these properties. Other threads will wait\nwhile trying to lock these properties until they are unlocked. Properties\nmust be unlocked before they are destroyed.\n\nThe lock is automatically taken when setting individual properties, this\nfunction is only needed when you want to set several properties atomically\nor want to guarantee that properties being queried aren't freed in another\nthread.\n\n\\param props the properties to lock.\n\\returns true on success or false on failure; call SDL_GetError() for more\n         information.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_UnlockProperties",
          "name": "SDL_LockProperties",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "props",
              "type": "SDL_PropertiesID"
            }
          ]
        },
        "SDL_UnlockProperties": {
          "doc": "Unlock a group of properties.\n\n\\param props the properties to unlock.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_LockProperties",
          "name": "SDL_UnlockProperties",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "props",
              "type": "SDL_PropertiesID"
            }
          ]
        },
        "SDL_CleanupPropertyCallback": {
          "doc": "A callback used to free resources when a property is deleted.\n\nThis should release any resources associated with `value` that are no\nlonger needed.\n\nThis callback is set per-property. Different properties in the same group\ncan have different cleanup callbacks.\n\nThis callback will be called _during_ SDL_SetPointerPropertyWithCleanup if\nthe function fails for any reason.\n\n\\param userdata an app-defined pointer passed to the callback.\n\\param value the pointer assigned to the property to clean up.\n\n\\threadsafety This callback may fire without any locks held; if this is a\n              concern, the app should provide its own locking.\n\n\\since This datatype is available since SDL 3.2.0.\n\n\\sa SDL_SetPointerPropertyWithCleanup",
          "name": "SDL_CleanupPropertyCallback",
          "kind": "callback",
          "type": "void",
          "parameters": [
            {
              "name": "userdata",
              "type": "void *"
            },
            {
              "name": "value",
              "type": "void *"
            }
          ]
        },
        "SDL_SetPointerPropertyWithCleanup": {
          "doc": "Set a pointer property in a group of properties with a cleanup function\nthat is called when the property is deleted.\n\nThe cleanup function is also called if setting the property fails for any\nreason.\n\nFor simply setting basic data types, like numbers, bools, or strings, use\nSDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty\ninstead, as those functions will handle cleanup on your behalf. This\nfunction is only for more complex, custom data.\n\n\\param props the properties to modify.\n\\param name the name of the property to modify.\n\\param value the new value of the property, or NULL to delete the property.\n\\param cleanup the function to call when this property is deleted, or NULL\n               if no cleanup is necessary.\n\\param userdata a pointer that is passed to the cleanup function.\n\\returns true on success or false on failure; call SDL_GetError() for more\n         information.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetPointerProperty\n\\sa SDL_SetPointerProperty\n\\sa SDL_CleanupPropertyCallback",
          "name": "SDL_SetPointerPropertyWithCleanup",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "props",
              "type": "SDL_PropertiesID"
            },
            {
              "name": "name",
              "type": "const char *"
            },
            {
              "name": "value",
              "type": "void *"
            },
            {
              "name": "cleanup",
              "type": "SDL_CleanupPropertyCallback"
            },
            {
              "name": "userdata",
              "type": "void *"
            }
          ]
        },
        "SDL_SetPointerProperty": {
          "doc": "Set a pointer property in a group of properties.\n\n\\param props the properties to modify.\n\\param name the name of the property to modify.\n\\param value the new value of the property, or NULL to delete the property.\n\\returns true on success or false on failure; call SDL_GetError() for more\n         information.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetPointerProperty\n\\sa SDL_HasProperty\n\\sa SDL_SetBooleanProperty\n\\sa SDL_SetFloatProperty\n\\sa SDL_SetNumberProperty\n\\sa SDL_SetPointerPropertyWithCleanup\n\\sa SDL_SetStringProperty",
          "name": "SDL_SetPointerProperty",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "props",
              "type": "SDL_PropertiesID"
            },
            {
              "name": "name",
              "type": "const char *"
            },
            {
              "name": "value",
              "type": "void *"
            }
          ]
        },
        "SDL_SetStringProperty": {
          "doc": "Set a string property in a group of properties.\n\nThis function makes a copy of the string; the caller does not have to\npreserve the data after this call completes.\n\n\\param props the properties to modify.\n\\param name the name of the property to modify.\n\\param value the new value of the property, or NULL to delete the property.\n\\returns true on success or false on failure; call SDL_GetError() for more\n         information.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetStringProperty",
          "name": "SDL_SetStringProperty",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "props",
              "type": "SDL_PropertiesID"
            },
            {
              "name": "name",
              "type": "const char *"
            },
            {
              "name": "value",
              "type": "const char *"
            }
          ]
        },
        "SDL_SetNumberProperty": {
          "doc": "Set an integer property in a group of properties.\n\n\\param props the properties to modify.\n\\param name the name of the property to modify.\n\\param value the new value of the property.\n\\returns true on success or false on failure; call SDL_GetError() for more\n         information.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetNumberProperty",
          "name": "SDL_SetNumberProperty",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "props",
              "type": "SDL_PropertiesID"
            },
            {
              "name": "name",
              "type": "const char *"
            },
            {
              "name": "value",
              "type": "Sint64"
            }
          ]
        },
        "SDL_SetFloatProperty": {
          "doc": "Set a floating point property in a group of properties.\n\n\\param props the properties to modify.\n\\param name the name of the property to modify.\n\\param value the new value of the property.\n\\returns true on success or false on failure; call SDL_GetError() for more\n         information.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetFloatProperty",
          "name": "SDL_SetFloatProperty",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "props",
              "type": "SDL_PropertiesID"
            },
            {
              "name": "name",
              "type": "const char *"
            },
            {
              "name": "value",
              "type": "float"
            }
          ]
        },
        "SDL_SetBooleanProperty": {
          "doc": "Set a boolean property in a group of properties.\n\n\\param props the properties to modify.\n\\param name the name of the property to modify.\n\\param value the new value of the property.\n\\returns true on success or false on failure; call SDL_GetError() for more\n         information.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetBooleanProperty",
          "name": "SDL_SetBooleanProperty",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "props",
              "type": "SDL_PropertiesID"
            },
            {
              "name": "name",
              "type": "const char *"
            },
            {
              "name": "value",
              "type": "bool"
            }
          ]
        },
        "SDL_HasProperty": {
          "doc": "Return whether a property exists in a group of properties.\n\n\\param props the properties to query.\n\\param name the name of the property to query.\n\\returns true if the property exists, or false if it doesn't.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetPropertyType",
          "name": "SDL_HasProperty",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "props",
              "type": "SDL_PropertiesID"
            },
            {
              "name": "name",
              "type": "const char *"
            }
          ]
        },
        "SDL_GetPropertyType": {
          "doc": "Get the type of a property in a group of properties.\n\n\\param props the properties to query.\n\\param name the name of the property to query.\n\\returns the type of the property, or SDL_PROPERTY_TYPE_INVALID if it is\n         not set.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_HasProperty",
          "name": "SDL_GetPropertyType",
          "kind": "function",
          "type": "SDL_PropertyType",
          "parameters": [
            {
              "name": "props",
              "type": "SDL_PropertiesID"
            },
            {
              "name": "name",
              "type": "const char *"
            }
          ]
        },
        "SDL_GetPointerProperty": {
          "doc": "Get a pointer property from a group of properties.\n\nBy convention, the names of properties that SDL exposes on objects will\nstart with \"SDL.\", and properties that SDL uses internally will start with\n\"SDL.internal.\". These should be considered read-only and should not be\nmodified by applications.\n\n\\param props the properties to query.\n\\param name the name of the property to query.\n\\param default_value the default value of the property.\n\\returns the value of the property, or `default_value` if it is not set or\n         not a pointer property.\n\n\\threadsafety It is safe to call this function from any thread, although\n              the data returned is not protected and could potentially be\n              freed if you call SDL_SetPointerProperty() or\n              SDL_ClearProperty() on these properties from another thread.\n              If you need to avoid this, use SDL_LockProperties() and\n              SDL_UnlockProperties().\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetBooleanProperty\n\\sa SDL_GetFloatProperty\n\\sa SDL_GetNumberProperty\n\\sa SDL_GetPropertyType\n\\sa SDL_GetStringProperty\n\\sa SDL_HasProperty\n\\sa SDL_SetPointerProperty",
          "name": "SDL_GetPointerProperty",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "props",
              "type": "SDL_PropertiesID"
            },
            {
              "name": "name",
              "type": "const char *"
            },
            {
              "name": "default_value",
              "type": "void *"
            }
          ]
        },
        "SDL_GetStringProperty": {
          "doc": "Get a string property from a group of properties.\n\n\\param props the properties to query.\n\\param name the name of the property to query.\n\\param default_value the default value of the property.\n\\returns the value of the property, or `default_value` if it is not set or\n         not a string property.\n\n\\threadsafety It is safe to call this function from any thread, although\n              the data returned is not protected and could potentially be\n              freed if you call SDL_SetStringProperty() or\n              SDL_ClearProperty() on these properties from another thread.\n              If you need to avoid this, use SDL_LockProperties() and\n              SDL_UnlockProperties().\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetPropertyType\n\\sa SDL_HasProperty\n\\sa SDL_SetStringProperty",
          "name": "SDL_GetStringProperty",
          "kind": "function",
          "type": "const char *",
          "parameters": [
            {
              "name": "props",
              "type": "SDL_PropertiesID"
            },
            {
              "name": "name",
              "type": "const char *"
            },
            {
              "name": "default_value",
              "type": "const char *"
            }
          ]
        },
        "SDL_GetNumberProperty": {
          "doc": "Get a number property from a group of properties.\n\nYou can use SDL_GetPropertyType() to query whether the property exists and\nis a number property.\n\n\\param props the properties to query.\n\\param name the name of the property to query.\n\\param default_value the default value of the property.\n\\returns the value of the property, or `default_value` if it is not set or\n         not a number property.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetPropertyType\n\\sa SDL_HasProperty\n\\sa SDL_SetNumberProperty",
          "name": "SDL_GetNumberProperty",
          "kind": "function",
          "type": "Sint64",
          "parameters": [
            {
              "name": "props",
              "type": "SDL_PropertiesID"
            },
            {
              "name": "name",
              "type": "const char *"
            },
            {
              "name": "default_value",
              "type": "Sint64"
            }
          ]
        },
        "SDL_GetFloatProperty": {
          "doc": "Get a floating point property from a group of properties.\n\nYou can use SDL_GetPropertyType() to query whether the property exists and\nis a floating point property.\n\n\\param props the properties to query.\n\\param name the name of the property to query.\n\\param default_value the default value of the property.\n\\returns the value of the property, or `default_value` if it is not set or\n         not a float property.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetPropertyType\n\\sa SDL_HasProperty\n\\sa SDL_SetFloatProperty",
          "name": "SDL_GetFloatProperty",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "props",
              "type": "SDL_PropertiesID"
            },
            {
              "name": "name",
              "type": "const char *"
            },
            {
              "name": "default_value",
              "type": "float"
            }
          ]
        },
        "SDL_GetBooleanProperty": {
          "doc": "Get a boolean property from a group of properties.\n\nYou can use SDL_GetPropertyType() to query whether the property exists and\nis a boolean property.\n\n\\param props the properties to query.\n\\param name the name of the property to query.\n\\param default_value the default value of the property.\n\\returns the value of the property, or `default_value` if it is not set or\n         not a boolean property.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_GetPropertyType\n\\sa SDL_HasProperty\n\\sa SDL_SetBooleanProperty",
          "name": "SDL_GetBooleanProperty",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "props",
              "type": "SDL_PropertiesID"
            },
            {
              "name": "name",
              "type": "const char *"
            },
            {
              "name": "default_value",
              "type": "bool"
            }
          ]
        },
        "SDL_ClearProperty": {
          "doc": "Clear a property from a group of properties.\n\n\\param props the properties to modify.\n\\param name the name of the property to clear.\n\\returns true on success or false on failure; call SDL_GetError() for more\n         information.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_ClearProperty",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "props",
              "type": "SDL_PropertiesID"
            },
            {
              "name": "name",
              "type": "const char *"
            }
          ]
        },
        "SDL_EnumeratePropertiesCallback": {
          "doc": "A callback used to enumerate all the properties in a group of properties.\n\nThis callback is called from SDL_EnumerateProperties(), and is called once\nper property in the set.\n\n\\param userdata an app-defined pointer passed to the callback.\n\\param props the SDL_PropertiesID that is being enumerated.\n\\param name the next property name in the enumeration.\n\n\\threadsafety SDL_EnumerateProperties holds a lock on `props` during this\n              callback.\n\n\\since This datatype is available since SDL 3.2.0.\n\n\\sa SDL_EnumerateProperties",
          "name": "SDL_EnumeratePropertiesCallback",
          "kind": "callback",
          "type": "void",
          "parameters": [
            {
              "name": "userdata",
              "type": "void *"
            },
            {
              "name": "props",
              "type": "SDL_PropertiesID"
            },
            {
              "name": "name",
              "type": "const char *"
            }
          ]
        },
        "SDL_EnumerateProperties": {
          "doc": "Enumerate the properties contained in a group of properties.\n\nThe callback function is called for each property in the group of\nproperties. The properties are locked during enumeration.\n\n\\param props the properties to query.\n\\param callback the function to call for each property.\n\\param userdata a pointer that is passed to `callback`.\n\\returns true on success or false on failure; call SDL_GetError() for more\n         information.\n\n\\threadsafety It is safe to call this function from any thread.\n\n\\since This function is available since SDL 3.2.0.",
          "name": "SDL_EnumerateProperties",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "props",
              "type": "SDL_PropertiesID"
            },
            {
              "name": "callback",
              "type": "SDL_EnumeratePropertiesCallback"
            },
            {
              "name": "userdata",
              "type": "void *"
            }
          ]
        },
        "SDL_DestroyProperties": {
          "doc": "Destroy a group of properties.\n\nAll properties are deleted and their cleanup functions will be called, if\nany.\n\n\\param props the properties to destroy.\n\n\\threadsafety This function should not be called while these properties are\n              locked or other threads might be setting or getting values\n              from these properties.\n\n\\since This function is available since SDL 3.2.0.\n\n\\sa SDL_CreateProperties",
          "name": "SDL_DestroyProperties",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "props",
              "type": "SDL_PropertiesID"
            }
          ]
        }
      }
    }
  }
}
