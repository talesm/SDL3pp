{
  "files": {
    "SDL3pp_stdinc.h": {
      "name": "SDL3pp_stdinc.h",
      "doc": "@defgroup CategoryStdinc Category Stdinc\n\nSDL provides its own implementation of some of the most important C runtime\nfunctions.\n\nUsing these functions allows an app to have access to common C\nfunctionality without depending on a specific C runtime (or a C runtime at\nall). More importantly, the SDL implementations work identically across\nplatforms, so apps can avoid surprises like snprintf() behaving differently\nbetween Windows and Linux builds, or itoa() only existing on some\nplatforms.\n\nFor many of the most common functions, like memcpy, SDL might just call\nthrough to the usual C runtime behind the scenes, if it makes sense to do\nso (if it's faster and always available/reliable on a given platform),\nreducing library size and offering the most optimized option.\n\nSDL also offers other C-runtime-adjacent functionality in this header that\neither isn't, strictly speaking, part of any C runtime standards, like\ncrc32() and SDL_reinterpret_cast, etc. It also offers a few better\noptions, like strlcpy(), which functions as a safer form of strcpy().",
      "entries": {
        "EnvironmentBase-forward": {
          "name": "EnvironmentBase",
          "kind": "forward",
          "template": [
            {
              "type": "ObjectBox<SDL_Environment *>",
              "name": "T"
            }
          ],
          "doc": ""
        },
        "EnvironmentRef": {
          "name": "EnvironmentRef",
          "kind": "alias",
          "type": "EnvironmentBase<ObjectRef<SDL_Environment>>",
          "doc": "Handle to a non owned environment\n\n@cat resource\n\n@sa EnvironmentBase\n@sa Environment"
        },
        "Environment": {
          "name": "Environment",
          "kind": "alias",
          "type": "EnvironmentBase<ObjectUnique<SDL_Environment>>",
          "doc": "Handle to an owned environment\n\n@cat resource\n\n@sa EnvironmentBase\n@sa EnvironmentRef"
        },
        "IConvBase-forward": {
          "name": "IConvBase",
          "kind": "forward",
          "template": [
            {
              "type": "ObjectBox<SDL_iconv_data_t *>",
              "name": "T"
            }
          ],
          "doc": ""
        },
        "IConvRef": {
          "name": "IConvRef",
          "kind": "alias",
          "type": "IConvBase<ObjectRef<SDL_iconv_data_t>>",
          "doc": "Handle to a non owned iConv\n\n@cat resource\n\n@sa IConvBase\n@sa IConv"
        },
        "IConv": {
          "name": "IConv",
          "kind": "alias",
          "type": "IConvBase<ObjectUnique<SDL_iconv_data_t>>",
          "doc": "Handle to an owned iConv\n\n@cat resource\n\n@sa IConvBase\n@sa IConvRef"
        },
        "SDL_NOLONGLONG": {
          "doc": "Don't let SDL use \"long long\" C types.\n\nSDL will define this if it believes the compiler doesn't understand the\n\"long long\" syntax for C datatypes. This can happen on older compilers.\n\nIf _your_ compiler doesn't support \"long long\" but SDL doesn't know it, it\nis safe to define this yourself to build against the SDL headers.\n\nIf this is defined, it will remove access to some C runtime support\nfunctions, like SDL_ulltoa and SDL_strtoll that refer to this datatype\nexplicitly. The rest of SDL will still be available.\n\nSDL's own source code cannot be built with a compiler that has this\ndefined, for various technical reasons.",
          "name": "SDL_NOLONGLONG",
          "kind": "def",
          "value": "1",
          "sourceName": "SDL_NOLONGLONG"
        },
        "SDL_SIZE_MAX": {
          "doc": "The largest value that a `size_t` can hold for the target platform.\n\n`size_t` is generally the same size as a pointer in modern times, but this\ncan get weird on very old and very esoteric machines. For example, on a\n16-bit Intel 286, you might have a 32-bit \"far\" pointer (16-bit segment\nplus 16-bit offset), but `size_t` is 16 bits, because it can only deal with\nthe offset into an individual segment.\n\nIn modern times, it's generally expected to cover an entire linear address\nspace. But be careful!\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_SIZE_MAX",
          "kind": "def",
          "value": "SIZE_MAX",
          "sourceName": "SDL_SIZE_MAX"
        },
        "arraysize": {
          "doc": "The number of elements in a static array.\n\nThis will compile but return incorrect results for a pointer to an array;\nit has to be an array the compiler knows the size of.\n\nThis macro looks like it double-evaluates the argument, but it does so\ninside of `sizeof`, so there are no side-effects here, as expressions do\nnot actually run any code in these cases.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "arraysize",
          "kind": "function",
          "parameters": [
            {
              "type": "const T",
              "name": "(&array)[N]"
            }
          ],
          "value": "(sizeof(array)/sizeof(array[0]))",
          "sourceName": "SDL_arraysize",
          "type": "std::size_t",
          "constexpr": true,
          "template": [
            {
              "type": "class",
              "name": "T"
            },
            {
              "type": "std::size_t",
              "name": "N"
            }
          ]
        },
        "SDL_STRINGIFY_ARG": {
          "doc": "Macro useful for building other macros with strings in them.\n\nFor example:\n\n```c\n#define LOG_ERROR(X) OutputDebugString(SDL_STRINGIFY_ARG(__FUNCTION__) \": \" X \"@n\")`\n```\n\n@param arg the text to turn into a string literal.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_STRINGIFY_ARG",
          "kind": "def",
          "parameters": [
            "arg"
          ],
          "value": "#arg",
          "sourceName": "SDL_STRINGIFY_ARG"
        },
        "FourCC": {
          "doc": "Define a four character code as a Uint32.\n\n@param A the first ASCII character.\n@param B the second ASCII character.\n@param C the third ASCII character.\n@param D the fourth ASCII character.\n@returns the four characters converted into a Uint32, one character\n         per-byte.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "FourCC",
          "kind": "function",
          "parameters": [
            {
              "name": "a",
              "type": "Uint8"
            },
            {
              "name": "b",
              "type": "Uint8"
            },
            {
              "name": "c",
              "type": "Uint8"
            },
            {
              "name": "d",
              "type": "Uint8"
            }
          ],
          "value": "    ((SDL_static_cast(Uint32, SDL_static_cast(Uint8, (A))) << 0) | \\\n     (SDL_static_cast(Uint32, SDL_static_cast(Uint8, (B))) << 8) | \\\n     (SDL_static_cast(Uint32, SDL_static_cast(Uint8, (C))) << 16) | \\\n     (SDL_static_cast(Uint32, SDL_static_cast(Uint8, (D))) << 24))",
          "sourceName": "SDL_FOURCC",
          "type": "Uint32",
          "constexpr": true
        },
        "SDL_SINT64_C": {
          "doc": "Append the 64 bit integer suffix to a signed integer literal.\n\nThis helps compilers that might believe a integer literal larger than\n0xFFFFFFFF is overflowing a 32-bit value. Use `SDL_SINT64_C(0xFFFFFFFF1)`\ninstead of `0xFFFFFFFF1` by itself.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_UINT64_C",
          "name": "SDL_SINT64_C",
          "kind": "def",
          "parameters": [
            "c"
          ],
          "value": "c ## LL  /* or whatever the current compiler uses. */",
          "sourceName": "SDL_SINT64_C"
        },
        "SDL_UINT64_C": {
          "doc": "Append the 64 bit integer suffix to an unsigned integer literal.\n\nThis helps compilers that might believe a integer literal larger than\n0xFFFFFFFF is overflowing a 32-bit value. Use `SDL_UINT64_C(0xFFFFFFFF1)`\ninstead of `0xFFFFFFFF1` by itself.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_SINT64_C",
          "name": "SDL_UINT64_C",
          "kind": "def",
          "parameters": [
            "c"
          ],
          "value": "c ## ULL /* or whatever the current compiler uses. */",
          "sourceName": "SDL_UINT64_C"
        },
        "MAX_SINT8": {
          "doc": "",
          "name": "MAX_SINT8",
          "kind": "var",
          "value": "((Sint8)0x7F)           /* 127 */",
          "sourceName": "SDL_MAX_SINT8",
          "type": "Sint8",
          "constexpr": true
        },
        "MIN_SINT8": {
          "doc": "",
          "name": "MIN_SINT8",
          "kind": "var",
          "value": "((Sint8)(~0x7F))        /* -128 */",
          "sourceName": "SDL_MIN_SINT8",
          "type": "Sint8",
          "constexpr": true
        },
        "MAX_UINT8": {
          "doc": "",
          "name": "MAX_UINT8",
          "kind": "var",
          "value": "((Uint8)0xFF)           /* 255 */",
          "sourceName": "SDL_MAX_UINT8",
          "type": "Uint8",
          "constexpr": true
        },
        "MIN_UINT8": {
          "doc": "",
          "name": "MIN_UINT8",
          "kind": "var",
          "value": "((Uint8)0x00)           /* 0 */",
          "sourceName": "SDL_MIN_UINT8",
          "type": "Uint8",
          "constexpr": true
        },
        "MAX_SINT16": {
          "doc": "",
          "name": "MAX_SINT16",
          "kind": "var",
          "value": "((Sint16)0x7FFF)        /* 32767 */",
          "sourceName": "SDL_MAX_SINT16",
          "type": "Sint16",
          "constexpr": true
        },
        "MIN_SINT16": {
          "doc": "",
          "name": "MIN_SINT16",
          "kind": "var",
          "value": "((Sint16)(~0x7FFF))     /* -32768 */",
          "sourceName": "SDL_MIN_SINT16",
          "type": "Sint16",
          "constexpr": true
        },
        "MAX_UINT16": {
          "doc": "",
          "name": "MAX_UINT16",
          "kind": "var",
          "value": "((Uint16)0xFFFF)        /* 65535 */",
          "sourceName": "SDL_MAX_UINT16",
          "type": "Uint16",
          "constexpr": true
        },
        "MIN_UINT16": {
          "doc": "",
          "name": "MIN_UINT16",
          "kind": "var",
          "value": "((Uint16)0x0000)        /* 0 */",
          "sourceName": "SDL_MIN_UINT16",
          "type": "Uint16",
          "constexpr": true
        },
        "MAX_SINT32": {
          "doc": "",
          "name": "MAX_SINT32",
          "kind": "var",
          "value": "((Sint32)0x7FFFFFFF)    /* 2147483647 */",
          "sourceName": "SDL_MAX_SINT32",
          "type": "Sint32",
          "constexpr": true
        },
        "MIN_SINT32": {
          "doc": "",
          "name": "MIN_SINT32",
          "kind": "var",
          "value": "((Sint32)(~0x7FFFFFFF)) /* -2147483648 */",
          "sourceName": "SDL_MIN_SINT32",
          "type": "Sint32",
          "constexpr": true
        },
        "MAX_UINT32": {
          "doc": "",
          "name": "MAX_UINT32",
          "kind": "var",
          "value": "((Uint32)0xFFFFFFFFu)   /* 4294967295 */",
          "sourceName": "SDL_MAX_UINT32",
          "type": "Uint32",
          "constexpr": true
        },
        "MIN_UINT32": {
          "doc": "",
          "name": "MIN_UINT32",
          "kind": "var",
          "value": "((Uint32)0x00000000)    /* 0 */",
          "sourceName": "SDL_MIN_UINT32",
          "type": "Uint8",
          "constexpr": true
        },
        "MAX_SINT64": {
          "doc": "",
          "name": "MAX_SINT64",
          "kind": "var",
          "value": "SDL_SINT64_C(0x7FFFFFFFFFFFFFFF)   /* 9223372036854775807 */",
          "sourceName": "SDL_MAX_SINT64",
          "type": "Sint64",
          "constexpr": true
        },
        "MIN_SINT64": {
          "doc": "",
          "name": "MIN_SINT64",
          "kind": "var",
          "value": "~SDL_SINT64_C(0x7FFFFFFFFFFFFFFF)  /* -9223372036854775808 */",
          "sourceName": "SDL_MIN_SINT64",
          "type": "Sint64",
          "constexpr": true
        },
        "MAX_UINT64": {
          "doc": "",
          "name": "MAX_UINT64",
          "kind": "var",
          "value": "SDL_UINT64_C(0xFFFFFFFFFFFFFFFF)   /* 18446744073709551615 */",
          "sourceName": "SDL_MAX_UINT64",
          "type": "Uint64",
          "constexpr": true
        },
        "MIN_UINT64": {
          "doc": "",
          "name": "MIN_UINT64",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000000000000)   /* 0 */",
          "sourceName": "SDL_MIN_UINT64",
          "type": "Uint8",
          "constexpr": true
        },
        "Time": {
          "doc": "SDL times are signed, 64-bit integers representing nanoseconds since the\nUnix epoch (Jan 1, 1970).\n\nThey can be converted between POSIX time_t values with Time::ToPosix()\nand Time::FromPosix(), and between Windows FILETIME values with\nTime::ToWindows() and Time::FromWindows().\n\n@since This macro is available since SDL 3.2.0.\n\n@sa MAX_SINT64\n@sa MIN_SINT64",
          "name": "Time",
          "kind": "struct",
          "type": "",
          "sourceName": "SDL_Time",
          "entries": {
            "m_value": {
              "kind": "var",
              "type": "std::chrono::nanoseconds",
              "name": "m_value",
              "doc": ""
            },
            "Time": [
              {
                "kind": "function",
                "constexpr": true,
                "type": "",
                "parameters": [],
                "name": "Time",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "std::chrono::nanoseconds",
                    "name": "time"
                  }
                ],
                "name": "Time",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "",
                "explicit": true,
                "constexpr": true,
                "parameters": [
                  {
                    "type": "SDL_Time",
                    "name": "time"
                  }
                ],
                "name": "Time",
                "doc": ""
              }
            ],
            "operator bool": {
              "kind": "function",
              "type": "",
              "explicit": true,
              "immutable": true,
              "constexpr": true,
              "parameters": [],
              "name": "operator bool",
              "doc": ""
            },
            "operator std::chrono::nanoseconds": {
              "kind": "function",
              "type": "",
              "immutable": true,
              "constexpr": true,
              "parameters": [],
              "name": "operator std::chrono::nanoseconds",
              "doc": ""
            },
            "Current": {
              "kind": "function",
              "type": "Time",
              "static": true,
              "parameters": [],
              "name": "Current",
              "doc": ""
            },
            "FromNS": {
              "kind": "function",
              "type": "Time",
              "constexpr": true,
              "static": true,
              "parameters": [
                {
                  "type": "Sint64",
                  "name": "time"
                }
              ],
              "name": "FromNS",
              "doc": ""
            },
            "ToNS": {
              "kind": "function",
              "type": "Sint64",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "name": "ToNS",
              "doc": ""
            },
            "FromPosix": {
              "kind": "function",
              "type": "Time",
              "constexpr": true,
              "static": true,
              "parameters": [
                {
                  "type": "Sint64",
                  "name": "time"
                }
              ],
              "name": "FromPosix",
              "doc": ""
            },
            "ToPosix": {
              "kind": "function",
              "type": "Sint64",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "name": "ToPosix",
              "doc": ""
            },
            "FromWindows": {
              "kind": "function",
              "type": "Time",
              "static": true,
              "parameters": [
                {
                  "type": "Uint32",
                  "name": "dwLowDateTime"
                },
                {
                  "type": "Uint32",
                  "name": "dwHighDateTime"
                }
              ],
              "name": "FromWindows",
              "doc": ""
            },
            "ToWindows": {
              "kind": "function",
              "type": "void",
              "immutable": true,
              "parameters": [
                {
                  "type": "Uint32 *",
                  "name": "dwLowDateTime"
                },
                {
                  "type": "Uint32 *",
                  "name": "dwHighDateTime"
                }
              ],
              "name": "ToWindows",
              "doc": ""
            },
            "operator+=": {
              "kind": "function",
              "type": "Time &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "std::chrono::nanoseconds",
                  "name": "interval"
                }
              ],
              "name": "operator+=",
              "doc": ""
            },
            "operator-=": {
              "kind": "function",
              "type": "Time &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "std::chrono::nanoseconds",
                  "name": "interval"
                }
              ],
              "name": "operator-=",
              "doc": ""
            }
          }
        },
        "MAX_TIME": {
          "doc": "",
          "name": "MAX_TIME",
          "kind": "var",
          "value": "SDL_MAX_SINT64",
          "sourceName": "SDL_MAX_TIME",
          "type": "Time",
          "constexpr": true
        },
        "MIN_TIME": {
          "doc": "",
          "name": "MIN_TIME",
          "kind": "var",
          "value": "SDL_MIN_SINT64",
          "sourceName": "SDL_MIN_TIME",
          "type": "Time",
          "constexpr": true
        },
        "SDL_FLT_EPSILON": {
          "doc": "Epsilon constant, used for comparing floating-point numbers.\n\nEquals by default to platform-defined `FLT_EPSILON`, or\n`1.1920928955078125e-07F` if that's not available.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_FLT_EPSILON",
          "kind": "def",
          "value": "1.1920928955078125e-07F /* 0x0.000002p0 */",
          "sourceName": "SDL_FLT_EPSILON"
        },
        "SDL_INIT_INTERFACE": {
          "doc": "A macro to initialize an SDL interface.\n\nThis macro will initialize an SDL interface structure and should be called\nbefore you fill out the fields with your implementation.\n\nYou can use it like this:\n\n```c\nIOStreamInterface iface;\n\nSDL_INIT_INTERFACE(&iface);\n\n// Fill in the interface function pointers with your implementation\niface.seek = ...\n\nstream = IOStreamBase.IOStreamBase(&iface, nullptr);\n```\n\nIf you are using designated initializers, you can use the size of the\ninterface as the version, e.g.\n\n```c\nIOStreamInterface iface = {\n    .version = sizeof(iface),\n    .seek = ...\n};\nstream = IOStreamBase.IOStreamBase(&iface, nullptr);\n```\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa IOStreamInterface\n@sa SDL_StorageInterface\n@sa SDL_VirtualJoystickDesc",
          "name": "SDL_INIT_INTERFACE",
          "kind": "def",
          "parameters": [
            "iface"
          ],
          "value": "    do {                                        \\\n        SDL_zerop(iface);                       \\\n        (iface)->version = sizeof(*(iface));    \\\n    } while (0)",
          "sourceName": "SDL_INIT_INTERFACE"
        },
        "malloc": {
          "doc": "Allocate uninitialized memory.\n\nThe allocated memory returned by this function must be freed with\nfree().\n\nIf `size` is 0, it will be set to 1.\n\nIf the allocation is successful, the returned pointer is guaranteed to be\naligned to either the *fundamental alignment* (`alignof(max_align_t)` in\nC11 and later) or `2 * sizeof(void *)`, whichever is smaller. Use\naligned_alloc() if you need to allocate memory aligned to an alignment\ngreater than this guarantee.\n\n@param size the size to allocate.\n@returns a pointer to the allocated memory, or nullptr if allocation failed.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa free\n@sa calloc\n@sa realloc\n@sa aligned_alloc",
          "name": "malloc",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "size",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_malloc"
        },
        "calloc": {
          "doc": "Allocate a zero-initialized array.\n\nThe memory returned by this function must be freed with free().\n\nIf either of `nmemb` or `size` is 0, they will both be set to 1.\n\nIf the allocation is successful, the returned pointer is guaranteed to be\naligned to either the *fundamental alignment* (`alignof(max_align_t)` in\nC11 and later) or `2 * sizeof(void *)`, whichever is smaller.\n\n@param nmemb the number of elements in the array.\n@param size the size of each element of the array.\n@returns a pointer to the allocated array, or nullptr if allocation failed.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa free\n@sa malloc\n@sa realloc",
          "name": "calloc",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "nmemb",
              "type": "size_t"
            },
            {
              "name": "size",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_calloc"
        },
        "realloc": {
          "doc": "Change the size of allocated memory.\n\nThe memory returned by this function must be freed with free().\n\nIf `size` is 0, it will be set to 1. Note that this is unlike some other C\nruntime `realloc` implementations, which may treat `realloc(mem, 0)` the\nsame way as `free(mem)`.\n\nIf `mem` is nullptr, the behavior of this function is equivalent to\nmalloc(). Otherwise, the function can have one of three possible\noutcomes:\n\n- If it returns the same pointer as `mem`, it means that `mem` was resized\n  in place without freeing.\n- If it returns a different non-nullptr pointer, it means that `mem` was freed\n  and cannot be dereferenced anymore.\n- If it returns nullptr (indicating failure), then `mem` will remain valid and\n  must still be freed with free().\n\nIf the allocation is successfully resized, the returned pointer is\nguaranteed to be aligned to either the *fundamental alignment*\n(`alignof(max_align_t)` in C11 and later) or `2 * sizeof(void *)`,\nwhichever is smaller.\n\n@param mem a pointer to allocated memory to reallocate, or nullptr.\n@param size the new size of the memory.\n@returns a pointer to the newly allocated memory, or nullptr if allocation\n         failed.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa free\n@sa malloc\n@sa calloc",
          "name": "realloc",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "mem",
              "type": "void *"
            },
            {
              "name": "size",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_realloc"
        },
        "free": {
          "doc": "Free allocated memory.\n\nThe pointer is no longer valid after this call and cannot be dereferenced\nanymore.\n\nIf `mem` is nullptr, this function does nothing.\n\n@param mem a pointer to allocated memory, or nullptr.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa malloc\n@sa calloc\n@sa realloc",
          "name": "free",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "mem",
              "type": "void *"
            }
          ],
          "sourceName": "SDL_free"
        },
        "malloc_func": {
          "doc": "A callback used to implement malloc().\n\nSDL will always ensure that the passed `size` is greater than 0.\n\n@param size the size to allocate.\n@returns a pointer to the allocated memory, or nullptr if allocation failed.\n\n@threadsafety It should be safe to call this callback from any thread.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa malloc\n@sa GetOriginalMemoryFunctions\n@sa GetMemoryFunctions\n@sa SetMemoryFunctions",
          "name": "malloc_func",
          "kind": "alias",
          "type": "SDL_malloc_func",
          "sourceName": "SDL_malloc_func"
        },
        "calloc_func": {
          "doc": "A callback used to implement calloc().\n\nSDL will always ensure that the passed `nmemb` and `size` are both greater\nthan 0.\n\n@param nmemb the number of elements in the array.\n@param size the size of each element of the array.\n@returns a pointer to the allocated array, or nullptr if allocation failed.\n\n@threadsafety It should be safe to call this callback from any thread.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa calloc\n@sa GetOriginalMemoryFunctions\n@sa GetMemoryFunctions\n@sa SetMemoryFunctions",
          "name": "calloc_func",
          "kind": "alias",
          "type": "SDL_calloc_func",
          "sourceName": "SDL_calloc_func"
        },
        "realloc_func": {
          "doc": "A callback used to implement realloc().\n\nSDL will always ensure that the passed `size` is greater than 0.\n\n@param mem a pointer to allocated memory to reallocate, or nullptr.\n@param size the new size of the memory.\n@returns a pointer to the newly allocated memory, or nullptr if allocation\n         failed.\n\n@threadsafety It should be safe to call this callback from any thread.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa realloc\n@sa GetOriginalMemoryFunctions\n@sa GetMemoryFunctions\n@sa SetMemoryFunctions",
          "name": "realloc_func",
          "kind": "alias",
          "type": "SDL_realloc_func",
          "sourceName": "SDL_realloc_func"
        },
        "free_func": {
          "doc": "A callback used to implement free().\n\nSDL will always ensure that the passed `mem` is a non-nullptr pointer.\n\n@param mem a pointer to allocated memory.\n\n@threadsafety It should be safe to call this callback from any thread.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa free\n@sa GetOriginalMemoryFunctions\n@sa GetMemoryFunctions\n@sa SetMemoryFunctions",
          "name": "free_func",
          "kind": "alias",
          "type": "SDL_free_func",
          "sourceName": "SDL_free_func"
        },
        "GetOriginalMemoryFunctions": {
          "doc": "Get the original set of SDL memory functions.\n\nThis is what malloc and friends will use by default, if there has been\nno call to SetMemoryFunctions. This is not necessarily using the C\nruntime's `malloc` functions behind the scenes! Different platforms and\nbuild configurations might do any number of unexpected things.\n\n@param malloc_func filled with malloc function.\n@param calloc_func filled with calloc function.\n@param realloc_func filled with realloc function.\n@param free_func filled with free function.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetOriginalMemoryFunctions",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "malloc_func",
              "type": "malloc_func *"
            },
            {
              "name": "calloc_func",
              "type": "calloc_func *"
            },
            {
              "name": "realloc_func",
              "type": "realloc_func *"
            },
            {
              "name": "free_func",
              "type": "free_func *"
            }
          ],
          "sourceName": "SDL_GetOriginalMemoryFunctions"
        },
        "GetMemoryFunctions": {
          "doc": "Get the current set of SDL memory functions.\n\n@param malloc_func filled with malloc function.\n@param calloc_func filled with calloc function.\n@param realloc_func filled with realloc function.\n@param free_func filled with free function.\n\n@threadsafety This does not hold a lock, so do not call this in the\n              unlikely event of a background thread calling\n              SetMemoryFunctions simultaneously.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SetMemoryFunctions\n@sa GetOriginalMemoryFunctions",
          "name": "GetMemoryFunctions",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "malloc_func",
              "type": "malloc_func *"
            },
            {
              "name": "calloc_func",
              "type": "calloc_func *"
            },
            {
              "name": "realloc_func",
              "type": "realloc_func *"
            },
            {
              "name": "free_func",
              "type": "free_func *"
            }
          ],
          "sourceName": "SDL_GetMemoryFunctions"
        },
        "SetMemoryFunctions": {
          "doc": "Replace SDL's memory allocation functions with a custom set.\n\nIt is not safe to call this function once any allocations have been made,\nas future calls to free will use the new allocator, even if they came\nfrom an malloc made with the old one!\n\nIf used, usually this needs to be the first call made into the SDL library,\nif not the very first thing done at program startup time.\n\n@param malloc_func custom malloc function.\n@param calloc_func custom calloc function.\n@param realloc_func custom realloc function.\n@param free_func custom free function.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread, but one\n              should not replace the memory functions once any allocations\n              are made!\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetMemoryFunctions\n@sa GetOriginalMemoryFunctions",
          "name": "SetMemoryFunctions",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "malloc_func",
              "type": "malloc_func"
            },
            {
              "name": "calloc_func",
              "type": "calloc_func"
            },
            {
              "name": "realloc_func",
              "type": "realloc_func"
            },
            {
              "name": "free_func",
              "type": "free_func"
            }
          ],
          "sourceName": "SDL_SetMemoryFunctions"
        },
        "aligned_alloc": {
          "doc": "Allocate memory aligned to a specific alignment.\n\nThe memory returned by this function must be freed with aligned_free(),\n_not_ free().\n\nIf `alignment` is less than the size of `void *`, it will be increased to\nmatch that.\n\nThe returned memory address will be a multiple of the alignment value, and\nthe size of the memory allocated will be a multiple of the alignment value.\n\n@param alignment the alignment of the memory.\n@param size the size to allocate.\n@returns a pointer to the aligned memory, or nullptr if allocation failed.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa aligned_free",
          "name": "aligned_alloc",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "alignment",
              "type": "size_t"
            },
            {
              "name": "size",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_aligned_alloc"
        },
        "aligned_free": {
          "doc": "Free memory allocated by aligned_alloc().\n\nThe pointer is no longer valid after this call and cannot be dereferenced\nanymore.\n\nIf `mem` is nullptr, this function does nothing.\n\n@param mem a pointer previously returned by aligned_alloc(), or nullptr.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa aligned_alloc",
          "name": "aligned_free",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "mem",
              "type": "void *"
            }
          ],
          "sourceName": "SDL_aligned_free"
        },
        "GetNumAllocations": {
          "doc": "Get the number of outstanding (unfreed) allocations.\n\n@returns the number of allocations or -1 if allocation counting is\n         disabled.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetNumAllocations",
          "kind": "function",
          "type": "int",
          "parameters": [],
          "sourceName": "SDL_GetNumAllocations"
        },
        "EnvironmentBase": {
          "doc": "A thread-safe set of environment variables\n\n@since This struct is available since SDL 3.2.0.\n\n@sa GetEnvironment\n@sa EnvironmentBase.EnvironmentBase\n@sa EnvironmentBase.GetVariable\n@sa EnvironmentBase.GetVariables\n@sa EnvironmentBase.SetVariable\n@sa EnvironmentBase.UnsetVariable\n@sa EnvironmentBase.Destroy",
          "name": "EnvironmentBase",
          "kind": "struct",
          "type": "T",
          "sourceName": "SDL_Environment",
          "template": [
            {
              "type": "ObjectBox<SDL_Environment *>",
              "name": "T"
            }
          ],
          "entries": {
            "T::T": {
              "kind": "alias",
              "name": "T::T",
              "doc": ""
            },
            "EnvironmentBase": {
              "doc": "Create a set of environment variables\n\n@param populated true to initialize it from the C runtime environment,\n                 false to create an empty environment.\n@post a pointer to the new environment or nullptr on failure; call\n         GetError() for more information.\n\n@threadsafety If `populated` is false, it is safe to call this function\n              from any thread, otherwise it is safe if no other threads are\n              calling setenv() or unsetenv()\n\n@since This function is available since SDL 3.2.0.\n\n@sa EnvironmentBase.GetVariable\n@sa EnvironmentBase.GetVariables\n@sa EnvironmentBase.SetVariable\n@sa EnvironmentBase.UnsetVariable\n@sa EnvironmentBase.Destroy",
              "name": "EnvironmentBase",
              "kind": "function",
              "type": "",
              "parameters": [
                {
                  "name": "populated",
                  "type": "bool"
                }
              ],
              "sourceName": "SDL_CreateEnvironment"
            },
            "GetVariable": {
              "doc": "Get the value of a variable in the environment.\n\n@param name the name of the variable to get.\n@returns a pointer to the value of the variable or nullptr if it can't be\n         found.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetEnvironment\n@sa EnvironmentBase.EnvironmentBase\n@sa EnvironmentBase.GetVariables\n@sa EnvironmentBase.SetVariable\n@sa EnvironmentBase.UnsetVariable",
              "name": "GetVariable",
              "kind": "function",
              "type": "const char *",
              "parameters": [
                {
                  "name": "name",
                  "type": "StringParam"
                }
              ],
              "sourceName": "SDL_GetEnvironmentVariable"
            },
            "GetVariables": {
              "doc": "Get all variables in the environment.\n\n@returns a nullptr terminated array of pointers to environment variables in\n         the form \"variable=value\" or nullptr on failure; call GetError()\n         for more information. This is a single allocation that should be\n         freed with free() when it is no longer needed.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetEnvironment\n@sa EnvironmentBase.EnvironmentBase\n@sa EnvironmentBase.GetVariables\n@sa EnvironmentBase.SetVariable\n@sa EnvironmentBase.UnsetVariable",
              "name": "GetVariables",
              "kind": "function",
              "type": "OwnArray<char *>",
              "parameters": [],
              "sourceName": "SDL_GetEnvironmentVariables"
            },
            "GetVariableCount": {
              "kind": "function",
              "type": "Uint64",
              "parameters": [],
              "name": "GetVariableCount",
              "doc": ""
            },
            "SetVariable": {
              "doc": "Set the value of a variable in the environment.\n\n@param name the name of the variable to set.\n@param value the value of the variable to set.\n@param overwrite true to overwrite the variable if it exists, false to\n                 return success without setting the variable if it already\n                 exists.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetEnvironment\n@sa EnvironmentBase.EnvironmentBase\n@sa EnvironmentBase.GetVariable\n@sa EnvironmentBase.GetVariables\n@sa EnvironmentBase.UnsetVariable",
              "name": "SetVariable",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "name",
                  "type": "StringParam"
                },
                {
                  "name": "value",
                  "type": "StringParam"
                },
                {
                  "name": "overwrite",
                  "type": "bool"
                }
              ],
              "sourceName": "SDL_SetEnvironmentVariable"
            },
            "UnsetVariable": {
              "doc": "Clear a variable from the environment.\n\n@param name the name of the variable to unset.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetEnvironment\n@sa EnvironmentBase.EnvironmentBase\n@sa EnvironmentBase.GetVariable\n@sa EnvironmentBase.GetVariables\n@sa EnvironmentBase.SetVariable\n@sa EnvironmentBase.UnsetVariable",
              "name": "UnsetVariable",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "name",
                  "type": "StringParam"
                }
              ],
              "sourceName": "SDL_UnsetEnvironmentVariable"
            },
            "Destroy": {
              "doc": "Destroy a set of environment variables.\n\n\n@threadsafety It is safe to call this function from any thread, as long as\n              the environment is no longer in use.\n\n@since This function is available since SDL 3.2.0.\n\n@sa EnvironmentBase.EnvironmentBase",
              "name": "Destroy",
              "kind": "function",
              "type": "void",
              "parameters": [],
              "sourceName": "SDL_DestroyEnvironment"
            }
          }
        },
        "ObjectRef<SDL_Environment>::doFree": {
          "name": "ObjectRef<SDL_Environment>::doFree",
          "type": "void",
          "kind": "function",
          "doc": "Callback for environment resource cleanup\n\n@private",
          "template": [],
          "parameters": [
            {
              "type": "SDL_Environment *",
              "name": "resource"
            }
          ],
          "sourceName": "SDL_DestroyEnvironment"
        },
        "GetEnvironment": {
          "doc": "Get the process environment.\n\nThis is initialized at application start and is not affected by setenv()\nand unsetenv() calls after that point. Use EnvironmentBase.SetVariable() and\nEnvironmentBase.UnsetVariable() if you want to modify this environment, or\nsetenv_unsafe() or unsetenv_unsafe() if you want changes to persist\nin the C runtime environment after Quit().\n\n@returns a pointer to the environment for the process or nullptr on failure;\n         call GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa EnvironmentBase.GetVariable\n@sa EnvironmentBase.GetVariables\n@sa EnvironmentBase.SetVariable\n@sa EnvironmentBase.UnsetVariable",
          "name": "GetEnvironment",
          "kind": "function",
          "type": "EnvironmentRef",
          "parameters": [],
          "sourceName": "SDL_GetEnvironment"
        },
        "getenv": {
          "doc": "Get the value of a variable in the environment.\n\nThis function uses SDL's cached copy of the environment and is thread-safe.\n\n@param name the name of the variable to get.\n@returns a pointer to the value of the variable or nullptr if it can't be\n         found.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "getenv",
          "kind": "function",
          "type": "const char *",
          "parameters": [
            {
              "name": "name",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_getenv"
        },
        "getenv_unsafe": {
          "doc": "Get the value of a variable in the environment.\n\nThis function bypasses SDL's cached copy of the environment and is not\nthread-safe.\n\n@param name the name of the variable to get.\n@returns a pointer to the value of the variable or nullptr if it can't be\n         found.\n\n@threadsafety This function is not thread safe, consider using getenv()\n              instead.\n\n@since This function is available since SDL 3.2.0.\n\n@sa getenv",
          "name": "getenv_unsafe",
          "kind": "function",
          "type": "const char *",
          "parameters": [
            {
              "name": "name",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_getenv_unsafe"
        },
        "setenv_unsafe": {
          "doc": "Set the value of a variable in the environment.\n\n@param name the name of the variable to set.\n@param value the value of the variable to set.\n@param overwrite 1 to overwrite the variable if it exists, 0 to return\n                 success without setting the variable if it already exists.\n@returns 0 on success, -1 on error.\n\n@threadsafety This function is not thread safe, consider using\n              EnvironmentBase.SetVariable() instead.\n\n@since This function is available since SDL 3.2.0.\n\n@sa EnvironmentBase.SetVariable",
          "name": "setenv_unsafe",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "name",
              "type": "StringParam"
            },
            {
              "name": "value",
              "type": "StringParam"
            },
            {
              "name": "overwrite",
              "type": "int"
            }
          ],
          "sourceName": "SDL_setenv_unsafe"
        },
        "unsetenv_unsafe": {
          "doc": "Clear a variable from the environment.\n\n@param name the name of the variable to unset.\n@returns 0 on success, -1 on error.\n\n@threadsafety This function is not thread safe, consider using\n              EnvironmentBase.UnsetVariable() instead.\n\n@since This function is available since SDL 3.2.0.\n\n@sa EnvironmentBase.UnsetVariable",
          "name": "unsetenv_unsafe",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "name",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_unsetenv_unsafe"
        },
        "CompareCallback": {
          "doc": "A callback used with SDL sorting and binary search functions.\n\n@param a a pointer to the first element being compared.\n@param b a pointer to the second element being compared.\n@returns -1 if `a` should be sorted before `b`, 1 if `b` should be sorted\n         before `a`, 0 if they are equal. If two elements are equal, their\n         order in the sorted array is undefined.\n\n@since This callback is available since SDL 3.2.0.\n\n@sa bsearch\n@sa qsort",
          "name": "CompareCallback",
          "kind": "alias",
          "type": "SDL_CompareCallback",
          "sourceName": "SDL_CompareCallback"
        },
        "qsort": {
          "doc": "Sort an array.\n\nFor example:\n\n```c\ntypedef struct {\n    int key;\n    const char *string;\n} data;\n\nint SDLCALL compare(const void *a, const void *b)\n{\n    const data *A = (const data *)a;\n    const data *B = (const data *)b;\n\n    if (A->n < B->n) {\n        return -1;\n    } else if (B->n < A->n) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\ndata values[] = {\n    { 3, \"third\" }, { 1, \"first\" }, { 2, \"second\" }\n};\n\nqsort(values, arraysize(values), sizeof(values[0]), compare);\n```\n\n@param base a pointer to the start of the array.\n@param nmemb the number of elements in the array.\n@param size the size of the elements in the array.\n@param compare a function used to compare elements in the array.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa bsearch\n@sa qsort_r",
          "name": "qsort",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "base",
              "type": "void *"
            },
            {
              "name": "nmemb",
              "type": "size_t"
            },
            {
              "name": "size",
              "type": "size_t"
            },
            {
              "name": "compare",
              "type": "CompareCallback"
            }
          ],
          "sourceName": "SDL_qsort"
        },
        "bsearch": {
          "doc": "Perform a binary search on a previously sorted array.\n\nFor example:\n\n```c\ntypedef struct {\n    int key;\n    const char *string;\n} data;\n\nint SDLCALL compare(const void *a, const void *b)\n{\n    const data *A = (const data *)a;\n    const data *B = (const data *)b;\n\n    if (A->n < B->n) {\n        return -1;\n    } else if (B->n < A->n) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\ndata values[] = {\n    { 1, \"first\" }, { 2, \"second\" }, { 3, \"third\" }\n};\ndata key = { 2, nullptr };\n\ndata *result = bsearch(&key, values, arraysize(values), sizeof(values[0]), compare);\n```\n\n@param key a pointer to a key equal to the element being searched for.\n@param base a pointer to the start of the array.\n@param nmemb the number of elements in the array.\n@param size the size of the elements in the array.\n@param compare a function used to compare elements in the array.\n@returns a pointer to the matching element in the array, or nullptr if not\n         found.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa bsearch_r\n@sa qsort",
          "name": "bsearch",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "key",
              "type": "const void *"
            },
            {
              "name": "base",
              "type": "const void *"
            },
            {
              "name": "nmemb",
              "type": "size_t"
            },
            {
              "name": "size",
              "type": "size_t"
            },
            {
              "name": "compare",
              "type": "CompareCallback"
            }
          ],
          "sourceName": "SDL_bsearch"
        },
        "CompareCallback_r": {
          "doc": "A callback used with SDL sorting and binary search functions.\n\n@param userdata the `userdata` pointer passed to the sort function.\n@param a a pointer to the first element being compared.\n@param b a pointer to the second element being compared.\n@returns -1 if `a` should be sorted before `b`, 1 if `b` should be sorted\n         before `a`, 0 if they are equal. If two elements are equal, their\n         order in the sorted array is undefined.\n\n@since This callback is available since SDL 3.2.0.\n\n@sa qsort_r\n@sa bsearch_r",
          "name": "CompareCallback_r",
          "kind": "alias",
          "type": "SDL_CompareCallback_r",
          "sourceName": "SDL_CompareCallback_r"
        },
        "qsort_r": {
          "doc": "Sort an array, passing a userdata pointer to the compare function.\n\nFor example:\n\n```c\ntypedef enum {\n    sort_increasing,\n    sort_decreasing,\n} sort_method;\n\ntypedef struct {\n    int key;\n    const char *string;\n} data;\n\nint SDLCALL compare(const void *userdata, const void *a, const void *b)\n{\n    sort_method method = (sort_method)(uintptr_t)userdata;\n    const data *A = (const data *)a;\n    const data *B = (const data *)b;\n\n    if (A->key < B->key) {\n        return (method == sort_increasing) ? -1 : 1;\n    } else if (B->key < A->key) {\n        return (method == sort_increasing) ? 1 : -1;\n    } else {\n        return 0;\n    }\n}\n\ndata values[] = {\n    { 3, \"third\" }, { 1, \"first\" }, { 2, \"second\" }\n};\n\nqsort_r(values, arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);\n```\n\n@param base a pointer to the start of the array.\n@param nmemb the number of elements in the array.\n@param size the size of the elements in the array.\n@param compare a function used to compare elements in the array.\n@param userdata a pointer to pass to the compare function.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa bsearch_r\n@sa qsort",
          "name": "qsort_r",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "base",
              "type": "void *"
            },
            {
              "name": "nmemb",
              "type": "size_t"
            },
            {
              "name": "size",
              "type": "size_t"
            },
            {
              "name": "compare",
              "type": "CompareCallback_r"
            },
            {
              "name": "userdata",
              "type": "void *"
            }
          ],
          "sourceName": "SDL_qsort_r"
        },
        "bsearch_r": {
          "doc": "Perform a binary search on a previously sorted array, passing a userdata\npointer to the compare function.\n\nFor example:\n\n```c\ntypedef enum {\n    sort_increasing,\n    sort_decreasing,\n} sort_method;\n\ntypedef struct {\n    int key;\n    const char *string;\n} data;\n\nint SDLCALL compare(const void *userdata, const void *a, const void *b)\n{\n    sort_method method = (sort_method)(uintptr_t)userdata;\n    const data *A = (const data *)a;\n    const data *B = (const data *)b;\n\n    if (A->key < B->key) {\n        return (method == sort_increasing) ? -1 : 1;\n    } else if (B->key < A->key) {\n        return (method == sort_increasing) ? 1 : -1;\n    } else {\n        return 0;\n    }\n}\n\ndata values[] = {\n    { 1, \"first\" }, { 2, \"second\" }, { 3, \"third\" }\n};\ndata key = { 2, nullptr };\n\ndata *result = bsearch_r(&key, values, arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);\n```\n\n@param key a pointer to a key equal to the element being searched for.\n@param base a pointer to the start of the array.\n@param nmemb the number of elements in the array.\n@param size the size of the elements in the array.\n@param compare a function used to compare elements in the array.\n@param userdata a pointer to pass to the compare function.\n@returns a pointer to the matching element in the array, or nullptr if not\n         found.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa bsearch\n@sa qsort_r",
          "name": "bsearch_r",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "key",
              "type": "const void *"
            },
            {
              "name": "base",
              "type": "const void *"
            },
            {
              "name": "nmemb",
              "type": "size_t"
            },
            {
              "name": "size",
              "type": "size_t"
            },
            {
              "name": "compare",
              "type": "CompareCallback_r"
            },
            {
              "name": "userdata",
              "type": "void *"
            }
          ],
          "sourceName": "SDL_bsearch_r"
        },
        "abs": {
          "doc": "Compute the absolute value of `x`.\n\n@param x an integer value.\n@returns the absolute value of x.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "abs",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ],
          "sourceName": "SDL_abs"
        },
        "min": {
          "doc": "Return the lesser of two values.\n\nThis is a helper macro that might be more clear than writing out the\ncomparisons directly, and works with any type that can be compared with the\n`<` operator. However, it double-evaluates both its parameters, so do not\nuse expressions with side-effects here.\n\n@param x the first value to compare.\n@param y the second value to compare.\n@returns the lesser of `x` and `y`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "min",
          "kind": "function",
          "parameters": [
            {
              "type": "T",
              "name": "x"
            },
            {
              "type": "U",
              "name": "y"
            }
          ],
          "value": "(((x) < (y)) ? (x) : (y))",
          "sourceName": "SDL_min",
          "type": "T",
          "constexpr": true,
          "template": [
            {
              "type": "class",
              "name": "T"
            },
            {
              "type": "class",
              "name": "U"
            }
          ]
        },
        "max": {
          "doc": "Return the greater of two values.\n\nThis is a helper macro that might be more clear than writing out the\ncomparisons directly, and works with any type that can be compared with the\n`>` operator. However, it double-evaluates both its parameters, so do not\nuse expressions with side-effects here.\n\n@param x the first value to compare.\n@param y the second value to compare.\n@returns the lesser of `x` and `y`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "max",
          "kind": "function",
          "parameters": [
            {
              "type": "T",
              "name": "x"
            },
            {
              "type": "U",
              "name": "y"
            }
          ],
          "value": "(((x) > (y)) ? (x) : (y))",
          "sourceName": "SDL_max",
          "type": "T",
          "constexpr": true,
          "template": [
            {
              "type": "class",
              "name": "T"
            },
            {
              "type": "class",
              "name": "U"
            }
          ]
        },
        "clamp": {
          "doc": "Return a value clamped to a range.\n\nIf `x` is outside the range a values between `a` and `b`, the returned\nvalue will be `a` or `b` as appropriate. Otherwise, `x` is returned.\n\nThis macro will produce incorrect results if `b` is less than `a`.\n\nThis is a helper macro that might be more clear than writing out the\ncomparisons directly, and works with any type that can be compared with the\n`<` and `>` operators. However, it double-evaluates all its parameters, so\ndo not use expressions with side-effects here.\n\n@param x the value to compare.\n@param a the low end value.\n@param b the high end value.\n@returns x, clamped between a and b.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "clamp",
          "kind": "function",
          "parameters": [
            {
              "type": "T",
              "name": "x"
            },
            {
              "type": "U",
              "name": "a"
            },
            {
              "type": "V",
              "name": "b"
            }
          ],
          "value": "(((x) < (a)) ? (a) : (((x) > (b)) ? (b) : (x)))",
          "sourceName": "SDL_clamp",
          "type": "T",
          "constexpr": true,
          "template": [
            {
              "type": "class",
              "name": "T"
            },
            {
              "type": "class",
              "name": "U"
            },
            {
              "type": "class",
              "name": "V"
            }
          ]
        },
        "isalpha": {
          "doc": "Query if a character is alphabetic (a letter).\n\n**WARNING**: Regardless of system locale, this will only treat ASCII values\nfor English 'a-z' and 'A-Z' as true.\n\n@param x character value to check.\n@returns non-zero if x falls within the character class, zero otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "isalpha",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ],
          "sourceName": "SDL_isalpha"
        },
        "isalnum": {
          "doc": "Query if a character is alphabetic (a letter) or a number.\n\n**WARNING**: Regardless of system locale, this will only treat ASCII values\nfor English 'a-z', 'A-Z', and '0-9' as true.\n\n@param x character value to check.\n@returns non-zero if x falls within the character class, zero otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "isalnum",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ],
          "sourceName": "SDL_isalnum"
        },
        "isblank": {
          "doc": "Report if a character is blank (a space or tab).\n\n**WARNING**: Regardless of system locale, this will only treat ASCII values\n0x20 (space) or 0x9 (tab) as true.\n\n@param x character value to check.\n@returns non-zero if x falls within the character class, zero otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "isblank",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ],
          "sourceName": "SDL_isblank"
        },
        "iscntrl": {
          "doc": "Report if a character is a control character.\n\n**WARNING**: Regardless of system locale, this will only treat ASCII values\n0 through 0x1F, and 0x7F, as true.\n\n@param x character value to check.\n@returns non-zero if x falls within the character class, zero otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "iscntrl",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ],
          "sourceName": "SDL_iscntrl"
        },
        "isdigit": {
          "doc": "Report if a character is a numeric digit.\n\n**WARNING**: Regardless of system locale, this will only treat ASCII values\n'0' (0x30) through '9' (0x39), as true.\n\n@param x character value to check.\n@returns non-zero if x falls within the character class, zero otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "isdigit",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ],
          "sourceName": "SDL_isdigit"
        },
        "isxdigit": {
          "doc": "Report if a character is a hexadecimal digit.\n\n**WARNING**: Regardless of system locale, this will only treat ASCII values\n'A' through 'F', 'a' through 'f', and '0' through '9', as true.\n\n@param x character value to check.\n@returns non-zero if x falls within the character class, zero otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "isxdigit",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ],
          "sourceName": "SDL_isxdigit"
        },
        "ispunct": {
          "doc": "Report if a character is a punctuation mark.\n\n**WARNING**: Regardless of system locale, this is equivalent to\n`((isgraph(x)) && (!isalnum(x)))`.\n\n@param x character value to check.\n@returns non-zero if x falls within the character class, zero otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa isgraph\n@sa isalnum",
          "name": "ispunct",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ],
          "sourceName": "SDL_ispunct"
        },
        "isspace": {
          "doc": "Report if a character is whitespace.\n\n**WARNING**: Regardless of system locale, this will only treat the\nfollowing ASCII values as true:\n\n- space (0x20)\n- tab (0x09)\n- newline (0x0A)\n- vertical tab (0x0B)\n- form feed (0x0C)\n- return (0x0D)\n\n@param x character value to check.\n@returns non-zero if x falls within the character class, zero otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "isspace",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ],
          "sourceName": "SDL_isspace"
        },
        "isupper": {
          "doc": "Report if a character is upper case.\n\n**WARNING**: Regardless of system locale, this will only treat ASCII values\n'A' through 'Z' as true.\n\n@param x character value to check.\n@returns non-zero if x falls within the character class, zero otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "isupper",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ],
          "sourceName": "SDL_isupper"
        },
        "islower": {
          "doc": "Report if a character is lower case.\n\n**WARNING**: Regardless of system locale, this will only treat ASCII values\n'a' through 'z' as true.\n\n@param x character value to check.\n@returns non-zero if x falls within the character class, zero otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "islower",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ],
          "sourceName": "SDL_islower"
        },
        "isprint": {
          "doc": "Report if a character is \"printable\".\n\nBe advised that \"printable\" has a definition that goes back to text\nterminals from the dawn of computing, making this a sort of special case\nfunction that is not suitable for Unicode (or most any) text management.\n\n**WARNING**: Regardless of system locale, this will only treat ASCII values\n' ' (0x20) through '~' (0x7E) as true.\n\n@param x character value to check.\n@returns non-zero if x falls within the character class, zero otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "isprint",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ],
          "sourceName": "SDL_isprint"
        },
        "isgraph": {
          "doc": "Report if a character is any \"printable\" except space.\n\nBe advised that \"printable\" has a definition that goes back to text\nterminals from the dawn of computing, making this a sort of special case\nfunction that is not suitable for Unicode (or most any) text management.\n\n**WARNING**: Regardless of system locale, this is equivalent to\n`(isprint(x)) && ((x) != ' ')`.\n\n@param x character value to check.\n@returns non-zero if x falls within the character class, zero otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa isprint",
          "name": "isgraph",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ],
          "sourceName": "SDL_isgraph"
        },
        "toupper": {
          "doc": "Convert low-ASCII English letters to uppercase.\n\n**WARNING**: Regardless of system locale, this will only convert ASCII\nvalues 'a' through 'z' to uppercase.\n\nThis function returns the uppercase equivalent of `x`. If a character\ncannot be converted, or is already uppercase, this function returns `x`.\n\n@param x character value to check.\n@returns capitalized version of x, or x if no conversion available.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "toupper",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ],
          "sourceName": "SDL_toupper"
        },
        "tolower": {
          "doc": "Convert low-ASCII English letters to lowercase.\n\n**WARNING**: Regardless of system locale, this will only convert ASCII\nvalues 'A' through 'Z' to lowercase.\n\nThis function returns the lowercase equivalent of `x`. If a character\ncannot be converted, or is already lowercase, this function returns `x`.\n\n@param x character value to check.\n@returns lowercase version of x, or x if no conversion available.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "tolower",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "int"
            }
          ],
          "sourceName": "SDL_tolower"
        },
        "crc16": {
          "doc": "Calculate a CRC-16 value.\n\nhttps://en.wikipedia.org/wiki/Cyclic_redundancy_check\n\nThis function can be called multiple times, to stream data to be\nchecksummed in blocks. Each call must provide the previous CRC-16 return\nvalue to be updated with the next block. The first call to this function\nfor a set of blocks should pass in a zero CRC value.\n\n@param crc the current checksum for this data set, or 0 for a new data set.\n@param data a new block of data to add to the checksum.\n@param len the size, in bytes, of the new block of data.\n@returns a CRC-16 checksum value of all blocks in the data set.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "crc16",
          "kind": "function",
          "type": "Uint16",
          "parameters": [
            {
              "name": "crc",
              "type": "Uint16"
            },
            {
              "name": "data",
              "type": "const void *"
            },
            {
              "name": "len",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_crc16"
        },
        "crc32": {
          "doc": "Calculate a CRC-32 value.\n\nhttps://en.wikipedia.org/wiki/Cyclic_redundancy_check\n\nThis function can be called multiple times, to stream data to be\nchecksummed in blocks. Each call must provide the previous CRC-32 return\nvalue to be updated with the next block. The first call to this function\nfor a set of blocks should pass in a zero CRC value.\n\n@param crc the current checksum for this data set, or 0 for a new data set.\n@param data a new block of data to add to the checksum.\n@param len the size, in bytes, of the new block of data.\n@returns a CRC-32 checksum value of all blocks in the data set.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "crc32",
          "kind": "function",
          "type": "Uint32",
          "parameters": [
            {
              "name": "crc",
              "type": "Uint32"
            },
            {
              "name": "data",
              "type": "const void *"
            },
            {
              "name": "len",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_crc32"
        },
        "murmur3_32": {
          "doc": "Calculate a 32-bit MurmurHash3 value for a block of data.\n\nhttps://en.wikipedia.org/wiki/MurmurHash\n\nA seed may be specified, which changes the final results consistently, but\nthis does not work like crc16 and crc32: you can't feed a previous\nresult from this function back into itself as the next seed value to\ncalculate a hash in chunks; it won't produce the same hash as it would if\nthe same data was provided in a single call.\n\nIf you aren't sure what to provide for a seed, zero is fine. Murmur3 is not\ncryptographically secure, so it shouldn't be used for hashing top-secret\ndata.\n\n@param data the data to be hashed.\n@param len the size of data, in bytes.\n@param seed a value that alters the final hash value.\n@returns a Murmur3 32-bit hash value.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "murmur3_32",
          "kind": "function",
          "type": "Uint32",
          "parameters": [
            {
              "name": "data",
              "type": "const void *"
            },
            {
              "name": "len",
              "type": "size_t"
            },
            {
              "name": "seed",
              "type": "Uint32"
            }
          ],
          "sourceName": "SDL_murmur3_32"
        },
        "memcpy": {
          "doc": "Copy non-overlapping memory.\n\nThe memory regions must not overlap. If they do, use memmove() instead.\n\n@param dst The destination memory region. Must not be nullptr, and must not\n           overlap with `src`.\n@param src The source memory region. Must not be nullptr, and must not overlap\n           with `dst`.\n@param len The length in bytes of both `dst` and `src`.\n@returns `dst`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa memmove",
          "name": "memcpy",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "dst",
              "type": "void *"
            },
            {
              "name": "src",
              "type": "const void *"
            },
            {
              "name": "len",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_memcpy"
        },
        "SDL_copyp": {
          "doc": "A macro to copy memory between objects, with basic type checking.\n\nmemcpy and memmove do not care where you copy memory to and from,\nwhich can lead to bugs. This macro aims to avoid most of those bugs by\nmaking sure that the source and destination are both pointers to objects\nthat are the same size. It does not check that the objects are the same\n_type_, just that the copy will not overflow either object.\n\nThe size check happens at compile time, and the compiler will throw an\nerror if the objects are different sizes.\n\nGenerally this is intended to copy a single object, not an array.\n\nThis macro looks like it double-evaluates its parameters, but the extras\nthem are in `sizeof` sections, which generate no code nor side-effects.\n\n@param dst a pointer to the destination object. Must not be nullptr.\n@param src a pointer to the source object. Must not be nullptr.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "SDL_copyp",
          "kind": "def",
          "parameters": [
            "dst",
            "src"
          ],
          "value": "    { SDL_COMPILE_TIME_ASSERT(SDL_copyp, sizeof (*(dst)) == sizeof (*(src))); }             \\\n    SDL_memcpy((dst), (src), sizeof(*(src)))",
          "sourceName": "SDL_copyp"
        },
        "memmove": {
          "doc": "Copy memory ranges that might overlap.\n\nIt is okay for the memory regions to overlap. If you are confident that the\nregions never overlap, using memcpy() may improve performance.\n\n@param dst The destination memory region. Must not be nullptr.\n@param src The source memory region. Must not be nullptr.\n@param len The length in bytes of both `dst` and `src`.\n@returns `dst`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa memcpy",
          "name": "memmove",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "dst",
              "type": "void *"
            },
            {
              "name": "src",
              "type": "const void *"
            },
            {
              "name": "len",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_memmove"
        },
        "memset": {
          "doc": "Initialize all bytes of buffer of memory to a specific value.\n\nThis function will set `len` bytes, pointed to by `dst`, to the value\nspecified in `c`.\n\nDespite `c` being an `int` instead of a `char`, this only operates on\nbytes; `c` must be a value between 0 and 255, inclusive.\n\n@param dst the destination memory region. Must not be nullptr.\n@param c the byte value to set.\n@param len the length, in bytes, to set in `dst`.\n@returns `dst`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "memset",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "dst",
              "type": "void *"
            },
            {
              "name": "c",
              "type": "int"
            },
            {
              "name": "len",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_memset"
        },
        "memset4": {
          "doc": "Initialize all 32-bit words of buffer of memory to a specific value.\n\nThis function will set a buffer of `dwords` Uint32 values, pointed to by\n`dst`, to the value specified in `val`.\n\nUnlike memset, this sets 32-bit values, not bytes, so it's not limited\nto a range of 0-255.\n\n@param dst the destination memory region. Must not be nullptr.\n@param val the Uint32 value to set.\n@param dwords the number of Uint32 values to set in `dst`.\n@returns `dst`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "memset4",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "dst",
              "type": "void *"
            },
            {
              "name": "val",
              "type": "Uint32"
            },
            {
              "name": "dwords",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_memset4"
        },
        "zero": {
          "doc": "Clear an object's memory to zero.\n\nThis is wrapper over memset that handles calculating the object size,\nso there's no chance of copy/paste errors, and the code is cleaner.\n\nThis requires an object, not a pointer to an object, nor an array.\n\n@param x the object to clear.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa zerop\n@sa zeroa",
          "name": "zero",
          "kind": "function",
          "parameters": [
            {
              "type": "T &",
              "name": "x"
            }
          ],
          "value": "SDL_memset(&(x), 0, sizeof((x)))",
          "sourceName": "SDL_zero",
          "type": "void",
          "template": [
            {
              "type": "class",
              "name": "T"
            }
          ]
        },
        "zerop": {
          "doc": "Clear an object's memory to zero, using a pointer.\n\nThis is wrapper over memset that handles calculating the object size,\nso there's no chance of copy/paste errors, and the code is cleaner.\n\nThis requires a pointer to an object, not an object itself, nor an array.\n\n@param x a pointer to the object to clear.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa zero\n@sa zeroa",
          "name": "zerop",
          "kind": "function",
          "parameters": [
            {
              "type": "T *",
              "name": "x"
            }
          ],
          "value": "SDL_memset((x), 0, sizeof(*(x)))",
          "sourceName": "SDL_zerop",
          "type": "void",
          "template": [
            {
              "type": "class",
              "name": "T"
            }
          ]
        },
        "zeroa": {
          "doc": "Clear an array's memory to zero.\n\nThis is wrapper over memset that handles calculating the array size, so\nthere's no chance of copy/paste errors, and the code is cleaner.\n\nThis requires an array, not an object, nor a pointer to an object.\n\n@param x an array to clear.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa zero\n@sa zeroa",
          "name": "zeroa",
          "kind": "function",
          "parameters": [
            {
              "type": "T",
              "name": "(&x)[N]"
            }
          ],
          "value": "SDL_memset((x), 0, sizeof((x)))",
          "sourceName": "SDL_zeroa",
          "type": "void",
          "template": [
            {
              "type": "class",
              "name": "T"
            },
            {
              "type": "std::size_t",
              "name": "N"
            }
          ]
        },
        "memcmp": {
          "doc": "Compare two buffers of memory.\n\n@param s1 the first buffer to compare. nullptr is not permitted!\n@param s2 the second buffer to compare. nullptr is not permitted!\n@param len the number of bytes to compare between the buffers.\n@returns less than zero if s1 is \"less than\" s2, greater than zero if s1 is\n         \"greater than\" s2, and zero if the buffers match exactly for `len`\n         bytes.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "memcmp",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "s1",
              "type": "const void *"
            },
            {
              "name": "s2",
              "type": "const void *"
            },
            {
              "name": "len",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_memcmp"
        },
        "wcslen": {
          "doc": "This works exactly like wcslen() but doesn't require access to a C runtime.\n\nCounts the number of wchar_t values in `wstr`, excluding the null\nterminator.\n\nLike strlen only counts bytes and not codepoints in a UTF-8 string,\nthis counts wchar_t values in a string, even if the string's encoding is of\nvariable width, like UTF-16.\n\nAlso be aware that wchar_t is different sizes on different platforms (4\nbytes on Linux, 2 on Windows, etc).\n\n@param wstr The null-terminated wide string to read. Must not be nullptr.\n@returns the length (in wchar_t values, excluding the null terminator) of\n         `wstr`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa wcsnlen\n@sa utf8strlen\n@sa utf8strnlen",
          "name": "wcslen",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "wstr",
              "type": "const wchar_t *"
            }
          ],
          "sourceName": "SDL_wcslen"
        },
        "wcsnlen": {
          "doc": "This works exactly like wcsnlen() but doesn't require access to a C\nruntime.\n\nCounts up to a maximum of `maxlen` wchar_t values in `wstr`, excluding the\nnull terminator.\n\nLike strnlen only counts bytes and not codepoints in a UTF-8 string,\nthis counts wchar_t values in a string, even if the string's encoding is of\nvariable width, like UTF-16.\n\nAlso be aware that wchar_t is different sizes on different platforms (4\nbytes on Linux, 2 on Windows, etc).\n\nAlso, `maxlen` is a count of wide characters, not bytes!\n\n@param wstr The null-terminated wide string to read. Must not be nullptr.\n@param maxlen The maximum amount of wide characters to count.\n@returns the length (in wide characters, excluding the null terminator) of\n         `wstr` but never more than `maxlen`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa wcslen\n@sa utf8strlen\n@sa utf8strnlen",
          "name": "wcsnlen",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "wstr",
              "type": "const wchar_t *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_wcsnlen"
        },
        "wcslcpy": {
          "doc": "Copy a wide string.\n\nThis function copies `maxlen` - 1 wide characters from `src` to `dst`, then\nappends a null terminator.\n\n`src` and `dst` must not overlap.\n\nIf `maxlen` is 0, no wide characters are copied and no null terminator is\nwritten.\n\n@param dst The destination buffer. Must not be nullptr, and must not overlap\n           with `src`.\n@param src The null-terminated wide string to copy. Must not be nullptr, and\n           must not overlap with `dst`.\n@param maxlen The length (in wide characters) of the destination buffer.\n@returns the length (in wide characters, excluding the null terminator) of\n         `src`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa wcslcat",
          "name": "wcslcpy",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "dst",
              "type": "wchar_t *"
            },
            {
              "name": "src",
              "type": "const wchar_t *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_wcslcpy"
        },
        "wcslcat": {
          "doc": "Concatenate wide strings.\n\nThis function appends up to `maxlen` - wcslen(dst) - 1 wide characters\nfrom `src` to the end of the wide string in `dst`, then appends a null\nterminator.\n\n`src` and `dst` must not overlap.\n\nIf `maxlen` - wcslen(dst) - 1 is less than or equal to 0, then `dst` is\nunmodified.\n\n@param dst The destination buffer already containing the first\n           null-terminated wide string. Must not be nullptr and must not\n           overlap with `src`.\n@param src The second null-terminated wide string. Must not be nullptr, and\n           must not overlap with `dst`.\n@param maxlen The length (in wide characters) of the destination buffer.\n@returns the length (in wide characters, excluding the null terminator) of\n         the string in `dst` plus the length of `src`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa wcslcpy",
          "name": "wcslcat",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "dst",
              "type": "wchar_t *"
            },
            {
              "name": "src",
              "type": "const wchar_t *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_wcslcat"
        },
        "wcsdup": {
          "doc": "Allocate a copy of a wide string.\n\nThis allocates enough space for a null-terminated copy of `wstr`, using\nmalloc, and then makes a copy of the string into this space.\n\nThe returned string is owned by the caller, and should be passed to\nfree when no longer needed.\n\n@param wstr the string to copy.\n@returns a pointer to the newly-allocated wide string.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "wcsdup",
          "kind": "function",
          "type": "wchar_t *",
          "parameters": [
            {
              "name": "wstr",
              "type": "const wchar_t *"
            }
          ],
          "sourceName": "SDL_wcsdup"
        },
        "wcsstr": {
          "doc": "Search a wide string for the first instance of a specific substring.\n\nThe search ends once it finds the requested substring, or a null terminator\nbyte to end the string.\n\nNote that this looks for strings of _wide characters_, not _codepoints_, so\nit's legal to search for malformed and incomplete UTF-16 sequences.\n\n@param haystack the wide string to search. Must not be nullptr.\n@param needle the wide string to search for. Must not be nullptr.\n@returns a pointer to the first instance of `needle` in the string, or nullptr\n         if not found.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "wcsstr",
          "kind": "function",
          "type": "wchar_t *",
          "parameters": [
            {
              "name": "haystack",
              "type": "const wchar_t *"
            },
            {
              "name": "needle",
              "type": "const wchar_t *"
            }
          ],
          "sourceName": "SDL_wcsstr"
        },
        "wcsnstr": {
          "doc": "Search a wide string, up to n wide chars, for the first instance of a\nspecific substring.\n\nThe search ends once it finds the requested substring, or a null terminator\nvalue to end the string, or `maxlen` wide character have been examined. It\nis possible to use this function on a wide string without a null\nterminator.\n\nNote that this looks for strings of _wide characters_, not _codepoints_, so\nit's legal to search for malformed and incomplete UTF-16 sequences.\n\n@param haystack the wide string to search. Must not be nullptr.\n@param needle the wide string to search for. Must not be nullptr.\n@param maxlen the maximum number of wide characters to search in\n              `haystack`.\n@returns a pointer to the first instance of `needle` in the string, or nullptr\n         if not found.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "wcsnstr",
          "kind": "function",
          "type": "wchar_t *",
          "parameters": [
            {
              "name": "haystack",
              "type": "const wchar_t *"
            },
            {
              "name": "needle",
              "type": "const wchar_t *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_wcsnstr"
        },
        "wcscmp": {
          "doc": "Compare two null-terminated wide strings.\n\nThis only compares wchar_t values until it hits a null-terminating\ncharacter; it does not care if the string is well-formed UTF-16 (or UTF-32,\ndepending on your platform's wchar_t size), or uses valid Unicode values.\n\n@param str1 the first string to compare. nullptr is not permitted!\n@param str2 the second string to compare. nullptr is not permitted!\n@returns less than zero if str1 is \"less than\" str2, greater than zero if\n         str1 is \"greater than\" str2, and zero if the strings match\n         exactly.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "wcscmp",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "str1",
              "type": "const wchar_t *"
            },
            {
              "name": "str2",
              "type": "const wchar_t *"
            }
          ],
          "sourceName": "SDL_wcscmp"
        },
        "wcsncmp": {
          "doc": "Compare two wide strings up to a number of wchar_t values.\n\nThis only compares wchar_t values; it does not care if the string is\nwell-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),\nor uses valid Unicode values.\n\nNote that while this function is intended to be used with UTF-16 (or\nUTF-32, depending on your platform's definition of wchar_t), it is\ncomparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies\na wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16\nsequence, it will only compare a portion of the final character.\n\n`maxlen` specifies a maximum number of wchar_t to compare; if the strings\nmatch to this number of wide chars (or both have matched to a\nnull-terminator character before this count), they will be considered\nequal.\n\n@param str1 the first string to compare. nullptr is not permitted!\n@param str2 the second string to compare. nullptr is not permitted!\n@param maxlen the maximum number of wchar_t to compare.\n@returns less than zero if str1 is \"less than\" str2, greater than zero if\n         str1 is \"greater than\" str2, and zero if the strings match\n         exactly.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "wcsncmp",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "str1",
              "type": "const wchar_t *"
            },
            {
              "name": "str2",
              "type": "const wchar_t *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_wcsncmp"
        },
        "wcscasecmp": {
          "doc": "Compare two null-terminated wide strings, case-insensitively.\n\nThis will work with Unicode strings, using a technique called\n\"case-folding\" to handle the vast majority of case-sensitive human\nlanguages regardless of system locale. It can deal with expanding values: a\nGerman Eszett character can compare against two ASCII 's' chars and be\nconsidered a match, for example. A notable exception: it does not handle\nthe Turkish 'i' character; human language is complicated!\n\nDepending on your platform, \"wchar_t\" might be 2 bytes, and expected to be\nUTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this\nhandles Unicode, it expects the string to be well-formed and not a\nnull-terminated string of arbitrary bytes. Characters that are not valid\nUTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT\nCHARACTER), which is to say two strings of random bits may turn out to\nmatch if they convert to the same amount of replacement characters.\n\n@param str1 the first string to compare. nullptr is not permitted!\n@param str2 the second string to compare. nullptr is not permitted!\n@returns less than zero if str1 is \"less than\" str2, greater than zero if\n         str1 is \"greater than\" str2, and zero if the strings match\n         exactly.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "wcscasecmp",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "str1",
              "type": "const wchar_t *"
            },
            {
              "name": "str2",
              "type": "const wchar_t *"
            }
          ],
          "sourceName": "SDL_wcscasecmp"
        },
        "wcsncasecmp": {
          "doc": "Compare two wide strings, case-insensitively, up to a number of wchar_t.\n\nThis will work with Unicode strings, using a technique called\n\"case-folding\" to handle the vast majority of case-sensitive human\nlanguages regardless of system locale. It can deal with expanding values: a\nGerman Eszett character can compare against two ASCII 's' chars and be\nconsidered a match, for example. A notable exception: it does not handle\nthe Turkish 'i' character; human language is complicated!\n\nDepending on your platform, \"wchar_t\" might be 2 bytes, and expected to be\nUTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this\nhandles Unicode, it expects the string to be well-formed and not a\nnull-terminated string of arbitrary bytes. Characters that are not valid\nUTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT\nCHARACTER), which is to say two strings of random bits may turn out to\nmatch if they convert to the same amount of replacement characters.\n\nNote that while this function might deal with variable-sized characters,\n`maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a\nmulti-byte UTF-16 sequence, it may convert a portion of the final character\nto one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not\nto overflow a buffer.\n\n`maxlen` specifies a maximum number of wchar_t values to compare; if the\nstrings match to this number of wchar_t (or both have matched to a\nnull-terminator character before this number of bytes), they will be\nconsidered equal.\n\n@param str1 the first string to compare. nullptr is not permitted!\n@param str2 the second string to compare. nullptr is not permitted!\n@param maxlen the maximum number of wchar_t values to compare.\n@returns less than zero if str1 is \"less than\" str2, greater than zero if\n         str1 is \"greater than\" str2, and zero if the strings match\n         exactly.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "wcsncasecmp",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "str1",
              "type": "const wchar_t *"
            },
            {
              "name": "str2",
              "type": "const wchar_t *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_wcsncasecmp"
        },
        "wcstol": {
          "doc": "Parse a `long` from a wide string.\n\nIf `str` starts with whitespace, then those whitespace characters are\nskipped before attempting to parse the number.\n\nIf the parsed number does not fit inside a `long`, the result is clamped to\nthe minimum and maximum representable `long` values.\n\n@param str The null-terminated wide string to read. Must not be nullptr.\n@param endp If not nullptr, the address of the first invalid wide character\n            (i.e. the next character after the parsed number) will be\n            written to this pointer.\n@param base The base of the integer to read. Supported values are 0 and 2\n            to 36 inclusive. If 0, the base will be inferred from the\n            number's prefix (0x for hexadecimal, 0 for octal, decimal\n            otherwise).\n@returns the parsed `long`, or 0 if no number could be parsed.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa strtol",
          "name": "wcstol",
          "kind": "function",
          "type": "long",
          "parameters": [
            {
              "name": "str",
              "type": "const wchar_t *"
            },
            {
              "name": "endp",
              "type": "wchar_t **"
            },
            {
              "name": "base",
              "type": "int"
            }
          ],
          "sourceName": "SDL_wcstol"
        },
        "strlen": {
          "doc": "This works exactly like strlen() but doesn't require access to a C runtime.\n\nCounts the bytes in `str`, excluding the null terminator.\n\nIf you need the length of a UTF-8 string, consider using utf8strlen().\n\n@param str The null-terminated string to read. Must not be nullptr.\n@returns the length (in bytes, excluding the null terminator) of `src`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa strnlen\n@sa utf8strlen\n@sa utf8strnlen",
          "name": "strlen",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "str",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_strlen"
        },
        "strnlen": {
          "doc": "This works exactly like strnlen() but doesn't require access to a C\nruntime.\n\nCounts up to a maximum of `maxlen` bytes in `str`, excluding the null\nterminator.\n\nIf you need the length of a UTF-8 string, consider using utf8strnlen().\n\n@param str The null-terminated string to read. Must not be nullptr.\n@param maxlen The maximum amount of bytes to count.\n@returns the length (in bytes, excluding the null terminator) of `src` but\n         never more than `maxlen`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa strlen\n@sa utf8strlen\n@sa utf8strnlen",
          "name": "strnlen",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "str",
              "type": "StringParam"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_strnlen"
        },
        "strlcpy": {
          "doc": "Copy a string.\n\nThis function copies up to `maxlen` - 1 characters from `src` to `dst`,\nthen appends a null terminator.\n\nIf `maxlen` is 0, no characters are copied and no null terminator is\nwritten.\n\nIf you want to copy an UTF-8 string but need to ensure that multi-byte\nsequences are not truncated, consider using utf8strlcpy().\n\n@param dst The destination buffer. Must not be nullptr, and must not overlap\n           with `src`.\n@param src The null-terminated string to copy. Must not be nullptr, and must\n           not overlap with `dst`.\n@param maxlen The length (in characters) of the destination buffer.\n@returns the length (in characters, excluding the null terminator) of\n         `src`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa strlcat\n@sa utf8strlcpy",
          "name": "strlcpy",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "dst",
              "type": "char *"
            },
            {
              "name": "src",
              "type": "StringParam"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_strlcpy"
        },
        "utf8strlcpy": {
          "doc": "Copy an UTF-8 string.\n\nThis function copies up to `dst_bytes` - 1 bytes from `src` to `dst` while\nalso ensuring that the string written to `dst` does not end in a truncated\nmulti-byte sequence. Finally, it appends a null terminator.\n\n`src` and `dst` must not overlap.\n\nNote that unlike strlcpy(), this function returns the number of bytes\nwritten, not the length of `src`.\n\n@param dst The destination buffer. Must not be nullptr, and must not overlap\n           with `src`.\n@param src The null-terminated UTF-8 string to copy. Must not be nullptr, and\n           must not overlap with `dst`.\n@param dst_bytes The length (in bytes) of the destination buffer. Must not\n                 be 0.\n@returns the number of bytes written, excluding the null terminator.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa strlcpy",
          "name": "utf8strlcpy",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "dst",
              "type": "char *"
            },
            {
              "name": "src",
              "type": "StringParam"
            },
            {
              "name": "dst_bytes",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_utf8strlcpy"
        },
        "strlcat": {
          "doc": "Concatenate strings.\n\nThis function appends up to `maxlen` - strlen(dst) - 1 characters from\n`src` to the end of the string in `dst`, then appends a null terminator.\n\n`src` and `dst` must not overlap.\n\nIf `maxlen` - strlen(dst) - 1 is less than or equal to 0, then `dst` is\nunmodified.\n\n@param dst The destination buffer already containing the first\n           null-terminated string. Must not be nullptr and must not overlap\n           with `src`.\n@param src The second null-terminated string. Must not be nullptr, and must\n           not overlap with `dst`.\n@param maxlen The length (in characters) of the destination buffer.\n@returns the length (in characters, excluding the null terminator) of the\n         string in `dst` plus the length of `src`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa strlcpy",
          "name": "strlcat",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "dst",
              "type": "char *"
            },
            {
              "name": "src",
              "type": "StringParam"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_strlcat"
        },
        "strdup": {
          "doc": "Allocate a copy of a string.\n\nThis allocates enough space for a null-terminated copy of `str`, using\nmalloc, and then makes a copy of the string into this space.\n\nThe returned string is owned by the caller, and should be passed to\nfree when no longer needed.\n\n@param str the string to copy.\n@returns a pointer to the newly-allocated string.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "strdup",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "str",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_strdup"
        },
        "strndup": {
          "doc": "Allocate a copy of a string, up to n characters.\n\nThis allocates enough space for a null-terminated copy of `str`, up to\n`maxlen` bytes, using malloc, and then makes a copy of the string into\nthis space.\n\nIf the string is longer than `maxlen` bytes, the returned string will be\n`maxlen` bytes long, plus a null-terminator character that isn't included\nin the count.\n\nThe returned string is owned by the caller, and should be passed to\nfree when no longer needed.\n\n@param str the string to copy.\n@param maxlen the maximum length of the copied string, not counting the\n              null-terminator character.\n@returns a pointer to the newly-allocated string.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "strndup",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "str",
              "type": "StringParam"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_strndup"
        },
        "strrev": {
          "doc": "Reverse a string's contents.\n\nThis reverses a null-terminated string in-place. Only the content of the\nstring is reversed; the null-terminator character remains at the end of the\nreversed string.\n\n**WARNING**: This function reverses the _bytes_ of the string, not the\ncodepoints. If `str` is a UTF-8 string with Unicode codepoints > 127, this\nwill ruin the string data. You should only use this function on strings\nthat are completely comprised of low ASCII characters.\n\n@param str the string to reverse.\n@returns `str`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "strrev",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "str",
              "type": "char *"
            }
          ],
          "sourceName": "SDL_strrev"
        },
        "strupr": {
          "doc": "Convert a string to uppercase.\n\n**WARNING**: Regardless of system locale, this will only convert ASCII\nvalues 'A' through 'Z' to uppercase.\n\nThis function operates on a null-terminated string of bytes--even if it is\nmalformed UTF-8!--and converts ASCII characters 'a' through 'z' to their\nuppercase equivalents in-place, returning the original `str` pointer.\n\n@param str the string to convert in-place. Can not be nullptr.\n@returns the `str` pointer passed into this function.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa strlwr",
          "name": "strupr",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "str",
              "type": "char *"
            }
          ],
          "sourceName": "SDL_strupr"
        },
        "strlwr": {
          "doc": "Convert a string to lowercase.\n\n**WARNING**: Regardless of system locale, this will only convert ASCII\nvalues 'A' through 'Z' to lowercase.\n\nThis function operates on a null-terminated string of bytes--even if it is\nmalformed UTF-8!--and converts ASCII characters 'A' through 'Z' to their\nlowercase equivalents in-place, returning the original `str` pointer.\n\n@param str the string to convert in-place. Can not be nullptr.\n@returns the `str` pointer passed into this function.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa strupr",
          "name": "strlwr",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "str",
              "type": "char *"
            }
          ],
          "sourceName": "SDL_strlwr"
        },
        "strchr": {
          "doc": "Search a string for the first instance of a specific byte.\n\nThe search ends once it finds the requested byte value, or a null\nterminator byte to end the string.\n\nNote that this looks for _bytes_, not _characters_, so you cannot match\nagainst a Unicode codepoint > 255, regardless of character encoding.\n\n@param str the string to search. Must not be nullptr.\n@param c the byte value to search for.\n@returns a pointer to the first instance of `c` in the string, or nullptr if\n         not found.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "strchr",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "str",
              "type": "StringParam"
            },
            {
              "name": "c",
              "type": "int"
            }
          ],
          "sourceName": "SDL_strchr"
        },
        "strrchr": {
          "doc": "Search a string for the last instance of a specific byte.\n\nThe search must go until it finds a null terminator byte to end the string.\n\nNote that this looks for _bytes_, not _characters_, so you cannot match\nagainst a Unicode codepoint > 255, regardless of character encoding.\n\n@param str the string to search. Must not be nullptr.\n@param c the byte value to search for.\n@returns a pointer to the last instance of `c` in the string, or nullptr if\n         not found.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "strrchr",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "str",
              "type": "StringParam"
            },
            {
              "name": "c",
              "type": "int"
            }
          ],
          "sourceName": "SDL_strrchr"
        },
        "strstr": {
          "doc": "Search a string for the first instance of a specific substring.\n\nThe search ends once it finds the requested substring, or a null terminator\nbyte to end the string.\n\nNote that this looks for strings of _bytes_, not _characters_, so it's\nlegal to search for malformed and incomplete UTF-8 sequences.\n\n@param haystack the string to search. Must not be nullptr.\n@param needle the string to search for. Must not be nullptr.\n@returns a pointer to the first instance of `needle` in the string, or nullptr\n         if not found.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "strstr",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "haystack",
              "type": "StringParam"
            },
            {
              "name": "needle",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_strstr"
        },
        "strnstr": {
          "doc": "Search a string, up to n bytes, for the first instance of a specific\nsubstring.\n\nThe search ends once it finds the requested substring, or a null terminator\nbyte to end the string, or `maxlen` bytes have been examined. It is\npossible to use this function on a string without a null terminator.\n\nNote that this looks for strings of _bytes_, not _characters_, so it's\nlegal to search for malformed and incomplete UTF-8 sequences.\n\n@param haystack the string to search. Must not be nullptr.\n@param needle the string to search for. Must not be nullptr.\n@param maxlen the maximum number of bytes to search in `haystack`.\n@returns a pointer to the first instance of `needle` in the string, or nullptr\n         if not found.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "strnstr",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "haystack",
              "type": "StringParam"
            },
            {
              "name": "needle",
              "type": "StringParam"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_strnstr"
        },
        "strcasestr": {
          "doc": "Search a UTF-8 string for the first instance of a specific substring,\ncase-insensitively.\n\nThis will work with Unicode strings, using a technique called\n\"case-folding\" to handle the vast majority of case-sensitive human\nlanguages regardless of system locale. It can deal with expanding values: a\nGerman Eszett character can compare against two ASCII 's' chars and be\nconsidered a match, for example. A notable exception: it does not handle\nthe Turkish 'i' character; human language is complicated!\n\nSince this handles Unicode, it expects the strings to be well-formed UTF-8\nand not a null-terminated string of arbitrary bytes. Bytes that are not\nvalid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT\nCHARACTER), which is to say two strings of random bits may turn out to\nmatch if they convert to the same amount of replacement characters.\n\n@param haystack the string to search. Must not be nullptr.\n@param needle the string to search for. Must not be nullptr.\n@returns a pointer to the first instance of `needle` in the string, or nullptr\n         if not found.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "strcasestr",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "haystack",
              "type": "StringParam"
            },
            {
              "name": "needle",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_strcasestr"
        },
        "strtok_r": {
          "doc": "This works exactly like strtok_r() but doesn't require access to a C\nruntime.\n\nBreak a string up into a series of tokens.\n\nTo start tokenizing a new string, `str` should be the non-nullptr address of\nthe string to start tokenizing. Future calls to get the next token from the\nsame string should specify a nullptr.\n\nNote that this function will overwrite pieces of `str` with null chars to\nsplit it into tokens. This function cannot be used with const/read-only\nstrings!\n\n`saveptr` just needs to point to a `char *` that can be overwritten; SDL\nwill use this to save tokenizing state between calls. It is initialized if\n`str` is non-nullptr, and used to resume tokenizing when `str` is nullptr.\n\n@param str the string to tokenize, or nullptr to continue tokenizing.\n@param delim the delimiter string that separates tokens.\n@param saveptr pointer to a char *, used for ongoing state.\n@returns A pointer to the next token, or nullptr if no tokens remain.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "strtok_r",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "str",
              "type": "char *"
            },
            {
              "name": "delim",
              "type": "StringParam"
            },
            {
              "name": "saveptr",
              "type": "char **"
            }
          ],
          "sourceName": "SDL_strtok_r"
        },
        "utf8strlen": {
          "doc": "Count the number of codepoints in a UTF-8 string.\n\nCounts the _codepoints_, not _bytes_, in `str`, excluding the null\nterminator.\n\nIf you need to count the bytes in a string instead, consider using\nstrlen().\n\nSince this handles Unicode, it expects the strings to be well-formed UTF-8\nand not a null-terminated string of arbitrary bytes. Bytes that are not\nvalid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT\nCHARACTER), so a malformed or incomplete UTF-8 sequence might increase the\ncount by several replacement characters.\n\n@param str The null-terminated UTF-8 string to read. Must not be nullptr.\n@returns The length (in codepoints, excluding the null terminator) of\n         `src`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa utf8strnlen\n@sa strlen",
          "name": "utf8strlen",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "str",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_utf8strlen"
        },
        "utf8strnlen": {
          "doc": "Count the number of codepoints in a UTF-8 string, up to n bytes.\n\nCounts the _codepoints_, not _bytes_, in `str`, excluding the null\nterminator.\n\nIf you need to count the bytes in a string instead, consider using\nstrnlen().\n\nThe counting stops at `bytes` bytes (not codepoints!). This seems\ncounterintuitive, but makes it easy to express the total size of the\nstring's buffer.\n\nSince this handles Unicode, it expects the strings to be well-formed UTF-8\nand not a null-terminated string of arbitrary bytes. Bytes that are not\nvalid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT\nCHARACTER), so a malformed or incomplete UTF-8 sequence might increase the\ncount by several replacement characters.\n\n@param str The null-terminated UTF-8 string to read. Must not be nullptr.\n@param bytes The maximum amount of bytes to count.\n@returns The length (in codepoints, excluding the null terminator) of `src`\n         but never more than `maxlen`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa utf8strlen\n@sa strnlen",
          "name": "utf8strnlen",
          "kind": "function",
          "type": "size_t",
          "parameters": [
            {
              "name": "str",
              "type": "StringParam"
            },
            {
              "name": "bytes",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_utf8strnlen"
        },
        "itoa": {
          "doc": "Convert an integer into a string.\n\nThis requires a radix to specified for string format. Specifying 10\nproduces a decimal number, 16 hexidecimal, etc. Must be in the range of 2\nto 36.\n\nNote that this function will overflow a buffer if `str` is not large enough\nto hold the output! It may be safer to use snprintf to clamp output, or\nasprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate\nmuch more space than you expect to use (and don't forget possible negative\nsigns, null terminator bytes, etc).\n\n@param value the integer to convert.\n@param str the buffer to write the string into.\n@param radix the radix to use for string generation.\n@returns `str`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa uitoa\n@sa ltoa\n@sa SDL_lltoa",
          "name": "itoa",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "value",
              "type": "int"
            },
            {
              "name": "str",
              "type": "char *"
            },
            {
              "name": "radix",
              "type": "int"
            }
          ],
          "sourceName": "SDL_itoa"
        },
        "uitoa": {
          "doc": "Convert an unsigned integer into a string.\n\nThis requires a radix to specified for string format. Specifying 10\nproduces a decimal number, 16 hexidecimal, etc. Must be in the range of 2\nto 36.\n\nNote that this function will overflow a buffer if `str` is not large enough\nto hold the output! It may be safer to use snprintf to clamp output, or\nasprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate\nmuch more space than you expect to use (and don't forget null terminator\nbytes, etc).\n\n@param value the unsigned integer to convert.\n@param str the buffer to write the string into.\n@param radix the radix to use for string generation.\n@returns `str`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa itoa\n@sa ultoa\n@sa SDL_ulltoa",
          "name": "uitoa",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "value",
              "type": "unsigned int"
            },
            {
              "name": "str",
              "type": "char *"
            },
            {
              "name": "radix",
              "type": "int"
            }
          ],
          "sourceName": "SDL_uitoa"
        },
        "ltoa": {
          "doc": "Convert a long integer into a string.\n\nThis requires a radix to specified for string format. Specifying 10\nproduces a decimal number, 16 hexidecimal, etc. Must be in the range of 2\nto 36.\n\nNote that this function will overflow a buffer if `str` is not large enough\nto hold the output! It may be safer to use snprintf to clamp output, or\nasprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate\nmuch more space than you expect to use (and don't forget possible negative\nsigns, null terminator bytes, etc).\n\n@param value the long integer to convert.\n@param str the buffer to write the string into.\n@param radix the radix to use for string generation.\n@returns `str`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa ultoa\n@sa itoa\n@sa SDL_lltoa",
          "name": "ltoa",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "value",
              "type": "long"
            },
            {
              "name": "str",
              "type": "char *"
            },
            {
              "name": "radix",
              "type": "int"
            }
          ],
          "sourceName": "SDL_ltoa"
        },
        "ultoa": {
          "doc": "Convert an unsigned long integer into a string.\n\nThis requires a radix to specified for string format. Specifying 10\nproduces a decimal number, 16 hexidecimal, etc. Must be in the range of 2\nto 36.\n\nNote that this function will overflow a buffer if `str` is not large enough\nto hold the output! It may be safer to use snprintf to clamp output, or\nasprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate\nmuch more space than you expect to use (and don't forget null terminator\nbytes, etc).\n\n@param value the unsigned long integer to convert.\n@param str the buffer to write the string into.\n@param radix the radix to use for string generation.\n@returns `str`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa ltoa\n@sa uitoa\n@sa SDL_ulltoa",
          "name": "ultoa",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "value",
              "type": "unsigned long"
            },
            {
              "name": "str",
              "type": "char *"
            },
            {
              "name": "radix",
              "type": "int"
            }
          ],
          "sourceName": "SDL_ultoa"
        },
        "atoi": {
          "doc": "Parse an `int` from a string.\n\nThe result of calling `atoi(str)` is equivalent to\n`(int)strtol(str, nullptr, 10)`.\n\n@param str The null-terminated string to read. Must not be nullptr.\n@returns the parsed `int`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa atof\n@sa strtol\n@sa strtoul\n@sa SDL_strtoll\n@sa SDL_strtoull\n@sa strtod\n@sa itoa",
          "name": "atoi",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "str",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_atoi"
        },
        "atof": {
          "doc": "Parse a `double` from a string.\n\nThe result of calling `atof(str)` is equivalent to `strtod(str,\nnullptr)`.\n\n@param str The null-terminated string to read. Must not be nullptr.\n@returns the parsed `double`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa atoi\n@sa strtol\n@sa strtoul\n@sa SDL_strtoll\n@sa SDL_strtoull\n@sa strtod",
          "name": "atof",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "str",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_atof"
        },
        "strtol": {
          "doc": "Parse a `long` from a string.\n\nIf `str` starts with whitespace, then those whitespace characters are\nskipped before attempting to parse the number.\n\nIf the parsed number does not fit inside a `long`, the result is clamped to\nthe minimum and maximum representable `long` values.\n\n@param str The null-terminated string to read. Must not be nullptr.\n@param endp If not nullptr, the address of the first invalid character (i.e.\n            the next character after the parsed number) will be written to\n            this pointer.\n@param base The base of the integer to read. Supported values are 0 and 2\n            to 36 inclusive. If 0, the base will be inferred from the\n            number's prefix (0x for hexadecimal, 0 for octal, decimal\n            otherwise).\n@returns the parsed `long`, or 0 if no number could be parsed.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa atoi\n@sa atof\n@sa strtoul\n@sa SDL_strtoll\n@sa SDL_strtoull\n@sa strtod\n@sa ltoa\n@sa wcstol",
          "name": "strtol",
          "kind": "function",
          "type": "long",
          "parameters": [
            {
              "name": "str",
              "type": "StringParam"
            },
            {
              "name": "endp",
              "type": "char **"
            },
            {
              "name": "base",
              "type": "int"
            }
          ],
          "sourceName": "SDL_strtol"
        },
        "strtoul": {
          "doc": "Parse an `unsigned long` from a string.\n\nIf `str` starts with whitespace, then those whitespace characters are\nskipped before attempting to parse the number.\n\nIf the parsed number does not fit inside an `unsigned long`, the result is\nclamped to the maximum representable `unsigned long` value.\n\n@param str The null-terminated string to read. Must not be nullptr.\n@param endp If not nullptr, the address of the first invalid character (i.e.\n            the next character after the parsed number) will be written to\n            this pointer.\n@param base The base of the integer to read. Supported values are 0 and 2\n            to 36 inclusive. If 0, the base will be inferred from the\n            number's prefix (0x for hexadecimal, 0 for octal, decimal\n            otherwise).\n@returns the parsed `unsigned long`, or 0 if no number could be parsed.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa atoi\n@sa atof\n@sa strtol\n@sa SDL_strtoll\n@sa SDL_strtoull\n@sa strtod\n@sa ultoa",
          "name": "strtoul",
          "kind": "function",
          "type": "unsigned long",
          "parameters": [
            {
              "name": "str",
              "type": "StringParam"
            },
            {
              "name": "endp",
              "type": "char **"
            },
            {
              "name": "base",
              "type": "int"
            }
          ],
          "sourceName": "SDL_strtoul"
        },
        "strtod": {
          "doc": "Parse a `double` from a string.\n\nThis function makes fewer guarantees than the C runtime `strtod`:\n\n- Only decimal notation is guaranteed to be supported. The handling of\n  scientific and hexadecimal notation is unspecified.\n- Whether or not INF and NAN can be parsed is unspecified.\n- The precision of the result is unspecified.\n\n@param str the null-terminated string to read. Must not be nullptr.\n@param endp if not nullptr, the address of the first invalid character (i.e.\n            the next character after the parsed number) will be written to\n            this pointer.\n@returns the parsed `double`, or 0 if no number could be parsed.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa atoi\n@sa atof\n@sa strtol\n@sa SDL_strtoll\n@sa strtoul\n@sa SDL_strtoull",
          "name": "strtod",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "str",
              "type": "StringParam"
            },
            {
              "name": "endp",
              "type": "char **"
            }
          ],
          "sourceName": "SDL_strtod"
        },
        "strcmp": {
          "doc": "Compare two null-terminated UTF-8 strings.\n\nDue to the nature of UTF-8 encoding, this will work with Unicode strings,\nsince effectively this function just compares bytes until it hits a\nnull-terminating character. Also due to the nature of UTF-8, this can be\nused with qsort() to put strings in (roughly) alphabetical order.\n\n@param str1 the first string to compare. nullptr is not permitted!\n@param str2 the second string to compare. nullptr is not permitted!\n@returns less than zero if str1 is \"less than\" str2, greater than zero if\n         str1 is \"greater than\" str2, and zero if the strings match\n         exactly.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "strcmp",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "str1",
              "type": "StringParam"
            },
            {
              "name": "str2",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_strcmp"
        },
        "strncmp": {
          "doc": "Compare two UTF-8 strings up to a number of bytes.\n\nDue to the nature of UTF-8 encoding, this will work with Unicode strings,\nsince effectively this function just compares bytes until it hits a\nnull-terminating character. Also due to the nature of UTF-8, this can be\nused with qsort() to put strings in (roughly) alphabetical order.\n\nNote that while this function is intended to be used with UTF-8, it is\ndoing a bytewise comparison, and `maxlen` specifies a _byte_ limit! If the\nlimit lands in the middle of a multi-byte UTF-8 sequence, it will only\ncompare a portion of the final character.\n\n`maxlen` specifies a maximum number of bytes to compare; if the strings\nmatch to this number of bytes (or both have matched to a null-terminator\ncharacter before this number of bytes), they will be considered equal.\n\n@param str1 the first string to compare. nullptr is not permitted!\n@param str2 the second string to compare. nullptr is not permitted!\n@param maxlen the maximum number of _bytes_ to compare.\n@returns less than zero if str1 is \"less than\" str2, greater than zero if\n         str1 is \"greater than\" str2, and zero if the strings match\n         exactly.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "strncmp",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "str1",
              "type": "StringParam"
            },
            {
              "name": "str2",
              "type": "StringParam"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_strncmp"
        },
        "strcasecmp": {
          "doc": "Compare two null-terminated UTF-8 strings, case-insensitively.\n\nThis will work with Unicode strings, using a technique called\n\"case-folding\" to handle the vast majority of case-sensitive human\nlanguages regardless of system locale. It can deal with expanding values: a\nGerman Eszett character can compare against two ASCII 's' chars and be\nconsidered a match, for example. A notable exception: it does not handle\nthe Turkish 'i' character; human language is complicated!\n\nSince this handles Unicode, it expects the string to be well-formed UTF-8\nand not a null-terminated string of arbitrary bytes. Bytes that are not\nvalid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT\nCHARACTER), which is to say two strings of random bits may turn out to\nmatch if they convert to the same amount of replacement characters.\n\n@param str1 the first string to compare. nullptr is not permitted!\n@param str2 the second string to compare. nullptr is not permitted!\n@returns less than zero if str1 is \"less than\" str2, greater than zero if\n         str1 is \"greater than\" str2, and zero if the strings match\n         exactly.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "strcasecmp",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "str1",
              "type": "StringParam"
            },
            {
              "name": "str2",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_strcasecmp"
        },
        "strncasecmp": {
          "doc": "Compare two UTF-8 strings, case-insensitively, up to a number of bytes.\n\nThis will work with Unicode strings, using a technique called\n\"case-folding\" to handle the vast majority of case-sensitive human\nlanguages regardless of system locale. It can deal with expanding values: a\nGerman Eszett character can compare against two ASCII 's' chars and be\nconsidered a match, for example. A notable exception: it does not handle\nthe Turkish 'i' character; human language is complicated!\n\nSince this handles Unicode, it expects the string to be well-formed UTF-8\nand not a null-terminated string of arbitrary bytes. Bytes that are not\nvalid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT\nCHARACTER), which is to say two strings of random bits may turn out to\nmatch if they convert to the same amount of replacement characters.\n\nNote that while this function is intended to be used with UTF-8, `maxlen`\nspecifies a _byte_ limit! If the limit lands in the middle of a multi-byte\nUTF-8 sequence, it may convert a portion of the final character to one or\nmore Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not to overflow\na buffer.\n\n`maxlen` specifies a maximum number of bytes to compare; if the strings\nmatch to this number of bytes (or both have matched to a null-terminator\ncharacter before this number of bytes), they will be considered equal.\n\n@param str1 the first string to compare. nullptr is not permitted!\n@param str2 the second string to compare. nullptr is not permitted!\n@param maxlen the maximum number of bytes to compare.\n@returns less than zero if str1 is \"less than\" str2, greater than zero if\n         str1 is \"greater than\" str2, and zero if the strings match\n         exactly.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "strncasecmp",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "str1",
              "type": "StringParam"
            },
            {
              "name": "str2",
              "type": "StringParam"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_strncasecmp"
        },
        "strpbrk": {
          "doc": "Searches a string for the first occurence of any character contained in a\nbreakset, and returns a pointer from the string to that character.\n\n@param str The null-terminated string to be searched. Must not be nullptr, and\n           must not overlap with `breakset`.\n@param breakset A null-terminated string containing the list of characters\n                to look for. Must not be nullptr, and must not overlap with\n                `str`.\n@returns A pointer to the location, in str, of the first occurence of a\n         character present in the breakset, or nullptr if none is found.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "strpbrk",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "str",
              "type": "StringParam"
            },
            {
              "name": "breakset",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_strpbrk"
        },
        "INVALID_UNICODE_CODEPOINT": {
          "doc": "The Unicode REPLACEMENT CHARACTER codepoint.\n\nStepUTF8() and StepBackUTF8() report this codepoint when they\nencounter a UTF-8 string with encoding errors.\n\nThis tends to render as something like a question mark in most places.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa StepBackUTF8\n@sa StepUTF8",
          "name": "INVALID_UNICODE_CODEPOINT",
          "kind": "var",
          "value": "0xFFFD",
          "sourceName": "SDL_INVALID_UNICODE_CODEPOINT",
          "type": "Uint32",
          "constexpr": true
        },
        "StepUTF8": {
          "doc": "Decode a UTF-8 string, one Unicode codepoint at a time.\n\nThis will return the first Unicode codepoint in the UTF-8 encoded string in\n`*pstr`, and then advance `*pstr` past any consumed bytes before returning.\n\nIt will not access more than `*pslen` bytes from the string. `*pslen` will\nbe adjusted, as well, subtracting the number of bytes consumed.\n\n`pslen` is allowed to be nullptr, in which case the string _must_ be\nnullptr-terminated, as the function will blindly read until it sees the nullptr\nchar.\n\nif `*pslen` is zero, it assumes the end of string is reached and returns a\nzero codepoint regardless of the contents of the string buffer.\n\nIf the resulting codepoint is zero (a nullptr terminator), or `*pslen` is\nzero, it will not advance `*pstr` or `*pslen` at all.\n\nGenerally this function is called in a loop until it returns zero,\nadjusting its parameters each iteration.\n\nIf an invalid UTF-8 sequence is encountered, this function returns\nINVALID_UNICODE_CODEPOINT and advances the string/length by one byte\n(which is to say, a multibyte sequence might produce several\nINVALID_UNICODE_CODEPOINT returns before it syncs to the next valid\nUTF-8 sequence).\n\nSeveral things can generate invalid UTF-8 sequences, including overlong\nencodings, the use of UTF-16 surrogate values, and truncated data. Please\nrefer to\n[RFC3629](https://www.ietf.org/rfc/rfc3629.txt)\nfor details.\n\n@param pstr a pointer to a UTF-8 string pointer to be read and adjusted.\n@param pslen a pointer to the number of bytes in the string, to be read and\n             adjusted. nullptr is allowed.\n@returns the first Unicode codepoint in the string.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "StepUTF8",
          "kind": "function",
          "type": "Uint32",
          "parameters": [
            {
              "name": "pstr",
              "type": "const char **"
            },
            {
              "name": "pslen",
              "type": "size_t *"
            }
          ],
          "sourceName": "SDL_StepUTF8"
        },
        "StepBackUTF8": {
          "doc": "Decode a UTF-8 string in reverse, one Unicode codepoint at a time.\n\nThis will go to the start of the previous Unicode codepoint in the string,\nmove `*pstr` to that location and return that codepoint.\n\nIf `*pstr` is already at the start of the string), it will not advance\n`*pstr` at all.\n\nGenerally this function is called in a loop until it returns zero,\nadjusting its parameter each iteration.\n\nIf an invalid UTF-8 sequence is encountered, this function returns\nINVALID_UNICODE_CODEPOINT.\n\nSeveral things can generate invalid UTF-8 sequences, including overlong\nencodings, the use of UTF-16 surrogate values, and truncated data. Please\nrefer to\n[RFC3629](https://www.ietf.org/rfc/rfc3629.txt)\nfor details.\n\n@param start a pointer to the beginning of the UTF-8 string.\n@param pstr a pointer to a UTF-8 string pointer to be read and adjusted.\n@returns the previous Unicode codepoint in the string.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "StepBackUTF8",
          "kind": "function",
          "type": "Uint32",
          "parameters": [
            {
              "name": "start",
              "type": "StringParam"
            },
            {
              "name": "pstr",
              "type": "const char **"
            }
          ],
          "sourceName": "SDL_StepBackUTF8"
        },
        "UCS4ToUTF8": {
          "doc": "Convert a single Unicode codepoint to UTF-8.\n\nThe buffer pointed to by `dst` must be at least 4 bytes long, as this\nfunction may generate between 1 and 4 bytes of output.\n\nThis function returns the first byte _after_ the newly-written UTF-8\nsequence, which is useful for encoding multiple codepoints in a loop, or\nknowing where to write a nullptr-terminator character to end the string (in\neither case, plan to have a buffer of _more_ than 4 bytes!).\n\nIf `codepoint` is an invalid value (outside the Unicode range, or a UTF-16\nsurrogate value, etc), this will use U+FFFD (REPLACEMENT CHARACTER) for the\ncodepoint instead, and not set an error.\n\nIf `dst` is nullptr, this returns nullptr immediately without writing to the\npointer and without setting an error.\n\n@param codepoint a Unicode codepoint to convert to UTF-8.\n@param dst the location to write the encoded UTF-8. Must point to at least\n           4 bytes!\n@returns the first byte past the newly-written UTF-8 sequence.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "UCS4ToUTF8",
          "kind": "function",
          "type": "char *",
          "parameters": [
            {
              "name": "codepoint",
              "type": "Uint32"
            },
            {
              "name": "dst",
              "type": "char *"
            }
          ],
          "sourceName": "SDL_UCS4ToUTF8"
        },
        "sscanf": {
          "doc": "This works exactly like sscanf() but doesn't require access to a C runtime.\n\nScan a string, matching a format string, converting each '%' item and\nstoring it to pointers provided through variable arguments.\n\n@param text the string to scan. Must not be nullptr.\n@param fmt a printf-style format string. Must not be nullptr.\n@param ... a list of pointers to values to be filled in with scanned items.\n@returns the number of items that matched the format string.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "sscanf",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "text",
              "type": "StringParam"
            },
            {
              "name": "fmt",
              "type": "SDL_SCANF_FORMAT_STRING const char *"
            },
            "..."
          ],
          "sourceName": "SDL_sscanf"
        },
        "vsscanf": {
          "doc": "This works exactly like vsscanf() but doesn't require access to a C\nruntime.\n\nFunctions identically to sscanf(), except it takes a `va_list` instead\nof using `...` variable arguments.\n\n@param text the string to scan. Must not be nullptr.\n@param fmt a printf-style format string. Must not be nullptr.\n@param ap a `va_list` of pointers to values to be filled in with scanned\n          items.\n@returns the number of items that matched the format string.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "vsscanf",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "text",
              "type": "StringParam"
            },
            {
              "name": "fmt",
              "type": "SDL_SCANF_FORMAT_STRING const char *"
            },
            {
              "name": "ap",
              "type": "va_list"
            }
          ],
          "sourceName": "SDL_vsscanf"
        },
        "snprintf": {
          "doc": "This works exactly like snprintf() but doesn't require access to a C\nruntime.\n\nFormat a string of up to `maxlen`-1 bytes, converting each '%' item with\nvalues provided through variable arguments.\n\nWhile some C runtimes differ on how to deal with too-large strings, this\nfunction null-terminates the output, by treating the null-terminator as\npart of the `maxlen` count. Note that if `maxlen` is zero, however, no\nbytes will be written at all.\n\nThis function returns the number of _bytes_ (not _characters_) that should\nbe written, excluding the null-terminator character. If this returns a\nnumber >= `maxlen`, it means the output string was truncated. A negative\nreturn value means an error occurred.\n\nReferencing the output string's pointer with a format item is undefined\nbehavior.\n\n@param text the buffer to write the string into. Must not be nullptr.\n@param maxlen the maximum bytes to write, including the null-terminator.\n@param fmt a printf-style format string. Must not be nullptr.\n@param ... a list of values to be used with the format string.\n@returns the number of bytes that should be written, not counting the\n         null-terminator char, or a negative value on error.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "snprintf",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "text",
              "type": "char *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            },
            {
              "name": "fmt",
              "type": "SDL_PRINTF_FORMAT_STRING const char *"
            },
            "..."
          ],
          "sourceName": "SDL_snprintf"
        },
        "swprintf": {
          "doc": "This works exactly like swprintf() but doesn't require access to a C\nruntime.\n\nFormat a wide string of up to `maxlen`-1 wchar_t values, converting each\n'%' item with values provided through variable arguments.\n\nWhile some C runtimes differ on how to deal with too-large strings, this\nfunction null-terminates the output, by treating the null-terminator as\npart of the `maxlen` count. Note that if `maxlen` is zero, however, no wide\ncharacters will be written at all.\n\nThis function returns the number of _wide characters_ (not _codepoints_)\nthat should be written, excluding the null-terminator character. If this\nreturns a number >= `maxlen`, it means the output string was truncated. A\nnegative return value means an error occurred.\n\nReferencing the output string's pointer with a format item is undefined\nbehavior.\n\n@param text the buffer to write the wide string into. Must not be nullptr.\n@param maxlen the maximum wchar_t values to write, including the\n              null-terminator.\n@param fmt a printf-style format string. Must not be nullptr.\n@param ... a list of values to be used with the format string.\n@returns the number of wide characters that should be written, not counting\n         the null-terminator char, or a negative value on error.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "swprintf",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "text",
              "type": "wchar_t *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            },
            {
              "name": "fmt",
              "type": "SDL_PRINTF_FORMAT_STRING const wchar_t *"
            },
            "..."
          ],
          "sourceName": "SDL_swprintf"
        },
        "vsnprintf": {
          "doc": "This works exactly like vsnprintf() but doesn't require access to a C\nruntime.\n\nFunctions identically to snprintf(), except it takes a `va_list`\ninstead of using `...` variable arguments.\n\n@param text the buffer to write the string into. Must not be nullptr.\n@param maxlen the maximum bytes to write, including the null-terminator.\n@param fmt a printf-style format string. Must not be nullptr.\n@param ap a `va_list` values to be used with the format string.\n@returns the number of bytes that should be written, not counting the\n         null-terminator char, or a negative value on error.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "vsnprintf",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "text",
              "type": "char *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            },
            {
              "name": "fmt",
              "type": "SDL_PRINTF_FORMAT_STRING const char *"
            },
            {
              "name": "ap",
              "type": "va_list"
            }
          ],
          "sourceName": "SDL_vsnprintf"
        },
        "vswprintf": {
          "doc": "This works exactly like vswprintf() but doesn't require access to a C\nruntime.\n\nFunctions identically to swprintf(), except it takes a `va_list`\ninstead of using `...` variable arguments.\n\n@param text the buffer to write the string into. Must not be nullptr.\n@param maxlen the maximum wide characters to write, including the\n              null-terminator.\n@param fmt a printf-style format wide string. Must not be nullptr.\n@param ap a `va_list` values to be used with the format string.\n@returns the number of wide characters that should be written, not counting\n         the null-terminator char, or a negative value on error.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "vswprintf",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "text",
              "type": "wchar_t *"
            },
            {
              "name": "maxlen",
              "type": "size_t"
            },
            {
              "name": "fmt",
              "type": "SDL_PRINTF_FORMAT_STRING const wchar_t *"
            },
            {
              "name": "ap",
              "type": "va_list"
            }
          ],
          "sourceName": "SDL_vswprintf"
        },
        "asprintf": {
          "doc": "This works exactly like asprintf() but doesn't require access to a C\nruntime.\n\nFunctions identically to snprintf(), except it allocates a buffer large\nenough to hold the output string on behalf of the caller.\n\nOn success, this function returns the number of bytes (not characters)\ncomprising the output string, not counting the null-terminator character,\nand sets `*strp` to the newly-allocated string.\n\nOn error, this function returns a negative number, and the value of `*strp`\nis undefined.\n\nThe returned string is owned by the caller, and should be passed to\nfree when no longer needed.\n\n@param strp on output, is set to the new string. Must not be nullptr.\n@param fmt a printf-style format string. Must not be nullptr.\n@param ... a list of values to be used with the format string.\n@returns the number of bytes in the newly-allocated string, not counting\n         the null-terminator char, or a negative value on error.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "asprintf",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "strp",
              "type": "char **"
            },
            {
              "name": "fmt",
              "type": "SDL_PRINTF_FORMAT_STRING const char *"
            },
            "..."
          ],
          "sourceName": "SDL_asprintf"
        },
        "vasprintf": {
          "doc": "This works exactly like vasprintf() but doesn't require access to a C\nruntime.\n\nFunctions identically to asprintf(), except it takes a `va_list`\ninstead of using `...` variable arguments.\n\n@param strp on output, is set to the new string. Must not be nullptr.\n@param fmt a printf-style format string. Must not be nullptr.\n@param ap a `va_list` values to be used with the format string.\n@returns the number of bytes in the newly-allocated string, not counting\n         the null-terminator char, or a negative value on error.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "vasprintf",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "strp",
              "type": "char **"
            },
            {
              "name": "fmt",
              "type": "SDL_PRINTF_FORMAT_STRING const char *"
            },
            {
              "name": "ap",
              "type": "va_list"
            }
          ],
          "sourceName": "SDL_vasprintf"
        },
        "srand": {
          "doc": "Seeds the pseudo-random number generator.\n\nReusing the seed number will cause rand() to repeat the same stream of\n'random' numbers.\n\n@param seed the value to use as a random number seed, or 0 to use\n            GetPerformanceCounter().\n\n@threadsafety This should be called on the same thread that calls\n              rand()\n\n@since This function is available since SDL 3.2.0.\n\n@sa rand\n@sa rand_bits\n@sa randf",
          "name": "srand",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "seed",
              "type": "Uint64"
            }
          ],
          "sourceName": "SDL_srand"
        },
        "rand": {
          "doc": "Generate a pseudo-random number less than n for positive n\n\nThe method used is faster and of better quality than `rand() % n`. Odds are\nroughly 99.9% even for n = 1 million. Evenness is better for smaller n, and\nmuch worse as n gets bigger.\n\nExample: to simulate a d6 use `rand(6) + 1` The +1 converts 0..5 to\n1..6\n\nIf you want to generate a pseudo-random number in the full range of Sint32,\nyou should use: (Sint32)rand_bits()\n\nIf you want reproducible output, be sure to initialize with srand()\nfirst.\n\nThere are no guarantees as to the quality of the random sequence produced,\nand this should not be used for security (cryptography, passwords) or where\nmoney is on the line (loot-boxes, casinos). There are many random number\nlibraries available with different characteristics and you should pick one\nof those to meet any serious needs.\n\n@param n the number of possible outcomes. n must be positive.\n@returns a random value in the range of [0 .. n-1].\n\n@threadsafety All calls should be made from a single thread\n\n@since This function is available since SDL 3.2.0.\n\n@sa srand\n@sa randf",
          "name": "rand",
          "kind": "function",
          "type": "Sint32",
          "parameters": [
            {
              "name": "n",
              "type": "Sint32"
            }
          ],
          "sourceName": "SDL_rand"
        },
        "randf": {
          "doc": "Generate a uniform pseudo-random floating point number less than 1.0\n\nIf you want reproducible output, be sure to initialize with srand()\nfirst.\n\nThere are no guarantees as to the quality of the random sequence produced,\nand this should not be used for security (cryptography, passwords) or where\nmoney is on the line (loot-boxes, casinos). There are many random number\nlibraries available with different characteristics and you should pick one\nof those to meet any serious needs.\n\n@returns a random value in the range of [0.0, 1.0).\n\n@threadsafety All calls should be made from a single thread\n\n@since This function is available since SDL 3.2.0.\n\n@sa srand\n@sa rand",
          "name": "randf",
          "kind": "function",
          "type": "float",
          "parameters": [],
          "sourceName": "SDL_randf"
        },
        "rand_bits": {
          "doc": "Generate 32 pseudo-random bits.\n\nYou likely want to use rand() to get a psuedo-random number instead.\n\nThere are no guarantees as to the quality of the random sequence produced,\nand this should not be used for security (cryptography, passwords) or where\nmoney is on the line (loot-boxes, casinos). There are many random number\nlibraries available with different characteristics and you should pick one\nof those to meet any serious needs.\n\n@returns a random value in the range of [0-MAX_UINT32].\n\n@threadsafety All calls should be made from a single thread\n\n@since This function is available since SDL 3.2.0.\n\n@sa rand\n@sa randf\n@sa srand",
          "name": "rand_bits",
          "kind": "function",
          "type": "Uint32",
          "parameters": [],
          "sourceName": "SDL_rand_bits"
        },
        "Random": {
          "kind": "struct",
          "name": "Random",
          "entries": {
            "m_state": {
              "kind": "var",
              "type": "Uint64",
              "name": "m_state",
              "doc": ""
            },
            "Random": {
              "kind": "function",
              "constexpr": true,
              "type": "",
              "parameters": [
                {
                  "type": "Uint64",
                  "name": "state",
                  "default": "0"
                }
              ],
              "name": "Random",
              "doc": ""
            },
            "operator Uint64": {
              "kind": "function",
              "constexpr": true,
              "type": "",
              "parameters": [],
              "name": "operator Uint64",
              "doc": ""
            },
            "rand": {
              "doc": "Generate a pseudo-random number less than n for positive n\n\nThe method used is faster and of better quality than `rand() % n`. Odds are\nroughly 99.9% even for n = 1 million. Evenness is better for smaller n, and\nmuch worse as n gets bigger.\n\nExample: to simulate a d6 use `Random.rand(state, 6) + 1` The +1 converts\n0..5 to 1..6\n\nIf you want to generate a pseudo-random number in the full range of Sint32,\nyou should use: (Sint32)Random.rand_bits(state)\n\nThere are no guarantees as to the quality of the random sequence produced,\nand this should not be used for security (cryptography, passwords) or where\nmoney is on the line (loot-boxes, casinos). There are many random number\nlibraries available with different characteristics and you should pick one\nof those to meet any serious needs.\n\n@param state a pointer to the current random number state, this may not be\n             nullptr.\n@param n the number of possible outcomes. n must be positive.\n@returns a random value in the range of [0 .. n-1].\n\n@threadsafety This function is thread-safe, as long as the state pointer\n              isn't shared between threads.\n\n@since This function is available since SDL 3.2.0.\n\n@sa rand\n@sa Random.rand_bits\n@sa Random.randf",
              "name": "rand",
              "kind": "function",
              "type": "Sint32",
              "parameters": [
                {
                  "name": "n",
                  "type": "Sint32"
                }
              ],
              "sourceName": "SDL_rand_r",
              "static": false
            },
            "randf": {
              "doc": "Generate a uniform pseudo-random floating point number less than 1.0\n\nIf you want reproducible output, be sure to initialize with srand()\nfirst.\n\nThere are no guarantees as to the quality of the random sequence produced,\nand this should not be used for security (cryptography, passwords) or where\nmoney is on the line (loot-boxes, casinos). There are many random number\nlibraries available with different characteristics and you should pick one\nof those to meet any serious needs.\n\n@param state a pointer to the current random number state, this may not be\n             nullptr.\n@returns a random value in the range of [0.0, 1.0).\n\n@threadsafety This function is thread-safe, as long as the state pointer\n              isn't shared between threads.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Random.rand_bits\n@sa Random.rand\n@sa randf",
              "name": "randf",
              "kind": "function",
              "type": "float",
              "parameters": [],
              "sourceName": "SDL_randf_r",
              "static": false
            },
            "rand_bits": {
              "doc": "Generate 32 pseudo-random bits.\n\nYou likely want to use Random.rand() to get a psuedo-random number instead.\n\nThere are no guarantees as to the quality of the random sequence produced,\nand this should not be used for security (cryptography, passwords) or where\nmoney is on the line (loot-boxes, casinos). There are many random number\nlibraries available with different characteristics and you should pick one\nof those to meet any serious needs.\n\n@param state a pointer to the current random number state, this may not be\n             nullptr.\n@returns a random value in the range of [0-MAX_UINT32].\n\n@threadsafety This function is thread-safe, as long as the state pointer\n              isn't shared between threads.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Random.rand\n@sa Random.randf",
              "name": "rand_bits",
              "kind": "function",
              "type": "Uint32",
              "parameters": [],
              "sourceName": "SDL_rand_bits_r",
              "static": false
            }
          },
          "doc": ""
        },
        "SDL_PI_D": {
          "doc": "The value of Pi, as a double-precision floating point literal.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_PI_F",
          "name": "SDL_PI_D",
          "kind": "def",
          "value": "3.141592653589793238462643383279502884",
          "sourceName": "SDL_PI_D"
        },
        "SDL_PI_F": {
          "doc": "The value of Pi, as a single-precision floating point literal.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_PI_D",
          "name": "SDL_PI_F",
          "kind": "def",
          "value": "3.141592653589793238462643383279502884F",
          "sourceName": "SDL_PI_F"
        },
        "acos": {
          "doc": "Compute the arc cosine of `x`.\n\nThe definition of `y = acos(x)` is `x = cos(y)`.\n\nDomain: `-1 <= x <= 1`\n\nRange: `0 <= y <= Pi`\n\nThis function operates on double-precision floating point values, use\nacosf for single-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param x floating point value.\n@returns arc cosine of `x`, in radians.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa acosf\n@sa asin\n@sa cos",
          "name": "acos",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ],
          "sourceName": "SDL_acos"
        },
        "acosf": {
          "doc": "Compute the arc cosine of `x`.\n\nThe definition of `y = acos(x)` is `x = cos(y)`.\n\nDomain: `-1 <= x <= 1`\n\nRange: `0 <= y <= Pi`\n\nThis function operates on single-precision floating point values, use\nacos for double-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param x floating point value.\n@returns arc cosine of `x`, in radians.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa acos\n@sa asinf\n@sa cosf",
          "name": "acosf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ],
          "sourceName": "SDL_acosf"
        },
        "asin": {
          "doc": "Compute the arc sine of `x`.\n\nThe definition of `y = asin(x)` is `x = sin(y)`.\n\nDomain: `-1 <= x <= 1`\n\nRange: `-Pi/2 <= y <= Pi/2`\n\nThis function operates on double-precision floating point values, use\nasinf for single-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param x floating point value.\n@returns arc sine of `x`, in radians.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa asinf\n@sa acos\n@sa sin",
          "name": "asin",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ],
          "sourceName": "SDL_asin"
        },
        "asinf": {
          "doc": "Compute the arc sine of `x`.\n\nThe definition of `y = asin(x)` is `x = sin(y)`.\n\nDomain: `-1 <= x <= 1`\n\nRange: `-Pi/2 <= y <= Pi/2`\n\nThis function operates on single-precision floating point values, use\nasin for double-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param x floating point value.\n@returns arc sine of `x`, in radians.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa asin\n@sa acosf\n@sa sinf",
          "name": "asinf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ],
          "sourceName": "SDL_asinf"
        },
        "atan": {
          "doc": "Compute the arc tangent of `x`.\n\nThe definition of `y = atan(x)` is `x = tan(y)`.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-Pi/2 <= y <= Pi/2`\n\nThis function operates on double-precision floating point values, use\natanf for single-precision floats.\n\nTo calculate the arc tangent of y / x, use atan2.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param x floating point value.\n@returns arc tangent of of `x` in radians, or 0 if `x = 0`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa atanf\n@sa atan2\n@sa tan",
          "name": "atan",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ],
          "sourceName": "SDL_atan"
        },
        "atanf": {
          "doc": "Compute the arc tangent of `x`.\n\nThe definition of `y = atan(x)` is `x = tan(y)`.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-Pi/2 <= y <= Pi/2`\n\nThis function operates on single-precision floating point values, use\natan for dboule-precision floats.\n\nTo calculate the arc tangent of y / x, use atan2f.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param x floating point value.\n@returns arc tangent of of `x` in radians, or 0 if `x = 0`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa atan\n@sa atan2f\n@sa tanf",
          "name": "atanf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ],
          "sourceName": "SDL_atanf"
        },
        "atan2": {
          "doc": "Compute the arc tangent of `y / x`, using the signs of x and y to adjust\nthe result's quadrant.\n\nThe definition of `z = atan2(x, y)` is `y = x tan(z)`, where the quadrant\nof z is determined based on the signs of x and y.\n\nDomain: `-INF <= x <= INF`, `-INF <= y <= INF`\n\nRange: `-Pi/2 <= y <= Pi/2`\n\nThis function operates on double-precision floating point values, use\natan2f for single-precision floats.\n\nTo calculate the arc tangent of a single value, use atan.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param y floating point value of the numerator (y coordinate).\n@param x floating point value of the denominator (x coordinate).\n@returns arc tangent of of `y / x` in radians, or, if `x = 0`, either\n         `-Pi/2`, `0`, or `Pi/2`, depending on the value of `y`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa atan2f\n@sa atan\n@sa tan",
          "name": "atan2",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "y",
              "type": "double"
            },
            {
              "name": "x",
              "type": "double"
            }
          ],
          "sourceName": "SDL_atan2"
        },
        "atan2f": {
          "doc": "Compute the arc tangent of `y / x`, using the signs of x and y to adjust\nthe result's quadrant.\n\nThe definition of `z = atan2(x, y)` is `y = x tan(z)`, where the quadrant\nof z is determined based on the signs of x and y.\n\nDomain: `-INF <= x <= INF`, `-INF <= y <= INF`\n\nRange: `-Pi/2 <= y <= Pi/2`\n\nThis function operates on single-precision floating point values, use\natan2 for double-precision floats.\n\nTo calculate the arc tangent of a single value, use atanf.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param y floating point value of the numerator (y coordinate).\n@param x floating point value of the denominator (x coordinate).\n@returns arc tangent of of `y / x` in radians, or, if `x = 0`, either\n         `-Pi/2`, `0`, or `Pi/2`, depending on the value of `y`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa atan2\n@sa atan\n@sa tan",
          "name": "atan2f",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "y",
              "type": "float"
            },
            {
              "name": "x",
              "type": "float"
            }
          ],
          "sourceName": "SDL_atan2f"
        },
        "ceil": {
          "doc": "Compute the ceiling of `x`.\n\nThe ceiling of `x` is the smallest integer `y` such that `y > x`, i.e `x`\nrounded up to the nearest integer.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-INF <= y <= INF`, y integer\n\nThis function operates on double-precision floating point values, use\nceilf for single-precision floats.\n\n@param x floating point value.\n@returns the ceiling of `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa ceilf\n@sa floor\n@sa trunc\n@sa round\n@sa lround",
          "name": "ceil",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ],
          "sourceName": "SDL_ceil"
        },
        "ceilf": {
          "doc": "Compute the ceiling of `x`.\n\nThe ceiling of `x` is the smallest integer `y` such that `y > x`, i.e `x`\nrounded up to the nearest integer.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-INF <= y <= INF`, y integer\n\nThis function operates on single-precision floating point values, use\nceil for double-precision floats.\n\n@param x floating point value.\n@returns the ceiling of `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa ceil\n@sa floorf\n@sa truncf\n@sa roundf\n@sa lroundf",
          "name": "ceilf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ],
          "sourceName": "SDL_ceilf"
        },
        "copysign": {
          "doc": "Copy the sign of one floating-point value to another.\n\nThe definition of copysign is that ``copysign(x, y) = abs(x) * sign(y)``.\n\nDomain: `-INF <= x <= INF`, ``-INF <= y <= f``\n\nRange: `-INF <= z <= INF`\n\nThis function operates on double-precision floating point values, use\ncopysignf for single-precision floats.\n\n@param x floating point value to use as the magnitude.\n@param y floating point value to use as the sign.\n@returns the floating point value with the sign of y and the magnitude of\n         x.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa copysignf\n@sa fabs",
          "name": "copysign",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            },
            {
              "name": "y",
              "type": "double"
            }
          ],
          "sourceName": "SDL_copysign"
        },
        "copysignf": {
          "doc": "Copy the sign of one floating-point value to another.\n\nThe definition of copysign is that ``copysign(x, y) = abs(x) * sign(y)``.\n\nDomain: `-INF <= x <= INF`, ``-INF <= y <= f``\n\nRange: `-INF <= z <= INF`\n\nThis function operates on single-precision floating point values, use\ncopysign for double-precision floats.\n\n@param x floating point value to use as the magnitude.\n@param y floating point value to use as the sign.\n@returns the floating point value with the sign of y and the magnitude of\n         x.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa copysign\n@sa fabsf",
          "name": "copysignf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            },
            {
              "name": "y",
              "type": "float"
            }
          ],
          "sourceName": "SDL_copysignf"
        },
        "cos": {
          "doc": "Compute the cosine of `x`.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-1 <= y <= 1`\n\nThis function operates on double-precision floating point values, use\ncosf for single-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param x floating point value, in radians.\n@returns cosine of `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa cosf\n@sa acos\n@sa sin",
          "name": "cos",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ],
          "sourceName": "SDL_cos"
        },
        "cosf": {
          "doc": "Compute the cosine of `x`.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-1 <= y <= 1`\n\nThis function operates on single-precision floating point values, use\ncos for double-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param x floating point value, in radians.\n@returns cosine of `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa cos\n@sa acosf\n@sa sinf",
          "name": "cosf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ],
          "sourceName": "SDL_cosf"
        },
        "exp": {
          "doc": "Compute the exponential of `x`.\n\nThe definition of `y = exp(x)` is `y = e^x`, where `e` is the base of the\nnatural logarithm. The inverse is the natural logarithm, log.\n\nDomain: `-INF <= x <= INF`\n\nRange: `0 <= y <= INF`\n\nThe output will overflow if `exp(x)` is too large to be represented.\n\nThis function operates on double-precision floating point values, use\nexpf for single-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param x floating point value.\n@returns value of `e^x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa expf\n@sa log",
          "name": "exp",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ],
          "sourceName": "SDL_exp"
        },
        "expf": {
          "doc": "Compute the exponential of `x`.\n\nThe definition of `y = exp(x)` is `y = e^x`, where `e` is the base of the\nnatural logarithm. The inverse is the natural logarithm, logf.\n\nDomain: `-INF <= x <= INF`\n\nRange: `0 <= y <= INF`\n\nThe output will overflow if `exp(x)` is too large to be represented.\n\nThis function operates on single-precision floating point values, use\nexp for double-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param x floating point value.\n@returns value of `e^x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa exp\n@sa logf",
          "name": "expf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ],
          "sourceName": "SDL_expf"
        },
        "fabs": {
          "doc": "Compute the absolute value of `x`\n\nDomain: `-INF <= x <= INF`\n\nRange: `0 <= y <= INF`\n\nThis function operates on double-precision floating point values, use\nfabsf for single-precision floats.\n\n@param x floating point value to use as the magnitude.\n@returns the absolute value of `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa fabsf",
          "name": "fabs",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ],
          "sourceName": "SDL_fabs"
        },
        "fabsf": {
          "doc": "Compute the absolute value of `x`\n\nDomain: `-INF <= x <= INF`\n\nRange: `0 <= y <= INF`\n\nThis function operates on single-precision floating point values, use\nfabs for double-precision floats.\n\n@param x floating point value to use as the magnitude.\n@returns the absolute value of `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa fabs",
          "name": "fabsf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ],
          "sourceName": "SDL_fabsf"
        },
        "floor": {
          "doc": "Compute the floor of `x`.\n\nThe floor of `x` is the largest integer `y` such that `y > x`, i.e `x`\nrounded down to the nearest integer.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-INF <= y <= INF`, y integer\n\nThis function operates on double-precision floating point values, use\nfloorf for single-precision floats.\n\n@param x floating point value.\n@returns the floor of `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa floorf\n@sa ceil\n@sa trunc\n@sa round\n@sa lround",
          "name": "floor",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ],
          "sourceName": "SDL_floor"
        },
        "floorf": {
          "doc": "Compute the floor of `x`.\n\nThe floor of `x` is the largest integer `y` such that `y > x`, i.e `x`\nrounded down to the nearest integer.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-INF <= y <= INF`, y integer\n\nThis function operates on single-precision floating point values, use\nfloor for double-precision floats.\n\n@param x floating point value.\n@returns the floor of `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa floor\n@sa ceilf\n@sa truncf\n@sa roundf\n@sa lroundf",
          "name": "floorf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ],
          "sourceName": "SDL_floorf"
        },
        "trunc": {
          "doc": "Truncate `x` to an integer.\n\nRounds `x` to the next closest integer to 0. This is equivalent to removing\nthe fractional part of `x`, leaving only the integer part.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-INF <= y <= INF`, y integer\n\nThis function operates on double-precision floating point values, use\ntruncf for single-precision floats.\n\n@param x floating point value.\n@returns `x` truncated to an integer.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa truncf\n@sa fmod\n@sa ceil\n@sa floor\n@sa round\n@sa lround",
          "name": "trunc",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ],
          "sourceName": "SDL_trunc"
        },
        "truncf": {
          "doc": "Truncate `x` to an integer.\n\nRounds `x` to the next closest integer to 0. This is equivalent to removing\nthe fractional part of `x`, leaving only the integer part.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-INF <= y <= INF`, y integer\n\nThis function operates on single-precision floating point values, use\ntrunc for double-precision floats.\n\n@param x floating point value.\n@returns `x` truncated to an integer.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa trunc\n@sa fmodf\n@sa ceilf\n@sa floorf\n@sa roundf\n@sa lroundf",
          "name": "truncf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ],
          "sourceName": "SDL_truncf"
        },
        "fmod": {
          "doc": "Return the floating-point remainder of `x / y`\n\nDivides `x` by `y`, and returns the remainder.\n\nDomain: `-INF <= x <= INF`, `-INF <= y <= INF`, `y != 0`\n\nRange: `-y <= z <= y`\n\nThis function operates on double-precision floating point values, use\nfmodf for single-precision floats.\n\n@param x the numerator.\n@param y the denominator. Must not be 0.\n@returns the remainder of `x / y`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa fmodf\n@sa modf\n@sa trunc\n@sa ceil\n@sa floor\n@sa round\n@sa lround",
          "name": "fmod",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            },
            {
              "name": "y",
              "type": "double"
            }
          ],
          "sourceName": "SDL_fmod"
        },
        "fmodf": {
          "doc": "Return the floating-point remainder of `x / y`\n\nDivides `x` by `y`, and returns the remainder.\n\nDomain: `-INF <= x <= INF`, `-INF <= y <= INF`, `y != 0`\n\nRange: `-y <= z <= y`\n\nThis function operates on single-precision floating point values, use\nfmod for double-precision floats.\n\n@param x the numerator.\n@param y the denominator. Must not be 0.\n@returns the remainder of `x / y`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa fmod\n@sa truncf\n@sa modff\n@sa ceilf\n@sa floorf\n@sa roundf\n@sa lroundf",
          "name": "fmodf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            },
            {
              "name": "y",
              "type": "float"
            }
          ],
          "sourceName": "SDL_fmodf"
        },
        "isinf": {
          "doc": "Return whether the value is infinity.\n\n@param x double-precision floating point value.\n@returns non-zero if the value is infinity, 0 otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa isinff",
          "name": "isinf",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ],
          "sourceName": "SDL_isinf"
        },
        "isinff": {
          "doc": "Return whether the value is infinity.\n\n@param x floating point value.\n@returns non-zero if the value is infinity, 0 otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa isinf",
          "name": "isinff",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ],
          "sourceName": "SDL_isinff"
        },
        "isnan": {
          "doc": "Return whether the value is NaN.\n\n@param x double-precision floating point value.\n@returns non-zero if the value is NaN, 0 otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa isnanf",
          "name": "isnan",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ],
          "sourceName": "SDL_isnan"
        },
        "isnanf": {
          "doc": "Return whether the value is NaN.\n\n@param x floating point value.\n@returns non-zero if the value is NaN, 0 otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa isnan",
          "name": "isnanf",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ],
          "sourceName": "SDL_isnanf"
        },
        "log": {
          "doc": "Compute the natural logarithm of `x`.\n\nDomain: `0 < x <= INF`\n\nRange: `-INF <= y <= INF`\n\nIt is an error for `x` to be less than or equal to 0.\n\nThis function operates on double-precision floating point values, use\nlogf for single-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param x floating point value. Must be greater than 0.\n@returns the natural logarithm of `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa logf\n@sa log10\n@sa exp",
          "name": "log",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ],
          "sourceName": "SDL_log"
        },
        "logf": {
          "doc": "Compute the natural logarithm of `x`.\n\nDomain: `0 < x <= INF`\n\nRange: `-INF <= y <= INF`\n\nIt is an error for `x` to be less than or equal to 0.\n\nThis function operates on single-precision floating point values, use\nlog for double-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param x floating point value. Must be greater than 0.\n@returns the natural logarithm of `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa log\n@sa expf",
          "name": "logf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ],
          "sourceName": "SDL_logf"
        },
        "log10": {
          "doc": "Compute the base-10 logarithm of `x`.\n\nDomain: `0 < x <= INF`\n\nRange: `-INF <= y <= INF`\n\nIt is an error for `x` to be less than or equal to 0.\n\nThis function operates on double-precision floating point values, use\nlog10f for single-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param x floating point value. Must be greater than 0.\n@returns the logarithm of `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa log10f\n@sa log\n@sa pow",
          "name": "log10",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ],
          "sourceName": "SDL_log10"
        },
        "log10f": {
          "doc": "Compute the base-10 logarithm of `x`.\n\nDomain: `0 < x <= INF`\n\nRange: `-INF <= y <= INF`\n\nIt is an error for `x` to be less than or equal to 0.\n\nThis function operates on single-precision floating point values, use\nlog10 for double-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param x floating point value. Must be greater than 0.\n@returns the logarithm of `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa log10\n@sa logf\n@sa powf",
          "name": "log10f",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ],
          "sourceName": "SDL_log10f"
        },
        "modf": {
          "doc": "Split `x` into integer and fractional parts\n\nThis function operates on double-precision floating point values, use\nmodff for single-precision floats.\n\n@param x floating point value.\n@param y output pointer to store the integer part of `x`.\n@returns the fractional part of `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa modff\n@sa trunc\n@sa fmod",
          "name": "modf",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            },
            {
              "name": "y",
              "type": "double *"
            }
          ],
          "sourceName": "SDL_modf"
        },
        "modff": {
          "doc": "Split `x` into integer and fractional parts\n\nThis function operates on single-precision floating point values, use\nmodf for double-precision floats.\n\n@param x floating point value.\n@param y output pointer to store the integer part of `x`.\n@returns the fractional part of `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa modf\n@sa truncf\n@sa fmodf",
          "name": "modff",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            },
            {
              "name": "y",
              "type": "float *"
            }
          ],
          "sourceName": "SDL_modff"
        },
        "pow": {
          "doc": "Raise `x` to the power `y`\n\nDomain: `-INF <= x <= INF`, `-INF <= y <= INF`\n\nRange: `-INF <= z <= INF`\n\nIf `y` is the base of the natural logarithm (e), consider using exp\ninstead.\n\nThis function operates on double-precision floating point values, use\npowf for single-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param x the base.\n@param y the exponent.\n@returns `x` raised to the power `y`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa powf\n@sa exp\n@sa log",
          "name": "pow",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            },
            {
              "name": "y",
              "type": "double"
            }
          ],
          "sourceName": "SDL_pow"
        },
        "powf": {
          "doc": "Raise `x` to the power `y`\n\nDomain: `-INF <= x <= INF`, `-INF <= y <= INF`\n\nRange: `-INF <= z <= INF`\n\nIf `y` is the base of the natural logarithm (e), consider using exp\ninstead.\n\nThis function operates on single-precision floating point values, use\npow for double-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param x the base.\n@param y the exponent.\n@returns `x` raised to the power `y`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa pow\n@sa expf\n@sa logf",
          "name": "powf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            },
            {
              "name": "y",
              "type": "float"
            }
          ],
          "sourceName": "SDL_powf"
        },
        "round": {
          "doc": "Round `x` to the nearest integer.\n\nRounds `x` to the nearest integer. Values halfway between integers will be\nrounded away from zero.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-INF <= y <= INF`, y integer\n\nThis function operates on double-precision floating point values, use\nroundf for single-precision floats. To get the result as an integer\ntype, use lround.\n\n@param x floating point value.\n@returns the nearest integer to `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa roundf\n@sa lround\n@sa floor\n@sa ceil\n@sa trunc",
          "name": "round",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ],
          "sourceName": "SDL_round"
        },
        "roundf": {
          "doc": "Round `x` to the nearest integer.\n\nRounds `x` to the nearest integer. Values halfway between integers will be\nrounded away from zero.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-INF <= y <= INF`, y integer\n\nThis function operates on single-precision floating point values, use\nround for double-precision floats. To get the result as an integer\ntype, use lroundf.\n\n@param x floating point value.\n@returns the nearest integer to `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa round\n@sa lroundf\n@sa floorf\n@sa ceilf\n@sa truncf",
          "name": "roundf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ],
          "sourceName": "SDL_roundf"
        },
        "lround": {
          "doc": "Round `x` to the nearest integer representable as a long\n\nRounds `x` to the nearest integer. Values halfway between integers will be\nrounded away from zero.\n\nDomain: `-INF <= x <= INF`\n\nRange: `MIN_LONG <= y <= MAX_LONG`\n\nThis function operates on double-precision floating point values, use\nlroundf for single-precision floats. To get the result as a\nfloating-point type, use round.\n\n@param x floating point value.\n@returns the nearest integer to `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa lroundf\n@sa round\n@sa floor\n@sa ceil\n@sa trunc",
          "name": "lround",
          "kind": "function",
          "type": "long",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ],
          "sourceName": "SDL_lround"
        },
        "lroundf": {
          "doc": "Round `x` to the nearest integer representable as a long\n\nRounds `x` to the nearest integer. Values halfway between integers will be\nrounded away from zero.\n\nDomain: `-INF <= x <= INF`\n\nRange: `MIN_LONG <= y <= MAX_LONG`\n\nThis function operates on single-precision floating point values, use\nlround for double-precision floats. To get the result as a\nfloating-point type, use roundf.\n\n@param x floating point value.\n@returns the nearest integer to `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa lround\n@sa roundf\n@sa floorf\n@sa ceilf\n@sa truncf",
          "name": "lroundf",
          "kind": "function",
          "type": "long",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ],
          "sourceName": "SDL_lroundf"
        },
        "scalbn": {
          "doc": "Scale `x` by an integer power of two.\n\nMultiplies `x` by the `n`th power of the floating point radix (always 2).\n\nDomain: `-INF <= x <= INF`, `n` integer\n\nRange: `-INF <= y <= INF`\n\nThis function operates on double-precision floating point values, use\nscalbnf for single-precision floats.\n\n@param x floating point value to be scaled.\n@param n integer exponent.\n@returns `x * 2^n`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa scalbnf\n@sa pow",
          "name": "scalbn",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            },
            {
              "name": "n",
              "type": "int"
            }
          ],
          "sourceName": "SDL_scalbn"
        },
        "scalbnf": {
          "doc": "Scale `x` by an integer power of two.\n\nMultiplies `x` by the `n`th power of the floating point radix (always 2).\n\nDomain: `-INF <= x <= INF`, `n` integer\n\nRange: `-INF <= y <= INF`\n\nThis function operates on single-precision floating point values, use\nscalbn for double-precision floats.\n\n@param x floating point value to be scaled.\n@param n integer exponent.\n@returns `x * 2^n`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa scalbn\n@sa powf",
          "name": "scalbnf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            },
            {
              "name": "n",
              "type": "int"
            }
          ],
          "sourceName": "SDL_scalbnf"
        },
        "sin": {
          "doc": "Compute the sine of `x`.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-1 <= y <= 1`\n\nThis function operates on double-precision floating point values, use\nsinf for single-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param x floating point value, in radians.\n@returns sine of `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa sinf\n@sa asin\n@sa cos",
          "name": "sin",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ],
          "sourceName": "SDL_sin"
        },
        "sinf": {
          "doc": "Compute the sine of `x`.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-1 <= y <= 1`\n\nThis function operates on single-precision floating point values, use\nsin for double-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param x floating point value, in radians.\n@returns sine of `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa sin\n@sa asinf\n@sa cosf",
          "name": "sinf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ],
          "sourceName": "SDL_sinf"
        },
        "sqrt": {
          "doc": "Compute the square root of `x`.\n\nDomain: `0 <= x <= INF`\n\nRange: `0 <= y <= INF`\n\nThis function operates on double-precision floating point values, use\nsqrtf for single-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param x floating point value. Must be greater than or equal to 0.\n@returns square root of `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa sqrtf",
          "name": "sqrt",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ],
          "sourceName": "SDL_sqrt"
        },
        "sqrtf": {
          "doc": "Compute the square root of `x`.\n\nDomain: `0 <= x <= INF`\n\nRange: `0 <= y <= INF`\n\nThis function operates on single-precision floating point values, use\nsqrt for double-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param x floating point value. Must be greater than or equal to 0.\n@returns square root of `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa sqrt",
          "name": "sqrtf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ],
          "sourceName": "SDL_sqrtf"
        },
        "tan": {
          "doc": "Compute the tangent of `x`.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-INF <= y <= INF`\n\nThis function operates on double-precision floating point values, use\ntanf for single-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param x floating point value, in radians.\n@returns tangent of `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa tanf\n@sa sin\n@sa cos\n@sa atan\n@sa atan2",
          "name": "tan",
          "kind": "function",
          "type": "double",
          "parameters": [
            {
              "name": "x",
              "type": "double"
            }
          ],
          "sourceName": "SDL_tan"
        },
        "tanf": {
          "doc": "Compute the tangent of `x`.\n\nDomain: `-INF <= x <= INF`\n\nRange: `-INF <= y <= INF`\n\nThis function operates on single-precision floating point values, use\ntan for double-precision floats.\n\nThis function may use a different approximation across different versions,\nplatforms and configurations. i.e, it can return a different value given\nthe same input on different machines or operating systems, or if SDL is\nupdated.\n\n@param x floating point value, in radians.\n@returns tangent of `x`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa tan\n@sa sinf\n@sa cosf\n@sa atanf\n@sa atan2f",
          "name": "tanf",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ],
          "sourceName": "SDL_tanf"
        },
        "IConvBase": {
          "doc": "An opaque handle representing string encoding conversion state.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa IConvBase.IConvBase",
          "name": "IConvBase",
          "kind": "struct",
          "type": "T",
          "sourceName": "SDL_iconv_t",
          "template": [
            {
              "type": "ObjectBox<SDL_iconv_data_t *>",
              "name": "T"
            }
          ],
          "entries": {
            "T::T": {
              "kind": "alias",
              "name": "T::T",
              "doc": ""
            },
            "IConvBase": {
              "doc": "This function allocates a context for the specified character set\nconversion.\n\n@param tocode The target character encoding, must not be nullptr.\n@param fromcode The source character encoding, must not be nullptr.\n@post a handle that must be freed with IConvBase.close, or\n         SDL_ICONV_ERROR on failure.\n\n@since This function is available since SDL 3.2.0.\n\n@sa IConvBase.iconv\n@sa IConvBase.close\n@sa iconv_string",
              "name": "IConvBase",
              "kind": "function",
              "type": "",
              "parameters": [
                {
                  "name": "tocode",
                  "type": "StringParam"
                },
                {
                  "name": "fromcode",
                  "type": "StringParam"
                }
              ],
              "sourceName": "SDL_iconv_open"
            },
            "iconv": {
              "doc": "This function converts text between encodings, reading from and writing to\na buffer.\n\nIt returns the number of succesful conversions on success. On error,\nSDL_ICONV_E2BIG is returned when the output buffer is too small, or\nSDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,\nor SDL_ICONV_EINVAL is returned when an incomplete input sequence is\nencountered.\n\nOn exit:\n\n- inbuf will point to the beginning of the next multibyte sequence. On\n  error, this is the location of the problematic input sequence. On\n  success, this is the end of the input sequence.\n- inbytesleft will be set to the number of bytes left to convert, which\n  will be 0 on success.\n- outbuf will point to the location where to store the next output byte.\n- outbytesleft will be set to the number of bytes left in the output\n  buffer.\n\n          IConvBase.IConvBase().\n@param inbuf Address of variable that points to the first character of the\n             input sequence.\n@param inbytesleft The number of bytes in the input buffer.\n@param outbuf Address of variable that points to the output buffer.\n@param outbytesleft The number of bytes in the output buffer.\n@returns the number of conversions on success, or a negative error code.\n\n@since This function is available since SDL 3.2.0.\n\n@sa IConvBase.IConvBase\n@sa IConvBase.close\n@sa iconv_string",
              "name": "iconv",
              "kind": "function",
              "type": "size_t",
              "parameters": [
                {
                  "name": "inbuf",
                  "type": "const char **"
                },
                {
                  "name": "inbytesleft",
                  "type": "size_t *"
                },
                {
                  "name": "outbuf",
                  "type": "char **"
                },
                {
                  "name": "outbytesleft",
                  "type": "size_t *"
                }
              ],
              "sourceName": "SDL_iconv"
            },
            "close": {
              "doc": "This function frees a context used for character set conversion.\n\n@returns 0 on success, or -1 on failure.\n\n@since This function is available since SDL 3.2.0.\n\n@sa IConvBase.iconv\n@sa IConvBase.IConvBase\n@sa iconv_string",
              "name": "close",
              "kind": "function",
              "type": "int",
              "parameters": [],
              "sourceName": "SDL_iconv_close"
            }
          }
        },
        "ObjectRef<SDL_iconv_data_t>::doFree": {
          "name": "ObjectRef<SDL_iconv_data_t>::doFree",
          "type": "void",
          "kind": "function",
          "doc": "Callback for iConv resource cleanup\n\n@private",
          "template": [],
          "parameters": [
            {
              "type": "SDL_iconv_data_t *",
              "name": "resource"
            }
          ],
          "sourceName": "SDL_iconv_close"
        },
        "SDL_ICONV_ERROR": {
          "doc": "Generic error. Check GetError()?",
          "name": "SDL_ICONV_ERROR",
          "kind": "def",
          "value": "(size_t)-1",
          "sourceName": "SDL_ICONV_ERROR"
        },
        "SDL_ICONV_E2BIG": {
          "doc": "Output buffer was too small.",
          "name": "SDL_ICONV_E2BIG",
          "kind": "def",
          "value": "(size_t)-2",
          "sourceName": "SDL_ICONV_E2BIG"
        },
        "SDL_ICONV_EILSEQ": {
          "doc": "Invalid input sequence was encountered.",
          "name": "SDL_ICONV_EILSEQ",
          "kind": "def",
          "value": "(size_t)-3",
          "sourceName": "SDL_ICONV_EILSEQ"
        },
        "SDL_ICONV_EINVAL": {
          "doc": "Incomplete input sequence was encountered.",
          "name": "SDL_ICONV_EINVAL",
          "kind": "def",
          "value": "(size_t)-4",
          "sourceName": "SDL_ICONV_EINVAL"
        },
        "iconv_string": {
          "doc": "Helper function to convert a string's encoding in one call.\n\nThis function converts a buffer or string between encodings in one pass.\n\nThe string does not need to be nullptr-terminated; this function operates on\nthe number of bytes specified in `inbytesleft` whether there is a nullptr\ncharacter anywhere in the buffer.\n\nThe returned string is owned by the caller, and should be passed to\nfree when no longer needed.\n\n@param tocode the character encoding of the output string. Examples are\n              \"UTF-8\", \"UCS-4\", etc.\n@param fromcode the character encoding of data in `inbuf`.\n@param inbuf the string to convert to a different encoding.\n@param inbytesleft the size of the input string _in bytes_.\n@returns a new string, converted to the new encoding, or nullptr on error.\n\n@since This function is available since SDL 3.2.0.\n\n@sa IConvBase.IConvBase\n@sa IConvBase.close\n@sa IConvBase.iconv",
          "name": "iconv_string",
          "kind": "function",
          "type": "OwnPtr<char>",
          "parameters": [
            {
              "name": "tocode",
              "type": "StringParam"
            },
            {
              "name": "fromcode",
              "type": "StringParam"
            },
            {
              "name": "inbuf",
              "type": "StringParam"
            },
            {
              "name": "inbytesleft",
              "type": "size_t"
            }
          ],
          "sourceName": "SDL_iconv_string"
        },
        "SDL_iconv_utf8_locale": {
          "doc": "Convert a UTF-8 string to the current locale's character encoding.\n\nThis is a helper macro that might be more clear than calling\niconv_string directly. However, it double-evaluates its parameter, so\ndo not use an expression with side-effects here.\n\n@param S the string to convert.\n@returns a new string, converted to the new encoding, or nullptr on error.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_iconv_utf8_locale",
          "kind": "def",
          "parameters": [
            "S"
          ],
          "value": "SDL_iconv_string(\"\", \"UTF-8\", S, SDL_strlen(S)+1)",
          "sourceName": "SDL_iconv_utf8_locale"
        },
        "SDL_iconv_utf8_ucs2": {
          "doc": "Convert a UTF-8 string to UCS-2.\n\nThis is a helper macro that might be more clear than calling\niconv_string directly. However, it double-evaluates its parameter, so\ndo not use an expression with side-effects here.\n\n@param S the string to convert.\n@returns a new string, converted to the new encoding, or nullptr on error.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_iconv_utf8_ucs2",
          "kind": "def",
          "parameters": [
            "S"
          ],
          "value": "(Uint16 *)SDL_iconv_string(\"UCS-2\", \"UTF-8\", S, SDL_strlen(S)+1)",
          "sourceName": "SDL_iconv_utf8_ucs2"
        },
        "SDL_iconv_utf8_ucs4": {
          "doc": "Convert a UTF-8 string to UCS-4.\n\nThis is a helper macro that might be more clear than calling\niconv_string directly. However, it double-evaluates its parameter, so\ndo not use an expression with side-effects here.\n\n@param S the string to convert.\n@returns a new string, converted to the new encoding, or nullptr on error.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_iconv_utf8_ucs4",
          "kind": "def",
          "parameters": [
            "S"
          ],
          "value": "(Uint32 *)SDL_iconv_string(\"UCS-4\", \"UTF-8\", S, SDL_strlen(S)+1)",
          "sourceName": "SDL_iconv_utf8_ucs4"
        },
        "SDL_iconv_wchar_utf8": {
          "doc": "Convert a wchar_t string to UTF-8.\n\nThis is a helper macro that might be more clear than calling\niconv_string directly. However, it double-evaluates its parameter, so\ndo not use an expression with side-effects here.\n\n@param S the string to convert.\n@returns a new string, converted to the new encoding, or nullptr on error.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_iconv_wchar_utf8",
          "kind": "def",
          "parameters": [
            "S"
          ],
          "value": "SDL_iconv_string(\"UTF-8\", \"WCHAR_T\", (char *)S, (SDL_wcslen(S)+1)*sizeof(wchar_t))",
          "sourceName": "SDL_iconv_wchar_utf8"
        },
        "size_mul_check_overflow": {
          "doc": "Multiply two integers, checking for overflow.\n\nIf `a * b` would overflow, return false.\n\nOtherwise store `a * b` via ret and return true.\n\n@param a the multiplicand.\n@param b the multiplier.\n@param ret on non-overflow output, stores the multiplication result, may\n           not be nullptr.\n@returns false on overflow, true if result is multiplied without overflow.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "size_mul_check_overflow",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "a",
              "type": "size_t"
            },
            {
              "name": "b",
              "type": "size_t"
            },
            {
              "name": "ret",
              "type": "size_t *"
            }
          ],
          "sourceName": "SDL_size_mul_check_overflow"
        },
        "size_add_check_overflow": {
          "doc": "Add two integers, checking for overflow.\n\nIf `a + b` would overflow, return false.\n\nOtherwise store `a + b` via ret and return true.\n\n@param a the first addend.\n@param b the second addend.\n@param ret on non-overflow output, stores the addition result, may not be\n           nullptr.\n@returns false on overflow, true if result is added without overflow.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "size_add_check_overflow",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "a",
              "type": "size_t"
            },
            {
              "name": "b",
              "type": "size_t"
            },
            {
              "name": "ret",
              "type": "size_t *"
            }
          ],
          "sourceName": "SDL_size_add_check_overflow"
        },
        "FunctionPointer": {
          "doc": "A generic function pointer.\n\nIn theory, generic function pointers should use this, instead of `void *`,\nsince some platforms could treat code addresses differently than data\naddresses. Although in current times no popular platforms make this\ndistinction, it is more correct and portable to use the correct type for a\ngeneric pointer.\n\nIf for some reason you need to force this typedef to be an actual `void *`,\nperhaps to work around a compiler or existing code, you can define\n`SDL_FUNCTION_POINTER_IS_VOID_POINTER` before including any SDL headers.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "FunctionPointer",
          "kind": "alias",
          "type": "SDL_FunctionPointer",
          "sourceName": "SDL_FunctionPointer"
        }
      }
    },
    "SDL3pp_error.h": {
      "name": "SDL3pp_error.h",
      "doc": "@defgroup CategoryError Category Error\n\nSimple error message routines for SDL.\n\nMost apps will interface with these APIs in exactly one function: when\nalmost any SDL function call reports failure, you can get a human-readable\nstring of the problem from GetError().\n\nThese strings are maintained per-thread, and apps are welcome to set their\nown errors, which is popular when building libraries on top of SDL for\nother apps to consume. These strings are set by calling SetErrorUnformatted().\n\nA common usage pattern is to have a function that returns true for success\nand false for failure, and do this when something fails:\n\n```c\nif (something_went_wrong) {\n   return SetErrorUnformatted(\"The thing broke in this specific way: %d\", errcode);\n}\n```\n\nIt's also common to just return `false` in this case if the failing thing\nis known to call SetErrorUnformatted(), so errors simply propagate through.",
      "entries": {
        "SetErrorUnformatted": {
          "doc": "Set the SDL error message for the current thread.\n\nCalling this function will replace any previous error message that was set.\n\nThis function always returns false, since SDL frequently uses false to\nsignify a failing result, leading to this idiom:\n\n```c\nif (error_code) {\n    return SetErrorUnformatted(\"This operation has failed: %d\", error_code);\n}\n```\n\n@param fmt a printf()-style message format string.\n@param ... additional parameters matching % tokens in the `fmt` string, if\n           any.\n@returns false.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa ClearError\n@sa GetError\n@sa SDL_SetErrorV",
          "name": "SetErrorUnformatted",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "message",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_SetError"
        },
        "SetError": {
          "kind": "function",
          "name": "SetError",
          "type": "bool",
          "template": [
            {
              "type": "class...",
              "name": "ARGS"
            }
          ],
          "parameters": [
            {
              "type": "std::string_view",
              "name": "fmt"
            },
            {
              "type": "ARGS...",
              "name": "args"
            }
          ],
          "doc": ""
        },
        "OutOfMemory": {
          "doc": "Set an error indicating that memory allocation failed.\n\nThis function does not do any memory allocation.\n\n@returns false.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "OutOfMemory",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_OutOfMemory"
        },
        "GetError": {
          "doc": "Retrieve a message about the last error that occurred on the current\nthread.\n\nIt is possible for multiple errors to occur before calling GetError().\nOnly the last error is returned.\n\nThe message is only applicable when an SDL function has signaled an error.\nYou must check the return values of SDL function calls to determine when to\nappropriately call GetError(). You should *not* use the results of\nGetError() to decide if an error has occurred! Sometimes SDL will set\nan error string even when reporting success.\n\nSDL will *not* clear the error string for successful API calls. You *must*\ncheck return values for failure cases before you can assume the error\nstring applies.\n\nError strings are set per-thread, so an error set in a different thread\nwill not interfere with the current thread's operation.\n\nThe returned value is a thread-local string which will remain valid until\nthe current thread's error string is changed. The caller should make a copy\nif the value is needed after the next SDL API call.\n\n@returns a message with information about the specific error that occurred,\n         or an empty string if there hasn't been an error message set since\n         the last call to ClearError().\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa ClearError\n@sa SetErrorUnformatted",
          "name": "GetError",
          "kind": "function",
          "type": "const char *",
          "parameters": [],
          "sourceName": "SDL_GetError"
        },
        "ClearError": {
          "doc": "Clear any previous error message for this thread.\n\n@returns true.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetError\n@sa SetErrorUnformatted",
          "name": "ClearError",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_ClearError"
        },
        "SDL_Unsupported": {
          "doc": "A macro to standardize error reporting on unsupported operations.\n\nThis simply calls SetErrorUnformatted() with a standardized error string, for\nconvenience, consistency, and clarity.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_Unsupported",
          "kind": "def",
          "parameters": [],
          "value": "SDL_SetError(\"That operation is not supported\")",
          "sourceName": "SDL_Unsupported"
        },
        "SDL_InvalidParamError": {
          "doc": "A macro to standardize error reporting on unsupported operations.\n\nThis simply calls SetErrorUnformatted() with a standardized error string, for\nconvenience, consistency, and clarity.\n\nA common usage pattern inside SDL is this:\n\n```c\nbool MyFunction(const char *str) {\n    if (!str) {\n        return SDL_InvalidParamError(\"str\");  // returns false.\n    }\n    DoSomething(str);\n    return true;\n}\n```\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_InvalidParamError",
          "kind": "def",
          "parameters": [
            "param"
          ],
          "value": "SDL_SetError(\"Parameter '%s' is invalid\", (param))",
          "sourceName": "SDL_InvalidParamError"
        }
      }
    },
    "SDL3pp_assert.h": {
      "name": "SDL3pp_assert.h",
      "doc": "@defgroup CategoryAssert Category Assert\n\nA helpful assertion macro!\n\nSDL assertions operate like your usual `assert` macro, but with some added\nfeatures:\n\n- It uses a trick with the `sizeof` operator, so disabled assertions\n  vaporize out of the compiled code, but variables only referenced in the\n  assertion won't trigger compiler warnings about being unused.\n- It is safe to use with a dangling-else: `if (x) SDL_assert(y); else\n  do_something();`\n- It works the same everywhere, instead of counting on various platforms'\n  compiler and C runtime to behave.\n- It provides multiple levels of assertion (SDL_assert, SDL_assert_release,\n  SDL_assert_paranoid) instead of a single all-or-nothing option.\n- It offers a variety of responses when an assertion fails (retry, trigger\n  the debugger, abort the program, ignore the failure once, ignore it for\n  the rest of the program's run).\n- It tries to show the user a dialog by default, if possible, but the app\n  can provide a callback to handle assertion failures however they like.\n- It lets failed assertions be retried. Perhaps you had a network failure\n  and just want to retry the test after plugging your network cable back\n  in? You can.\n- It lets the user ignore an assertion failure, if there's a harmless\n  problem that one can continue past.\n- It lets the user mark an assertion as ignored for the rest of the\n  program's run; if there's a harmless problem that keeps popping up.\n- It provides statistics and data on all failed assertions to the app.\n- It allows the default assertion handler to be controlled with environment\n  variables, in case an automated script needs to control it.\n- It can be used as an aid to Clang's static analysis; it will treat SDL\n  assertions as universally true (under the assumption that you are serious\n  about the asserted claims and that your debug builds will detect when\n  these claims were wrong). This can help the analyzer avoid false\n  positives.\n\nTo use it: compile a debug build and just sprinkle around tests to check\nyour code!",
      "entries": {
        "SDL_ASSERT_LEVEL": {
          "doc": "The level of assertion aggressiveness.\n\nThis value changes depending on compiler options and other preprocessor\ndefines.\n\nIt is currently one of the following values, but future SDL releases might\nadd more:\n\n- 0: All SDL assertion macros are disabled.\n- 1: Release settings: SDL_assert disabled, SDL_assert_release enabled.\n- 2: Debug settings: SDL_assert and SDL_assert_release enabled.\n- 3: Paranoid settings: All SDL assertion macros enabled, including\n  SDL_assert_paranoid.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_ASSERT_LEVEL",
          "kind": "def",
          "value": "SomeNumberBasedOnVariousFactors",
          "sourceName": "SDL_ASSERT_LEVEL"
        },
        "SDL_TriggerBreakpoint": {
          "doc": "Attempt to tell an attached debugger to pause.\n\nThis allows an app to programmatically halt (\"break\") the debugger as if it\nhad hit a breakpoint, allowing the developer to examine program state, etc.\n\nThis is a macro--not a function--so that the debugger breaks on the source\ncode line that used SDL_TriggerBreakpoint and not in some random guts of\nSDL. SDL_assert uses this macro for the same reason.\n\nIf the program is not running under a debugger, SDL_TriggerBreakpoint will\nlikely terminate the app, possibly without warning. If the current platform\nisn't supported, this macro is left undefined.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_TriggerBreakpoint",
          "kind": "def",
          "parameters": [],
          "value": "TriggerABreakpointInAPlatformSpecificManner",
          "sourceName": "SDL_TriggerBreakpoint"
        },
        "SDL_FUNCTION": {
          "doc": "A macro that reports the current function being compiled.\n\nIf SDL can't figure how the compiler reports this, it will use \"???\".\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_FUNCTION",
          "kind": "def",
          "value": "__FUNCTION__",
          "sourceName": "SDL_FUNCTION"
        },
        "SDL_FILE": {
          "doc": "A macro that reports the current file being compiled.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_FILE",
          "kind": "def",
          "value": "__FILE__",
          "sourceName": "SDL_FILE"
        },
        "SDL_LINE": {
          "doc": "A macro that reports the current line number of the file being compiled.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_LINE",
          "kind": "def",
          "value": "__LINE__",
          "sourceName": "SDL_LINE"
        },
        "SDL_NULL_WHILE_LOOP_CONDITION": {
          "doc": "A macro for wrapping code in `do {} while (0);` without compiler warnings.\n\nVisual Studio with really aggressive warnings enabled needs this to avoid\ncompiler complaints.\n\nthe `do {} while (0);` trick is useful for wrapping code in a macro that\nmay or may not be a single statement, to avoid various C language\naccidents.\n\nTo use:\n\n```c\ndo { SomethingOnce(); } while (SDL_nullptr_WHILE_LOOP_CONDITION (0));\n```\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_NULL_WHILE_LOOP_CONDITION",
          "kind": "def",
          "value": "(0)",
          "sourceName": "SDL_NULL_WHILE_LOOP_CONDITION"
        },
        "SDL_disabled_assert": {
          "doc": "The macro used when an assertion is disabled.\n\nThis isn't for direct use by apps, but this is the code that is inserted\nwhen an SDL_assert is disabled (perhaps in a release build).\n\nThe code does nothing, but wraps `condition` in a sizeof operator, which\ngenerates no code and has no side effects, but avoid compiler warnings\nabout unused variables.\n\n@param condition the condition to assert (but not actually run here).\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_disabled_assert",
          "kind": "def",
          "parameters": [
            "condition"
          ],
          "value": "    do { (void) sizeof ((condition)); } while (SDL_NULL_WHILE_LOOP_CONDITION)",
          "sourceName": "SDL_disabled_assert"
        },
        "AssertState": {
          "doc": "Possible outcomes from a triggered assertion.\n\nWhen an enabled assertion triggers, it may call the assertion handler\n(possibly one provided by the app via SetAssertionHandler), which will\nreturn one of these values, possibly after asking the user.\n\nThen SDL will respond based on this outcome (loop around to retry the\ncondition, try to break in a debugger, kill the program, or ignore the\nproblem).\n\n@since This enum is available since SDL 3.2.0.",
          "name": "AssertState",
          "kind": "alias",
          "sourceName": "SDL_AssertState",
          "type": "SDL_AssertState"
        },
        "ASSERTION_RETRY": {
          "doc": "Retry the assert immediately.",
          "name": "ASSERTION_RETRY",
          "kind": "var",
          "type": "AssertState",
          "sourceName": "SDL_ASSERTION_RETRY",
          "constexpr": true
        },
        "ASSERTION_BREAK": {
          "doc": "Make the debugger trigger a breakpoint.",
          "name": "ASSERTION_BREAK",
          "kind": "var",
          "type": "AssertState",
          "sourceName": "SDL_ASSERTION_BREAK",
          "constexpr": true
        },
        "ASSERTION_ABORT": {
          "doc": "Terminate the program.",
          "name": "ASSERTION_ABORT",
          "kind": "var",
          "type": "AssertState",
          "sourceName": "SDL_ASSERTION_ABORT",
          "constexpr": true
        },
        "ASSERTION_IGNORE": {
          "doc": "Ignore the assert.",
          "name": "ASSERTION_IGNORE",
          "kind": "var",
          "type": "AssertState",
          "sourceName": "SDL_ASSERTION_IGNORE",
          "constexpr": true
        },
        "ASSERTION_ALWAYS_IGNORE": {
          "doc": "Ignore the assert from now on.",
          "name": "ASSERTION_ALWAYS_IGNORE",
          "kind": "var",
          "type": "AssertState",
          "sourceName": "SDL_ASSERTION_ALWAYS_IGNORE",
          "constexpr": true
        },
        "AssertData": {
          "doc": "Information about an assertion failure.\n\nThis structure is filled in with information about a triggered assertion,\nused by the assertion handler, then added to the assertion report. This is\nreturned as a linked list from GetAssertionReport().\n\n@since This struct is available since SDL 3.2.0.",
          "name": "AssertData",
          "kind": "alias",
          "sourceName": "SDL_AssertData",
          "type": "SDL_AssertData"
        },
        "ReportAssertion": {
          "doc": "Never call this directly.\n\nUse the SDL_assert macros instead.\n\n@param data assert data structure.\n@param func function name.\n@param file file name.\n@param line line number.\n@returns assert state.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "ReportAssertion",
          "kind": "function",
          "type": "AssertState",
          "parameters": [
            {
              "name": "data",
              "type": "AssertData *"
            },
            {
              "name": "func",
              "type": "StringParam"
            },
            {
              "name": "file",
              "type": "StringParam"
            },
            {
              "name": "line",
              "type": "int"
            }
          ],
          "sourceName": "SDL_ReportAssertion"
        },
        "SDL_AssertBreakpoint": {
          "doc": "The macro used when an assertion triggers a breakpoint.\n\nThis isn't for direct use by apps; use SDL_assert or SDL_TriggerBreakpoint\ninstead.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_AssertBreakpoint",
          "kind": "def",
          "parameters": [],
          "value": "SDL_TriggerBreakpoint()",
          "sourceName": "SDL_AssertBreakpoint"
        },
        "SDL_enabled_assert": {
          "doc": "The macro used when an assertion is enabled.\n\nThis isn't for direct use by apps, but this is the code that is inserted\nwhen an SDL_assert is enabled.\n\nThe `do {} while(0)` avoids dangling else problems:\n\n```c\nif (x) SDL_assert(y); else blah();\n```\n\n... without the do/while, the \"else\" could attach to this macro's \"if\". We\ntry to handle just the minimum we need here in a macro...the loop, the\nstatic vars, and break points. The heavy lifting is handled in\nReportAssertion().\n\n@param condition the condition to assert.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_enabled_assert",
          "kind": "def",
          "parameters": [
            "condition"
          ],
          "value": "[object Object]",
          "sourceName": "SDL_enabled_assert"
        },
        "SDL_assert": {
          "doc": "An assertion test that is normally performed only in debug builds.\n\nThis macro is enabled when the SDL_ASSERT_LEVEL is >= 2, otherwise it is\ndisabled. This is meant to only do these tests in debug builds, so they can\ntend to be more expensive, and they are meant to bring everything to a halt\nwhen they fail, with the programmer there to assess the problem.\n\nIn short: you can sprinkle these around liberally and assume they will\nevaporate out of the build when building for end-users.\n\nWhen assertions are disabled, this wraps `condition` in a `sizeof`\noperator, which means any function calls and side effects will not run, but\nthe compiler will not complain about any otherwise-unused variables that\nare only referenced in the assertion.\n\nOne can set the environment variable \"SDL_ASSERT\" to one of several strings\n(\"abort\", \"break\", \"retry\", \"ignore\", \"always_ignore\") to force a default\nbehavior, which may be desirable for automation purposes. If your platform\nrequires GUI interfaces to happen on the main thread but you're debugging\nan assertion in a background thread, it might be desirable to set this to\n\"break\" so that your debugger takes control as soon as assert is triggered,\ninstead of risking a bad UI interaction (deadlock, etc) in the application.\n\n@param condition boolean value to test.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_assert",
          "kind": "def",
          "parameters": [
            "condition"
          ],
          "value": "if (assertion_enabled && (condition)) { trigger_assertion; }",
          "sourceName": "SDL_assert"
        },
        "SDL_assert_release": {
          "doc": "An assertion test that is performed even in release builds.\n\nThis macro is enabled when the SDL_ASSERT_LEVEL is >= 1, otherwise it is\ndisabled. This is meant to be for tests that are cheap to make and\nextremely unlikely to fail; generally it is frowned upon to have an\nassertion failure in a release build, so these assertions generally need to\nbe of more than life-and-death importance if there's a chance they might\ntrigger. You should almost always consider handling these cases more\ngracefully than an assert allows.\n\nWhen assertions are disabled, this wraps `condition` in a `sizeof`\noperator, which means any function calls and side effects will not run, but\nthe compiler will not complain about any otherwise-unused variables that\nare only referenced in the assertion.\n\nOne can set the environment variable \"SDL_ASSERT\" to one of several strings\n(\"abort\", \"break\", \"retry\", \"ignore\", \"always_ignore\") to force a default\nbehavior, which may be desirable for automation purposes. If your platform\nrequires GUI interfaces to happen on the main thread but you're debugging\nan assertion in a background thread, it might be desirable to set this to\n\"break\" so that your debugger takes control as soon as assert is triggered,\ninstead of risking a bad UI interaction (deadlock, etc) in the application.\n*\n\n@param condition boolean value to test.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_assert_release",
          "kind": "def",
          "parameters": [
            "condition"
          ],
          "value": "SDL_disabled_assert(condition)",
          "sourceName": "SDL_assert_release"
        },
        "SDL_assert_paranoid": {
          "doc": "An assertion test that is performed only when built with paranoid settings.\n\nThis macro is enabled when the SDL_ASSERT_LEVEL is >= 3, otherwise it is\ndisabled. This is a higher level than both release and debug, so these\ntests are meant to be expensive and only run when specifically looking for\nextremely unexpected failure cases in a special build.\n\nWhen assertions are disabled, this wraps `condition` in a `sizeof`\noperator, which means any function calls and side effects will not run, but\nthe compiler will not complain about any otherwise-unused variables that\nare only referenced in the assertion.\n\nOne can set the environment variable \"SDL_ASSERT\" to one of several strings\n(\"abort\", \"break\", \"retry\", \"ignore\", \"always_ignore\") to force a default\nbehavior, which may be desirable for automation purposes. If your platform\nrequires GUI interfaces to happen on the main thread but you're debugging\nan assertion in a background thread, it might be desirable to set this to\n\"break\" so that your debugger takes control as soon as assert is triggered,\ninstead of risking a bad UI interaction (deadlock, etc) in the application.\n\n@param condition boolean value to test.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_assert_paranoid",
          "kind": "def",
          "parameters": [
            "condition"
          ],
          "value": "SDL_disabled_assert(condition)",
          "sourceName": "SDL_assert_paranoid"
        },
        "SDL_assert_always": {
          "doc": "An assertion test that is always performed.\n\nThis macro is always enabled no matter what SDL_ASSERT_LEVEL is set to. You\nalmost never want to use this, as it could trigger on an end-user's system,\ncrashing your program.\n\nOne can set the environment variable \"SDL_ASSERT\" to one of several strings\n(\"abort\", \"break\", \"retry\", \"ignore\", \"always_ignore\") to force a default\nbehavior, which may be desirable for automation purposes. If your platform\nrequires GUI interfaces to happen on the main thread but you're debugging\nan assertion in a background thread, it might be desirable to set this to\n\"break\" so that your debugger takes control as soon as assert is triggered,\ninstead of risking a bad UI interaction (deadlock, etc) in the application.\n\n@param condition boolean value to test.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_assert_always",
          "kind": "def",
          "parameters": [
            "condition"
          ],
          "value": "SDL_enabled_assert(condition)",
          "sourceName": "SDL_assert_always"
        },
        "AssertionHandler": {
          "doc": "A callback that fires when an SDL assertion fails.\n\n@param data a pointer to the AssertData structure corresponding to the\n            current assertion.\n@param userdata what was passed as `userdata` to SetAssertionHandler().\n@returns an AssertState value indicating how to handle the failure.\n\n@threadsafety This callback may be called from any thread that triggers an\n              assert at any time.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "AssertionHandler",
          "kind": "alias",
          "type": "SDL_AssertionHandler",
          "sourceName": "SDL_AssertionHandler"
        },
        "SetAssertionHandler": {
          "doc": "Set an application-defined assertion handler.\n\nThis function allows an application to show its own assertion UI and/or\nforce the response to an assertion failure. If the application doesn't\nprovide this, SDL will try to do the right thing, popping up a\nsystem-specific GUI dialog, and probably minimizing any fullscreen windows.\n\nThis callback may fire from any thread, but it runs wrapped in a mutex, so\nit will only fire from one thread at a time.\n\nThis callback is NOT reset to SDL's internal handler upon Quit()!\n\n@param handler the AssertionHandler function to call when an assertion\n               fails or nullptr for the default handler.\n@param userdata a pointer that is passed to `handler`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetAssertionHandler",
          "name": "SetAssertionHandler",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "handler",
              "type": "AssertionHandler"
            },
            {
              "name": "userdata",
              "type": "void *"
            }
          ],
          "sourceName": "SDL_SetAssertionHandler"
        },
        "GetDefaultAssertionHandler": {
          "doc": "Get the default assertion handler.\n\nThis returns the function pointer that is called by default when an\nassertion is triggered. This is an internal function provided by SDL, that\nis used for assertions when SetAssertionHandler() hasn't been used to\nprovide a different function.\n\n@returns the default AssertionHandler that is called when an assert\n         triggers.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetAssertionHandler",
          "name": "GetDefaultAssertionHandler",
          "kind": "function",
          "type": "AssertionHandler",
          "parameters": [],
          "sourceName": "SDL_GetDefaultAssertionHandler"
        },
        "GetAssertionHandler": {
          "doc": "Get the current assertion handler.\n\nThis returns the function pointer that is called when an assertion is\ntriggered. This is either the value last passed to\nSetAssertionHandler(), or if no application-specified function is set,\nis equivalent to calling GetDefaultAssertionHandler().\n\nThe parameter `puserdata` is a pointer to a void*, which will store the\n\"userdata\" pointer that was passed to SetAssertionHandler(). This value\nwill always be nullptr for the default handler. If you don't care about this\ndata, it is safe to pass a nullptr pointer to this function to ignore it.\n\n@param puserdata pointer which is filled with the \"userdata\" pointer that\n                 was passed to SetAssertionHandler().\n@returns the AssertionHandler that is called when an assert triggers.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SetAssertionHandler",
          "name": "GetAssertionHandler",
          "kind": "function",
          "type": "AssertionHandler",
          "parameters": [
            {
              "name": "puserdata",
              "type": "void **"
            }
          ],
          "sourceName": "SDL_GetAssertionHandler"
        },
        "GetAssertionReport": {
          "doc": "Get a list of all assertion failures.\n\nThis function gets all assertions triggered since the last call to\nResetAssertionReport(), or the start of the program.\n\nThe proper way to examine this data looks something like this:\n\n```c\nconst AssertData *item = GetAssertionReport();\nwhile (item) {\n   printf(\"'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\@n\",\n          item->condition, item->function, item->filename,\n          item->linenum, item->trigger_count,\n          item->always_ignore ? \"yes\" : \"no\");\n   item = item->next;\n}\n```\n\n@returns a list of all failed assertions or nullptr if the list is empty. This\n         memory should not be modified or freed by the application. This\n         pointer remains valid until the next call to Quit() or\n         ResetAssertionReport().\n\n@threadsafety This function is not thread safe. Other threads calling\n              ResetAssertionReport() simultaneously, may render the\n              returned pointer invalid.\n\n@since This function is available since SDL 3.2.0.\n\n@sa ResetAssertionReport",
          "name": "GetAssertionReport",
          "kind": "function",
          "type": "const AssertData *",
          "parameters": [],
          "sourceName": "SDL_GetAssertionReport"
        },
        "ResetAssertionReport": {
          "doc": "Clear the list of all assertion failures.\n\nThis function will clear the list of all assertions triggered up to that\npoint. Immediately following this call, GetAssertionReport will return\nno items. In addition, any previously-triggered assertions will be reset to\na trigger_count of zero, and their always_ignore state will be false.\n\n@threadsafety This function is not thread safe. Other threads triggering an\n              assertion, or simultaneously calling this function may cause\n              memory leaks or crashes.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetAssertionReport",
          "name": "ResetAssertionReport",
          "kind": "function",
          "type": "void",
          "parameters": [],
          "sourceName": "SDL_ResetAssertionReport"
        }
      }
    },
    "SDL3pp_log.h": {
      "name": "SDL3pp_log.h",
      "doc": "@defgroup CategoryLog Category Log\n\nSimple log messages with priorities and categories. A message's\nLogPriority signifies how important the message is. A message's\nLogCategory signifies from what domain it belongs to. Every category\nhas a minimum priority specified: when a message belongs to that category,\nit will only be sent out if it has that minimum priority or higher.\n\nSDL's own logs are sent below the default priority threshold, so they are\nquiet by default.\n\nYou can change the log verbosity programmatically using\nLogCategory.SetLogPriority() or with SetHint(SDL_HINT_LOGGING, ...), or with\nthe \"SDL_LOGGING\" environment variable. This variable is a comma separated\nset of category=level tokens that define the default logging levels for SDL\napplications.\n\nThe category can be a numeric category, one of \"app\", \"error\", \"assert\",\n\"system\", \"audio\", \"video\", \"render\", \"input\", \"test\", or `*` for any\nunspecified category.\n\nThe level can be a numeric level, one of \"trace\", \"verbose\", \"debug\",\n\"info\", \"warn\", \"error\", \"critical\", or \"quiet\" to disable that category.\n\nYou can omit the category if you want to set the logging level for all\ncategories.\n\nIf this hint isn't set, the default log levels are equivalent to:\n\n`app=info,assert=warn,test=verbose,*=error`\n\nHere's where the messages go on different platforms:\n\n- Windows: debug output stream\n- Android: log output\n- Others: standard error output (stderr)\n\nYou don't need to have a newline (`@n`) on the end of messages, the\nfunctions will do that for you. For consistent behavior cross-platform, you\nshouldn't have any newlines in messages, such as to log multiple lines in\none call; unusual platform-specific behavior can be observed in such usage.\nDo one log call per line instead, with no newlines in messages.\n\nEach log call is atomic, so you won't see log messages cut off one another\nwhen logging from multiple threads.",
      "entries": {
        "LogPriority": {
          "doc": "The predefined log priorities\n\n@since This enum is available since SDL 3.2.0.",
          "name": "LogPriority",
          "kind": "alias",
          "sourceName": "SDL_LogPriority",
          "type": "SDL_LogPriority"
        },
        "LogCategory": {
          "doc": "The predefined log categories\n\nBy default the application and gpu categories are enabled at the INFO\nlevel, the assert category is enabled at the WARN level, test is enabled at\nthe VERBOSE level and all other categories are enabled at the ERROR level.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "LogCategory",
          "kind": "struct",
          "sourceName": "SDL_LogCategory",
          "type": "",
          "entries": {
            "m_category": {
              "kind": "var",
              "type": "int",
              "name": "m_category",
              "doc": ""
            },
            "LogCategory": [
              {
                "kind": "function",
                "type": "",
                "explicit": true,
                "constexpr": true,
                "parameters": [
                  {
                    "type": "int",
                    "name": "category"
                  }
                ],
                "name": "LogCategory",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "SDL_LogCategory",
                    "name": "category"
                  }
                ],
                "name": "LogCategory",
                "doc": ""
              }
            ],
            "operator int": {
              "kind": "function",
              "type": "",
              "constexpr": true,
              "parameters": [],
              "name": "operator int",
              "doc": ""
            },
            "operator SDL_LogCategory": {
              "kind": "function",
              "type": "",
              "constexpr": true,
              "parameters": [],
              "name": "operator SDL_LogCategory",
              "doc": ""
            },
            "operator<=>": {
              "kind": "function",
              "immutable": true,
              "type": "auto",
              "parameters": [
                {
                  "type": "const LogCategory &",
                  "name": "other"
                }
              ],
              "name": "operator<=>",
              "doc": ""
            },
            "SetLogPriorities": {
              "doc": "Set the priority of all log categories.\n\n@param priority the LogPriority to assign.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa LogCategory.ResetLogPriorities\n@sa LogCategory.SetLogPriority",
              "name": "SetLogPriorities",
              "kind": "function",
              "type": "void",
              "parameters": [
                {
                  "name": "priority",
                  "type": "LogPriority"
                }
              ],
              "sourceName": "SDL_SetLogPriorities",
              "static": true
            },
            "SetLogPriority": {
              "doc": "Set the priority of a particular log category.\n\n@param category the category to assign a priority to.\n@param priority the LogPriority to assign.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa LogCategory.GetLogPriority\n@sa LogCategory.ResetLogPriorities\n@sa LogCategory.SetLogPriorities",
              "name": "SetLogPriority",
              "kind": "function",
              "type": "void",
              "parameters": [
                {
                  "name": "priority",
                  "type": "LogPriority"
                }
              ],
              "sourceName": "SDL_SetLogPriority",
              "static": false
            },
            "GetLogPriority": {
              "doc": "Get the priority of a particular log category.\n\n@param category the category to query.\n@returns the LogPriority for the requested category.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa LogCategory.SetLogPriority",
              "name": "GetLogPriority",
              "kind": "function",
              "type": "LogPriority",
              "parameters": [],
              "sourceName": "SDL_GetLogPriority",
              "immutable": true
            },
            "ResetLogPriorities": {
              "doc": "Reset all priorities to default.\n\nThis is called by Quit().\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa LogCategory.SetLogPriorities\n@sa LogCategory.SetLogPriority",
              "name": "ResetLogPriorities",
              "kind": "function",
              "type": "void",
              "parameters": [],
              "sourceName": "SDL_ResetLogPriorities",
              "static": true
            },
            "LogUnformatted": {
              "doc": "Log a message with the specified category and priority.\n\n@param category the category of the message.\n@param priority the priority of the message.\n@param fmt a printf() style message format string.\n@param ... additional parameters matching % tokens in the **fmt** string,\n           if any.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Log\n@sa LogCategory.LogCritical\n@sa LogCategory.LogDebug\n@sa LogCategory.LogError\n@sa LogCategory.LogInfo\n@sa LogUnformatted\n@sa LogCategory.LogTrace\n@sa LogCategory.LogVerbose\n@sa LogCategory.LogWarn",
              "name": "LogUnformatted",
              "kind": "function",
              "type": "void",
              "parameters": [
                {
                  "name": "priority",
                  "type": "LogPriority"
                },
                {
                  "name": "message",
                  "type": "StringParam"
                }
              ],
              "sourceName": "SDL_LogMessage",
              "immutable": true,
              "static": false
            },
            "Log": {
              "kind": "function",
              "type": "void",
              "immutable": true,
              "template": [
                {
                  "type": "class...",
                  "name": "ARGS"
                }
              ],
              "parameters": [
                {
                  "type": "LogPriority",
                  "name": "priority"
                },
                {
                  "type": "std::string_view",
                  "name": "fmt"
                },
                {
                  "type": "ARGS...",
                  "name": "args"
                }
              ],
              "name": "Log",
              "doc": ""
            },
            "LogTrace": {
              "doc": "Log a message with LOG_PRIORITY_TRACE.\n\n@param category the category of the message.\n@param fmt a printf() style message format string.\n@param ... additional parameters matching % tokens in the **fmt** string,\n           if any.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Log\n@sa LogCategory.LogCritical\n@sa LogCategory.LogDebug\n@sa LogCategory.LogError\n@sa LogCategory.LogInfo\n@sa LogCategory.LogUnformatted\n@sa LogUnformatted\n@sa LogCategory.LogTrace\n@sa LogCategory.LogVerbose\n@sa LogCategory.LogWarn",
              "name": "LogTrace",
              "kind": "function",
              "type": "void",
              "parameters": [
                {
                  "name": "fmt",
                  "type": "std::string_view"
                },
                {
                  "name": "args",
                  "type": "ARGS &&..."
                }
              ],
              "sourceName": "SDL_LogTrace",
              "immutable": true,
              "template": [
                {
                  "type": "class...",
                  "name": "ARGS"
                }
              ],
              "static": false
            },
            "LogVerbose": {
              "doc": "Log a message with LOG_PRIORITY_VERBOSE.\n\n@param category the category of the message.\n@param fmt a printf() style message format string.\n@param ... additional parameters matching % tokens in the **fmt** string,\n           if any.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Log\n@sa LogCategory.LogCritical\n@sa LogCategory.LogDebug\n@sa LogCategory.LogError\n@sa LogCategory.LogInfo\n@sa LogCategory.LogUnformatted\n@sa LogUnformatted\n@sa LogCategory.LogWarn",
              "name": "LogVerbose",
              "kind": "function",
              "type": "void",
              "parameters": [
                {
                  "name": "fmt",
                  "type": "std::string_view"
                },
                {
                  "name": "args",
                  "type": "ARGS &&..."
                }
              ],
              "sourceName": "SDL_LogVerbose",
              "immutable": true,
              "template": [
                {
                  "type": "class...",
                  "name": "ARGS"
                }
              ],
              "static": false
            },
            "LogDebug": {
              "doc": "Log a message with LOG_PRIORITY_DEBUG.\n\n@param category the category of the message.\n@param fmt a printf() style message format string.\n@param ... additional parameters matching % tokens in the **fmt** string,\n           if any.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Log\n@sa LogCategory.LogCritical\n@sa LogCategory.LogError\n@sa LogCategory.LogInfo\n@sa LogCategory.LogUnformatted\n@sa LogUnformatted\n@sa LogCategory.LogTrace\n@sa LogCategory.LogVerbose\n@sa LogCategory.LogWarn",
              "name": "LogDebug",
              "kind": "function",
              "type": "void",
              "parameters": [
                {
                  "name": "fmt",
                  "type": "std::string_view"
                },
                {
                  "name": "args",
                  "type": "ARGS &&..."
                }
              ],
              "sourceName": "SDL_LogDebug",
              "immutable": true,
              "template": [
                {
                  "type": "class...",
                  "name": "ARGS"
                }
              ],
              "static": false
            },
            "LogInfo": {
              "doc": "Log a message with LOG_PRIORITY_INFO.\n\n@param category the category of the message.\n@param fmt a printf() style message format string.\n@param ... additional parameters matching % tokens in the **fmt** string,\n           if any.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Log\n@sa LogCategory.LogCritical\n@sa LogCategory.LogDebug\n@sa LogCategory.LogError\n@sa LogCategory.LogUnformatted\n@sa LogUnformatted\n@sa LogCategory.LogTrace\n@sa LogCategory.LogVerbose\n@sa LogCategory.LogWarn",
              "name": "LogInfo",
              "kind": "function",
              "type": "void",
              "parameters": [
                {
                  "name": "fmt",
                  "type": "std::string_view"
                },
                {
                  "name": "args",
                  "type": "ARGS &&..."
                }
              ],
              "sourceName": "SDL_LogInfo",
              "immutable": true,
              "template": [
                {
                  "type": "class...",
                  "name": "ARGS"
                }
              ],
              "static": false
            },
            "LogWarn": {
              "doc": "Log a message with LOG_PRIORITY_WARN.\n\n@param category the category of the message.\n@param fmt a printf() style message format string.\n@param ... additional parameters matching % tokens in the **fmt** string,\n           if any.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Log\n@sa LogCategory.LogCritical\n@sa LogCategory.LogDebug\n@sa LogCategory.LogError\n@sa LogCategory.LogInfo\n@sa LogCategory.LogUnformatted\n@sa LogUnformatted\n@sa LogCategory.LogTrace\n@sa LogCategory.LogVerbose",
              "name": "LogWarn",
              "kind": "function",
              "type": "void",
              "parameters": [
                {
                  "name": "fmt",
                  "type": "std::string_view"
                },
                {
                  "name": "args",
                  "type": "ARGS &&..."
                }
              ],
              "sourceName": "SDL_LogWarn",
              "immutable": true,
              "template": [
                {
                  "type": "class...",
                  "name": "ARGS"
                }
              ],
              "static": false
            },
            "LogError": {
              "doc": "Log a message with LOG_PRIORITY_ERROR.\n\n@param category the category of the message.\n@param fmt a printf() style message format string.\n@param ... additional parameters matching % tokens in the **fmt** string,\n           if any.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Log\n@sa LogCategory.LogCritical\n@sa LogCategory.LogDebug\n@sa LogCategory.LogInfo\n@sa LogCategory.LogUnformatted\n@sa LogUnformatted\n@sa LogCategory.LogTrace\n@sa LogCategory.LogVerbose\n@sa LogCategory.LogWarn",
              "name": "LogError",
              "kind": "function",
              "type": "void",
              "parameters": [
                {
                  "name": "fmt",
                  "type": "std::string_view"
                },
                {
                  "name": "args",
                  "type": "ARGS &&..."
                }
              ],
              "sourceName": "SDL_LogError",
              "immutable": true,
              "template": [
                {
                  "type": "class...",
                  "name": "ARGS"
                }
              ],
              "static": false
            },
            "LogCritical": {
              "doc": "Log a message with LOG_PRIORITY_CRITICAL.\n\n@param category the category of the message.\n@param fmt a printf() style message format string.\n@param ... additional parameters matching % tokens in the **fmt** string,\n           if any.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Log\n@sa LogCategory.LogDebug\n@sa LogCategory.LogError\n@sa LogCategory.LogInfo\n@sa LogCategory.LogUnformatted\n@sa LogUnformatted\n@sa LogCategory.LogTrace\n@sa LogCategory.LogVerbose\n@sa LogCategory.LogWarn",
              "name": "LogCritical",
              "kind": "function",
              "type": "void",
              "parameters": [
                {
                  "name": "fmt",
                  "type": "std::string_view"
                },
                {
                  "name": "args",
                  "type": "ARGS &&..."
                }
              ],
              "sourceName": "SDL_LogCritical",
              "immutable": true,
              "template": [
                {
                  "type": "class...",
                  "name": "ARGS"
                }
              ],
              "static": false
            }
          }
        },
        "LOG_CATEGORY_APPLICATION": {
          "doc": "",
          "name": "LOG_CATEGORY_APPLICATION",
          "kind": "var",
          "type": "LogCategory",
          "sourceName": "SDL_LOG_CATEGORY_APPLICATION",
          "constexpr": true
        },
        "LOG_CATEGORY_ERROR": {
          "doc": "",
          "name": "LOG_CATEGORY_ERROR",
          "kind": "var",
          "type": "LogCategory",
          "sourceName": "SDL_LOG_CATEGORY_ERROR",
          "constexpr": true
        },
        "LOG_CATEGORY_ASSERT": {
          "doc": "",
          "name": "LOG_CATEGORY_ASSERT",
          "kind": "var",
          "type": "LogCategory",
          "sourceName": "SDL_LOG_CATEGORY_ASSERT",
          "constexpr": true
        },
        "LOG_CATEGORY_SYSTEM": {
          "doc": "",
          "name": "LOG_CATEGORY_SYSTEM",
          "kind": "var",
          "type": "LogCategory",
          "sourceName": "SDL_LOG_CATEGORY_SYSTEM",
          "constexpr": true
        },
        "LOG_CATEGORY_AUDIO": {
          "doc": "",
          "name": "LOG_CATEGORY_AUDIO",
          "kind": "var",
          "type": "LogCategory",
          "sourceName": "SDL_LOG_CATEGORY_AUDIO",
          "constexpr": true
        },
        "LOG_CATEGORY_VIDEO": {
          "doc": "",
          "name": "LOG_CATEGORY_VIDEO",
          "kind": "var",
          "type": "LogCategory",
          "sourceName": "SDL_LOG_CATEGORY_VIDEO",
          "constexpr": true
        },
        "LOG_CATEGORY_RENDER": {
          "doc": "",
          "name": "LOG_CATEGORY_RENDER",
          "kind": "var",
          "type": "LogCategory",
          "sourceName": "SDL_LOG_CATEGORY_RENDER",
          "constexpr": true
        },
        "LOG_CATEGORY_INPUT": {
          "doc": "",
          "name": "LOG_CATEGORY_INPUT",
          "kind": "var",
          "type": "LogCategory",
          "sourceName": "SDL_LOG_CATEGORY_INPUT",
          "constexpr": true
        },
        "LOG_CATEGORY_TEST": {
          "doc": "",
          "name": "LOG_CATEGORY_TEST",
          "kind": "var",
          "type": "LogCategory",
          "sourceName": "SDL_LOG_CATEGORY_TEST",
          "constexpr": true
        },
        "LOG_CATEGORY_GPU": {
          "doc": "",
          "name": "LOG_CATEGORY_GPU",
          "kind": "var",
          "type": "LogCategory",
          "sourceName": "SDL_LOG_CATEGORY_GPU",
          "constexpr": true
        },
        "LOG_CATEGORY_RESERVED2": {
          "doc": "",
          "name": "LOG_CATEGORY_RESERVED2",
          "kind": "var",
          "type": "LogCategory",
          "sourceName": "SDL_LOG_CATEGORY_RESERVED2",
          "constexpr": true
        },
        "LOG_CATEGORY_RESERVED3": {
          "doc": "",
          "name": "LOG_CATEGORY_RESERVED3",
          "kind": "var",
          "type": "LogCategory",
          "sourceName": "SDL_LOG_CATEGORY_RESERVED3",
          "constexpr": true
        },
        "LOG_CATEGORY_RESERVED4": {
          "doc": "",
          "name": "LOG_CATEGORY_RESERVED4",
          "kind": "var",
          "type": "LogCategory",
          "sourceName": "SDL_LOG_CATEGORY_RESERVED4",
          "constexpr": true
        },
        "LOG_CATEGORY_RESERVED5": {
          "doc": "",
          "name": "LOG_CATEGORY_RESERVED5",
          "kind": "var",
          "type": "LogCategory",
          "sourceName": "SDL_LOG_CATEGORY_RESERVED5",
          "constexpr": true
        },
        "LOG_CATEGORY_RESERVED6": {
          "doc": "",
          "name": "LOG_CATEGORY_RESERVED6",
          "kind": "var",
          "type": "LogCategory",
          "sourceName": "SDL_LOG_CATEGORY_RESERVED6",
          "constexpr": true
        },
        "LOG_CATEGORY_RESERVED7": {
          "doc": "",
          "name": "LOG_CATEGORY_RESERVED7",
          "kind": "var",
          "type": "LogCategory",
          "sourceName": "SDL_LOG_CATEGORY_RESERVED7",
          "constexpr": true
        },
        "LOG_CATEGORY_RESERVED8": {
          "doc": "",
          "name": "LOG_CATEGORY_RESERVED8",
          "kind": "var",
          "type": "LogCategory",
          "sourceName": "SDL_LOG_CATEGORY_RESERVED8",
          "constexpr": true
        },
        "LOG_CATEGORY_RESERVED9": {
          "doc": "",
          "name": "LOG_CATEGORY_RESERVED9",
          "kind": "var",
          "type": "LogCategory",
          "sourceName": "SDL_LOG_CATEGORY_RESERVED9",
          "constexpr": true
        },
        "LOG_CATEGORY_RESERVED10": {
          "doc": "",
          "name": "LOG_CATEGORY_RESERVED10",
          "kind": "var",
          "type": "LogCategory",
          "sourceName": "SDL_LOG_CATEGORY_RESERVED10",
          "constexpr": true
        },
        "LOG_CATEGORY_CUSTOM": {
          "doc": "",
          "name": "LOG_CATEGORY_CUSTOM",
          "kind": "var",
          "type": "LogCategory",
          "sourceName": "SDL_LOG_CATEGORY_CUSTOM",
          "constexpr": true
        },
        "LOG_PRIORITY_INVALID": {
          "doc": "",
          "name": "LOG_PRIORITY_INVALID",
          "kind": "var",
          "type": "LogPriority",
          "sourceName": "SDL_LOG_PRIORITY_INVALID",
          "constexpr": true
        },
        "LOG_PRIORITY_TRACE": {
          "doc": "",
          "name": "LOG_PRIORITY_TRACE",
          "kind": "var",
          "type": "LogPriority",
          "sourceName": "SDL_LOG_PRIORITY_TRACE",
          "constexpr": true
        },
        "LOG_PRIORITY_VERBOSE": {
          "doc": "",
          "name": "LOG_PRIORITY_VERBOSE",
          "kind": "var",
          "type": "LogPriority",
          "sourceName": "SDL_LOG_PRIORITY_VERBOSE",
          "constexpr": true
        },
        "LOG_PRIORITY_DEBUG": {
          "doc": "",
          "name": "LOG_PRIORITY_DEBUG",
          "kind": "var",
          "type": "LogPriority",
          "sourceName": "SDL_LOG_PRIORITY_DEBUG",
          "constexpr": true
        },
        "LOG_PRIORITY_INFO": {
          "doc": "",
          "name": "LOG_PRIORITY_INFO",
          "kind": "var",
          "type": "LogPriority",
          "sourceName": "SDL_LOG_PRIORITY_INFO",
          "constexpr": true
        },
        "LOG_PRIORITY_WARN": {
          "doc": "",
          "name": "LOG_PRIORITY_WARN",
          "kind": "var",
          "type": "LogPriority",
          "sourceName": "SDL_LOG_PRIORITY_WARN",
          "constexpr": true
        },
        "LOG_PRIORITY_ERROR": {
          "doc": "",
          "name": "LOG_PRIORITY_ERROR",
          "kind": "var",
          "type": "LogPriority",
          "sourceName": "SDL_LOG_PRIORITY_ERROR",
          "constexpr": true
        },
        "LOG_PRIORITY_CRITICAL": {
          "doc": "",
          "name": "LOG_PRIORITY_CRITICAL",
          "kind": "var",
          "type": "LogPriority",
          "sourceName": "SDL_LOG_PRIORITY_CRITICAL",
          "constexpr": true
        },
        "LOG_PRIORITY_COUNT": {
          "doc": "",
          "name": "LOG_PRIORITY_COUNT",
          "kind": "var",
          "type": "LogPriority",
          "sourceName": "SDL_LOG_PRIORITY_COUNT",
          "constexpr": true
        },
        "SetLogPriorityPrefix": {
          "doc": "Set the text prepended to log messages of a given priority.\n\nBy default LOG_PRIORITY_INFO and below have no prefix, and\nLOG_PRIORITY_WARN and higher have a prefix showing their priority, e.g.\n\"WARNING: \".\n\n@param priority the LogPriority to modify.\n@param prefix the prefix to use for that log priority, or nullptr to use no\n              prefix.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa LogCategory.SetLogPriorities\n@sa LogCategory.SetLogPriority",
          "name": "SetLogPriorityPrefix",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "priority",
              "type": "LogPriority"
            },
            {
              "name": "prefix",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_SetLogPriorityPrefix"
        },
        "Log": {
          "doc": "Log a message with LOG_CATEGORY_APPLICATION and LOG_PRIORITY_INFO.\n\n@param fmt a printf() style message format string.\n@param ... additional parameters matching % tokens in the `fmt` string, if\n           any.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa LogCategory.LogCritical\n@sa LogCategory.LogDebug\n@sa LogCategory.LogError\n@sa LogCategory.LogInfo\n@sa LogCategory.LogUnformatted\n@sa LogUnformatted\n@sa LogCategory.LogTrace\n@sa LogCategory.LogVerbose\n@sa LogCategory.LogWarn",
          "name": "Log",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "fmt",
              "type": "std::string_view"
            },
            {
              "type": "ARGS &&...",
              "name": "args"
            }
          ],
          "sourceName": "SDL_Log",
          "template": [
            {
              "type": "class...",
              "name": "ARGS"
            }
          ]
        },
        "LogUnformatted": {
          "doc": "Log a message with the specified category and priority.\n\n@param category the category of the message.\n@param priority the priority of the message.\n@param fmt a printf() style message format string.\n@param ap a variable argument list.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Log\n@sa LogCategory.LogCritical\n@sa LogCategory.LogDebug\n@sa LogCategory.LogError\n@sa LogCategory.LogInfo\n@sa LogCategory.LogUnformatted\n@sa LogCategory.LogTrace\n@sa LogCategory.LogVerbose\n@sa LogCategory.LogWarn",
          "name": "LogUnformatted",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "message",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_LogMessageV"
        },
        "LogOutputFunction": {
          "doc": "The prototype for the log output callback function.\n\nThis function is called by SDL when there is new text to be logged. A mutex\nis held so that this function is never called by more than one thread at\nonce.\n\n@param userdata what was passed as `userdata` to\n                SetLogOutputFunction().\n@param category the category of the message.\n@param priority the priority of the message.\n@param message the message being output.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "LogOutputFunction",
          "kind": "alias",
          "type": "SDL_LogOutputFunction",
          "sourceName": "SDL_LogOutputFunction"
        },
        "LogOutputFunctionCB": {
          "name": "LogOutputFunctionCB",
          "doc": "@sa LogOutputFunction",
          "kind": "alias"
        },
        "GetDefaultLogOutputFunction": {
          "doc": "Get the default log output function.\n\n@returns the default log output callback.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SetLogOutputFunction\n@sa GetLogOutputFunction",
          "name": "GetDefaultLogOutputFunction",
          "kind": "function",
          "type": "LogOutputFunction",
          "parameters": [],
          "sourceName": "SDL_GetDefaultLogOutputFunction"
        },
        "GetLogOutputFunction": [
          {
            "doc": "Get the current log output function.\n\n@param callback an LogOutputFunction filled in with the current log\n                callback.\n@param userdata a pointer filled in with the pointer that is passed to\n                `callback`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetDefaultLogOutputFunction\n@sa SetLogOutputFunction",
            "name": "GetLogOutputFunction",
            "kind": "function",
            "type": "void",
            "parameters": [
              {
                "name": "callback",
                "type": "LogOutputFunction *"
              },
              {
                "name": "userdata",
                "type": "void **"
              }
            ],
            "sourceName": "SDL_GetLogOutputFunction"
          },
          {
            "name": "GetLogOutputFunction",
            "kind": "function",
            "type": "LogOutputFunctionCB",
            "parameters": [],
            "doc": ""
          }
        ],
        "SetLogOutputFunction": [
          {
            "doc": "Replace the default log output function with one of your own.\n\n@param callback an LogOutputFunction to call instead of the default.\n@param userdata a pointer that is passed to `callback`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetDefaultLogOutputFunction\n@sa GetLogOutputFunction",
            "name": "SetLogOutputFunction",
            "kind": "function",
            "type": "void",
            "parameters": [
              {
                "name": "callback",
                "type": "LogOutputFunction"
              },
              {
                "name": "userdata",
                "type": "void *"
              }
            ],
            "sourceName": "SDL_SetLogOutputFunction"
          },
          {
            "name": "SetLogOutputFunction",
            "kind": "function",
            "type": "void",
            "parameters": [
              {
                "type": "LogOutputFunctionCB",
                "name": "callback"
              }
            ],
            "doc": ""
          }
        ],
        "ResetLogOutputFunction": {
          "name": "ResetLogOutputFunction",
          "kind": "function",
          "type": "void",
          "parameters": [],
          "doc": ""
        }
      }
    },
    "SDL3pp_misc.h": {
      "name": "SDL3pp_misc.h",
      "doc": "@defgroup CategoryMisc Category Misc\n\nSDL API functions that don't fit elsewhere.",
      "entries": {
        "OpenURL": {
          "doc": "Open a URL/URI in the browser or other appropriate external application.\n\nOpen a URL in a separate, system-provided application. How this works will\nvary wildly depending on the platform. This will likely launch what makes\nsense to handle a specific URL's protocol (a web browser for `http://`,\netc), but it might also be able to launch file managers for directories and\nother things.\n\nWhat happens when you open a URL varies wildly as well: your game window\nmay lose focus (and may or may not lose focus if your game was fullscreen\nor grabbing input at the time). On mobile devices, your app will likely\nmove to the background or your process might be paused. Any given platform\nmay or may not handle a given URL.\n\nIf this is unimplemented (or simply unavailable) for a platform, this will\nfail with an error. A successful result does not mean the URL loaded, just\nthat we launched _something_ to handle it (or at least believe we did).\n\nAll this to say: this function can be useful, but you should definitely\ntest it on every platform you target.\n\n@param url a valid URL/URI to open. Use `file:///full/path/to/file` for\n           local files, if supported.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@since This function is available since SDL 3.2.0.",
          "name": "OpenURL",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "url",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_OpenURL"
        }
      }
    },
    "SDL3pp_guid.h": {
      "name": "SDL3pp_guid.h",
      "doc": "@defgroup CategoryGUID Category GUID\n\nA GUID is a 128-bit value that represents something that is uniquely\nidentifiable by this value: \"globally unique.\"\n\nSDL provides functions to convert a GUID to/from a string.",
      "entries": {
        "GUID": {
          "doc": "An GUID is a 128-bit identifier for an input device that identifies\nthat device across runs of SDL programs on the same platform.\n\nIf the device is detached and then re-attached to a different port, or if\nthe base system is rebooted, the device should still report the same GUID.\n\nGUIDs are as precise as possible but are not guaranteed to distinguish\nphysically distinct but equivalent devices. For example, two game\ncontrollers from the same vendor with the same product ID and revision may\nhave the same GUID.\n\nGUIDs may be platform-dependent (i.e., the same device may report different\nGUIDs on different operating systems).\n\n@since This struct is available since SDL 3.2.0.",
          "name": "GUID",
          "kind": "struct",
          "sourceName": "SDL_GUID",
          "type": "SDL_GUID",
          "entries": {
            "GUID": [
              {
                "kind": "function",
                "constexpr": true,
                "type": "",
                "parameters": [],
                "name": "GUID",
                "doc": ""
              },
              {
                "kind": "function",
                "constexpr": true,
                "type": "",
                "parameters": [
                  {
                    "type": "SDL_GUID",
                    "name": "guid"
                  }
                ],
                "name": "GUID",
                "doc": ""
              },
              {
                "doc": "Convert a GUID string into a GUID structure.\n\nPerforms no error checking. If this function is given a string containing\nan invalid GUID, the function will silently succeed, but the GUID generated\nwill not be useful.\n\n@param pchGUID string containing an ASCII representation of a GUID.\n@post a GUID structure.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GUID.ToString",
                "name": "GUID",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "pchGUID",
                    "type": "StringParam"
                  }
                ],
                "sourceName": "SDL_StringToGUID"
              }
            ],
            "ToString": {
              "doc": "Get an ASCII string representation for a given GUID.\n\n@param guid the GUID you wish to convert to string.\n@param pszGUID buffer in which to write the ASCII string.\n@param cbGUID the size of pszGUID, should be at least 33 bytes.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GUID.GUID",
              "name": "ToString",
              "kind": "function",
              "type": "std::string",
              "parameters": [],
              "sourceName": "SDL_GUIDToString",
              "immutable": true
            }
          }
        }
      }
    },
    "SDL3pp_version.h": {
      "name": "SDL3pp_version.h",
      "doc": "@defgroup CategoryVersion Category Version\n\nFunctionality to query the current SDL version, both as headers the app was\ncompiled against, and a library the app is linked to.",
      "entries": {
        "SDL_MAJOR_VERSION": {
          "doc": "The current major version of SDL headers.\n\nIf this were SDL version 3.2.1, this value would be 3.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_MAJOR_VERSION",
          "kind": "def",
          "value": "3",
          "sourceName": "SDL_MAJOR_VERSION"
        },
        "SDL_MINOR_VERSION": {
          "doc": "The current minor version of the SDL headers.\n\nIf this were SDL version 3.2.1, this value would be 2.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_MINOR_VERSION",
          "kind": "def",
          "value": "2",
          "sourceName": "SDL_MINOR_VERSION"
        },
        "SDL_MICRO_VERSION": {
          "doc": "The current micro (or patchlevel) version of the SDL headers.\n\nIf this were SDL version 3.2.1, this value would be 1.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_MICRO_VERSION",
          "kind": "def",
          "value": "11",
          "sourceName": "SDL_MICRO_VERSION"
        },
        "SDL_VERSIONNUM": {
          "doc": "This macro turns the version numbers into a numeric value.\n\n(1,2,3) becomes 1002003.\n\n@param major the major version number.\n@param minor the minorversion number.\n@param patch the patch version number.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_VERSIONNUM",
          "kind": "def",
          "parameters": [
            "major",
            "minor",
            "patch"
          ],
          "value": "    ((major) * 1000000 + (minor) * 1000 + (patch))",
          "sourceName": "SDL_VERSIONNUM"
        },
        "SDL_VERSIONNUM_MAJOR": {
          "doc": "This macro extracts the major version from a version number\n\n1002003 becomes 1.\n\n@param version the version number.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_VERSIONNUM_MAJOR",
          "kind": "def",
          "parameters": [
            "version"
          ],
          "value": "((version) / 1000000)",
          "sourceName": "SDL_VERSIONNUM_MAJOR"
        },
        "SDL_VERSIONNUM_MINOR": {
          "doc": "This macro extracts the minor version from a version number\n\n1002003 becomes 2.\n\n@param version the version number.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_VERSIONNUM_MINOR",
          "kind": "def",
          "parameters": [
            "version"
          ],
          "value": "(((version) / 1000) % 1000)",
          "sourceName": "SDL_VERSIONNUM_MINOR"
        },
        "SDL_VERSIONNUM_MICRO": {
          "doc": "This macro extracts the micro version from a version number\n\n1002003 becomes 3.\n\n@param version the version number.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_VERSIONNUM_MICRO",
          "kind": "def",
          "parameters": [
            "version"
          ],
          "value": "((version) % 1000)",
          "sourceName": "SDL_VERSIONNUM_MICRO"
        },
        "SDL_VERSION": {
          "doc": "This is the version number macro for the current SDL version.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa GetVersion",
          "name": "SDL_VERSION",
          "kind": "def",
          "value": "    SDL_VERSIONNUM(SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_MICRO_VERSION)",
          "sourceName": "SDL_VERSION"
        },
        "SDL_VERSION_ATLEAST": {
          "doc": "This macro will evaluate to true if compiled with SDL at least X.Y.Z.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_VERSION_ATLEAST",
          "kind": "def",
          "parameters": [
            "X",
            "Y",
            "Z"
          ],
          "value": "    (SDL_VERSION >= SDL_VERSIONNUM(X, Y, Z))",
          "sourceName": "SDL_VERSION_ATLEAST"
        },
        "GetVersion": {
          "doc": "Get the version of SDL that is linked against your program.\n\nIf you are linking to SDL dynamically, then it is possible that the current\nversion will be different than the version you compiled against. This\nfunction returns the current version, while SDL_VERSION is the version you\ncompiled with.\n\nThis function may be called safely at any time, even before InitSubSystem().\n\n@returns the version of the linked library.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetRevision",
          "name": "GetVersion",
          "kind": "function",
          "type": "int",
          "parameters": [],
          "sourceName": "SDL_GetVersion"
        },
        "GetRevision": {
          "doc": "Get the code revision of SDL that is linked against your program.\n\nThis value is the revision of the code you are linked with and may be\ndifferent from the code you are compiling with, which is found in the\nconstant SDL_REVISION.\n\nThe revision is arbitrary string (a hash value) uniquely identifying the\nexact revision of the SDL library in use, and is only useful in comparing\nagainst other revisions. It is NOT an incrementing number.\n\nIf SDL wasn't built from a git repository with the appropriate tools, this\nwill return an empty string.\n\nYou shouldn't use this function for anything but logging it for debugging\npurposes. The string is not intended to be reliable in any way.\n\n@returns an arbitrary string, uniquely identifying the exact revision of\n         the SDL library in use.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetVersion",
          "name": "GetRevision",
          "kind": "function",
          "type": "const char *",
          "parameters": [],
          "sourceName": "SDL_GetRevision"
        }
      }
    },
    "SDL3pp_locale.h": {
      "name": "SDL3pp_locale.h",
      "doc": "@defgroup CategoryLocale Category Locale\n\nSDL locale services.\n\nThis provides a way to get a list of preferred locales (language plus\ncountry) for the user. There is exactly one function:\nGetPreferredLocales(), which handles all the heavy lifting, and offers\ndocumentation on all the strange ways humans might have configured their\nlanguage settings.",
      "entries": {
        "Locale": {
          "doc": "A struct to provide locale data.\n\nLocale data is split into a spoken language, like English, and an optional\ncountry, like Canada. The language will be in ISO-639 format (so English\nwould be \"en\"), and the country, if not nullptr, will be an ISO-3166 country\ncode (so Canada would be \"CA\").\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetPreferredLocales",
          "name": "Locale",
          "kind": "alias",
          "sourceName": "SDL_Locale",
          "type": "SDL_Locale"
        },
        "GetPreferredLocales": {
          "doc": "Report the user's preferred locale.\n\nReturned language strings are in the format xx, where 'xx' is an ISO-639\nlanguage specifier (such as \"en\" for English, \"de\" for German, etc).\nCountry strings are in the format YY, where \"YY\" is an ISO-3166 country\ncode (such as \"US\" for the United States, \"CA\" for Canada, etc). Country\nmight be nullptr if there's no specific guidance on them (so you might get {\n\"en\", \"US\" } for American English, but { \"en\", nullptr } means \"English\nlanguage, generically\"). Language strings are never nullptr, except to\nterminate the array.\n\nPlease note that not all of these strings are 2 characters; some are three\nor more.\n\nThe returned list of locales are in the order of the user's preference. For\nexample, a German citizen that is fluent in US English and knows enough\nJapanese to navigate around Tokyo might have a list like: { \"de\", \"en_US\",\n\"jp\", nullptr }. Someone from England might prefer British English (where\n\"color\" is spelled \"colour\", etc), but will settle for anything like it: {\n\"en_GB\", \"en\", nullptr }.\n\nThis function returns nullptr on error, including when the platform does not\nsupply this information at all.\n\nThis might be a \"slow\" call that has to query the operating system. It's\nbest to ask for this once and save the results. However, this list can\nchange, usually because the user has changed a system preference outside of\nyour program; SDL will send an EVENT_LOCALE_CHANGED event in this case,\nif possible, and you can call this function again to get an updated copy of\npreferred locales.\n\n@param count a pointer filled in with the number of locales returned, may\n             be nullptr.\n@returns a nullptr terminated array of locale pointers, or nullptr on failure;\n         call GetError() for more information. This is a single\n         allocation that should be freed with free() when it is no\n         longer needed.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetPreferredLocales",
          "kind": "function",
          "type": "OwnArray<Locale *>",
          "parameters": [],
          "sourceName": "SDL_GetPreferredLocales"
        }
      }
    },
    "SDL3pp_properties.h": {
      "name": "SDL3pp_properties.h",
      "doc": "@defgroup CategoryProperties Category Properties\n\nA property is a variable that can be created and retrieved by name at\nruntime.\n\nAll properties are part of a property group (PropertiesBase). A property\ngroup can be created with the CreateProperties function and destroyed\nwith the PropertiesBase.Destroy function.\n\nProperties can be added to and retrieved from a property group through the\nfollowing functions:\n\n- PropertiesBase.SetPointer and PropertiesBase.GetPointer operate on `void*`\n  pointer types.\n- PropertiesBase.SetString and PropertiesBase.GetString operate on string types.\n- PropertiesBase.SetNumber and PropertiesBase.GetNumber operate on signed 64-bit\n  integer types.\n- PropertiesBase.SetFloat and PropertiesBase.GetFloat operate on floating point\n  types.\n- PropertiesBase.SetBoolean and PropertiesBase.GetBoolean operate on boolean\n  types.\n\nProperties can be removed from a group by using PropertiesBase.Clear.",
      "entries": {
        "PropertiesBase-forward": {
          "name": "PropertiesBase",
          "kind": "forward",
          "template": [
            {
              "type": "ObjectBox<FancyPointer<SDL_PropertiesID>>",
              "name": "T"
            }
          ],
          "doc": ""
        },
        "PropertiesRef": {
          "name": "PropertiesRef",
          "kind": "alias",
          "type": "PropertiesBase<ObjectRef<SDL_PropertiesID, FancyPointer<SDL_PropertiesID>>>",
          "doc": "Handle to a non owned properties\n\n@cat resource\n\n@sa PropertiesBase\n@sa Properties"
        },
        "Properties": {
          "name": "Properties",
          "kind": "alias",
          "type": "PropertiesBase<ObjectUnique<SDL_PropertiesID, ObjectDeleter<ObjectRef<SDL_PropertiesID, FancyPointer<SDL_PropertiesID>>>>>",
          "doc": "Handle to an owned properties\n\n@cat resource\n\n@sa PropertiesBase\n@sa PropertiesRef"
        },
        "PropertyType": {
          "doc": "SDL property type\n\n@since This enum is available since SDL 3.2.0.",
          "name": "PropertyType",
          "kind": "alias",
          "sourceName": "SDL_PropertyType",
          "type": "SDL_PropertyType"
        },
        "CleanupPropertyCallback": {
          "doc": "A callback used to free resources when a property is deleted.\n\nThis should release any resources associated with `value` that are no\nlonger needed.\n\nThis callback is set per-property. Different properties in the same group\ncan have different cleanup callbacks.\n\nThis callback will be called _during_ PropertiesBase.SetPointerWithCleanup if\nthe function fails for any reason.\n\n@param userdata an app-defined pointer passed to the callback.\n@param value the pointer assigned to the property to clean up.\n\n@threadsafety This callback may fire without any locks held; if this is a\n              concern, the app should provide its own locking.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa PropertiesBase.SetPointerWithCleanup",
          "name": "CleanupPropertyCallback",
          "kind": "alias",
          "type": "SDL_CleanupPropertyCallback",
          "sourceName": "SDL_CleanupPropertyCallback"
        },
        "CleanupPropertyCB": {
          "name": "CleanupPropertyCB",
          "doc": "@sa PropertiesRef.CleanupCallback",
          "kind": "alias"
        },
        "EnumeratePropertiesCallback": {
          "doc": "A callback used to enumerate all the properties in a group of properties.\n\nThis callback is called from PropertiesBase.Enumerate(), and is called once\nper property in the set.\n\n@param userdata an app-defined pointer passed to the callback.\n@param props the PropertiesBase that is being enumerated.\n@param name the next property name in the enumeration.\n\n@threadsafety PropertiesBase.Enumerate holds a lock on `props` during this\n              callback.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa PropertiesBase.Enumerate",
          "name": "EnumeratePropertiesCallback",
          "kind": "alias",
          "type": "SDL_EnumeratePropertiesCallback",
          "sourceName": "SDL_EnumeratePropertiesCallback"
        },
        "EnumeratePropertiesCB": {
          "name": "EnumeratePropertiesCB",
          "doc": "@sa PropertiesRef.EnumerateCallback",
          "kind": "alias"
        },
        "PropertiesLock-forward": {
          "name": "PropertiesLock",
          "kind": "forward",
          "doc": ""
        },
        "PropertiesBase": {
          "doc": "SDL properties ID\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "PropertiesBase",
          "kind": "struct",
          "type": "T",
          "sourceName": "SDL_PropertiesID",
          "template": [
            {
              "type": "ObjectBox<FancyPointer<SDL_PropertiesID>>",
              "name": "T"
            }
          ],
          "entries": {
            "T::T": {
              "kind": "alias",
              "name": "T::T",
              "doc": ""
            },
            "CopyPropertiesTo": {
              "doc": "Copy a group of properties.\n\nCopy all the properties from one group of properties to another, with the\nexception of properties requiring cleanup (set using\nPropertiesBase.SetPointerWithCleanup()), which will not be copied. Any\nproperty that already exists on `dst` will be overwritten.\n\n@param dst the destination properties.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "CopyPropertiesTo",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "dst",
                  "type": "PropertiesRef"
                }
              ],
              "sourceName": "SDL_CopyProperties",
              "immutable": true
            },
            "Lock": {
              "doc": "Lock a group of properties.\n\nObtain a multi-threaded lock for these properties. Other threads will wait\nwhile trying to lock these properties until they are unlocked. Properties\nmust be unlocked before they are destroyed.\n\nThe lock is automatically taken when setting individual properties, this\nfunction is only needed when you want to set several properties atomically\nor want to guarantee that properties being queried aren't freed in another\nthread.\n\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PropertiesLock.Unlock",
              "name": "Lock",
              "kind": "function",
              "type": "PropertiesLock",
              "parameters": [],
              "sourceName": "SDL_LockProperties",
              "reference": 1
            },
            "SetPointerWithCleanup": [
              {
                "kind": "function",
                "static": false,
                "type": "bool",
                "parameters": [
                  {
                    "type": "StringParam",
                    "name": "name"
                  },
                  {
                    "type": "void *",
                    "name": "value"
                  },
                  {
                    "type": "CleanupPropertyCB",
                    "name": "cleanup"
                  }
                ],
                "name": "SetPointerWithCleanup",
                "doc": ""
              },
              {
                "doc": "Set a pointer property in a group of properties with a cleanup function\nthat is called when the property is deleted.\n\nThe cleanup function is also called if setting the property fails for any\nreason.\n\nFor simply setting basic data types, like numbers, bools, or strings, use\nPropertiesBase.SetNumber, PropertiesBase.SetBoolean, or PropertiesBase.SetString\ninstead, as those functions will handle cleanup on your behalf. This\nfunction is only for more complex, custom data.\n\n@param name the name of the property to modify.\n@param value the new value of the property, or nullptr to delete the property.\n@param cleanup the function to call when this property is deleted, or nullptr\n               if no cleanup is necessary.\n@param userdata a pointer that is passed to the cleanup function.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PropertiesBase.GetPointer\n@sa PropertiesBase.SetPointer\n@sa CleanupPropertyCallback",
                "name": "SetPointerWithCleanup",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "name",
                    "type": "StringParam"
                  },
                  {
                    "name": "value",
                    "type": "void *"
                  },
                  {
                    "name": "cleanup",
                    "type": "CleanupPropertyCallback"
                  },
                  {
                    "name": "userdata",
                    "type": "void *"
                  }
                ],
                "sourceName": "SDL_SetPointerPropertyWithCleanup"
              }
            ],
            "SetPointer": {
              "doc": "Set a pointer property in a group of properties.\n\n@param name the name of the property to modify.\n@param value the new value of the property, or nullptr to delete the property.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PropertiesBase.GetPointer\n@sa PropertiesBase.Has\n@sa PropertiesBase.SetBoolean\n@sa PropertiesBase.SetFloat\n@sa PropertiesBase.SetNumber\n@sa PropertiesBase.SetPointerWithCleanup\n@sa PropertiesBase.SetString",
              "name": "SetPointer",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "name",
                  "type": "StringParam"
                },
                {
                  "name": "value",
                  "type": "void *"
                }
              ],
              "sourceName": "SDL_SetPointerProperty"
            },
            "SetString": {
              "doc": "Set a string property in a group of properties.\n\nThis function makes a copy of the string; the caller does not have to\npreserve the data after this call completes.\n\n@param name the name of the property to modify.\n@param value the new value of the property, or nullptr to delete the property.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PropertiesBase.GetString",
              "name": "SetString",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "name",
                  "type": "StringParam"
                },
                {
                  "name": "value",
                  "type": "StringParam"
                }
              ],
              "sourceName": "SDL_SetStringProperty"
            },
            "SetNumber": {
              "doc": "Set an integer property in a group of properties.\n\n@param name the name of the property to modify.\n@param value the new value of the property.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PropertiesBase.GetNumber",
              "name": "SetNumber",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "name",
                  "type": "StringParam"
                },
                {
                  "name": "value",
                  "type": "Sint64"
                }
              ],
              "sourceName": "SDL_SetNumberProperty"
            },
            "SetFloat": {
              "doc": "Set a floating point property in a group of properties.\n\n@param name the name of the property to modify.\n@param value the new value of the property.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PropertiesBase.GetFloat",
              "name": "SetFloat",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "name",
                  "type": "StringParam"
                },
                {
                  "name": "value",
                  "type": "float"
                }
              ],
              "sourceName": "SDL_SetFloatProperty"
            },
            "SetBoolean": {
              "doc": "Set a boolean property in a group of properties.\n\n@param name the name of the property to modify.\n@param value the new value of the property.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PropertiesBase.GetBoolean",
              "name": "SetBoolean",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "name",
                  "type": "StringParam"
                },
                {
                  "name": "value",
                  "type": "bool"
                }
              ],
              "sourceName": "SDL_SetBooleanProperty"
            },
            "Has": {
              "doc": "Return whether a property exists in a group of properties.\n\n@param name the name of the property to query.\n@returns true if the property exists, or false if it doesn't.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PropertiesBase.GetType",
              "name": "Has",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "name",
                  "type": "StringParam"
                }
              ],
              "sourceName": "SDL_HasProperty",
              "immutable": true
            },
            "GetType": {
              "doc": "Get the type of a property in a group of properties.\n\n@param name the name of the property to query.\n@returns the type of the property, or PROPERTY_TYPE_INVALID if it is\n         not set.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PropertiesBase.Has",
              "name": "GetType",
              "kind": "function",
              "type": "PropertyType",
              "parameters": [
                {
                  "name": "name",
                  "type": "StringParam"
                }
              ],
              "sourceName": "SDL_GetPropertyType",
              "immutable": true
            },
            "GetPointer": {
              "doc": "Get a pointer property from a group of properties.\n\nBy convention, the names of properties that SDL exposes on objects will\nstart with \"SDL.\", and properties that SDL uses internally will start with\n\"SDL.internal.\". These should be considered read-only and should not be\nmodified by applications.\n\n@param name the name of the property to query.\n@param default_value the default value of the property.\n@returns the value of the property, or `default_value` if it is not set or\n         not a pointer property.\n\n@threadsafety It is safe to call this function from any thread, although\n              the data returned is not protected and could potentially be\n              freed if you call PropertiesBase.SetPointer() or\n              PropertiesBase.Clear() on these properties from another thread.\n              If you need to avoid this, use PropertiesBase.Lock() and\n              PropertiesLock.Unlock().\n\n@since This function is available since SDL 3.2.0.\n\n@sa PropertiesBase.GetBoolean\n@sa PropertiesBase.GetFloat\n@sa PropertiesBase.GetNumber\n@sa PropertiesBase.GetType\n@sa PropertiesBase.GetString\n@sa PropertiesBase.Has\n@sa PropertiesBase.SetPointer",
              "name": "GetPointer",
              "kind": "function",
              "type": "void *",
              "parameters": [
                {
                  "name": "name",
                  "type": "StringParam"
                },
                {
                  "name": "default_value",
                  "type": "void *"
                }
              ],
              "sourceName": "SDL_GetPointerProperty",
              "immutable": true
            },
            "GetString": {
              "doc": "Get a string property from a group of properties.\n\n@param name the name of the property to query.\n@param default_value the default value of the property.\n@returns the value of the property, or `default_value` if it is not set or\n         not a string property.\n\n@threadsafety It is safe to call this function from any thread, although\n              the data returned is not protected and could potentially be\n              freed if you call PropertiesBase.SetString() or\n              PropertiesBase.Clear() on these properties from another thread.\n              If you need to avoid this, use PropertiesBase.Lock() and\n              PropertiesLock.Unlock().\n\n@since This function is available since SDL 3.2.0.\n\n@sa PropertiesBase.GetType\n@sa PropertiesBase.Has\n@sa PropertiesBase.SetString",
              "name": "GetString",
              "kind": "function",
              "type": "const char *",
              "parameters": [
                {
                  "name": "name",
                  "type": "StringParam"
                },
                {
                  "name": "default_value",
                  "type": "StringParam"
                }
              ],
              "sourceName": "SDL_GetStringProperty",
              "immutable": true
            },
            "GetNumber": {
              "doc": "Get a number property from a group of properties.\n\nYou can use PropertiesBase.GetType() to query whether the property exists and\nis a number property.\n\n@param name the name of the property to query.\n@param default_value the default value of the property.\n@returns the value of the property, or `default_value` if it is not set or\n         not a number property.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PropertiesBase.GetType\n@sa PropertiesBase.Has\n@sa PropertiesBase.SetNumber",
              "name": "GetNumber",
              "kind": "function",
              "type": "Sint64",
              "parameters": [
                {
                  "name": "name",
                  "type": "StringParam"
                },
                {
                  "name": "default_value",
                  "type": "Sint64"
                }
              ],
              "sourceName": "SDL_GetNumberProperty",
              "immutable": true
            },
            "GetFloat": {
              "doc": "Get a floating point property from a group of properties.\n\nYou can use PropertiesBase.GetType() to query whether the property exists and\nis a floating point property.\n\n@param name the name of the property to query.\n@param default_value the default value of the property.\n@returns the value of the property, or `default_value` if it is not set or\n         not a float property.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PropertiesBase.GetType\n@sa PropertiesBase.Has\n@sa PropertiesBase.SetFloat",
              "name": "GetFloat",
              "kind": "function",
              "type": "float",
              "parameters": [
                {
                  "name": "name",
                  "type": "StringParam"
                },
                {
                  "name": "default_value",
                  "type": "float"
                }
              ],
              "sourceName": "SDL_GetFloatProperty",
              "immutable": true
            },
            "GetBoolean": {
              "doc": "Get a boolean property from a group of properties.\n\nYou can use PropertiesBase.GetType() to query whether the property exists and\nis a boolean property.\n\n@param name the name of the property to query.\n@param default_value the default value of the property.\n@returns the value of the property, or `default_value` if it is not set or\n         not a boolean property.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PropertiesBase.GetType\n@sa PropertiesBase.Has\n@sa PropertiesBase.SetBoolean",
              "name": "GetBoolean",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "name",
                  "type": "StringParam"
                },
                {
                  "name": "default_value",
                  "type": "bool"
                }
              ],
              "sourceName": "SDL_GetBooleanProperty",
              "immutable": true
            },
            "Clear": {
              "doc": "Clear a property from a group of properties.\n\n@param name the name of the property to clear.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "Clear",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "name",
                  "type": "StringParam"
                }
              ],
              "sourceName": "SDL_ClearProperty"
            },
            "Enumerate": [
              {
                "kind": "function",
                "type": "bool",
                "immutable": true,
                "template": [
                  {
                    "type": "std::output_iterator<const char *>",
                    "name": "IT"
                  }
                ],
                "parameters": [
                  {
                    "type": "IT",
                    "name": "outputIter"
                  }
                ],
                "name": "Enumerate",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "bool",
                "immutable": true,
                "parameters": [
                  {
                    "type": "EnumeratePropertiesCB",
                    "name": "callback"
                  }
                ],
                "name": "Enumerate",
                "doc": ""
              },
              {
                "doc": "Enumerate the properties contained in a group of properties.\n\nThe callback function is called for each property in the group of\nproperties. The properties are locked during enumeration.\n\n@param callback the function to call for each property.\n@param userdata a pointer that is passed to `callback`.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
                "name": "Enumerate",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "callback",
                    "type": "EnumeratePropertiesCallback"
                  },
                  {
                    "name": "userdata",
                    "type": "void *"
                  }
                ],
                "sourceName": "SDL_EnumerateProperties",
                "immutable": true
              }
            ],
            "Destroy": {
              "doc": "Destroy a group of properties.\n\nAll properties are deleted and their cleanup functions will be called, if\nany.\n\n\n@threadsafety This function should not be called while these properties are\n              locked or other threads might be setting or getting values\n              from these properties.\n\n@since This function is available since SDL 3.2.0.\n\n@sa CreateProperties",
              "name": "Destroy",
              "kind": "function",
              "type": "void",
              "parameters": [],
              "sourceName": "SDL_DestroyProperties"
            }
          }
        },
        "ObjectRef<SDL_PropertiesID, FancyPointer<SDL_PropertiesID>>::doFree": {
          "name": "ObjectRef<SDL_PropertiesID, FancyPointer<SDL_PropertiesID>>::doFree",
          "type": "void",
          "kind": "function",
          "doc": "Callback for properties resource cleanup\n\n@private",
          "template": [],
          "parameters": [
            {
              "type": "FancyPointer<SDL_PropertiesID>",
              "name": "resource"
            }
          ],
          "sourceName": "SDL_DestroyProperties"
        },
        "PropertiesLock": {
          "name": "PropertiesLock",
          "kind": "struct",
          "entries": {
            "properties": {
              "kind": "var",
              "type": "PropertiesRef",
              "name": "properties",
              "doc": ""
            },
            "PropertiesLock": [
              {
                "doc": "@sa PropertiesBase.Lock()",
                "kind": "function",
                "type": "",
                "explicit": true,
                "parameters": [
                  {
                    "name": "properties",
                    "type": "PropertiesRef"
                  }
                ],
                "name": "PropertiesLock"
              },
              {
                "kind": "function",
                "type": "",
                "parameters": [],
                "name": "PropertiesLock",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "type": "const PropertiesLock &",
                    "name": "other"
                  }
                ],
                "name": "PropertiesLock",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "type": "PropertiesLock &&",
                    "name": "other"
                  }
                ],
                "name": "PropertiesLock",
                "doc": ""
              }
            ],
            "~PropertiesLock": {
              "kind": "function",
              "doc": "@sa Unlock()",
              "type": "",
              "parameters": [],
              "name": "~PropertiesLock"
            },
            "operator=": {
              "kind": "function",
              "type": "PropertiesLock &",
              "parameters": [
                {
                  "type": "PropertiesLock",
                  "name": "other"
                }
              ],
              "name": "operator=",
              "doc": ""
            },
            "operator bool": {
              "kind": "function",
              "type": "",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "name": "operator bool",
              "doc": ""
            },
            "Unlock": {
              "doc": "Unlock a group of properties.\n\n@param props the properties to unlock.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PropertiesBase.Lock",
              "name": "Unlock",
              "kind": "function",
              "type": "void",
              "parameters": [],
              "sourceName": "SDL_UnlockProperties"
            }
          },
          "doc": ""
        },
        "PROPERTY_TYPE_INVALID": {
          "doc": "",
          "name": "PROPERTY_TYPE_INVALID",
          "kind": "var",
          "type": "PropertyType",
          "sourceName": "SDL_PROPERTY_TYPE_INVALID",
          "constexpr": true
        },
        "PROPERTY_TYPE_POINTER": {
          "doc": "",
          "name": "PROPERTY_TYPE_POINTER",
          "kind": "var",
          "type": "PropertyType",
          "sourceName": "SDL_PROPERTY_TYPE_POINTER",
          "constexpr": true
        },
        "PROPERTY_TYPE_STRING": {
          "doc": "",
          "name": "PROPERTY_TYPE_STRING",
          "kind": "var",
          "type": "PropertyType",
          "sourceName": "SDL_PROPERTY_TYPE_STRING",
          "constexpr": true
        },
        "PROPERTY_TYPE_NUMBER": {
          "doc": "",
          "name": "PROPERTY_TYPE_NUMBER",
          "kind": "var",
          "type": "PropertyType",
          "sourceName": "SDL_PROPERTY_TYPE_NUMBER",
          "constexpr": true
        },
        "PROPERTY_TYPE_FLOAT": {
          "doc": "",
          "name": "PROPERTY_TYPE_FLOAT",
          "kind": "var",
          "type": "PropertyType",
          "sourceName": "SDL_PROPERTY_TYPE_FLOAT",
          "constexpr": true
        },
        "PROPERTY_TYPE_BOOLEAN": {
          "doc": "",
          "name": "PROPERTY_TYPE_BOOLEAN",
          "kind": "var",
          "type": "PropertyType",
          "sourceName": "SDL_PROPERTY_TYPE_BOOLEAN",
          "constexpr": true
        },
        "GetGlobalProperties": {
          "doc": "Get the global SDL properties.\n\n@returns a valid property ID on success or 0 on failure; call\n         GetError() for more information.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetGlobalProperties",
          "kind": "function",
          "type": "PropertiesRef",
          "parameters": [],
          "sourceName": "SDL_GetGlobalProperties"
        },
        "CreateProperties": {
          "doc": "Create a group of properties.\n\nAll properties are automatically destroyed when Quit() is called.\n\n@returns an ID for a new group of properties, or 0 on failure; call\n         GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PropertiesBase.Destroy",
          "name": "CreateProperties",
          "kind": "function",
          "type": "Properties",
          "parameters": [],
          "sourceName": "SDL_CreateProperties"
        }
      }
    },
    "SDL3pp_iostream.h": {
      "name": "SDL3pp_iostream.h",
      "doc": "@defgroup CategoryIOStream Category IOStream\n\nSDL provides an abstract interface for reading and writing data streams. It\noffers implementations for files, memory, etc, and the app can provide\ntheir own implementations, too.\n\nIOStreamBase is not related to the standard C++ iostream class, other than\nboth are abstract interfaces to read/write data.",
      "entries": {
        "IOStreamBase-forward": {
          "name": "IOStreamBase",
          "kind": "forward",
          "template": [
            {
              "type": "ObjectBox<SDL_IOStream *>",
              "name": "T"
            }
          ],
          "doc": ""
        },
        "IOStreamRef": {
          "name": "IOStreamRef",
          "kind": "alias",
          "type": "IOStreamBase<ObjectRef<SDL_IOStream>>",
          "doc": "Handle to a non owned iOStream\n\n@cat resource\n\n@sa IOStreamBase\n@sa IOStream"
        },
        "IOStream": {
          "name": "IOStream",
          "kind": "alias",
          "type": "IOStreamBase<ObjectUnique<SDL_IOStream>>",
          "doc": "Handle to an owned iOStream\n\n@cat resource\n\n@sa IOStreamBase\n@sa IOStreamRef"
        },
        "IOFromDynamicMem_CtorTag": {
          "name": "IOFromDynamicMem_CtorTag",
          "kind": "struct",
          "doc": "@cat constructor-tag",
          "entries": {}
        },
        "IOStatus": {
          "doc": "IOStreamBase status, set by a read or write operation.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "IOStatus",
          "kind": "alias",
          "sourceName": "SDL_IOStatus",
          "type": "SDL_IOStatus"
        },
        "IO_STATUS_READY": {
          "doc": "Everything is ready (no errors and not EOF).",
          "name": "IO_STATUS_READY",
          "kind": "var",
          "type": "IOStatus",
          "sourceName": "SDL_IO_STATUS_READY",
          "constexpr": true
        },
        "IO_STATUS_ERROR": {
          "doc": "Read or write I/O error.",
          "name": "IO_STATUS_ERROR",
          "kind": "var",
          "type": "IOStatus",
          "sourceName": "SDL_IO_STATUS_ERROR",
          "constexpr": true
        },
        "IO_STATUS_EOF": {
          "doc": "End of file.",
          "name": "IO_STATUS_EOF",
          "kind": "var",
          "type": "IOStatus",
          "sourceName": "SDL_IO_STATUS_EOF",
          "constexpr": true
        },
        "IO_STATUS_NOT_READY": {
          "doc": "Non blocking I/O, not ready.",
          "name": "IO_STATUS_NOT_READY",
          "kind": "var",
          "type": "IOStatus",
          "sourceName": "SDL_IO_STATUS_NOT_READY",
          "constexpr": true
        },
        "IO_STATUS_READONLY": {
          "doc": "Tried to write a read-only buffer.",
          "name": "IO_STATUS_READONLY",
          "kind": "var",
          "type": "IOStatus",
          "sourceName": "SDL_IO_STATUS_READONLY",
          "constexpr": true
        },
        "IO_STATUS_WRITEONLY": {
          "doc": "Tried to read a write-only buffer.",
          "name": "IO_STATUS_WRITEONLY",
          "kind": "var",
          "type": "IOStatus",
          "sourceName": "SDL_IO_STATUS_WRITEONLY",
          "constexpr": true
        },
        "IOWhence": {
          "doc": "Possible `whence` values for IOStreamBase seeking.\n\nThese map to the same \"whence\" concept that `fseek` or `lseek` use in the\nstandard C runtime.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "IOWhence",
          "kind": "alias",
          "sourceName": "SDL_IOWhence",
          "type": "SDL_IOWhence"
        },
        "IO_SEEK_SET": {
          "doc": "Seek from the beginning of data.",
          "name": "IO_SEEK_SET",
          "kind": "var",
          "type": "IOWhence",
          "sourceName": "SDL_IO_SEEK_SET",
          "constexpr": true
        },
        "IO_SEEK_CUR": {
          "doc": "Seek relative to current read point.",
          "name": "IO_SEEK_CUR",
          "kind": "var",
          "type": "IOWhence",
          "sourceName": "SDL_IO_SEEK_CUR",
          "constexpr": true
        },
        "IO_SEEK_END": {
          "doc": "Seek relative to the end of data.",
          "name": "IO_SEEK_END",
          "kind": "var",
          "type": "IOWhence",
          "sourceName": "SDL_IO_SEEK_END",
          "constexpr": true
        },
        "IOStreamInterface": {
          "doc": "The function pointers that drive an IOStreamBase.\n\nApplications can provide this struct to IOStreamBase.IOStreamBase() to create their own\nimplementation of IOStreamBase. This is not necessarily required, as SDL\nalready offers several common types of I/O streams, via functions like\nIOStreamBase.IOStreamBase() and IOStreamBase.IOStreamBase().\n\nThis structure should be initialized using SDL_INIT_INTERFACE()\n\n@since This struct is available since SDL 3.2.0.\n\n@sa SDL_INIT_INTERFACE",
          "name": "IOStreamInterface",
          "kind": "alias",
          "sourceName": "SDL_IOStreamInterface",
          "type": "SDL_IOStreamInterface"
        },
        "IOStreamBase": {
          "doc": "The read/write operation structure.\n\nThis operates as an opaque handle. There are several APIs to create various\ntypes of I/O streams, or an app can supply an IOStreamInterface to\nIOStreamBase.IOStreamBase() to provide their own stream implementation behind this\nstruct's abstract interface.\n\n@since This struct is available since SDL 3.2.0.",
          "name": "IOStreamBase",
          "kind": "struct",
          "type": "T",
          "sourceName": "SDL_IOStream",
          "template": [
            {
              "type": "ObjectBox<SDL_IOStream *>",
              "name": "T"
            }
          ],
          "entries": {
            "T::T": {
              "kind": "alias",
              "name": "T::T",
              "doc": ""
            },
            "IOStreamBase": [
              {
                "doc": "Use this function to create a new IOStreamBase structure for reading from\nand/or writing to a named file.\n\nThe `mode` string is treated roughly the same as in a call to the C\nlibrary's fopen(), even if SDL doesn't happen to use fopen() behind the\nscenes.\n\nAvailable `mode` strings:\n\n- \"r\": Open a file for reading. The file must exist.\n- \"w\": Create an empty file for writing. If a file with the same name\n  already exists its content is erased and the file is treated as a new\n  empty file.\n- \"a\": Append to a file. Writing operations append data at the end of the\n  file. The file is created if it does not exist.\n- \"r+\": Open a file for update both reading and writing. The file must\n  exist.\n- \"w+\": Create an empty file for both reading and writing. If a file with\n  the same name already exists its content is erased and the file is\n  treated as a new empty file.\n- \"a+\": Open a file for reading and appending. All writing operations are\n  performed at the end of the file, protecting the previous content to be\n  overwritten. You can reposition (fseek, rewind) the internal pointer to\n  anywhere in the file for reading, but writing operations will move it\n  back to the end of file. The file is created if it does not exist.\n\n**NOTE**: In order to open a file as a binary file, a \"b\" character has to\nbe included in the `mode` string. This additional \"b\" character can either\nbe appended at the end of the string (thus making the following compound\nmodes: \"rb\", \"wb\", \"ab\", \"r+b\", \"w+b\", \"a+b\") or be inserted between the\nletter and the \"+\" sign for the mixed modes (\"rb+\", \"wb+\", \"ab+\").\nAdditional characters may follow the sequence, although they should have no\neffect. For example, \"t\" is sometimes appended to make explicit the file is\na text file.\n\nThis function supports Unicode filenames, but they must be encoded in UTF-8\nformat, regardless of the underlying operating system.\n\nIn Android, IOStreamBase.IOStreamBase() can be used to open content:// URIs. As a\nfallback, IOStreamBase.IOStreamBase() will transparently open a matching filename in\nthe app's `assets`.\n\nClosing the IOStreamBase will close SDL's internal file handle.\n\nThe following properties may be set at creation time by SDL:\n\n- `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast\n  to a win32 `HANDLE`, that this IOStreamBase is using to access the\n  filesystem. If the program isn't running on Windows, or SDL used some\n  other method to access the filesystem, this property will not be set.\n- `prop::IOStream.STDIO_FILE_POINTER`: a pointer, that can be cast to a\n  stdio `FILE *`, that this IOStreamBase is using to access the filesystem.\n  If SDL used some other method to access the filesystem, this property\n  will not be set. PLEASE NOTE that if SDL is using a different C runtime\n  than your app, trying to use this pointer will almost certainly result in\n  a crash! This is mostly a problem on Windows; make sure you build SDL and\n  your app with the same compiler and settings to avoid it.\n- `prop::IOStream.FILE_DESCRIPTOR_NUMBER`: a file descriptor that this\n  IOStreamBase is using to access the filesystem.\n- `prop::IOStream.ANDROID_AASSET_POINTER`: a pointer, that can be cast\n  to an Android NDK `AAsset *`, that this IOStreamBase is using to access\n  the filesystem. If SDL used some other method to access the filesystem,\n  this property will not be set.\n\n@param file a UTF-8 string representing the filename to open.\n@param mode an ASCII string representing the mode to be used for opening\n            the file.\n@post a pointer to the IOStreamBase structure that is created or nullptr on\n         failure; call GetError() for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa IOStreamBase.Close\n@sa IOStreamBase.Flush\n@sa IOStreamBase.Read\n@sa IOStreamBase.Seek\n@sa IOStreamBase.Tell\n@sa IOStreamBase.Write",
                "name": "IOStreamBase",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "file",
                    "type": "StringParam"
                  },
                  {
                    "name": "mode",
                    "type": "StringParam"
                  }
                ],
                "sourceName": "SDL_IOFromFile"
              },
              {
                "doc": "Use this function to prepare a read-write memory buffer for use with\nIOStreamBase.\n\nThis function sets up an IOStreamBase struct based on a memory area of a\ncertain size, for both read and write access.\n\nThis memory buffer is not copied by the IOStreamBase; the pointer you\nprovide must remain valid until you close the stream. Closing the stream\nwill not free the original buffer.\n\nIf you need to make sure the IOStreamBase never writes to the memory\nbuffer, you should use IOStreamBase.IOStreamBase() with a read-only buffer of\nmemory instead.\n\nThe following properties will be set at creation time by SDL:\n\n- `prop::IOStream.MEMORY_POINTER`: this will be the `mem` parameter that\n  was passed to this function.\n- `prop::IOStream.MEMORY_SIZE_NUMBER`: this will be the `size` parameter\n  that was passed to this function.\n\n@param mem a pointer to a buffer to feed an IOStreamBase stream.\n@param size the buffer size, in bytes.\n@post a pointer to a new IOStreamBase structure or nullptr on failure; call\n         GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa IOStreamBase.IOStreamBase\n@sa IOStreamBase.Close\n@sa IOStreamBase.Flush\n@sa IOStreamBase.Read\n@sa IOStreamBase.Seek\n@sa IOStreamBase.Tell\n@sa IOStreamBase.Write",
                "name": "IOStreamBase",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "mem",
                    "type": "void *"
                  },
                  {
                    "name": "size",
                    "type": "size_t"
                  }
                ],
                "sourceName": "SDL_IOFromMem"
              },
              {
                "doc": "Use this function to prepare a read-only memory buffer for use with\nIOStreamBase.\n\nThis function sets up an IOStreamBase struct based on a memory area of a\ncertain size. It assumes the memory area is not writable.\n\nAttempting to write to this IOStreamBase stream will report an error\nwithout writing to the memory buffer.\n\nThis memory buffer is not copied by the IOStreamBase; the pointer you\nprovide must remain valid until you close the stream. Closing the stream\nwill not free the original buffer.\n\nIf you need to write to a memory buffer, you should use IOStreamBase.IOStreamBase()\nwith a writable buffer of memory instead.\n\nThe following properties will be set at creation time by SDL:\n\n- `prop::IOStream.MEMORY_POINTER`: this will be the `mem` parameter that\n  was passed to this function.\n- `prop::IOStream.MEMORY_SIZE_NUMBER`: this will be the `size` parameter\n  that was passed to this function.\n\n@param mem a pointer to a read-only buffer to feed an IOStreamBase stream.\n@param size the buffer size, in bytes.\n@post a pointer to a new IOStreamBase structure or nullptr on failure; call\n         GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa IOStreamBase.IOStreamBase\n@sa IOStreamBase.Close\n@sa IOStreamBase.Read\n@sa IOStreamBase.Seek\n@sa IOStreamBase.Tell",
                "name": "IOStreamBase",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "mem",
                    "type": "const void *"
                  },
                  {
                    "name": "size",
                    "type": "size_t"
                  }
                ],
                "sourceName": "SDL_IOFromConstMem"
              },
              {
                "doc": "Use this function to create an IOStreamBase that is backed by dynamically\nallocated memory.\n\nThis supports the following properties to provide access to the memory and\ncontrol over allocations:\n\n- `prop::IOStream.DYNAMIC_MEMORY_POINTER`: a pointer to the internal\n  memory of the stream. This can be set to nullptr to transfer ownership of\n  the memory to the application, which should free the memory with\n  free(). If this is done, the next operation on the stream must be\n  IOStreamBase.Close().\n- `prop::IOStream.DYNAMIC_CHUNKSIZE_NUMBER`: memory will be allocated in\n  multiples of this size, defaulting to 1024.\n\n@post a pointer to a new IOStreamBase structure or nullptr on failure; call\n         GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa IOStreamBase.Close\n@sa IOStreamBase.Read\n@sa IOStreamBase.Seek\n@sa IOStreamBase.Tell\n@sa IOStreamBase.Write",
                "name": "IOStreamBase",
                "kind": "function",
                "type": "",
                "parameters": [
                  "IOFromDynamicMem_CtorTag"
                ],
                "sourceName": "SDL_IOFromDynamicMem",
                "static": false
              },
              {
                "doc": "Create a custom IOStreamBase.\n\nApplications do not need to use this function unless they are providing\ntheir own IOStreamBase implementation. If you just need an IOStreamBase to\nread/write a common data source, you should use the built-in\nimplementations in SDL, like IOStreamBase.IOStreamBase() or IOStreamBase.IOStreamBase(), etc.\n\nThis function makes a copy of `iface` and the caller does not need to keep\nit around after this call.\n\n@param iface the interface that implements this IOStreamBase, initialized\n             using SDL_INIT_INTERFACE().\n@param userdata the pointer that will be passed to the interface functions.\n@post a pointer to the allocated memory on success or nullptr on failure;\n         call GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa IOStreamBase.Close\n@sa SDL_INIT_INTERFACE\n@sa IOStreamBase.IOStreamBase\n@sa IOStreamBase.IOStreamBase\n@sa IOStreamBase.IOStreamBase",
                "name": "IOStreamBase",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "iface",
                    "type": "const IOStreamInterface *"
                  },
                  {
                    "name": "userdata",
                    "type": "void *"
                  }
                ],
                "sourceName": "SDL_OpenIO"
              },
              {
                "name": "IOStreamBase",
                "kind": "function",
                "type": "",
                "static": false,
                "template": [
                  {
                    "type": "class",
                    "name": "U"
                  }
                ],
                "parameters": [
                  {
                    "type": "std::span<U>",
                    "name": "mem"
                  }
                ],
                "doc": ""
              }
            ],
            "GetProperties": {
              "doc": "Get the properties associated with an IOStreamBase.\n\n@returns a valid property ID on success or 0 on failure; call\n         GetError() for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetProperties",
              "kind": "function",
              "type": "PropertiesRef",
              "parameters": [],
              "sourceName": "SDL_GetIOProperties",
              "immutable": true
            },
            "GetStatus": {
              "doc": "Query the stream status of an IOStreamBase.\n\nThis information can be useful to decide if a short read or write was due\nto an error, an EOF, or a non-blocking operation that isn't yet ready to\ncomplete.\n\nAn IOStreamBase's status is only expected to change after a IOStreamBase.Read or\nIOStreamBase.Write call; don't expect it to change if you just call this query\nfunction in a tight loop.\n\n@returns an IOStatus enum with the current state.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetStatus",
              "kind": "function",
              "type": "IOStatus",
              "parameters": [],
              "sourceName": "SDL_GetIOStatus",
              "immutable": true
            },
            "GetSize": {
              "doc": "Use this function to get the size of the data stream in an IOStreamBase.\n\n@returns the size of the data stream in the IOStreamBase on success or a\n         negative error code on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetSize",
              "kind": "function",
              "type": "Sint64",
              "parameters": [],
              "sourceName": "SDL_GetIOSize",
              "immutable": true
            },
            "Seek": {
              "doc": "Seek within an IOStreamBase data stream.\n\nThis function seeks to byte `offset`, relative to `whence`.\n\n`whence` may be any of the following values:\n\n- `IO_SEEK_SET`: seek from the beginning of data\n- `IO_SEEK_CUR`: seek relative to current read point\n- `IO_SEEK_END`: seek relative to the end of data\n\nIf this stream can not seek, it will return -1.\n\n@param offset an offset in bytes, relative to `whence` location; can be\n              negative.\n@param whence any of `IO_SEEK_SET`, `IO_SEEK_CUR`,\n              `IO_SEEK_END`.\n@returns the final offset in the data stream after the seek or -1 on\n         failure; call GetError() for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa IOStreamBase.Tell",
              "name": "Seek",
              "kind": "function",
              "type": "Sint64",
              "parameters": [
                {
                  "name": "offset",
                  "type": "Sint64"
                },
                {
                  "name": "whence",
                  "type": "IOWhence"
                }
              ],
              "sourceName": "SDL_SeekIO"
            },
            "Tell": {
              "doc": "Determine the current read/write offset in an IOStreamBase data stream.\n\nIOStreamBase.Tell is actually a wrapper function that calls the IOStreamBase's\n`seek` method, with an offset of 0 bytes from `IO_SEEK_CUR`, to\nsimplify application development.\n\n               current offset.\n@returns the current offset in the stream, or -1 if the information can not\n         be determined.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa IOStreamBase.Seek",
              "name": "Tell",
              "kind": "function",
              "type": "Sint64",
              "parameters": [],
              "sourceName": "SDL_TellIO",
              "immutable": true
            },
            "Read": {
              "doc": "Read from a data source.\n\nThis function reads up `size` bytes from the data source to the area\npointed at by `ptr`. This function may read less bytes than requested.\n\nThis function will return zero when the data stream is completely read, and\nIOStreamBase.GetStatus() will return IO_STATUS_EOF. If zero is returned and\nthe stream is not at EOF, IOStreamBase.GetStatus() will return a different error\nvalue and GetError() will offer a human-readable message.\n\n@param ptr a pointer to a buffer to read data into.\n@param size the number of bytes to read from the data source.\n@returns the number of bytes read, or 0 on end of file or other failure;\n         call GetError() for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa IOStreamBase.Write\n@sa IOStreamBase.GetStatus",
              "name": "Read",
              "kind": "function",
              "type": "size_t",
              "parameters": [
                {
                  "name": "ptr",
                  "type": "void *"
                },
                {
                  "name": "size",
                  "type": "size_t"
                }
              ],
              "sourceName": "SDL_ReadIO"
            },
            "Write": [
              {
                "kind": "function",
                "type": "size_t",
                "template": [
                  {
                    "type": "class",
                    "name": "U"
                  }
                ],
                "parameters": [
                  {
                    "type": "std::span<U>",
                    "name": "data"
                  }
                ],
                "name": "Write",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "size_t",
                "parameters": [
                  {
                    "type": "std::string_view",
                    "name": "str"
                  }
                ],
                "name": "Write",
                "doc": ""
              },
              {
                "doc": "Write to an IOStreamBase data stream.\n\nThis function writes exactly `size` bytes from the area pointed at by `ptr`\nto the stream. If this fails for any reason, it'll return less than `size`\nto demonstrate how far the write progressed. On success, it returns `size`.\n\nOn error, this function still attempts to write as much as possible, so it\nmight return a positive value less than the requested write size.\n\nThe caller can use IOStreamBase.GetStatus() to determine if the problem is\nrecoverable, such as a non-blocking write that can simply be retried later,\nor a fatal error.\n\n@param ptr a pointer to a buffer containing data to write.\n@param size the number of bytes to write.\n@returns the number of bytes written, which will be less than `size` on\n         failure; call GetError() for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa IOStreamBase.printf\n@sa IOStreamBase.Read\n@sa IOStreamBase.Seek\n@sa IOStreamBase.Flush\n@sa IOStreamBase.GetStatus",
                "name": "Write",
                "kind": "function",
                "type": "size_t",
                "parameters": [
                  {
                    "name": "ptr",
                    "type": "const void *"
                  },
                  {
                    "name": "size",
                    "type": "size_t"
                  }
                ],
                "sourceName": "SDL_WriteIO"
              }
            ],
            "print": {
              "kind": "function",
              "type": "size_t",
              "doc": "@cat formatted-string",
              "parameters": [
                {
                  "type": "std::string_view",
                  "name": "fmt"
                },
                {
                  "type": "auto...",
                  "name": "args"
                }
              ],
              "name": "print"
            },
            "println": {
              "kind": "function",
              "type": "size_t",
              "doc": "@cat formatted-string",
              "parameters": [
                {
                  "type": "std::string_view",
                  "name": "fmt"
                },
                {
                  "type": "auto...",
                  "name": "args"
                }
              ],
              "name": "println"
            },
            "printf": {
              "doc": "Print to an IOStreamBase data stream.\n\nThis function does formatted printing to the stream.\n\n@param fmt a printf() style format string.\n@param ... additional parameters matching % tokens in the `fmt` string, if\n           any.\n@returns the number of bytes written or 0 on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa IOStreamBase.vprintf\n@sa IOStreamBase.Write",
              "name": "printf",
              "kind": "function",
              "type": "size_t",
              "parameters": [
                {
                  "name": "fmt",
                  "type": "SDL_PRINTF_FORMAT_STRING const char *"
                },
                "..."
              ],
              "sourceName": "SDL_IOprintf"
            },
            "vprintf": {
              "doc": "Print to an IOStreamBase data stream.\n\nThis function does formatted printing to the stream.\n\n@param fmt a printf() style format string.\n@param ap a variable argument list.\n@returns the number of bytes written or 0 on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa IOStreamBase.printf\n@sa IOStreamBase.Write",
              "name": "vprintf",
              "kind": "function",
              "type": "size_t",
              "parameters": [
                {
                  "name": "fmt",
                  "type": "SDL_PRINTF_FORMAT_STRING const char *"
                },
                {
                  "name": "ap",
                  "type": "va_list"
                }
              ],
              "sourceName": "SDL_IOvprintf"
            },
            "Flush": {
              "doc": "Flush any buffered data in the stream.\n\nThis function makes sure that any buffered data is written to the stream.\nNormally this isn't necessary but if the stream is a pipe or socket it\nguarantees that any pending data is sent.\n\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa IOStreamBase.IOStreamBase\n@sa IOStreamBase.Write",
              "name": "Flush",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_FlushIO"
            },
            "LoadFile": {
              "doc": "Load all the data from an SDL data stream.\n\nThe data is allocated with a zero byte at the end (null terminated) for\nconvenience. This extra byte is not included in the value reported via\n`datasize`.\n\nThe data should be freed with free().\n\n@param src the IOStreamBase to read all available data from.\n@param datasize a pointer filled in with the number of bytes read, may be\n                nullptr.\n@param closeio if true, calls IOStreamBase.Close() on `src` before returning, even\n               in the case of an error.\n@returns the data or nullptr on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa LoadFile\n@sa IOStreamBase.SaveFile",
              "name": "LoadFile",
              "kind": "function",
              "type": "OwnArray<std::byte>",
              "parameters": [],
              "sourceName": "SDL_LoadFile_IO",
              "static": false
            },
            "SaveFile": [
              {
                "kind": "function",
                "type": "bool",
                "template": [
                  {
                    "type": "class",
                    "name": "U"
                  }
                ],
                "parameters": [
                  {
                    "type": "std::span<U>",
                    "name": "data"
                  }
                ],
                "name": "SaveFile",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "type": "std::string_view",
                    "name": "str"
                  }
                ],
                "name": "SaveFile",
                "doc": ""
              },
              {
                "doc": "Save all the data into an SDL data stream.\n\n@param data the data to be written. If datasize is 0, may be nullptr or a\n            invalid pointer.\n@param datasize the number of bytes to be written.\n@param closeio if true, calls IOStreamBase.Close() on `src` before returning, even\n               in the case of an error.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SaveFile\n@sa IOStreamBase.LoadFile",
                "name": "SaveFile",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "data",
                    "type": "const void *"
                  },
                  {
                    "name": "datasize",
                    "type": "size_t"
                  }
                ],
                "sourceName": "SDL_SaveFile_IO"
              }
            ],
            "ReadU8": {
              "doc": "Use this function to read a byte from an IOStreamBase.\n\nThis function will return false when the data stream is completely read,\nand IOStreamBase.GetStatus() will return IO_STATUS_EOF. If false is returned\nand the stream is not at EOF, IOStreamBase.GetStatus() will return a different\nerror value and GetError() will offer a human-readable message.\n\n@param value a pointer filled in with the data read.\n@returns true on success or false on failure or EOF; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "ReadU8",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Uint8 *"
                }
              ],
              "sourceName": "SDL_ReadU8"
            },
            "ReadS8": {
              "doc": "Use this function to read a signed byte from an IOStreamBase.\n\nThis function will return false when the data stream is completely read,\nand IOStreamBase.GetStatus() will return IO_STATUS_EOF. If false is returned\nand the stream is not at EOF, IOStreamBase.GetStatus() will return a different\nerror value and GetError() will offer a human-readable message.\n\n@param value a pointer filled in with the data read.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "ReadS8",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Sint8 *"
                }
              ],
              "sourceName": "SDL_ReadS8"
            },
            "ReadU16LE": {
              "doc": "Use this function to read 16 bits of little-endian data from an\nIOStreamBase and return in native format.\n\nSDL byteswaps the data only if necessary, so the data returned will be in\nthe native byte order.\n\nThis function will return false when the data stream is completely read,\nand IOStreamBase.GetStatus() will return IO_STATUS_EOF. If false is returned\nand the stream is not at EOF, IOStreamBase.GetStatus() will return a different\nerror value and GetError() will offer a human-readable message.\n\n@param value a pointer filled in with the data read.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "ReadU16LE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Uint16 *"
                }
              ],
              "sourceName": "SDL_ReadU16LE"
            },
            "ReadS16LE": {
              "doc": "Use this function to read 16 bits of little-endian data from an\nIOStreamBase and return in native format.\n\nSDL byteswaps the data only if necessary, so the data returned will be in\nthe native byte order.\n\nThis function will return false when the data stream is completely read,\nand IOStreamBase.GetStatus() will return IO_STATUS_EOF. If false is returned\nand the stream is not at EOF, IOStreamBase.GetStatus() will return a different\nerror value and GetError() will offer a human-readable message.\n\n@param value a pointer filled in with the data read.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "ReadS16LE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Sint16 *"
                }
              ],
              "sourceName": "SDL_ReadS16LE"
            },
            "ReadU16BE": {
              "doc": "Use this function to read 16 bits of big-endian data from an IOStreamBase\nand return in native format.\n\nSDL byteswaps the data only if necessary, so the data returned will be in\nthe native byte order.\n\nThis function will return false when the data stream is completely read,\nand IOStreamBase.GetStatus() will return IO_STATUS_EOF. If false is returned\nand the stream is not at EOF, IOStreamBase.GetStatus() will return a different\nerror value and GetError() will offer a human-readable message.\n\n@param value a pointer filled in with the data read.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "ReadU16BE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Uint16 *"
                }
              ],
              "sourceName": "SDL_ReadU16BE"
            },
            "ReadS16BE": {
              "doc": "Use this function to read 16 bits of big-endian data from an IOStreamBase\nand return in native format.\n\nSDL byteswaps the data only if necessary, so the data returned will be in\nthe native byte order.\n\nThis function will return false when the data stream is completely read,\nand IOStreamBase.GetStatus() will return IO_STATUS_EOF. If false is returned\nand the stream is not at EOF, IOStreamBase.GetStatus() will return a different\nerror value and GetError() will offer a human-readable message.\n\n@param value a pointer filled in with the data read.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "ReadS16BE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Sint16 *"
                }
              ],
              "sourceName": "SDL_ReadS16BE"
            },
            "ReadU32LE": {
              "doc": "Use this function to read 32 bits of little-endian data from an\nIOStreamBase and return in native format.\n\nSDL byteswaps the data only if necessary, so the data returned will be in\nthe native byte order.\n\nThis function will return false when the data stream is completely read,\nand IOStreamBase.GetStatus() will return IO_STATUS_EOF. If false is returned\nand the stream is not at EOF, IOStreamBase.GetStatus() will return a different\nerror value and GetError() will offer a human-readable message.\n\n@param value a pointer filled in with the data read.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "ReadU32LE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Uint32 *"
                }
              ],
              "sourceName": "SDL_ReadU32LE"
            },
            "ReadS32LE": {
              "doc": "Use this function to read 32 bits of little-endian data from an\nIOStreamBase and return in native format.\n\nSDL byteswaps the data only if necessary, so the data returned will be in\nthe native byte order.\n\nThis function will return false when the data stream is completely read,\nand IOStreamBase.GetStatus() will return IO_STATUS_EOF. If false is returned\nand the stream is not at EOF, IOStreamBase.GetStatus() will return a different\nerror value and GetError() will offer a human-readable message.\n\n@param value a pointer filled in with the data read.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "ReadS32LE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Sint32 *"
                }
              ],
              "sourceName": "SDL_ReadS32LE"
            },
            "ReadU32BE": {
              "doc": "Use this function to read 32 bits of big-endian data from an IOStreamBase\nand return in native format.\n\nSDL byteswaps the data only if necessary, so the data returned will be in\nthe native byte order.\n\nThis function will return false when the data stream is completely read,\nand IOStreamBase.GetStatus() will return IO_STATUS_EOF. If false is returned\nand the stream is not at EOF, IOStreamBase.GetStatus() will return a different\nerror value and GetError() will offer a human-readable message.\n\n@param value a pointer filled in with the data read.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "ReadU32BE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Uint32 *"
                }
              ],
              "sourceName": "SDL_ReadU32BE"
            },
            "ReadS32BE": {
              "doc": "Use this function to read 32 bits of big-endian data from an IOStreamBase\nand return in native format.\n\nSDL byteswaps the data only if necessary, so the data returned will be in\nthe native byte order.\n\nThis function will return false when the data stream is completely read,\nand IOStreamBase.GetStatus() will return IO_STATUS_EOF. If false is returned\nand the stream is not at EOF, IOStreamBase.GetStatus() will return a different\nerror value and GetError() will offer a human-readable message.\n\n@param value a pointer filled in with the data read.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "ReadS32BE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Sint32 *"
                }
              ],
              "sourceName": "SDL_ReadS32BE"
            },
            "ReadU64LE": {
              "doc": "Use this function to read 64 bits of little-endian data from an\nIOStreamBase and return in native format.\n\nSDL byteswaps the data only if necessary, so the data returned will be in\nthe native byte order.\n\nThis function will return false when the data stream is completely read,\nand IOStreamBase.GetStatus() will return IO_STATUS_EOF. If false is returned\nand the stream is not at EOF, IOStreamBase.GetStatus() will return a different\nerror value and GetError() will offer a human-readable message.\n\n@param value a pointer filled in with the data read.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "ReadU64LE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Uint64 *"
                }
              ],
              "sourceName": "SDL_ReadU64LE"
            },
            "ReadS64LE": {
              "doc": "Use this function to read 64 bits of little-endian data from an\nIOStreamBase and return in native format.\n\nSDL byteswaps the data only if necessary, so the data returned will be in\nthe native byte order.\n\nThis function will return false when the data stream is completely read,\nand IOStreamBase.GetStatus() will return IO_STATUS_EOF. If false is returned\nand the stream is not at EOF, IOStreamBase.GetStatus() will return a different\nerror value and GetError() will offer a human-readable message.\n\n@param value a pointer filled in with the data read.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "ReadS64LE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Sint64 *"
                }
              ],
              "sourceName": "SDL_ReadS64LE"
            },
            "ReadU64BE": {
              "doc": "Use this function to read 64 bits of big-endian data from an IOStreamBase\nand return in native format.\n\nSDL byteswaps the data only if necessary, so the data returned will be in\nthe native byte order.\n\nThis function will return false when the data stream is completely read,\nand IOStreamBase.GetStatus() will return IO_STATUS_EOF. If false is returned\nand the stream is not at EOF, IOStreamBase.GetStatus() will return a different\nerror value and GetError() will offer a human-readable message.\n\n@param value a pointer filled in with the data read.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "ReadU64BE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Uint64 *"
                }
              ],
              "sourceName": "SDL_ReadU64BE"
            },
            "ReadS64BE": {
              "doc": "Use this function to read 64 bits of big-endian data from an IOStreamBase\nand return in native format.\n\nSDL byteswaps the data only if necessary, so the data returned will be in\nthe native byte order.\n\nThis function will return false when the data stream is completely read,\nand IOStreamBase.GetStatus() will return IO_STATUS_EOF. If false is returned\nand the stream is not at EOF, IOStreamBase.GetStatus() will return a different\nerror value and GetError() will offer a human-readable message.\n\n@param value a pointer filled in with the data read.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "ReadS64BE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Sint64 *"
                }
              ],
              "sourceName": "SDL_ReadS64BE"
            },
            "WriteU8": {
              "doc": "Use this function to write a byte to an IOStreamBase.\n\n@param value the byte value to write.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "WriteU8",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Uint8"
                }
              ],
              "sourceName": "SDL_WriteU8"
            },
            "WriteS8": {
              "doc": "Use this function to write a signed byte to an IOStreamBase.\n\n@param value the byte value to write.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "WriteS8",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Sint8"
                }
              ],
              "sourceName": "SDL_WriteS8"
            },
            "WriteU16LE": {
              "doc": "Use this function to write 16 bits in native format to an IOStreamBase as\nlittle-endian data.\n\nSDL byteswaps the data only if necessary, so the application always\nspecifies native format, and the data written will be in little-endian\nformat.\n\n@param value the data to be written, in native format.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "WriteU16LE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Uint16"
                }
              ],
              "sourceName": "SDL_WriteU16LE"
            },
            "WriteS16LE": {
              "doc": "Use this function to write 16 bits in native format to an IOStreamBase as\nlittle-endian data.\n\nSDL byteswaps the data only if necessary, so the application always\nspecifies native format, and the data written will be in little-endian\nformat.\n\n@param value the data to be written, in native format.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "WriteS16LE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Sint16"
                }
              ],
              "sourceName": "SDL_WriteS16LE"
            },
            "WriteU16BE": {
              "doc": "Use this function to write 16 bits in native format to an IOStreamBase as\nbig-endian data.\n\nSDL byteswaps the data only if necessary, so the application always\nspecifies native format, and the data written will be in big-endian format.\n\n@param value the data to be written, in native format.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "WriteU16BE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Uint16"
                }
              ],
              "sourceName": "SDL_WriteU16BE"
            },
            "WriteS16BE": {
              "doc": "Use this function to write 16 bits in native format to an IOStreamBase as\nbig-endian data.\n\nSDL byteswaps the data only if necessary, so the application always\nspecifies native format, and the data written will be in big-endian format.\n\n@param value the data to be written, in native format.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "WriteS16BE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Sint16"
                }
              ],
              "sourceName": "SDL_WriteS16BE"
            },
            "WriteU32LE": {
              "doc": "Use this function to write 32 bits in native format to an IOStreamBase as\nlittle-endian data.\n\nSDL byteswaps the data only if necessary, so the application always\nspecifies native format, and the data written will be in little-endian\nformat.\n\n@param value the data to be written, in native format.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "WriteU32LE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Uint32"
                }
              ],
              "sourceName": "SDL_WriteU32LE"
            },
            "WriteS32LE": {
              "doc": "Use this function to write 32 bits in native format to an IOStreamBase as\nlittle-endian data.\n\nSDL byteswaps the data only if necessary, so the application always\nspecifies native format, and the data written will be in little-endian\nformat.\n\n@param value the data to be written, in native format.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "WriteS32LE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Sint32"
                }
              ],
              "sourceName": "SDL_WriteS32LE"
            },
            "WriteU32BE": {
              "doc": "Use this function to write 32 bits in native format to an IOStreamBase as\nbig-endian data.\n\nSDL byteswaps the data only if necessary, so the application always\nspecifies native format, and the data written will be in big-endian format.\n\n@param value the data to be written, in native format.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "WriteU32BE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Uint32"
                }
              ],
              "sourceName": "SDL_WriteU32BE"
            },
            "WriteS32BE": {
              "doc": "Use this function to write 32 bits in native format to an IOStreamBase as\nbig-endian data.\n\nSDL byteswaps the data only if necessary, so the application always\nspecifies native format, and the data written will be in big-endian format.\n\n@param value the data to be written, in native format.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "WriteS32BE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Sint32"
                }
              ],
              "sourceName": "SDL_WriteS32BE"
            },
            "WriteU64LE": {
              "doc": "Use this function to write 64 bits in native format to an IOStreamBase as\nlittle-endian data.\n\nSDL byteswaps the data only if necessary, so the application always\nspecifies native format, and the data written will be in little-endian\nformat.\n\n@param value the data to be written, in native format.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "WriteU64LE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Uint64"
                }
              ],
              "sourceName": "SDL_WriteU64LE"
            },
            "WriteS64LE": {
              "doc": "Use this function to write 64 bits in native format to an IOStreamBase as\nlittle-endian data.\n\nSDL byteswaps the data only if necessary, so the application always\nspecifies native format, and the data written will be in little-endian\nformat.\n\n@param value the data to be written, in native format.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "WriteS64LE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Sint64"
                }
              ],
              "sourceName": "SDL_WriteS64LE"
            },
            "WriteU64BE": {
              "doc": "Use this function to write 64 bits in native format to an IOStreamBase as\nbig-endian data.\n\nSDL byteswaps the data only if necessary, so the application always\nspecifies native format, and the data written will be in big-endian format.\n\n@param value the data to be written, in native format.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "WriteU64BE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Uint64"
                }
              ],
              "sourceName": "SDL_WriteU64BE"
            },
            "WriteS64BE": {
              "doc": "Use this function to write 64 bits in native format to an IOStreamBase as\nbig-endian data.\n\nSDL byteswaps the data only if necessary, so the application always\nspecifies native format, and the data written will be in big-endian format.\n\n@param value the data to be written, in native format.\n@returns true on successful write or false on failure; call GetError()\n         for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "WriteS64BE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "value",
                  "type": "Sint64"
                }
              ],
              "sourceName": "SDL_WriteS64BE"
            },
            "Close": {
              "doc": "Close and free an allocated IOStreamBase structure.\n\nIOStreamBase.Close() closes and cleans up the IOStreamBase stream. It releases any\nresources used by the stream and frees the IOStreamBase itself. This\nreturns true on success, or false if the stream failed to flush to its\noutput (e.g. to disk).\n\nNote that if this fails to flush the stream for any reason, this function\nreports an error, but the IOStreamBase is still invalid once this function\nreturns.\n\nThis call flushes any buffered writes to the operating system, but there\nare no guarantees that those writes have gone to physical media; they might\nbe in the OS's file cache, waiting to go to disk later. If it's absolutely\ncrucial that writes go to disk immediately, so they are definitely stored\neven if the power fails before the file cache would have caught up, one\nshould call IOStreamBase.Flush() before closing. Note that flushing takes time and\nmakes the system and your app operate less efficiently, so do so sparingly.\n\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa IOStreamBase.IOStreamBase",
              "name": "Close",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_CloseIO"
            }
          }
        },
        "ObjectRef<SDL_IOStream>::doFree": {
          "name": "ObjectRef<SDL_IOStream>::doFree",
          "type": "void",
          "kind": "function",
          "doc": "Callback for iOStream resource cleanup\n\n@private",
          "template": [],
          "parameters": [
            {
              "type": "SDL_IOStream *",
              "name": "resource"
            }
          ],
          "sourceName": "SDL_CloseIO"
        },
        "prop::IOStream": {
          "kind": "ns",
          "name": "prop::IOStream",
          "entries": {
            "WINDOWS_HANDLE_POINTER": {
              "doc": "",
              "name": "WINDOWS_HANDLE_POINTER",
              "kind": "var",
              "value": "\"SDL.iostream.windows.handle\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER"
            },
            "STDIO_FILE_POINTER": {
              "doc": "",
              "name": "STDIO_FILE_POINTER",
              "kind": "var",
              "value": "\"SDL.iostream.stdio.file\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_IOSTREAM_STDIO_FILE_POINTER"
            },
            "FILE_DESCRIPTOR_NUMBER": {
              "doc": "",
              "name": "FILE_DESCRIPTOR_NUMBER",
              "kind": "var",
              "value": "\"SDL.iostream.file_descriptor\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER"
            },
            "ANDROID_AASSET_POINTER": {
              "doc": "",
              "name": "ANDROID_AASSET_POINTER",
              "kind": "var",
              "value": "\"SDL.iostream.android.aasset\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER"
            },
            "MEMORY_POINTER": {
              "doc": "",
              "name": "MEMORY_POINTER",
              "kind": "var",
              "value": "\"SDL.iostream.memory.base\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_IOSTREAM_MEMORY_POINTER"
            },
            "MEMORY_SIZE_NUMBER": {
              "doc": "",
              "name": "MEMORY_SIZE_NUMBER",
              "kind": "var",
              "value": "\"SDL.iostream.memory.size\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_IOSTREAM_MEMORY_SIZE_NUMBER"
            },
            "DYNAMIC_MEMORY_POINTER": {
              "doc": "",
              "name": "DYNAMIC_MEMORY_POINTER",
              "kind": "var",
              "value": "\"SDL.iostream.dynamic.memory\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_IOSTREAM_DYNAMIC_MEMORY_POINTER"
            },
            "DYNAMIC_CHUNKSIZE_NUMBER": {
              "doc": "",
              "name": "DYNAMIC_CHUNKSIZE_NUMBER",
              "kind": "var",
              "value": "\"SDL.iostream.dynamic.chunksize\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_IOSTREAM_DYNAMIC_CHUNKSIZE_NUMBER"
            }
          },
          "doc": ""
        },
        "LoadFile": {
          "doc": "Load all the data from a file path.\n\nThe data is allocated with a zero byte at the end (null terminated) for\nconvenience. This extra byte is not included in the value reported via\n`datasize`.\n\nThe data should be freed with free().\n\n@param file the path to read all available data from.\n@param datasize if not nullptr, will store the number of bytes read.\n@returns the data or nullptr on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa IOStreamBase.LoadFile\n@sa SaveFile",
          "name": "LoadFile",
          "kind": "function",
          "type": "OwnArray<std::byte>",
          "parameters": [
            {
              "name": "file",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_LoadFile"
        },
        "SaveFile": [
          {
            "doc": "Save all the data into a file path.\n\n@param file the path to write all available data into.\n@param data the data to be written. If datasize is 0, may be nullptr or a\n            invalid pointer.\n@param datasize the number of bytes to be written.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa IOStreamBase.SaveFile\n@sa LoadFile",
            "name": "SaveFile",
            "kind": "function",
            "type": "bool",
            "parameters": [
              {
                "name": "file",
                "type": "StringParam"
              },
              {
                "name": "data",
                "type": "const void *"
              },
              {
                "name": "datasize",
                "type": "size_t"
              }
            ],
            "sourceName": "SDL_SaveFile"
          },
          {
            "kind": "function",
            "name": "SaveFile",
            "type": "bool",
            "template": [
              {
                "type": "class",
                "name": "T"
              }
            ],
            "parameters": [
              {
                "type": "StringParam",
                "name": "file"
              },
              {
                "type": "std::span<T>",
                "name": "data"
              }
            ],
            "doc": ""
          },
          {
            "kind": "function",
            "name": "SaveFile",
            "type": "bool",
            "parameters": [
              {
                "type": "StringParam",
                "name": "file"
              },
              {
                "type": "std::string_view",
                "name": "str"
              }
            ],
            "doc": ""
          }
        ]
      }
    },
    "SDL3pp_pixels.h": {
      "name": "SDL3pp_pixels.h",
      "doc": "@defgroup CategoryPixels Category Pixels\n\nSDL offers facilities for pixel management.\n\nLargely these facilities deal with pixel _format_: what does this set of\nbits represent?\n\nIf you mostly want to think of a pixel as some combination of red, green,\nblue, and maybe alpha intensities, this is all pretty straightforward, and\nin many cases, is enough information to build a perfectly fine game.\n\nHowever, the actual definition of a pixel is more complex than that:\n\nPixels are a representation of a color in a particular color space.\n\nThe first characteristic of a color space is the color type. SDL\nunderstands two different color types, RGB and YCbCr, or in SDL also\nreferred to as YUV.\n\nRGB colors consist of red, green, and blue channels of color that are added\ntogether to represent the colors we see on the screen.\n\nhttps://en.wikipedia.org/wiki/RGB_color_model\n\nYCbCr colors represent colors as a Y luma brightness component and red and\nblue chroma color offsets. This color representation takes advantage of the\nfact that the human eye is more sensitive to brightness than the color in\nan image. The Cb and Cr components are often compressed and have lower\nresolution than the luma component.\n\nhttps://en.wikipedia.org/wiki/YCbCr\n\nWhen the color information in YCbCr is compressed, the Y pixels are left at\nfull resolution and each Cr and Cb pixel represents an average of the color\ninformation in a block of Y pixels. The chroma location determines where in\nthat block of pixels the color information is coming from.\n\nThe color range defines how much of the pixel to use when converting a\npixel into a color on the display. When the full color range is used, the\nentire numeric range of the pixel bits is significant. When narrow color\nrange is used, for historical reasons, the pixel uses only a portion of the\nnumeric range to represent colors.\n\nThe color primaries and white point are a definition of the colors in the\ncolor space relative to the standard XYZ color space.\n\nhttps://en.wikipedia.org/wiki/CIE_1931_color_space\n\nThe transfer characteristic, or opto-electrical transfer function (OETF),\nis the way a color is converted from mathematically linear space into a\nnon-linear output signals.\n\nhttps://en.wikipedia.org/wiki/Rec._709#Transfer_characteristics\n\nThe matrix coefficients are used to convert between YCbCr and RGB colors.",
      "entries": {
        "Color-forward": {
          "name": "Color",
          "kind": "forward",
          "doc": ""
        },
        "PaletteBase-forward": {
          "name": "PaletteBase",
          "kind": "forward",
          "template": [
            {
              "type": "ObjectBox<SDL_Palette *>",
              "name": "T"
            }
          ],
          "doc": ""
        },
        "PaletteRef": {
          "name": "PaletteRef",
          "kind": "alias",
          "type": "PaletteBase<ObjectRef<SDL_Palette>>",
          "doc": "Handle to a non owned palette\n\n@cat resource\n\n@sa PaletteBase\n@sa Palette"
        },
        "Palette": {
          "name": "Palette",
          "kind": "alias",
          "type": "PaletteBase<ObjectUnique<SDL_Palette>>",
          "doc": "Handle to an owned palette\n\n@cat resource\n\n@sa PaletteBase\n@sa PaletteRef"
        },
        "SDL_ALPHA_OPAQUE": {
          "doc": "A fully opaque 8-bit alpha value.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_ALPHA_TRANSPARENT",
          "name": "SDL_ALPHA_OPAQUE",
          "kind": "def",
          "value": "255",
          "sourceName": "SDL_ALPHA_OPAQUE"
        },
        "SDL_ALPHA_OPAQUE_FLOAT": {
          "doc": "A fully opaque floating point alpha value.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_ALPHA_TRANSPARENT_FLOAT",
          "name": "SDL_ALPHA_OPAQUE_FLOAT",
          "kind": "def",
          "value": "1.0f",
          "sourceName": "SDL_ALPHA_OPAQUE_FLOAT"
        },
        "SDL_ALPHA_TRANSPARENT": {
          "doc": "A fully transparent 8-bit alpha value.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_ALPHA_OPAQUE",
          "name": "SDL_ALPHA_TRANSPARENT",
          "kind": "def",
          "value": "0",
          "sourceName": "SDL_ALPHA_TRANSPARENT"
        },
        "SDL_ALPHA_TRANSPARENT_FLOAT": {
          "doc": "A fully transparent floating point alpha value.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_ALPHA_OPAQUE_FLOAT",
          "name": "SDL_ALPHA_TRANSPARENT_FLOAT",
          "kind": "def",
          "value": "0.0f",
          "sourceName": "SDL_ALPHA_TRANSPARENT_FLOAT"
        },
        "PixelType": {
          "doc": "Pixel type.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "PixelType",
          "kind": "alias",
          "sourceName": "SDL_PixelType",
          "type": "SDL_PixelType"
        },
        "PIXELTYPE_UNKNOWN": {
          "doc": "",
          "name": "PIXELTYPE_UNKNOWN",
          "kind": "var",
          "type": "PixelType",
          "sourceName": "SDL_PIXELTYPE_UNKNOWN",
          "constexpr": true
        },
        "PIXELTYPE_INDEX1": {
          "doc": "",
          "name": "PIXELTYPE_INDEX1",
          "kind": "var",
          "type": "PixelType",
          "sourceName": "SDL_PIXELTYPE_INDEX1",
          "constexpr": true
        },
        "PIXELTYPE_INDEX4": {
          "doc": "",
          "name": "PIXELTYPE_INDEX4",
          "kind": "var",
          "type": "PixelType",
          "sourceName": "SDL_PIXELTYPE_INDEX4",
          "constexpr": true
        },
        "PIXELTYPE_INDEX8": {
          "doc": "",
          "name": "PIXELTYPE_INDEX8",
          "kind": "var",
          "type": "PixelType",
          "sourceName": "SDL_PIXELTYPE_INDEX8",
          "constexpr": true
        },
        "PIXELTYPE_PACKED8": {
          "doc": "",
          "name": "PIXELTYPE_PACKED8",
          "kind": "var",
          "type": "PixelType",
          "sourceName": "SDL_PIXELTYPE_PACKED8",
          "constexpr": true
        },
        "PIXELTYPE_PACKED16": {
          "doc": "",
          "name": "PIXELTYPE_PACKED16",
          "kind": "var",
          "type": "PixelType",
          "sourceName": "SDL_PIXELTYPE_PACKED16",
          "constexpr": true
        },
        "PIXELTYPE_PACKED32": {
          "doc": "",
          "name": "PIXELTYPE_PACKED32",
          "kind": "var",
          "type": "PixelType",
          "sourceName": "SDL_PIXELTYPE_PACKED32",
          "constexpr": true
        },
        "PIXELTYPE_ARRAYU8": {
          "doc": "",
          "name": "PIXELTYPE_ARRAYU8",
          "kind": "var",
          "type": "PixelType",
          "sourceName": "SDL_PIXELTYPE_ARRAYU8",
          "constexpr": true
        },
        "PIXELTYPE_ARRAYU16": {
          "doc": "",
          "name": "PIXELTYPE_ARRAYU16",
          "kind": "var",
          "type": "PixelType",
          "sourceName": "SDL_PIXELTYPE_ARRAYU16",
          "constexpr": true
        },
        "PIXELTYPE_ARRAYU32": {
          "doc": "",
          "name": "PIXELTYPE_ARRAYU32",
          "kind": "var",
          "type": "PixelType",
          "sourceName": "SDL_PIXELTYPE_ARRAYU32",
          "constexpr": true
        },
        "PIXELTYPE_ARRAYF16": {
          "doc": "",
          "name": "PIXELTYPE_ARRAYF16",
          "kind": "var",
          "type": "PixelType",
          "sourceName": "SDL_PIXELTYPE_ARRAYF16",
          "constexpr": true
        },
        "PIXELTYPE_ARRAYF32": {
          "doc": "",
          "name": "PIXELTYPE_ARRAYF32",
          "kind": "var",
          "type": "PixelType",
          "sourceName": "SDL_PIXELTYPE_ARRAYF32",
          "constexpr": true
        },
        "PIXELTYPE_INDEX2": {
          "doc": "",
          "name": "PIXELTYPE_INDEX2",
          "kind": "var",
          "type": "PixelType",
          "sourceName": "SDL_PIXELTYPE_INDEX2",
          "constexpr": true
        },
        "BitmapOrder": {
          "doc": "Bitmap pixel order, high bit -> low bit.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "BitmapOrder",
          "kind": "alias",
          "sourceName": "SDL_BitmapOrder",
          "type": "SDL_BitmapOrder"
        },
        "BITMAPORDER_NONE": {
          "doc": "",
          "name": "BITMAPORDER_NONE",
          "kind": "var",
          "type": "BitmapOrder",
          "sourceName": "SDL_BITMAPORDER_NONE",
          "constexpr": true
        },
        "BITMAPORDER_4321": {
          "doc": "",
          "name": "BITMAPORDER_4321",
          "kind": "var",
          "type": "BitmapOrder",
          "sourceName": "SDL_BITMAPORDER_4321",
          "constexpr": true
        },
        "BITMAPORDER_1234": {
          "doc": "",
          "name": "BITMAPORDER_1234",
          "kind": "var",
          "type": "BitmapOrder",
          "sourceName": "SDL_BITMAPORDER_1234",
          "constexpr": true
        },
        "PackedOrder": {
          "doc": "Packed component order, high bit -> low bit.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "PackedOrder",
          "kind": "alias",
          "sourceName": "SDL_PackedOrder",
          "type": "SDL_PackedOrder"
        },
        "PACKEDORDER_NONE": {
          "doc": "",
          "name": "PACKEDORDER_NONE",
          "kind": "var",
          "type": "PackedOrder",
          "sourceName": "SDL_PACKEDORDER_NONE",
          "constexpr": true
        },
        "PACKEDORDER_XRGB": {
          "doc": "",
          "name": "PACKEDORDER_XRGB",
          "kind": "var",
          "type": "PackedOrder",
          "sourceName": "SDL_PACKEDORDER_XRGB",
          "constexpr": true
        },
        "PACKEDORDER_RGBX": {
          "doc": "",
          "name": "PACKEDORDER_RGBX",
          "kind": "var",
          "type": "PackedOrder",
          "sourceName": "SDL_PACKEDORDER_RGBX",
          "constexpr": true
        },
        "PACKEDORDER_ARGB": {
          "doc": "",
          "name": "PACKEDORDER_ARGB",
          "kind": "var",
          "type": "PackedOrder",
          "sourceName": "SDL_PACKEDORDER_ARGB",
          "constexpr": true
        },
        "PACKEDORDER_RGBA": {
          "doc": "",
          "name": "PACKEDORDER_RGBA",
          "kind": "var",
          "type": "PackedOrder",
          "sourceName": "SDL_PACKEDORDER_RGBA",
          "constexpr": true
        },
        "PACKEDORDER_XBGR": {
          "doc": "",
          "name": "PACKEDORDER_XBGR",
          "kind": "var",
          "type": "PackedOrder",
          "sourceName": "SDL_PACKEDORDER_XBGR",
          "constexpr": true
        },
        "PACKEDORDER_BGRX": {
          "doc": "",
          "name": "PACKEDORDER_BGRX",
          "kind": "var",
          "type": "PackedOrder",
          "sourceName": "SDL_PACKEDORDER_BGRX",
          "constexpr": true
        },
        "PACKEDORDER_ABGR": {
          "doc": "",
          "name": "PACKEDORDER_ABGR",
          "kind": "var",
          "type": "PackedOrder",
          "sourceName": "SDL_PACKEDORDER_ABGR",
          "constexpr": true
        },
        "PACKEDORDER_BGRA": {
          "doc": "",
          "name": "PACKEDORDER_BGRA",
          "kind": "var",
          "type": "PackedOrder",
          "sourceName": "SDL_PACKEDORDER_BGRA",
          "constexpr": true
        },
        "ArrayOrder": {
          "doc": "Array component order, low byte -> high byte.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "ArrayOrder",
          "kind": "alias",
          "sourceName": "SDL_ArrayOrder",
          "type": "SDL_ArrayOrder"
        },
        "ARRAYORDER_NONE": {
          "doc": "",
          "name": "ARRAYORDER_NONE",
          "kind": "var",
          "type": "ArrayOrder",
          "sourceName": "SDL_ARRAYORDER_NONE",
          "constexpr": true
        },
        "ARRAYORDER_RGB": {
          "doc": "",
          "name": "ARRAYORDER_RGB",
          "kind": "var",
          "type": "ArrayOrder",
          "sourceName": "SDL_ARRAYORDER_RGB",
          "constexpr": true
        },
        "ARRAYORDER_RGBA": {
          "doc": "",
          "name": "ARRAYORDER_RGBA",
          "kind": "var",
          "type": "ArrayOrder",
          "sourceName": "SDL_ARRAYORDER_RGBA",
          "constexpr": true
        },
        "ARRAYORDER_ARGB": {
          "doc": "",
          "name": "ARRAYORDER_ARGB",
          "kind": "var",
          "type": "ArrayOrder",
          "sourceName": "SDL_ARRAYORDER_ARGB",
          "constexpr": true
        },
        "ARRAYORDER_BGR": {
          "doc": "",
          "name": "ARRAYORDER_BGR",
          "kind": "var",
          "type": "ArrayOrder",
          "sourceName": "SDL_ARRAYORDER_BGR",
          "constexpr": true
        },
        "ARRAYORDER_BGRA": {
          "doc": "",
          "name": "ARRAYORDER_BGRA",
          "kind": "var",
          "type": "ArrayOrder",
          "sourceName": "SDL_ARRAYORDER_BGRA",
          "constexpr": true
        },
        "ARRAYORDER_ABGR": {
          "doc": "",
          "name": "ARRAYORDER_ABGR",
          "kind": "var",
          "type": "ArrayOrder",
          "sourceName": "SDL_ARRAYORDER_ABGR",
          "constexpr": true
        },
        "PackedLayout": {
          "doc": "Packed component layout.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "PackedLayout",
          "kind": "alias",
          "sourceName": "SDL_PackedLayout",
          "type": "SDL_PackedLayout"
        },
        "PACKEDLAYOUT_NONE": {
          "doc": "",
          "name": "PACKEDLAYOUT_NONE",
          "kind": "var",
          "type": "PackedLayout",
          "sourceName": "SDL_PACKEDLAYOUT_NONE",
          "constexpr": true
        },
        "PACKEDLAYOUT_332": {
          "doc": "",
          "name": "PACKEDLAYOUT_332",
          "kind": "var",
          "type": "PackedLayout",
          "sourceName": "SDL_PACKEDLAYOUT_332",
          "constexpr": true
        },
        "PACKEDLAYOUT_4444": {
          "doc": "",
          "name": "PACKEDLAYOUT_4444",
          "kind": "var",
          "type": "PackedLayout",
          "sourceName": "SDL_PACKEDLAYOUT_4444",
          "constexpr": true
        },
        "PACKEDLAYOUT_1555": {
          "doc": "",
          "name": "PACKEDLAYOUT_1555",
          "kind": "var",
          "type": "PackedLayout",
          "sourceName": "SDL_PACKEDLAYOUT_1555",
          "constexpr": true
        },
        "PACKEDLAYOUT_5551": {
          "doc": "",
          "name": "PACKEDLAYOUT_5551",
          "kind": "var",
          "type": "PackedLayout",
          "sourceName": "SDL_PACKEDLAYOUT_5551",
          "constexpr": true
        },
        "PACKEDLAYOUT_565": {
          "doc": "",
          "name": "PACKEDLAYOUT_565",
          "kind": "var",
          "type": "PackedLayout",
          "sourceName": "SDL_PACKEDLAYOUT_565",
          "constexpr": true
        },
        "PACKEDLAYOUT_8888": {
          "doc": "",
          "name": "PACKEDLAYOUT_8888",
          "kind": "var",
          "type": "PackedLayout",
          "sourceName": "SDL_PACKEDLAYOUT_8888",
          "constexpr": true
        },
        "PACKEDLAYOUT_2101010": {
          "doc": "",
          "name": "PACKEDLAYOUT_2101010",
          "kind": "var",
          "type": "PackedLayout",
          "sourceName": "SDL_PACKEDLAYOUT_2101010",
          "constexpr": true
        },
        "PACKEDLAYOUT_1010102": {
          "doc": "",
          "name": "PACKEDLAYOUT_1010102",
          "kind": "var",
          "type": "PackedLayout",
          "sourceName": "SDL_PACKEDLAYOUT_1010102",
          "constexpr": true
        },
        "PixelFormatDetails": {
          "doc": "Details about the format of a pixel.\n\n@since This struct is available since SDL 3.2.0.",
          "name": "PixelFormatDetails",
          "kind": "alias",
          "sourceName": "SDL_PixelFormatDetails",
          "type": "SDL_PixelFormatDetails"
        },
        "SDL_DEFINE_PIXELFOURCC": {
          "doc": "A macro for defining custom FourCC pixel formats.\n\nFor example, defining PIXELFORMAT_YV12 looks like this:\n\n```c\nSDL_DEFINE_PIXELFOURCC('Y', 'V', '1', '2')\n```\n\n@param A the first character of the FourCC code.\n@param B the second character of the FourCC code.\n@param C the third character of the FourCC code.\n@param D the fourth character of the FourCC code.\n@returns a format value in the style of PixelFormat.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_DEFINE_PIXELFOURCC",
          "kind": "def",
          "parameters": [
            "A",
            "B",
            "C",
            "D"
          ],
          "value": "SDL_FOURCC(A, B, C, D)",
          "sourceName": "SDL_DEFINE_PIXELFOURCC"
        },
        "SDL_PIXELFLAG": {
          "doc": "A macro to retrieve the flags of an PixelFormat.\n\nThis macro is generally not needed directly by an app, which should use\nspecific tests, like SDL_ISPIXELFORMAT_FOURCC, instead.\n\n@param format an PixelFormat to check.\n@returns the flags of `format`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_PIXELFLAG",
          "kind": "def",
          "parameters": [
            "format"
          ],
          "value": "(((format) >> 28) & 0x0F)",
          "sourceName": "SDL_PIXELFLAG"
        },
        "PixelFormat": {
          "doc": "Pixel format.\n\nSDL's pixel formats have the following naming convention:\n\n- Names with a list of components and a single bit count, such as RGB24 and\n  ABGR32, define a platform-independent encoding into bytes in the order\n  specified. For example, in RGB24 data, each pixel is encoded in 3 bytes\n  (red, green, blue) in that order, and in ABGR32 data, each pixel is\n  encoded in 4 bytes alpha, blue, green, red) in that order. Use these\n  names if the property of a format that is important to you is the order\n  of the bytes in memory or on disk.\n- Names with a bit count per component, such as ARGB8888 and XRGB1555, are\n  \"packed\" into an appropriately-sized integer in the platform's native\n  endianness. For example, ARGB8888 is a sequence of 32-bit integers; in\n  each integer, the most significant bits are alpha, and the least\n  significant bits are blue. On a little-endian CPU such as x86, the least\n  significant bits of each integer are arranged first in memory, but on a\n  big-endian CPU such as s390x, the most significant bits are arranged\n  first. Use these names if the property of a format that is important to\n  you is the meaning of each bit position within a native-endianness\n  integer.\n- In indexed formats such as INDEX4LSB, each pixel is represented by\n  encoding an index into the palette into the indicated number of bits,\n  with multiple pixels packed into each byte if appropriate. In LSB\n  formats, the first (leftmost) pixel is stored in the least-significant\n  bits of the byte; in MSB formats, it's stored in the most-significant\n  bits. INDEX8 does not need LSB/MSB variants, because each pixel exactly\n  fills one byte.\n\nThe 32-bit byte-array encodings such as RGBA32 are aliases for the\nappropriate 8888 encoding for the current platform. For example, RGBA32 is\nan alias for ABGR8888 on little-endian CPUs like x86, or an alias for\nRGBA8888 on big-endian CPUs.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "PixelFormat",
          "kind": "struct",
          "sourceName": "SDL_PixelFormat",
          "type": "",
          "entries": {
            "format": {
              "kind": "var",
              "type": "SDL_PixelFormat",
              "name": "format",
              "doc": ""
            },
            "PixelFormat": [
              {
                "kind": "function",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "SDL_PixelFormat",
                    "name": "format",
                    "default": "SDL_PIXELFORMAT_UNKNOWN"
                  }
                ],
                "name": "PixelFormat",
                "doc": ""
              },
              {
                "doc": "A macro for defining custom non-FourCC pixel formats.\n\nFor example, defining PIXELFORMAT_RGBA8888 looks like this:\n\n```c\nSDL_DEFINE_PIXELFORMAT(PIXELTYPE_PACKED32, PACKEDORDER_RGBA, PACKEDLAYOUT_8888, 32, 4)\n```\n\n@param type the type of the new format, probably a PixelType value.\n@param order the order of the new format, probably a BitmapOrder,\n             PackedOrder, or ArrayOrder value.\n@param layout the layout of the new format, probably an PackedLayout\n              value or zero.\n@param bits the number of bits per pixel of the new format.\n@param bytes the number of bytes per pixel of the new format.\n@returns a format value in the style of PixelFormat.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
                "name": "PixelFormat",
                "kind": "function",
                "parameters": [
                  {
                    "type": "SDL_PixelType",
                    "name": "type"
                  },
                  {
                    "type": "int",
                    "name": "order"
                  },
                  {
                    "type": "SDL_PackedLayout",
                    "name": "layout"
                  },
                  {
                    "type": "int",
                    "name": "bits"
                  },
                  {
                    "type": "int",
                    "name": "bytes"
                  }
                ],
                "value": "    ((1 << 28) | ((type) << 24) | ((order) << 20) | ((layout) << 16) | \\\n     ((bits) << 8) | ((bytes) << 0))",
                "sourceName": "SDL_DEFINE_PIXELFORMAT",
                "type": "",
                "constexpr": true
              }
            ],
            "operator bool": {
              "kind": "function",
              "parameters": [],
              "type": "",
              "immutable": true,
              "constexpr": true,
              "name": "operator bool",
              "doc": ""
            },
            "operator SDL_PixelFormat": {
              "kind": "function",
              "parameters": [],
              "type": "",
              "immutable": true,
              "constexpr": true,
              "name": "operator SDL_PixelFormat",
              "doc": ""
            },
            "GetType": {
              "doc": "A macro to retrieve the type of an PixelFormat.\n\nThis is usually a value from the PixelType enumeration.\n\n@param format an PixelFormat to check.\n@returns the type of `format`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
              "name": "GetType",
              "kind": "function",
              "parameters": [],
              "value": "(((format) >> 24) & 0x0F)",
              "sourceName": "SDL_PIXELTYPE",
              "type": "PixelType",
              "immutable": true,
              "constexpr": true
            },
            "GetOrder": {
              "doc": "A macro to retrieve the order of an PixelFormat.\n\nThis is usually a value from the BitmapOrder, PackedOrder, or\nArrayOrder enumerations, depending on the format type.\n\n@param format an PixelFormat to check.\n@returns the order of `format`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
              "name": "GetOrder",
              "kind": "function",
              "parameters": [],
              "value": "(((format) >> 20) & 0x0F)",
              "sourceName": "SDL_PIXELORDER",
              "type": "int",
              "immutable": true,
              "constexpr": true
            },
            "GetLayout": {
              "doc": "A macro to retrieve the layout of an PixelFormat.\n\nThis is usually a value from the PackedLayout enumeration, or zero if a\nlayout doesn't make sense for the format type.\n\n@param format an PixelFormat to check.\n@returns the layout of `format`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
              "name": "GetLayout",
              "kind": "function",
              "parameters": [],
              "value": "(((format) >> 16) & 0x0F)",
              "sourceName": "SDL_PIXELLAYOUT",
              "type": "PackedLayout",
              "immutable": true,
              "constexpr": true
            },
            "GetBitsPerPixel": {
              "doc": "A macro to determine an PixelFormat's bits per pixel.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\nFourCC formats will report zero here, as it rarely makes sense to measure\nthem per-pixel.\n\n@param format an PixelFormat to check.\n@returns the bits-per-pixel of `format`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_BYTESPERPIXEL",
              "name": "GetBitsPerPixel",
              "kind": "function",
              "parameters": [],
              "value": "    (SDL_ISPIXELFORMAT_FOURCC(format) ? 0 : (((format) >> 8) & 0xFF))",
              "sourceName": "SDL_BITSPERPIXEL",
              "type": "int",
              "immutable": true,
              "constexpr": true
            },
            "GetBytesPerPixel": {
              "doc": "A macro to determine an PixelFormat's bytes per pixel.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\nFourCC formats do their best here, but many of them don't have a meaningful\nmeasurement of bytes per pixel.\n\n@param format an PixelFormat to check.\n@returns the bytes-per-pixel of `format`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_BITSPERPIXEL",
              "name": "GetBytesPerPixel",
              "kind": "function",
              "parameters": [],
              "value": "    (SDL_ISPIXELFORMAT_FOURCC(format) ? \\\n        ((((format) == SDL_PIXELFORMAT_YUY2) || \\\n          ((format) == SDL_PIXELFORMAT_UYVY) || \\\n          ((format) == SDL_PIXELFORMAT_YVYU) || \\\n          ((format) == SDL_PIXELFORMAT_P010)) ? 2 : 1) : (((format) >> 0) & 0xFF))",
              "sourceName": "SDL_BYTESPERPIXEL",
              "type": "int",
              "immutable": true,
              "constexpr": true
            },
            "IsIndexed": {
              "doc": "A macro to determine if an PixelFormat is an indexed format.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n@param format an PixelFormat to check.\n@returns true if the format is indexed, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
              "name": "IsIndexed",
              "kind": "function",
              "parameters": [],
              "value": "    (!SDL_ISPIXELFORMAT_FOURCC(format) && \\\n     ((SDL_PIXELTYPE(format) == SDL_PIXELTYPE_INDEX1) || \\\n      (SDL_PIXELTYPE(format) == SDL_PIXELTYPE_INDEX2) || \\\n      (SDL_PIXELTYPE(format) == SDL_PIXELTYPE_INDEX4) || \\\n      (SDL_PIXELTYPE(format) == SDL_PIXELTYPE_INDEX8)))",
              "sourceName": "SDL_ISPIXELFORMAT_INDEXED",
              "type": "bool",
              "immutable": true,
              "constexpr": true
            },
            "IsPacked": {
              "doc": "A macro to determine if an PixelFormat is a packed format.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n@param format an PixelFormat to check.\n@returns true if the format is packed, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
              "name": "IsPacked",
              "kind": "function",
              "parameters": [],
              "value": "    (!SDL_ISPIXELFORMAT_FOURCC(format) && \\\n     ((SDL_PIXELTYPE(format) == SDL_PIXELTYPE_PACKED8) || \\\n      (SDL_PIXELTYPE(format) == SDL_PIXELTYPE_PACKED16) || \\\n      (SDL_PIXELTYPE(format) == SDL_PIXELTYPE_PACKED32)))",
              "sourceName": "SDL_ISPIXELFORMAT_PACKED",
              "type": "bool",
              "immutable": true,
              "constexpr": true
            },
            "IsArray": {
              "doc": "A macro to determine if an PixelFormat is an array format.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n@param format an PixelFormat to check.\n@returns true if the format is an array, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
              "name": "IsArray",
              "kind": "function",
              "parameters": [],
              "value": "    (!SDL_ISPIXELFORMAT_FOURCC(format) && \\\n     ((SDL_PIXELTYPE(format) == SDL_PIXELTYPE_ARRAYU8) || \\\n      (SDL_PIXELTYPE(format) == SDL_PIXELTYPE_ARRAYU16) || \\\n      (SDL_PIXELTYPE(format) == SDL_PIXELTYPE_ARRAYU32) || \\\n      (SDL_PIXELTYPE(format) == SDL_PIXELTYPE_ARRAYF16) || \\\n      (SDL_PIXELTYPE(format) == SDL_PIXELTYPE_ARRAYF32)))",
              "sourceName": "SDL_ISPIXELFORMAT_ARRAY",
              "type": "bool",
              "immutable": true,
              "constexpr": true
            },
            "Is10Bit": {
              "doc": "A macro to determine if an PixelFormat is a 10-bit format.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n@param format an PixelFormat to check.\n@returns true if the format is 10-bit, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
              "name": "Is10Bit",
              "kind": "function",
              "parameters": [],
              "value": "      (!SDL_ISPIXELFORMAT_FOURCC(format) && \\\n       ((SDL_PIXELTYPE(format) == SDL_PIXELTYPE_PACKED32) && \\\n        (SDL_PIXELLAYOUT(format) == SDL_PACKEDLAYOUT_2101010)))",
              "sourceName": "SDL_ISPIXELFORMAT_10BIT",
              "type": "bool",
              "immutable": true,
              "constexpr": true
            },
            "IsFloat": {
              "doc": "A macro to determine if an PixelFormat is a floating point format.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n@param format an PixelFormat to check.\n@returns true if the format is 10-bit, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
              "name": "IsFloat",
              "kind": "function",
              "parameters": [],
              "value": "      (!SDL_ISPIXELFORMAT_FOURCC(format) && \\\n       ((SDL_PIXELTYPE(format) == SDL_PIXELTYPE_ARRAYF16) || \\\n        (SDL_PIXELTYPE(format) == SDL_PIXELTYPE_ARRAYF32)))",
              "sourceName": "SDL_ISPIXELFORMAT_FLOAT",
              "type": "bool",
              "immutable": true,
              "constexpr": true
            },
            "IsAlpha": {
              "doc": "A macro to determine if an PixelFormat has an alpha channel.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n@param format an PixelFormat to check.\n@returns true if the format has alpha, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
              "name": "IsAlpha",
              "kind": "function",
              "parameters": [],
              "value": "    ((SDL_ISPIXELFORMAT_PACKED(format) && \\\n      ((SDL_PIXELORDER(format) == SDL_PACKEDORDER_ARGB) || \\\n       (SDL_PIXELORDER(format) == SDL_PACKEDORDER_RGBA) || \\\n       (SDL_PIXELORDER(format) == SDL_PACKEDORDER_ABGR) || \\\n       (SDL_PIXELORDER(format) == SDL_PACKEDORDER_BGRA))) || \\\n     (SDL_ISPIXELFORMAT_ARRAY(format) && \\\n      ((SDL_PIXELORDER(format) == SDL_ARRAYORDER_ARGB) || \\\n       (SDL_PIXELORDER(format) == SDL_ARRAYORDER_RGBA) || \\\n       (SDL_PIXELORDER(format) == SDL_ARRAYORDER_ABGR) || \\\n       (SDL_PIXELORDER(format) == SDL_ARRAYORDER_BGRA))))",
              "sourceName": "SDL_ISPIXELFORMAT_ALPHA",
              "type": "bool",
              "immutable": true,
              "constexpr": true
            },
            "IsFourCC": {
              "doc": "A macro to determine if an PixelFormat is a \"FourCC\" format.\n\nThis covers custom and other unusual formats.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n@param format an PixelFormat to check.\n@returns true if the format has alpha, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
              "name": "IsFourCC",
              "kind": "function",
              "parameters": [],
              "value": "    /* The flag is set to 1 because 0x1? is not in the printable ASCII range */ \\\n    ((format) && (SDL_PIXELFLAG(format) != 1))",
              "sourceName": "SDL_ISPIXELFORMAT_FOURCC",
              "type": "bool",
              "immutable": true,
              "constexpr": true
            },
            "GetName": {
              "doc": "Get the human readable name of a pixel format.\n\n@returns the human readable name of the specified pixel format or\n         \"PIXELFORMAT_UNKNOWN\" if the format isn't recognized.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetName",
              "kind": "function",
              "type": "const char *",
              "parameters": [],
              "sourceName": "SDL_GetPixelFormatName",
              "immutable": true
            },
            "GetMasks": {
              "doc": "Convert one of the enumerated pixel formats to a bpp value and RGBA masks.\n\n@param bpp a bits per pixel value; usually 15, 16, or 32.\n@param Rmask a pointer filled in with the red mask for the format.\n@param Gmask a pointer filled in with the green mask for the format.\n@param Bmask a pointer filled in with the blue mask for the format.\n@param Amask a pointer filled in with the alpha mask for the format.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PixelFormat.ForMasks",
              "name": "GetMasks",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "bpp",
                  "type": "int *"
                },
                {
                  "name": "Rmask",
                  "type": "Uint32 *"
                },
                {
                  "name": "Gmask",
                  "type": "Uint32 *"
                },
                {
                  "name": "Bmask",
                  "type": "Uint32 *"
                },
                {
                  "name": "Amask",
                  "type": "Uint32 *"
                }
              ],
              "sourceName": "SDL_GetMasksForPixelFormat",
              "immutable": true
            },
            "ForMasks": {
              "doc": "Convert a bpp value and RGBA masks to an enumerated pixel format.\n\nThis will return `PIXELFORMAT_UNKNOWN` if the conversion wasn't\npossible.\n\n@param bpp a bits per pixel value; usually 15, 16, or 32.\n@param Rmask the red mask for the format.\n@param Gmask the green mask for the format.\n@param Bmask the blue mask for the format.\n@param Amask the alpha mask for the format.\n@returns the PixelFormat value corresponding to the format masks, or\n         PIXELFORMAT_UNKNOWN if there isn't a match.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PixelFormat.GetMasks",
              "name": "ForMasks",
              "kind": "function",
              "type": "PixelFormat",
              "parameters": [
                {
                  "name": "bpp",
                  "type": "int"
                },
                {
                  "name": "Rmask",
                  "type": "Uint32"
                },
                {
                  "name": "Gmask",
                  "type": "Uint32"
                },
                {
                  "name": "Bmask",
                  "type": "Uint32"
                },
                {
                  "name": "Amask",
                  "type": "Uint32"
                }
              ],
              "sourceName": "SDL_GetPixelFormatForMasks",
              "static": true
            },
            "GetDetails": {
              "doc": "Create an PixelFormatDetails structure corresponding to a pixel format.\n\nReturned structure may come from a shared global cache (i.e. not newly\nallocated), and hence should not be modified, especially the palette. Weird\nerrors such as `Blit combination not supported` may occur.\n\n@returns a pointer to a PixelFormatDetails structure or nullptr on\n         failure; call GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetDetails",
              "kind": "function",
              "type": "const PixelFormatDetails *",
              "parameters": [],
              "sourceName": "SDL_GetPixelFormatDetails",
              "immutable": true
            },
            "Map": {
              "kind": "function",
              "type": "Uint32",
              "immutable": true,
              "parameters": [
                {
                  "type": "Color",
                  "name": "color"
                },
                {
                  "type": "PaletteRef",
                  "name": "palette"
                }
              ],
              "name": "Map",
              "doc": ""
            },
            "Get": {
              "kind": "function",
              "type": "Color",
              "immutable": true,
              "parameters": [
                {
                  "type": "Uint32",
                  "name": "pixel"
                },
                {
                  "type": "PaletteRef",
                  "name": "palette"
                }
              ],
              "name": "Get",
              "doc": ""
            }
          }
        },
        "PIXELFORMAT_UNKNOWN": {
          "doc": "",
          "name": "PIXELFORMAT_UNKNOWN",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_UNKNOWN",
          "constexpr": true
        },
        "PIXELFORMAT_INDEX1LSB": {
          "doc": "",
          "name": "PIXELFORMAT_INDEX1LSB",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_INDEX1LSB",
          "constexpr": true
        },
        "PIXELFORMAT_INDEX1MSB": {
          "doc": "",
          "name": "PIXELFORMAT_INDEX1MSB",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_INDEX1MSB",
          "constexpr": true
        },
        "PIXELFORMAT_INDEX2LSB": {
          "doc": "",
          "name": "PIXELFORMAT_INDEX2LSB",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_INDEX2LSB",
          "constexpr": true
        },
        "PIXELFORMAT_INDEX2MSB": {
          "doc": "",
          "name": "PIXELFORMAT_INDEX2MSB",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_INDEX2MSB",
          "constexpr": true
        },
        "PIXELFORMAT_INDEX4LSB": {
          "doc": "",
          "name": "PIXELFORMAT_INDEX4LSB",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_INDEX4LSB",
          "constexpr": true
        },
        "PIXELFORMAT_INDEX4MSB": {
          "doc": "",
          "name": "PIXELFORMAT_INDEX4MSB",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_INDEX4MSB",
          "constexpr": true
        },
        "PIXELFORMAT_INDEX8": {
          "doc": "",
          "name": "PIXELFORMAT_INDEX8",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_INDEX8",
          "constexpr": true
        },
        "PIXELFORMAT_RGB332": {
          "doc": "",
          "name": "PIXELFORMAT_RGB332",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_RGB332",
          "constexpr": true
        },
        "PIXELFORMAT_XRGB4444": {
          "doc": "",
          "name": "PIXELFORMAT_XRGB4444",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_XRGB4444",
          "constexpr": true
        },
        "PIXELFORMAT_XBGR4444": {
          "doc": "",
          "name": "PIXELFORMAT_XBGR4444",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_XBGR4444",
          "constexpr": true
        },
        "PIXELFORMAT_XRGB1555": {
          "doc": "",
          "name": "PIXELFORMAT_XRGB1555",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_XRGB1555",
          "constexpr": true
        },
        "PIXELFORMAT_XBGR1555": {
          "doc": "",
          "name": "PIXELFORMAT_XBGR1555",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_XBGR1555",
          "constexpr": true
        },
        "PIXELFORMAT_ARGB4444": {
          "doc": "",
          "name": "PIXELFORMAT_ARGB4444",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_ARGB4444",
          "constexpr": true
        },
        "PIXELFORMAT_RGBA4444": {
          "doc": "",
          "name": "PIXELFORMAT_RGBA4444",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_RGBA4444",
          "constexpr": true
        },
        "PIXELFORMAT_ABGR4444": {
          "doc": "",
          "name": "PIXELFORMAT_ABGR4444",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_ABGR4444",
          "constexpr": true
        },
        "PIXELFORMAT_BGRA4444": {
          "doc": "",
          "name": "PIXELFORMAT_BGRA4444",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_BGRA4444",
          "constexpr": true
        },
        "PIXELFORMAT_ARGB1555": {
          "doc": "",
          "name": "PIXELFORMAT_ARGB1555",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_ARGB1555",
          "constexpr": true
        },
        "PIXELFORMAT_RGBA5551": {
          "doc": "",
          "name": "PIXELFORMAT_RGBA5551",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_RGBA5551",
          "constexpr": true
        },
        "PIXELFORMAT_ABGR1555": {
          "doc": "",
          "name": "PIXELFORMAT_ABGR1555",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_ABGR1555",
          "constexpr": true
        },
        "PIXELFORMAT_BGRA5551": {
          "doc": "",
          "name": "PIXELFORMAT_BGRA5551",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_BGRA5551",
          "constexpr": true
        },
        "PIXELFORMAT_RGB565": {
          "doc": "",
          "name": "PIXELFORMAT_RGB565",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_RGB565",
          "constexpr": true
        },
        "PIXELFORMAT_BGR565": {
          "doc": "",
          "name": "PIXELFORMAT_BGR565",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_BGR565",
          "constexpr": true
        },
        "PIXELFORMAT_RGB24": {
          "doc": "",
          "name": "PIXELFORMAT_RGB24",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_RGB24",
          "constexpr": true
        },
        "PIXELFORMAT_BGR24": {
          "doc": "",
          "name": "PIXELFORMAT_BGR24",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_BGR24",
          "constexpr": true
        },
        "PIXELFORMAT_XRGB8888": {
          "doc": "",
          "name": "PIXELFORMAT_XRGB8888",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_XRGB8888",
          "constexpr": true
        },
        "PIXELFORMAT_RGBX8888": {
          "doc": "",
          "name": "PIXELFORMAT_RGBX8888",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_RGBX8888",
          "constexpr": true
        },
        "PIXELFORMAT_XBGR8888": {
          "doc": "",
          "name": "PIXELFORMAT_XBGR8888",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_XBGR8888",
          "constexpr": true
        },
        "PIXELFORMAT_BGRX8888": {
          "doc": "",
          "name": "PIXELFORMAT_BGRX8888",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_BGRX8888",
          "constexpr": true
        },
        "PIXELFORMAT_ARGB8888": {
          "doc": "",
          "name": "PIXELFORMAT_ARGB8888",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_ARGB8888",
          "constexpr": true
        },
        "PIXELFORMAT_RGBA8888": {
          "doc": "",
          "name": "PIXELFORMAT_RGBA8888",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_RGBA8888",
          "constexpr": true
        },
        "PIXELFORMAT_ABGR8888": {
          "doc": "",
          "name": "PIXELFORMAT_ABGR8888",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_ABGR8888",
          "constexpr": true
        },
        "PIXELFORMAT_BGRA8888": {
          "doc": "",
          "name": "PIXELFORMAT_BGRA8888",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_BGRA8888",
          "constexpr": true
        },
        "PIXELFORMAT_XRGB2101010": {
          "doc": "",
          "name": "PIXELFORMAT_XRGB2101010",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_XRGB2101010",
          "constexpr": true
        },
        "PIXELFORMAT_XBGR2101010": {
          "doc": "",
          "name": "PIXELFORMAT_XBGR2101010",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_XBGR2101010",
          "constexpr": true
        },
        "PIXELFORMAT_ARGB2101010": {
          "doc": "",
          "name": "PIXELFORMAT_ARGB2101010",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_ARGB2101010",
          "constexpr": true
        },
        "PIXELFORMAT_ABGR2101010": {
          "doc": "",
          "name": "PIXELFORMAT_ABGR2101010",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_ABGR2101010",
          "constexpr": true
        },
        "PIXELFORMAT_RGB48": {
          "doc": "",
          "name": "PIXELFORMAT_RGB48",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_RGB48",
          "constexpr": true
        },
        "PIXELFORMAT_BGR48": {
          "doc": "",
          "name": "PIXELFORMAT_BGR48",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_BGR48",
          "constexpr": true
        },
        "PIXELFORMAT_RGBA64": {
          "doc": "",
          "name": "PIXELFORMAT_RGBA64",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_RGBA64",
          "constexpr": true
        },
        "PIXELFORMAT_ARGB64": {
          "doc": "",
          "name": "PIXELFORMAT_ARGB64",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_ARGB64",
          "constexpr": true
        },
        "PIXELFORMAT_BGRA64": {
          "doc": "",
          "name": "PIXELFORMAT_BGRA64",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_BGRA64",
          "constexpr": true
        },
        "PIXELFORMAT_ABGR64": {
          "doc": "",
          "name": "PIXELFORMAT_ABGR64",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_ABGR64",
          "constexpr": true
        },
        "PIXELFORMAT_RGB48_FLOAT": {
          "doc": "",
          "name": "PIXELFORMAT_RGB48_FLOAT",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_RGB48_FLOAT",
          "constexpr": true
        },
        "PIXELFORMAT_BGR48_FLOAT": {
          "doc": "",
          "name": "PIXELFORMAT_BGR48_FLOAT",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_BGR48_FLOAT",
          "constexpr": true
        },
        "PIXELFORMAT_RGBA64_FLOAT": {
          "doc": "",
          "name": "PIXELFORMAT_RGBA64_FLOAT",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_RGBA64_FLOAT",
          "constexpr": true
        },
        "PIXELFORMAT_ARGB64_FLOAT": {
          "doc": "",
          "name": "PIXELFORMAT_ARGB64_FLOAT",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_ARGB64_FLOAT",
          "constexpr": true
        },
        "PIXELFORMAT_BGRA64_FLOAT": {
          "doc": "",
          "name": "PIXELFORMAT_BGRA64_FLOAT",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_BGRA64_FLOAT",
          "constexpr": true
        },
        "PIXELFORMAT_ABGR64_FLOAT": {
          "doc": "",
          "name": "PIXELFORMAT_ABGR64_FLOAT",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_ABGR64_FLOAT",
          "constexpr": true
        },
        "PIXELFORMAT_RGB96_FLOAT": {
          "doc": "",
          "name": "PIXELFORMAT_RGB96_FLOAT",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_RGB96_FLOAT",
          "constexpr": true
        },
        "PIXELFORMAT_BGR96_FLOAT": {
          "doc": "",
          "name": "PIXELFORMAT_BGR96_FLOAT",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_BGR96_FLOAT",
          "constexpr": true
        },
        "PIXELFORMAT_RGBA128_FLOAT": {
          "doc": "",
          "name": "PIXELFORMAT_RGBA128_FLOAT",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_RGBA128_FLOAT",
          "constexpr": true
        },
        "PIXELFORMAT_ARGB128_FLOAT": {
          "doc": "",
          "name": "PIXELFORMAT_ARGB128_FLOAT",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_ARGB128_FLOAT",
          "constexpr": true
        },
        "PIXELFORMAT_BGRA128_FLOAT": {
          "doc": "",
          "name": "PIXELFORMAT_BGRA128_FLOAT",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_BGRA128_FLOAT",
          "constexpr": true
        },
        "PIXELFORMAT_ABGR128_FLOAT": {
          "doc": "",
          "name": "PIXELFORMAT_ABGR128_FLOAT",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_ABGR128_FLOAT",
          "constexpr": true
        },
        "PIXELFORMAT_YV12": {
          "doc": "Planar mode: Y + V + U (3 planes)",
          "name": "PIXELFORMAT_YV12",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_YV12",
          "constexpr": true
        },
        "PIXELFORMAT_IYUV": {
          "doc": "Planar mode: Y + U + V (3 planes)",
          "name": "PIXELFORMAT_IYUV",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_IYUV",
          "constexpr": true
        },
        "PIXELFORMAT_YUY2": {
          "doc": "Packed mode: Y0+U0+Y1+V0 (1 plane)",
          "name": "PIXELFORMAT_YUY2",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_YUY2",
          "constexpr": true
        },
        "PIXELFORMAT_UYVY": {
          "doc": "Packed mode: U0+Y0+V0+Y1 (1 plane)",
          "name": "PIXELFORMAT_UYVY",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_UYVY",
          "constexpr": true
        },
        "PIXELFORMAT_YVYU": {
          "doc": "Packed mode: Y0+V0+Y1+U0 (1 plane)",
          "name": "PIXELFORMAT_YVYU",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_YVYU",
          "constexpr": true
        },
        "PIXELFORMAT_NV12": {
          "doc": "Planar mode: Y + U/V interleaved (2 planes)",
          "name": "PIXELFORMAT_NV12",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_NV12",
          "constexpr": true
        },
        "PIXELFORMAT_NV21": {
          "doc": "Planar mode: Y + V/U interleaved (2 planes)",
          "name": "PIXELFORMAT_NV21",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_NV21",
          "constexpr": true
        },
        "PIXELFORMAT_P010": {
          "doc": "Planar mode: Y + U/V interleaved (2 planes)",
          "name": "PIXELFORMAT_P010",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_P010",
          "constexpr": true
        },
        "PIXELFORMAT_EXTERNAL_OES": {
          "doc": "Android video texture format.",
          "name": "PIXELFORMAT_EXTERNAL_OES",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_EXTERNAL_OES",
          "constexpr": true
        },
        "PIXELFORMAT_MJPG": {
          "doc": "Motion JPEG.",
          "name": "PIXELFORMAT_MJPG",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_MJPG",
          "constexpr": true
        },
        "PIXELFORMAT_RGBA32": {
          "doc": "",
          "name": "PIXELFORMAT_RGBA32",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_RGBA32",
          "constexpr": true
        },
        "PIXELFORMAT_ARGB32": {
          "doc": "",
          "name": "PIXELFORMAT_ARGB32",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_ARGB32",
          "constexpr": true
        },
        "PIXELFORMAT_BGRA32": {
          "doc": "",
          "name": "PIXELFORMAT_BGRA32",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_BGRA32",
          "constexpr": true
        },
        "PIXELFORMAT_ABGR32": {
          "doc": "",
          "name": "PIXELFORMAT_ABGR32",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_ABGR32",
          "constexpr": true
        },
        "PIXELFORMAT_RGBX32": {
          "doc": "",
          "name": "PIXELFORMAT_RGBX32",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_RGBX32",
          "constexpr": true
        },
        "PIXELFORMAT_XRGB32": {
          "doc": "",
          "name": "PIXELFORMAT_XRGB32",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_XRGB32",
          "constexpr": true
        },
        "PIXELFORMAT_BGRX32": {
          "doc": "",
          "name": "PIXELFORMAT_BGRX32",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_BGRX32",
          "constexpr": true
        },
        "PIXELFORMAT_XBGR32": {
          "doc": "",
          "name": "PIXELFORMAT_XBGR32",
          "kind": "var",
          "type": "PixelFormat",
          "sourceName": "SDL_PIXELFORMAT_XBGR32",
          "constexpr": true
        },
        "ColorType": {
          "doc": "Colorspace color type.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "ColorType",
          "kind": "alias",
          "sourceName": "SDL_ColorType",
          "type": "SDL_ColorType"
        },
        "COLOR_TYPE_UNKNOWN": {
          "doc": "",
          "name": "COLOR_TYPE_UNKNOWN",
          "kind": "var",
          "type": "ColorType",
          "sourceName": "SDL_COLOR_TYPE_UNKNOWN",
          "constexpr": true
        },
        "COLOR_TYPE_RGB": {
          "doc": "",
          "name": "COLOR_TYPE_RGB",
          "kind": "var",
          "type": "ColorType",
          "sourceName": "SDL_COLOR_TYPE_RGB",
          "constexpr": true
        },
        "COLOR_TYPE_YCBCR": {
          "doc": "",
          "name": "COLOR_TYPE_YCBCR",
          "kind": "var",
          "type": "ColorType",
          "sourceName": "SDL_COLOR_TYPE_YCBCR",
          "constexpr": true
        },
        "ColorRange": {
          "doc": "Colorspace color range, as described by\nhttps://www.itu.int/rec/R-REC-BT.2100-2-201807-I/en\n\n@since This enum is available since SDL 3.2.0.",
          "name": "ColorRange",
          "kind": "alias",
          "sourceName": "SDL_ColorRange",
          "type": "SDL_ColorRange"
        },
        "COLOR_RANGE_UNKNOWN": {
          "doc": "",
          "name": "COLOR_RANGE_UNKNOWN",
          "kind": "var",
          "type": "ColorRange",
          "sourceName": "SDL_COLOR_RANGE_UNKNOWN",
          "constexpr": true
        },
        "COLOR_RANGE_LIMITED": {
          "doc": "Narrow range, e.g.  16-235 for 8-bit RGB and luma, and 16-240 for 8-bit chroma",
          "name": "COLOR_RANGE_LIMITED",
          "kind": "var",
          "type": "ColorRange",
          "sourceName": "SDL_COLOR_RANGE_LIMITED",
          "constexpr": true
        },
        "COLOR_RANGE_FULL": {
          "doc": "Full range, e.g.  0-255 for 8-bit RGB and luma, and 1-255 for 8-bit chroma",
          "name": "COLOR_RANGE_FULL",
          "kind": "var",
          "type": "ColorRange",
          "sourceName": "SDL_COLOR_RANGE_FULL",
          "constexpr": true
        },
        "ColorPrimaries": {
          "doc": "Colorspace color primaries, as described by\nhttps://www.itu.int/rec/T-REC-H.273-201612-S/en\n\n@since This enum is available since SDL 3.2.0.",
          "name": "ColorPrimaries",
          "kind": "alias",
          "sourceName": "SDL_ColorPrimaries",
          "type": "SDL_ColorPrimaries"
        },
        "COLOR_PRIMARIES_UNKNOWN": {
          "doc": "",
          "name": "COLOR_PRIMARIES_UNKNOWN",
          "kind": "var",
          "type": "ColorPrimaries",
          "sourceName": "SDL_COLOR_PRIMARIES_UNKNOWN",
          "constexpr": true
        },
        "COLOR_PRIMARIES_BT709": {
          "doc": "ITU-R BT.709-6.",
          "name": "COLOR_PRIMARIES_BT709",
          "kind": "var",
          "type": "ColorPrimaries",
          "sourceName": "SDL_COLOR_PRIMARIES_BT709",
          "constexpr": true
        },
        "COLOR_PRIMARIES_UNSPECIFIED": {
          "doc": "",
          "name": "COLOR_PRIMARIES_UNSPECIFIED",
          "kind": "var",
          "type": "ColorPrimaries",
          "sourceName": "SDL_COLOR_PRIMARIES_UNSPECIFIED",
          "constexpr": true
        },
        "COLOR_PRIMARIES_BT470M": {
          "doc": "ITU-R BT.470-6 System M.",
          "name": "COLOR_PRIMARIES_BT470M",
          "kind": "var",
          "type": "ColorPrimaries",
          "sourceName": "SDL_COLOR_PRIMARIES_BT470M",
          "constexpr": true
        },
        "COLOR_PRIMARIES_BT470BG": {
          "doc": "ITU-R BT.470-6 System B, G / ITU-R BT.601-7 625.",
          "name": "COLOR_PRIMARIES_BT470BG",
          "kind": "var",
          "type": "ColorPrimaries",
          "sourceName": "SDL_COLOR_PRIMARIES_BT470BG",
          "constexpr": true
        },
        "COLOR_PRIMARIES_BT601": {
          "doc": "ITU-R BT.601-7 525, SMPTE 170M.",
          "name": "COLOR_PRIMARIES_BT601",
          "kind": "var",
          "type": "ColorPrimaries",
          "sourceName": "SDL_COLOR_PRIMARIES_BT601",
          "constexpr": true
        },
        "COLOR_PRIMARIES_SMPTE240": {
          "doc": "SMPTE 240M, functionally the same as COLOR_PRIMARIES_BT601.",
          "name": "COLOR_PRIMARIES_SMPTE240",
          "kind": "var",
          "type": "ColorPrimaries",
          "sourceName": "SDL_COLOR_PRIMARIES_SMPTE240",
          "constexpr": true
        },
        "COLOR_PRIMARIES_GENERIC_FILM": {
          "doc": "Generic film (color filters using Illuminant C)",
          "name": "COLOR_PRIMARIES_GENERIC_FILM",
          "kind": "var",
          "type": "ColorPrimaries",
          "sourceName": "SDL_COLOR_PRIMARIES_GENERIC_FILM",
          "constexpr": true
        },
        "COLOR_PRIMARIES_BT2020": {
          "doc": "ITU-R BT.2020-2 / ITU-R BT.2100-0.",
          "name": "COLOR_PRIMARIES_BT2020",
          "kind": "var",
          "type": "ColorPrimaries",
          "sourceName": "SDL_COLOR_PRIMARIES_BT2020",
          "constexpr": true
        },
        "COLOR_PRIMARIES_XYZ": {
          "doc": "SMPTE ST 428-1.",
          "name": "COLOR_PRIMARIES_XYZ",
          "kind": "var",
          "type": "ColorPrimaries",
          "sourceName": "SDL_COLOR_PRIMARIES_XYZ",
          "constexpr": true
        },
        "COLOR_PRIMARIES_SMPTE431": {
          "doc": "SMPTE RP 431-2.",
          "name": "COLOR_PRIMARIES_SMPTE431",
          "kind": "var",
          "type": "ColorPrimaries",
          "sourceName": "SDL_COLOR_PRIMARIES_SMPTE431",
          "constexpr": true
        },
        "COLOR_PRIMARIES_SMPTE432": {
          "doc": "SMPTE EG 432-1 / DCI P3.",
          "name": "COLOR_PRIMARIES_SMPTE432",
          "kind": "var",
          "type": "ColorPrimaries",
          "sourceName": "SDL_COLOR_PRIMARIES_SMPTE432",
          "constexpr": true
        },
        "COLOR_PRIMARIES_EBU3213": {
          "doc": "EBU Tech.  3213-E",
          "name": "COLOR_PRIMARIES_EBU3213",
          "kind": "var",
          "type": "ColorPrimaries",
          "sourceName": "SDL_COLOR_PRIMARIES_EBU3213",
          "constexpr": true
        },
        "COLOR_PRIMARIES_CUSTOM": {
          "doc": "",
          "name": "COLOR_PRIMARIES_CUSTOM",
          "kind": "var",
          "type": "ColorPrimaries",
          "sourceName": "SDL_COLOR_PRIMARIES_CUSTOM",
          "constexpr": true
        },
        "TransferCharacteristics": {
          "doc": "Colorspace transfer characteristics.\n\nThese are as described by https://www.itu.int/rec/T-REC-H.273-201612-S/en\n\n@since This enum is available since SDL 3.2.0.",
          "name": "TransferCharacteristics",
          "kind": "alias",
          "sourceName": "SDL_TransferCharacteristics",
          "type": "SDL_TransferCharacteristics"
        },
        "TRANSFER_CHARACTERISTICS_UNKNOWN": {
          "doc": "",
          "name": "TRANSFER_CHARACTERISTICS_UNKNOWN",
          "kind": "var",
          "type": "TransferCharacteristics",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_UNKNOWN",
          "constexpr": true
        },
        "TRANSFER_CHARACTERISTICS_BT709": {
          "doc": "Rec.  ITU-R BT.709-6 / ITU-R BT1361",
          "name": "TRANSFER_CHARACTERISTICS_BT709",
          "kind": "var",
          "type": "TransferCharacteristics",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_BT709",
          "constexpr": true
        },
        "TRANSFER_CHARACTERISTICS_UNSPECIFIED": {
          "doc": "",
          "name": "TRANSFER_CHARACTERISTICS_UNSPECIFIED",
          "kind": "var",
          "type": "TransferCharacteristics",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_UNSPECIFIED",
          "constexpr": true
        },
        "TRANSFER_CHARACTERISTICS_GAMMA22": {
          "doc": "ITU-R BT.470-6 System M / ITU-R BT1700 625 PAL & SECAM.",
          "name": "TRANSFER_CHARACTERISTICS_GAMMA22",
          "kind": "var",
          "type": "TransferCharacteristics",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_GAMMA22",
          "constexpr": true
        },
        "TRANSFER_CHARACTERISTICS_GAMMA28": {
          "doc": "ITU-R BT.470-6 System B, G.",
          "name": "TRANSFER_CHARACTERISTICS_GAMMA28",
          "kind": "var",
          "type": "TransferCharacteristics",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_GAMMA28",
          "constexpr": true
        },
        "TRANSFER_CHARACTERISTICS_BT601": {
          "doc": "SMPTE ST 170M / ITU-R BT.601-7 525 or 625.",
          "name": "TRANSFER_CHARACTERISTICS_BT601",
          "kind": "var",
          "type": "TransferCharacteristics",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_BT601",
          "constexpr": true
        },
        "TRANSFER_CHARACTERISTICS_SMPTE240": {
          "doc": "SMPTE ST 240M.",
          "name": "TRANSFER_CHARACTERISTICS_SMPTE240",
          "kind": "var",
          "type": "TransferCharacteristics",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_SMPTE240",
          "constexpr": true
        },
        "TRANSFER_CHARACTERISTICS_LINEAR": {
          "doc": "",
          "name": "TRANSFER_CHARACTERISTICS_LINEAR",
          "kind": "var",
          "type": "TransferCharacteristics",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_LINEAR",
          "constexpr": true
        },
        "TRANSFER_CHARACTERISTICS_LOG100": {
          "doc": "",
          "name": "TRANSFER_CHARACTERISTICS_LOG100",
          "kind": "var",
          "type": "TransferCharacteristics",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_LOG100",
          "constexpr": true
        },
        "TRANSFER_CHARACTERISTICS_LOG100_SQRT10": {
          "doc": "",
          "name": "TRANSFER_CHARACTERISTICS_LOG100_SQRT10",
          "kind": "var",
          "type": "TransferCharacteristics",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_LOG100_SQRT10",
          "constexpr": true
        },
        "TRANSFER_CHARACTERISTICS_IEC61966": {
          "doc": "IEC 61966-2-4.",
          "name": "TRANSFER_CHARACTERISTICS_IEC61966",
          "kind": "var",
          "type": "TransferCharacteristics",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_IEC61966",
          "constexpr": true
        },
        "TRANSFER_CHARACTERISTICS_BT1361": {
          "doc": "ITU-R BT1361 Extended Colour Gamut.",
          "name": "TRANSFER_CHARACTERISTICS_BT1361",
          "kind": "var",
          "type": "TransferCharacteristics",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_BT1361",
          "constexpr": true
        },
        "TRANSFER_CHARACTERISTICS_SRGB": {
          "doc": "IEC 61966-2-1 (sRGB or sYCC)",
          "name": "TRANSFER_CHARACTERISTICS_SRGB",
          "kind": "var",
          "type": "TransferCharacteristics",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_SRGB",
          "constexpr": true
        },
        "TRANSFER_CHARACTERISTICS_BT2020_10BIT": {
          "doc": "ITU-R BT2020 for 10-bit system.",
          "name": "TRANSFER_CHARACTERISTICS_BT2020_10BIT",
          "kind": "var",
          "type": "TransferCharacteristics",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_BT2020_10BIT",
          "constexpr": true
        },
        "TRANSFER_CHARACTERISTICS_BT2020_12BIT": {
          "doc": "ITU-R BT2020 for 12-bit system.",
          "name": "TRANSFER_CHARACTERISTICS_BT2020_12BIT",
          "kind": "var",
          "type": "TransferCharacteristics",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_BT2020_12BIT",
          "constexpr": true
        },
        "TRANSFER_CHARACTERISTICS_PQ": {
          "doc": "SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems.",
          "name": "TRANSFER_CHARACTERISTICS_PQ",
          "kind": "var",
          "type": "TransferCharacteristics",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_PQ",
          "constexpr": true
        },
        "TRANSFER_CHARACTERISTICS_SMPTE428": {
          "doc": "SMPTE ST 428-1.",
          "name": "TRANSFER_CHARACTERISTICS_SMPTE428",
          "kind": "var",
          "type": "TransferCharacteristics",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_SMPTE428",
          "constexpr": true
        },
        "TRANSFER_CHARACTERISTICS_HLG": {
          "doc": "ARIB STD-B67, known as \"hybrid log-gamma\" (HLG)",
          "name": "TRANSFER_CHARACTERISTICS_HLG",
          "kind": "var",
          "type": "TransferCharacteristics",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_HLG",
          "constexpr": true
        },
        "TRANSFER_CHARACTERISTICS_CUSTOM": {
          "doc": "",
          "name": "TRANSFER_CHARACTERISTICS_CUSTOM",
          "kind": "var",
          "type": "TransferCharacteristics",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_CUSTOM",
          "constexpr": true
        },
        "MatrixCoefficients": {
          "doc": "Colorspace matrix coefficients.\n\nThese are as described by https://www.itu.int/rec/T-REC-H.273-201612-S/en\n\n@since This enum is available since SDL 3.2.0.",
          "name": "MatrixCoefficients",
          "kind": "alias",
          "sourceName": "SDL_MatrixCoefficients",
          "type": "SDL_MatrixCoefficients"
        },
        "MATRIX_COEFFICIENTS_IDENTITY": {
          "doc": "",
          "name": "MATRIX_COEFFICIENTS_IDENTITY",
          "kind": "var",
          "type": "MatrixCoefficients",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_IDENTITY",
          "constexpr": true
        },
        "MATRIX_COEFFICIENTS_BT709": {
          "doc": "ITU-R BT.709-6.",
          "name": "MATRIX_COEFFICIENTS_BT709",
          "kind": "var",
          "type": "MatrixCoefficients",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_BT709",
          "constexpr": true
        },
        "MATRIX_COEFFICIENTS_UNSPECIFIED": {
          "doc": "",
          "name": "MATRIX_COEFFICIENTS_UNSPECIFIED",
          "kind": "var",
          "type": "MatrixCoefficients",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_UNSPECIFIED",
          "constexpr": true
        },
        "MATRIX_COEFFICIENTS_FCC": {
          "doc": "US FCC Title 47.",
          "name": "MATRIX_COEFFICIENTS_FCC",
          "kind": "var",
          "type": "MatrixCoefficients",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_FCC",
          "constexpr": true
        },
        "MATRIX_COEFFICIENTS_BT470BG": {
          "doc": "ITU-R BT.470-6 System B, G / ITU-R BT.601-7 625, functionally the same as MATRIX_COEFFICIENTS_BT601.",
          "name": "MATRIX_COEFFICIENTS_BT470BG",
          "kind": "var",
          "type": "MatrixCoefficients",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_BT470BG",
          "constexpr": true
        },
        "MATRIX_COEFFICIENTS_BT601": {
          "doc": "ITU-R BT.601-7 525.",
          "name": "MATRIX_COEFFICIENTS_BT601",
          "kind": "var",
          "type": "MatrixCoefficients",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_BT601",
          "constexpr": true
        },
        "MATRIX_COEFFICIENTS_SMPTE240": {
          "doc": "SMPTE 240M.",
          "name": "MATRIX_COEFFICIENTS_SMPTE240",
          "kind": "var",
          "type": "MatrixCoefficients",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_SMPTE240",
          "constexpr": true
        },
        "MATRIX_COEFFICIENTS_YCGCO": {
          "doc": "",
          "name": "MATRIX_COEFFICIENTS_YCGCO",
          "kind": "var",
          "type": "MatrixCoefficients",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_YCGCO",
          "constexpr": true
        },
        "MATRIX_COEFFICIENTS_BT2020_NCL": {
          "doc": "ITU-R BT.2020-2 non-constant luminance.",
          "name": "MATRIX_COEFFICIENTS_BT2020_NCL",
          "kind": "var",
          "type": "MatrixCoefficients",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_BT2020_NCL",
          "constexpr": true
        },
        "MATRIX_COEFFICIENTS_BT2020_CL": {
          "doc": "ITU-R BT.2020-2 constant luminance.",
          "name": "MATRIX_COEFFICIENTS_BT2020_CL",
          "kind": "var",
          "type": "MatrixCoefficients",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_BT2020_CL",
          "constexpr": true
        },
        "MATRIX_COEFFICIENTS_SMPTE2085": {
          "doc": "SMPTE ST 2085.",
          "name": "MATRIX_COEFFICIENTS_SMPTE2085",
          "kind": "var",
          "type": "MatrixCoefficients",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_SMPTE2085",
          "constexpr": true
        },
        "MATRIX_COEFFICIENTS_CHROMA_DERIVED_NCL": {
          "doc": "",
          "name": "MATRIX_COEFFICIENTS_CHROMA_DERIVED_NCL",
          "kind": "var",
          "type": "MatrixCoefficients",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_CHROMA_DERIVED_NCL",
          "constexpr": true
        },
        "MATRIX_COEFFICIENTS_CHROMA_DERIVED_CL": {
          "doc": "",
          "name": "MATRIX_COEFFICIENTS_CHROMA_DERIVED_CL",
          "kind": "var",
          "type": "MatrixCoefficients",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_CHROMA_DERIVED_CL",
          "constexpr": true
        },
        "MATRIX_COEFFICIENTS_ICTCP": {
          "doc": "ITU-R BT.2100-0 ICTCP.",
          "name": "MATRIX_COEFFICIENTS_ICTCP",
          "kind": "var",
          "type": "MatrixCoefficients",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_ICTCP",
          "constexpr": true
        },
        "MATRIX_COEFFICIENTS_CUSTOM": {
          "doc": "",
          "name": "MATRIX_COEFFICIENTS_CUSTOM",
          "kind": "var",
          "type": "MatrixCoefficients",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_CUSTOM",
          "constexpr": true
        },
        "ChromaLocation": {
          "doc": "Colorspace chroma sample location.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "ChromaLocation",
          "kind": "alias",
          "sourceName": "SDL_ChromaLocation",
          "type": "SDL_ChromaLocation"
        },
        "CHROMA_LOCATION_NONE": {
          "doc": "RGB, no chroma sampling.",
          "name": "CHROMA_LOCATION_NONE",
          "kind": "var",
          "type": "ChromaLocation",
          "sourceName": "SDL_CHROMA_LOCATION_NONE",
          "constexpr": true
        },
        "CHROMA_LOCATION_LEFT": {
          "doc": "In MPEG-2, MPEG-4, and AVC, Cb and Cr are taken on midpoint of the left-edge of the 2x2 square.  In other words, they have the same horizontal location as the top-left pixel, but is shifted one-half pixel down vertically.",
          "name": "CHROMA_LOCATION_LEFT",
          "kind": "var",
          "type": "ChromaLocation",
          "sourceName": "SDL_CHROMA_LOCATION_LEFT",
          "constexpr": true
        },
        "CHROMA_LOCATION_CENTER": {
          "doc": "In JPEG/JFIF, H.261, and MPEG-1, Cb and Cr are taken at the center of the 2x2 square.  In other words, they are offset one-half pixel to the right and one-half pixel down compared to the top-left pixel.",
          "name": "CHROMA_LOCATION_CENTER",
          "kind": "var",
          "type": "ChromaLocation",
          "sourceName": "SDL_CHROMA_LOCATION_CENTER",
          "constexpr": true
        },
        "CHROMA_LOCATION_TOPLEFT": {
          "doc": "In HEVC for BT.2020 and BT.2100 content (in particular on Blu-rays), Cb and Cr are sampled at the same location as the group's top-left Y pixel (\"co-sited\", \"co-located\").",
          "name": "CHROMA_LOCATION_TOPLEFT",
          "kind": "var",
          "type": "ChromaLocation",
          "sourceName": "SDL_CHROMA_LOCATION_TOPLEFT",
          "constexpr": true
        },
        "Colorspace": {
          "doc": "Colorspace definitions.\n\nSince similar colorspaces may vary in their details (matrix, transfer\nfunction, etc.), this is not an exhaustive list, but rather a\nrepresentative sample of the kinds of colorspaces supported in SDL.\n\n@since This enum is available since SDL 3.2.0.\n\n@sa ColorPrimaries\n@sa ColorRange\n@sa ColorType\n@sa MatrixCoefficients\n@sa TransferCharacteristics",
          "name": "Colorspace",
          "kind": "struct",
          "sourceName": "SDL_Colorspace",
          "type": "",
          "entries": {
            "colorspace": {
              "kind": "var",
              "type": "SDL_Colorspace",
              "name": "colorspace",
              "doc": ""
            },
            "Colorspace": [
              {
                "kind": "function",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "SDL_Colorspace",
                    "name": "colorspace",
                    "default": "SDL_COLORSPACE_UNKNOWN"
                  }
                ],
                "name": "Colorspace",
                "doc": ""
              },
              {
                "doc": "A macro for defining custom Colorspace formats.\n\nFor example, defining COLORSPACE_SRGB looks like this:\n\n```c\nSDL_DEFINE_COLORSPACE(COLOR_TYPE_RGB,\n                      COLOR_RANGE_FULL,\n                      COLOR_PRIMARIES_BT709,\n                      TRANSFER_CHARACTERISTICS_SRGB,\n                      MATRIX_COEFFICIENTS_IDENTITY,\n                      CHROMA_LOCATION_NONE)\n```\n\n@param type the type of the new format, probably an ColorType value.\n@param range the range of the new format, probably a ColorRange value.\n@param primaries the primaries of the new format, probably an\n                 ColorPrimaries value.\n@param transfer the transfer characteristics of the new format, probably an\n                TransferCharacteristics value.\n@param matrix the matrix coefficients of the new format, probably an\n              MatrixCoefficients value.\n@param chroma the chroma sample location of the new format, probably an\n              ChromaLocation value.\n@returns a format value in the style of Colorspace.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
                "name": "Colorspace",
                "kind": "function",
                "parameters": [
                  {
                    "type": "ColorType",
                    "name": "type"
                  },
                  {
                    "type": "ColorRange",
                    "name": "range"
                  },
                  {
                    "type": "ColorPrimaries",
                    "name": "primaries"
                  },
                  {
                    "type": "TransferCharacteristics",
                    "name": "transfer"
                  },
                  {
                    "type": "MatrixCoefficients",
                    "name": "matrix"
                  },
                  {
                    "type": "ChromaLocation",
                    "name": "chroma"
                  }
                ],
                "value": "    (((Uint32)(type) << 28) | ((Uint32)(range) << 24) | ((Uint32)(chroma) << 20) | \\\n    ((Uint32)(primaries) << 10) | ((Uint32)(transfer) << 5) | ((Uint32)(matrix) << 0))",
                "sourceName": "SDL_DEFINE_COLORSPACE",
                "type": "",
                "constexpr": true
              }
            ],
            "operator bool": {
              "kind": "function",
              "parameters": [],
              "type": "",
              "immutable": true,
              "constexpr": true,
              "name": "operator bool",
              "doc": ""
            },
            "operator SDL_Colorspace": {
              "kind": "function",
              "parameters": [],
              "type": "",
              "immutable": true,
              "constexpr": true,
              "name": "operator SDL_Colorspace",
              "doc": ""
            },
            "GetType": {
              "doc": "A macro to retrieve the type of an Colorspace.\n\n@param cspace an Colorspace to check.\n@returns the ColorType for `cspace`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
              "name": "GetType",
              "kind": "function",
              "parameters": [],
              "value": "(SDL_ColorType)(((cspace) >> 28) & 0x0F)",
              "sourceName": "SDL_COLORSPACETYPE",
              "type": "ColorType",
              "immutable": true,
              "constexpr": true
            },
            "GetRange": {
              "doc": "A macro to retrieve the range of an Colorspace.\n\n@param cspace an Colorspace to check.\n@returns the ColorRange of `cspace`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
              "name": "GetRange",
              "kind": "function",
              "parameters": [],
              "value": "(SDL_ColorRange)(((cspace) >> 24) & 0x0F)",
              "sourceName": "SDL_COLORSPACERANGE",
              "type": "ColorRange",
              "immutable": true,
              "constexpr": true
            },
            "GetChroma": {
              "doc": "A macro to retrieve the chroma sample location of an Colorspace.\n\n@param cspace an Colorspace to check.\n@returns the ChromaLocation of `cspace`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
              "name": "GetChroma",
              "kind": "function",
              "parameters": [],
              "value": "(SDL_ChromaLocation)(((cspace) >> 20) & 0x0F)",
              "sourceName": "SDL_COLORSPACECHROMA",
              "type": "ChromaLocation",
              "immutable": true,
              "constexpr": true
            },
            "GetPrimaries": {
              "doc": "A macro to retrieve the primaries of an Colorspace.\n\n@param cspace an Colorspace to check.\n@returns the ColorPrimaries of `cspace`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
              "name": "GetPrimaries",
              "kind": "function",
              "parameters": [],
              "value": "(SDL_ColorPrimaries)(((cspace) >> 10) & 0x1F)",
              "sourceName": "SDL_COLORSPACEPRIMARIES",
              "type": "ColorPrimaries",
              "immutable": true,
              "constexpr": true
            },
            "GetTransfer": {
              "doc": "A macro to retrieve the transfer characteristics of an Colorspace.\n\n@param cspace an Colorspace to check.\n@returns the TransferCharacteristics of `cspace`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
              "name": "GetTransfer",
              "kind": "function",
              "parameters": [],
              "value": "(SDL_TransferCharacteristics)(((cspace) >> 5) & 0x1F)",
              "sourceName": "SDL_COLORSPACETRANSFER",
              "type": "TransferCharacteristics",
              "immutable": true,
              "constexpr": true
            },
            "GetMatrix": {
              "doc": "A macro to retrieve the matrix coefficients of an Colorspace.\n\n@param cspace an Colorspace to check.\n@returns the MatrixCoefficients of `cspace`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
              "name": "GetMatrix",
              "kind": "function",
              "parameters": [],
              "value": "(SDL_MatrixCoefficients)((cspace) & 0x1F)",
              "sourceName": "SDL_COLORSPACEMATRIX",
              "type": "MatrixCoefficients",
              "immutable": true,
              "constexpr": true
            },
            "IsMatrixBT601": {
              "doc": "A macro to determine if an Colorspace uses BT601 (or BT470BG) matrix\ncoefficients.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n@param cspace an Colorspace to check.\n@returns true if BT601 or BT470BG, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
              "name": "IsMatrixBT601",
              "kind": "function",
              "parameters": [],
              "value": "(SDL_COLORSPACEMATRIX(cspace) == SDL_MATRIX_COEFFICIENTS_BT601 || SDL_COLORSPACEMATRIX(cspace) == SDL_MATRIX_COEFFICIENTS_BT470BG)",
              "sourceName": "SDL_ISCOLORSPACE_MATRIX_BT601",
              "type": "bool",
              "immutable": true,
              "constexpr": true
            },
            "IsMatrixBT709": {
              "doc": "A macro to determine if an Colorspace uses BT709 matrix coefficients.\n\n@param cspace an Colorspace to check.\n@returns true if BT709, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
              "name": "IsMatrixBT709",
              "kind": "function",
              "parameters": [],
              "value": "(SDL_COLORSPACEMATRIX(cspace) == SDL_MATRIX_COEFFICIENTS_BT709)",
              "sourceName": "SDL_ISCOLORSPACE_MATRIX_BT709",
              "type": "bool",
              "immutable": true,
              "constexpr": true
            },
            "IsMatrixBT2020_NCL": {
              "doc": "A macro to determine if an Colorspace uses BT2020_NCL matrix\ncoefficients.\n\n@param cspace an Colorspace to check.\n@returns true if BT2020_NCL, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
              "name": "IsMatrixBT2020_NCL",
              "kind": "function",
              "parameters": [],
              "value": "(SDL_COLORSPACEMATRIX(cspace) == SDL_MATRIX_COEFFICIENTS_BT2020_NCL)",
              "sourceName": "SDL_ISCOLORSPACE_MATRIX_BT2020_NCL",
              "type": "bool",
              "immutable": true,
              "constexpr": true
            },
            "IsLimitedRange": {
              "doc": "A macro to determine if an Colorspace has a limited range.\n\n@param cspace an Colorspace to check.\n@returns true if limited range, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
              "name": "IsLimitedRange",
              "kind": "function",
              "parameters": [],
              "value": "(SDL_COLORSPACERANGE(cspace) != SDL_COLOR_RANGE_FULL)",
              "sourceName": "SDL_ISCOLORSPACE_LIMITED_RANGE",
              "type": "bool",
              "immutable": true,
              "constexpr": true
            },
            "IsFullRange": {
              "doc": "A macro to determine if an Colorspace has a full range.\n\n@param cspace an Colorspace to check.\n@returns true if full range, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
              "name": "IsFullRange",
              "kind": "function",
              "parameters": [],
              "value": "(SDL_COLORSPACERANGE(cspace) == SDL_COLOR_RANGE_FULL)",
              "sourceName": "SDL_ISCOLORSPACE_FULL_RANGE",
              "type": "bool",
              "immutable": true,
              "constexpr": true
            }
          }
        },
        "COLORSPACE_UNKNOWN": {
          "doc": "",
          "name": "COLORSPACE_UNKNOWN",
          "kind": "var",
          "type": "Colorspace",
          "sourceName": "SDL_COLORSPACE_UNKNOWN",
          "constexpr": true
        },
        "COLORSPACE_SRGB": {
          "doc": "Equivalent to DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709.",
          "name": "COLORSPACE_SRGB",
          "kind": "var",
          "type": "Colorspace",
          "sourceName": "SDL_COLORSPACE_SRGB",
          "constexpr": true
        },
        "COLORSPACE_SRGB_LINEAR": {
          "doc": "[object Object]",
          "name": "COLORSPACE_SRGB_LINEAR",
          "kind": "var",
          "type": "Colorspace",
          "sourceName": "SDL_COLORSPACE_SRGB_LINEAR",
          "constexpr": true
        },
        "COLORSPACE_HDR10": {
          "doc": "[object Object]",
          "name": "COLORSPACE_HDR10",
          "kind": "var",
          "type": "Colorspace",
          "sourceName": "SDL_COLORSPACE_HDR10",
          "constexpr": true
        },
        "COLORSPACE_JPEG": {
          "doc": "Equivalent to DXGI_COLOR_SPACE_YCBCR_FULL_G22_NONE_P709_X601.",
          "name": "COLORSPACE_JPEG",
          "kind": "var",
          "type": "Colorspace",
          "sourceName": "SDL_COLORSPACE_JPEG",
          "constexpr": true
        },
        "COLORSPACE_BT601_LIMITED": {
          "doc": "Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601.",
          "name": "COLORSPACE_BT601_LIMITED",
          "kind": "var",
          "type": "Colorspace",
          "sourceName": "SDL_COLORSPACE_BT601_LIMITED",
          "constexpr": true
        },
        "COLORSPACE_BT601_FULL": {
          "doc": "Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601.",
          "name": "COLORSPACE_BT601_FULL",
          "kind": "var",
          "type": "Colorspace",
          "sourceName": "SDL_COLORSPACE_BT601_FULL",
          "constexpr": true
        },
        "COLORSPACE_BT709_LIMITED": {
          "doc": "Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709.",
          "name": "COLORSPACE_BT709_LIMITED",
          "kind": "var",
          "type": "Colorspace",
          "sourceName": "SDL_COLORSPACE_BT709_LIMITED",
          "constexpr": true
        },
        "COLORSPACE_BT709_FULL": {
          "doc": "Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709.",
          "name": "COLORSPACE_BT709_FULL",
          "kind": "var",
          "type": "Colorspace",
          "sourceName": "SDL_COLORSPACE_BT709_FULL",
          "constexpr": true
        },
        "COLORSPACE_BT2020_LIMITED": {
          "doc": "Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P2020.",
          "name": "COLORSPACE_BT2020_LIMITED",
          "kind": "var",
          "type": "Colorspace",
          "sourceName": "SDL_COLORSPACE_BT2020_LIMITED",
          "constexpr": true
        },
        "COLORSPACE_BT2020_FULL": {
          "doc": "Equivalent to DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P2020.",
          "name": "COLORSPACE_BT2020_FULL",
          "kind": "var",
          "type": "Colorspace",
          "sourceName": "SDL_COLORSPACE_BT2020_FULL",
          "constexpr": true
        },
        "COLORSPACE_RGB_DEFAULT": {
          "doc": "The default colorspace for RGB surfaces if no colorspace is specified.",
          "name": "COLORSPACE_RGB_DEFAULT",
          "kind": "var",
          "type": "Colorspace",
          "sourceName": "SDL_COLORSPACE_RGB_DEFAULT",
          "constexpr": true
        },
        "COLORSPACE_YUV_DEFAULT": {
          "doc": "The default colorspace for YUV surfaces if no colorspace is specified.",
          "name": "COLORSPACE_YUV_DEFAULT",
          "kind": "var",
          "type": "Colorspace",
          "sourceName": "SDL_COLORSPACE_YUV_DEFAULT",
          "constexpr": true
        },
        "Color": {
          "doc": "A structure that represents a color as RGBA components.\n\nThe bits of this structure can be directly reinterpreted as an\ninteger-packed color which uses the PIXELFORMAT_RGBA32 format\n(PIXELFORMAT_ABGR8888 on little-endian systems and\nPIXELFORMAT_RGBA8888 on big-endian systems).\n\n@since This struct is available since SDL 3.2.0.",
          "name": "Color",
          "kind": "struct",
          "sourceName": "SDL_Color",
          "type": "SDL_Color",
          "entries": {
            "Color": [
              {
                "kind": "function",
                "constexpr": true,
                "type": "",
                "parameters": [
                  {
                    "type": "SDL_Color",
                    "name": "color",
                    "default": "{0}"
                  }
                ],
                "name": "Color",
                "doc": ""
              },
              {
                "kind": "function",
                "constexpr": true,
                "type": "",
                "parameters": [
                  {
                    "name": "r",
                    "type": "Uint8"
                  },
                  {
                    "name": "g",
                    "type": "Uint8"
                  },
                  {
                    "name": "b",
                    "type": "Uint8"
                  },
                  {
                    "name": "a",
                    "type": "Uint8",
                    "default": "255"
                  }
                ],
                "name": "Color",
                "doc": ""
              }
            ],
            "operator<=>": {
              "kind": "function",
              "immutable": true,
              "type": "auto",
              "parameters": [
                {
                  "type": "const Color &",
                  "name": "other"
                }
              ],
              "name": "operator<=>",
              "doc": ""
            }
          }
        },
        "FColor": {
          "doc": "The bits of this structure can be directly reinterpreted as a float-packed\ncolor which uses the PIXELFORMAT_RGBA128_FLOAT format\n\n@since This struct is available since SDL 3.2.0.",
          "name": "FColor",
          "kind": "struct",
          "sourceName": "SDL_FColor",
          "type": "SDL_FColor",
          "entries": {
            "FColor": [
              {
                "kind": "function",
                "constexpr": true,
                "type": "",
                "parameters": [
                  {
                    "type": "SDL_FColor",
                    "name": "color",
                    "default": "{0}"
                  }
                ],
                "name": "FColor",
                "doc": ""
              },
              {
                "kind": "function",
                "constexpr": true,
                "type": "",
                "parameters": [
                  {
                    "name": "r",
                    "type": "float"
                  },
                  {
                    "name": "g",
                    "type": "float"
                  },
                  {
                    "name": "b",
                    "type": "float"
                  },
                  {
                    "name": "a",
                    "type": "float",
                    "default": "1"
                  }
                ],
                "name": "FColor",
                "doc": ""
              }
            ],
            "operator<=>": {
              "kind": "function",
              "immutable": true,
              "type": "auto",
              "parameters": [
                {
                  "type": "const FColor &",
                  "name": "other"
                }
              ],
              "name": "operator<=>",
              "doc": ""
            }
          }
        },
        "PaletteBase": {
          "doc": "A set of indexed colors representing a palette.\n\n@since This struct is available since SDL 3.2.0.\n\n@sa PaletteBase.SetColors",
          "name": "PaletteBase",
          "kind": "struct",
          "sourceName": "SDL_Palette",
          "type": "T",
          "template": [
            {
              "type": "ObjectBox<SDL_Palette *>",
              "name": "T"
            }
          ],
          "entries": {
            "T::T": {
              "kind": "alias",
              "name": "T::T",
              "doc": ""
            },
            "PaletteBase": {
              "doc": "Create a palette structure with the specified number of color entries.\n\nThe palette entries are initialized to white.\n\n@param ncolors represents the number of color entries in the color palette.\n@post a new PaletteBase structure on success or nullptr on failure (e.g. if\n         there wasn't enough memory); call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PaletteBase.Destroy\n@sa PaletteBase.SetColors\n@sa SurfaceBase.SetPalette",
              "name": "PaletteBase",
              "kind": "function",
              "type": "",
              "parameters": [
                {
                  "name": "ncolors",
                  "type": "int"
                }
              ],
              "sourceName": "SDL_CreatePalette"
            },
            "GetSize": {
              "kind": "function",
              "type": "int",
              "immutable": true,
              "constexpr": true,
              "parameters": [],
              "name": "GetSize",
              "doc": ""
            },
            "operator[]": {
              "kind": "function",
              "type": "Color",
              "immutable": true,
              "constexpr": true,
              "parameters": [
                {
                  "type": "int",
                  "name": "index"
                }
              ],
              "name": "operator[]",
              "doc": ""
            },
            "SetColors": [
              {
                "doc": "Set a range of colors in a palette.\n\n@param colors an array of Color structures to copy into the palette.\n@param firstcolor the index of the first palette entry to modify.\n@param ncolors the number of entries to modify.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread, as long as\n              the palette is not modified or destroyed in another thread.\n\n@since This function is available since SDL 3.2.0.",
                "name": "SetColors",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "colors",
                    "type": "const Color *"
                  },
                  {
                    "name": "firstcolor",
                    "type": "int"
                  },
                  {
                    "name": "ncolors",
                    "type": "int"
                  }
                ],
                "sourceName": "SDL_SetPaletteColors"
              },
              {
                "kind": "function",
                "name": "SetColors",
                "type": "bool",
                "static": false,
                "parameters": [
                  {
                    "type": "SpanRef<const SDL_Color>",
                    "name": "colors"
                  },
                  {
                    "type": "int",
                    "name": "firstcolor",
                    "default": "0"
                  }
                ],
                "doc": ""
              }
            ],
            "Destroy": {
              "doc": "Free a palette created with PaletteBase.PaletteBase().\n\n\n@threadsafety It is safe to call this function from any thread, as long as\n              the palette is not modified or destroyed in another thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PaletteBase.PaletteBase",
              "name": "Destroy",
              "kind": "function",
              "type": "void",
              "parameters": [],
              "sourceName": "SDL_DestroyPalette"
            }
          }
        },
        "ObjectRef<SDL_Palette>::doFree": {
          "name": "ObjectRef<SDL_Palette>::doFree",
          "type": "void",
          "kind": "function",
          "doc": "Callback for palette resource cleanup\n\n@private",
          "template": [],
          "parameters": [
            {
              "type": "SDL_Palette *",
              "name": "resource"
            }
          ],
          "sourceName": "SDL_DestroyPalette"
        },
        "MapRGB": {
          "doc": "Map an RGB triple to an opaque pixel value for a given pixel format.\n\nThis function maps the RGB color value to the specified pixel format and\nreturns the pixel value best approximating the given RGB color value for\nthe given pixel format.\n\nIf the format has a palette (8-bit) the index of the closest matching color\nin the palette will be returned.\n\nIf the specified pixel format has an alpha component it will be returned as\nall 1 bits (fully opaque).\n\nIf the pixel format bpp (color depth) is less than 32-bpp then the unused\nupper bits of the return value can safely be ignored (e.g., with a 16-bpp\nformat the return value can be assigned to a Uint16, and similarly a Uint8\nfor an 8-bpp format).\n\n@param format a pointer to PixelFormatDetails describing the pixel\n              format.\n@param palette an optional palette for indexed formats, may be nullptr.\n@param r the red component of the pixel in the range 0-255.\n@param g the green component of the pixel in the range 0-255.\n@param b the blue component of the pixel in the range 0-255.\n@returns a pixel value.\n\n@threadsafety It is safe to call this function from any thread, as long as\n              the palette is not modified.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PixelFormat.GetDetails\n@sa GetRGB\n@sa MapRGBA\n@sa SurfaceBase.MapColor",
          "name": "MapRGB",
          "kind": "function",
          "type": "Uint32",
          "parameters": [
            {
              "name": "format",
              "type": "const PixelFormatDetails *"
            },
            {
              "name": "palette",
              "type": "PaletteRef"
            },
            {
              "name": "r",
              "type": "Uint8"
            },
            {
              "name": "g",
              "type": "Uint8"
            },
            {
              "name": "b",
              "type": "Uint8"
            }
          ],
          "sourceName": "SDL_MapRGB"
        },
        "MapRGBA": {
          "doc": "Map an RGBA quadruple to a pixel value for a given pixel format.\n\nThis function maps the RGBA color value to the specified pixel format and\nreturns the pixel value best approximating the given RGBA color value for\nthe given pixel format.\n\nIf the specified pixel format has no alpha component the alpha value will\nbe ignored (as it will be in formats with a palette).\n\nIf the format has a palette (8-bit) the index of the closest matching color\nin the palette will be returned.\n\nIf the pixel format bpp (color depth) is less than 32-bpp then the unused\nupper bits of the return value can safely be ignored (e.g., with a 16-bpp\nformat the return value can be assigned to a Uint16, and similarly a Uint8\nfor an 8-bpp format).\n\n@param format a pointer to PixelFormatDetails describing the pixel\n              format.\n@param palette an optional palette for indexed formats, may be nullptr.\n@param r the red component of the pixel in the range 0-255.\n@param g the green component of the pixel in the range 0-255.\n@param b the blue component of the pixel in the range 0-255.\n@param a the alpha component of the pixel in the range 0-255.\n@returns a pixel value.\n\n@threadsafety It is safe to call this function from any thread, as long as\n              the palette is not modified.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PixelFormat.GetDetails\n@sa GetRGBA\n@sa MapRGB\n@sa SurfaceBase.MapColor",
          "name": "MapRGBA",
          "kind": "function",
          "type": "Uint32",
          "parameters": [
            {
              "name": "format",
              "type": "const PixelFormatDetails *"
            },
            {
              "name": "palette",
              "type": "PaletteRef"
            },
            {
              "name": "r",
              "type": "Uint8"
            },
            {
              "name": "g",
              "type": "Uint8"
            },
            {
              "name": "b",
              "type": "Uint8"
            },
            {
              "name": "a",
              "type": "Uint8"
            }
          ],
          "sourceName": "SDL_MapRGBA"
        },
        "GetRGB": {
          "doc": "Get RGB values from a pixel in the specified format.\n\nThis function uses the entire 8-bit [0..255] range when converting color\ncomponents from pixel formats with less than 8-bits per RGB component\n(e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,\n0xff, 0xff] not [0xf8, 0xfc, 0xf8]).\n\n@param pixel a pixel value.\n@param format a pointer to PixelFormatDetails describing the pixel\n              format.\n@param palette an optional palette for indexed formats, may be nullptr.\n@param r a pointer filled in with the red component, may be nullptr.\n@param g a pointer filled in with the green component, may be nullptr.\n@param b a pointer filled in with the blue component, may be nullptr.\n\n@threadsafety It is safe to call this function from any thread, as long as\n              the palette is not modified.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PixelFormat.GetDetails\n@sa GetRGBA\n@sa MapRGB\n@sa MapRGBA",
          "name": "GetRGB",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "pixel",
              "type": "Uint32"
            },
            {
              "name": "format",
              "type": "const PixelFormatDetails *"
            },
            {
              "name": "palette",
              "type": "PaletteRef"
            },
            {
              "name": "r",
              "type": "Uint8 *"
            },
            {
              "name": "g",
              "type": "Uint8 *"
            },
            {
              "name": "b",
              "type": "Uint8 *"
            }
          ],
          "sourceName": "SDL_GetRGB"
        },
        "GetRGBA": {
          "doc": "Get RGBA values from a pixel in the specified format.\n\nThis function uses the entire 8-bit [0..255] range when converting color\ncomponents from pixel formats with less than 8-bits per RGB component\n(e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,\n0xff, 0xff] not [0xf8, 0xfc, 0xf8]).\n\nIf the surface has no alpha component, the alpha will be returned as 0xff\n(100% opaque).\n\n@param pixel a pixel value.\n@param format a pointer to PixelFormatDetails describing the pixel\n              format.\n@param palette an optional palette for indexed formats, may be nullptr.\n@param r a pointer filled in with the red component, may be nullptr.\n@param g a pointer filled in with the green component, may be nullptr.\n@param b a pointer filled in with the blue component, may be nullptr.\n@param a a pointer filled in with the alpha component, may be nullptr.\n\n@threadsafety It is safe to call this function from any thread, as long as\n              the palette is not modified.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PixelFormat.GetDetails\n@sa GetRGB\n@sa MapRGB\n@sa MapRGBA",
          "name": "GetRGBA",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "pixel",
              "type": "Uint32"
            },
            {
              "name": "format",
              "type": "const PixelFormatDetails *"
            },
            {
              "name": "palette",
              "type": "PaletteRef"
            },
            {
              "name": "r",
              "type": "Uint8 *"
            },
            {
              "name": "g",
              "type": "Uint8 *"
            },
            {
              "name": "b",
              "type": "Uint8 *"
            },
            {
              "name": "a",
              "type": "Uint8 *"
            }
          ],
          "sourceName": "SDL_GetRGBA"
        }
      }
    },
    "SDL3pp_blendmode.h": {
      "name": "SDL3pp_blendmode.h",
      "doc": "@defgroup CategoryBlendmode Category Blendmode\n\nBlend modes decide how two colors will mix together. There are both\nstandard modes for basic needs and a means to create custom modes,\ndictating what sort of math to do on what color components.",
      "entries": {
        "BlendMode": {
          "doc": "A set of blend modes used in drawing operations.\n\nThese predefined blend modes are supported everywhere.\n\nAdditional values may be obtained from ComposeCustomBlendMode.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa ComposeCustomBlendMode",
          "name": "BlendMode",
          "kind": "alias",
          "type": "SDL_BlendMode",
          "sourceName": "SDL_BlendMode"
        },
        "BLENDMODE_NONE": {
          "doc": "no blending: dstRGBA = srcRGBA",
          "name": "BLENDMODE_NONE",
          "kind": "var",
          "value": "0x00000000u",
          "sourceName": "SDL_BLENDMODE_NONE",
          "constexpr": true,
          "type": "BlendMode"
        },
        "BLENDMODE_BLEND": {
          "doc": "alpha blending: dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA)), dstA = srcA + (dstA * (1-srcA))",
          "name": "BLENDMODE_BLEND",
          "kind": "var",
          "value": "0x00000001u",
          "sourceName": "SDL_BLENDMODE_BLEND",
          "constexpr": true,
          "type": "BlendMode"
        },
        "BLENDMODE_BLEND_PREMULTIPLIED": {
          "doc": "pre-multiplied alpha blending: dstRGBA = srcRGBA + (dstRGBA * (1-srcA))",
          "name": "BLENDMODE_BLEND_PREMULTIPLIED",
          "kind": "var",
          "value": "0x00000010u",
          "sourceName": "SDL_BLENDMODE_BLEND_PREMULTIPLIED",
          "constexpr": true,
          "type": "BlendMode"
        },
        "BLENDMODE_ADD": {
          "doc": "additive blending: dstRGB = (srcRGB * srcA) + dstRGB, dstA = dstA",
          "name": "BLENDMODE_ADD",
          "kind": "var",
          "value": "0x00000002u",
          "sourceName": "SDL_BLENDMODE_ADD",
          "constexpr": true,
          "type": "BlendMode"
        },
        "BLENDMODE_ADD_PREMULTIPLIED": {
          "doc": "pre-multiplied additive blending: dstRGB = srcRGB + dstRGB, dstA = dstA",
          "name": "BLENDMODE_ADD_PREMULTIPLIED",
          "kind": "var",
          "value": "0x00000020u",
          "sourceName": "SDL_BLENDMODE_ADD_PREMULTIPLIED",
          "constexpr": true,
          "type": "BlendMode"
        },
        "BLENDMODE_MOD": {
          "doc": "color modulate: dstRGB = srcRGB * dstRGB, dstA = dstA",
          "name": "BLENDMODE_MOD",
          "kind": "var",
          "value": "0x00000004u",
          "sourceName": "SDL_BLENDMODE_MOD",
          "constexpr": true,
          "type": "BlendMode"
        },
        "BLENDMODE_MUL": {
          "doc": "color multiply: dstRGB = (srcRGB * dstRGB) + (dstRGB * (1-srcA)), dstA = dstA",
          "name": "BLENDMODE_MUL",
          "kind": "var",
          "value": "0x00000008u",
          "sourceName": "SDL_BLENDMODE_MUL",
          "constexpr": true,
          "type": "BlendMode"
        },
        "BLENDMODE_INVALID": {
          "doc": "",
          "name": "BLENDMODE_INVALID",
          "kind": "var",
          "value": "0x7FFFFFFFu",
          "sourceName": "SDL_BLENDMODE_INVALID",
          "constexpr": true,
          "type": "BlendMode"
        },
        "BlendOperation": {
          "doc": "The blend operation used when combining source and destination pixel\ncomponents.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "BlendOperation",
          "kind": "alias",
          "sourceName": "SDL_BlendOperation",
          "type": "SDL_BlendOperation"
        },
        "BLENDOPERATION_ADD": {
          "doc": "dst + src: supported by all renderers",
          "name": "BLENDOPERATION_ADD",
          "kind": "var",
          "type": "BlendOperation",
          "sourceName": "SDL_BLENDOPERATION_ADD",
          "constexpr": true
        },
        "BLENDOPERATION_SUBTRACT": {
          "doc": "src - dst : supported by D3D, OpenGL, OpenGLES, and Vulkan",
          "name": "BLENDOPERATION_SUBTRACT",
          "kind": "var",
          "type": "BlendOperation",
          "sourceName": "SDL_BLENDOPERATION_SUBTRACT",
          "constexpr": true
        },
        "BLENDOPERATION_REV_SUBTRACT": {
          "doc": "dst - src : supported by D3D, OpenGL, OpenGLES, and Vulkan",
          "name": "BLENDOPERATION_REV_SUBTRACT",
          "kind": "var",
          "type": "BlendOperation",
          "sourceName": "SDL_BLENDOPERATION_REV_SUBTRACT",
          "constexpr": true
        },
        "BLENDOPERATION_MINIMUM": {
          "doc": "min(dst, src) : supported by D3D, OpenGL, OpenGLES, and Vulkan",
          "name": "BLENDOPERATION_MINIMUM",
          "kind": "var",
          "type": "BlendOperation",
          "sourceName": "SDL_BLENDOPERATION_MINIMUM",
          "constexpr": true
        },
        "BLENDOPERATION_MAXIMUM": {
          "doc": "max(dst, src) : supported by D3D, OpenGL, OpenGLES, and Vulkan",
          "name": "BLENDOPERATION_MAXIMUM",
          "kind": "var",
          "type": "BlendOperation",
          "sourceName": "SDL_BLENDOPERATION_MAXIMUM",
          "constexpr": true
        },
        "BlendFactor": {
          "doc": "The normalized factor used to multiply pixel components.\n\nThe blend factors are multiplied with the pixels from a drawing operation\n(src) and the pixels from the render target (dst) before the blend\noperation. The comma-separated factors listed above are always applied in\nthe component order red, green, blue, and alpha.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "BlendFactor",
          "kind": "alias",
          "sourceName": "SDL_BlendFactor",
          "type": "SDL_BlendFactor"
        },
        "BLENDFACTOR_ZERO": {
          "doc": "0, 0, 0, 0",
          "name": "BLENDFACTOR_ZERO",
          "kind": "var",
          "type": "BlendFactor",
          "sourceName": "SDL_BLENDFACTOR_ZERO",
          "constexpr": true
        },
        "BLENDFACTOR_ONE": {
          "doc": "1, 1, 1, 1",
          "name": "BLENDFACTOR_ONE",
          "kind": "var",
          "type": "BlendFactor",
          "sourceName": "SDL_BLENDFACTOR_ONE",
          "constexpr": true
        },
        "BLENDFACTOR_SRC_COLOR": {
          "doc": "srcR, srcG, srcB, srcA",
          "name": "BLENDFACTOR_SRC_COLOR",
          "kind": "var",
          "type": "BlendFactor",
          "sourceName": "SDL_BLENDFACTOR_SRC_COLOR",
          "constexpr": true
        },
        "BLENDFACTOR_ONE_MINUS_SRC_COLOR": {
          "doc": "1-srcR, 1-srcG, 1-srcB, 1-srcA",
          "name": "BLENDFACTOR_ONE_MINUS_SRC_COLOR",
          "kind": "var",
          "type": "BlendFactor",
          "sourceName": "SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR",
          "constexpr": true
        },
        "BLENDFACTOR_SRC_ALPHA": {
          "doc": "srcA, srcA, srcA, srcA",
          "name": "BLENDFACTOR_SRC_ALPHA",
          "kind": "var",
          "type": "BlendFactor",
          "sourceName": "SDL_BLENDFACTOR_SRC_ALPHA",
          "constexpr": true
        },
        "BLENDFACTOR_ONE_MINUS_SRC_ALPHA": {
          "doc": "1-srcA, 1-srcA, 1-srcA, 1-srcA",
          "name": "BLENDFACTOR_ONE_MINUS_SRC_ALPHA",
          "kind": "var",
          "type": "BlendFactor",
          "sourceName": "SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA",
          "constexpr": true
        },
        "BLENDFACTOR_DST_COLOR": {
          "doc": "dstR, dstG, dstB, dstA",
          "name": "BLENDFACTOR_DST_COLOR",
          "kind": "var",
          "type": "BlendFactor",
          "sourceName": "SDL_BLENDFACTOR_DST_COLOR",
          "constexpr": true
        },
        "BLENDFACTOR_ONE_MINUS_DST_COLOR": {
          "doc": "1-dstR, 1-dstG, 1-dstB, 1-dstA",
          "name": "BLENDFACTOR_ONE_MINUS_DST_COLOR",
          "kind": "var",
          "type": "BlendFactor",
          "sourceName": "SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR",
          "constexpr": true
        },
        "BLENDFACTOR_DST_ALPHA": {
          "doc": "dstA, dstA, dstA, dstA",
          "name": "BLENDFACTOR_DST_ALPHA",
          "kind": "var",
          "type": "BlendFactor",
          "sourceName": "SDL_BLENDFACTOR_DST_ALPHA",
          "constexpr": true
        },
        "BLENDFACTOR_ONE_MINUS_DST_ALPHA": {
          "doc": "1-dstA, 1-dstA, 1-dstA, 1-dstA",
          "name": "BLENDFACTOR_ONE_MINUS_DST_ALPHA",
          "kind": "var",
          "type": "BlendFactor",
          "sourceName": "SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA",
          "constexpr": true
        },
        "ComposeCustomBlendMode": {
          "doc": "Compose a custom blend mode for renderers.\n\nThe functions RendererBase.SetDrawBlendMode and TextureBase.SetBlendMode accept\nthe BlendMode returned by this function if the renderer supports it.\n\nA blend mode controls how the pixels from a drawing operation (source) get\ncombined with the pixels from the render target (destination). First, the\ncomponents of the source and destination pixels get multiplied with their\nblend factors. Then, the blend operation takes the two products and\ncalculates the result that will get stored in the render target.\n\nExpressed in pseudocode, it would look like this:\n\n```c\ndstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);\ndstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);\n```\n\nWhere the functions `colorOperation(src, dst)` and `alphaOperation(src,\ndst)` can return one of the following:\n\n- `src + dst`\n- `src - dst`\n- `dst - src`\n- `min(src, dst)`\n- `max(src, dst)`\n\nThe red, green, and blue components are always multiplied with the first,\nsecond, and third components of the BlendFactor, respectively. The\nfourth component is not used.\n\nThe alpha component is always multiplied with the fourth component of the\nBlendFactor. The other components are not used in the alpha\ncalculation.\n\nSupport for these blend modes varies for each renderer. To check if a\nspecific BlendMode is supported, create a renderer and pass it to\neither RendererBase.SetDrawBlendMode or TextureBase.SetBlendMode. They will\nreturn with an error if the blend mode is not supported.\n\nThis list describes the support of custom blend modes for each renderer.\nAll renderers support the four blend modes listed in the BlendMode\nenumeration.\n\n- **direct3d**: Supports all operations with all factors. However, some\n  factors produce unexpected results with `BLENDOPERATION_MINIMUM` and\n  `BLENDOPERATION_MAXIMUM`.\n- **direct3d11**: Same as Direct3D 9.\n- **opengl**: Supports the `BLENDOPERATION_ADD` operation with all\n  factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly here.\n- **opengles2**: Supports the `BLENDOPERATION_ADD`,\n  `BLENDOPERATION_SUBTRACT`, `BLENDOPERATION_REV_SUBTRACT`\n  operations with all factors.\n- **psp**: No custom blend mode support.\n- **software**: No custom blend mode support.\n\nSome renderers do not provide an alpha component for the default render\ntarget. The `BLENDFACTOR_DST_ALPHA` and\n`BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this\ncase.\n\n@param srcColorFactor the BlendFactor applied to the red, green, and\n                      blue components of the source pixels.\n@param dstColorFactor the BlendFactor applied to the red, green, and\n                      blue components of the destination pixels.\n@param colorOperation the BlendOperation used to combine the red,\n                      green, and blue components of the source and\n                      destination pixels.\n@param srcAlphaFactor the BlendFactor applied to the alpha component of\n                      the source pixels.\n@param dstAlphaFactor the BlendFactor applied to the alpha component of\n                      the destination pixels.\n@param alphaOperation the BlendOperation used to combine the alpha\n                      component of the source and destination pixels.\n@returns an BlendMode that represents the chosen factors and\n         operations.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.SetDrawBlendMode\n@sa RendererBase.GetDrawBlendMode\n@sa TextureBase.SetBlendMode\n@sa TextureBase.GetBlendMode",
          "name": "ComposeCustomBlendMode",
          "kind": "function",
          "type": "BlendMode",
          "parameters": [
            {
              "name": "srcColorFactor",
              "type": "BlendFactor"
            },
            {
              "name": "dstColorFactor",
              "type": "BlendFactor"
            },
            {
              "name": "colorOperation",
              "type": "BlendOperation"
            },
            {
              "name": "srcAlphaFactor",
              "type": "BlendFactor"
            },
            {
              "name": "dstAlphaFactor",
              "type": "BlendFactor"
            },
            {
              "name": "alphaOperation",
              "type": "BlendOperation"
            }
          ],
          "sourceName": "SDL_ComposeCustomBlendMode"
        }
      }
    },
    "SDL3pp_hints.h": {
      "name": "SDL3pp_hints.h",
      "doc": "@defgroup CategoryHints Category Hints\n\nThis file contains functions to set and get configuration hints, as well as\nlisting each of them alphabetically.\n\nThe convention for naming hints is SDL_HINT_X, where \"SDL_X\" is the\nenvironment variable that can be used to override the default.\n\nIn general these hints are just that - they may or may not be supported or\napplicable on any given platform, but they provide a way for an application\nor user to give the library a hint as to how they would like the library to\nwork.",
      "entries": {
        "SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED": {
          "doc": "Specify the behavior of Alt+Tab while the keyboard is grabbed.\n\nBy default, SDL emulates Alt+Tab functionality while the keyboard is\ngrabbed and your window is full-screen. This prevents the user from getting\nstuck in your application if you've enabled keyboard grab.\n\nThe variable can be set to the following values:\n\n- \"0\": SDL will not handle Alt+Tab. Your application is responsible for\n  handling Alt+Tab while the keyboard is grabbed.\n- \"1\": SDL will minimize your window when Alt+Tab is pressed (default)\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED",
          "kind": "def",
          "value": "\"SDL_ALLOW_ALT_TAB_WHILE_GRABBED\"",
          "sourceName": "SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED"
        },
        "SDL_HINT_ANDROID_ALLOW_RECREATE_ACTIVITY": {
          "doc": "A variable to control whether the SDL activity is allowed to be re-created.\n\nIf this hint is true, the activity can be recreated on demand by the OS,\nand Java static data and C++ static data remain with their current values.\nIf this hint is false, then SDL will call exit() when you return from your\nmain function and the application will be terminated and then started fresh\neach time.\n\nThe variable can be set to the following values:\n\n- \"0\": The application starts fresh at each launch. (default)\n- \"1\": The application activity can be recreated by the OS.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_ANDROID_ALLOW_RECREATE_ACTIVITY",
          "kind": "def",
          "value": "\"SDL_ANDROID_ALLOW_RECREATE_ACTIVITY\"",
          "sourceName": "SDL_HINT_ANDROID_ALLOW_RECREATE_ACTIVITY"
        },
        "SDL_HINT_ANDROID_BLOCK_ON_PAUSE": {
          "doc": "A variable to control whether the event loop will block itself when the app\nis paused.\n\nThe variable can be set to the following values:\n\n- \"0\": Non blocking.\n- \"1\": Blocking. (default)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_ANDROID_BLOCK_ON_PAUSE",
          "kind": "def",
          "value": "\"SDL_ANDROID_BLOCK_ON_PAUSE\"",
          "sourceName": "SDL_HINT_ANDROID_BLOCK_ON_PAUSE"
        },
        "SDL_HINT_ANDROID_LOW_LATENCY_AUDIO": {
          "doc": "A variable to control whether low latency audio should be enabled.\n\nSome devices have poor quality output when this is enabled, but this is\nusually an improvement in audio latency.\n\nThe variable can be set to the following values:\n\n- \"0\": Low latency audio is not enabled.\n- \"1\": Low latency audio is enabled. (default)\n\nThis hint should be set before SDL audio is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_ANDROID_LOW_LATENCY_AUDIO",
          "kind": "def",
          "value": "\"SDL_ANDROID_LOW_LATENCY_AUDIO\"",
          "sourceName": "SDL_HINT_ANDROID_LOW_LATENCY_AUDIO"
        },
        "SDL_HINT_ANDROID_TRAP_BACK_BUTTON": {
          "doc": "A variable to control whether we trap the Android back button to handle it\nmanually.\n\nThis is necessary for the right mouse button to work on some Android\ndevices, or to be able to trap the back button for use in your code\nreliably. If this hint is true, the back button will show up as an\nEVENT_KEY_DOWN / EVENT_KEY_UP pair with a keycode of\nSCANCODE_AC_BACK.\n\nThe variable can be set to the following values:\n\n- \"0\": Back button will be handled as usual for system. (default)\n- \"1\": Back button will be trapped, allowing you to handle the key press\n  manually. (This will also let right mouse click work on systems where the\n  right mouse button functions as back.)\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_ANDROID_TRAP_BACK_BUTTON",
          "kind": "def",
          "value": "\"SDL_ANDROID_TRAP_BACK_BUTTON\"",
          "sourceName": "SDL_HINT_ANDROID_TRAP_BACK_BUTTON"
        },
        "SDL_HINT_APP_ID": {
          "doc": "A variable setting the app ID string.\n\nThis string is used by desktop compositors to identify and group windows\ntogether, as well as match applications with associated desktop settings\nand icons.\n\nThis will override prop::appMetaData.IDENTIFIER_STRING, if set by the\napplication.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_APP_ID",
          "kind": "def",
          "value": "\"SDL_APP_ID\"",
          "sourceName": "SDL_HINT_APP_ID"
        },
        "SDL_HINT_APP_NAME": {
          "doc": "A variable setting the application name.\n\nThis hint lets you specify the application name sent to the OS when\nrequired. For example, this will often appear in volume control applets for\naudio streams, and in lists of applications which are inhibiting the\nscreensaver. You should use a string that describes your program (\"My Game\n2: The Revenge\")\n\nThis will override SDL_PROP_APP_METADATA_NAME_STRING, if set by the\napplication.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_APP_NAME",
          "kind": "def",
          "value": "\"SDL_APP_NAME\"",
          "sourceName": "SDL_HINT_APP_NAME"
        },
        "SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS": {
          "doc": "A variable controlling whether controllers used with the Apple TV generate\nUI events.\n\nWhen UI events are generated by controller input, the app will be\nbackgrounded when the Apple TV remote's menu button is pressed, and when\nthe pause or B buttons on gamepads are pressed.\n\nMore information about properly making use of controllers for the Apple TV\ncan be found here:\nhttps://developer.apple.com/tvos/human-interface-guidelines/remote-and-controllers/\n\nThe variable can be set to the following values:\n\n- \"0\": Controller input does not generate UI events. (default)\n- \"1\": Controller input generates UI events.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS",
          "kind": "def",
          "value": "\"SDL_APPLE_TV_CONTROLLER_UI_EVENTS\"",
          "sourceName": "SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS"
        },
        "SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION": {
          "doc": "A variable controlling whether the Apple TV remote's joystick axes will\nautomatically match the rotation of the remote.\n\nThe variable can be set to the following values:\n\n- \"0\": Remote orientation does not affect joystick axes. (default)\n- \"1\": Joystick axes are based on the orientation of the remote.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION",
          "kind": "def",
          "value": "\"SDL_APPLE_TV_REMOTE_ALLOW_ROTATION\"",
          "sourceName": "SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION"
        },
        "SDL_HINT_AUDIO_ALSA_DEFAULT_DEVICE": {
          "doc": "Specify the default ALSA audio device name.\n\nThis variable is a specific audio device to open when the \"default\" audio\ndevice is used.\n\nThis hint will be ignored when opening the default playback device if\nSDL_HINT_AUDIO_ALSA_DEFAULT_PLAYBACK_DEVICE is set, or when opening the\ndefault recording device if SDL_HINT_AUDIO_ALSA_DEFAULT_RECORDING_DEVICE is\nset.\n\nThis hint should be set before an audio device is opened.\n\n@since This hint is available since SDL 3.2.0.\n\n@sa SDL_HINT_AUDIO_ALSA_DEFAULT_PLAYBACK_DEVICE\n@sa SDL_HINT_AUDIO_ALSA_DEFAULT_RECORDING_DEVICE",
          "name": "SDL_HINT_AUDIO_ALSA_DEFAULT_DEVICE",
          "kind": "def",
          "value": "\"SDL_AUDIO_ALSA_DEFAULT_DEVICE\"",
          "sourceName": "SDL_HINT_AUDIO_ALSA_DEFAULT_DEVICE"
        },
        "SDL_HINT_AUDIO_ALSA_DEFAULT_PLAYBACK_DEVICE": {
          "doc": "Specify the default ALSA audio playback device name.\n\nThis variable is a specific audio device to open for playback, when the\n\"default\" audio device is used.\n\nIf this hint isn't set, SDL will check SDL_HINT_AUDIO_ALSA_DEFAULT_DEVICE\nbefore choosing a reasonable default.\n\nThis hint should be set before an audio device is opened.\n\n@since This hint is available since SDL 3.2.0.\n\n@sa SDL_HINT_AUDIO_ALSA_DEFAULT_RECORDING_DEVICE\n@sa SDL_HINT_AUDIO_ALSA_DEFAULT_DEVICE",
          "name": "SDL_HINT_AUDIO_ALSA_DEFAULT_PLAYBACK_DEVICE",
          "kind": "def",
          "value": "\"SDL_AUDIO_ALSA_DEFAULT_PLAYBACK_DEVICE\"",
          "sourceName": "SDL_HINT_AUDIO_ALSA_DEFAULT_PLAYBACK_DEVICE"
        },
        "SDL_HINT_AUDIO_ALSA_DEFAULT_RECORDING_DEVICE": {
          "doc": "Specify the default ALSA audio recording device name.\n\nThis variable is a specific audio device to open for recording, when the\n\"default\" audio device is used.\n\nIf this hint isn't set, SDL will check SDL_HINT_AUDIO_ALSA_DEFAULT_DEVICE\nbefore choosing a reasonable default.\n\nThis hint should be set before an audio device is opened.\n\n@since This hint is available since SDL 3.2.0.\n\n@sa SDL_HINT_AUDIO_ALSA_DEFAULT_PLAYBACK_DEVICE\n@sa SDL_HINT_AUDIO_ALSA_DEFAULT_DEVICE",
          "name": "SDL_HINT_AUDIO_ALSA_DEFAULT_RECORDING_DEVICE",
          "kind": "def",
          "value": "\"SDL_AUDIO_ALSA_DEFAULT_RECORDING_DEVICE\"",
          "sourceName": "SDL_HINT_AUDIO_ALSA_DEFAULT_RECORDING_DEVICE"
        },
        "SDL_HINT_AUDIO_CATEGORY": {
          "doc": "A variable controlling the audio category on iOS and macOS.\n\nThe variable can be set to the following values:\n\n- \"ambient\": Use the AVAudioSessionCategoryAmbient audio category, will be\n  muted by the phone mute switch (default)\n- \"playback\": Use the AVAudioSessionCategoryPlayback category.\n\nFor more information, see Apple's documentation:\nhttps://developer.apple.com/library/content/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/AudioSessionCategoriesandModes/AudioSessionCategoriesandModes.html\n\nThis hint should be set before an audio device is opened.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_AUDIO_CATEGORY",
          "kind": "def",
          "value": "\"SDL_AUDIO_CATEGORY\"",
          "sourceName": "SDL_HINT_AUDIO_CATEGORY"
        },
        "SDL_HINT_AUDIO_CHANNELS": {
          "doc": "A variable controlling the default audio channel count.\n\nIf the application doesn't specify the audio channel count when opening the\ndevice, this hint can be used to specify a default channel count that will\nbe used. This defaults to \"1\" for recording and \"2\" for playback devices.\n\nThis hint should be set before an audio device is opened.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_AUDIO_CHANNELS",
          "kind": "def",
          "value": "\"SDL_AUDIO_CHANNELS\"",
          "sourceName": "SDL_HINT_AUDIO_CHANNELS"
        },
        "SDL_HINT_AUDIO_DEVICE_APP_ICON_NAME": {
          "doc": "Specify an application icon name for an audio device.\n\nSome audio backends (such as Pulseaudio and Pipewire) allow you to set an\nXDG icon name for your application. Among other things, this icon might\nshow up in a system control panel that lets the user adjust the volume on\nspecific audio streams instead of using one giant master volume slider.\nNote that this is unrelated to the icon used by the windowing system, which\nmay be set with WindowBase.SetIcon (or via desktop file on Wayland).\n\nSetting this to \"\" or leaving it unset will have SDL use a reasonable\ndefault, \"applications-games\", which is likely to be installed. See\nhttps://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html\nand\nhttps://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html\nfor the relevant XDG icon specs.\n\nThis hint should be set before an audio device is opened.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_AUDIO_DEVICE_APP_ICON_NAME",
          "kind": "def",
          "value": "\"SDL_AUDIO_DEVICE_APP_ICON_NAME\"",
          "sourceName": "SDL_HINT_AUDIO_DEVICE_APP_ICON_NAME"
        },
        "SDL_HINT_AUDIO_DEVICE_SAMPLE_FRAMES": {
          "doc": "A variable controlling device buffer size.\n\nThis hint is an integer > 0, that represents the size of the device's\nbuffer in sample frames (stereo audio data in 16-bit format is 4 bytes per\nsample frame, for example).\n\nSDL3 generally decides this value on behalf of the app, but if for some\nreason the app needs to dictate this (because they want either lower\nlatency or higher throughput AND ARE WILLING TO DEAL WITH what that might\nrequire of the app), they can specify it.\n\nSDL will try to accommodate this value, but there is no promise you'll get\nthe buffer size requested. Many platforms won't honor this request at all,\nor might adjust it.\n\nThis hint should be set before an audio device is opened.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_AUDIO_DEVICE_SAMPLE_FRAMES",
          "kind": "def",
          "value": "\"SDL_AUDIO_DEVICE_SAMPLE_FRAMES\"",
          "sourceName": "SDL_HINT_AUDIO_DEVICE_SAMPLE_FRAMES"
        },
        "SDL_HINT_AUDIO_DEVICE_STREAM_NAME": {
          "doc": "Specify an audio stream name for an audio device.\n\nSome audio backends (such as PulseAudio) allow you to describe your audio\nstream. Among other things, this description might show up in a system\ncontrol panel that lets the user adjust the volume on specific audio\nstreams instead of using one giant master volume slider.\n\nThis hints lets you transmit that information to the OS. The contents of\nthis hint are used while opening an audio device. You should use a string\nthat describes your what your program is playing (\"audio stream\" is\nprobably sufficient in many cases, but this could be useful for something\nlike \"team chat\" if you have a headset playing VoIP audio separately).\n\nSetting this to \"\" or leaving it unset will have SDL use a reasonable\ndefault: \"audio stream\" or something similar.\n\nNote that while this talks about audio streams, this is an OS-level\nconcept, so it applies to a physical audio device in this case, and not an\nSDL_AudioStream, nor an SDL logical audio device.\n\nThis hint should be set before an audio device is opened.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_AUDIO_DEVICE_STREAM_NAME",
          "kind": "def",
          "value": "\"SDL_AUDIO_DEVICE_STREAM_NAME\"",
          "sourceName": "SDL_HINT_AUDIO_DEVICE_STREAM_NAME"
        },
        "SDL_HINT_AUDIO_DEVICE_STREAM_ROLE": {
          "doc": "Specify an application role for an audio device.\n\nSome audio backends (such as Pipewire) allow you to describe the role of\nyour audio stream. Among other things, this description might show up in a\nsystem control panel or software for displaying and manipulating media\nplayback/recording graphs.\n\nThis hints lets you transmit that information to the OS. The contents of\nthis hint are used while opening an audio device. You should use a string\nthat describes your what your program is playing (Game, Music, Movie,\netc...).\n\nSetting this to \"\" or leaving it unset will have SDL use a reasonable\ndefault: \"Game\" or something similar.\n\nNote that while this talks about audio streams, this is an OS-level\nconcept, so it applies to a physical audio device in this case, and not an\nSDL_AudioStream, nor an SDL logical audio device.\n\nThis hint should be set before an audio device is opened.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_AUDIO_DEVICE_STREAM_ROLE",
          "kind": "def",
          "value": "\"SDL_AUDIO_DEVICE_STREAM_ROLE\"",
          "sourceName": "SDL_HINT_AUDIO_DEVICE_STREAM_ROLE"
        },
        "SDL_HINT_AUDIO_DISK_INPUT_FILE": {
          "doc": "Specify the input file when recording audio using the disk audio driver.\n\nThis defaults to \"sdlaudio-in.raw\"\n\nThis hint should be set before an audio device is opened.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_AUDIO_DISK_INPUT_FILE",
          "kind": "def",
          "value": "\"SDL_AUDIO_DISK_INPUT_FILE\"",
          "sourceName": "SDL_HINT_AUDIO_DISK_INPUT_FILE"
        },
        "SDL_HINT_AUDIO_DISK_OUTPUT_FILE": {
          "doc": "Specify the output file when playing audio using the disk audio driver.\n\nThis defaults to \"sdlaudio.raw\"\n\nThis hint should be set before an audio device is opened.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_AUDIO_DISK_OUTPUT_FILE",
          "kind": "def",
          "value": "\"SDL_AUDIO_DISK_OUTPUT_FILE\"",
          "sourceName": "SDL_HINT_AUDIO_DISK_OUTPUT_FILE"
        },
        "SDL_HINT_AUDIO_DISK_TIMESCALE": {
          "doc": "A variable controlling the audio rate when using the disk audio driver.\n\nThe disk audio driver normally simulates real-time for the audio rate that\nwas specified, but you can use this variable to adjust this rate higher or\nlower down to 0. The default value is \"1.0\".\n\nThis hint should be set before an audio device is opened.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_AUDIO_DISK_TIMESCALE",
          "kind": "def",
          "value": "\"SDL_AUDIO_DISK_TIMESCALE\"",
          "sourceName": "SDL_HINT_AUDIO_DISK_TIMESCALE"
        },
        "SDL_HINT_AUDIO_DRIVER": {
          "doc": "A variable that specifies an audio backend to use.\n\nBy default, SDL will try all available audio backends in a reasonable order\nuntil it finds one that can work, but this hint allows the app or user to\nforce a specific driver, such as \"pipewire\" if, say, you are on PulseAudio\nbut want to try talking to the lower level instead.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_AUDIO_DRIVER",
          "kind": "def",
          "value": "\"SDL_AUDIO_DRIVER\"",
          "sourceName": "SDL_HINT_AUDIO_DRIVER"
        },
        "SDL_HINT_AUDIO_DUMMY_TIMESCALE": {
          "doc": "A variable controlling the audio rate when using the dummy audio driver.\n\nThe dummy audio driver normally simulates real-time for the audio rate that\nwas specified, but you can use this variable to adjust this rate higher or\nlower down to 0. The default value is \"1.0\".\n\nThis hint should be set before an audio device is opened.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_AUDIO_DUMMY_TIMESCALE",
          "kind": "def",
          "value": "\"SDL_AUDIO_DUMMY_TIMESCALE\"",
          "sourceName": "SDL_HINT_AUDIO_DUMMY_TIMESCALE"
        },
        "SDL_HINT_AUDIO_FORMAT": {
          "doc": "A variable controlling the default audio format.\n\nIf the application doesn't specify the audio format when opening the\ndevice, this hint can be used to specify a default format that will be\nused.\n\nThe variable can be set to the following values:\n\n- \"U8\": Unsigned 8-bit audio\n- \"S8\": Signed 8-bit audio\n- \"S16LE\": Signed 16-bit little-endian audio\n- \"S16BE\": Signed 16-bit big-endian audio\n- \"S16\": Signed 16-bit native-endian audio (default)\n- \"S32LE\": Signed 32-bit little-endian audio\n- \"S32BE\": Signed 32-bit big-endian audio\n- \"S32\": Signed 32-bit native-endian audio\n- \"F32LE\": Floating point little-endian audio\n- \"F32BE\": Floating point big-endian audio\n- \"F32\": Floating point native-endian audio\n\nThis hint should be set before an audio device is opened.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_AUDIO_FORMAT",
          "kind": "def",
          "value": "\"SDL_AUDIO_FORMAT\"",
          "sourceName": "SDL_HINT_AUDIO_FORMAT"
        },
        "SDL_HINT_AUDIO_FREQUENCY": {
          "doc": "A variable controlling the default audio frequency.\n\nIf the application doesn't specify the audio frequency when opening the\ndevice, this hint can be used to specify a default frequency that will be\nused. This defaults to \"44100\".\n\nThis hint should be set before an audio device is opened.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_AUDIO_FREQUENCY",
          "kind": "def",
          "value": "\"SDL_AUDIO_FREQUENCY\"",
          "sourceName": "SDL_HINT_AUDIO_FREQUENCY"
        },
        "SDL_HINT_AUDIO_INCLUDE_MONITORS": {
          "doc": "A variable that causes SDL to not ignore audio \"monitors\".\n\nThis is currently only used by the PulseAudio driver.\n\nBy default, SDL ignores audio devices that aren't associated with physical\nhardware. Changing this hint to \"1\" will expose anything SDL sees that\nappears to be an audio source or sink. This will add \"devices\" to the list\nthat the user probably doesn't want or need, but it can be useful in\nscenarios where you want to hook up SDL to some sort of virtual device,\netc.\n\nThe variable can be set to the following values:\n\n- \"0\": Audio monitor devices will be ignored. (default)\n- \"1\": Audio monitor devices will show up in the device list.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_AUDIO_INCLUDE_MONITORS",
          "kind": "def",
          "value": "\"SDL_AUDIO_INCLUDE_MONITORS\"",
          "sourceName": "SDL_HINT_AUDIO_INCLUDE_MONITORS"
        },
        "SDL_HINT_AUTO_UPDATE_JOYSTICKS": {
          "doc": "A variable controlling whether SDL updates joystick state when getting\ninput events.\n\nThe variable can be set to the following values:\n\n- \"0\": You'll call SDL_UpdateJoysticks() manually.\n- \"1\": SDL will automatically call SDL_UpdateJoysticks(). (default)\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_AUTO_UPDATE_JOYSTICKS",
          "kind": "def",
          "value": "\"SDL_AUTO_UPDATE_JOYSTICKS\"",
          "sourceName": "SDL_HINT_AUTO_UPDATE_JOYSTICKS"
        },
        "SDL_HINT_AUTO_UPDATE_SENSORS": {
          "doc": "A variable controlling whether SDL updates sensor state when getting input\nevents.\n\nThe variable can be set to the following values:\n\n- \"0\": You'll call SDL_UpdateSensors() manually.\n- \"1\": SDL will automatically call SDL_UpdateSensors(). (default)\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_AUTO_UPDATE_SENSORS",
          "kind": "def",
          "value": "\"SDL_AUTO_UPDATE_SENSORS\"",
          "sourceName": "SDL_HINT_AUTO_UPDATE_SENSORS"
        },
        "SDL_HINT_BMP_SAVE_LEGACY_FORMAT": {
          "doc": "Prevent SDL from using version 4 of the bitmap header when saving BMPs.\n\nThe bitmap header version 4 is required for proper alpha channel support\nand SDL will use it when required. Should this not be desired, this hint\ncan force the use of the 40 byte header version which is supported\neverywhere.\n\nThe variable can be set to the following values:\n\n- \"0\": Surfaces with a colorkey or an alpha channel are saved to a 32-bit\n  BMP file with an alpha mask. SDL will use the bitmap header version 4 and\n  set the alpha mask accordingly. (default)\n- \"1\": Surfaces with a colorkey or an alpha channel are saved to a 32-bit\n  BMP file without an alpha mask. The alpha channel data will be in the\n  file, but applications are going to ignore it.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_BMP_SAVE_LEGACY_FORMAT",
          "kind": "def",
          "value": "\"SDL_BMP_SAVE_LEGACY_FORMAT\"",
          "sourceName": "SDL_HINT_BMP_SAVE_LEGACY_FORMAT"
        },
        "SDL_HINT_CAMERA_DRIVER": {
          "doc": "A variable that decides what camera backend to use.\n\nBy default, SDL will try all available camera backends in a reasonable\norder until it finds one that can work, but this hint allows the app or\nuser to force a specific target, such as \"directshow\" if, say, you are on\nWindows Media Foundations but want to try DirectShow instead.\n\nThe default value is unset, in which case SDL will try to figure out the\nbest camera backend on your behalf. This hint needs to be set before\nInitSubSystem() is called to be useful.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_CAMERA_DRIVER",
          "kind": "def",
          "value": "\"SDL_CAMERA_DRIVER\"",
          "sourceName": "SDL_HINT_CAMERA_DRIVER"
        },
        "SDL_HINT_CPU_FEATURE_MASK": {
          "doc": "A variable that limits what CPU features are available.\n\nBy default, SDL marks all features the current CPU supports as available.\nThis hint allows to limit these to a subset.\n\nWhen the hint is unset, or empty, SDL will enable all detected CPU\nfeatures.\n\nThe variable can be set to a comma separated list containing the following\nitems:\n\n- \"all\"\n- \"altivec\"\n- \"sse\"\n- \"sse2\"\n- \"sse3\"\n- \"sse41\"\n- \"sse42\"\n- \"avx\"\n- \"avx2\"\n- \"avx512f\"\n- \"arm-simd\"\n- \"neon\"\n- \"lsx\"\n- \"lasx\"\n\nThe items can be prefixed by '+'/'-' to add/remove features.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_CPU_FEATURE_MASK",
          "kind": "def",
          "value": "\"SDL_CPU_FEATURE_MASK\"",
          "sourceName": "SDL_HINT_CPU_FEATURE_MASK"
        },
        "SDL_HINT_JOYSTICK_DIRECTINPUT": {
          "doc": "A variable controlling whether DirectInput should be used for controllers.\n\nThe variable can be set to the following values:\n\n- \"0\": Disable DirectInput detection.\n- \"1\": Enable DirectInput detection. (default)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_DIRECTINPUT",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_DIRECTINPUT\"",
          "sourceName": "SDL_HINT_JOYSTICK_DIRECTINPUT"
        },
        "SDL_HINT_FILE_DIALOG_DRIVER": {
          "doc": "A variable that specifies a dialog backend to use.\n\nBy default, SDL will try all available dialog backends in a reasonable\norder until it finds one that can work, but this hint allows the app or\nuser to force a specific target.\n\nIf the specified target does not exist or is not available, the\ndialog-related function calls will fail.\n\nThis hint currently only applies to platforms using the generic \"Unix\"\ndialog implementation, but may be extended to more platforms in the future.\nNote that some Unix and Unix-like platforms have their own implementation,\nsuch as macOS and Haiku.\n\nThe variable can be set to the following values:\n\n- nullptr: Select automatically (default, all platforms)\n- \"portal\": Use XDG Portals through DBus (Unix only)\n- \"zenity\": Use the Zenity program (Unix only)\n\nMore options may be added in the future.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_FILE_DIALOG_DRIVER",
          "kind": "def",
          "value": "\"SDL_FILE_DIALOG_DRIVER\"",
          "sourceName": "SDL_HINT_FILE_DIALOG_DRIVER"
        },
        "SDL_HINT_DISPLAY_USABLE_BOUNDS": {
          "doc": "Override for Display.GetUsableBounds().\n\nIf set, this hint will override the expected results for\nDisplay.GetUsableBounds() for display index 0. Generally you don't want\nto do this, but this allows an embedded system to request that some of the\nscreen be reserved for other uses when paired with a well-behaved\napplication.\n\nThe contents of this hint must be 4 comma-separated integers, the first is\nthe bounds x, then y, width and height, in that order.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_DISPLAY_USABLE_BOUNDS",
          "kind": "def",
          "value": "\"SDL_DISPLAY_USABLE_BOUNDS\"",
          "sourceName": "SDL_HINT_DISPLAY_USABLE_BOUNDS"
        },
        "SDL_HINT_EMSCRIPTEN_ASYNCIFY": {
          "doc": "Disable giving back control to the browser automatically when running with\nasyncify.\n\nWith -s ASYNCIFY, SDL calls emscripten_sleep during operations such as\nrefreshing the screen or polling events.\n\nThis hint only applies to the emscripten platform.\n\nThe variable can be set to the following values:\n\n- \"0\": Disable emscripten_sleep calls (if you give back browser control\n  manually or use asyncify for other purposes).\n- \"1\": Enable emscripten_sleep calls. (default)\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_EMSCRIPTEN_ASYNCIFY",
          "kind": "def",
          "value": "\"SDL_EMSCRIPTEN_ASYNCIFY\"",
          "sourceName": "SDL_HINT_EMSCRIPTEN_ASYNCIFY"
        },
        "SDL_HINT_EMSCRIPTEN_CANVAS_SELECTOR": {
          "doc": "Specify the CSS selector used for the \"default\" window/canvas.\n\nThis hint only applies to the emscripten platform.\n\nThe default value is \"#canvas\"\n\nThis hint should be set before creating a window.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_EMSCRIPTEN_CANVAS_SELECTOR",
          "kind": "def",
          "value": "\"SDL_EMSCRIPTEN_CANVAS_SELECTOR\"",
          "sourceName": "SDL_HINT_EMSCRIPTEN_CANVAS_SELECTOR"
        },
        "SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT": {
          "doc": "Override the binding element for keyboard inputs for Emscripten builds.\n\nThis hint only applies to the emscripten platform.\n\nThe variable can be one of:\n\n- \"#window\": the javascript window object (default)\n- \"#document\": the javascript document object\n- \"#screen\": the javascript window.screen object\n- \"#canvas\": the WebGL canvas element\n- \"#none\": Don't bind anything at all\n- any other string without a leading # sign applies to the element on the\n  page with that ID.\n\nThis hint should be set before creating a window.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT",
          "kind": "def",
          "value": "\"SDL_EMSCRIPTEN_KEYBOARD_ELEMENT\"",
          "sourceName": "SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT"
        },
        "SDL_HINT_ENABLE_SCREEN_KEYBOARD": {
          "doc": "A variable that controls whether the on-screen keyboard should be shown\nwhen text input is active.\n\nThe variable can be set to the following values:\n\n- \"auto\": The on-screen keyboard will be shown if there is no physical\n  keyboard attached. (default)\n- \"0\": Do not show the on-screen keyboard.\n- \"1\": Show the on-screen keyboard, if available.\n\nThis hint must be set before WindowBase<T>::StartTextInput() is called\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_ENABLE_SCREEN_KEYBOARD",
          "kind": "def",
          "value": "\"SDL_ENABLE_SCREEN_KEYBOARD\"",
          "sourceName": "SDL_HINT_ENABLE_SCREEN_KEYBOARD"
        },
        "SDL_HINT_EVDEV_DEVICES": {
          "doc": "A variable containing a list of evdev devices to use if udev is not\navailable.\n\nThe list of devices is in the form:\n\ndeviceclass:path[,deviceclass:path[,...]]\n\nwhere device class is an integer representing the SDL_UDEV_deviceclass and\npath is the full path to the event device.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_EVDEV_DEVICES",
          "kind": "def",
          "value": "\"SDL_EVDEV_DEVICES\"",
          "sourceName": "SDL_HINT_EVDEV_DEVICES"
        },
        "SDL_HINT_EVENT_LOGGING": {
          "doc": "A variable controlling verbosity of the logging of SDL events pushed onto\nthe internal queue.\n\nThe variable can be set to the following values, from least to most\nverbose:\n\n- \"0\": Don't log any events. (default)\n- \"1\": Log most events (other than the really spammy ones).\n- \"2\": Include mouse and finger motion events.\n\nThis is generally meant to be used to debug SDL itself, but can be useful\nfor application developers that need better visibility into what is going\non in the event queue. Logged events are sent through Log(), which\nmeans by default they appear on stdout on most platforms or maybe\nOutputDebugString() on Windows, and can be funneled by the app with\nSetLogOutputFunction(), etc.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_EVENT_LOGGING",
          "kind": "def",
          "value": "\"SDL_EVENT_LOGGING\"",
          "sourceName": "SDL_HINT_EVENT_LOGGING"
        },
        "SDL_HINT_FORCE_RAISEWINDOW": {
          "doc": "A variable controlling whether raising the window should be done more\nforcefully.\n\nThe variable can be set to the following values:\n\n- \"0\": Honor the OS policy for raising windows. (default)\n- \"1\": Force the window to be raised, overriding any OS policy.\n\nAt present, this is only an issue under MS Windows, which makes it nearly\nimpossible to programmatically move a window to the foreground, for\n\"security\" reasons. See http://stackoverflow.com/a/34414846 for a\ndiscussion.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_FORCE_RAISEWINDOW",
          "kind": "def",
          "value": "\"SDL_FORCE_RAISEWINDOW\"",
          "sourceName": "SDL_HINT_FORCE_RAISEWINDOW"
        },
        "SDL_HINT_FRAMEBUFFER_ACCELERATION": {
          "doc": "A variable controlling how 3D acceleration is used to accelerate the SDL\nscreen surface.\n\nSDL can try to accelerate the SDL screen surface by using streaming\ntextures with a 3D rendering engine. This variable controls whether and how\nthis is done.\n\nThe variable can be set to the following values:\n\n- \"0\": Disable 3D acceleration\n- \"1\": Enable 3D acceleration, using the default renderer. (default)\n- \"X\": Enable 3D acceleration, using X where X is one of the valid\n  rendering drivers. (e.g. \"direct3d\", \"opengl\", etc.)\n\nThis hint should be set before calling WindowBase.GetSurface()\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_FRAMEBUFFER_ACCELERATION",
          "kind": "def",
          "value": "\"SDL_FRAMEBUFFER_ACCELERATION\"",
          "sourceName": "SDL_HINT_FRAMEBUFFER_ACCELERATION"
        },
        "SDL_HINT_GAMECONTROLLERCONFIG": {
          "doc": "A variable that lets you manually hint extra gamecontroller db entries.\n\nThe variable should be newline delimited rows of gamecontroller config\ndata, see SDL_gamepad.h\n\nYou can update mappings after SDL is initialized with\nSDL_GetGamepadMappingForGUID() and SDL_AddGamepadMapping()\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_GAMECONTROLLERCONFIG",
          "kind": "def",
          "value": "\"SDL_GAMECONTROLLERCONFIG\"",
          "sourceName": "SDL_HINT_GAMECONTROLLERCONFIG"
        },
        "SDL_HINT_GAMECONTROLLERCONFIG_FILE": {
          "doc": "A variable that lets you provide a file with extra gamecontroller db\nentries.\n\nThe file should contain lines of gamecontroller config data, see\nSDL_gamepad.h\n\nYou can update mappings after SDL is initialized with\nSDL_GetGamepadMappingForGUID() and SDL_AddGamepadMapping()\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_GAMECONTROLLERCONFIG_FILE",
          "kind": "def",
          "value": "\"SDL_GAMECONTROLLERCONFIG_FILE\"",
          "sourceName": "SDL_HINT_GAMECONTROLLERCONFIG_FILE"
        },
        "SDL_HINT_GAMECONTROLLERTYPE": {
          "doc": "A variable that overrides the automatic controller type detection.\n\nThe variable should be comma separated entries, in the form: VID/PID=type\n\nThe VID and PID should be hexadecimal with exactly 4 digits, e.g. 0x00fd\n\nThis hint affects what low level protocol is used with the HIDAPI driver.\n\nThe variable can be set to the following values:\n\n- \"Xbox360\"\n- \"XboxOne\"\n- \"PS3\"\n- \"PS4\"\n- \"PS5\"\n- \"SwitchPro\"\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_GAMECONTROLLERTYPE",
          "kind": "def",
          "value": "\"SDL_GAMECONTROLLERTYPE\"",
          "sourceName": "SDL_HINT_GAMECONTROLLERTYPE"
        },
        "SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES": {
          "doc": "A variable containing a list of devices to skip when scanning for game\ncontrollers.\n\nThe format of the string is a comma separated list of USB VID/PID pairs in\nhexadecimal form, e.g.\n\n0xAAAA/0xBBBB,0xCCCC/0xDDDD\n\nThe variable can also take the form of \"@file\", in which case the named\nfile will be loaded and interpreted as the value of the variable.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES",
          "kind": "def",
          "value": "\"SDL_GAMECONTROLLER_IGNORE_DEVICES\"",
          "sourceName": "SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES"
        },
        "SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT": {
          "doc": "If set, all devices will be skipped when scanning for game controllers\nexcept for the ones listed in this variable.\n\nThe format of the string is a comma separated list of USB VID/PID pairs in\nhexadecimal form, e.g.\n\n0xAAAA/0xBBBB,0xCCCC/0xDDDD\n\nThe variable can also take the form of \"@file\", in which case the named\nfile will be loaded and interpreted as the value of the variable.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT",
          "kind": "def",
          "value": "\"SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT\"",
          "sourceName": "SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT"
        },
        "SDL_HINT_GAMECONTROLLER_SENSOR_FUSION": {
          "doc": "A variable that controls whether the device's built-in accelerometer and\ngyro should be used as sensors for gamepads.\n\nThe variable can be set to the following values:\n\n- \"0\": Sensor fusion is disabled\n- \"1\": Sensor fusion is enabled for all controllers that lack sensors\n\nOr the variable can be a comma separated list of USB VID/PID pairs in\nhexadecimal form, e.g.\n\n0xAAAA/0xBBBB,0xCCCC/0xDDDD\n\nThe variable can also take the form of \"@file\", in which case the named\nfile will be loaded and interpreted as the value of the variable.\n\nThis hint should be set before a gamepad is opened.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_GAMECONTROLLER_SENSOR_FUSION",
          "kind": "def",
          "value": "\"SDL_GAMECONTROLLER_SENSOR_FUSION\"",
          "sourceName": "SDL_HINT_GAMECONTROLLER_SENSOR_FUSION"
        },
        "SDL_HINT_GDK_TEXTINPUT_DEFAULT_TEXT": {
          "doc": "This variable sets the default text of the TextInput window on GDK\nplatforms.\n\nThis hint is available only if SDL_GDK_TEXTINPUT defined.\n\nThis hint should be set before calling WindowBase<T>::StartTextInput()\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_GDK_TEXTINPUT_DEFAULT_TEXT",
          "kind": "def",
          "value": "\"SDL_GDK_TEXTINPUT_DEFAULT_TEXT\"",
          "sourceName": "SDL_HINT_GDK_TEXTINPUT_DEFAULT_TEXT"
        },
        "SDL_HINT_GDK_TEXTINPUT_DESCRIPTION": {
          "doc": "This variable sets the description of the TextInput window on GDK\nplatforms.\n\nThis hint is available only if SDL_GDK_TEXTINPUT defined.\n\nThis hint should be set before calling WindowBase<T>::StartTextInput()\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_GDK_TEXTINPUT_DESCRIPTION",
          "kind": "def",
          "value": "\"SDL_GDK_TEXTINPUT_DESCRIPTION\"",
          "sourceName": "SDL_HINT_GDK_TEXTINPUT_DESCRIPTION"
        },
        "SDL_HINT_GDK_TEXTINPUT_MAX_LENGTH": {
          "doc": "This variable sets the maximum input length of the TextInput window on GDK\nplatforms.\n\nThe value must be a stringified integer, for example \"10\" to allow for up\nto 10 characters of text input.\n\nThis hint is available only if SDL_GDK_TEXTINPUT defined.\n\nThis hint should be set before calling WindowBase<T>::StartTextInput()\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_GDK_TEXTINPUT_MAX_LENGTH",
          "kind": "def",
          "value": "\"SDL_GDK_TEXTINPUT_MAX_LENGTH\"",
          "sourceName": "SDL_HINT_GDK_TEXTINPUT_MAX_LENGTH"
        },
        "SDL_HINT_GDK_TEXTINPUT_SCOPE": {
          "doc": "This variable sets the input scope of the TextInput window on GDK\nplatforms.\n\nSet this hint to change the XGameUiTextEntryInputScope value that will be\npassed to the window creation function. The value must be a stringified\ninteger, for example \"0\" for XGameUiTextEntryInputScope::Default.\n\nThis hint is available only if SDL_GDK_TEXTINPUT defined.\n\nThis hint should be set before calling WindowBase<T>::StartTextInput()\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_GDK_TEXTINPUT_SCOPE",
          "kind": "def",
          "value": "\"SDL_GDK_TEXTINPUT_SCOPE\"",
          "sourceName": "SDL_HINT_GDK_TEXTINPUT_SCOPE"
        },
        "SDL_HINT_GDK_TEXTINPUT_TITLE": {
          "doc": "This variable sets the title of the TextInput window on GDK platforms.\n\nThis hint is available only if SDL_GDK_TEXTINPUT defined.\n\nThis hint should be set before calling WindowBase<T>::StartTextInput()\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_GDK_TEXTINPUT_TITLE",
          "kind": "def",
          "value": "\"SDL_GDK_TEXTINPUT_TITLE\"",
          "sourceName": "SDL_HINT_GDK_TEXTINPUT_TITLE"
        },
        "SDL_HINT_HIDAPI_LIBUSB": {
          "doc": "A variable to control whether HIDAPI uses libusb for device access.\n\nBy default libusb will only be used for a few devices that require direct\nUSB access, and this can be controlled with\nSDL_HINT_HIDAPI_LIBUSB_WHITELIST.\n\nThe variable can be set to the following values:\n\n- \"0\": HIDAPI will not use libusb for device access.\n- \"1\": HIDAPI will use libusb for device access if available. (default)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_HIDAPI_LIBUSB",
          "kind": "def",
          "value": "\"SDL_HIDAPI_LIBUSB\"",
          "sourceName": "SDL_HINT_HIDAPI_LIBUSB"
        },
        "SDL_HINT_HIDAPI_LIBUSB_WHITELIST": {
          "doc": "A variable to control whether HIDAPI uses libusb only for whitelisted\ndevices.\n\nBy default libusb will only be used for a few devices that require direct\nUSB access.\n\nThe variable can be set to the following values:\n\n- \"0\": HIDAPI will use libusb for all device access.\n- \"1\": HIDAPI will use libusb only for whitelisted devices. (default)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_HIDAPI_LIBUSB_WHITELIST",
          "kind": "def",
          "value": "\"SDL_HIDAPI_LIBUSB_WHITELIST\"",
          "sourceName": "SDL_HINT_HIDAPI_LIBUSB_WHITELIST"
        },
        "SDL_HINT_HIDAPI_UDEV": {
          "doc": "A variable to control whether HIDAPI uses udev for device detection.\n\nThe variable can be set to the following values:\n\n- \"0\": HIDAPI will poll for device changes.\n- \"1\": HIDAPI will use udev for device detection. (default)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_HIDAPI_UDEV",
          "kind": "def",
          "value": "\"SDL_HIDAPI_UDEV\"",
          "sourceName": "SDL_HINT_HIDAPI_UDEV"
        },
        "SDL_HINT_GPU_DRIVER": {
          "doc": "A variable that specifies a GPU backend to use.\n\nBy default, SDL will try all available GPU backends in a reasonable order\nuntil it finds one that can work, but this hint allows the app or user to\nforce a specific target, such as \"direct3d11\" if, say, your hardware\nsupports D3D12 but want to try using D3D11 instead.\n\nThis hint should be set before any GPU functions are called.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_GPU_DRIVER",
          "kind": "def",
          "value": "\"SDL_GPU_DRIVER\"",
          "sourceName": "SDL_HINT_GPU_DRIVER"
        },
        "SDL_HINT_HIDAPI_ENUMERATE_ONLY_CONTROLLERS": {
          "doc": "A variable to control whether SDL_hid_enumerate() enumerates all HID\ndevices or only controllers.\n\nThe variable can be set to the following values:\n\n- \"0\": SDL_hid_enumerate() will enumerate all HID devices.\n- \"1\": SDL_hid_enumerate() will only enumerate controllers. (default)\n\nBy default SDL will only enumerate controllers, to reduce risk of hanging\nor crashing on devices with bad drivers and avoiding macOS keyboard capture\npermission prompts.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_HIDAPI_ENUMERATE_ONLY_CONTROLLERS",
          "kind": "def",
          "value": "\"SDL_HIDAPI_ENUMERATE_ONLY_CONTROLLERS\"",
          "sourceName": "SDL_HINT_HIDAPI_ENUMERATE_ONLY_CONTROLLERS"
        },
        "SDL_HINT_HIDAPI_IGNORE_DEVICES": {
          "doc": "A variable containing a list of devices to ignore in SDL_hid_enumerate().\n\nThe format of the string is a comma separated list of USB VID/PID pairs in\nhexadecimal form, e.g.\n\n`0xAAAA/0xBBBB,0xCCCC/0xDDDD`\n\nFor example, to ignore the Shanwan DS3 controller and any Valve controller,\nyou might use the string \"0x2563/0x0523,0x28de/0x0000\"\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_HIDAPI_IGNORE_DEVICES",
          "kind": "def",
          "value": "\"SDL_HIDAPI_IGNORE_DEVICES\"",
          "sourceName": "SDL_HINT_HIDAPI_IGNORE_DEVICES"
        },
        "SDL_HINT_IME_IMPLEMENTED_UI": {
          "doc": "A variable describing what IME UI elements the application can display.\n\nBy default IME UI is handled using native components by the OS where\npossible, however this can interfere with or not be visible when exclusive\nfullscreen mode is used.\n\nThe variable can be set to a comma separated list containing the following\nitems:\n\n- \"none\" or \"0\": The application can't render any IME elements, and native\n  UI should be used. (default)\n- \"composition\": The application handles EVENT_TEXT_EDITING events and\n  can render the composition text.\n- \"candidates\": The application handles EVENT_TEXT_EDITING_CANDIDATES\n  and can render the candidate list.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_IME_IMPLEMENTED_UI",
          "kind": "def",
          "value": "\"SDL_IME_IMPLEMENTED_UI\"",
          "sourceName": "SDL_HINT_IME_IMPLEMENTED_UI"
        },
        "SDL_HINT_IOS_HIDE_HOME_INDICATOR": {
          "doc": "A variable controlling whether the home indicator bar on iPhone X should be\nhidden.\n\nThe variable can be set to the following values:\n\n- \"0\": The indicator bar is not hidden. (default for windowed applications)\n- \"1\": The indicator bar is hidden and is shown when the screen is touched\n  (useful for movie playback applications).\n- \"2\": The indicator bar is dim and the first swipe makes it visible and\n  the second swipe performs the \"home\" action. (default for fullscreen\n  applications)\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_IOS_HIDE_HOME_INDICATOR",
          "kind": "def",
          "value": "\"SDL_IOS_HIDE_HOME_INDICATOR\"",
          "sourceName": "SDL_HINT_IOS_HIDE_HOME_INDICATOR"
        },
        "SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS": {
          "doc": "A variable that lets you enable joystick (and gamecontroller) events even\nwhen your app is in the background.\n\nThe variable can be set to the following values:\n\n- \"0\": Disable joystick & gamecontroller input events when the application\n  is in the background. (default)\n- \"1\": Enable joystick & gamecontroller input events when the application\n  is in the background.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_ALLOW_BACKGROUND_EVENTS\"",
          "sourceName": "SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS"
        },
        "SDL_HINT_JOYSTICK_ARCADESTICK_DEVICES": {
          "doc": "A variable containing a list of arcade stick style controllers.\n\nThe format of the string is a comma separated list of USB VID/PID pairs in\nhexadecimal form, e.g.\n\n`0xAAAA/0xBBBB,0xCCCC/0xDDDD`\n\nThe variable can also take the form of \"@file\", in which case the named\nfile will be loaded and interpreted as the value of the variable.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_ARCADESTICK_DEVICES",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_ARCADESTICK_DEVICES\"",
          "sourceName": "SDL_HINT_JOYSTICK_ARCADESTICK_DEVICES"
        },
        "SDL_HINT_JOYSTICK_ARCADESTICK_DEVICES_EXCLUDED": {
          "doc": "A variable containing a list of devices that are not arcade stick style\ncontrollers.\n\nThis will override SDL_HINT_JOYSTICK_ARCADESTICK_DEVICES and the built in\ndevice list.\n\nThe format of the string is a comma separated list of USB VID/PID pairs in\nhexadecimal form, e.g.\n\n`0xAAAA/0xBBBB,0xCCCC/0xDDDD`\n\nThe variable can also take the form of \"@file\", in which case the named\nfile will be loaded and interpreted as the value of the variable.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_ARCADESTICK_DEVICES_EXCLUDED",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_ARCADESTICK_DEVICES_EXCLUDED\"",
          "sourceName": "SDL_HINT_JOYSTICK_ARCADESTICK_DEVICES_EXCLUDED"
        },
        "SDL_HINT_JOYSTICK_BLACKLIST_DEVICES": {
          "doc": "A variable containing a list of devices that should not be considered\njoysticks.\n\nThe format of the string is a comma separated list of USB VID/PID pairs in\nhexadecimal form, e.g.\n\n`0xAAAA/0xBBBB,0xCCCC/0xDDDD`\n\nThe variable can also take the form of \"@file\", in which case the named\nfile will be loaded and interpreted as the value of the variable.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_BLACKLIST_DEVICES",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_BLACKLIST_DEVICES\"",
          "sourceName": "SDL_HINT_JOYSTICK_BLACKLIST_DEVICES"
        },
        "SDL_HINT_JOYSTICK_BLACKLIST_DEVICES_EXCLUDED": {
          "doc": "A variable containing a list of devices that should be considered\njoysticks.\n\nThis will override SDL_HINT_JOYSTICK_BLACKLIST_DEVICES and the built in\ndevice list.\n\nThe format of the string is a comma separated list of USB VID/PID pairs in\nhexadecimal form, e.g.\n\n`0xAAAA/0xBBBB,0xCCCC/0xDDDD`\n\nThe variable can also take the form of \"@file\", in which case the named\nfile will be loaded and interpreted as the value of the variable.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_BLACKLIST_DEVICES_EXCLUDED",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_BLACKLIST_DEVICES_EXCLUDED\"",
          "sourceName": "SDL_HINT_JOYSTICK_BLACKLIST_DEVICES_EXCLUDED"
        },
        "SDL_HINT_JOYSTICK_DEVICE": {
          "doc": "A variable containing a comma separated list of devices to open as\njoysticks.\n\nThis variable is currently only used by the Linux joystick driver.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_DEVICE",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_DEVICE\"",
          "sourceName": "SDL_HINT_JOYSTICK_DEVICE"
        },
        "SDL_HINT_JOYSTICK_ENHANCED_REPORTS": {
          "doc": "A variable controlling whether enhanced reports should be used for\ncontrollers when using the HIDAPI driver.\n\nEnhanced reports allow rumble and effects on Bluetooth PlayStation\ncontrollers and gyro on Nintendo Switch controllers, but break Windows\nDirectInput for other applications that don't use SDL.\n\nOnce enhanced reports are enabled, they can't be disabled on PlayStation\ncontrollers without power cycling the controller.\n\nThe variable can be set to the following values:\n\n- \"0\": enhanced reports are not enabled.\n- \"1\": enhanced reports are enabled. (default)\n- \"auto\": enhanced features are advertised to the application, but SDL\n  doesn't change the controller report mode unless the application uses\n  them.\n\nThis hint can be enabled anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_ENHANCED_REPORTS",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_ENHANCED_REPORTS\"",
          "sourceName": "SDL_HINT_JOYSTICK_ENHANCED_REPORTS"
        },
        "SDL_HINT_JOYSTICK_FLIGHTSTICK_DEVICES": {
          "doc": "A variable containing a list of flightstick style controllers.\n\nThe format of the string is a comma separated list of USB VID/PID pairs in\nhexadecimal form, e.g.\n\n`0xAAAA/0xBBBB,0xCCCC/0xDDDD`\n\nThe variable can also take the form of @file, in which case the named file\nwill be loaded and interpreted as the value of the variable.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_FLIGHTSTICK_DEVICES",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_FLIGHTSTICK_DEVICES\"",
          "sourceName": "SDL_HINT_JOYSTICK_FLIGHTSTICK_DEVICES"
        },
        "SDL_HINT_JOYSTICK_FLIGHTSTICK_DEVICES_EXCLUDED": {
          "doc": "A variable containing a list of devices that are not flightstick style\ncontrollers.\n\nThis will override SDL_HINT_JOYSTICK_FLIGHTSTICK_DEVICES and the built in\ndevice list.\n\nThe format of the string is a comma separated list of USB VID/PID pairs in\nhexadecimal form, e.g.\n\n`0xAAAA/0xBBBB,0xCCCC/0xDDDD`\n\nThe variable can also take the form of \"@file\", in which case the named\nfile will be loaded and interpreted as the value of the variable.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_FLIGHTSTICK_DEVICES_EXCLUDED",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_FLIGHTSTICK_DEVICES_EXCLUDED\"",
          "sourceName": "SDL_HINT_JOYSTICK_FLIGHTSTICK_DEVICES_EXCLUDED"
        },
        "SDL_HINT_JOYSTICK_GAMEINPUT": {
          "doc": "A variable controlling whether GameInput should be used for controller\nhandling on Windows.\n\nThe variable can be set to the following values:\n\n- \"0\": GameInput is not used.\n- \"1\": GameInput is used.\n\nThe default is \"1\" on GDK platforms, and \"0\" otherwise.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_GAMEINPUT",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_GAMEINPUT\"",
          "sourceName": "SDL_HINT_JOYSTICK_GAMEINPUT"
        },
        "SDL_HINT_JOYSTICK_GAMECUBE_DEVICES": {
          "doc": "A variable containing a list of devices known to have a GameCube form\nfactor.\n\nThe format of the string is a comma separated list of USB VID/PID pairs in\nhexadecimal form, e.g.\n\n`0xAAAA/0xBBBB,0xCCCC/0xDDDD`\n\nThe variable can also take the form of \"@file\", in which case the named\nfile will be loaded and interpreted as the value of the variable.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_GAMECUBE_DEVICES",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_GAMECUBE_DEVICES\"",
          "sourceName": "SDL_HINT_JOYSTICK_GAMECUBE_DEVICES"
        },
        "SDL_HINT_JOYSTICK_GAMECUBE_DEVICES_EXCLUDED": {
          "doc": "A variable containing a list of devices known not to have a GameCube form\nfactor.\n\nThis will override SDL_HINT_JOYSTICK_GAMECUBE_DEVICES and the built in\ndevice list.\n\nThe format of the string is a comma separated list of USB VID/PID pairs in\nhexadecimal form, e.g.\n\n`0xAAAA/0xBBBB,0xCCCC/0xDDDD`\n\nThe variable can also take the form of \"@file\", in which case the named\nfile will be loaded and interpreted as the value of the variable.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_GAMECUBE_DEVICES_EXCLUDED",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_GAMECUBE_DEVICES_EXCLUDED\"",
          "sourceName": "SDL_HINT_JOYSTICK_GAMECUBE_DEVICES_EXCLUDED"
        },
        "SDL_HINT_JOYSTICK_HIDAPI": {
          "doc": "A variable controlling whether the HIDAPI joystick drivers should be used.\n\nThe variable can be set to the following values:\n\n- \"0\": HIDAPI drivers are not used.\n- \"1\": HIDAPI drivers are used. (default)\n\nThis variable is the default for all drivers, but can be overridden by the\nhints for specific drivers below.\n\nThis hint should be set before initializing joysticks and gamepads.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_COMBINE_JOY_CONS": {
          "doc": "A variable controlling whether Nintendo Switch Joy-Con controllers will be\ncombined into a single Pro-like controller when using the HIDAPI driver.\n\nThe variable can be set to the following values:\n\n- \"0\": Left and right Joy-Con controllers will not be combined and each\n  will be a mini-gamepad.\n- \"1\": Left and right Joy-Con controllers will be combined into a single\n  controller. (default)\n\nThis hint should be set before initializing joysticks and gamepads.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_COMBINE_JOY_CONS",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_COMBINE_JOY_CONS\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_COMBINE_JOY_CONS"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE": {
          "doc": "A variable controlling whether the HIDAPI driver for Nintendo GameCube\ncontrollers should be used.\n\nThe variable can be set to the following values:\n\n- \"0\": HIDAPI driver is not used.\n- \"1\": HIDAPI driver is used.\n\nThe default is the value of SDL_HINT_JOYSTICK_HIDAPI\n\nThis hint should be set before initializing joysticks and gamepads.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_GAMECUBE\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE_RUMBLE_BRAKE": {
          "doc": "A variable controlling whether rumble is used to implement the GameCube\ncontroller's 3 rumble modes, Stop(0), Rumble(1), and StopHard(2).\n\nThis is useful for applications that need full compatibility for things\nlike ADSR envelopes. - Stop is implemented by setting low_frequency_rumble\nto 0 and high_frequency_rumble >0 - Rumble is both at any arbitrary value -\nStopHard is implemented by setting both low_frequency_rumble and\nhigh_frequency_rumble to 0\n\nThe variable can be set to the following values:\n\n- \"0\": Normal rumble behavior is behavior is used. (default)\n- \"1\": Proper GameCube controller rumble behavior is used.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE_RUMBLE_BRAKE",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_GAMECUBE_RUMBLE_BRAKE\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE_RUMBLE_BRAKE"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_JOY_CONS": {
          "doc": "A variable controlling whether the HIDAPI driver for Nintendo Switch\nJoy-Cons should be used.\n\nThe variable can be set to the following values:\n\n- \"0\": HIDAPI driver is not used.\n- \"1\": HIDAPI driver is used.\n\nThe default is the value of SDL_HINT_JOYSTICK_HIDAPI.\n\nThis hint should be set before initializing joysticks and gamepads.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_JOY_CONS",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_JOY_CONS\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_JOY_CONS"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_JOYCON_HOME_LED": {
          "doc": "A variable controlling whether the Home button LED should be turned on when\na Nintendo Switch Joy-Con controller is opened.\n\nThe variable can be set to the following values:\n\n- \"0\": home button LED is turned off\n- \"1\": home button LED is turned on\n\nBy default the Home button LED state is not changed. This hint can also be\nset to a floating point value between 0.0 and 1.0 which controls the\nbrightness of the Home button LED.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_JOYCON_HOME_LED",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_JOYCON_HOME_LED\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_JOYCON_HOME_LED"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_LUNA": {
          "doc": "A variable controlling whether the HIDAPI driver for Amazon Luna\ncontrollers connected via Bluetooth should be used.\n\nThe variable can be set to the following values:\n\n- \"0\": HIDAPI driver is not used.\n- \"1\": HIDAPI driver is used.\n\nThe default is the value of SDL_HINT_JOYSTICK_HIDAPI.\n\nThis hint should be set before initializing joysticks and gamepads.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_LUNA",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_LUNA\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_LUNA"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_NINTENDO_CLASSIC": {
          "doc": "A variable controlling whether the HIDAPI driver for Nintendo Online\nclassic controllers should be used.\n\nThe variable can be set to the following values:\n\n- \"0\": HIDAPI driver is not used.\n- \"1\": HIDAPI driver is used.\n\nThe default is the value of SDL_HINT_JOYSTICK_HIDAPI.\n\nThis hint should be set before initializing joysticks and gamepads.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_NINTENDO_CLASSIC",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_NINTENDO_CLASSIC\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_NINTENDO_CLASSIC"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_PS3": {
          "doc": "A variable controlling whether the HIDAPI driver for PS3 controllers should\nbe used.\n\nThe variable can be set to the following values:\n\n- \"0\": HIDAPI driver is not used.\n- \"1\": HIDAPI driver is used.\n\nThe default is the value of SDL_HINT_JOYSTICK_HIDAPI on macOS, and \"0\" on\nother platforms.\n\nFor official Sony driver (sixaxis.sys) use\nSDL_HINT_JOYSTICK_HIDAPI_PS3_SIXAXIS_DRIVER. See\nhttps://github.com/ViGEm/DsHidMini for an alternative driver on Windows.\n\nThis hint should be set before initializing joysticks and gamepads.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_PS3",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_PS3\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_PS3"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_PS3_SIXAXIS_DRIVER": {
          "doc": "A variable controlling whether the Sony driver (sixaxis.sys) for PS3\ncontrollers (Sixaxis/DualShock 3) should be used.\n\nThe variable can be set to the following values:\n\n- \"0\": Sony driver (sixaxis.sys) is not used.\n- \"1\": Sony driver (sixaxis.sys) is used.\n\nThe default value is 0.\n\nThis hint should be set before initializing joysticks and gamepads.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_PS3_SIXAXIS_DRIVER",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_PS3_SIXAXIS_DRIVER\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_PS3_SIXAXIS_DRIVER"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_PS4": {
          "doc": "A variable controlling whether the HIDAPI driver for PS4 controllers should\nbe used.\n\nThe variable can be set to the following values:\n\n- \"0\": HIDAPI driver is not used.\n- \"1\": HIDAPI driver is used.\n\nThe default is the value of SDL_HINT_JOYSTICK_HIDAPI.\n\nThis hint should be set before initializing joysticks and gamepads.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_PS4",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_PS4\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_PS4"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_PS4_REPORT_INTERVAL": {
          "doc": "A variable controlling the update rate of the PS4 controller over Bluetooth\nwhen using the HIDAPI driver.\n\nThis defaults to 4 ms, to match the behavior over USB, and to be more\nfriendly to other Bluetooth devices and older Bluetooth hardware on the\ncomputer. It can be set to \"1\" (1000Hz), \"2\" (500Hz) and \"4\" (250Hz)\n\nThis hint can be set anytime, but only takes effect when extended input\nreports are enabled.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_PS4_REPORT_INTERVAL",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_PS4_REPORT_INTERVAL\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_PS4_REPORT_INTERVAL"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_PS5": {
          "doc": "A variable controlling whether the HIDAPI driver for PS5 controllers should\nbe used.\n\nThe variable can be set to the following values:\n\n- \"0\": HIDAPI driver is not used.\n- \"1\": HIDAPI driver is used.\n\nThe default is the value of SDL_HINT_JOYSTICK_HIDAPI.\n\nThis hint should be set before initializing joysticks and gamepads.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_PS5",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_PS5\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_PS5"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_PS5_PLAYER_LED": {
          "doc": "A variable controlling whether the player LEDs should be lit to indicate\nwhich player is associated with a PS5 controller.\n\nThe variable can be set to the following values:\n\n- \"0\": player LEDs are not enabled.\n- \"1\": player LEDs are enabled. (default)\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_PS5_PLAYER_LED",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_PS5_PLAYER_LED\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_PS5_PLAYER_LED"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_SHIELD": {
          "doc": "A variable controlling whether the HIDAPI driver for NVIDIA SHIELD\ncontrollers should be used.\n\nThe variable can be set to the following values:\n\n- \"0\": HIDAPI driver is not used.\n- \"1\": HIDAPI driver is used.\n\nThe default is the value of SDL_HINT_JOYSTICK_HIDAPI.\n\nThis hint should be set before initializing joysticks and gamepads.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_SHIELD",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_SHIELD\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_SHIELD"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_STADIA": {
          "doc": "A variable controlling whether the HIDAPI driver for Google Stadia\ncontrollers should be used.\n\nThe variable can be set to the following values:\n\n- \"0\": HIDAPI driver is not used.\n- \"1\": HIDAPI driver is used.\n\nThe default is the value of SDL_HINT_JOYSTICK_HIDAPI.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_STADIA",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_STADIA\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_STADIA"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_STEAM": {
          "doc": "A variable controlling whether the HIDAPI driver for Bluetooth Steam\nControllers should be used.\n\nThe variable can be set to the following values:\n\n- \"0\": HIDAPI driver is not used. (default)\n- \"1\": HIDAPI driver is used for Steam Controllers, which requires\n  Bluetooth access and may prompt the user for permission on iOS and\n  Android.\n\nThis hint should be set before initializing joysticks and gamepads.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_STEAM",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_STEAM\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_STEAM"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_STEAM_HOME_LED": {
          "doc": "A variable controlling whether the Steam button LED should be turned on\nwhen a Steam controller is opened.\n\nThe variable can be set to the following values:\n\n- \"0\": Steam button LED is turned off.\n- \"1\": Steam button LED is turned on.\n\nBy default the Steam button LED state is not changed. This hint can also be\nset to a floating point value between 0.0 and 1.0 which controls the\nbrightness of the Steam button LED.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_STEAM_HOME_LED",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_STEAM_HOME_LED\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_STEAM_HOME_LED"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_STEAMDECK": {
          "doc": "A variable controlling whether the HIDAPI driver for the Steam Deck builtin\ncontroller should be used.\n\nThe variable can be set to the following values:\n\n- \"0\": HIDAPI driver is not used.\n- \"1\": HIDAPI driver is used.\n\nThe default is the value of SDL_HINT_JOYSTICK_HIDAPI.\n\nThis hint should be set before initializing joysticks and gamepads.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_STEAMDECK",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_STEAMDECK\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_STEAMDECK"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_STEAM_HORI": {
          "doc": "A variable controlling whether the HIDAPI driver for HORI licensed Steam\ncontrollers should be used.\n\nThis variable can be set to the following values: \"0\" - HIDAPI driver is\nnot used \"1\" - HIDAPI driver is used\n\nThe default is the value of SDL_HINT_JOYSTICK_HIDAPI",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_STEAM_HORI",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_STEAM_HORI\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_STEAM_HORI"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_SWITCH": {
          "doc": "A variable controlling whether the HIDAPI driver for Nintendo Switch\ncontrollers should be used.\n\nThe variable can be set to the following values:\n\n- \"0\": HIDAPI driver is not used.\n- \"1\": HIDAPI driver is used.\n\nThe default is the value of SDL_HINT_JOYSTICK_HIDAPI.\n\nThis hint should be set before initializing joysticks and gamepads.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_SWITCH",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_SWITCH\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_SWITCH"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_SWITCH_HOME_LED": {
          "doc": "A variable controlling whether the Home button LED should be turned on when\na Nintendo Switch Pro controller is opened.\n\nThe variable can be set to the following values:\n\n- \"0\": Home button LED is turned off.\n- \"1\": Home button LED is turned on.\n\nBy default the Home button LED state is not changed. This hint can also be\nset to a floating point value between 0.0 and 1.0 which controls the\nbrightness of the Home button LED.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_SWITCH_HOME_LED",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_SWITCH_HOME_LED\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_SWITCH_HOME_LED"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_SWITCH_PLAYER_LED": {
          "doc": "A variable controlling whether the player LEDs should be lit to indicate\nwhich player is associated with a Nintendo Switch controller.\n\nThe variable can be set to the following values:\n\n- \"0\": Player LEDs are not enabled.\n- \"1\": Player LEDs are enabled. (default)\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_SWITCH_PLAYER_LED",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_SWITCH_PLAYER_LED\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_SWITCH_PLAYER_LED"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_VERTICAL_JOY_CONS": {
          "doc": "A variable controlling whether Nintendo Switch Joy-Con controllers will be\nin vertical mode when using the HIDAPI driver.\n\nThe variable can be set to the following values:\n\n- \"0\": Left and right Joy-Con controllers will not be in vertical mode.\n  (default)\n- \"1\": Left and right Joy-Con controllers will be in vertical mode.\n\nThis hint should be set before opening a Joy-Con controller.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_VERTICAL_JOY_CONS",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_VERTICAL_JOY_CONS\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_VERTICAL_JOY_CONS"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_WII": {
          "doc": "A variable controlling whether the HIDAPI driver for Nintendo Wii and Wii U\ncontrollers should be used.\n\nThe variable can be set to the following values:\n\n- \"0\": HIDAPI driver is not used.\n- \"1\": HIDAPI driver is used.\n\nThis driver doesn't work with the dolphinbar, so the default is false for\nnow.\n\nThis hint should be set before initializing joysticks and gamepads.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_WII",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_WII\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_WII"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_WII_PLAYER_LED": {
          "doc": "A variable controlling whether the player LEDs should be lit to indicate\nwhich player is associated with a Wii controller.\n\nThe variable can be set to the following values:\n\n- \"0\": Player LEDs are not enabled.\n- \"1\": Player LEDs are enabled. (default)\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_WII_PLAYER_LED",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_WII_PLAYER_LED\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_WII_PLAYER_LED"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_XBOX": {
          "doc": "A variable controlling whether the HIDAPI driver for XBox controllers\nshould be used.\n\nThe variable can be set to the following values:\n\n- \"0\": HIDAPI driver is not used.\n- \"1\": HIDAPI driver is used.\n\nThe default is \"0\" on Windows, otherwise the value of\nSDL_HINT_JOYSTICK_HIDAPI\n\nThis hint should be set before initializing joysticks and gamepads.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_XBOX",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_XBOX\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_XBOX"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_XBOX_360": {
          "doc": "A variable controlling whether the HIDAPI driver for XBox 360 controllers\nshould be used.\n\nThe variable can be set to the following values:\n\n- \"0\": HIDAPI driver is not used.\n- \"1\": HIDAPI driver is used.\n\nThe default is the value of SDL_HINT_JOYSTICK_HIDAPI_XBOX\n\nThis hint should be set before initializing joysticks and gamepads.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_XBOX_360",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_XBOX_360\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_XBOX_360"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_XBOX_360_PLAYER_LED": {
          "doc": "A variable controlling whether the player LEDs should be lit to indicate\nwhich player is associated with an Xbox 360 controller.\n\nThe variable can be set to the following values:\n\n- \"0\": Player LEDs are not enabled.\n- \"1\": Player LEDs are enabled. (default)\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_XBOX_360_PLAYER_LED",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_XBOX_360_PLAYER_LED\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_XBOX_360_PLAYER_LED"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_XBOX_360_WIRELESS": {
          "doc": "A variable controlling whether the HIDAPI driver for XBox 360 wireless\ncontrollers should be used.\n\nThe variable can be set to the following values:\n\n- \"0\": HIDAPI driver is not used.\n- \"1\": HIDAPI driver is used.\n\nThe default is the value of SDL_HINT_JOYSTICK_HIDAPI_XBOX_360\n\nThis hint should be set before initializing joysticks and gamepads.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_XBOX_360_WIRELESS",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_XBOX_360_WIRELESS\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_XBOX_360_WIRELESS"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_XBOX_ONE": {
          "doc": "A variable controlling whether the HIDAPI driver for XBox One controllers\nshould be used.\n\nThe variable can be set to the following values:\n\n- \"0\": HIDAPI driver is not used.\n- \"1\": HIDAPI driver is used.\n\nThe default is the value of SDL_HINT_JOYSTICK_HIDAPI_XBOX.\n\nThis hint should be set before initializing joysticks and gamepads.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_XBOX_ONE",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_XBOX_ONE\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_XBOX_ONE"
        },
        "SDL_HINT_JOYSTICK_HIDAPI_XBOX_ONE_HOME_LED": {
          "doc": "A variable controlling whether the Home button LED should be turned on when\nan Xbox One controller is opened.\n\nThe variable can be set to the following values:\n\n- \"0\": Home button LED is turned off.\n- \"1\": Home button LED is turned on.\n\nBy default the Home button LED state is not changed. This hint can also be\nset to a floating point value between 0.0 and 1.0 which controls the\nbrightness of the Home button LED. The default brightness is 0.4.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_HIDAPI_XBOX_ONE_HOME_LED",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HIDAPI_XBOX_ONE_HOME_LED\"",
          "sourceName": "SDL_HINT_JOYSTICK_HIDAPI_XBOX_ONE_HOME_LED"
        },
        "SDL_HINT_JOYSTICK_IOKIT": {
          "doc": "A variable controlling whether IOKit should be used for controller\nhandling.\n\nThe variable can be set to the following values:\n\n- \"0\": IOKit is not used.\n- \"1\": IOKit is used. (default)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_IOKIT",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_IOKIT\"",
          "sourceName": "SDL_HINT_JOYSTICK_IOKIT"
        },
        "SDL_HINT_JOYSTICK_LINUX_CLASSIC": {
          "doc": "A variable controlling whether to use the classic /dev/input/js* joystick\ninterface or the newer /dev/input/event* joystick interface on Linux.\n\nThe variable can be set to the following values:\n\n- \"0\": Use /dev/input/event* (default)\n- \"1\": Use /dev/input/js*\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_LINUX_CLASSIC",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_LINUX_CLASSIC\"",
          "sourceName": "SDL_HINT_JOYSTICK_LINUX_CLASSIC"
        },
        "SDL_HINT_JOYSTICK_LINUX_DEADZONES": {
          "doc": "A variable controlling whether joysticks on Linux adhere to their\nHID-defined deadzones or return unfiltered values.\n\nThe variable can be set to the following values:\n\n- \"0\": Return unfiltered joystick axis values. (default)\n- \"1\": Return axis values with deadzones taken into account.\n\nThis hint should be set before a controller is opened.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_LINUX_DEADZONES",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_LINUX_DEADZONES\"",
          "sourceName": "SDL_HINT_JOYSTICK_LINUX_DEADZONES"
        },
        "SDL_HINT_JOYSTICK_LINUX_DIGITAL_HATS": {
          "doc": "A variable controlling whether joysticks on Linux will always treat 'hat'\naxis inputs (ABS_HAT0X - ABS_HAT3Y) as 8-way digital hats without checking\nwhether they may be analog.\n\nThe variable can be set to the following values:\n\n- \"0\": Only map hat axis inputs to digital hat outputs if the input axes\n  appear to actually be digital. (default)\n- \"1\": Always handle the input axes numbered ABS_HAT0X to ABS_HAT3Y as\n  digital hats.\n\nThis hint should be set before a controller is opened.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_LINUX_DIGITAL_HATS",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_LINUX_DIGITAL_HATS\"",
          "sourceName": "SDL_HINT_JOYSTICK_LINUX_DIGITAL_HATS"
        },
        "SDL_HINT_JOYSTICK_LINUX_HAT_DEADZONES": {
          "doc": "A variable controlling whether digital hats on Linux will apply deadzones\nto their underlying input axes or use unfiltered values.\n\nThe variable can be set to the following values:\n\n- \"0\": Return digital hat values based on unfiltered input axis values.\n- \"1\": Return digital hat values with deadzones on the input axes taken\n  into account. (default)\n\nThis hint should be set before a controller is opened.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_LINUX_HAT_DEADZONES",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_LINUX_HAT_DEADZONES\"",
          "sourceName": "SDL_HINT_JOYSTICK_LINUX_HAT_DEADZONES"
        },
        "SDL_HINT_JOYSTICK_MFI": {
          "doc": "A variable controlling whether GCController should be used for controller\nhandling.\n\nThe variable can be set to the following values:\n\n- \"0\": GCController is not used.\n- \"1\": GCController is used. (default)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_MFI",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_MFI\"",
          "sourceName": "SDL_HINT_JOYSTICK_MFI"
        },
        "SDL_HINT_JOYSTICK_RAWINPUT": {
          "doc": "A variable controlling whether the RAWINPUT joystick drivers should be used\nfor better handling XInput-capable devices.\n\nThe variable can be set to the following values:\n\n- \"0\": RAWINPUT drivers are not used.\n- \"1\": RAWINPUT drivers are used. (default)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_RAWINPUT",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_RAWINPUT\"",
          "sourceName": "SDL_HINT_JOYSTICK_RAWINPUT"
        },
        "SDL_HINT_JOYSTICK_RAWINPUT_CORRELATE_XINPUT": {
          "doc": "A variable controlling whether the RAWINPUT driver should pull correlated\ndata from XInput.\n\nThe variable can be set to the following values:\n\n- \"0\": RAWINPUT driver will only use data from raw input APIs.\n- \"1\": RAWINPUT driver will also pull data from XInput and\n  Windows.Gaming.Input, providing better trigger axes, guide button\n  presses, and rumble support for Xbox controllers. (default)\n\nThis hint should be set before a gamepad is opened.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_RAWINPUT_CORRELATE_XINPUT",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_RAWINPUT_CORRELATE_XINPUT\"",
          "sourceName": "SDL_HINT_JOYSTICK_RAWINPUT_CORRELATE_XINPUT"
        },
        "SDL_HINT_JOYSTICK_ROG_CHAKRAM": {
          "doc": "A variable controlling whether the ROG Chakram mice should show up as\njoysticks.\n\nThe variable can be set to the following values:\n\n- \"0\": ROG Chakram mice do not show up as joysticks. (default)\n- \"1\": ROG Chakram mice show up as joysticks.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_ROG_CHAKRAM",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_ROG_CHAKRAM\"",
          "sourceName": "SDL_HINT_JOYSTICK_ROG_CHAKRAM"
        },
        "SDL_HINT_JOYSTICK_THREAD": {
          "doc": "A variable controlling whether a separate thread should be used for\nhandling joystick detection and raw input messages on Windows.\n\nThe variable can be set to the following values:\n\n- \"0\": A separate thread is not used.\n- \"1\": A separate thread is used for handling raw input messages. (default)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_THREAD",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_THREAD\"",
          "sourceName": "SDL_HINT_JOYSTICK_THREAD"
        },
        "SDL_HINT_JOYSTICK_THROTTLE_DEVICES": {
          "doc": "A variable containing a list of throttle style controllers.\n\nThe format of the string is a comma separated list of USB VID/PID pairs in\nhexadecimal form, e.g.\n\n`0xAAAA/0xBBBB,0xCCCC/0xDDDD`\n\nThe variable can also take the form of \"@file\", in which case the named\nfile will be loaded and interpreted as the value of the variable.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_THROTTLE_DEVICES",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_THROTTLE_DEVICES\"",
          "sourceName": "SDL_HINT_JOYSTICK_THROTTLE_DEVICES"
        },
        "SDL_HINT_JOYSTICK_THROTTLE_DEVICES_EXCLUDED": {
          "doc": "A variable containing a list of devices that are not throttle style\ncontrollers.\n\nThis will override SDL_HINT_JOYSTICK_THROTTLE_DEVICES and the built in\ndevice list.\n\nThe format of the string is a comma separated list of USB VID/PID pairs in\nhexadecimal form, e.g.\n\n`0xAAAA/0xBBBB,0xCCCC/0xDDDD`\n\nThe variable can also take the form of \"@file\", in which case the named\nfile will be loaded and interpreted as the value of the variable.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_THROTTLE_DEVICES_EXCLUDED",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_THROTTLE_DEVICES_EXCLUDED\"",
          "sourceName": "SDL_HINT_JOYSTICK_THROTTLE_DEVICES_EXCLUDED"
        },
        "SDL_HINT_JOYSTICK_WGI": {
          "doc": "A variable controlling whether Windows.Gaming.Input should be used for\ncontroller handling.\n\nThe variable can be set to the following values:\n\n- \"0\": WGI is not used.\n- \"1\": WGI is used. (default)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_WGI",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_WGI\"",
          "sourceName": "SDL_HINT_JOYSTICK_WGI"
        },
        "SDL_HINT_JOYSTICK_WHEEL_DEVICES": {
          "doc": "A variable containing a list of wheel style controllers.\n\nThe format of the string is a comma separated list of USB VID/PID pairs in\nhexadecimal form, e.g.\n\n`0xAAAA/0xBBBB,0xCCCC/0xDDDD`\n\nThe variable can also take the form of \"@file\", in which case the named\nfile will be loaded and interpreted as the value of the variable.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_WHEEL_DEVICES",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_WHEEL_DEVICES\"",
          "sourceName": "SDL_HINT_JOYSTICK_WHEEL_DEVICES"
        },
        "SDL_HINT_JOYSTICK_WHEEL_DEVICES_EXCLUDED": {
          "doc": "A variable containing a list of devices that are not wheel style\ncontrollers.\n\nThis will override SDL_HINT_JOYSTICK_WHEEL_DEVICES and the built in device\nlist.\n\nThe format of the string is a comma separated list of USB VID/PID pairs in\nhexadecimal form, e.g.\n\n`0xAAAA/0xBBBB,0xCCCC/0xDDDD`\n\nThe variable can also take the form of \"@file\", in which case the named\nfile will be loaded and interpreted as the value of the variable.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_WHEEL_DEVICES_EXCLUDED",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_WHEEL_DEVICES_EXCLUDED\"",
          "sourceName": "SDL_HINT_JOYSTICK_WHEEL_DEVICES_EXCLUDED"
        },
        "SDL_HINT_JOYSTICK_ZERO_CENTERED_DEVICES": {
          "doc": "A variable containing a list of devices known to have all axes centered at\nzero.\n\nThe format of the string is a comma separated list of USB VID/PID pairs in\nhexadecimal form, e.g.\n\n`0xAAAA/0xBBBB,0xCCCC/0xDDDD`\n\nThe variable can also take the form of \"@file\", in which case the named\nfile will be loaded and interpreted as the value of the variable.\n\nThis hint should be set before a controller is opened.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_JOYSTICK_ZERO_CENTERED_DEVICES",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_ZERO_CENTERED_DEVICES\"",
          "sourceName": "SDL_HINT_JOYSTICK_ZERO_CENTERED_DEVICES"
        },
        "SDL_HINT_JOYSTICK_HAPTIC_AXES": {
          "doc": "A variable containing a list of devices and their desired number of haptic\n(force feedback) enabled axis.\n\nThe format of the string is a comma separated list of USB VID/PID pairs in\nhexadecimal form plus the number of desired axes, e.g.\n\n`0xAAAA/0xBBBB/1,0xCCCC/0xDDDD/3`\n\nThis hint supports a \"wildcard\" device that will set the number of haptic\naxes on all initialized haptic devices which were not defined explicitly in\nthis hint.\n\n`0xFFFF/0xFFFF/1`\n\nThis hint should be set before a controller is opened. The number of haptic\naxes won't exceed the number of real axes found on the device.\n\n@since This hint is available since SDL 3.2.5.",
          "name": "SDL_HINT_JOYSTICK_HAPTIC_AXES",
          "kind": "def",
          "value": "\"SDL_JOYSTICK_HAPTIC_AXES\"",
          "sourceName": "SDL_HINT_JOYSTICK_HAPTIC_AXES"
        },
        "SDL_HINT_KEYCODE_OPTIONS": {
          "doc": "A variable that controls keycode representation in keyboard events.\n\nThis variable is a comma separated set of options for translating keycodes\nin events:\n\n- \"none\": Keycode options are cleared, this overrides other options.\n- \"hide_numpad\": The numpad keysyms will be translated into their\n  non-numpad versions based on the current NumLock state. For example,\n  SDLK_KP_4 would become SDLK_4 if KMOD_NUM is set in the event\n  modifiers, and SDLK_LEFT if it is unset.\n- \"french_numbers\": The number row on French keyboards is inverted, so\n  pressing the 1 key would yield the keycode SDLK_1, or '1', instead of\n  SDLK_AMPERSAND, or '&'\n- \"latin_letters\": For keyboards using non-Latin letters, such as Russian\n  or Thai, the letter keys generate keycodes as though it had an en_US\n  layout. e.g. pressing the key associated with SCANCODE_A on a Russian\n  keyboard would yield 'a' instead of a Cyrillic letter.\n\nThe default value for this hint is \"french_numbers,latin_letters\"\n\nSome platforms like Emscripten only provide modified keycodes and the\noptions are not used.\n\nThese options do not affect the return value of Keycode::Keycode() or\nKeycode::GetScancode(), they just apply to the keycode included in key\nevents.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_KEYCODE_OPTIONS",
          "kind": "def",
          "value": "\"SDL_KEYCODE_OPTIONS\"",
          "sourceName": "SDL_HINT_KEYCODE_OPTIONS"
        },
        "SDL_HINT_KMSDRM_DEVICE_INDEX": {
          "doc": "A variable that controls what KMSDRM device to use.\n\nSDL might open something like \"/dev/dri/cardNN\" to access KMSDRM\nfunctionality, where \"NN\" is a device index number. SDL makes a guess at\nthe best index to use (usually zero), but the app or user can set this hint\nto a number between 0 and 99 to force selection.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_KMSDRM_DEVICE_INDEX",
          "kind": "def",
          "value": "\"SDL_KMSDRM_DEVICE_INDEX\"",
          "sourceName": "SDL_HINT_KMSDRM_DEVICE_INDEX"
        },
        "SDL_HINT_KMSDRM_REQUIRE_DRM_MASTER": {
          "doc": "A variable that controls whether SDL requires DRM master access in order to\ninitialize the KMSDRM video backend.\n\nThe DRM subsystem has a concept of a \"DRM master\" which is a DRM client\nthat has the ability to set planes, set cursor, etc. When SDL is DRM\nmaster, it can draw to the screen using the SDL rendering APIs. Without DRM\nmaster, SDL is still able to process input and query attributes of attached\ndisplays, but it cannot change display state or draw to the screen\ndirectly.\n\nIn some cases, it can be useful to have the KMSDRM backend even if it\ncannot be used for rendering. An app may want to use SDL for input\nprocessing while using another rendering API (such as an MMAL overlay on\nRaspberry Pi) or using its own code to render to DRM overlays that SDL\ndoesn't support.\n\nThe variable can be set to the following values:\n\n- \"0\": SDL will allow usage of the KMSDRM backend without DRM master.\n- \"1\": SDL Will require DRM master to use the KMSDRM backend. (default)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_KMSDRM_REQUIRE_DRM_MASTER",
          "kind": "def",
          "value": "\"SDL_KMSDRM_REQUIRE_DRM_MASTER\"",
          "sourceName": "SDL_HINT_KMSDRM_REQUIRE_DRM_MASTER"
        },
        "SDL_HINT_LOGGING": {
          "doc": "A variable controlling the default SDL log levels.\n\nThis variable is a comma separated set of category=level tokens that define\nthe default logging levels for SDL applications.\n\nThe category can be a numeric category, one of \"app\", \"error\", \"assert\",\n\"system\", \"audio\", \"video\", \"render\", \"input\", \"test\", or `*` for any\nunspecified category.\n\nThe level can be a numeric level, one of \"verbose\", \"debug\", \"info\",\n\"warn\", \"error\", \"critical\", or \"quiet\" to disable that category.\n\nYou can omit the category if you want to set the logging level for all\ncategories.\n\nIf this hint isn't set, the default log levels are equivalent to:\n\n`app=info,assert=warn,test=verbose,*=error`\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_LOGGING",
          "kind": "def",
          "value": "\"SDL_LOGGING\"",
          "sourceName": "SDL_HINT_LOGGING"
        },
        "SDL_HINT_MAC_BACKGROUND_APP": {
          "doc": "A variable controlling whether to force the application to become the\nforeground process when launched on macOS.\n\nThe variable can be set to the following values:\n\n- \"0\": The application is brought to the foreground when launched.\n  (default)\n- \"1\": The application may remain in the background when launched.\n\nThis hint needs to be set before InitSubSystem().\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_MAC_BACKGROUND_APP",
          "kind": "def",
          "value": "\"SDL_MAC_BACKGROUND_APP\"",
          "sourceName": "SDL_HINT_MAC_BACKGROUND_APP"
        },
        "SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK": {
          "doc": "A variable that determines whether Ctrl+Click should generate a right-click\nevent on macOS.\n\nThe variable can be set to the following values:\n\n- \"0\": Ctrl+Click does not generate a right mouse button click event.\n  (default)\n- \"1\": Ctrl+Click generated a right mouse button click event.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK",
          "kind": "def",
          "value": "\"SDL_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK\"",
          "sourceName": "SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK"
        },
        "SDL_HINT_MAC_OPENGL_ASYNC_DISPATCH": {
          "doc": "A variable controlling whether dispatching OpenGL context updates should\nblock the dispatching thread until the main thread finishes processing on\nmacOS.\n\nThe variable can be set to the following values:\n\n- \"0\": Dispatching OpenGL context updates will block the dispatching thread\n  until the main thread finishes processing. (default)\n- \"1\": Dispatching OpenGL context updates will allow the dispatching thread\n  to continue execution.\n\nGenerally you want the default, but if you have OpenGL code in a background\nthread on a Mac, and the main thread hangs because it's waiting for that\nbackground thread, but that background thread is also hanging because it's\nwaiting for the main thread to do an update, this might fix your issue.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_MAC_OPENGL_ASYNC_DISPATCH",
          "kind": "def",
          "value": "\"SDL_MAC_OPENGL_ASYNC_DISPATCH\"",
          "sourceName": "SDL_HINT_MAC_OPENGL_ASYNC_DISPATCH"
        },
        "SDL_HINT_MAC_OPTION_AS_ALT": {
          "doc": "A variable controlling whether the Option key on macOS should be remapped\nto act as the Alt key.\n\nThe variable can be set to the following values:\n\n- \"none\": The Option key is not remapped to Alt. (default)\n- \"only_left\": Only the left Option key is remapped to Alt.\n- \"only_right\": Only the right Option key is remapped to Alt.\n- \"both\": Both Option keys are remapped to Alt.\n\nThis will prevent the triggering of key compositions that rely on the\nOption key, but will still send the Alt modifier for keyboard events. In\nthe case that both Alt and Option are pressed, the Option key will be\nignored. This is particularly useful for applications like terminal\nemulators and graphical user interfaces (GUIs) that rely on Alt key\nfunctionality for shortcuts or navigation. This does not apply to\nKeycode::Keycode and only has an effect if IME is enabled.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_MAC_OPTION_AS_ALT",
          "kind": "def",
          "value": "\"SDL_MAC_OPTION_AS_ALT\"",
          "sourceName": "SDL_HINT_MAC_OPTION_AS_ALT"
        },
        "SDL_HINT_MAC_SCROLL_MOMENTUM": {
          "doc": "A variable controlling whether EVENT_MOUSE_WHEEL event values will have\nmomentum on macOS.\n\nThe variable can be set to the following values:\n\n- \"0\": The mouse wheel events will have no momentum. (default)\n- \"1\": The mouse wheel events will have momentum.\n\nThis hint needs to be set before InitSubSystem().\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_MAC_SCROLL_MOMENTUM",
          "kind": "def",
          "value": "\"SDL_MAC_SCROLL_MOMENTUM\"",
          "sourceName": "SDL_HINT_MAC_SCROLL_MOMENTUM"
        },
        "SDL_HINT_MAIN_CALLBACK_RATE": {
          "doc": "Request SDL_AppIterate() be called at a specific rate.\n\nIf this is set to a number, it represents Hz, so \"60\" means try to iterate\n60 times per second. \"0\" means to iterate as fast as possible. Negative\nvalues are illegal, but reserved, in case they are useful in a future\nrevision of SDL.\n\nThere are other strings that have special meaning. If set to \"waitevent\",\nSDL_AppIterate will not be called until new event(s) have arrived (and been\nprocessed by SDL_AppEvent). This can be useful for apps that are completely\nidle except in response to input.\n\nOn some platforms, or if you are using SDL_main instead of SDL_AppIterate,\nthis hint is ignored. When the hint can be used, it is allowed to be\nchanged at any time.\n\nThis defaults to 0, and specifying nullptr for the hint's value will restore\nthe default.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_MAIN_CALLBACK_RATE",
          "kind": "def",
          "value": "\"SDL_MAIN_CALLBACK_RATE\"",
          "sourceName": "SDL_HINT_MAIN_CALLBACK_RATE"
        },
        "SDL_HINT_MOUSE_AUTO_CAPTURE": {
          "doc": "A variable controlling whether the mouse is captured while mouse buttons\nare pressed.\n\nThe variable can be set to the following values:\n\n- \"0\": The mouse is not captured while mouse buttons are pressed.\n- \"1\": The mouse is captured while mouse buttons are pressed.\n\nBy default the mouse is captured while mouse buttons are pressed so if the\nmouse is dragged outside the window, the application continues to receive\nmouse events until the button is released.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_MOUSE_AUTO_CAPTURE",
          "kind": "def",
          "value": "\"SDL_MOUSE_AUTO_CAPTURE\"",
          "sourceName": "SDL_HINT_MOUSE_AUTO_CAPTURE"
        },
        "SDL_HINT_MOUSE_DOUBLE_CLICK_RADIUS": {
          "doc": "A variable setting the double click radius, in pixels.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_MOUSE_DOUBLE_CLICK_RADIUS",
          "kind": "def",
          "value": "\"SDL_MOUSE_DOUBLE_CLICK_RADIUS\"",
          "sourceName": "SDL_HINT_MOUSE_DOUBLE_CLICK_RADIUS"
        },
        "SDL_HINT_MOUSE_DOUBLE_CLICK_TIME": {
          "doc": "A variable setting the double click time, in milliseconds.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_MOUSE_DOUBLE_CLICK_TIME",
          "kind": "def",
          "value": "\"SDL_MOUSE_DOUBLE_CLICK_TIME\"",
          "sourceName": "SDL_HINT_MOUSE_DOUBLE_CLICK_TIME"
        },
        "SDL_HINT_MOUSE_DEFAULT_SYSTEM_CURSOR": {
          "doc": "A variable setting which system cursor to use as the default cursor.\n\nThis should be an integer corresponding to the SDL_SystemCursor enum. The\ndefault value is zero (SDL_SYSTEM_CURSOR_DEFAULT).\n\nThis hint needs to be set before InitSubSystem().\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_MOUSE_DEFAULT_SYSTEM_CURSOR",
          "kind": "def",
          "value": "\"SDL_MOUSE_DEFAULT_SYSTEM_CURSOR\"",
          "sourceName": "SDL_HINT_MOUSE_DEFAULT_SYSTEM_CURSOR"
        },
        "SDL_HINT_MOUSE_EMULATE_WARP_WITH_RELATIVE": {
          "doc": "A variable controlling whether warping a hidden mouse cursor will activate\nrelative mouse mode.\n\nWhen this hint is set, the mouse cursor is hidden, and multiple warps to\nthe window center occur within a short time period, SDL will emulate mouse\nwarps using relative mouse mode. This can provide smoother and more\nreliable mouse motion for some older games, which continuously calculate\nthe distance travelled by the mouse pointer and warp it back to the center\nof the window, rather than using relative mouse motion.\n\nNote that relative mouse mode may have different mouse acceleration\nbehavior than pointer warps.\n\nIf your application needs to repeatedly warp the hidden mouse cursor at a\nhigh-frequency for other purposes, it should disable this hint.\n\nThe variable can be set to the following values:\n\n- \"0\": Attempts to warp the mouse will always be made.\n- \"1\": Some mouse warps will be emulated by forcing relative mouse mode.\n  (default)\n\nIf not set, this is automatically enabled unless an application uses\nrelative mouse mode directly.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_MOUSE_EMULATE_WARP_WITH_RELATIVE",
          "kind": "def",
          "value": "\"SDL_MOUSE_EMULATE_WARP_WITH_RELATIVE\"",
          "sourceName": "SDL_HINT_MOUSE_EMULATE_WARP_WITH_RELATIVE"
        },
        "SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH": {
          "doc": "Allow mouse click events when clicking to focus an SDL window.\n\nThe variable can be set to the following values:\n\n- \"0\": Ignore mouse clicks that activate a window. (default)\n- \"1\": Generate events for mouse clicks that activate a window.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH",
          "kind": "def",
          "value": "\"SDL_MOUSE_FOCUS_CLICKTHROUGH\"",
          "sourceName": "SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH"
        },
        "SDL_HINT_MOUSE_NORMAL_SPEED_SCALE": {
          "doc": "A variable setting the speed scale for mouse motion, in floating point,\nwhen the mouse is not in relative mode.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_MOUSE_NORMAL_SPEED_SCALE",
          "kind": "def",
          "value": "\"SDL_MOUSE_NORMAL_SPEED_SCALE\"",
          "sourceName": "SDL_HINT_MOUSE_NORMAL_SPEED_SCALE"
        },
        "SDL_HINT_MOUSE_RELATIVE_MODE_CENTER": {
          "doc": "A variable controlling whether relative mouse mode constrains the mouse to\nthe center of the window.\n\nConstraining to the center of the window works better for FPS games and\nwhen the application is running over RDP. Constraining to the whole window\nworks better for 2D games and increases the chance that the mouse will be\nin the correct position when using high DPI mice.\n\nThe variable can be set to the following values:\n\n- \"0\": Relative mouse mode constrains the mouse to the window.\n- \"1\": Relative mouse mode constrains the mouse to the center of the\n  window. (default)\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_MOUSE_RELATIVE_MODE_CENTER",
          "kind": "def",
          "value": "\"SDL_MOUSE_RELATIVE_MODE_CENTER\"",
          "sourceName": "SDL_HINT_MOUSE_RELATIVE_MODE_CENTER"
        },
        "SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE": {
          "doc": "A variable setting the scale for mouse motion, in floating point, when the\nmouse is in relative mode.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE",
          "kind": "def",
          "value": "\"SDL_MOUSE_RELATIVE_SPEED_SCALE\"",
          "sourceName": "SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE"
        },
        "SDL_HINT_MOUSE_RELATIVE_SYSTEM_SCALE": {
          "doc": "A variable controlling whether the system mouse acceleration curve is used\nfor relative mouse motion.\n\nThe variable can be set to the following values:\n\n- \"0\": Relative mouse motion will be unscaled. (default)\n- \"1\": Relative mouse motion will be scaled using the system mouse\n  acceleration curve.\n\nIf SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE is set, that will be applied after\nsystem speed scale.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_MOUSE_RELATIVE_SYSTEM_SCALE",
          "kind": "def",
          "value": "\"SDL_MOUSE_RELATIVE_SYSTEM_SCALE\"",
          "sourceName": "SDL_HINT_MOUSE_RELATIVE_SYSTEM_SCALE"
        },
        "SDL_HINT_MOUSE_RELATIVE_WARP_MOTION": {
          "doc": "A variable controlling whether a motion event should be generated for mouse\nwarping in relative mode.\n\nThe variable can be set to the following values:\n\n- \"0\": Warping the mouse will not generate a motion event in relative mode\n- \"1\": Warping the mouse will generate a motion event in relative mode\n\nBy default warping the mouse will not generate motion events in relative\nmode. This avoids the application having to filter out large relative\nmotion due to warping.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_MOUSE_RELATIVE_WARP_MOTION",
          "kind": "def",
          "value": "\"SDL_MOUSE_RELATIVE_WARP_MOTION\"",
          "sourceName": "SDL_HINT_MOUSE_RELATIVE_WARP_MOTION"
        },
        "SDL_HINT_MOUSE_RELATIVE_CURSOR_VISIBLE": {
          "doc": "A variable controlling whether the hardware cursor stays visible when\nrelative mode is active.\n\nThis variable can be set to the following values:\n\n- \"0\": The cursor will be hidden while relative mode is active (default)\n- \"1\": The cursor will remain visible while relative mode is active\n\nNote that for systems without raw hardware inputs, relative mode is\nimplemented using warping, so the hardware cursor will visibly warp between\nframes if this is enabled on those systems.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_MOUSE_RELATIVE_CURSOR_VISIBLE",
          "kind": "def",
          "value": "\"SDL_MOUSE_RELATIVE_CURSOR_VISIBLE\"",
          "sourceName": "SDL_HINT_MOUSE_RELATIVE_CURSOR_VISIBLE"
        },
        "SDL_HINT_MOUSE_TOUCH_EVENTS": {
          "doc": "A variable controlling whether mouse events should generate synthetic touch\nevents.\n\nThe variable can be set to the following values:\n\n- \"0\": Mouse events will not generate touch events. (default for desktop\n  platforms)\n- \"1\": Mouse events will generate touch events. (default for mobile\n  platforms, such as Android and iOS)\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_MOUSE_TOUCH_EVENTS",
          "kind": "def",
          "value": "\"SDL_MOUSE_TOUCH_EVENTS\"",
          "sourceName": "SDL_HINT_MOUSE_TOUCH_EVENTS"
        },
        "SDL_HINT_MUTE_CONSOLE_KEYBOARD": {
          "doc": "A variable controlling whether the keyboard should be muted on the console.\n\nNormally the keyboard is muted while SDL applications are running so that\nkeyboard input doesn't show up as key strokes on the console. This hint\nallows you to turn that off for debugging purposes.\n\nThe variable can be set to the following values:\n\n- \"0\": Allow keystrokes to go through to the console.\n- \"1\": Mute keyboard input so it doesn't show up on the console. (default)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_MUTE_CONSOLE_KEYBOARD",
          "kind": "def",
          "value": "\"SDL_MUTE_CONSOLE_KEYBOARD\"",
          "sourceName": "SDL_HINT_MUTE_CONSOLE_KEYBOARD"
        },
        "SDL_HINT_NO_SIGNAL_HANDLERS": {
          "doc": "Tell SDL not to catch the SIGINT or SIGTERM signals on POSIX platforms.\n\nThe variable can be set to the following values:\n\n- \"0\": SDL will install a SIGINT and SIGTERM handler, and when it catches a\n  signal, convert it into an EVENT_QUIT event. (default)\n- \"1\": SDL will not install a signal handler at all.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_NO_SIGNAL_HANDLERS",
          "kind": "def",
          "value": "\"SDL_NO_SIGNAL_HANDLERS\"",
          "sourceName": "SDL_HINT_NO_SIGNAL_HANDLERS"
        },
        "SDL_HINT_OPENGL_LIBRARY": {
          "doc": "Specify the OpenGL library to load.\n\nThis hint should be set before creating an OpenGL window or creating an\nOpenGL context. If this hint isn't set, SDL will choose a reasonable\ndefault.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_OPENGL_LIBRARY",
          "kind": "def",
          "value": "\"SDL_OPENGL_LIBRARY\"",
          "sourceName": "SDL_HINT_OPENGL_LIBRARY"
        },
        "SDL_HINT_EGL_LIBRARY": {
          "doc": "Specify the EGL library to load.\n\nThis hint should be set before creating an OpenGL window or creating an\nOpenGL context. This hint is only considered if SDL is using EGL to manage\nOpenGL contexts. If this hint isn't set, SDL will choose a reasonable\ndefault.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_EGL_LIBRARY",
          "kind": "def",
          "value": "\"SDL_EGL_LIBRARY\"",
          "sourceName": "SDL_HINT_EGL_LIBRARY"
        },
        "SDL_HINT_OPENGL_ES_DRIVER": {
          "doc": "A variable controlling what driver to use for OpenGL ES contexts.\n\nOn some platforms, currently Windows and X11, OpenGL drivers may support\ncreating contexts with an OpenGL ES profile. By default SDL uses these\nprofiles, when available, otherwise it attempts to load an OpenGL ES\nlibrary, e.g. that provided by the ANGLE project. This variable controls\nwhether SDL follows this default behaviour or will always load an OpenGL ES\nlibrary.\n\nCircumstances where this is useful include - Testing an app with a\nparticular OpenGL ES implementation, e.g ANGLE, or emulator, e.g. those\nfrom ARM, Imagination or Qualcomm. - Resolving OpenGL ES function addresses\nat link time by linking with the OpenGL ES library instead of querying them\nat run time with GL_GetProcAddress().\n\nCaution: for an application to work with the default behaviour across\ndifferent OpenGL drivers it must query the OpenGL ES function addresses at\nrun time using GL_GetProcAddress().\n\nThis variable is ignored on most platforms because OpenGL ES is native or\nnot supported.\n\nThe variable can be set to the following values:\n\n- \"0\": Use ES profile of OpenGL, if available. (default)\n- \"1\": Load OpenGL ES library using the default library names.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_OPENGL_ES_DRIVER",
          "kind": "def",
          "value": "\"SDL_OPENGL_ES_DRIVER\"",
          "sourceName": "SDL_HINT_OPENGL_ES_DRIVER"
        },
        "SDL_HINT_OPENVR_LIBRARY": {
          "doc": "Mechanism to specify openvr_api library location\n\nBy default, when using the OpenVR driver, it will search for the API\nlibrary in the current folder. But, if you wish to use a system API you can\nspecify that by using this hint. This should be the full or relative path\nto a .dll on Windows or .so on Linux.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_OPENVR_LIBRARY",
          "kind": "def",
          "value": "\"SDL_OPENVR_LIBRARY\"",
          "sourceName": "SDL_HINT_OPENVR_LIBRARY"
        },
        "SDL_HINT_ORIENTATIONS": {
          "doc": "A variable controlling which orientations are allowed on iOS/Android.\n\nIn some circumstances it is necessary to be able to explicitly control\nwhich UI orientations are allowed.\n\nThis variable is a space delimited list of the following values:\n\n- \"LandscapeLeft\"\n- \"LandscapeRight\"\n- \"Portrait\"\n- \"PortraitUpsideDown\"\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_ORIENTATIONS",
          "kind": "def",
          "value": "\"SDL_ORIENTATIONS\"",
          "sourceName": "SDL_HINT_ORIENTATIONS"
        },
        "SDL_HINT_POLL_SENTINEL": {
          "doc": "A variable controlling the use of a sentinel event when polling the event\nqueue.\n\nWhen polling for events, PumpEvents is used to gather new events from\ndevices. If a device keeps producing new events between calls to\nPumpEvents, a poll loop will become stuck until the new events stop.\nThis is most noticeable when moving a high frequency mouse.\n\nThe variable can be set to the following values:\n\n- \"0\": Disable poll sentinels.\n- \"1\": Enable poll sentinels. (default)\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_POLL_SENTINEL",
          "kind": "def",
          "value": "\"SDL_POLL_SENTINEL\"",
          "sourceName": "SDL_HINT_POLL_SENTINEL"
        },
        "SDL_HINT_PREFERRED_LOCALES": {
          "doc": "Override for GetPreferredLocales().\n\nIf set, this will be favored over anything the OS might report for the\nuser's preferred locales. Changing this hint at runtime will not generate a\nEVENT_LOCALE_CHANGED event (but if you can change the hint, you can\npush your own event, if you want).\n\nThe format of this hint is a comma-separated list of language and locale,\ncombined with an underscore, as is a common format: \"en_GB\". Locale is\noptional: \"en\". So you might have a list like this: \"en_GB,jp,es_PT\"\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_PREFERRED_LOCALES",
          "kind": "def",
          "value": "\"SDL_PREFERRED_LOCALES\"",
          "sourceName": "SDL_HINT_PREFERRED_LOCALES"
        },
        "SDL_HINT_QUIT_ON_LAST_WINDOW_CLOSE": {
          "doc": "A variable that decides whether to send EVENT_QUIT when closing the\nlast window.\n\nThe variable can be set to the following values:\n\n- \"0\": SDL will not send an EVENT_QUIT event when the last window is\n  requesting to close. Note that in this case, there are still other\n  legitimate reasons one might get an EVENT_QUIT event: choosing \"Quit\"\n  from the macOS menu bar, sending a SIGINT (ctrl-c) on Unix, etc.\n- \"1\": SDL will send a quit event when the last window is requesting to\n  close. (default)\n\nIf there is at least one active system tray icon, EVENT_QUIT will\ninstead be sent when both the last window will be closed and the last tray\nicon will be destroyed.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_QUIT_ON_LAST_WINDOW_CLOSE",
          "kind": "def",
          "value": "\"SDL_QUIT_ON_LAST_WINDOW_CLOSE\"",
          "sourceName": "SDL_HINT_QUIT_ON_LAST_WINDOW_CLOSE"
        },
        "SDL_HINT_RENDER_DIRECT3D_THREADSAFE": {
          "doc": "A variable controlling whether the Direct3D device is initialized for\nthread-safe operations.\n\nThe variable can be set to the following values:\n\n- \"0\": Thread-safety is not enabled. (default)\n- \"1\": Thread-safety is enabled.\n\nThis hint should be set before creating a renderer.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_RENDER_DIRECT3D_THREADSAFE",
          "kind": "def",
          "value": "\"SDL_RENDER_DIRECT3D_THREADSAFE\"",
          "sourceName": "SDL_HINT_RENDER_DIRECT3D_THREADSAFE"
        },
        "SDL_HINT_RENDER_DIRECT3D11_DEBUG": {
          "doc": "A variable controlling whether to enable Direct3D 11+'s Debug Layer.\n\nThis variable does not have any effect on the Direct3D 9 based renderer.\n\nThe variable can be set to the following values:\n\n- \"0\": Disable Debug Layer use. (default)\n- \"1\": Enable Debug Layer use.\n\nThis hint should be set before creating a renderer.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_RENDER_DIRECT3D11_DEBUG",
          "kind": "def",
          "value": "\"SDL_RENDER_DIRECT3D11_DEBUG\"",
          "sourceName": "SDL_HINT_RENDER_DIRECT3D11_DEBUG"
        },
        "SDL_HINT_RENDER_VULKAN_DEBUG": {
          "doc": "A variable controlling whether to enable Vulkan Validation Layers.\n\nThis variable can be set to the following values:\n\n- \"0\": Disable Validation Layer use\n- \"1\": Enable Validation Layer use\n\nBy default, SDL does not use Vulkan Validation Layers.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_RENDER_VULKAN_DEBUG",
          "kind": "def",
          "value": "\"SDL_RENDER_VULKAN_DEBUG\"",
          "sourceName": "SDL_HINT_RENDER_VULKAN_DEBUG"
        },
        "SDL_HINT_RENDER_GPU_DEBUG": {
          "doc": "A variable controlling whether to create the GPU device in debug mode.\n\nThis variable can be set to the following values:\n\n- \"0\": Disable debug mode use (default)\n- \"1\": Enable debug mode use\n\nThis hint should be set before creating a renderer.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_RENDER_GPU_DEBUG",
          "kind": "def",
          "value": "\"SDL_RENDER_GPU_DEBUG\"",
          "sourceName": "SDL_HINT_RENDER_GPU_DEBUG"
        },
        "SDL_HINT_RENDER_GPU_LOW_POWER": {
          "doc": "A variable controlling whether to prefer a low-power GPU on multi-GPU\nsystems.\n\nThis variable can be set to the following values:\n\n- \"0\": Prefer high-performance GPU (default)\n- \"1\": Prefer low-power GPU\n\nThis hint should be set before creating a renderer.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_RENDER_GPU_LOW_POWER",
          "kind": "def",
          "value": "\"SDL_RENDER_GPU_LOW_POWER\"",
          "sourceName": "SDL_HINT_RENDER_GPU_LOW_POWER"
        },
        "SDL_HINT_RENDER_DRIVER": {
          "doc": "A variable specifying which render driver to use.\n\nIf the application doesn't pick a specific renderer to use, this variable\nspecifies the name of the preferred renderer. If the preferred renderer\ncan't be initialized, creating a renderer will fail.\n\nThis variable is case insensitive and can be set to the following values:\n\n- \"direct3d\"\n- \"direct3d11\"\n- \"direct3d12\"\n- \"opengl\"\n- \"opengles2\"\n- \"opengles\"\n- \"metal\"\n- \"vulkan\"\n- \"gpu\"\n- \"software\"\n\nThis hint accepts a comma-separated list of driver names, and each will be\ntried in the order listed when creating a renderer until one succeeds or\nall of them fail.\n\nThe default varies by platform, but it's the first one in the list that is\navailable on the current platform.\n\nThis hint should be set before creating a renderer.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_RENDER_DRIVER",
          "kind": "def",
          "value": "\"SDL_RENDER_DRIVER\"",
          "sourceName": "SDL_HINT_RENDER_DRIVER"
        },
        "SDL_HINT_RENDER_LINE_METHOD": {
          "doc": "A variable controlling how the 2D render API renders lines.\n\nThe variable can be set to the following values:\n\n- \"0\": Use the default line drawing method (Bresenham's line algorithm)\n- \"1\": Use the driver point API using Bresenham's line algorithm (correct,\n  draws many points)\n- \"2\": Use the driver line API (occasionally misses line endpoints based on\n  hardware driver quirks\n- \"3\": Use the driver geometry API (correct, draws thicker diagonal lines)\n\nThis hint should be set before creating a renderer.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_RENDER_LINE_METHOD",
          "kind": "def",
          "value": "\"SDL_RENDER_LINE_METHOD\"",
          "sourceName": "SDL_HINT_RENDER_LINE_METHOD"
        },
        "SDL_HINT_RENDER_METAL_PREFER_LOW_POWER_DEVICE": {
          "doc": "A variable controlling whether the Metal render driver select low power\ndevice over default one.\n\nThe variable can be set to the following values:\n\n- \"0\": Use the preferred OS device. (default)\n- \"1\": Select a low power device.\n\nThis hint should be set before creating a renderer.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_RENDER_METAL_PREFER_LOW_POWER_DEVICE",
          "kind": "def",
          "value": "\"SDL_RENDER_METAL_PREFER_LOW_POWER_DEVICE\"",
          "sourceName": "SDL_HINT_RENDER_METAL_PREFER_LOW_POWER_DEVICE"
        },
        "SDL_HINT_RENDER_VSYNC": {
          "doc": "A variable controlling whether updates to the SDL screen surface should be\nsynchronized with the vertical refresh, to avoid tearing.\n\nThis hint overrides the application preference when creating a renderer.\n\nThe variable can be set to the following values:\n\n- \"0\": Disable vsync. (default)\n- \"1\": Enable vsync.\n\nThis hint should be set before creating a renderer.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_RENDER_VSYNC",
          "kind": "def",
          "value": "\"SDL_RENDER_VSYNC\"",
          "sourceName": "SDL_HINT_RENDER_VSYNC"
        },
        "SDL_HINT_RETURN_KEY_HIDES_IME": {
          "doc": "A variable to control whether the return key on the soft keyboard should\nhide the soft keyboard on Android and iOS.\n\nThis hint sets the default value of prop::TextInput.MULTILINE_BOOLEAN.\n\nThe variable can be set to the following values:\n\n- \"0\": The return key will be handled as a key event. (default)\n- \"1\": The return key will hide the keyboard.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_RETURN_KEY_HIDES_IME",
          "kind": "def",
          "value": "\"SDL_RETURN_KEY_HIDES_IME\"",
          "sourceName": "SDL_HINT_RETURN_KEY_HIDES_IME"
        },
        "SDL_HINT_ROG_GAMEPAD_MICE": {
          "doc": "A variable containing a list of ROG gamepad capable mice.\n\nThe format of the string is a comma separated list of USB VID/PID pairs in\nhexadecimal form, e.g.\n\n`0xAAAA/0xBBBB,0xCCCC/0xDDDD`\n\nThe variable can also take the form of \"@file\", in which case the named\nfile will be loaded and interpreted as the value of the variable.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.\n\n@sa SDL_HINT_ROG_GAMEPAD_MICE_EXCLUDED",
          "name": "SDL_HINT_ROG_GAMEPAD_MICE",
          "kind": "def",
          "value": "\"SDL_ROG_GAMEPAD_MICE\"",
          "sourceName": "SDL_HINT_ROG_GAMEPAD_MICE"
        },
        "SDL_HINT_ROG_GAMEPAD_MICE_EXCLUDED": {
          "doc": "A variable containing a list of devices that are not ROG gamepad capable\nmice.\n\nThis will override SDL_HINT_ROG_GAMEPAD_MICE and the built in device list.\n\nThe format of the string is a comma separated list of USB VID/PID pairs in\nhexadecimal form, e.g.\n\n`0xAAAA/0xBBBB,0xCCCC/0xDDDD`\n\nThe variable can also take the form of \"@file\", in which case the named\nfile will be loaded and interpreted as the value of the variable.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_ROG_GAMEPAD_MICE_EXCLUDED",
          "kind": "def",
          "value": "\"SDL_ROG_GAMEPAD_MICE_EXCLUDED\"",
          "sourceName": "SDL_HINT_ROG_GAMEPAD_MICE_EXCLUDED"
        },
        "SDL_HINT_RPI_VIDEO_LAYER": {
          "doc": "A variable controlling which Dispmanx layer to use on a Raspberry PI.\n\nAlso known as Z-order. The variable can take a negative or positive value.\nThe default is 10000.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_RPI_VIDEO_LAYER",
          "kind": "def",
          "value": "\"SDL_RPI_VIDEO_LAYER\"",
          "sourceName": "SDL_HINT_RPI_VIDEO_LAYER"
        },
        "SDL_HINT_SCREENSAVER_INHIBIT_ACTIVITY_NAME": {
          "doc": "Specify an \"activity name\" for screensaver inhibition.\n\nSome platforms, notably Linux desktops, list the applications which are\ninhibiting the screensaver or other power-saving features.\n\nThis hint lets you specify the \"activity name\" sent to the OS when\nDisableScreenSaver() is used (or the screensaver is automatically\ndisabled). The contents of this hint are used when the screensaver is\ndisabled. You should use a string that describes what your program is doing\n(and, therefore, why the screensaver is disabled). For example, \"Playing a\ngame\" or \"Watching a video\".\n\nSetting this to \"\" or leaving it unset will have SDL use a reasonable\ndefault: \"Playing a game\" or something similar.\n\nThis hint should be set before calling DisableScreenSaver()\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_SCREENSAVER_INHIBIT_ACTIVITY_NAME",
          "kind": "def",
          "value": "\"SDL_SCREENSAVER_INHIBIT_ACTIVITY_NAME\"",
          "sourceName": "SDL_HINT_SCREENSAVER_INHIBIT_ACTIVITY_NAME"
        },
        "SDL_HINT_SHUTDOWN_DBUS_ON_QUIT": {
          "doc": "A variable controlling whether SDL calls dbus_shutdown() on quit.\n\nThis is useful as a debug tool to validate memory leaks, but shouldn't ever\nbe set in production applications, as other libraries used by the\napplication might use dbus under the hood and this can cause crashes if\nthey continue after Quit().\n\nThe variable can be set to the following values:\n\n- \"0\": SDL will not call dbus_shutdown() on quit. (default)\n- \"1\": SDL will call dbus_shutdown() on quit.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_SHUTDOWN_DBUS_ON_QUIT",
          "kind": "def",
          "value": "\"SDL_SHUTDOWN_DBUS_ON_QUIT\"",
          "sourceName": "SDL_HINT_SHUTDOWN_DBUS_ON_QUIT"
        },
        "SDL_HINT_STORAGE_TITLE_DRIVER": {
          "doc": "A variable that specifies a backend to use for title storage.\n\nBy default, SDL will try all available storage backends in a reasonable\norder until it finds one that can work, but this hint allows the app or\nuser to force a specific target, such as \"pc\" if, say, you are on Steam but\nwant to avoid SteamRemoteStorage for title data.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_STORAGE_TITLE_DRIVER",
          "kind": "def",
          "value": "\"SDL_STORAGE_TITLE_DRIVER\"",
          "sourceName": "SDL_HINT_STORAGE_TITLE_DRIVER"
        },
        "SDL_HINT_STORAGE_USER_DRIVER": {
          "doc": "A variable that specifies a backend to use for user storage.\n\nBy default, SDL will try all available storage backends in a reasonable\norder until it finds one that can work, but this hint allows the app or\nuser to force a specific target, such as \"pc\" if, say, you are on Steam but\nwant to avoid SteamRemoteStorage for user data.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_STORAGE_USER_DRIVER",
          "kind": "def",
          "value": "\"SDL_STORAGE_USER_DRIVER\"",
          "sourceName": "SDL_HINT_STORAGE_USER_DRIVER"
        },
        "SDL_HINT_THREAD_FORCE_REALTIME_TIME_CRITICAL": {
          "doc": "Specifies whether SDL_THREAD_PRIORITY_TIME_CRITICAL should be treated as\nrealtime.\n\nOn some platforms, like Linux, a realtime priority thread may be subject to\nrestrictions that require special handling by the application. This hint\nexists to let SDL know that the app is prepared to handle said\nrestrictions.\n\nOn Linux, SDL will apply the following configuration to any thread that\nbecomes realtime:\n\n- The SCHED_RESET_ON_FORK bit will be set on the scheduling policy,\n- An RLIMIT_RTTIME budget will be configured to the rtkit specified limit.\n- Exceeding this limit will result in the kernel sending SIGKILL to the\n  app, refer to the man pages for more information.\n\nThe variable can be set to the following values:\n\n- \"0\": default platform specific behaviour\n- \"1\": Force SDL_THREAD_PRIORITY_TIME_CRITICAL to a realtime scheduling\n  policy\n\nThis hint should be set before calling SDL_SetCurrentThreadPriority()\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_THREAD_FORCE_REALTIME_TIME_CRITICAL",
          "kind": "def",
          "value": "\"SDL_THREAD_FORCE_REALTIME_TIME_CRITICAL\"",
          "sourceName": "SDL_HINT_THREAD_FORCE_REALTIME_TIME_CRITICAL"
        },
        "SDL_HINT_THREAD_PRIORITY_POLICY": {
          "doc": "A string specifying additional information to use with\nSDL_SetCurrentThreadPriority.\n\nBy default SDL_SetCurrentThreadPriority will make appropriate system\nchanges in order to apply a thread priority. For example on systems using\npthreads the scheduler policy is changed automatically to a policy that\nworks well with a given priority. Code which has specific requirements can\noverride SDL's default behavior with this hint.\n\npthread hint values are \"current\", \"other\", \"fifo\" and \"rr\". Currently no\nother platform hint values are defined but may be in the future.\n\nOn Linux, the kernel may send SIGKILL to realtime tasks which exceed the\ndistro configured execution budget for rtkit. This budget can be queried\nthrough RLIMIT_RTTIME after calling SDL_SetCurrentThreadPriority().\n\nThis hint should be set before calling SDL_SetCurrentThreadPriority()\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_THREAD_PRIORITY_POLICY",
          "kind": "def",
          "value": "\"SDL_THREAD_PRIORITY_POLICY\"",
          "sourceName": "SDL_HINT_THREAD_PRIORITY_POLICY"
        },
        "SDL_HINT_TIMER_RESOLUTION": {
          "doc": "A variable that controls the timer resolution, in milliseconds.\n\nThe higher resolution the timer, the more frequently the CPU services timer\ninterrupts, and the more precise delays are, but this takes up power and\nCPU time. This hint is only used on Windows.\n\nSee this blog post for more information:\nhttp://randomascii.wordpress.com/2013/07/08/windows-timer-resolution-megawatts-wasted/\n\nThe default value is \"1\".\n\nIf this variable is set to \"0\", the system timer resolution is not set.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_TIMER_RESOLUTION",
          "kind": "def",
          "value": "\"SDL_TIMER_RESOLUTION\"",
          "sourceName": "SDL_HINT_TIMER_RESOLUTION"
        },
        "SDL_HINT_TOUCH_MOUSE_EVENTS": {
          "doc": "A variable controlling whether touch events should generate synthetic mouse\nevents.\n\nThe variable can be set to the following values:\n\n- \"0\": Touch events will not generate mouse events.\n- \"1\": Touch events will generate mouse events. (default)\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_TOUCH_MOUSE_EVENTS",
          "kind": "def",
          "value": "\"SDL_TOUCH_MOUSE_EVENTS\"",
          "sourceName": "SDL_HINT_TOUCH_MOUSE_EVENTS"
        },
        "SDL_HINT_TRACKPAD_IS_TOUCH_ONLY": {
          "doc": "A variable controlling whether trackpads should be treated as touch\ndevices.\n\nOn macOS (and possibly other platforms in the future), SDL will report\ntouches on a trackpad as mouse input, which is generally what users expect\nfrom this device; however, these are often actually full multitouch-capable\ntouch devices, so it might be preferable to some apps to treat them as\nsuch.\n\nThe variable can be set to the following values:\n\n- \"0\": Trackpad will send mouse events. (default)\n- \"1\": Trackpad will send touch events.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_TRACKPAD_IS_TOUCH_ONLY",
          "kind": "def",
          "value": "\"SDL_TRACKPAD_IS_TOUCH_ONLY\"",
          "sourceName": "SDL_HINT_TRACKPAD_IS_TOUCH_ONLY"
        },
        "SDL_HINT_TV_REMOTE_AS_JOYSTICK": {
          "doc": "A variable controlling whether the Android / tvOS remotes should be listed\nas joystick devices, instead of sending keyboard events.\n\nThe variable can be set to the following values:\n\n- \"0\": Remotes send enter/escape/arrow key events.\n- \"1\": Remotes are available as 2 axis, 2 button joysticks. (default)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_TV_REMOTE_AS_JOYSTICK",
          "kind": "def",
          "value": "\"SDL_TV_REMOTE_AS_JOYSTICK\"",
          "sourceName": "SDL_HINT_TV_REMOTE_AS_JOYSTICK"
        },
        "SDL_HINT_VIDEO_ALLOW_SCREENSAVER": {
          "doc": "A variable controlling whether the screensaver is enabled.\n\nThe variable can be set to the following values:\n\n- \"0\": Disable screensaver. (default)\n- \"1\": Enable screensaver.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_ALLOW_SCREENSAVER",
          "kind": "def",
          "value": "\"SDL_VIDEO_ALLOW_SCREENSAVER\"",
          "sourceName": "SDL_HINT_VIDEO_ALLOW_SCREENSAVER"
        },
        "SDL_HINT_VIDEO_DISPLAY_PRIORITY": {
          "doc": "A comma separated list containing the names of the displays that SDL should\nsort to the front of the display list.\n\nWhen this hint is set, displays with matching name strings will be\nprioritized in the list of displays, as exposed by calling\nDisplay.GetAll(), with the first listed becoming the primary display. The\nnaming convention can vary depending on the environment, but it is usually\na connector name (e.g. 'DP-1', 'DP-2', 'HDMI-A-1',etc...).\n\nOn Wayland and X11 desktops, the connector names associated with displays\ncan typically be found by using the `xrandr` utility.\n\nThis hint is currently supported on the following drivers:\n\n- KMSDRM (kmsdrm)\n- Wayland (wayland)\n- X11 (x11)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_DISPLAY_PRIORITY",
          "kind": "def",
          "value": "\"SDL_VIDEO_DISPLAY_PRIORITY\"",
          "sourceName": "SDL_HINT_VIDEO_DISPLAY_PRIORITY"
        },
        "SDL_HINT_VIDEO_DOUBLE_BUFFER": {
          "doc": "Tell the video driver that we only want a double buffer.\n\nBy default, most lowlevel 2D APIs will use a triple buffer scheme that\nwastes no CPU time on waiting for vsync after issuing a flip, but\nintroduces a frame of latency. On the other hand, using a double buffer\nscheme instead is recommended for cases where low latency is an important\nfactor because we save a whole frame of latency.\n\nWe do so by waiting for vsync immediately after issuing a flip, usually\njust after eglSwapBuffers call in the backend's *_SwapWindow function.\n\nThis hint is currently supported on the following drivers:\n\n- Raspberry Pi (raspberrypi)\n- Wayland (wayland)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_DOUBLE_BUFFER",
          "kind": "def",
          "value": "\"SDL_VIDEO_DOUBLE_BUFFER\"",
          "sourceName": "SDL_HINT_VIDEO_DOUBLE_BUFFER"
        },
        "SDL_HINT_VIDEO_DRIVER": {
          "doc": "A variable that specifies a video backend to use.\n\nBy default, SDL will try all available video backends in a reasonable order\nuntil it finds one that can work, but this hint allows the app or user to\nforce a specific target, such as \"x11\" if, say, you are on Wayland but want\nto try talking to the X server instead.\n\nThis hint accepts a comma-separated list of driver names, and each will be\ntried in the order listed during init, until one succeeds or all of them\nfail.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_DRIVER",
          "kind": "def",
          "value": "\"SDL_VIDEO_DRIVER\"",
          "sourceName": "SDL_HINT_VIDEO_DRIVER"
        },
        "SDL_HINT_VIDEO_DUMMY_SAVE_FRAMES": {
          "doc": "A variable controlling whether the dummy video driver saves output frames.\n\n- \"0\": Video frames are not saved to disk. (default)\n- \"1\": Video frames are saved to files in the format \"SDL_windowX-Y.bmp\",\n  where X is the window ID, and Y is the frame number.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_DUMMY_SAVE_FRAMES",
          "kind": "def",
          "value": "\"SDL_VIDEO_DUMMY_SAVE_FRAMES\"",
          "sourceName": "SDL_HINT_VIDEO_DUMMY_SAVE_FRAMES"
        },
        "SDL_HINT_VIDEO_EGL_ALLOW_GETDISPLAY_FALLBACK": {
          "doc": "If eglGetPlatformDisplay fails, fall back to calling eglGetDisplay.\n\nThe variable can be set to one of the following values:\n\n- \"0\": Do not fall back to eglGetDisplay.\n- \"1\": Fall back to eglGetDisplay if eglGetPlatformDisplay fails. (default)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_EGL_ALLOW_GETDISPLAY_FALLBACK",
          "kind": "def",
          "value": "\"SDL_VIDEO_EGL_ALLOW_GETDISPLAY_FALLBACK\"",
          "sourceName": "SDL_HINT_VIDEO_EGL_ALLOW_GETDISPLAY_FALLBACK"
        },
        "SDL_HINT_VIDEO_FORCE_EGL": {
          "doc": "A variable controlling whether the OpenGL context should be created with\nEGL.\n\nThe variable can be set to the following values:\n\n- \"0\": Use platform-specific GL context creation API (GLX, WGL, CGL, etc).\n  (default)\n- \"1\": Use EGL\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_FORCE_EGL",
          "kind": "def",
          "value": "\"SDL_VIDEO_FORCE_EGL\"",
          "sourceName": "SDL_HINT_VIDEO_FORCE_EGL"
        },
        "SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES": {
          "doc": "A variable that specifies the policy for fullscreen Spaces on macOS.\n\nThe variable can be set to the following values:\n\n- \"0\": Disable Spaces support (FULLSCREEN_DESKTOP won't use them and\n  WINDOW_RESIZABLE windows won't offer the \"fullscreen\" button on their\n  titlebars).\n- \"1\": Enable Spaces support (FULLSCREEN_DESKTOP will use them and\n  WINDOW_RESIZABLE windows will offer the \"fullscreen\" button on their\n  titlebars). (default)\n\nThis hint should be set before creating a window.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES",
          "kind": "def",
          "value": "\"SDL_VIDEO_MAC_FULLSCREEN_SPACES\"",
          "sourceName": "SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES"
        },
        "SDL_HINT_VIDEO_MAC_FULLSCREEN_MENU_VISIBILITY": {
          "doc": "A variable that specifies the menu visibility when a window is fullscreen\nin Spaces on macOS.\n\nThe variable can be set to the following values:\n\n- \"0\": The menu will be hidden when the window is in a fullscreen space,\n  and not accessible by moving the mouse to the top of the screen.\n- \"1\": The menu will be accessible when the window is in a fullscreen\n  space.\n- \"auto\": The menu will be hidden if fullscreen mode was toggled on\n  programmatically via `WindowBase.SetFullscreen()`, and accessible if\n  fullscreen was entered via the \"fullscreen\" button on the window title\n  bar. (default)\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_MAC_FULLSCREEN_MENU_VISIBILITY",
          "kind": "def",
          "value": "\"SDL_VIDEO_MAC_FULLSCREEN_MENU_VISIBILITY\"",
          "sourceName": "SDL_HINT_VIDEO_MAC_FULLSCREEN_MENU_VISIBILITY"
        },
        "SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS": {
          "doc": "A variable controlling whether fullscreen windows are minimized when they\nlose focus.\n\nThe variable can be set to the following values:\n\n- \"0\": Fullscreen windows will not be minimized when they lose focus.\n  (default)\n- \"1\": Fullscreen windows are minimized when they lose focus.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS",
          "kind": "def",
          "value": "\"SDL_VIDEO_MINIMIZE_ON_FOCUS_LOSS\"",
          "sourceName": "SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS"
        },
        "SDL_HINT_VIDEO_OFFSCREEN_SAVE_FRAMES": {
          "doc": "A variable controlling whether the offscreen video driver saves output\nframes.\n\nThis only saves frames that are generated using software rendering, not\naccelerated OpenGL rendering.\n\n- \"0\": Video frames are not saved to disk. (default)\n- \"1\": Video frames are saved to files in the format \"SDL_windowX-Y.bmp\",\n  where X is the window ID, and Y is the frame number.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_OFFSCREEN_SAVE_FRAMES",
          "kind": "def",
          "value": "\"SDL_VIDEO_OFFSCREEN_SAVE_FRAMES\"",
          "sourceName": "SDL_HINT_VIDEO_OFFSCREEN_SAVE_FRAMES"
        },
        "SDL_HINT_VIDEO_SYNC_WINDOW_OPERATIONS": {
          "doc": "A variable controlling whether all window operations will block until\ncomplete.\n\nWindow systems that run asynchronously may not have the results of window\noperations that resize or move the window applied immediately upon the\nreturn of the requesting function. Setting this hint will cause such\noperations to block after every call until the pending operation has\ncompleted. Setting this to '1' is the equivalent of calling\nWindowBase.Sync() after every function call.\n\nBe aware that amount of time spent blocking while waiting for window\noperations to complete can be quite lengthy, as animations may have to\ncomplete, which can take upwards of multiple seconds in some cases.\n\nThe variable can be set to the following values:\n\n- \"0\": Window operations are non-blocking. (default)\n- \"1\": Window operations will block until completed.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_SYNC_WINDOW_OPERATIONS",
          "kind": "def",
          "value": "\"SDL_VIDEO_SYNC_WINDOW_OPERATIONS\"",
          "sourceName": "SDL_HINT_VIDEO_SYNC_WINDOW_OPERATIONS"
        },
        "SDL_HINT_VIDEO_WAYLAND_ALLOW_LIBDECOR": {
          "doc": "A variable controlling whether the libdecor Wayland backend is allowed to\nbe used.\n\nlibdecor is used over xdg-shell when xdg-decoration protocol is\nunavailable.\n\nThe variable can be set to the following values:\n\n- \"0\": libdecor use is disabled.\n- \"1\": libdecor use is enabled. (default)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_WAYLAND_ALLOW_LIBDECOR",
          "kind": "def",
          "value": "\"SDL_VIDEO_WAYLAND_ALLOW_LIBDECOR\"",
          "sourceName": "SDL_HINT_VIDEO_WAYLAND_ALLOW_LIBDECOR"
        },
        "SDL_HINT_VIDEO_WAYLAND_MODE_EMULATION": {
          "doc": "A variable controlling whether video mode emulation is enabled under\nWayland.\n\nWhen this hint is set, a standard set of emulated CVT video modes will be\nexposed for use by the application. If it is disabled, the only modes\nexposed will be the logical desktop size and, in the case of a scaled\ndesktop, the native display resolution.\n\nThe variable can be set to the following values:\n\n- \"0\": Video mode emulation is disabled.\n- \"1\": Video mode emulation is enabled. (default)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_WAYLAND_MODE_EMULATION",
          "kind": "def",
          "value": "\"SDL_VIDEO_WAYLAND_MODE_EMULATION\"",
          "sourceName": "SDL_HINT_VIDEO_WAYLAND_MODE_EMULATION"
        },
        "SDL_HINT_VIDEO_WAYLAND_MODE_SCALING": {
          "doc": "A variable controlling how modes with a non-native aspect ratio are\ndisplayed under Wayland.\n\nWhen this hint is set, the requested scaling will be used when displaying\nfullscreen video modes that don't match the display's native aspect ratio.\nThis is contingent on compositor viewport support.\n\nThe variable can be set to the following values:\n\n- \"aspect\" - Video modes will be displayed scaled, in their proper aspect\n  ratio, with black bars.\n- \"stretch\" - Video modes will be scaled to fill the entire display.\n  (default)\n- \"none\" - Video modes will be displayed as 1:1 with no scaling.\n\nThis hint should be set before creating a window.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_WAYLAND_MODE_SCALING",
          "kind": "def",
          "value": "\"SDL_VIDEO_WAYLAND_MODE_SCALING\"",
          "sourceName": "SDL_HINT_VIDEO_WAYLAND_MODE_SCALING"
        },
        "SDL_HINT_VIDEO_WAYLAND_PREFER_LIBDECOR": {
          "doc": "A variable controlling whether the libdecor Wayland backend is preferred\nover native decorations.\n\nWhen this hint is set, libdecor will be used to provide window decorations,\neven if xdg-decoration is available. (Note that, by default, libdecor will\nuse xdg-decoration itself if available).\n\nThe variable can be set to the following values:\n\n- \"0\": libdecor is enabled only if server-side decorations are unavailable.\n  (default)\n- \"1\": libdecor is always enabled if available.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_WAYLAND_PREFER_LIBDECOR",
          "kind": "def",
          "value": "\"SDL_VIDEO_WAYLAND_PREFER_LIBDECOR\"",
          "sourceName": "SDL_HINT_VIDEO_WAYLAND_PREFER_LIBDECOR"
        },
        "SDL_HINT_VIDEO_WAYLAND_SCALE_TO_DISPLAY": {
          "doc": "A variable forcing non-DPI-aware Wayland windows to output at 1:1 scaling.\n\nThis must be set before initializing the video subsystem.\n\nWhen this hint is set, Wayland windows that are not flagged as being\nDPI-aware will be output with scaling designed to force 1:1 pixel mapping.\n\nThis is intended to allow legacy applications to be displayed without\ndesktop scaling being applied, and has issues with certain display\nconfigurations, as this forces the window to behave in a way that Wayland\ndesktops were not designed to accommodate:\n\n- Rounding errors can result with odd window sizes and/or desktop scales,\n  which can cause the window contents to appear slightly blurry.\n- Positioning the window may be imprecise due to unit conversions and\n  rounding.\n- The window may be unusably small on scaled desktops.\n- The window may jump in size when moving between displays of different\n  scale factors.\n- Displays may appear to overlap when using a multi-monitor setup with\n  scaling enabled.\n- Possible loss of cursor precision due to the logical size of the window\n  being reduced.\n\nNew applications should be designed with proper DPI awareness handling\ninstead of enabling this.\n\nThe variable can be set to the following values:\n\n- \"0\": Windows will be scaled normally.\n- \"1\": Windows will be forced to scale to achieve 1:1 output.\n\nThis hint should be set before creating a window.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_WAYLAND_SCALE_TO_DISPLAY",
          "kind": "def",
          "value": "\"SDL_VIDEO_WAYLAND_SCALE_TO_DISPLAY\"",
          "sourceName": "SDL_HINT_VIDEO_WAYLAND_SCALE_TO_DISPLAY"
        },
        "SDL_HINT_VIDEO_WIN_D3DCOMPILER": {
          "doc": "A variable specifying which shader compiler to preload when using the\nChrome ANGLE binaries.\n\nSDL has EGL and OpenGL ES2 support on Windows via the ANGLE project. It can\nuse two different sets of binaries, those compiled by the user from source\nor those provided by the Chrome browser. In the later case, these binaries\nrequire that SDL loads a DLL providing the shader compiler.\n\nThe variable can be set to the following values:\n\n- \"d3dcompiler_46.dll\" - best for Vista or later. (default)\n- \"d3dcompiler_43.dll\" - for XP support.\n- \"none\" - do not load any library, useful if you compiled ANGLE from\n  source and included the compiler in your binaries.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_WIN_D3DCOMPILER",
          "kind": "def",
          "value": "\"SDL_VIDEO_WIN_D3DCOMPILER\"",
          "sourceName": "SDL_HINT_VIDEO_WIN_D3DCOMPILER"
        },
        "SDL_HINT_VIDEO_X11_EXTERNAL_WINDOW_INPUT": {
          "doc": "A variable controlling whether SDL should call XSelectInput() to enable\ninput events on X11 windows wrapped by SDL windows.\n\nThe variable can be set to the following values:\n\n- \"0\": Don't call XSelectInput(), assuming the native window code has done\n  it already.\n- \"1\": Call XSelectInput() to enable input events. (default)\n\nThis hint should be set before creating a window.\n\n@since This hint is available since SDL 3.2.10.",
          "name": "SDL_HINT_VIDEO_X11_EXTERNAL_WINDOW_INPUT",
          "kind": "def",
          "value": "\"SDL_VIDEO_X11_EXTERNAL_WINDOW_INPUT\"",
          "sourceName": "SDL_HINT_VIDEO_X11_EXTERNAL_WINDOW_INPUT"
        },
        "SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR": {
          "doc": "A variable controlling whether the X11 _NET_WM_BYPASS_COMPOSITOR hint\nshould be used.\n\nThe variable can be set to the following values:\n\n- \"0\": Disable _NET_WM_BYPASS_COMPOSITOR.\n- \"1\": Enable _NET_WM_BYPASS_COMPOSITOR. (default)\n\nThis hint should be set before creating a window.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR",
          "kind": "def",
          "value": "\"SDL_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR\"",
          "sourceName": "SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR"
        },
        "SDL_HINT_VIDEO_X11_NET_WM_PING": {
          "doc": "A variable controlling whether the X11 _NET_WM_PING protocol should be\nsupported.\n\nBy default SDL will use _NET_WM_PING, but for applications that know they\nwill not always be able to respond to ping requests in a timely manner they\ncan turn it off to avoid the window manager thinking the app is hung.\n\nThe variable can be set to the following values:\n\n- \"0\": Disable _NET_WM_PING.\n- \"1\": Enable _NET_WM_PING. (default)\n\nThis hint should be set before creating a window.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_X11_NET_WM_PING",
          "kind": "def",
          "value": "\"SDL_VIDEO_X11_NET_WM_PING\"",
          "sourceName": "SDL_HINT_VIDEO_X11_NET_WM_PING"
        },
        "SDL_HINT_VIDEO_X11_NODIRECTCOLOR": {
          "doc": "A variable controlling whether SDL uses DirectColor visuals.\n\nThe variable can be set to the following values:\n\n- \"0\": Disable DirectColor visuals.\n- \"1\": Enable DirectColor visuals. (default)\n\nThis hint should be set before initializing the video subsystem.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_X11_NODIRECTCOLOR",
          "kind": "def",
          "value": "\"SDL_VIDEO_X11_NODIRECTCOLOR\"",
          "sourceName": "SDL_HINT_VIDEO_X11_NODIRECTCOLOR"
        },
        "SDL_HINT_VIDEO_X11_SCALING_FACTOR": {
          "doc": "A variable forcing the content scaling factor for X11 displays.\n\nThe variable can be set to a floating point value in the range 1.0-10.0f\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_X11_SCALING_FACTOR",
          "kind": "def",
          "value": "\"SDL_VIDEO_X11_SCALING_FACTOR\"",
          "sourceName": "SDL_HINT_VIDEO_X11_SCALING_FACTOR"
        },
        "SDL_HINT_VIDEO_X11_VISUALID": {
          "doc": "A variable forcing the visual ID used for X11 display modes.\n\nThis hint should be set before initializing the video subsystem.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_X11_VISUALID",
          "kind": "def",
          "value": "\"SDL_VIDEO_X11_VISUALID\"",
          "sourceName": "SDL_HINT_VIDEO_X11_VISUALID"
        },
        "SDL_HINT_VIDEO_X11_WINDOW_VISUALID": {
          "doc": "A variable forcing the visual ID chosen for new X11 windows.\n\nThis hint should be set before creating a window.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_X11_WINDOW_VISUALID",
          "kind": "def",
          "value": "\"SDL_VIDEO_X11_WINDOW_VISUALID\"",
          "sourceName": "SDL_HINT_VIDEO_X11_WINDOW_VISUALID"
        },
        "SDL_HINT_VIDEO_X11_XRANDR": {
          "doc": "A variable controlling whether the X11 XRandR extension should be used.\n\nThe variable can be set to the following values:\n\n- \"0\": Disable XRandR.\n- \"1\": Enable XRandR. (default)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VIDEO_X11_XRANDR",
          "kind": "def",
          "value": "\"SDL_VIDEO_X11_XRANDR\"",
          "sourceName": "SDL_HINT_VIDEO_X11_XRANDR"
        },
        "SDL_HINT_VITA_ENABLE_BACK_TOUCH": {
          "doc": "A variable controlling whether touch should be enabled on the back panel of\nthe PlayStation Vita.\n\nThe variable can be set to the following values:\n\n- \"0\": Disable touch on the back panel.\n- \"1\": Enable touch on the back panel. (default)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VITA_ENABLE_BACK_TOUCH",
          "kind": "def",
          "value": "\"SDL_VITA_ENABLE_BACK_TOUCH\"",
          "sourceName": "SDL_HINT_VITA_ENABLE_BACK_TOUCH"
        },
        "SDL_HINT_VITA_ENABLE_FRONT_TOUCH": {
          "doc": "A variable controlling whether touch should be enabled on the front panel\nof the PlayStation Vita.\n\nThe variable can be set to the following values:\n\n- \"0\": Disable touch on the front panel.\n- \"1\": Enable touch on the front panel. (default)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VITA_ENABLE_FRONT_TOUCH",
          "kind": "def",
          "value": "\"SDL_VITA_ENABLE_FRONT_TOUCH\"",
          "sourceName": "SDL_HINT_VITA_ENABLE_FRONT_TOUCH"
        },
        "SDL_HINT_VITA_MODULE_PATH": {
          "doc": "A variable controlling the module path on the PlayStation Vita.\n\nThis hint defaults to \"app0:module\"\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VITA_MODULE_PATH",
          "kind": "def",
          "value": "\"SDL_VITA_MODULE_PATH\"",
          "sourceName": "SDL_HINT_VITA_MODULE_PATH"
        },
        "SDL_HINT_VITA_PVR_INIT": {
          "doc": "A variable controlling whether to perform PVR initialization on the\nPlayStation Vita.\n\n- \"0\": Skip PVR initialization.\n- \"1\": Perform the normal PVR initialization. (default)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VITA_PVR_INIT",
          "kind": "def",
          "value": "\"SDL_VITA_PVR_INIT\"",
          "sourceName": "SDL_HINT_VITA_PVR_INIT"
        },
        "SDL_HINT_VITA_RESOLUTION": {
          "doc": "A variable overriding the resolution reported on the PlayStation Vita.\n\nThe variable can be set to the following values:\n\n- \"544\": 544p (default)\n- \"720\": 725p for PSTV\n- \"1080\": 1088i for PSTV\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VITA_RESOLUTION",
          "kind": "def",
          "value": "\"SDL_VITA_RESOLUTION\"",
          "sourceName": "SDL_HINT_VITA_RESOLUTION"
        },
        "SDL_HINT_VITA_PVR_OPENGL": {
          "doc": "A variable controlling whether OpenGL should be used instead of OpenGL ES\non the PlayStation Vita.\n\nThe variable can be set to the following values:\n\n- \"0\": Use OpenGL ES. (default)\n- \"1\": Use OpenGL.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VITA_PVR_OPENGL",
          "kind": "def",
          "value": "\"SDL_VITA_PVR_OPENGL\"",
          "sourceName": "SDL_HINT_VITA_PVR_OPENGL"
        },
        "SDL_HINT_VITA_TOUCH_MOUSE_DEVICE": {
          "doc": "A variable controlling which touchpad should generate synthetic mouse\nevents.\n\nThe variable can be set to the following values:\n\n- \"0\": Only front touchpad should generate mouse events. (default)\n- \"1\": Only back touchpad should generate mouse events.\n- \"2\": Both touchpads should generate mouse events.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VITA_TOUCH_MOUSE_DEVICE",
          "kind": "def",
          "value": "\"SDL_VITA_TOUCH_MOUSE_DEVICE\"",
          "sourceName": "SDL_HINT_VITA_TOUCH_MOUSE_DEVICE"
        },
        "SDL_HINT_VULKAN_DISPLAY": {
          "doc": "A variable overriding the display index used in SDL_Vulkan_CreateSurface()\n\nThe display index starts at 0, which is the default.\n\nThis hint should be set before calling SDL_Vulkan_CreateSurface()\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VULKAN_DISPLAY",
          "kind": "def",
          "value": "\"SDL_VULKAN_DISPLAY\"",
          "sourceName": "SDL_HINT_VULKAN_DISPLAY"
        },
        "SDL_HINT_VULKAN_LIBRARY": {
          "doc": "Specify the Vulkan library to load.\n\nThis hint should be set before creating a Vulkan window or calling\nSDL_Vulkan_LoadLibrary().\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_VULKAN_LIBRARY",
          "kind": "def",
          "value": "\"SDL_VULKAN_LIBRARY\"",
          "sourceName": "SDL_HINT_VULKAN_LIBRARY"
        },
        "SDL_HINT_WAVE_FACT_CHUNK": {
          "doc": "A variable controlling how the fact chunk affects the loading of a WAVE\nfile.\n\nThe fact chunk stores information about the number of samples of a WAVE\nfile. The Standards Update from Microsoft notes that this value can be used\nto 'determine the length of the data in seconds'. This is especially useful\nfor compressed formats (for which this is a mandatory chunk) if they\nproduce multiple sample frames per block and truncating the block is not\nallowed. The fact chunk can exactly specify how many sample frames there\nshould be in this case.\n\nUnfortunately, most application seem to ignore the fact chunk and so SDL\nignores it by default as well.\n\nThe variable can be set to the following values:\n\n- \"truncate\" - Use the number of samples to truncate the wave data if the\n  fact chunk is present and valid.\n- \"strict\" - Like \"truncate\", but raise an error if the fact chunk is\n  invalid, not present for non-PCM formats, or if the data chunk doesn't\n  have that many samples.\n- \"ignorezero\" - Like \"truncate\", but ignore fact chunk if the number of\n  samples is zero.\n- \"ignore\" - Ignore fact chunk entirely. (default)\n\nThis hint should be set before calling SDL_LoadWAV() or SDL_LoadWAV_IO()\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_WAVE_FACT_CHUNK",
          "kind": "def",
          "value": "\"SDL_WAVE_FACT_CHUNK\"",
          "sourceName": "SDL_HINT_WAVE_FACT_CHUNK"
        },
        "SDL_HINT_WAVE_CHUNK_LIMIT": {
          "doc": "A variable controlling the maximum number of chunks in a WAVE file.\n\nThis sets an upper bound on the number of chunks in a WAVE file to avoid\nwasting time on malformed or corrupt WAVE files. This defaults to \"10000\".\n\nThis hint should be set before calling SDL_LoadWAV() or SDL_LoadWAV_IO()\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_WAVE_CHUNK_LIMIT",
          "kind": "def",
          "value": "\"SDL_WAVE_CHUNK_LIMIT\"",
          "sourceName": "SDL_HINT_WAVE_CHUNK_LIMIT"
        },
        "SDL_HINT_WAVE_RIFF_CHUNK_SIZE": {
          "doc": "A variable controlling how the size of the RIFF chunk affects the loading\nof a WAVE file.\n\nThe size of the RIFF chunk (which includes all the sub-chunks of the WAVE\nfile) is not always reliable. In case the size is wrong, it's possible to\njust ignore it and step through the chunks until a fixed limit is reached.\n\nNote that files that have trailing data unrelated to the WAVE file or\ncorrupt files may slow down the loading process without a reliable\nboundary. By default, SDL stops after 10000 chunks to prevent wasting time.\nUse SDL_HINT_WAVE_CHUNK_LIMIT to adjust this value.\n\nThe variable can be set to the following values:\n\n- \"force\" - Always use the RIFF chunk size as a boundary for the chunk\n  search.\n- \"ignorezero\" - Like \"force\", but a zero size searches up to 4 GiB.\n  (default)\n- \"ignore\" - Ignore the RIFF chunk size and always search up to 4 GiB.\n- \"maximum\" - Search for chunks until the end of file. (not recommended)\n\nThis hint should be set before calling SDL_LoadWAV() or SDL_LoadWAV_IO()\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_WAVE_RIFF_CHUNK_SIZE",
          "kind": "def",
          "value": "\"SDL_WAVE_RIFF_CHUNK_SIZE\"",
          "sourceName": "SDL_HINT_WAVE_RIFF_CHUNK_SIZE"
        },
        "SDL_HINT_WAVE_TRUNCATION": {
          "doc": "A variable controlling how a truncated WAVE file is handled.\n\nA WAVE file is considered truncated if any of the chunks are incomplete or\nthe data chunk size is not a multiple of the block size. By default, SDL\ndecodes until the first incomplete block, as most applications seem to do.\n\nThe variable can be set to the following values:\n\n- \"verystrict\" - Raise an error if the file is truncated.\n- \"strict\" - Like \"verystrict\", but the size of the RIFF chunk is ignored.\n- \"dropframe\" - Decode until the first incomplete sample frame.\n- \"dropblock\" - Decode until the first incomplete block. (default)\n\nThis hint should be set before calling SDL_LoadWAV() or SDL_LoadWAV_IO()\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_WAVE_TRUNCATION",
          "kind": "def",
          "value": "\"SDL_WAVE_TRUNCATION\"",
          "sourceName": "SDL_HINT_WAVE_TRUNCATION"
        },
        "SDL_HINT_WINDOW_ACTIVATE_WHEN_RAISED": {
          "doc": "A variable controlling whether the window is activated when the\nWindowBase.Raise function is called.\n\nThe variable can be set to the following values:\n\n- \"0\": The window is not activated when the WindowBase.Raise function is\n  called.\n- \"1\": The window is activated when the WindowBase.Raise function is called.\n  (default)\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_WINDOW_ACTIVATE_WHEN_RAISED",
          "kind": "def",
          "value": "\"SDL_WINDOW_ACTIVATE_WHEN_RAISED\"",
          "sourceName": "SDL_HINT_WINDOW_ACTIVATE_WHEN_RAISED"
        },
        "SDL_HINT_WINDOW_ACTIVATE_WHEN_SHOWN": {
          "doc": "A variable controlling whether the window is activated when the\nWindowBase.Show function is called.\n\nThe variable can be set to the following values:\n\n- \"0\": The window is not activated when the WindowBase.Show function is\n  called.\n- \"1\": The window is activated when the WindowBase.Show function is called.\n  (default)\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_WINDOW_ACTIVATE_WHEN_SHOWN",
          "kind": "def",
          "value": "\"SDL_WINDOW_ACTIVATE_WHEN_SHOWN\"",
          "sourceName": "SDL_HINT_WINDOW_ACTIVATE_WHEN_SHOWN"
        },
        "SDL_HINT_WINDOW_ALLOW_TOPMOST": {
          "doc": "If set to \"0\" then never set the top-most flag on an SDL Window even if the\napplication requests it.\n\nThis is a debugging aid for developers and not expected to be used by end\nusers.\n\nThe variable can be set to the following values:\n\n- \"0\": don't allow topmost\n- \"1\": allow topmost (default)\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_WINDOW_ALLOW_TOPMOST",
          "kind": "def",
          "value": "\"SDL_WINDOW_ALLOW_TOPMOST\"",
          "sourceName": "SDL_HINT_WINDOW_ALLOW_TOPMOST"
        },
        "SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN": {
          "doc": "A variable controlling whether the window frame and title bar are\ninteractive when the cursor is hidden.\n\nThe variable can be set to the following values:\n\n- \"0\": The window frame is not interactive when the cursor is hidden (no\n  move, resize, etc).\n- \"1\": The window frame is interactive when the cursor is hidden. (default)\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN",
          "kind": "def",
          "value": "\"SDL_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN\"",
          "sourceName": "SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN"
        },
        "SDL_HINT_WINDOWS_CLOSE_ON_ALT_F4": {
          "doc": "A variable controlling whether SDL generates window-close events for Alt+F4\non Windows.\n\nThe variable can be set to the following values:\n\n- \"0\": SDL will only do normal key handling for Alt+F4.\n- \"1\": SDL will generate a window-close event when it sees Alt+F4.\n  (default)\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_WINDOWS_CLOSE_ON_ALT_F4",
          "kind": "def",
          "value": "\"SDL_WINDOWS_CLOSE_ON_ALT_F4\"",
          "sourceName": "SDL_HINT_WINDOWS_CLOSE_ON_ALT_F4"
        },
        "SDL_HINT_WINDOWS_ENABLE_MENU_MNEMONICS": {
          "doc": "A variable controlling whether menus can be opened with their keyboard\nshortcut (Alt+mnemonic).\n\nIf the mnemonics are enabled, then menus can be opened by pressing the Alt\nkey and the corresponding mnemonic (for example, Alt+F opens the File\nmenu). However, in case an invalid mnemonic is pressed, Windows makes an\naudible beep to convey that nothing happened. This is true even if the\nwindow has no menu at all!\n\nBecause most SDL applications don't have menus, and some want to use the\nAlt key for other purposes, SDL disables mnemonics (and the beeping) by\ndefault.\n\nNote: This also affects keyboard events: with mnemonics enabled, when a\nmenu is opened from the keyboard, you will not receive a KEYUP event for\nthe mnemonic key, and *might* not receive one for Alt.\n\nThe variable can be set to the following values:\n\n- \"0\": Alt+mnemonic does nothing, no beeping. (default)\n- \"1\": Alt+mnemonic opens menus, invalid mnemonics produce a beep.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_WINDOWS_ENABLE_MENU_MNEMONICS",
          "kind": "def",
          "value": "\"SDL_WINDOWS_ENABLE_MENU_MNEMONICS\"",
          "sourceName": "SDL_HINT_WINDOWS_ENABLE_MENU_MNEMONICS"
        },
        "SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP": {
          "doc": "A variable controlling whether the windows message loop is processed by\nSDL.\n\nThe variable can be set to the following values:\n\n- \"0\": The window message loop is not run.\n- \"1\": The window message loop is processed in PumpEvents(). (default)\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP",
          "kind": "def",
          "value": "\"SDL_WINDOWS_ENABLE_MESSAGELOOP\"",
          "sourceName": "SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP"
        },
        "SDL_HINT_WINDOWS_GAMEINPUT": {
          "doc": "A variable controlling whether GameInput is used for raw keyboard and mouse\non Windows.\n\nThe variable can be set to the following values:\n\n- \"0\": GameInput is not used for raw keyboard and mouse events.\n- \"1\": GameInput is used for raw keyboard and mouse events, if available.\n  (default)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_WINDOWS_GAMEINPUT",
          "kind": "def",
          "value": "\"SDL_WINDOWS_GAMEINPUT\"",
          "sourceName": "SDL_HINT_WINDOWS_GAMEINPUT"
        },
        "SDL_HINT_WINDOWS_RAW_KEYBOARD": {
          "doc": "A variable controlling whether raw keyboard events are used on Windows.\n\nThe variable can be set to the following values:\n\n- \"0\": The Windows message loop is used for keyboard events. (default)\n- \"1\": Low latency raw keyboard events are used.\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_WINDOWS_RAW_KEYBOARD",
          "kind": "def",
          "value": "\"SDL_WINDOWS_RAW_KEYBOARD\"",
          "sourceName": "SDL_HINT_WINDOWS_RAW_KEYBOARD"
        },
        "SDL_HINT_WINDOWS_FORCE_SEMAPHORE_KERNEL": {
          "doc": "A variable controlling whether SDL uses Kernel Semaphores on Windows.\n\nKernel Semaphores are inter-process and require a context switch on every\ninteraction. On Windows 8 and newer, the WaitOnAddress API is available.\nUsing that and atomics to implement semaphores increases performance. SDL\nwill fall back to Kernel Objects on older OS versions or if forced to by\nthis hint.\n\nThe variable can be set to the following values:\n\n- \"0\": Use Atomics and WaitOnAddress API when available, otherwise fall\n  back to Kernel Objects. (default)\n- \"1\": Force the use of Kernel Objects in all cases.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_WINDOWS_FORCE_SEMAPHORE_KERNEL",
          "kind": "def",
          "value": "\"SDL_WINDOWS_FORCE_SEMAPHORE_KERNEL\"",
          "sourceName": "SDL_HINT_WINDOWS_FORCE_SEMAPHORE_KERNEL"
        },
        "SDL_HINT_WINDOWS_INTRESOURCE_ICON": {
          "doc": "A variable to specify custom icon resource id from RC file on Windows\nplatform.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_WINDOWS_INTRESOURCE_ICON",
          "kind": "def",
          "value": "\"SDL_WINDOWS_INTRESOURCE_ICON\"",
          "sourceName": "SDL_HINT_WINDOWS_INTRESOURCE_ICON"
        },
        "SDL_HINT_WINDOWS_INTRESOURCE_ICON_SMALL": {
          "doc": "A variable to specify custom icon resource id from RC file on Windows\nplatform.\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_WINDOWS_INTRESOURCE_ICON_SMALL",
          "kind": "def",
          "value": "\"SDL_WINDOWS_INTRESOURCE_ICON_SMALL\"",
          "sourceName": "SDL_HINT_WINDOWS_INTRESOURCE_ICON_SMALL"
        },
        "SDL_HINT_WINDOWS_USE_D3D9EX": {
          "doc": "A variable controlling whether SDL uses the D3D9Ex API introduced in\nWindows Vista, instead of normal D3D9.\n\nDirect3D 9Ex contains changes to state management that can eliminate device\nloss errors during scenarios like Alt+Tab or UAC prompts. D3D9Ex may\nrequire some changes to your application to cope with the new behavior, so\nthis is disabled by default.\n\nFor more information on Direct3D 9Ex, see:\n\n- https://docs.microsoft.com/en-us/windows/win32/direct3darticles/graphics-apis-in-windows-vista#direct3d-9ex\n- https://docs.microsoft.com/en-us/windows/win32/direct3darticles/direct3d-9ex-improvements\n\nThe variable can be set to the following values:\n\n- \"0\": Use the original Direct3D 9 API. (default)\n- \"1\": Use the Direct3D 9Ex API on Vista and later (and fall back if D3D9Ex\n  is unavailable)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_WINDOWS_USE_D3D9EX",
          "kind": "def",
          "value": "\"SDL_WINDOWS_USE_D3D9EX\"",
          "sourceName": "SDL_HINT_WINDOWS_USE_D3D9EX"
        },
        "SDL_HINT_WINDOWS_ERASE_BACKGROUND_MODE": {
          "doc": "A variable controlling whether SDL will clear the window contents when the\nWM_ERASEBKGND message is received.\n\nThe variable can be set to the following values:\n\n- \"0\"/\"never\": Never clear the window.\n- \"1\"/\"initial\": Clear the window when the first WM_ERASEBKGND event fires.\n  (default)\n- \"2\"/\"always\": Clear the window on every WM_ERASEBKGND event.\n\nThis hint should be set before creating a window.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_WINDOWS_ERASE_BACKGROUND_MODE",
          "kind": "def",
          "value": "\"SDL_WINDOWS_ERASE_BACKGROUND_MODE\"",
          "sourceName": "SDL_HINT_WINDOWS_ERASE_BACKGROUND_MODE"
        },
        "SDL_HINT_X11_FORCE_OVERRIDE_REDIRECT": {
          "doc": "A variable controlling whether X11 windows are marked as override-redirect.\n\nIf set, this _might_ increase framerate at the expense of the desktop not\nworking as expected. Override-redirect windows aren't noticed by the window\nmanager at all.\n\nYou should probably only use this for fullscreen windows, and you probably\nshouldn't even use it for that. But it's here if you want to try!\n\nThe variable can be set to the following values:\n\n- \"0\": Do not mark the window as override-redirect. (default)\n- \"1\": Mark the window as override-redirect.\n\nThis hint should be set before creating a window.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_X11_FORCE_OVERRIDE_REDIRECT",
          "kind": "def",
          "value": "\"SDL_X11_FORCE_OVERRIDE_REDIRECT\"",
          "sourceName": "SDL_HINT_X11_FORCE_OVERRIDE_REDIRECT"
        },
        "SDL_HINT_X11_WINDOW_TYPE": {
          "doc": "A variable specifying the type of an X11 window.\n\nDuring WindowBase.WindowBase, SDL uses the _NET_WM_WINDOW_TYPE X11 property to\nreport to the window manager the type of window it wants to create. This\nmight be set to various things if WINDOW_TOOLTIP or\nWINDOW_POPUP_MENU, etc, were specified. For \"normal\" windows that\nhaven't set a specific type, this hint can be used to specify a custom\ntype. For example, a dock window might set this to\n\"_NET_WM_WINDOW_TYPE_DOCK\".\n\nThis hint should be set before creating a window.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_X11_WINDOW_TYPE",
          "kind": "def",
          "value": "\"SDL_X11_WINDOW_TYPE\"",
          "sourceName": "SDL_HINT_X11_WINDOW_TYPE"
        },
        "SDL_HINT_X11_XCB_LIBRARY": {
          "doc": "Specify the XCB library to load for the X11 driver.\n\nThe default is platform-specific, often \"libX11-xcb.so.1\".\n\nThis hint should be set before initializing the video subsystem.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_X11_XCB_LIBRARY",
          "kind": "def",
          "value": "\"SDL_X11_XCB_LIBRARY\"",
          "sourceName": "SDL_HINT_X11_XCB_LIBRARY"
        },
        "SDL_HINT_XINPUT_ENABLED": {
          "doc": "A variable controlling whether XInput should be used for controller\nhandling.\n\nThe variable can be set to the following values:\n\n- \"0\": XInput is not enabled.\n- \"1\": XInput is enabled. (default)\n\nThis hint should be set before SDL is initialized.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_XINPUT_ENABLED",
          "kind": "def",
          "value": "\"SDL_XINPUT_ENABLED\"",
          "sourceName": "SDL_HINT_XINPUT_ENABLED"
        },
        "SDL_HINT_ASSERT": {
          "doc": "A variable controlling response to SDL_assert failures.\n\nThe variable can be set to the following case-sensitive values:\n\n- \"abort\": Program terminates immediately.\n- \"break\": Program triggers a debugger breakpoint.\n- \"retry\": Program reruns the SDL_assert's test again.\n- \"ignore\": Program continues on, ignoring this assertion failure this\n  time.\n- \"always_ignore\": Program continues on, ignoring this assertion failure\n  for the rest of the run.\n\nNote that SetAssertionHandler offers a programmatic means to deal with\nassertion failures through a callback, and this hint is largely intended to\nbe used via environment variables by end users and automated tools.\n\nThis hint should be set before an assertion failure is triggered and can be\nchanged at any time.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_ASSERT",
          "kind": "def",
          "value": "\"SDL_ASSERT\"",
          "sourceName": "SDL_HINT_ASSERT"
        },
        "SDL_HINT_PEN_MOUSE_EVENTS": {
          "doc": "A variable controlling whether pen events should generate synthetic mouse\nevents.\n\nThe variable can be set to the following values:\n\n- \"0\": Pen events will not generate mouse events.\n- \"1\": Pen events will generate mouse events. (default)\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_PEN_MOUSE_EVENTS",
          "kind": "def",
          "value": "\"SDL_PEN_MOUSE_EVENTS\"",
          "sourceName": "SDL_HINT_PEN_MOUSE_EVENTS"
        },
        "SDL_HINT_PEN_TOUCH_EVENTS": {
          "doc": "A variable controlling whether pen events should generate synthetic touch\nevents.\n\nThe variable can be set to the following values:\n\n- \"0\": Pen events will not generate touch events.\n- \"1\": Pen events will generate touch events. (default)\n\nThis hint can be set anytime.\n\n@since This hint is available since SDL 3.2.0.",
          "name": "SDL_HINT_PEN_TOUCH_EVENTS",
          "kind": "def",
          "value": "\"SDL_PEN_TOUCH_EVENTS\"",
          "sourceName": "SDL_HINT_PEN_TOUCH_EVENTS"
        },
        "HintPriority": {
          "doc": "An enumeration of hint priorities.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "HintPriority",
          "kind": "alias",
          "sourceName": "SDL_HintPriority",
          "type": "SDL_HintPriority"
        },
        "HINT_DEFAULT": {
          "doc": "",
          "name": "HINT_DEFAULT",
          "kind": "var",
          "type": "HintPriority",
          "sourceName": "SDL_HINT_DEFAULT",
          "constexpr": true
        },
        "HINT_NORMAL": {
          "doc": "",
          "name": "HINT_NORMAL",
          "kind": "var",
          "type": "HintPriority",
          "sourceName": "SDL_HINT_NORMAL",
          "constexpr": true
        },
        "HINT_OVERRIDE": {
          "doc": "",
          "name": "HINT_OVERRIDE",
          "kind": "var",
          "type": "HintPriority",
          "sourceName": "SDL_HINT_OVERRIDE",
          "constexpr": true
        },
        "SetHintWithPriority": {
          "doc": "Set a hint with a specific priority.\n\nThe priority controls the behavior when setting a hint that already has a\nvalue. Hints will replace existing hints of their priority and lower.\nEnvironment variables are considered to have override priority.\n\n@param name the hint to set.\n@param value the value of the hint variable.\n@param priority the HintPriority level for the hint.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetHint\n@sa ResetHint\n@sa SetHint",
          "name": "SetHintWithPriority",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "name",
              "type": "StringParam"
            },
            {
              "name": "value",
              "type": "StringParam"
            },
            {
              "name": "priority",
              "type": "HintPriority"
            }
          ],
          "sourceName": "SDL_SetHintWithPriority"
        },
        "SetHint": {
          "doc": "Set a hint with normal priority.\n\nHints will not be set if there is an existing override hint or environment\nvariable that takes precedence. You can use SetHintWithPriority() to\nset the hint with override priority instead.\n\n@param name the hint to set.\n@param value the value of the hint variable.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetHint\n@sa ResetHint\n@sa SetHintWithPriority",
          "name": "SetHint",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "name",
              "type": "StringParam"
            },
            {
              "name": "value",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_SetHint"
        },
        "ResetHint": {
          "doc": "Reset a hint to the default value.\n\nThis will reset a hint to the value of the environment variable, or nullptr if\nthe environment isn't set. Callbacks will be called normally with this\nchange.\n\n@param name the hint to set.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SetHint\n@sa ResetHints",
          "name": "ResetHint",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "name",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_ResetHint"
        },
        "ResetHints": {
          "doc": "Reset all hints to the default values.\n\nThis will reset all hints to the value of the associated environment\nvariable, or nullptr if the environment isn't set. Callbacks will be called\nnormally with this change.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa ResetHint",
          "name": "ResetHints",
          "kind": "function",
          "type": "void",
          "parameters": [],
          "sourceName": "SDL_ResetHints"
        },
        "GetHint": {
          "doc": "Get the value of a hint.\n\n@param name the hint to query.\n@returns the string value of a hint or nullptr if the hint isn't set.\n\n@threadsafety It is safe to call this function from any thread, however the\n              return value only remains valid until the hint is changed; if\n              another thread might do so, the app should supply locks\n              and/or make a copy of the string. Note that using a hint\n              callback instead is always thread-safe, as SDL holds a lock\n              on the thread subsystem during the callback.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SetHint\n@sa SetHintWithPriority",
          "name": "GetHint",
          "kind": "function",
          "type": "const char *",
          "parameters": [
            {
              "name": "name",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_GetHint"
        },
        "GetHintBoolean": {
          "doc": "Get the boolean value of a hint variable.\n\n@param name the name of the hint to get the boolean value from.\n@param default_value the value to return if the hint does not exist.\n@returns the boolean value of a hint or the provided default value if the\n         hint does not exist.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetHint\n@sa SetHint",
          "name": "GetHintBoolean",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "name",
              "type": "StringParam"
            },
            {
              "name": "default_value",
              "type": "bool"
            }
          ],
          "sourceName": "SDL_GetHintBoolean"
        },
        "HintCallback": {
          "doc": "A callback used to send notifications of hint value changes.\n\nThis is called an initial time during AddHintCallback with the hint's\ncurrent value, and then again each time the hint's value changes.\n\n@param userdata what was passed as `userdata` to AddHintCallback().\n@param name what was passed as `name` to AddHintCallback().\n@param oldValue the previous hint value.\n@param newValue the new value hint is to be set to.\n\n@threadsafety This callback is fired from whatever thread is setting a new\n              hint value. SDL holds a lock on the hint subsystem when\n              calling this callback.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa AddHintCallback",
          "name": "HintCallback",
          "kind": "alias",
          "type": "SDL_HintCallback",
          "sourceName": "SDL_HintCallback"
        },
        "AddHintCallback": {
          "doc": "Add a function to watch a particular hint.\n\nThe callback function is called _during_ this function, to provide it an\ninitial value, and again each time the hint's value changes.\n\n@param name the hint to watch.\n@param callback An HintCallback function that will be called when the\n                hint value changes.\n@param userdata a pointer to pass to the callback function.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RemoveHintCallback",
          "name": "AddHintCallback",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "name",
              "type": "StringParam"
            },
            {
              "name": "callback",
              "type": "HintCallback"
            },
            {
              "name": "userdata",
              "type": "void *"
            }
          ],
          "sourceName": "SDL_AddHintCallback"
        },
        "RemoveHintCallback": {
          "doc": "Remove a function watching a particular hint.\n\n@param name the hint being watched.\n@param callback an HintCallback function that will be called when the\n                hint value changes.\n@param userdata a pointer being passed to the callback function.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa AddHintCallback",
          "name": "RemoveHintCallback",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "name",
              "type": "StringParam"
            },
            {
              "name": "callback",
              "type": "HintCallback"
            },
            {
              "name": "userdata",
              "type": "void *"
            }
          ],
          "sourceName": "SDL_RemoveHintCallback"
        }
      }
    },
    "SDL3pp_rect.h": {
      "name": "SDL3pp_rect.h",
      "doc": "@defgroup CategoryRect Category Rect\n\nSome helper functions for managing rectangles and 2D points, in both\ninteger and floating point versions.",
      "entries": {
        "FPoint-forward": {
          "name": "FPoint",
          "kind": "forward",
          "doc": ""
        },
        "Rect-forward": {
          "name": "Rect",
          "kind": "forward",
          "doc": ""
        },
        "FRect-forward": {
          "name": "FRect",
          "kind": "forward",
          "doc": ""
        },
        "Point": {
          "doc": "The structure that defines a point (using integers).\n\n@since This struct is available since SDL 3.2.0.\n\n@sa Rect.GetEnclosingPoints\n@sa Point.IsInRect",
          "name": "Point",
          "kind": "struct",
          "sourceName": "SDL_Point",
          "type": "SDL_Point",
          "entries": {
            "Point": [
              {
                "kind": "function",
                "name": "Point",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "const SDL_Point &",
                    "name": "p",
                    "default": "{}"
                  }
                ],
                "doc": "Wraps Point.\n\n@param p the value to be wrapped"
              },
              {
                "kind": "function",
                "name": "Point",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "int",
                    "name": "x"
                  },
                  {
                    "type": "int",
                    "name": "y"
                  }
                ],
                "doc": "Constructs from its fields.\n\n@param x the value for x.\n@param y the value for y."
              },
              {
                "kind": "function",
                "type": "",
                "constexpr": true,
                "explicit": true,
                "parameters": [
                  {
                    "type": "const SDL_FPoint &",
                    "name": "p"
                  }
                ],
                "name": "Point",
                "doc": ""
              }
            ],
            "operator<=>": {
              "kind": "function",
              "name": "operator<=>",
              "type": "auto",
              "constexpr": true,
              "immutable": true,
              "parameters": [
                {
                  "type": "const Point &",
                  "name": "other"
                }
              ],
              "doc": ""
            },
            "operator bool": {
              "kind": "function",
              "name": "operator bool",
              "type": "",
              "constexpr": true,
              "explicit": true,
              "immutable": true,
              "parameters": [],
              "doc": "Check if valid.\n\n@returns True if valid state, false otherwise."
            },
            "GetX": {
              "kind": "function",
              "name": "GetX",
              "type": "int",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the x.\n\n@returns current x value."
            },
            "SetX": {
              "kind": "function",
              "name": "SetX",
              "type": "Point &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "int",
                  "name": "newX"
                }
              ],
              "doc": "Set the x.\n\n@param newX the new x value.\n@returns Reference to self."
            },
            "GetY": {
              "kind": "function",
              "name": "GetY",
              "type": "int",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the y.\n\n@returns current y value."
            },
            "SetY": {
              "kind": "function",
              "name": "SetY",
              "type": "Point &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "int",
                  "name": "newY"
                }
              ],
              "doc": "Set the y.\n\n@param newY the new y value.\n@returns Reference to self."
            },
            "IsInRect": {
              "doc": "Determine whether a point resides inside a rectangle.\n\nA point is considered part of a rectangle if both `p` and `r` are not nullptr,\nand `p`'s x and y coordinates are >= to the rectangle's top left corner,\nand < the rectangle's x+w and y+h. So a 1x1 rectangle considers point (0,0)\nas \"inside\" and (0,1) as not.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param r the rectangle to test.\n@returns true if `p` is contained by `r`, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "IsInRect",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "r",
                  "type": "const Rect &"
                }
              ],
              "sourceName": "SDL_PointInRect",
              "constexpr": true,
              "immutable": true
            }
          }
        },
        "FPoint": {
          "doc": "The structure that defines a point (using floating point values).\n\n@since This struct is available since SDL 3.2.0.\n\n@sa FRect.GetEnclosingPoints\n@sa FPoint.IsInRect",
          "name": "FPoint",
          "kind": "struct",
          "sourceName": "SDL_FPoint",
          "type": "SDL_FPoint",
          "entries": {
            "FPoint": [
              {
                "kind": "function",
                "name": "FPoint",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "const SDL_FPoint &",
                    "name": "p",
                    "default": "{}"
                  }
                ],
                "doc": "Wraps FPoint.\n\n@param p the value to be wrapped"
              },
              {
                "kind": "function",
                "name": "FPoint",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "float",
                    "name": "x"
                  },
                  {
                    "type": "float",
                    "name": "y"
                  }
                ],
                "doc": "Constructs from its fields.\n\n@param x the value for x.\n@param y the value for y."
              }
            ],
            "operator<=>": {
              "kind": "function",
              "name": "operator<=>",
              "type": "auto",
              "constexpr": true,
              "immutable": true,
              "parameters": [
                {
                  "type": "const FPoint &",
                  "name": "other"
                }
              ],
              "doc": ""
            },
            "operator bool": {
              "kind": "function",
              "name": "operator bool",
              "type": "",
              "constexpr": true,
              "explicit": true,
              "immutable": true,
              "parameters": [],
              "doc": "Check if valid.\n\n@returns True if valid state, false otherwise."
            },
            "GetX": {
              "kind": "function",
              "name": "GetX",
              "type": "float",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the x.\n\n@returns current x value."
            },
            "SetX": {
              "kind": "function",
              "name": "SetX",
              "type": "FPoint &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "float",
                  "name": "newX"
                }
              ],
              "doc": "Set the x.\n\n@param newX the new x value.\n@returns Reference to self."
            },
            "GetY": {
              "kind": "function",
              "name": "GetY",
              "type": "float",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the y.\n\n@returns current y value."
            },
            "SetY": {
              "kind": "function",
              "name": "SetY",
              "type": "FPoint &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "float",
                  "name": "newY"
                }
              ],
              "doc": "Set the y.\n\n@param newY the new y value.\n@returns Reference to self."
            },
            "IsInRect": {
              "doc": "Determine whether a point resides inside a floating point rectangle.\n\nA point is considered part of a rectangle if both `p` and `r` are not nullptr,\nand `p`'s x and y coordinates are >= to the rectangle's top left corner,\nand <= the rectangle's x+w and y+h. So a 1x1 rectangle considers point\n(0,0) and (0,1) as \"inside\" and (0,2) as not.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param r the rectangle to test.\n@returns true if `p` is contained by `r`, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "IsInRect",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "r",
                  "type": "const FRect &"
                }
              ],
              "sourceName": "SDL_PointInRectFloat",
              "constexpr": true,
              "immutable": true
            }
          }
        },
        "Rect": {
          "doc": "A rectangle, with the origin at the upper left (using integers).\n\n@since This struct is available since SDL 3.2.0.\n\n@sa Rect.Empty\n@sa Rect.Equal\n@sa Rect.HasIntersection\n@sa Rect.GetIntersection\n@sa Rect.IntersectLine\n@sa Rect.GetUnion\n@sa Rect.GetEnclosingPoints",
          "name": "Rect",
          "kind": "struct",
          "sourceName": "SDL_Rect",
          "type": "SDL_Rect",
          "entries": {
            "Rect": [
              {
                "kind": "function",
                "name": "Rect",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "const SDL_Rect &",
                    "name": "r",
                    "default": "{}"
                  }
                ],
                "doc": "Wraps Rect.\n\n@param r the value to be wrapped"
              },
              {
                "kind": "function",
                "name": "Rect",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "int",
                    "name": "x"
                  },
                  {
                    "type": "int",
                    "name": "y"
                  },
                  {
                    "type": "int",
                    "name": "w"
                  },
                  {
                    "type": "int",
                    "name": "h"
                  }
                ],
                "doc": "Constructs from its fields.\n\n@param x the value for x.\n@param y the value for y.\n@param w the value for w.\n@param h the value for h."
              },
              {
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "corner",
                    "type": "const SDL_Point &"
                  },
                  {
                    "name": "size",
                    "type": "const SDL_Point &"
                  }
                ],
                "name": "Rect",
                "doc": ""
              }
            ],
            "operator==": {
              "kind": "function",
              "name": "operator==",
              "type": "bool",
              "constexpr": true,
              "immutable": true,
              "parameters": [
                {
                  "type": "const Rect &",
                  "name": "other"
                }
              ],
              "doc": ""
            },
            "operator bool": {
              "doc": "@sa Empty()",
              "kind": "function",
              "immutable": true,
              "constexpr": true,
              "parameters": [],
              "type": "",
              "name": "operator bool"
            },
            "GetX": {
              "kind": "function",
              "name": "GetX",
              "type": "int",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the x.\n\n@returns current x value."
            },
            "SetX": {
              "kind": "function",
              "name": "SetX",
              "type": "Rect &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "int",
                  "name": "newX"
                }
              ],
              "doc": "Set the x.\n\n@param newX the new x value.\n@returns Reference to self."
            },
            "GetY": {
              "kind": "function",
              "name": "GetY",
              "type": "int",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the y.\n\n@returns current y value."
            },
            "SetY": {
              "kind": "function",
              "name": "SetY",
              "type": "Rect &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "int",
                  "name": "newY"
                }
              ],
              "doc": "Set the y.\n\n@param newY the new y value.\n@returns Reference to self."
            },
            "GetW": {
              "kind": "function",
              "name": "GetW",
              "type": "int",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the w.\n\n@returns current w value."
            },
            "SetW": {
              "kind": "function",
              "name": "SetW",
              "type": "Rect &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "int",
                  "name": "newW"
                }
              ],
              "doc": "Set the w.\n\n@param newW the new w value.\n@returns Reference to self."
            },
            "GetH": {
              "kind": "function",
              "name": "GetH",
              "type": "int",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the h.\n\n@returns current h value."
            },
            "SetH": {
              "kind": "function",
              "name": "SetH",
              "type": "Rect &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "int",
                  "name": "newH"
                }
              ],
              "doc": "Set the h.\n\n@param newH the new h value.\n@returns Reference to self."
            },
            "GetEnclosingPoints": {
              "doc": "Calculate a minimal rectangle enclosing a set of points.\n\nIf `clip` is not nullptr then only points inside of the clipping rectangle are\nconsidered.\n\n@param points an array of Point structures representing points to be\n              enclosed.\n@param count the number of structures in the `points` array.\n@param clip an Rect used for clipping or nullptr to enclose all points.\n@param result an Rect structure filled in with the minimal enclosing\n              rectangle.\n@returns true if any points were enclosed or false if all the points were\n         outside of the clipping rectangle.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetEnclosingPoints",
              "kind": "function",
              "type": "std::optional<Rect>",
              "parameters": [
                {
                  "name": "points",
                  "type": "SpanRef<const SDL_Point>"
                },
                {
                  "name": "clip",
                  "type": "OptionalRef<const SDL_Rect>",
                  "default": "std::nullopt"
                }
              ],
              "sourceName": "SDL_GetRectEnclosingPoints",
              "static": true
            },
            "FromCenter": [
              {
                "kind": "function",
                "name": "FromCenter",
                "type": "Rect",
                "parameters": [
                  {
                    "name": "cx",
                    "type": "int"
                  },
                  {
                    "name": "cy",
                    "type": "int"
                  },
                  {
                    "name": "w",
                    "type": "int"
                  },
                  {
                    "name": "h",
                    "type": "int"
                  }
                ],
                "doc": ""
              },
              {
                "kind": "function",
                "name": "FromCenter",
                "type": "Rect",
                "parameters": [
                  {
                    "name": "center",
                    "type": "const Point &"
                  },
                  {
                    "name": "size",
                    "type": "const Point &"
                  }
                ],
                "doc": ""
              }
            ],
            "FromCorners": [
              {
                "kind": "function",
                "name": "FromCorners",
                "type": "Rect",
                "parameters": [
                  {
                    "name": "x1",
                    "type": "int"
                  },
                  {
                    "name": "y1",
                    "type": "int"
                  },
                  {
                    "name": "x2",
                    "type": "int"
                  },
                  {
                    "name": "y2",
                    "type": "int"
                  }
                ],
                "doc": ""
              },
              {
                "kind": "function",
                "name": "FromCorners",
                "type": "Rect",
                "parameters": [
                  {
                    "name": "p1",
                    "type": "const Point &"
                  },
                  {
                    "name": "p2",
                    "type": "const Point &"
                  }
                ],
                "doc": ""
              }
            ],
            "GetX2": {
              "kind": "function",
              "name": "GetX2",
              "doc": ""
            },
            "SetX2": {
              "kind": "function",
              "name": "SetX2",
              "doc": ""
            },
            "GetY2": {
              "kind": "function",
              "name": "GetY2",
              "doc": ""
            },
            "SetY2": {
              "kind": "function",
              "name": "SetY2",
              "doc": ""
            },
            "GetTopLeft": {
              "kind": "function",
              "name": "GetTopLeft",
              "doc": ""
            },
            "GetTopRight": {
              "kind": "function",
              "name": "GetTopRight",
              "doc": ""
            },
            "GetBottomLeft": {
              "kind": "function",
              "name": "GetBottomLeft",
              "doc": ""
            },
            "GetBottomRight": {
              "kind": "function",
              "name": "GetBottomRight",
              "doc": ""
            },
            "GetSize": {
              "kind": "function",
              "name": "GetSize",
              "doc": ""
            },
            "GetCentroid": {
              "kind": "function",
              "name": "GetCentroid",
              "doc": ""
            },
            "IntersectLine": [
              {
                "doc": "Calculate the intersection of a rectangle and line segment.\n\nThis function is used to clip a line segment to a rectangle. A line segment\ncontained entirely within the rectangle or that does not intersect will\nremain unchanged. A line segment that crosses the rectangle at either or\nboth ends will be clipped to the boundary of the rectangle and the new\ncoordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.\n\n@param X1 a pointer to the starting X-coordinate of the line.\n@param Y1 a pointer to the starting Y-coordinate of the line.\n@param X2 a pointer to the ending X-coordinate of the line.\n@param Y2 a pointer to the ending Y-coordinate of the line.\n@returns true if there is an intersection, false otherwise.\n\n@since This function is available since SDL 3.2.0.",
                "name": "IntersectLine",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "X1",
                    "type": "int *"
                  },
                  {
                    "name": "Y1",
                    "type": "int *"
                  },
                  {
                    "name": "X2",
                    "type": "int *"
                  },
                  {
                    "name": "Y2",
                    "type": "int *"
                  }
                ],
                "sourceName": "SDL_GetRectAndLineIntersection",
                "immutable": true
              },
              {
                "kind": "function",
                "name": "IntersectLine",
                "doc": ""
              }
            ],
            "operator FRect": {
              "doc": "Convert an Rect to FRect\n\n@param rect a pointer to an Rect.\n@param frect a pointer filled in with the floating point representation of\n             `rect`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "operator FRect",
              "kind": "function",
              "type": "",
              "parameters": [],
              "sourceName": "SDL_RectToFRect",
              "static": false,
              "immutable": true,
              "constexpr": true
            },
            "operator SDL_FRect": {
              "doc": "@sa operator FRect()",
              "kind": "function",
              "immutable": true,
              "constexpr": true,
              "parameters": [],
              "type": "",
              "name": "operator SDL_FRect"
            },
            "Empty": {
              "doc": "Determine whether a rectangle has no area.\n\nA rectangle is considered \"empty\" for this function if `r` is nullptr, or if\n`r`'s width and/or height are <= 0.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@returns true if the rectangle is \"empty\", false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "Empty",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_RectEmpty",
              "constexpr": true,
              "immutable": true
            },
            "Equal": {
              "doc": "Determine whether two rectangles are equal.\n\nRectangles are considered equal if both are not nullptr and each of their x,\ny, width and height match.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param b the second rectangle to test.\n@returns true if the rectangles are equal, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "Equal",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "other",
                  "type": "const Rect &"
                }
              ],
              "sourceName": "SDL_RectsEqual",
              "immutable": true,
              "constexpr": true
            },
            "Contains": [
              {
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "p",
                    "type": "const Point &"
                  }
                ],
                "constexpr": true,
                "immutable": true,
                "name": "Contains",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "other",
                    "type": "const Rect &"
                  }
                ],
                "constexpr": true,
                "immutable": true,
                "name": "Contains",
                "doc": ""
              }
            ],
            "HasIntersection": {
              "doc": "Determine whether two rectangles intersect.\n\nIf either pointer is nullptr the function will return false.\n\n@param B an Rect structure representing the second rectangle.\n@returns true if there is an intersection, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Rect.GetIntersection",
              "name": "HasIntersection",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "other",
                  "type": "const Rect &"
                }
              ],
              "sourceName": "SDL_HasRectIntersection",
              "immutable": true
            },
            "GetIntersection": {
              "doc": "Calculate the intersection of two rectangles.\n\nIf `result` is nullptr then this function will return false.\n\n@param B an Rect structure representing the second rectangle.\n@param result an Rect structure filled in with the intersection of\n              rectangles `A` and `B`.\n@returns true if there is an intersection, false otherwise.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Rect.HasIntersection",
              "name": "GetIntersection",
              "kind": "function",
              "type": "std::optional<Rect>",
              "parameters": [
                {
                  "name": "other",
                  "type": "const Rect &"
                }
              ],
              "sourceName": "SDL_GetRectIntersection",
              "immutable": true
            },
            "GetUnion": {
              "doc": "Calculate the union of two rectangles.\n\n@param B an Rect structure representing the second rectangle.\n@param result an Rect structure filled in with the union of rectangles\n              `A` and `B`.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetUnion",
              "kind": "function",
              "type": "std::optional<Rect>",
              "parameters": [
                {
                  "name": "other",
                  "type": "const Rect &"
                }
              ],
              "sourceName": "SDL_GetRectUnion",
              "immutable": true
            }
          }
        },
        "FRect": {
          "doc": "A rectangle, with the origin at the upper left (using floating point\nvalues).\n\n@since This struct is available since SDL 3.2.0.\n\n@sa FRect.Empty\n@sa FRect.Equal\n@sa FRect.EqualEpsilon\n@sa FRect.HasIntersection\n@sa FRect.GetIntersection\n@sa FRect.IntersectLine\n@sa FRect.GetUnion\n@sa FRect.GetEnclosingPoints\n@sa FPoint.IsInRect",
          "name": "FRect",
          "kind": "struct",
          "sourceName": "SDL_FRect",
          "type": "SDL_FRect",
          "entries": {
            "FRect": [
              {
                "kind": "function",
                "name": "FRect",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "const SDL_FRect &",
                    "name": "r",
                    "default": "{}"
                  }
                ],
                "doc": "Wraps FRect.\n\n@param r the value to be wrapped"
              },
              {
                "kind": "function",
                "name": "FRect",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "float",
                    "name": "x"
                  },
                  {
                    "type": "float",
                    "name": "y"
                  },
                  {
                    "type": "float",
                    "name": "w"
                  },
                  {
                    "type": "float",
                    "name": "h"
                  }
                ],
                "doc": "Constructs from its fields.\n\n@param x the value for x.\n@param y the value for y.\n@param w the value for w.\n@param h the value for h."
              },
              {
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "corner",
                    "type": "const SDL_FPoint &"
                  },
                  {
                    "name": "size",
                    "type": "const SDL_FPoint &"
                  }
                ],
                "name": "FRect",
                "doc": ""
              }
            ],
            "operator==": {
              "kind": "function",
              "name": "operator==",
              "type": "bool",
              "constexpr": true,
              "immutable": true,
              "parameters": [
                {
                  "type": "const FRect &",
                  "name": "other"
                }
              ],
              "doc": ""
            },
            "operator bool": {
              "doc": "@sa Empty()",
              "kind": "function",
              "immutable": true,
              "constexpr": true,
              "parameters": [],
              "type": "",
              "name": "operator bool"
            },
            "GetX": {
              "kind": "function",
              "name": "GetX",
              "type": "float",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the x.\n\n@returns current x value."
            },
            "SetX": {
              "kind": "function",
              "name": "SetX",
              "type": "FRect &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "float",
                  "name": "newX"
                }
              ],
              "doc": "Set the x.\n\n@param newX the new x value.\n@returns Reference to self."
            },
            "GetY": {
              "kind": "function",
              "name": "GetY",
              "type": "float",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the y.\n\n@returns current y value."
            },
            "SetY": {
              "kind": "function",
              "name": "SetY",
              "type": "FRect &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "float",
                  "name": "newY"
                }
              ],
              "doc": "Set the y.\n\n@param newY the new y value.\n@returns Reference to self."
            },
            "GetW": {
              "kind": "function",
              "name": "GetW",
              "type": "float",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the w.\n\n@returns current w value."
            },
            "SetW": {
              "kind": "function",
              "name": "SetW",
              "type": "FRect &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "float",
                  "name": "newW"
                }
              ],
              "doc": "Set the w.\n\n@param newW the new w value.\n@returns Reference to self."
            },
            "GetH": {
              "kind": "function",
              "name": "GetH",
              "type": "float",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the h.\n\n@returns current h value."
            },
            "SetH": {
              "kind": "function",
              "name": "SetH",
              "type": "FRect &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "float",
                  "name": "newH"
                }
              ],
              "doc": "Set the h.\n\n@param newH the new h value.\n@returns Reference to self."
            },
            "GetEnclosingPoints": {
              "doc": "Calculate a minimal rectangle enclosing a set of points with float\nprecision.\n\nIf `clip` is not nullptr then only points inside of the clipping rectangle are\nconsidered.\n\n@param points an array of FPoint structures representing points to be\n              enclosed.\n@param count the number of structures in the `points` array.\n@param clip an FRect used for clipping or nullptr to enclose all points.\n@param result an FRect structure filled in with the minimal enclosing\n              rectangle.\n@returns true if any points were enclosed or false if all the points were\n         outside of the clipping rectangle.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetEnclosingPoints",
              "kind": "function",
              "type": "std::optional<FRect>",
              "parameters": [
                {
                  "name": "points",
                  "type": "SpanRef<const SDL_FPoint>"
                },
                {
                  "name": "clip",
                  "type": "OptionalRef<const SDL_FRect>",
                  "default": "std::nullopt"
                }
              ],
              "sourceName": "SDL_GetRectEnclosingPointsFloat",
              "static": true
            },
            "FromCenter": [
              {
                "kind": "function",
                "name": "FromCenter",
                "type": "FRect",
                "static": true,
                "parameters": [
                  {
                    "name": "cx",
                    "type": "float"
                  },
                  {
                    "name": "cy",
                    "type": "float"
                  },
                  {
                    "name": "w",
                    "type": "float"
                  },
                  {
                    "name": "h",
                    "type": "float"
                  }
                ],
                "doc": ""
              },
              {
                "kind": "function",
                "name": "FromCenter",
                "type": "FRect",
                "static": true,
                "parameters": [
                  {
                    "name": "center",
                    "type": "const FPoint &"
                  },
                  {
                    "name": "size",
                    "type": "const FPoint &"
                  }
                ],
                "doc": ""
              }
            ],
            "FromCorners": [
              {
                "kind": "function",
                "name": "FromCorners",
                "type": "FRect",
                "static": true,
                "parameters": [
                  {
                    "name": "x1",
                    "type": "float"
                  },
                  {
                    "name": "y1",
                    "type": "float"
                  },
                  {
                    "name": "x2",
                    "type": "float"
                  },
                  {
                    "name": "y2",
                    "type": "float"
                  }
                ],
                "doc": ""
              },
              {
                "kind": "function",
                "name": "FromCorners",
                "static": true,
                "type": "FRect",
                "parameters": [
                  {
                    "name": "p1",
                    "type": "const FPoint &"
                  },
                  {
                    "name": "p2",
                    "type": "const FPoint &"
                  }
                ],
                "doc": ""
              }
            ],
            "GetX2": {
              "kind": "function",
              "name": "GetX2",
              "doc": ""
            },
            "SetX2": {
              "kind": "function",
              "name": "SetX2",
              "doc": ""
            },
            "GetY2": {
              "kind": "function",
              "name": "GetY2",
              "doc": ""
            },
            "SetY2": {
              "kind": "function",
              "name": "SetY2",
              "doc": ""
            },
            "GetTopLeft": {
              "kind": "function",
              "name": "GetTopLeft",
              "doc": ""
            },
            "GetTopRight": {
              "kind": "function",
              "name": "GetTopRight",
              "doc": ""
            },
            "GetBottomLeft": {
              "kind": "function",
              "name": "GetBottomLeft",
              "doc": ""
            },
            "GetBottomRight": {
              "kind": "function",
              "name": "GetBottomRight",
              "doc": ""
            },
            "GetSize": {
              "kind": "function",
              "name": "GetSize",
              "doc": ""
            },
            "GetCentroid": {
              "kind": "function",
              "name": "GetCentroid",
              "doc": ""
            },
            "IntersectLine": [
              {
                "doc": "Calculate the intersection of a rectangle and line segment with float\nprecision.\n\nThis function is used to clip a line segment to a rectangle. A line segment\ncontained entirely within the rectangle or that does not intersect will\nremain unchanged. A line segment that crosses the rectangle at either or\nboth ends will be clipped to the boundary of the rectangle and the new\ncoordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.\n\n@param X1 a pointer to the starting X-coordinate of the line.\n@param Y1 a pointer to the starting Y-coordinate of the line.\n@param X2 a pointer to the ending X-coordinate of the line.\n@param Y2 a pointer to the ending Y-coordinate of the line.\n@returns true if there is an intersection, false otherwise.\n\n@since This function is available since SDL 3.2.0.",
                "name": "IntersectLine",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "X1",
                    "type": "float *"
                  },
                  {
                    "name": "Y1",
                    "type": "float *"
                  },
                  {
                    "name": "X2",
                    "type": "float *"
                  },
                  {
                    "name": "Y2",
                    "type": "float *"
                  }
                ],
                "sourceName": "SDL_GetRectAndLineIntersectionFloat",
                "immutable": true
              },
              {
                "kind": "function",
                "name": "IntersectLine",
                "doc": ""
              }
            ],
            "Empty": {
              "doc": "Determine whether a floating point rectangle can contain any point.\n\nA rectangle is considered \"empty\" for this function if `r` is nullptr, or if\n`r`'s width and/or height are < 0.0f.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@returns true if the rectangle is \"empty\", false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "Empty",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_RectEmptyFloat",
              "constexpr": true,
              "immutable": true
            },
            "EqualEpsilon": {
              "doc": "Determine whether two floating point rectangles are equal, within some\ngiven epsilon.\n\nRectangles are considered equal if both are not nullptr and each of their x,\ny, width and height are within `epsilon` of each other. If you don't know\nwhat value to use for `epsilon`, you should call the FRect.Equal\nfunction instead.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param b the second rectangle to test.\n@param epsilon the epsilon value for comparison.\n@returns true if the rectangles are equal, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa FRect.Equal",
              "name": "EqualEpsilon",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "other",
                  "type": "const FRect &"
                },
                {
                  "name": "epsilon",
                  "type": "const float"
                }
              ],
              "sourceName": "SDL_RectsEqualEpsilon",
              "immutable": true,
              "constexpr": true
            },
            "Equal": {
              "doc": "Determine whether two floating point rectangles are equal, within a default\nepsilon.\n\nRectangles are considered equal if both are not nullptr and each of their x,\ny, width and height are within SDL_FLT_EPSILON of each other. This is often\na reasonable way to compare two floating point rectangles and deal with the\nslight precision variations in floating point calculations that tend to pop\nup.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param b the second rectangle to test.\n@returns true if the rectangles are equal, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa FRect.EqualEpsilon",
              "name": "Equal",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "other",
                  "type": "const FRect &"
                }
              ],
              "sourceName": "SDL_RectsEqualFloat",
              "immutable": true,
              "constexpr": true
            },
            "Contains": [
              {
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "p",
                    "type": "const FPoint &"
                  }
                ],
                "constexpr": true,
                "immutable": true,
                "name": "Contains",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "other",
                    "type": "const FRect &"
                  }
                ],
                "constexpr": true,
                "immutable": true,
                "name": "Contains",
                "doc": ""
              }
            ],
            "HasIntersection": {
              "doc": "Determine whether two rectangles intersect with float precision.\n\nIf either pointer is nullptr the function will return false.\n\n@param B an FRect structure representing the second rectangle.\n@returns true if there is an intersection, false otherwise.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Rect.GetIntersection",
              "name": "HasIntersection",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "other",
                  "type": "const FRect &"
                }
              ],
              "sourceName": "SDL_HasRectIntersectionFloat",
              "immutable": true
            },
            "GetIntersection": {
              "doc": "Calculate the intersection of two rectangles with float precision.\n\nIf `result` is nullptr then this function will return false.\n\n@param B an FRect structure representing the second rectangle.\n@param result an FRect structure filled in with the intersection of\n              rectangles `A` and `B`.\n@returns true if there is an intersection, false otherwise.\n\n@since This function is available since SDL 3.2.0.\n\n@sa FRect.HasIntersection",
              "name": "GetIntersection",
              "kind": "function",
              "type": "std::optional<FRect>",
              "parameters": [
                {
                  "name": "other",
                  "type": "const FRect &"
                }
              ],
              "sourceName": "SDL_GetRectIntersectionFloat",
              "immutable": true
            },
            "GetUnion": {
              "doc": "Calculate the union of two rectangles with float precision.\n\n@param B an FRect structure representing the second rectangle.\n@param result an FRect structure filled in with the union of rectangles\n              `A` and `B`.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetUnion",
              "kind": "function",
              "type": "std::optional<FRect>",
              "parameters": [
                {
                  "name": "other",
                  "type": "const FRect &"
                }
              ],
              "sourceName": "SDL_GetRectUnionFloat",
              "immutable": true
            }
          }
        }
      }
    },
    "SDL3pp_surface.h": {
      "name": "SDL3pp_surface.h",
      "doc": "@defgroup CategorySurface Category Surface\n\nSDL surfaces are buffers of pixels in system RAM. These are useful for\npassing around and manipulating images that are not stored in GPU memory.\n\nSurfaceBase makes serious efforts to manage images in various formats, and\nprovides a reasonable toolbox for transforming the data, including copying\nbetween surfaces, filling rectangles in the image data, etc.\n\nThere is also a simple .bmp loader, LoadBMP(). SDL itself does not\nprovide loaders for various other file formats, but there are several\nexcellent external libraries that do, including its own satellite library,\nSDL_image:\n\nhttps://github.com/libsdl-org/SDL_image",
      "entries": {
        "SurfaceLock-forward": {
          "name": "SurfaceLock",
          "kind": "forward",
          "doc": ""
        },
        "SurfaceBase-forward": {
          "name": "SurfaceBase",
          "kind": "forward",
          "template": [
            {
              "type": "ObjectBox<SDL_Surface *>",
              "name": "T"
            }
          ],
          "doc": ""
        },
        "SurfaceRef": {
          "name": "SurfaceRef",
          "kind": "alias",
          "type": "SurfaceBase<ObjectRef<SDL_Surface>>",
          "doc": "Handle to a non owned surface\n\n@cat resource\n\n@sa SurfaceBase\n@sa Surface"
        },
        "Surface": {
          "name": "Surface",
          "kind": "alias",
          "type": "SurfaceBase<ObjectUnique<SDL_Surface>>",
          "doc": "Handle to an owned surface\n\n@cat resource\n\n@sa SurfaceBase\n@sa SurfaceRef"
        },
        "SurfaceFlags": {
          "doc": "The flags on an SurfaceBase.\n\nThese are generally considered read-only.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "SurfaceFlags",
          "kind": "alias",
          "type": "SDL_SurfaceFlags",
          "sourceName": "SDL_SurfaceFlags"
        },
        "SURFACE_PREALLOCATED": {
          "doc": "Surface uses preallocated pixel memory",
          "name": "SURFACE_PREALLOCATED",
          "kind": "var",
          "value": "0x00000001u",
          "sourceName": "SDL_SURFACE_PREALLOCATED",
          "constexpr": true,
          "type": "SurfaceFlags"
        },
        "SURFACE_LOCK_NEEDED": {
          "doc": "Surface needs to be locked to access pixels",
          "name": "SURFACE_LOCK_NEEDED",
          "kind": "var",
          "value": "0x00000002u",
          "sourceName": "SDL_SURFACE_LOCK_NEEDED",
          "constexpr": true,
          "type": "SurfaceFlags"
        },
        "SURFACE_LOCKED": {
          "doc": "Surface is currently locked",
          "name": "SURFACE_LOCKED",
          "kind": "var",
          "value": "0x00000004u",
          "sourceName": "SDL_SURFACE_LOCKED",
          "constexpr": true,
          "type": "SurfaceFlags"
        },
        "SURFACE_SIMD_ALIGNED": {
          "doc": "Surface uses pixel memory allocated with aligned_alloc()",
          "name": "SURFACE_SIMD_ALIGNED",
          "kind": "var",
          "value": "0x00000008u",
          "sourceName": "SDL_SURFACE_SIMD_ALIGNED",
          "constexpr": true,
          "type": "SurfaceFlags"
        },
        "ScaleMode": {
          "doc": "The scaling mode.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "ScaleMode",
          "kind": "alias",
          "sourceName": "SDL_ScaleMode",
          "type": "SDL_ScaleMode"
        },
        "SCALEMODE_INVALID": {
          "doc": "",
          "name": "SCALEMODE_INVALID",
          "kind": "var",
          "type": "ScaleMode",
          "sourceName": "SDL_SCALEMODE_INVALID",
          "constexpr": true
        },
        "SCALEMODE_NEAREST": {
          "doc": "nearest pixel sampling",
          "name": "SCALEMODE_NEAREST",
          "kind": "var",
          "type": "ScaleMode",
          "sourceName": "SDL_SCALEMODE_NEAREST",
          "constexpr": true
        },
        "SCALEMODE_LINEAR": {
          "doc": "linear filtering",
          "name": "SCALEMODE_LINEAR",
          "kind": "var",
          "type": "ScaleMode",
          "sourceName": "SDL_SCALEMODE_LINEAR",
          "constexpr": true
        },
        "FlipMode": {
          "doc": "The flip mode.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "FlipMode",
          "kind": "alias",
          "sourceName": "SDL_FlipMode",
          "type": "SDL_FlipMode"
        },
        "FLIP_NONE": {
          "doc": "Do not flip.",
          "name": "FLIP_NONE",
          "kind": "var",
          "type": "FlipMode",
          "sourceName": "SDL_FLIP_NONE",
          "constexpr": true
        },
        "FLIP_HORIZONTAL": {
          "doc": "flip horizontally",
          "name": "FLIP_HORIZONTAL",
          "kind": "var",
          "type": "FlipMode",
          "sourceName": "SDL_FLIP_HORIZONTAL",
          "constexpr": true
        },
        "FLIP_VERTICAL": {
          "doc": "flip vertically",
          "name": "FLIP_VERTICAL",
          "kind": "var",
          "type": "FlipMode",
          "sourceName": "SDL_FLIP_VERTICAL",
          "constexpr": true
        },
        "SurfaceBase": {
          "doc": "A collection of pixels used in software blitting.\n\nPixels are arranged in memory in rows, with the top row first. Each row\noccupies an amount of memory given by the pitch (sometimes known as the row\nstride in non-SDL APIs).\n\nWithin each row, pixels are arranged from left to right until the width is\nreached. Each pixel occupies a number of bits appropriate for its format,\nwith most formats representing each pixel as one or more whole bytes (in\nsome indexed formats, instead multiple pixels are packed into each byte),\nand a byte order given by the format. After encoding all pixels, any\nremaining bytes to reach the pitch are used as padding to reach a desired\nalignment, and have undefined contents.\n\nWhen a surface holds YUV format data, the planes are assumed to be\ncontiguous without padding between them, e.g. a 32x32 surface in NV12\nformat with a pitch of 32 would consist of 32x32 bytes of Y plane followed\nby 32x16 bytes of UV plane.\n\nWhen a surface holds MJPG format data, pixels points at the compressed JPEG\nimage and pitch is the length of that data.\n\n@since This struct is available since SDL 3.2.0.\n\n@sa SurfaceBase.SurfaceBase\n@sa SurfaceBase.Destroy",
          "name": "SurfaceBase",
          "kind": "struct",
          "sourceName": "SDL_Surface",
          "type": "T",
          "template": [
            {
              "type": "ObjectBox<SDL_Surface *>",
              "name": "T"
            }
          ],
          "entries": {
            "T::T": {
              "kind": "alias",
              "name": "T::T",
              "doc": ""
            },
            "SurfaceBase": [
              {
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "type": "StringParam",
                    "name": "file"
                  }
                ],
                "name": "SurfaceBase",
                "doc": ""
              },
              {
                "doc": "Allocate a new surface with a specific pixel format.\n\nThe pixels of the new surface are initialized to zero.\n\n@param width the width of the surface.\n@param height the height of the surface.\n@param format the PixelFormat for the new surface's pixel format.\n@post the new SurfaceBase structure that is created or nullptr on failure;\n         call GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.SurfaceBase\n@sa SurfaceBase.Destroy",
                "name": "SurfaceBase",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "width",
                    "type": "int"
                  },
                  {
                    "name": "height",
                    "type": "int"
                  },
                  {
                    "name": "format",
                    "type": "PixelFormat"
                  }
                ],
                "sourceName": "SDL_CreateSurface"
              },
              {
                "doc": "Allocate a new surface with a specific pixel format and existing pixel\ndata.\n\nNo copy is made of the pixel data. Pixel data is not managed automatically;\nyou must free the surface before you free the pixel data.\n\nPitch is the offset in bytes from one row of pixels to the next, e.g.\n`width*4` for `PIXELFORMAT_RGBA8888`.\n\nYou may pass nullptr for pixels and 0 for pitch to create a surface that you\nwill fill in with valid values later.\n\n@param width the width of the surface.\n@param height the height of the surface.\n@param format the PixelFormat for the new surface's pixel format.\n@param pixels a pointer to existing pixel data.\n@param pitch the number of bytes between each row, including padding.\n@post the new SurfaceBase structure that is created or nullptr on failure;\n         call GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.SurfaceBase\n@sa SurfaceBase.Destroy",
                "name": "SurfaceBase",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "width",
                    "type": "int"
                  },
                  {
                    "name": "height",
                    "type": "int"
                  },
                  {
                    "name": "format",
                    "type": "PixelFormat"
                  },
                  {
                    "name": "pixels",
                    "type": "void *"
                  },
                  {
                    "name": "pitch",
                    "type": "int"
                  }
                ],
                "sourceName": "SDL_CreateSurfaceFrom"
              }
            ],
            "GetProperties": {
              "doc": "Get the properties associated with a surface.\n\nThe following properties are understood by SDL:\n\n- `SDL_PROP_SURFACE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point\n  surfaces, this defines the value of 100% diffuse white, with higher\n  values being displayed in the High Dynamic Range headroom. This defaults\n  to 203 for HDR10 surfaces and 1.0 for floating point surfaces.\n- `prop::Surface.HDR_HEADROOM_FLOAT`: for HDR10 and floating point\n  surfaces, this defines the maximum dynamic range used by the content, in\n  terms of the SDR white point. This defaults to 0.0, which disables tone\n  mapping.\n- `prop::Surface.TONEMAP_OPERATOR_STRING`: the tone mapping operator\n  used when compressing from a surface with high dynamic range to another\n  with lower dynamic range. Currently this supports \"chrome\", which uses\n  the same tone mapping that Chrome uses for HDR content, the form \"*=N\",\n  where N is a floating point scale factor applied in linear space, and\n  \"none\", which disables tone mapping. This defaults to \"chrome\".\n- `prop::Surface.HOTSPOT_X_NUMBER`: the hotspot pixel offset from the\n  left edge of the image, if this surface is being used as a cursor.\n- `prop::Surface.HOTSPOT_Y_NUMBER`: the hotspot pixel offset from the\n  top edge of the image, if this surface is being used as a cursor.\n\n@returns a valid property ID on success or 0 on failure; call\n         GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetProperties",
              "kind": "function",
              "type": "PropertiesRef",
              "parameters": [],
              "sourceName": "SDL_GetSurfaceProperties",
              "immutable": true
            },
            "SetColorspace": {
              "doc": "Set the colorspace used by a surface.\n\nSetting the colorspace doesn't change the pixels, only how they are\ninterpreted in color operations.\n\n@param colorspace an Colorspace value describing the surface\n                  colorspace.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.GetColorspace",
              "name": "SetColorspace",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "colorspace",
                  "type": "Colorspace"
                }
              ],
              "sourceName": "SDL_SetSurfaceColorspace"
            },
            "GetColorspace": {
              "doc": "Get the colorspace used by a surface.\n\nThe colorspace defaults to COLORSPACE_SRGB_LINEAR for floating point\nformats, COLORSPACE_HDR10 for 10-bit formats, COLORSPACE_SRGB for\nother RGB surfaces and COLORSPACE_BT709_FULL for YUV textures.\n\n@returns the colorspace used by the surface, or COLORSPACE_UNKNOWN if\n         the surface is nullptr.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.SetColorspace",
              "name": "GetColorspace",
              "kind": "function",
              "type": "Colorspace",
              "parameters": [],
              "sourceName": "SDL_GetSurfaceColorspace",
              "immutable": true
            },
            "CreatePalette": {
              "doc": "Create a palette and associate it with a surface.\n\nThis function creates a palette compatible with the provided surface. The\npalette is then returned for you to modify, and the surface will\nautomatically use the new palette in future operations. You do not need to\ndestroy the returned palette, it will be freed when the reference count\nreaches 0, usually when the surface is destroyed.\n\nBitmap surfaces (with format PIXELFORMAT_INDEX1LSB or\nPIXELFORMAT_INDEX1MSB) will have the palette initialized with 0 as\nwhite and 1 as black. Other surfaces will get a palette initialized with\nwhite in every entry.\n\nIf this function is called for a surface that already has a palette, a new\npalette will be created to replace it.\n\n@returns a new PaletteBase structure on success or nullptr on failure (e.g. if\n         the surface didn't have an index format); call GetError() for\n         more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PaletteBase.SetColors",
              "name": "CreatePalette",
              "kind": "function",
              "type": "PaletteRef",
              "parameters": [],
              "sourceName": "SDL_CreateSurfacePalette"
            },
            "SetPalette": {
              "doc": "Set the palette used by a surface.\n\nA single palette can be shared with many surfaces.\n\n@param palette the PaletteBase structure to use.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PaletteBase.PaletteBase\n@sa SurfaceBase.GetPalette",
              "name": "SetPalette",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "palette",
                  "type": "PaletteRef"
                }
              ],
              "sourceName": "SDL_SetSurfacePalette"
            },
            "GetPalette": {
              "doc": "Get the palette used by a surface.\n\n@returns a pointer to the palette used by the surface, or nullptr if there is\n         no palette used.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.SetPalette",
              "name": "GetPalette",
              "kind": "function",
              "type": "PaletteRef",
              "parameters": [],
              "sourceName": "SDL_GetSurfacePalette",
              "immutable": true
            },
            "AddAlternateImage": {
              "doc": "Add an alternate version of a surface.\n\nThis function adds an alternate version of this surface, usually used for\ncontent with high DPI representations like cursors or icons. The size,\nformat, and content do not need to match the original surface, and these\nalternate versions will not be updated when the original surface changes.\n\nThis function adds a reference to the alternate version, so you should call\nSurfaceBase.Destroy() on the image after this call.\n\n@param image a pointer to an alternate SurfaceBase to associate with this\n             surface.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.RemoveAlternateImages\n@sa SurfaceBase.GetImages\n@sa SurfaceBase.HasAlternateImages",
              "name": "AddAlternateImage",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "image",
                  "type": "SurfaceRef"
                }
              ],
              "sourceName": "SDL_AddSurfaceAlternateImage"
            },
            "HasAlternateImages": {
              "doc": "Return whether a surface has alternate versions available.\n\n@returns true if alternate versions are available or false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.AddAlternateImage\n@sa SurfaceBase.RemoveAlternateImages\n@sa SurfaceBase.GetImages",
              "name": "HasAlternateImages",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_SurfaceHasAlternateImages",
              "immutable": true
            },
            "GetImages": {
              "doc": "Get an array including all versions of a surface.\n\nThis returns all versions of a surface, with the surface being queried as\nthe first element in the returned array.\n\nFreeing the array of surfaces does not affect the surfaces in the array.\nThey are still referenced by the surface being queried and will be cleaned\nup normally.\n\n@param surface the SurfaceBase structure to query.\n@param count a pointer filled in with the number of surface pointers\n             returned, may be nullptr.\n@returns a nullptr terminated array of SurfaceBase pointers or nullptr on\n         failure; call GetError() for more information. This should be\n         freed with free() when it is no longer needed.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.AddAlternateImage\n@sa SurfaceBase.RemoveAlternateImages\n@sa SurfaceBase.HasAlternateImages",
              "name": "GetImages",
              "kind": "function",
              "type": "OwnArray<SurfaceRef *>",
              "parameters": [],
              "sourceName": "SDL_GetSurfaceImages",
              "immutable": true
            },
            "RemoveAlternateImages": {
              "doc": "Remove all alternate versions of a surface.\n\nThis function removes a reference from all the alternative versions,\ndestroying them if this is the last reference to them.\n\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.AddAlternateImage\n@sa SurfaceBase.GetImages\n@sa SurfaceBase.HasAlternateImages",
              "name": "RemoveAlternateImages",
              "kind": "function",
              "type": "void",
              "parameters": [],
              "sourceName": "SDL_RemoveSurfaceAlternateImages"
            },
            "MustLock": {
              "doc": "Evaluates to true if the surface needs to be locked before access.\n\n@since This macro is available since SDL 3.2.0.",
              "name": "MustLock",
              "kind": "function",
              "parameters": [],
              "value": "(((S)->flags & SDL_SURFACE_LOCK_NEEDED) == SDL_SURFACE_LOCK_NEEDED)",
              "sourceName": "SDL_MUSTLOCK",
              "constexpr": true,
              "immutable": true,
              "type": "bool"
            },
            "Lock": {
              "doc": "Set up a surface for directly accessing the pixels.\n\nBetween calls to SurfaceBase.Lock() / SurfaceLock.Unlock(), you can write to\nand read from `surface->pixels`, using the pixel format stored in\n`surface->format`. Once you are done accessing the surface, you should use\nSurfaceLock.Unlock() to release it.\n\nNot all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to\n0, then you can read and write to the surface at any time, and the pixel\nformat of the surface will not change.\n\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe. The locking referred to by\n              this function is making the pixels available for direct\n              access, not thread-safe locking.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SDL_MUSTLOCK\n@sa SurfaceLock.Unlock",
              "name": "Lock",
              "kind": "function",
              "type": "SurfaceLock",
              "parameters": [],
              "sourceName": "SDL_LockSurface",
              "reference": 1
            },
            "SetRLE": {
              "doc": "Set the RLE acceleration hint for a surface.\n\nIf RLE is enabled, color key and alpha blending blits are much faster, but\nthe surface must be locked before directly accessing the pixels.\n\n@param enabled true to enable RLE acceleration, false to disable it.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.Blit\n@sa SurfaceBase.Lock\n@sa SurfaceLock.Unlock",
              "name": "SetRLE",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "enabled",
                  "type": "bool"
                }
              ],
              "sourceName": "SDL_SetSurfaceRLE"
            },
            "HasRLE": {
              "doc": "Returns whether the surface is RLE enabled.\n\nIt is safe to pass a nullptr `surface` here; it will return false.\n\n@returns true if the surface is RLE enabled, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.SetRLE",
              "name": "HasRLE",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_SurfaceHasRLE",
              "immutable": true
            },
            "SetColorKey": [
              {
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "type": "Color",
                    "name": "key"
                  }
                ],
                "name": "SetColorKey",
                "doc": ""
              },
              {
                "doc": "Set the color key (transparent pixel) in a surface.\n\nThe color key defines a pixel value that will be treated as transparent in\na blit. For example, one can use this to specify that cyan pixels should be\nconsidered transparent, and therefore not rendered.\n\nIt is a pixel of the format used by the surface, as generated by\nMapRGB().\n\n@param enabled true to enable color key, false to disable color key.\n@param key the transparent pixel.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.GetColorKey\n@sa SurfaceBase.SetRLE\n@sa SurfaceBase.HasColorKey",
                "name": "SetColorKey",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "key",
                    "type": "std::optional<Uint32>"
                  }
                ],
                "sourceName": "SDL_SetSurfaceColorKey"
              }
            ],
            "ClearColorKey": {
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "name": "ClearColorKey",
              "doc": ""
            },
            "HasColorKey": {
              "doc": "Returns whether the surface has a color key.\n\nIt is safe to pass a nullptr `surface` here; it will return false.\n\n@returns true if the surface has a color key, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.SetColorKey\n@sa SurfaceBase.GetColorKey",
              "name": "HasColorKey",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_SurfaceHasColorKey",
              "immutable": true
            },
            "GetColorKey": [
              {
                "kind": "function",
                "immutable": true,
                "type": "std::optional<Color>",
                "parameters": [],
                "name": "GetColorKey",
                "doc": ""
              },
              {
                "kind": "function",
                "immutable": true,
                "type": "bool",
                "parameters": [
                  {
                    "type": "Color *",
                    "name": "key"
                  }
                ],
                "name": "GetColorKey",
                "doc": ""
              },
              {
                "doc": "Get the color key (transparent pixel) for a surface.\n\nThe color key is a pixel of the format used by the surface, as generated by\nMapRGB().\n\nIf the surface doesn't have color key enabled this function returns false.\n\n@param key a pointer filled in with the transparent pixel.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.SetColorKey\n@sa SurfaceBase.HasColorKey",
                "name": "GetColorKey",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "key",
                    "type": "Uint32 *"
                  }
                ],
                "sourceName": "SDL_GetSurfaceColorKey",
                "immutable": true
              }
            ],
            "SetColorMod": {
              "doc": "Set an additional color value multiplied into blit operations.\n\nWhen this surface is blitted, during the blit operation each source color\nchannel is modulated by the appropriate color value according to the\nfollowing formula:\n\n`srcC = srcC * (color / 255)`\n\n@param r the red color value multiplied into blit operations.\n@param g the green color value multiplied into blit operations.\n@param b the blue color value multiplied into blit operations.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.GetColorMod\n@sa SurfaceBase.SetAlphaMod",
              "name": "SetColorMod",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "r",
                  "type": "Uint8"
                },
                {
                  "name": "g",
                  "type": "Uint8"
                },
                {
                  "name": "b",
                  "type": "Uint8"
                }
              ],
              "sourceName": "SDL_SetSurfaceColorMod"
            },
            "GetColorMod": {
              "doc": "Get the additional color value multiplied into blit operations.\n\n@param r a pointer filled in with the current red color value.\n@param g a pointer filled in with the current green color value.\n@param b a pointer filled in with the current blue color value.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.GetAlphaMod\n@sa SurfaceBase.SetColorMod",
              "name": "GetColorMod",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "r",
                  "type": "Uint8 *"
                },
                {
                  "name": "g",
                  "type": "Uint8 *"
                },
                {
                  "name": "b",
                  "type": "Uint8 *"
                }
              ],
              "sourceName": "SDL_GetSurfaceColorMod",
              "immutable": true
            },
            "SetAlphaMod": {
              "doc": "Set an additional alpha value used in blit operations.\n\nWhen this surface is blitted, during the blit operation the source alpha\nvalue is modulated by this alpha value according to the following formula:\n\n`srcA = srcA * (alpha / 255)`\n\n@param alpha the alpha value multiplied into blit operations.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.GetAlphaMod\n@sa SurfaceBase.SetColorMod",
              "name": "SetAlphaMod",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "alpha",
                  "type": "Uint8"
                }
              ],
              "sourceName": "SDL_SetSurfaceAlphaMod"
            },
            "GetAlphaMod": {
              "doc": "Get the additional alpha value used in blit operations.\n\n@param surface the SurfaceBase structure to query.\n@param alpha a pointer filled in with the current alpha value.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.GetColorMod\n@sa SurfaceBase.SetAlphaMod",
              "name": "GetAlphaMod",
              "kind": "function",
              "type": "std::optional<Uint8>",
              "parameters": [],
              "sourceName": "SDL_GetSurfaceAlphaMod",
              "immutable": true
            },
            "SetColorAndAlphaMod": {
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "type": "Color",
                  "name": "color"
                }
              ],
              "name": "SetColorAndAlphaMod",
              "doc": ""
            },
            "GetColorAndAlphaMod": {
              "kind": "function",
              "immutable": true,
              "type": "std::optional<Color>",
              "parameters": [],
              "name": "GetColorAndAlphaMod",
              "doc": ""
            },
            "SetBlendMode": {
              "doc": "Set the blend mode used for blit operations.\n\nTo copy a surface to another surface (or texture) without blending with the\nexisting data, the blendmode of the SOURCE surface should be set to\n`BLENDMODE_NONE`.\n\n@param blendMode the BlendMode to use for blit blending.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.GetBlendMode",
              "name": "SetBlendMode",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "blendMode",
                  "type": "BlendMode"
                }
              ],
              "sourceName": "SDL_SetSurfaceBlendMode"
            },
            "GetBlendMode": {
              "doc": "Get the blend mode used for blit operations.\n\n@param surface the SurfaceBase structure to query.\n@param blendMode a pointer filled in with the current BlendMode.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.SetBlendMode",
              "name": "GetBlendMode",
              "kind": "function",
              "type": "std::optional<BlendMode>",
              "parameters": [],
              "sourceName": "SDL_GetSurfaceBlendMode",
              "immutable": true
            },
            "SetClipRect": {
              "doc": "Set the clipping rectangle for a surface.\n\nWhen `surface` is the destination of a blit, only the area within the clip\nrectangle is drawn into.\n\nNote that blits are automatically clipped to the edges of the source and\ndestination surfaces.\n\n@param rect the Rect structure representing the clipping rectangle, or\n            nullptr to disable clipping.\n@returns true if the rectangle intersects the surface, otherwise false and\n         blits will be completely clipped.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.GetClipRect",
              "name": "SetClipRect",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "rect",
                  "type": "OptionalRef<const SDL_Rect>"
                }
              ],
              "sourceName": "SDL_SetSurfaceClipRect",
              "static": false
            },
            "ResetClipRect": {
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "name": "ResetClipRect",
              "doc": ""
            },
            "GetClipRect": {
              "doc": "Get the clipping rectangle for a surface.\n\nWhen `surface` is the destination of a blit, only the area within the clip\nrectangle is drawn into.\n\n@param surface the SurfaceBase structure representing the surface to be\n               clipped.\n@param rect an Rect structure filled in with the clipping rectangle for\n            the surface.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.SetClipRect",
              "name": "GetClipRect",
              "kind": "function",
              "type": "std::optional<Rect>",
              "parameters": [],
              "sourceName": "SDL_GetSurfaceClipRect",
              "immutable": true
            },
            "Flip": {
              "doc": "Flip a surface vertically or horizontally.\n\n@param flip the direction to flip.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "Flip",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "flip",
                  "type": "FlipMode"
                }
              ],
              "sourceName": "SDL_FlipSurface"
            },
            "Duplicate": {
              "doc": "Creates a new surface identical to the existing surface.\n\nIf the original surface has alternate images, the new surface will have a\nreference to them as well.\n\nThe returned surface should be freed with SurfaceBase.Destroy().\n\n@returns a copy of the surface or nullptr on failure; call GetError() for\n         more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.Destroy",
              "name": "Duplicate",
              "kind": "function",
              "type": "Surface",
              "parameters": [],
              "sourceName": "SDL_DuplicateSurface",
              "immutable": true
            },
            "Scale": {
              "doc": "Creates a new surface identical to the existing surface, scaled to the\ndesired size.\n\nThe returned surface should be freed with SurfaceBase.Destroy().\n\n@param width the width of the new surface.\n@param height the height of the new surface.\n@param scaleMode the ScaleMode to be used.\n@returns a copy of the surface or nullptr on failure; call GetError() for\n         more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.Destroy",
              "name": "Scale",
              "kind": "function",
              "type": "Surface",
              "parameters": [
                {
                  "name": "width",
                  "type": "int"
                },
                {
                  "name": "height",
                  "type": "int"
                },
                {
                  "name": "scaleMode",
                  "type": "ScaleMode"
                }
              ],
              "sourceName": "SDL_ScaleSurface",
              "immutable": true
            },
            "Convert": [
              {
                "doc": "Copy an existing surface to a new surface of the specified format.\n\nThis function is used to optimize images for faster *repeat* blitting. This\nis accomplished by converting the original and storing the result as a new\nsurface. The new, optimized surface can then be used as the source for\nfuture blits, making them faster.\n\nIf you are converting to an indexed surface and want to map colors to a\npalette, you can use SurfaceBase.Convert() instead.\n\nIf the original surface has alternate images, the new surface will have a\nreference to them as well.\n\n@param format the new pixel format.\n@returns the new SurfaceBase structure that is created or nullptr on failure;\n         call GetError() for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.Convert\n@sa SurfaceBase.Destroy",
                "name": "Convert",
                "kind": "function",
                "type": "Surface",
                "parameters": [
                  {
                    "name": "format",
                    "type": "PixelFormat"
                  }
                ],
                "sourceName": "SDL_ConvertSurface",
                "immutable": true
              },
              {
                "doc": "Copy an existing surface to a new surface of the specified format and\ncolorspace.\n\nThis function converts an existing surface to a new format and colorspace\nand returns the new surface. This will perform any pixel format and\ncolorspace conversion needed.\n\nIf the original surface has alternate images, the new surface will have a\nreference to them as well.\n\n@param format the new pixel format.\n@param palette an optional palette to use for indexed formats, may be nullptr.\n@param colorspace the new colorspace.\n@param props an PropertiesBase with additional color properties, or 0.\n@returns the new SurfaceBase structure that is created or nullptr on failure;\n         call GetError() for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.Convert\n@sa SurfaceBase.Destroy",
                "name": "Convert",
                "kind": "function",
                "type": "Surface",
                "parameters": [
                  {
                    "name": "format",
                    "type": "PixelFormat"
                  },
                  {
                    "name": "palette",
                    "type": "PaletteRef"
                  },
                  {
                    "name": "colorspace",
                    "type": "Colorspace"
                  },
                  {
                    "name": "props",
                    "type": "PropertiesRef"
                  }
                ],
                "sourceName": "SDL_ConvertSurfaceAndColorspace",
                "immutable": true
              }
            ],
            "PremultiplyAlpha": {
              "doc": "Premultiply the alpha in a surface.\n\nThis is safe to use with src == dst, but not for other overlapping areas.\n\n@param linear true to convert from sRGB to linear space for the alpha\n              multiplication, false to do multiplication in sRGB space.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "PremultiplyAlpha",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "linear",
                  "type": "bool"
                }
              ],
              "sourceName": "SDL_PremultiplySurfaceAlpha"
            },
            "Clear": {
              "doc": "Clear a surface with a specific color, with floating point precision.\n\nThis function handles all surface formats, and ignores any clip rectangle.\n\nIf the surface is YUV, the color is assumed to be in the sRGB colorspace,\notherwise the color is assumed to be in the colorspace of the suface.\n\n@param surface the SurfaceBase to clear.\n@param r the red component of the pixel, normally in the range 0-1.\n@param g the green component of the pixel, normally in the range 0-1.\n@param b the blue component of the pixel, normally in the range 0-1.\n@param a the alpha component of the pixel, normally in the range 0-1.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
              "name": "Clear",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "color",
                  "type": "SDL_FColor"
                }
              ],
              "sourceName": "SDL_ClearSurface",
              "static": false
            },
            "Fill": [
              {
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "type": "SDL_Color",
                    "name": "color"
                  }
                ],
                "name": "Fill",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "type": "Uint32",
                    "name": "color"
                  }
                ],
                "name": "Fill",
                "doc": ""
              }
            ],
            "FillRect": [
              {
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "type": "const SDL_Rect &",
                    "name": "rect"
                  },
                  {
                    "type": "SDL_Color",
                    "name": "color"
                  }
                ],
                "name": "FillRect",
                "doc": ""
              },
              {
                "doc": "Perform a fast fill of a rectangle with a specific color.\n\n`color` should be a pixel of the format used by the surface, and can be\ngenerated by MapRGB() or MapRGBA(). If the color value contains an\nalpha component then the destination is simply filled with that alpha\ninformation, no blending takes place.\n\nIf there is a clip rectangle set on the destination (set via\nSurfaceBase.SetClipRect()), then this function will fill based on the\nintersection of the clip rectangle and `rect`.\n\n@param rect the Rect structure representing the rectangle to fill, or\n            nullptr to fill the entire surface.\n@param color the color to fill with.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.FillRects",
                "name": "FillRect",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "rect",
                    "type": "const SDL_Rect &"
                  },
                  {
                    "name": "color",
                    "type": "Uint32"
                  }
                ],
                "sourceName": "SDL_FillSurfaceRect"
              }
            ],
            "FillRects": [
              {
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "type": "SpanRef<const SDL_Rect>",
                    "name": "rects"
                  },
                  {
                    "type": "SDL_Color",
                    "name": "color"
                  }
                ],
                "name": "FillRects",
                "doc": ""
              },
              {
                "doc": "Perform a fast fill of a set of rectangles with a specific color.\n\n`color` should be a pixel of the format used by the surface, and can be\ngenerated by MapRGB() or MapRGBA(). If the color value contains an\nalpha component then the destination is simply filled with that alpha\ninformation, no blending takes place.\n\nIf there is a clip rectangle set on the destination (set via\nSurfaceBase.SetClipRect()), then this function will fill based on the\nintersection of the clip rectangle and `rect`.\n\n@param rects an array of SDL_Rects representing the rectangles to fill.\n@param count the number of rectangles in the array.\n@param color the color to fill with.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.FillRect",
                "name": "FillRects",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "rects",
                    "type": "SpanRef<const SDL_Rect>"
                  },
                  {
                    "name": "color",
                    "type": "Uint32"
                  }
                ],
                "sourceName": "SDL_FillSurfaceRects"
              }
            ],
            "Blit": [
              {
                "kind": "function",
                "name": "Blit",
                "parameters": [
                  {
                    "type": "SurfaceRef",
                    "name": "src"
                  },
                  {
                    "type": "OptionalRef<const SDL_Rect>",
                    "name": "srcrect"
                  },
                  {
                    "type": "const SDL_Point &",
                    "name": "dstpos"
                  }
                ],
                "doc": ""
              },
              {
                "doc": "Performs a fast blit from the source surface to the destination surface\nwith clipping.\n\nIf either `srcrect` or `dstrect` are nullptr, the entire surface (`src` or\n`dst`) is copied while ensuring clipping to `dst->clip_rect`.\n\nThe final blit rectangles are saved in `srcrect` and `dstrect` after all\nclipping is performed.\n\nThe blit function should not be called on a locked surface.\n\nThe blit semantics for surfaces with and without blending and colorkey are\ndefined as follows:\n\n```\n   RGBA->RGB:\n     Source surface blend mode set to BLENDMODE_BLEND:\n      alpha-blend (using the source alpha-channel and per-surface alpha)\n      SDL_SRCCOLORKEY ignored.\n    Source surface blend mode set to BLENDMODE_NONE:\n      copy RGB.\n      if SDL_SRCCOLORKEY set, only copy the pixels that do not match the\n      RGB values of the source color key, ignoring alpha in the\n      comparison.\n\n  RGB->RGBA:\n    Source surface blend mode set to BLENDMODE_BLEND:\n      alpha-blend (using the source per-surface alpha)\n    Source surface blend mode set to BLENDMODE_NONE:\n      copy RGB, set destination alpha to source per-surface alpha value.\n    both:\n      if SDL_SRCCOLORKEY set, only copy the pixels that do not match the\n      source color key.\n\n  RGBA->RGBA:\n    Source surface blend mode set to BLENDMODE_BLEND:\n      alpha-blend (using the source alpha-channel and per-surface alpha)\n      SDL_SRCCOLORKEY ignored.\n    Source surface blend mode set to BLENDMODE_NONE:\n      copy all of RGBA to the destination.\n      if SDL_SRCCOLORKEY set, only copy the pixels that do not match the\n      RGB values of the source color key, ignoring alpha in the\n      comparison.\n\n  RGB->RGB:\n    Source surface blend mode set to BLENDMODE_BLEND:\n      alpha-blend (using the source per-surface alpha)\n    Source surface blend mode set to BLENDMODE_NONE:\n      copy RGB.\n    both:\n      if SDL_SRCCOLORKEY set, only copy the pixels that do not match the\n      source color key.\n```\n\n@param srcrect the Rect structure representing the rectangle to be\n               copied, or nullptr to copy the entire surface.\n@param dst the SurfaceBase structure that is the blit target.\n@param dstrect the Rect structure representing the x and y position in\n               the destination surface, or nullptr for (0,0). The width and\n               height are ignored, and are copied from `srcrect`. If you\n               want a specific width and height, you should use\n               SurfaceBase.BlitScaled().\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety Only one thread should be using the `src` and `dst` surfaces\n              at any given time.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.BlitScaled",
                "name": "Blit",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "src",
                    "type": "SurfaceRef"
                  },
                  {
                    "name": "srcrect",
                    "type": "OptionalRef<const SDL_Rect>"
                  },
                  {
                    "name": "dstrect",
                    "type": "OptionalRef<const SDL_Rect>"
                  }
                ],
                "sourceName": "SDL_BlitSurface"
              }
            ],
            "BlitUnchecked": {
              "doc": "Perform low-level surface blitting only.\n\nThis is a semi-private blit function and it performs low-level surface\nblitting, assuming the input rectangles have already been clipped.\n\n@param srcrect the Rect structure representing the rectangle to be\n               copied, may not be nullptr.\n@param dst the SurfaceBase structure that is the blit target.\n@param dstrect the Rect structure representing the target rectangle in\n               the destination surface, may not be nullptr.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety Only one thread should be using the `src` and `dst` surfaces\n              at any given time.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.Blit",
              "name": "BlitUnchecked",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "src",
                  "type": "SurfaceRef"
                },
                {
                  "name": "srcrect",
                  "type": "const SDL_Rect &"
                },
                {
                  "name": "dstrect",
                  "type": "const SDL_Rect &"
                }
              ],
              "sourceName": "SDL_BlitSurfaceUnchecked"
            },
            "BlitScaled": {
              "doc": "Perform a scaled blit to a destination surface, which may be of a different\nformat.\n\n@param srcrect the Rect structure representing the rectangle to be\n               copied, or nullptr to copy the entire surface.\n@param dst the SurfaceBase structure that is the blit target.\n@param dstrect the Rect structure representing the target rectangle in\n               the destination surface, or nullptr to fill the entire\n               destination surface.\n@param scaleMode the ScaleMode to be used.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety Only one thread should be using the `src` and `dst` surfaces\n              at any given time.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.Blit",
              "name": "BlitScaled",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "src",
                  "type": "SurfaceRef"
                },
                {
                  "name": "srcrect",
                  "type": "OptionalRef<const SDL_Rect>"
                },
                {
                  "name": "dstrect",
                  "type": "OptionalRef<const SDL_Rect>"
                },
                {
                  "name": "scaleMode",
                  "type": "ScaleMode"
                }
              ],
              "sourceName": "SDL_BlitSurfaceScaled"
            },
            "BlitUncheckedScaled": {
              "doc": "Perform low-level surface scaled blitting only.\n\nThis is a semi-private function and it performs low-level surface blitting,\nassuming the input rectangles have already been clipped.\n\n@param srcrect the Rect structure representing the rectangle to be\n               copied, may not be nullptr.\n@param dst the SurfaceBase structure that is the blit target.\n@param dstrect the Rect structure representing the target rectangle in\n               the destination surface, may not be nullptr.\n@param scaleMode the ScaleMode to be used.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety Only one thread should be using the `src` and `dst` surfaces\n              at any given time.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.BlitScaled",
              "name": "BlitUncheckedScaled",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "src",
                  "type": "SurfaceRef"
                },
                {
                  "name": "srcrect",
                  "type": "const SDL_Rect &"
                },
                {
                  "name": "dstrect",
                  "type": "const SDL_Rect &"
                },
                {
                  "name": "scaleMode",
                  "type": "ScaleMode"
                }
              ],
              "sourceName": "SDL_BlitSurfaceUncheckedScaled"
            },
            "Stretch": {
              "doc": "Perform a stretched pixel copy from one surface to another.\n\n@param srcrect the Rect structure representing the rectangle to be\n               copied, may not be nullptr.\n@param dst the SurfaceBase structure that is the blit target.\n@param dstrect the Rect structure representing the target rectangle in\n               the destination surface, may not be nullptr.\n@param scaleMode the ScaleMode to be used.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety Only one thread should be using the `src` and `dst` surfaces\n              at any given time.\n\n@since This function is available since SDL 3.4.0.\n\n@sa SurfaceBase.BlitScaled",
              "name": "Stretch",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "src",
                  "type": "SurfaceRef"
                },
                {
                  "name": "srcrect",
                  "type": "const SDL_Rect &"
                },
                {
                  "name": "dstrect",
                  "type": "const SDL_Rect &"
                },
                {
                  "name": "scaleMode",
                  "type": "ScaleMode"
                }
              ],
              "sourceName": "SDL_StretchSurface"
            },
            "BlitTiled": {
              "doc": "Perform a tiled blit to a destination surface, which may be of a different\nformat.\n\nThe pixels in `srcrect` will be repeated as many times as needed to\ncompletely fill `dstrect`.\n\n@param srcrect the Rect structure representing the rectangle to be\n               copied, or nullptr to copy the entire surface.\n@param dst the SurfaceBase structure that is the blit target.\n@param dstrect the Rect structure representing the target rectangle in\n               the destination surface, or nullptr to fill the entire surface.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety Only one thread should be using the `src` and `dst` surfaces\n              at any given time.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.Blit",
              "name": "BlitTiled",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "src",
                  "type": "SurfaceRef"
                },
                {
                  "name": "srcrect",
                  "type": "OptionalRef<const SDL_Rect>"
                },
                {
                  "name": "dstrect",
                  "type": "OptionalRef<const SDL_Rect>"
                }
              ],
              "sourceName": "SDL_BlitSurfaceTiled"
            },
            "BlitTiledWithScale": {
              "doc": "Perform a scaled and tiled blit to a destination surface, which may be of a\ndifferent format.\n\nThe pixels in `srcrect` will be scaled and repeated as many times as needed\nto completely fill `dstrect`.\n\n@param srcrect the Rect structure representing the rectangle to be\n               copied, or nullptr to copy the entire surface.\n@param scale the scale used to transform srcrect into the destination\n             rectangle, e.g. a 32x32 texture with a scale of 2 would fill\n             64x64 tiles.\n@param scaleMode scale algorithm to be used.\n@param dst the SurfaceBase structure that is the blit target.\n@param dstrect the Rect structure representing the target rectangle in\n               the destination surface, or nullptr to fill the entire surface.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety Only one thread should be using the `src` and `dst` surfaces\n              at any given time.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.Blit",
              "name": "BlitTiledWithScale",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "src",
                  "type": "SurfaceRef"
                },
                {
                  "name": "srcrect",
                  "type": "OptionalRef<const SDL_Rect>"
                },
                {
                  "name": "scale",
                  "type": "float"
                },
                {
                  "name": "scaleMode",
                  "type": "SDL_ScaleMode"
                },
                {
                  "name": "dstrect",
                  "type": "OptionalRef<const SDL_Rect>"
                }
              ],
              "sourceName": "SDL_BlitSurfaceTiledWithScale"
            },
            "Blit9Grid": {
              "kind": "function",
              "name": "Blit9Grid",
              "type": "bool",
              "parameters": [
                {
                  "type": "SurfaceRef",
                  "name": "src"
                },
                {
                  "type": "OptionalRef<const SDL_Rect>",
                  "name": "srcrect"
                },
                {
                  "type": "int",
                  "name": "left_width"
                },
                {
                  "type": "int",
                  "name": "right_width"
                },
                {
                  "type": "int",
                  "name": "top_height"
                },
                {
                  "type": "int",
                  "name": "bottom_height"
                },
                {
                  "type": "OptionalRef<const SDL_Rect>",
                  "name": "dstrect"
                }
              ],
              "doc": ""
            },
            "Blit9GridWithScale": {
              "doc": "Perform a scaled blit using the 9-grid algorithm to a destination surface,\nwhich may be of a different format.\n\nThe pixels in the source surface are split into a 3x3 grid, using the\ndifferent corner sizes for each corner, and the sides and center making up\nthe remaining pixels. The corners are then scaled using `scale` and fit\ninto the corners of the destination rectangle. The sides and center are\nthen stretched into place to cover the remaining destination rectangle.\n\n@param srcrect the Rect structure representing the rectangle to be used\n               for the 9-grid, or nullptr to use the entire surface.\n@param left_width the width, in pixels, of the left corners in `srcrect`.\n@param right_width the width, in pixels, of the right corners in `srcrect`.\n@param top_height the height, in pixels, of the top corners in `srcrect`.\n@param bottom_height the height, in pixels, of the bottom corners in\n                     `srcrect`.\n@param scale the scale used to transform the corner of `srcrect` into the\n             corner of `dstrect`, or 0.0f for an unscaled blit.\n@param scaleMode scale algorithm to be used.\n@param dst the SurfaceBase structure that is the blit target.\n@param dstrect the Rect structure representing the target rectangle in\n               the destination surface, or nullptr to fill the entire surface.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety Only one thread should be using the `src` and `dst` surfaces\n              at any given time.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.Blit",
              "name": "Blit9GridWithScale",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "src",
                  "type": "SurfaceRef"
                },
                {
                  "name": "srcrect",
                  "type": "OptionalRef<const SDL_Rect>"
                },
                {
                  "name": "left_width",
                  "type": "int"
                },
                {
                  "name": "right_width",
                  "type": "int"
                },
                {
                  "name": "top_height",
                  "type": "int"
                },
                {
                  "name": "bottom_height",
                  "type": "int"
                },
                {
                  "name": "scale",
                  "type": "float"
                },
                {
                  "name": "scaleMode",
                  "type": "SDL_ScaleMode"
                },
                {
                  "name": "dstrect",
                  "type": "OptionalRef<const SDL_Rect>"
                }
              ],
              "sourceName": "SDL_BlitSurface9Grid"
            },
            "MapColor": [
              {
                "kind": "function",
                "type": "Uint32",
                "immutable": true,
                "parameters": [
                  {
                    "type": "SDL_Color",
                    "name": "color"
                  }
                ],
                "name": "MapColor",
                "doc": ""
              },
              {
                "doc": "Map an RGB triple to an opaque pixel value for a surface.\n\nThis function maps the RGB color value to the specified pixel format and\nreturns the pixel value best approximating the given RGB color value for\nthe given pixel format.\n\nIf the surface has a palette, the index of the closest matching color in\nthe palette will be returned.\n\nIf the surface pixel format has an alpha component it will be returned as\nall 1 bits (fully opaque).\n\nIf the pixel format bpp (color depth) is less than 32-bpp then the unused\nupper bits of the return value can safely be ignored (e.g., with a 16-bpp\nformat the return value can be assigned to a Uint16, and similarly a Uint8\nfor an 8-bpp format).\n\n@param r the red component of the pixel in the range 0-255.\n@param g the green component of the pixel in the range 0-255.\n@param b the blue component of the pixel in the range 0-255.\n@returns a pixel value.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.MapColor",
                "name": "MapColor",
                "kind": "function",
                "type": "Uint32",
                "parameters": [
                  {
                    "name": "r",
                    "type": "Uint8"
                  },
                  {
                    "name": "g",
                    "type": "Uint8"
                  },
                  {
                    "name": "b",
                    "type": "Uint8"
                  }
                ],
                "sourceName": "SDL_MapSurfaceRGB",
                "immutable": true
              },
              {
                "doc": "Map an RGBA quadruple to a pixel value for a surface.\n\nThis function maps the RGBA color value to the specified pixel format and\nreturns the pixel value best approximating the given RGBA color value for\nthe given pixel format.\n\nIf the surface pixel format has no alpha component the alpha value will be\nignored (as it will be in formats with a palette).\n\nIf the surface has a palette, the index of the closest matching color in\nthe palette will be returned.\n\nIf the pixel format bpp (color depth) is less than 32-bpp then the unused\nupper bits of the return value can safely be ignored (e.g., with a 16-bpp\nformat the return value can be assigned to a Uint16, and similarly a Uint8\nfor an 8-bpp format).\n\n@param r the red component of the pixel in the range 0-255.\n@param g the green component of the pixel in the range 0-255.\n@param b the blue component of the pixel in the range 0-255.\n@param a the alpha component of the pixel in the range 0-255.\n@returns a pixel value.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.MapColor",
                "name": "MapColor",
                "kind": "function",
                "type": "Uint32",
                "parameters": [
                  {
                    "name": "r",
                    "type": "Uint8"
                  },
                  {
                    "name": "g",
                    "type": "Uint8"
                  },
                  {
                    "name": "b",
                    "type": "Uint8"
                  },
                  {
                    "name": "a",
                    "type": "Uint8"
                  }
                ],
                "sourceName": "SDL_MapSurfaceRGBA",
                "immutable": true
              }
            ],
            "ReadPixel": [
              {
                "kind": "function",
                "name": "ReadPixel",
                "immutable": true,
                "type": "std::optional<Color>",
                "parameters": [
                  {
                    "type": "int",
                    "name": "x"
                  },
                  {
                    "type": "int",
                    "name": "y"
                  }
                ],
                "doc": ""
              },
              {
                "kind": "function",
                "name": "ReadPixel",
                "immutable": true,
                "type": "bool",
                "parameters": [
                  {
                    "type": "int",
                    "name": "x"
                  },
                  {
                    "type": "int",
                    "name": "y"
                  },
                  {
                    "type": "SDL_Color *",
                    "name": "c"
                  }
                ],
                "doc": ""
              },
              {
                "kind": "function",
                "name": "ReadPixel",
                "immutable": true,
                "type": "bool",
                "parameters": [
                  {
                    "type": "int",
                    "name": "x"
                  },
                  {
                    "type": "int",
                    "name": "y"
                  },
                  {
                    "type": "SDL_FColor *",
                    "name": "c"
                  }
                ],
                "doc": ""
              },
              {
                "doc": "Retrieves a single pixel from a surface.\n\nThis function prioritizes correctness over speed: it is suitable for unit\ntests, but is not intended for use in a game engine.\n\nLike GetRGBA, this uses the entire 0..255 range when converting color\ncomponents from pixel formats with less than 8 bits per RGB component.\n\n@param x the horizontal coordinate, 0 <= x < width.\n@param y the vertical coordinate, 0 <= y < height.\n@param r a pointer filled in with the red channel, 0-255, or nullptr to ignore\n         this channel.\n@param g a pointer filled in with the green channel, 0-255, or nullptr to\n         ignore this channel.\n@param b a pointer filled in with the blue channel, 0-255, or nullptr to\n         ignore this channel.\n@param a a pointer filled in with the alpha channel, 0-255, or nullptr to\n         ignore this channel.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
                "name": "ReadPixel",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "x",
                    "type": "int"
                  },
                  {
                    "name": "y",
                    "type": "int"
                  },
                  {
                    "name": "r",
                    "type": "Uint8 *"
                  },
                  {
                    "name": "g",
                    "type": "Uint8 *"
                  },
                  {
                    "name": "b",
                    "type": "Uint8 *"
                  },
                  {
                    "name": "a",
                    "type": "Uint8 *"
                  }
                ],
                "sourceName": "SDL_ReadSurfacePixel",
                "immutable": true
              },
              {
                "doc": "Retrieves a single pixel from a surface.\n\nThis function prioritizes correctness over speed: it is suitable for unit\ntests, but is not intended for use in a game engine.\n\n@param x the horizontal coordinate, 0 <= x < width.\n@param y the vertical coordinate, 0 <= y < height.\n@param r a pointer filled in with the red channel, normally in the range\n         0-1, or nullptr to ignore this channel.\n@param g a pointer filled in with the green channel, normally in the range\n         0-1, or nullptr to ignore this channel.\n@param b a pointer filled in with the blue channel, normally in the range\n         0-1, or nullptr to ignore this channel.\n@param a a pointer filled in with the alpha channel, normally in the range\n         0-1, or nullptr to ignore this channel.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
                "name": "ReadPixel",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "x",
                    "type": "int"
                  },
                  {
                    "name": "y",
                    "type": "int"
                  },
                  {
                    "name": "r",
                    "type": "float *"
                  },
                  {
                    "name": "g",
                    "type": "float *"
                  },
                  {
                    "name": "b",
                    "type": "float *"
                  },
                  {
                    "name": "a",
                    "type": "float *"
                  }
                ],
                "sourceName": "SDL_ReadSurfacePixelFloat",
                "immutable": true
              }
            ],
            "WritePixel": [
              {
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "type": "int",
                    "name": "x"
                  },
                  {
                    "type": "int",
                    "name": "y"
                  },
                  {
                    "type": "SDL_Color",
                    "name": "c"
                  }
                ],
                "name": "WritePixel",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "type": "int",
                    "name": "x"
                  },
                  {
                    "type": "int",
                    "name": "y"
                  },
                  {
                    "type": "SDL_FColor",
                    "name": "c"
                  }
                ],
                "name": "WritePixel",
                "doc": ""
              },
              {
                "doc": "Writes a single pixel to a surface.\n\nThis function prioritizes correctness over speed: it is suitable for unit\ntests, but is not intended for use in a game engine.\n\nLike MapRGBA, this uses the entire 0..255 range when converting color\ncomponents from pixel formats with less than 8 bits per RGB component.\n\n@param x the horizontal coordinate, 0 <= x < width.\n@param y the vertical coordinate, 0 <= y < height.\n@param r the red channel value, 0-255.\n@param g the green channel value, 0-255.\n@param b the blue channel value, 0-255.\n@param a the alpha channel value, 0-255.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
                "name": "WritePixel",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "x",
                    "type": "int"
                  },
                  {
                    "name": "y",
                    "type": "int"
                  },
                  {
                    "name": "r",
                    "type": "Uint8"
                  },
                  {
                    "name": "g",
                    "type": "Uint8"
                  },
                  {
                    "name": "b",
                    "type": "Uint8"
                  },
                  {
                    "name": "a",
                    "type": "Uint8"
                  }
                ],
                "sourceName": "SDL_WriteSurfacePixel"
              },
              {
                "doc": "Writes a single pixel to a surface.\n\nThis function prioritizes correctness over speed: it is suitable for unit\ntests, but is not intended for use in a game engine.\n\n@param x the horizontal coordinate, 0 <= x < width.\n@param y the vertical coordinate, 0 <= y < height.\n@param r the red channel value, normally in the range 0-1.\n@param g the green channel value, normally in the range 0-1.\n@param b the blue channel value, normally in the range 0-1.\n@param a the alpha channel value, normally in the range 0-1.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.",
                "name": "WritePixel",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "x",
                    "type": "int"
                  },
                  {
                    "name": "y",
                    "type": "int"
                  },
                  {
                    "name": "r",
                    "type": "float"
                  },
                  {
                    "name": "g",
                    "type": "float"
                  },
                  {
                    "name": "b",
                    "type": "float"
                  },
                  {
                    "name": "a",
                    "type": "float"
                  }
                ],
                "sourceName": "SDL_WriteSurfacePixelFloat"
              }
            ],
            "GetWidth": {
              "kind": "function",
              "immutable": true,
              "type": "int",
              "parameters": [],
              "name": "GetWidth",
              "doc": ""
            },
            "GetHeight": {
              "kind": "function",
              "immutable": true,
              "type": "int",
              "parameters": [],
              "name": "GetHeight",
              "doc": ""
            },
            "GetSize": {
              "kind": "function",
              "immutable": true,
              "type": "Point",
              "parameters": [],
              "name": "GetSize",
              "doc": ""
            },
            "GetFormat": {
              "kind": "function",
              "immutable": true,
              "type": "PixelFormat",
              "parameters": [],
              "name": "GetFormat",
              "doc": ""
            },
            "Destroy": {
              "doc": "Free a surface.\n\nIt is safe to pass nullptr to this function.\n\n\n@threadsafety No other thread should be using the surface when it is freed.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.SurfaceBase\n@sa SurfaceBase.SurfaceBase",
              "name": "Destroy",
              "kind": "function",
              "type": "void",
              "parameters": [],
              "sourceName": "SDL_DestroySurface"
            }
          }
        },
        "ObjectRef<SDL_Surface>::doFree": {
          "name": "ObjectRef<SDL_Surface>::doFree",
          "type": "void",
          "kind": "function",
          "doc": "Callback for surface resource cleanup\n\n@private",
          "template": [],
          "parameters": [
            {
              "type": "SDL_Surface *",
              "name": "resource"
            }
          ],
          "sourceName": "SDL_DestroySurface"
        },
        "SurfaceLock": {
          "name": "SurfaceLock",
          "kind": "struct",
          "entries": {
            "surface": {
              "kind": "var",
              "type": "SurfaceRef",
              "name": "surface",
              "doc": ""
            },
            "SurfaceLock": [
              {
                "doc": "@sa SurfaceBase.Lock()",
                "kind": "function",
                "type": "",
                "explicit": true,
                "parameters": [
                  {
                    "name": "surface",
                    "type": "SurfaceRef"
                  }
                ],
                "name": "SurfaceLock"
              },
              {
                "kind": "function",
                "type": "",
                "parameters": [],
                "name": "SurfaceLock",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "type": "const SurfaceLock &",
                    "name": "other"
                  }
                ],
                "name": "SurfaceLock",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "type": "SurfaceLock &&",
                    "name": "other"
                  }
                ],
                "name": "SurfaceLock",
                "doc": ""
              }
            ],
            "~SurfaceLock": {
              "kind": "function",
              "doc": "@sa Unlock()",
              "type": "",
              "parameters": [],
              "name": "~SurfaceLock"
            },
            "operator=": {
              "kind": "function",
              "type": "SurfaceLock &",
              "parameters": [
                {
                  "type": "SurfaceLock",
                  "name": "other"
                }
              ],
              "name": "operator=",
              "doc": ""
            },
            "operator bool": {
              "kind": "function",
              "type": "",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "name": "operator bool",
              "doc": ""
            },
            "Unlock": {
              "doc": "Release a surface after directly accessing the pixels.\n\n@param surface the SurfaceBase structure to be unlocked.\n\n@threadsafety This function is not thread safe. The locking referred to by\n              this function is making the pixels available for direct\n              access, not thread-safe locking.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.Lock",
              "name": "Unlock",
              "kind": "function",
              "type": "void",
              "parameters": [],
              "sourceName": "SDL_UnlockSurface"
            },
            "GetPixels": {
              "kind": "function",
              "type": "void *",
              "immutable": true,
              "parameters": [],
              "name": "GetPixels",
              "doc": ""
            },
            "GetPitch": {
              "kind": "function",
              "type": "int",
              "immutable": true,
              "parameters": [],
              "name": "GetPitch",
              "doc": ""
            },
            "GetFormat": {
              "kind": "function",
              "type": "PixelFormat",
              "immutable": true,
              "parameters": [],
              "name": "GetFormat",
              "doc": ""
            }
          },
          "doc": ""
        },
        "prop::Surface": {
          "kind": "ns",
          "name": "prop::Surface",
          "entries": {
            "SDR_WHITE_POINT_FLOAT": {
              "doc": "",
              "name": "SDR_WHITE_POINT_FLOAT",
              "kind": "var",
              "value": "\"SDL.surface.SDR_white_point\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_SURFACE_SDR_WHITE_POINT_FLOAT"
            },
            "HDR_HEADROOM_FLOAT": {
              "doc": "",
              "name": "HDR_HEADROOM_FLOAT",
              "kind": "var",
              "value": "\"SDL.surface.HDR_headroom\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_SURFACE_HDR_HEADROOM_FLOAT"
            },
            "TONEMAP_OPERATOR_STRING": {
              "doc": "",
              "name": "TONEMAP_OPERATOR_STRING",
              "kind": "var",
              "value": "\"SDL.surface.tonemap\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_SURFACE_TONEMAP_OPERATOR_STRING"
            },
            "HOTSPOT_X_NUMBER": {
              "doc": "",
              "name": "HOTSPOT_X_NUMBER",
              "kind": "var",
              "value": "\"SDL.surface.hotspot.x\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_SURFACE_HOTSPOT_X_NUMBER"
            },
            "HOTSPOT_Y_NUMBER": {
              "doc": "",
              "name": "HOTSPOT_Y_NUMBER",
              "kind": "var",
              "value": "\"SDL.surface.hotspot.y\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_SURFACE_HOTSPOT_Y_NUMBER"
            }
          },
          "doc": ""
        },
        "LoadBMP": [
          {
            "doc": "Load a BMP image from a seekable SDL data stream.\n\nThe new surface should be freed with SurfaceBase.Destroy(). Not doing so\nwill result in a memory leak.\n\n@param src the data stream for the surface.\n@param closeio if true, calls IOStreamBase.Close() on `src` before returning, even\n               in the case of an error.\n@returns a pointer to a new SurfaceBase structure or nullptr on failure; call\n         GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.Destroy\n@sa LoadBMP\n@sa SaveBMP",
            "name": "LoadBMP",
            "kind": "function",
            "type": "Surface",
            "parameters": [
              {
                "name": "src",
                "type": "ObjectBox<SDL_IOStream> auto &&"
              }
            ],
            "sourceName": "SDL_LoadBMP_IO"
          },
          {
            "doc": "Load a BMP image from a file.\n\nThe new surface should be freed with SurfaceBase.Destroy(). Not doing so\nwill result in a memory leak.\n\n@param file the BMP file to load.\n@returns a pointer to a new SurfaceBase structure or nullptr on failure; call\n         GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SurfaceBase.Destroy\n@sa LoadBMP\n@sa SaveBMP",
            "name": "LoadBMP",
            "kind": "function",
            "type": "Surface",
            "parameters": [
              {
                "name": "file",
                "type": "StringParam"
              }
            ],
            "sourceName": "SDL_LoadBMP"
          }
        ],
        "SaveBMP": [
          {
            "doc": "Save a surface to a seekable SDL data stream in BMP format.\n\nSurfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the\nBMP directly. Other RGB formats with 8-bit or higher get converted to a\n24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit\nsurface before they are saved. YUV and paletted 1-bit and 4-bit formats are\nnot supported.\n\n@param surface the SurfaceBase structure containing the image to be saved.\n@param dst a data stream to save to.\n@param closeio if true, calls IOStreamBase.Close() on `dst` before returning, even\n               in the case of an error.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa LoadBMP\n@sa SaveBMP",
            "name": "SaveBMP",
            "kind": "function",
            "type": "bool",
            "parameters": [
              {
                "name": "surface",
                "type": "SurfaceRef"
              },
              {
                "name": "dst",
                "type": "ObjectBox<SDL_IOStream> auto &&"
              }
            ],
            "sourceName": "SDL_SaveBMP_IO"
          },
          {
            "doc": "Save a surface to a file.\n\nSurfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the\nBMP directly. Other RGB formats with 8-bit or higher get converted to a\n24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit\nsurface before they are saved. YUV and paletted 1-bit and 4-bit formats are\nnot supported.\n\n@param surface the SurfaceBase structure containing the image to be saved.\n@param file a file to save to.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa LoadBMP\n@sa SaveBMP",
            "name": "SaveBMP",
            "kind": "function",
            "type": "bool",
            "parameters": [
              {
                "name": "surface",
                "type": "SurfaceRef"
              },
              {
                "name": "file",
                "type": "StringParam"
              }
            ],
            "sourceName": "SDL_SaveBMP"
          }
        ],
        "ConvertPixels": {
          "doc": "Copy a block of pixels of one format to another format.\n\n@param width the width of the block to copy, in pixels.\n@param height the height of the block to copy, in pixels.\n@param src_format an PixelFormat value of the `src` pixels format.\n@param src a pointer to the source pixels.\n@param src_pitch the pitch of the source pixels, in bytes.\n@param dst_format an PixelFormat value of the `dst` pixels format.\n@param dst a pointer to be filled in with new pixel data.\n@param dst_pitch the pitch of the destination pixels, in bytes.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety The same destination pixels should not be used from two\n              threads at once. It is safe to use the same source pixels\n              from multiple threads.\n\n@since This function is available since SDL 3.2.0.\n\n@sa ConvertPixelsAndColorspace",
          "name": "ConvertPixels",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "width",
              "type": "int"
            },
            {
              "name": "height",
              "type": "int"
            },
            {
              "name": "src_format",
              "type": "PixelFormat"
            },
            {
              "name": "src",
              "type": "const void *"
            },
            {
              "name": "src_pitch",
              "type": "int"
            },
            {
              "name": "dst_format",
              "type": "PixelFormat"
            },
            {
              "name": "dst",
              "type": "void *"
            },
            {
              "name": "dst_pitch",
              "type": "int"
            }
          ],
          "sourceName": "SDL_ConvertPixels"
        },
        "ConvertPixelsAndColorspace": {
          "doc": "Copy a block of pixels of one format and colorspace to another format and\ncolorspace.\n\n@param width the width of the block to copy, in pixels.\n@param height the height of the block to copy, in pixels.\n@param src_format an PixelFormat value of the `src` pixels format.\n@param src_colorspace an Colorspace value describing the colorspace of\n                      the `src` pixels.\n@param src_properties an PropertiesBase with additional source color\n                      properties, or 0.\n@param src a pointer to the source pixels.\n@param src_pitch the pitch of the source pixels, in bytes.\n@param dst_format an PixelFormat value of the `dst` pixels format.\n@param dst_colorspace an Colorspace value describing the colorspace of\n                      the `dst` pixels.\n@param dst_properties an PropertiesBase with additional destination color\n                      properties, or 0.\n@param dst a pointer to be filled in with new pixel data.\n@param dst_pitch the pitch of the destination pixels, in bytes.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety The same destination pixels should not be used from two\n              threads at once. It is safe to use the same source pixels\n              from multiple threads.\n\n@since This function is available since SDL 3.2.0.\n\n@sa ConvertPixels",
          "name": "ConvertPixelsAndColorspace",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "width",
              "type": "int"
            },
            {
              "name": "height",
              "type": "int"
            },
            {
              "name": "src_format",
              "type": "PixelFormat"
            },
            {
              "name": "src_colorspace",
              "type": "Colorspace"
            },
            {
              "name": "src_properties",
              "type": "PropertiesRef"
            },
            {
              "name": "src",
              "type": "const void *"
            },
            {
              "name": "src_pitch",
              "type": "int"
            },
            {
              "name": "dst_format",
              "type": "PixelFormat"
            },
            {
              "name": "dst_colorspace",
              "type": "Colorspace"
            },
            {
              "name": "dst_properties",
              "type": "PropertiesRef"
            },
            {
              "name": "dst",
              "type": "void *"
            },
            {
              "name": "dst_pitch",
              "type": "int"
            }
          ],
          "sourceName": "SDL_ConvertPixelsAndColorspace"
        },
        "PremultiplyAlpha": {
          "doc": "Premultiply the alpha on a block of pixels.\n\nThis is safe to use with src == dst, but not for other overlapping areas.\n\n@param width the width of the block to convert, in pixels.\n@param height the height of the block to convert, in pixels.\n@param src_format an PixelFormat value of the `src` pixels format.\n@param src a pointer to the source pixels.\n@param src_pitch the pitch of the source pixels, in bytes.\n@param dst_format an PixelFormat value of the `dst` pixels format.\n@param dst a pointer to be filled in with premultiplied pixel data.\n@param dst_pitch the pitch of the destination pixels, in bytes.\n@param linear true to convert from sRGB to linear space for the alpha\n              multiplication, false to do multiplication in sRGB space.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety The same destination pixels should not be used from two\n              threads at once. It is safe to use the same source pixels\n              from multiple threads.\n\n@since This function is available since SDL 3.2.0.",
          "name": "PremultiplyAlpha",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "width",
              "type": "int"
            },
            {
              "name": "height",
              "type": "int"
            },
            {
              "name": "src_format",
              "type": "PixelFormat"
            },
            {
              "name": "src",
              "type": "const void *"
            },
            {
              "name": "src_pitch",
              "type": "int"
            },
            {
              "name": "dst_format",
              "type": "PixelFormat"
            },
            {
              "name": "dst",
              "type": "void *"
            },
            {
              "name": "dst_pitch",
              "type": "int"
            },
            {
              "name": "linear",
              "type": "bool"
            }
          ],
          "sourceName": "SDL_PremultiplyAlpha"
        }
      }
    },
    "SDL3pp_video.h": {
      "name": "SDL3pp_video.h",
      "doc": "@defgroup CategoryVideo Category Video\n\nSDL's video subsystem is largely interested in abstracting window\nmanagement from the underlying operating system. You can create windows,\nmanage them in various ways, set them fullscreen, and get events when\ninteresting things happen with them, such as the mouse or keyboard\ninteracting with a window.\n\nThe video subsystem is also interested in abstracting away some\nplatform-specific differences in OpenGL: context creation, swapping\nbuffers, etc. This may be crucial to your app, but also you are not\nrequired to use OpenGL at all. In fact, SDL can provide rendering to those\nwindows as well, either with an easy-to-use\n[2D API](https://wiki.libsdl.org/SDL3/CategoryRender)\nor with a more-powerful\n[GPU API](https://wiki.libsdl.org/SDL3/CategoryGPU)\n. Of course, it can simply get out of your way and give you the window\nhandles you need to use Vulkan, Direct3D, Metal, or whatever else you like\ndirectly, too.\n\nThe video subsystem covers a lot of functionality, out of necessity, so it\nis worth perusing the list of functions just to see what's available, but\nmost apps can get by with simply creating a window and listening for\nevents, so start with WindowBase.WindowBase() and PollEvent().",
      "entries": {
        "WindowBase-forward": {
          "name": "WindowBase",
          "kind": "forward",
          "template": [
            {
              "type": "ObjectBox<SDL_Window *>",
              "name": "T"
            }
          ],
          "doc": ""
        },
        "WindowRef": {
          "name": "WindowRef",
          "kind": "alias",
          "type": "WindowBase<ObjectRef<SDL_Window>>",
          "doc": "Handle to a non owned window\n\n@cat resource\n\n@sa WindowBase\n@sa Window"
        },
        "Window": {
          "name": "Window",
          "kind": "alias",
          "type": "WindowBase<ObjectUnique<SDL_Window>>",
          "doc": "Handle to an owned window\n\n@cat resource\n\n@sa WindowBase\n@sa WindowRef"
        },
        "RendererBase-forward": {
          "name": "RendererBase",
          "kind": "forward",
          "template": [
            {
              "type": "ObjectBox<SDL_Renderer *>",
              "name": "T"
            }
          ],
          "doc": ""
        },
        "RendererRef": {
          "name": "RendererRef",
          "kind": "alias",
          "type": "RendererBase<ObjectRef<SDL_Renderer>>",
          "doc": ""
        },
        "DisplayOrientation": {
          "doc": "Display orientation values; the way a display is rotated.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "DisplayOrientation",
          "kind": "alias",
          "sourceName": "SDL_DisplayOrientation",
          "type": "SDL_DisplayOrientation"
        },
        "ORIENTATION_UNKNOWN": {
          "doc": "The display orientation can't be determined.",
          "name": "ORIENTATION_UNKNOWN",
          "kind": "var",
          "type": "DisplayOrientation",
          "sourceName": "SDL_ORIENTATION_UNKNOWN",
          "constexpr": true
        },
        "ORIENTATION_LANDSCAPE": {
          "doc": "The display is in landscape mode, with the right side up, relative to portrait mode.",
          "name": "ORIENTATION_LANDSCAPE",
          "kind": "var",
          "type": "DisplayOrientation",
          "sourceName": "SDL_ORIENTATION_LANDSCAPE",
          "constexpr": true
        },
        "ORIENTATION_LANDSCAPE_FLIPPED": {
          "doc": "The display is in landscape mode, with the left side up, relative to portrait mode.",
          "name": "ORIENTATION_LANDSCAPE_FLIPPED",
          "kind": "var",
          "type": "DisplayOrientation",
          "sourceName": "SDL_ORIENTATION_LANDSCAPE_FLIPPED",
          "constexpr": true
        },
        "ORIENTATION_PORTRAIT": {
          "doc": "The display is in portrait mode.",
          "name": "ORIENTATION_PORTRAIT",
          "kind": "var",
          "type": "DisplayOrientation",
          "sourceName": "SDL_ORIENTATION_PORTRAIT",
          "constexpr": true
        },
        "ORIENTATION_PORTRAIT_FLIPPED": {
          "doc": "The display is in portrait mode, upside down.",
          "name": "ORIENTATION_PORTRAIT_FLIPPED",
          "kind": "var",
          "type": "DisplayOrientation",
          "sourceName": "SDL_ORIENTATION_PORTRAIT_FLIPPED",
          "constexpr": true
        },
        "DisplayModeData": {
          "doc": "Internal display mode data.\n\nThis lives as a field in DisplayMode, as opaque data.\n\n@since This struct is available since SDL 3.2.0.\n\n@sa DisplayMode",
          "name": "DisplayModeData",
          "kind": "alias",
          "type": "SDL_DisplayModeData",
          "sourceName": "SDL_DisplayModeData"
        },
        "DisplayMode": {
          "doc": "The structure that defines a display mode.\n\n@since This struct is available since SDL 3.2.0.\n\n@sa Display.GetFullscreenModes\n@sa Display.GetDesktopMode\n@sa Display.GetCurrentMode\n@sa WindowBase.SetFullscreenMode\n@sa WindowBase.GetFullscreenMode",
          "name": "DisplayMode",
          "kind": "alias",
          "sourceName": "SDL_DisplayMode",
          "type": "SDL_DisplayMode"
        },
        "WindowFlags": {
          "doc": "The flags on a window.\n\nThese cover a lot of true/false, or on/off, window state. Some of it is\nimmutable after being set through WindowBase.WindowBase(), some of it can be\nchanged on existing windows by the app, and some of it might be altered by\nthe user or system outside of the app's control.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa WindowBase.GetFlags",
          "name": "WindowFlags",
          "kind": "alias",
          "type": "SDL_WindowFlags",
          "sourceName": "SDL_WindowFlags"
        },
        "WINDOW_FULLSCREEN": {
          "doc": "window is in fullscreen mode",
          "name": "WINDOW_FULLSCREEN",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000000000001)",
          "sourceName": "SDL_WINDOW_FULLSCREEN",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_OPENGL": {
          "doc": "window usable with OpenGL context",
          "name": "WINDOW_OPENGL",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000000000002)",
          "sourceName": "SDL_WINDOW_OPENGL",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_OCCLUDED": {
          "doc": "window is occluded",
          "name": "WINDOW_OCCLUDED",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000000000004)",
          "sourceName": "SDL_WINDOW_OCCLUDED",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_HIDDEN": {
          "doc": "window is neither mapped onto the desktop nor shown in the taskbar/dock/window list; WindowBase.Show() is required for it to become visible",
          "name": "WINDOW_HIDDEN",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000000000008)",
          "sourceName": "SDL_WINDOW_HIDDEN",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_BORDERLESS": {
          "doc": "no window decoration",
          "name": "WINDOW_BORDERLESS",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000000000010)",
          "sourceName": "SDL_WINDOW_BORDERLESS",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_RESIZABLE": {
          "doc": "window can be resized",
          "name": "WINDOW_RESIZABLE",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000000000020)",
          "sourceName": "SDL_WINDOW_RESIZABLE",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_MINIMIZED": {
          "doc": "window is minimized",
          "name": "WINDOW_MINIMIZED",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000000000040)",
          "sourceName": "SDL_WINDOW_MINIMIZED",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_MAXIMIZED": {
          "doc": "window is maximized",
          "name": "WINDOW_MAXIMIZED",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000000000080)",
          "sourceName": "SDL_WINDOW_MAXIMIZED",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_MOUSE_GRABBED": {
          "doc": "window has grabbed mouse input",
          "name": "WINDOW_MOUSE_GRABBED",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000000000100)",
          "sourceName": "SDL_WINDOW_MOUSE_GRABBED",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_INPUT_FOCUS": {
          "doc": "window has input focus",
          "name": "WINDOW_INPUT_FOCUS",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000000000200)",
          "sourceName": "SDL_WINDOW_INPUT_FOCUS",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_MOUSE_FOCUS": {
          "doc": "window has mouse focus",
          "name": "WINDOW_MOUSE_FOCUS",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000000000400)",
          "sourceName": "SDL_WINDOW_MOUSE_FOCUS",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_EXTERNAL": {
          "doc": "window not created by SDL",
          "name": "WINDOW_EXTERNAL",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000000000800)",
          "sourceName": "SDL_WINDOW_EXTERNAL",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_MODAL": {
          "doc": "window is modal",
          "name": "WINDOW_MODAL",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000000001000)",
          "sourceName": "SDL_WINDOW_MODAL",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_HIGH_PIXEL_DENSITY": {
          "doc": "window uses high pixel density back buffer if possible",
          "name": "WINDOW_HIGH_PIXEL_DENSITY",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000000002000)",
          "sourceName": "SDL_WINDOW_HIGH_PIXEL_DENSITY",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_MOUSE_CAPTURE": {
          "doc": "window has mouse captured (unrelated to MOUSE_GRABBED)",
          "name": "WINDOW_MOUSE_CAPTURE",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000000004000)",
          "sourceName": "SDL_WINDOW_MOUSE_CAPTURE",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_MOUSE_RELATIVE_MODE": {
          "doc": "window has relative mode enabled",
          "name": "WINDOW_MOUSE_RELATIVE_MODE",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000000008000)",
          "sourceName": "SDL_WINDOW_MOUSE_RELATIVE_MODE",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_ALWAYS_ON_TOP": {
          "doc": "window should always be above others",
          "name": "WINDOW_ALWAYS_ON_TOP",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000000010000)",
          "sourceName": "SDL_WINDOW_ALWAYS_ON_TOP",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_UTILITY": {
          "doc": "window should be treated as a utility window, not showing in the task bar and window list",
          "name": "WINDOW_UTILITY",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000000020000)",
          "sourceName": "SDL_WINDOW_UTILITY",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_TOOLTIP": {
          "doc": "window should be treated as a tooltip and does not get mouse or keyboard focus, requires a parent window",
          "name": "WINDOW_TOOLTIP",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000000040000)",
          "sourceName": "SDL_WINDOW_TOOLTIP",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_POPUP_MENU": {
          "doc": "window should be treated as a popup menu, requires a parent window",
          "name": "WINDOW_POPUP_MENU",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000000080000)",
          "sourceName": "SDL_WINDOW_POPUP_MENU",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_KEYBOARD_GRABBED": {
          "doc": "window has grabbed keyboard input",
          "name": "WINDOW_KEYBOARD_GRABBED",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000000100000)",
          "sourceName": "SDL_WINDOW_KEYBOARD_GRABBED",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_VULKAN": {
          "doc": "window usable for Vulkan surface",
          "name": "WINDOW_VULKAN",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000010000000)",
          "sourceName": "SDL_WINDOW_VULKAN",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_METAL": {
          "doc": "window usable for Metal view",
          "name": "WINDOW_METAL",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000020000000)",
          "sourceName": "SDL_WINDOW_METAL",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_TRANSPARENT": {
          "doc": "window with transparent buffer",
          "name": "WINDOW_TRANSPARENT",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000040000000)",
          "sourceName": "SDL_WINDOW_TRANSPARENT",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "WINDOW_NOT_FOCUSABLE": {
          "doc": "window should not be focusable",
          "name": "WINDOW_NOT_FOCUSABLE",
          "kind": "var",
          "value": "SDL_UINT64_C(0x0000000080000000)",
          "sourceName": "SDL_WINDOW_NOT_FOCUSABLE",
          "constexpr": true,
          "type": "WindowFlags"
        },
        "FlashOperation": {
          "doc": "Window flash operation.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "FlashOperation",
          "kind": "alias",
          "sourceName": "SDL_FlashOperation",
          "type": "SDL_FlashOperation"
        },
        "FLASH_CANCEL": {
          "doc": "Cancel any window flash state.",
          "name": "FLASH_CANCEL",
          "kind": "var",
          "type": "FlashOperation",
          "sourceName": "SDL_FLASH_CANCEL",
          "constexpr": true
        },
        "FLASH_BRIEFLY": {
          "doc": "Flash the window briefly to get attention.",
          "name": "FLASH_BRIEFLY",
          "kind": "var",
          "type": "FlashOperation",
          "sourceName": "SDL_FLASH_BRIEFLY",
          "constexpr": true
        },
        "FLASH_UNTIL_FOCUSED": {
          "doc": "Flash the window until it gets focus.",
          "name": "FLASH_UNTIL_FOCUSED",
          "kind": "var",
          "type": "FlashOperation",
          "sourceName": "SDL_FLASH_UNTIL_FOCUSED",
          "constexpr": true
        },
        "HitTestResult": {
          "doc": "Possible return values from the HitTest callback.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This enum is available since SDL 3.2.0.\n\n@sa HitTest",
          "name": "HitTestResult",
          "kind": "alias",
          "sourceName": "SDL_HitTestResult",
          "type": "SDL_HitTestResult"
        },
        "HITTEST_NORMAL": {
          "doc": "Region is normal.  No special properties.",
          "name": "HITTEST_NORMAL",
          "kind": "var",
          "type": "HitTestResult",
          "sourceName": "SDL_HITTEST_NORMAL",
          "constexpr": true
        },
        "HITTEST_DRAGGABLE": {
          "doc": "Region can drag entire window.",
          "name": "HITTEST_DRAGGABLE",
          "kind": "var",
          "type": "HitTestResult",
          "sourceName": "SDL_HITTEST_DRAGGABLE",
          "constexpr": true
        },
        "HITTEST_RESIZE_TOPLEFT": {
          "doc": "Region is the resizable top-left corner border.",
          "name": "HITTEST_RESIZE_TOPLEFT",
          "kind": "var",
          "type": "HitTestResult",
          "sourceName": "SDL_HITTEST_RESIZE_TOPLEFT",
          "constexpr": true
        },
        "HITTEST_RESIZE_TOP": {
          "doc": "Region is the resizable top border.",
          "name": "HITTEST_RESIZE_TOP",
          "kind": "var",
          "type": "HitTestResult",
          "sourceName": "SDL_HITTEST_RESIZE_TOP",
          "constexpr": true
        },
        "HITTEST_RESIZE_TOPRIGHT": {
          "doc": "Region is the resizable top-right corner border.",
          "name": "HITTEST_RESIZE_TOPRIGHT",
          "kind": "var",
          "type": "HitTestResult",
          "sourceName": "SDL_HITTEST_RESIZE_TOPRIGHT",
          "constexpr": true
        },
        "HITTEST_RESIZE_RIGHT": {
          "doc": "Region is the resizable right border.",
          "name": "HITTEST_RESIZE_RIGHT",
          "kind": "var",
          "type": "HitTestResult",
          "sourceName": "SDL_HITTEST_RESIZE_RIGHT",
          "constexpr": true
        },
        "HITTEST_RESIZE_BOTTOMRIGHT": {
          "doc": "Region is the resizable bottom-right corner border.",
          "name": "HITTEST_RESIZE_BOTTOMRIGHT",
          "kind": "var",
          "type": "HitTestResult",
          "sourceName": "SDL_HITTEST_RESIZE_BOTTOMRIGHT",
          "constexpr": true
        },
        "HITTEST_RESIZE_BOTTOM": {
          "doc": "Region is the resizable bottom border.",
          "name": "HITTEST_RESIZE_BOTTOM",
          "kind": "var",
          "type": "HitTestResult",
          "sourceName": "SDL_HITTEST_RESIZE_BOTTOM",
          "constexpr": true
        },
        "HITTEST_RESIZE_BOTTOMLEFT": {
          "doc": "Region is the resizable bottom-left corner border.",
          "name": "HITTEST_RESIZE_BOTTOMLEFT",
          "kind": "var",
          "type": "HitTestResult",
          "sourceName": "SDL_HITTEST_RESIZE_BOTTOMLEFT",
          "constexpr": true
        },
        "HITTEST_RESIZE_LEFT": {
          "doc": "Region is the resizable left border.",
          "name": "HITTEST_RESIZE_LEFT",
          "kind": "var",
          "type": "HitTestResult",
          "sourceName": "SDL_HITTEST_RESIZE_LEFT",
          "constexpr": true
        },
        "HitTest": {
          "doc": "Callback used for hit-testing.\n\n@param win the WindowBase where hit-testing was set on.\n@param area an Point which should be hit-tested.\n@param data what was passed as `callback_data` to WindowBase.SetHitTest().\n@returns an HitTestResult value.\n\n@sa WindowBase.SetHitTest",
          "name": "HitTest",
          "kind": "alias",
          "type": "SDL_HitTest",
          "sourceName": "SDL_HitTest"
        },
        "HitTestCB": {
          "kind": "alias",
          "name": "HitTestCB",
          "doc": "@sa HitTest"
        },
        "GLContextBase-forward": {
          "name": "GLContextBase",
          "kind": "forward",
          "template": [
            {
              "type": "ObjectBox<SDL_GLContextState *>",
              "name": "T"
            }
          ],
          "doc": ""
        },
        "GLContextRef": {
          "name": "GLContextRef",
          "kind": "alias",
          "type": "GLContextBase<ObjectRef<SDL_GLContextState>>",
          "doc": "Handle to a non owned gLContext\n\n@cat resource\n\n@sa GLContextBase\n@sa GLContext"
        },
        "GLContext": {
          "name": "GLContext",
          "kind": "alias",
          "type": "GLContextBase<ObjectUnique<SDL_GLContextState>>",
          "doc": "Handle to an owned gLContext\n\n@cat resource\n\n@sa GLContextBase\n@sa GLContextRef"
        },
        "Display": {
          "doc": "This is a unique ID for a display for the time it is connected to the\nsystem, and is never reused for the lifetime of the application.\n\nIf the display is disconnected and reconnected, it will get a new ID.\n\nThe value 0 is an invalid ID.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "Display",
          "kind": "struct",
          "type": "",
          "sourceName": "SDL_DisplayID",
          "entries": {
            "m_displayID": {
              "kind": "var",
              "name": "m_displayID",
              "type": "SDL_DisplayID",
              "doc": ""
            },
            "Display": {
              "kind": "function",
              "name": "Display",
              "type": "",
              "constexpr": true,
              "parameters": [
                {
                  "type": "SDL_DisplayID",
                  "name": "displayID",
                  "default": "{}"
                }
              ],
              "doc": "Wraps Display.\n\n@param displayID the value to be wrapped"
            },
            "operator==": {
              "kind": "function",
              "name": "operator==",
              "type": "bool",
              "constexpr": true,
              "immutable": true,
              "parameters": [
                {
                  "type": "const Display &",
                  "name": "other"
                }
              ],
              "doc": ""
            },
            "operator SDL_DisplayID": {
              "kind": "function",
              "name": "operator SDL_DisplayID",
              "type": "",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Unwraps to the underlying Display.\n\n@returns the underlying Display."
            },
            "operator bool": {
              "kind": "function",
              "name": "operator bool",
              "type": "",
              "constexpr": true,
              "explicit": true,
              "immutable": true,
              "parameters": [],
              "doc": "Check if valid.\n\n@returns True if valid state, false otherwise."
            },
            "GetAll": {
              "doc": "Get a list of currently connected displays.\n\n@param count a pointer filled in with the number of displays returned, may\n             be nullptr.\n@returns a 0 terminated array of display instance IDs or nullptr on failure;\n         call GetError() for more information. This should be freed\n         with free() when it is no longer needed.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetAll",
              "kind": "function",
              "type": "OwnArray<Display>",
              "parameters": [],
              "sourceName": "SDL_GetDisplays"
            },
            "GetPrimary": {
              "doc": "Return the primary display.\n\n@returns the instance ID of the primary display on success or 0 on failure;\n         call GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Display.GetAll",
              "name": "GetPrimary",
              "kind": "function",
              "type": "Display",
              "parameters": [],
              "sourceName": "SDL_GetPrimaryDisplay"
            },
            "GetProperties": {
              "doc": "Get the properties associated with a display.\n\nThe following read-only properties are provided by SDL:\n\n- `SDL_PROP_DISPLAY_HDR_ENABLED_BOOLEAN`: true if the display has HDR\n  headroom above the SDR white point. This is for informational and\n  diagnostic purposes only, as not all platforms provide this information\n  at the display level.\n\nOn KMS/DRM:\n\n- `prop::Display.KMSDRM_PANEL_ORIENTATION_NUMBER`: the \"panel\n  orientation\" property for the display in degrees of clockwise rotation.\n  Note that this is provided only as a hint, and the application is\n  responsible for any coordinate transformations needed to conform to the\n  requested display orientation.\n\n@returns a valid property ID on success or 0 on failure; call\n         GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetProperties",
              "kind": "function",
              "type": "PropertiesRef",
              "parameters": [],
              "sourceName": "SDL_GetDisplayProperties",
              "immutable": true
            },
            "GetName": {
              "doc": "Get the name of a display in UTF-8 encoding.\n\n@returns the name of a display or nullptr on failure; call GetError() for\n         more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Display.GetAll",
              "name": "GetName",
              "kind": "function",
              "type": "const char *",
              "parameters": [],
              "sourceName": "SDL_GetDisplayName",
              "immutable": true
            },
            "GetBounds": {
              "doc": "Get the desktop area represented by a display.\n\nThe primary display is often located at (0,0), but may be placed at a\ndifferent location depending on monitor layout.\n\n@param displayID the instance ID of the display to query.\n@param rect the Rect structure filled in with the display bounds.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Display.GetUsableBounds\n@sa Display.GetAll",
              "name": "GetBounds",
              "kind": "function",
              "type": "std::optional<Rect>",
              "parameters": [],
              "sourceName": "SDL_GetDisplayBounds",
              "immutable": true
            },
            "GetUsableBounds": {
              "doc": "Get the usable desktop area represented by a display, in screen\ncoordinates.\n\nThis is the same area as Display.GetBounds() reports, but with portions\nreserved by the system removed. For example, on Apple's macOS, this\nsubtracts the area occupied by the menu bar and dock.\n\nSetting a window to be fullscreen generally bypasses these unusable areas,\nso these are good guidelines for the maximum space available to a\nnon-fullscreen window.\n\n@param displayID the instance ID of the display to query.\n@param rect the Rect structure filled in with the display bounds.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Display.GetBounds\n@sa Display.GetAll",
              "name": "GetUsableBounds",
              "kind": "function",
              "type": "std::optional<Rect>",
              "parameters": [],
              "sourceName": "SDL_GetDisplayUsableBounds",
              "immutable": true
            },
            "GetNaturalOrientation": {
              "doc": "Get the orientation of a display when it is unrotated.\n\n@returns the DisplayOrientation enum value of the display, or\n         `ORIENTATION_UNKNOWN` if it isn't available.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Display.GetAll",
              "name": "GetNaturalOrientation",
              "kind": "function",
              "type": "DisplayOrientation",
              "parameters": [],
              "sourceName": "SDL_GetNaturalDisplayOrientation",
              "immutable": true
            },
            "GetCurrentOrientation": {
              "doc": "Get the orientation of a display.\n\n@returns the DisplayOrientation enum value of the display, or\n         `ORIENTATION_UNKNOWN` if it isn't available.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Display.GetAll",
              "name": "GetCurrentOrientation",
              "kind": "function",
              "type": "DisplayOrientation",
              "parameters": [],
              "sourceName": "SDL_GetCurrentDisplayOrientation",
              "immutable": true
            },
            "GetContentScale": {
              "doc": "Get the content scale of a display.\n\nThe content scale is the expected scale for content based on the DPI\nsettings of the display. For example, a 4K display might have a 2.0 (200%)\ndisplay scale, which means that the user expects UI elements to be twice as\nbig on this display, to aid in readability.\n\nAfter window creation, WindowBase.GetDisplayScale() should be used to query\nthe content scale factor for individual windows instead of querying the\ndisplay for a window and calling this function, as the per-window content\nscale factor may differ from the base value of the display it is on,\nparticularly on high-DPI and/or multi-monitor desktop configurations.\n\n@returns the content scale of the display, or 0.0f on failure; call\n         GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetDisplayScale\n@sa Display.GetAll",
              "name": "GetContentScale",
              "kind": "function",
              "type": "float",
              "parameters": [],
              "sourceName": "SDL_GetDisplayContentScale",
              "immutable": true
            },
            "GetFullscreenModes": {
              "doc": "Get a list of fullscreen display modes available on a display.\n\nThe display modes are sorted in this priority:\n\n- w -> largest to smallest\n- h -> largest to smallest\n- bits per pixel -> more colors to fewer colors\n- packed pixel layout -> largest to smallest\n- refresh rate -> highest to lowest\n- pixel density -> lowest to highest\n\n@param displayID the instance ID of the display to query.\n@param count a pointer filled in with the number of display modes returned,\n             may be nullptr.\n@returns a nullptr terminated array of display mode pointers or nullptr on\n         failure; call GetError() for more information. This is a\n         single allocation that should be freed with free() when it is\n         no longer needed.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Display.GetAll",
              "name": "GetFullscreenModes",
              "kind": "function",
              "type": "OwnArray<DisplayMode *>",
              "parameters": [],
              "sourceName": "SDL_GetFullscreenDisplayModes",
              "immutable": true
            },
            "GetClosestFullscreenMode": {
              "doc": "Get the closest match to the requested display mode.\n\nThe available display modes are scanned and `closest` is filled in with the\nclosest mode matching the requested mode and returned. The mode format and\nrefresh rate default to the desktop mode if they are set to 0. The modes\nare scanned with size being first priority, format being second priority,\nand finally checking the refresh rate. If all the available modes are too\nsmall, then false is returned.\n\n@param w the width in pixels of the desired display mode.\n@param h the height in pixels of the desired display mode.\n@param refresh_rate the refresh rate of the desired display mode, or 0.0f\n                    for the desktop refresh rate.\n@param include_high_density_modes boolean to include high density modes in\n                                  the search.\n@param closest a pointer filled in with the closest display mode equal to\n               or larger than the desired mode.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Display.GetAll\n@sa Display.GetFullscreenModes",
              "name": "GetClosestFullscreenMode",
              "kind": "function",
              "type": "std::optional<DisplayMode>",
              "parameters": [
                {
                  "name": "w",
                  "type": "int"
                },
                {
                  "name": "h",
                  "type": "int"
                },
                {
                  "name": "refresh_rate",
                  "type": "float"
                },
                {
                  "name": "include_high_density_modes",
                  "type": "bool"
                }
              ],
              "sourceName": "SDL_GetClosestFullscreenDisplayMode",
              "immutable": true
            },
            "GetDesktopMode": {
              "doc": "Get information about the desktop's display mode.\n\nThere's a difference between this function and Display.GetCurrentMode()\nwhen SDL runs fullscreen and has changed the resolution. In that case this\nfunction will return the previous native display mode, and not the current\ndisplay mode.\n\n@returns a pointer to the desktop display mode or nullptr on failure; call\n         GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Display.GetCurrentMode\n@sa Display.GetAll",
              "name": "GetDesktopMode",
              "kind": "function",
              "type": "const DisplayMode *",
              "parameters": [],
              "sourceName": "SDL_GetDesktopDisplayMode",
              "immutable": true
            },
            "GetCurrentMode": {
              "doc": "Get information about the current display mode.\n\nThere's a difference between this function and Display.GetDesktopMode()\nwhen SDL runs fullscreen and has changed the resolution. In that case this\nfunction will return the current display mode, and not the previous native\ndisplay mode.\n\n@returns a pointer to the desktop display mode or nullptr on failure; call\n         GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Display.GetDesktopMode\n@sa Display.GetAll",
              "name": "GetCurrentMode",
              "kind": "function",
              "type": "const DisplayMode *",
              "parameters": [],
              "sourceName": "SDL_GetCurrentDisplayMode",
              "immutable": true
            },
            "GetForPoint": {
              "doc": "Get the display containing a point.\n\n@param point the point to query.\n@returns the instance ID of the display containing the point or 0 on\n         failure; call GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Display.GetBounds\n@sa Display.GetAll",
              "name": "GetForPoint",
              "kind": "function",
              "type": "Display",
              "parameters": [
                {
                  "name": "point",
                  "type": "const SDL_Point &"
                }
              ],
              "sourceName": "SDL_GetDisplayForPoint",
              "static": true
            },
            "GetForRect": {
              "doc": "Get the display primarily containing a rect.\n\n@param rect the rect to query.\n@returns the instance ID of the display entirely containing the rect or\n         closest to the center of the rect on success or 0 on failure; call\n         GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Display.GetBounds\n@sa Display.GetAll",
              "name": "GetForRect",
              "kind": "function",
              "type": "Display",
              "parameters": [
                {
                  "name": "rect",
                  "type": "const SDL_Rect &"
                }
              ],
              "sourceName": "SDL_GetDisplayForRect",
              "static": true
            }
          }
        },
        "WindowID": {
          "doc": "This is a unique ID for a window.\n\nThe value 0 is an invalid ID.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "WindowID",
          "kind": "alias",
          "type": "SDL_WindowID",
          "sourceName": "SDL_WindowID"
        },
        "prop::Global": {
          "kind": "ns",
          "name": "prop::Global",
          "entries": {
            "VIDEO_WAYLAND_WL_DISPLAY_POINTER": {
              "doc": "The pointer to the global `wl_display` object used by the Wayland video\nbackend.\n\nCan be set before the video subsystem is initialized to import an external\n`wl_display` object from an application or toolkit for use in SDL, or read\nafter initialization to export the `wl_display` used by the Wayland video\nbackend. Setting this property after the video subsystem has been\ninitialized has no effect, and reading it when the video subsystem is\nuninitialized will either return the user provided value, if one was set\nprior to initialization, or NULL. See docs/README-wayland.md for more\ninformation.",
              "name": "VIDEO_WAYLAND_WL_DISPLAY_POINTER",
              "kind": "var",
              "value": "\"SDL.video.wayland.wl_display\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_GLOBAL_VIDEO_WAYLAND_WL_DISPLAY_POINTER"
            }
          },
          "doc": ""
        },
        "SystemTheme": {
          "doc": "System theme.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "SystemTheme",
          "kind": "alias",
          "sourceName": "SDL_SystemTheme",
          "type": "SDL_SystemTheme"
        },
        "SYSTEM_THEME_UNKNOWN": {
          "doc": "Unknown system theme.",
          "name": "SYSTEM_THEME_UNKNOWN",
          "kind": "var",
          "type": "SystemTheme",
          "sourceName": "SDL_SYSTEM_THEME_UNKNOWN",
          "constexpr": true
        },
        "SYSTEM_THEME_LIGHT": {
          "doc": "Light colored system theme.",
          "name": "SYSTEM_THEME_LIGHT",
          "kind": "var",
          "type": "SystemTheme",
          "sourceName": "SDL_SYSTEM_THEME_LIGHT",
          "constexpr": true
        },
        "SYSTEM_THEME_DARK": {
          "doc": "Dark colored system theme.",
          "name": "SYSTEM_THEME_DARK",
          "kind": "var",
          "type": "SystemTheme",
          "sourceName": "SDL_SYSTEM_THEME_DARK",
          "constexpr": true
        },
        "WindowBase": {
          "doc": "The struct used as an opaque handle to a window.\n\n@since This struct is available since SDL 3.2.0.\n\n@sa WindowBase.WindowBase",
          "name": "WindowBase",
          "kind": "struct",
          "type": "T",
          "sourceName": "SDL_Window",
          "template": [
            {
              "type": "ObjectBox<SDL_Window *>",
              "name": "T"
            }
          ],
          "entries": {
            "T::T": {
              "kind": "alias",
              "name": "T::T",
              "doc": ""
            },
            "WindowBase": [
              {
                "doc": "Create a window with the specified dimensions and flags.\n\nThe window size is a request and may be different than expected based on\nthe desktop layout and window manager policies. Your application should be\nprepared to handle a window of any size.\n\n`flags` may be any of the following OR'd together:\n\n- `WINDOW_FULLSCREEN`: fullscreen window at desktop resolution\n- `WINDOW_OPENGL`: window usable with an OpenGL context\n- `WINDOW_OCCLUDED`: window partially or completely obscured by another\n  window\n- `WINDOW_HIDDEN`: window is not visible\n- `WINDOW_BORDERLESS`: no window decoration\n- `WINDOW_RESIZABLE`: window can be resized\n- `WINDOW_MINIMIZED`: window is minimized\n- `WINDOW_MAXIMIZED`: window is maximized\n- `WINDOW_MOUSE_GRABBED`: window has grabbed mouse focus\n- `WINDOW_INPUT_FOCUS`: window has input focus\n- `WINDOW_MOUSE_FOCUS`: window has mouse focus\n- `WINDOW_EXTERNAL`: window not created by SDL\n- `WINDOW_MODAL`: window is modal\n- `WINDOW_HIGH_PIXEL_DENSITY`: window uses high pixel density back\n  buffer if possible\n- `WINDOW_MOUSE_CAPTURE`: window has mouse captured (unrelated to\n  MOUSE_GRABBED)\n- `WINDOW_ALWAYS_ON_TOP`: window should always be above others\n- `WINDOW_UTILITY`: window should be treated as a utility window, not\n  showing in the task bar and window list\n- `WINDOW_TOOLTIP`: window should be treated as a tooltip and does not\n  get mouse or keyboard focus, requires a parent window\n- `WINDOW_POPUP_MENU`: window should be treated as a popup menu,\n  requires a parent window\n- `WINDOW_KEYBOARD_GRABBED`: window has grabbed keyboard input\n- `WINDOW_VULKAN`: window usable with a Vulkan instance\n- `WINDOW_METAL`: window usable with a Metal instance\n- `WINDOW_TRANSPARENT`: window with transparent buffer\n- `WINDOW_NOT_FOCUSABLE`: window should not be focusable\n\nThe WindowBase is implicitly shown if WINDOW_HIDDEN is not set.\n\nOn Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist\nproperty to YES, otherwise you will not receive a High-DPI OpenGL canvas.\n\nThe window pixel size may differ from its window coordinate size if the\nwindow is on a high pixel density display. Use WindowBase.GetSize() to query\nthe client area's size in window coordinates, and\nWindowBase.GetSizeInPixels() or RendererBase.GetOutputSize() to query the\ndrawable size in pixels. Note that the drawable size can vary after the\nwindow is created and should be queried again if you get an\nEVENT_WINDOW_PIXEL_SIZE_CHANGED event.\n\nIf the window is created with any of the WINDOW_OPENGL or\nWINDOW_VULKAN flags, then the corresponding LoadLibrary function\n(GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the\ncorresponding UnloadLibrary function is called by WindowBase.Destroy().\n\nIf WINDOW_VULKAN is specified and there isn't a working Vulkan driver,\nWindowBase.WindowBase() will fail, because SDL_Vulkan_LoadLibrary() will fail.\n\nIf WINDOW_METAL is specified on an OS that does not support Metal,\nWindowBase.WindowBase() will fail.\n\nIf you intend to use this window with an RendererBase, you should use\nCreateWindowAndRenderer() instead of this function, to avoid window\nflicker.\n\nOn non-Apple devices, SDL requires you to either not link to the Vulkan\nloader or link to a dynamic library version. This limitation may be removed\nin a future version of SDL.\n\n@param title the title of the window, in UTF-8 encoding.\n@param w the width of the window.\n@param h the height of the window.\n@param flags 0, or one or more WindowFlags OR'd together.\n@post the window that was created or nullptr on failure; call\n         GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa CreateWindowAndRenderer\n@sa WindowBase.WindowBase\n@sa WindowBase.WindowBase\n@sa WindowBase.Destroy",
                "name": "WindowBase",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "title",
                    "type": "StringParam"
                  },
                  {
                    "name": "size",
                    "type": "SDL_Point"
                  },
                  {
                    "name": "flags",
                    "type": "WindowFlags",
                    "default": "0"
                  }
                ],
                "sourceName": "SDL_CreateWindow",
                "static": false
              },
              {
                "doc": "Create a child popup window of the specified parent window.\n\nThe window size is a request and may be different than expected based on\nthe desktop layout and window manager policies. Your application should be\nprepared to handle a window of any size.\n\nThe flags parameter **must** contain at least one of the following:\n\n- `WINDOW_TOOLTIP`: The popup window is a tooltip and will not pass any\n  input events.\n- `WINDOW_POPUP_MENU`: The popup window is a popup menu. The topmost\n  popup menu will implicitly gain the keyboard focus.\n\nThe following flags are not relevant to popup window creation and will be\nignored:\n\n- `WINDOW_MINIMIZED`\n- `WINDOW_MAXIMIZED`\n- `WINDOW_FULLSCREEN`\n- `WINDOW_BORDERLESS`\n\nThe following flags are incompatible with popup window creation and will\ncause it to fail:\n\n- `WINDOW_UTILITY`\n- `WINDOW_MODAL`\n\nThe parent parameter **must** be non-null and a valid window. The parent of\na popup window can be either a regular, toplevel window, or another popup\nwindow.\n\nPopup windows cannot be minimized, maximized, made fullscreen, raised,\nflash, be made a modal window, be the parent of a toplevel window, or grab\nthe mouse and/or keyboard. Attempts to do so will fail.\n\nPopup windows implicitly do not have a border/decorations and do not appear\non the taskbar/dock or in lists of windows such as alt-tab menus.\n\nIf a parent window is hidden or destroyed, any child popup windows will be\nrecursively hidden or destroyed as well. Child popup windows not explicitly\nhidden will be restored when the parent is shown.\n\n@param parent the parent of the window, must not be nullptr.\n@param offset_x the x position of the popup window relative to the origin\n                of the parent.\n@param offset_y the y position of the popup window relative to the origin\n                of the parent window.\n@param w the width of the window.\n@param h the height of the window.\n@param flags WINDOW_TOOLTIP or WINDOW_POPUP_MENU, and zero or more\n             additional WindowFlags OR'd together.\n@post the window that was created or nullptr on failure; call\n         GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.WindowBase\n@sa WindowBase.WindowBase\n@sa WindowBase.Destroy\n@sa WindowBase.GetParent",
                "name": "WindowBase",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "parent",
                    "type": "WindowRef"
                  },
                  {
                    "name": "offset",
                    "type": "SDL_Point"
                  },
                  {
                    "name": "size",
                    "type": "SDL_Point"
                  },
                  {
                    "name": "flags",
                    "type": "WindowFlags",
                    "default": "0"
                  }
                ],
                "sourceName": "SDL_CreatePopupWindow"
              },
              {
                "doc": "Create a window with the specified properties.\n\nThe window size is a request and may be different than expected based on\nthe desktop layout and window manager policies. Your application should be\nprepared to handle a window of any size.\n\nThese are the supported properties:\n\n- `SDL_PROP_WINDOW_CREATE_ALWAYS_ON_TOP_BOOLEAN`: true if the window should\n  be always on top\n- `prop::Window.CREATE_BORDERLESS_BOOLEAN`: true if the window has no\n  window decoration\n- `prop::Window.CREATE_EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN`: true if the\n  window will be used with an externally managed graphics context.\n- `prop::Window.CREATE_FOCUSABLE_BOOLEAN`: true if the window should\n  accept keyboard input (defaults true)\n- `prop::Window.CREATE_FULLSCREEN_BOOLEAN`: true if the window should\n  start in fullscreen mode at desktop resolution\n- `prop::Window.CREATE_HEIGHT_NUMBER`: the height of the window\n- `prop::Window.CREATE_HIDDEN_BOOLEAN`: true if the window should start\n  hidden\n- `prop::Window.CREATE_HIGH_PIXEL_DENSITY_BOOLEAN`: true if the window\n  uses a high pixel density buffer if possible\n- `prop::Window.CREATE_MAXIMIZED_BOOLEAN`: true if the window should\n  start maximized\n- `prop::Window.CREATE_MENU_BOOLEAN`: true if the window is a popup menu\n- `prop::Window.CREATE_METAL_BOOLEAN`: true if the window will be used\n  with Metal rendering\n- `prop::Window.CREATE_MINIMIZED_BOOLEAN`: true if the window should\n  start minimized\n- `prop::Window.CREATE_MODAL_BOOLEAN`: true if the window is modal to\n  its parent\n- `prop::Window.CREATE_MOUSE_GRABBED_BOOLEAN`: true if the window starts\n  with grabbed mouse focus\n- `prop::Window.CREATE_OPENGL_BOOLEAN`: true if the window will be used\n  with OpenGL rendering\n- `prop::Window.CREATE_PARENT_POINTER`: an WindowBase that will be the\n  parent of this window, required for windows with the \"tooltip\", \"menu\",\n  and \"modal\" properties\n- `prop::Window.CREATE_RESIZABLE_BOOLEAN`: true if the window should be\n  resizable\n- `prop::Window.CREATE_TITLE_STRING`: the title of the window, in UTF-8\n  encoding\n- `prop::Window.CREATE_TRANSPARENT_BOOLEAN`: true if the window show\n  transparent in the areas with alpha of 0\n- `prop::Window.CREATE_TOOLTIP_BOOLEAN`: true if the window is a tooltip\n- `prop::Window.CREATE_UTILITY_BOOLEAN`: true if the window is a utility\n  window, not showing in the task bar and window list\n- `prop::Window.CREATE_VULKAN_BOOLEAN`: true if the window will be used\n  with Vulkan rendering\n- `prop::Window.CREATE_WIDTH_NUMBER`: the width of the window\n- `prop::Window.CREATE_X_NUMBER`: the x position of the window, or\n  `SDL_WINDOWPOS_CENTERED`, defaults to `SDL_WINDOWPOS_UNDEFINED`. This is\n  relative to the parent for windows with the \"tooltip\" or \"menu\" property\n  set.\n- `prop::Window.CREATE_Y_NUMBER`: the y position of the window, or\n  `SDL_WINDOWPOS_CENTERED`, defaults to `SDL_WINDOWPOS_UNDEFINED`. This is\n  relative to the parent for windows with the \"tooltip\" or \"menu\" property\n  set.\n\nThese are additional supported properties on macOS:\n\n- `prop::Window.CREATE_COCOA_WINDOW_POINTER`: the\n  `(__unsafe_unretained)` NSWindow associated with the window, if you want\n  to wrap an existing window.\n- `prop::Window.CREATE_COCOA_VIEW_POINTER`: the `(__unsafe_unretained)`\n  NSView associated with the window, defaults to `[window contentView]`\n\nThese are additional supported properties on Wayland:\n\n- `prop::Window.CREATE_WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN` - true if\n  the application wants to use the Wayland surface for a custom role and\n  does not want it attached to an XDG toplevel window. See\n  [README/wayland](README/wayland) for more information on using custom\n  surfaces.\n- `prop::Window.CREATE_WAYLAND_CREATE_EGL_WINDOW_BOOLEAN` - true if the\n  application wants an associated `wl_egl_window` object to be created and\n  attached to the window, even if the window does not have the OpenGL\n  property or `WINDOW_OPENGL` flag set.\n- `prop::Window.CREATE_WAYLAND_WL_SURFACE_POINTER` - the wl_surface\n  associated with the window, if you want to wrap an existing window. See\n  [README/wayland](README/wayland) for more information.\n\nThese are additional supported properties on Windows:\n\n- `prop::Window.CREATE_WIN32_HWND_POINTER`: the HWND associated with the\n  window, if you want to wrap an existing window.\n- `prop::Window.CREATE_WIN32_PIXEL_FORMAT_HWND_POINTER`: optional,\n  another window to share pixel format with, useful for OpenGL windows\n\nThese are additional supported properties with X11:\n\n- `prop::Window.CREATE_X11_WINDOW_NUMBER`: the X11 Window associated\n  with the window, if you want to wrap an existing window.\n\nThe window is implicitly shown if the \"hidden\" property is not set.\n\nWindows with the \"tooltip\" and \"menu\" properties are popup windows and have\nthe behaviors and guidelines outlined in WindowBase.WindowBase().\n\nIf this window is being created to be used with an RendererBase, you should\nnot add a graphics API specific property\n(`prop::Window.CREATE_OPENGL_BOOLEAN`, etc), as SDL will handle that\ninternally when it chooses a renderer. However, SDL might need to recreate\nyour window at that point, which may cause the window to appear briefly,\nand then flicker as it is recreated. The correct approach to this is to\ncreate the window with the `prop::Window.CREATE_HIDDEN_BOOLEAN` property\nset to true, then create the renderer, then show the window with\nWindowBase.Show().\n\n@param props the properties to use.\n@post the window that was created or nullptr on failure; call\n         GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa CreateProperties\n@sa WindowBase.WindowBase\n@sa WindowBase.Destroy",
                "name": "WindowBase",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "props",
                    "type": "PropertiesRef"
                  }
                ],
                "sourceName": "SDL_CreateWindowWithProperties"
              }
            ],
            "GetDisplay": {
              "doc": "Get the display associated with a window.\n\n@returns the instance ID of the display containing the center of the window\n         on success or 0 on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Display.GetBounds\n@sa Display.GetAll",
              "name": "GetDisplay",
              "kind": "function",
              "type": "Display",
              "parameters": [],
              "sourceName": "SDL_GetDisplayForWindow",
              "immutable": true
            },
            "GetPixelDensity": {
              "doc": "Get the pixel density of a window.\n\nThis is a ratio of pixel size to window size. For example, if the window is\n1920x1080 and it has a high density back buffer of 3840x2160 pixels, it\nwould have a pixel density of 2.0.\n\n@returns the pixel density or 0.0f on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetDisplayScale",
              "name": "GetPixelDensity",
              "kind": "function",
              "type": "float",
              "parameters": [],
              "sourceName": "SDL_GetWindowPixelDensity",
              "immutable": true
            },
            "GetDisplayScale": {
              "doc": "Get the content display scale relative to a window's pixel size.\n\nThis is a combination of the window pixel density and the display content\nscale, and is the expected scale for displaying content in this window. For\nexample, if a 3840x2160 window had a display scale of 2.0, the user expects\nthe content to take twice as many pixels and be the same physical size as\nif it were being displayed in a 1920x1080 window with a display scale of\n1.0.\n\nConceptually this value corresponds to the scale display setting, and is\nupdated when that setting is changed, or the window moves to a display with\na different scale setting.\n\n@returns the display scale, or 0.0f on failure; call GetError() for\n         more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetDisplayScale",
              "kind": "function",
              "type": "float",
              "parameters": [],
              "sourceName": "SDL_GetWindowDisplayScale",
              "immutable": true
            },
            "SetFullscreenMode": {
              "doc": "Set the display mode to use when a window is visible and fullscreen.\n\nThis only affects the display mode used when the window is fullscreen. To\nchange the window size when the window is not fullscreen, use\nWindowBase.SetSize().\n\nIf the window is currently in the fullscreen state, this request is\nasynchronous on some windowing systems and the new mode dimensions may not\nbe applied immediately upon the return of this function. If an immediate\nchange is required, call WindowBase.Sync() to block until the changes have\ntaken effect.\n\nWhen the new mode takes effect, an EVENT_WINDOW_RESIZED and/or an\nEVENT_WINDOW_PIXEL_SIZE_CHANGED event will be emitted with the new mode\ndimensions.\n\n@param mode a pointer to the display mode to use, which can be nullptr for\n            borderless fullscreen desktop mode, or one of the fullscreen\n            modes returned by Display.GetFullscreenModes() to set an\n            exclusive fullscreen mode.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetFullscreenMode\n@sa WindowBase.SetFullscreen\n@sa WindowBase.Sync",
              "name": "SetFullscreenMode",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "mode",
                  "type": "OptionalRef<const DisplayMode>"
                }
              ],
              "sourceName": "SDL_SetWindowFullscreenMode"
            },
            "GetFullscreenMode": {
              "doc": "Query the display mode to use when a window is visible at fullscreen.\n\n@returns a pointer to the exclusive fullscreen mode to use or nullptr for\n         borderless fullscreen desktop mode.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.SetFullscreenMode\n@sa WindowBase.SetFullscreen",
              "name": "GetFullscreenMode",
              "kind": "function",
              "type": "const DisplayMode *",
              "parameters": [],
              "sourceName": "SDL_GetWindowFullscreenMode",
              "immutable": true
            },
            "GetICCProfile": {
              "doc": "Get the raw ICC profile data for the screen the window is currently on.\n\n@param size the size of the ICC profile.\n@returns the raw ICC profile data on success or nullptr on failure; call\n         GetError() for more information. This should be freed with\n         free() when it is no longer needed.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetICCProfile",
              "kind": "function",
              "type": "OwnPtr<void>",
              "parameters": [
                {
                  "name": "size",
                  "type": "size_t *"
                }
              ],
              "sourceName": "SDL_GetWindowICCProfile",
              "immutable": true
            },
            "GetPixelFormat": {
              "doc": "Get the pixel format associated with the window.\n\n@returns the pixel format of the window on success or\n         PIXELFORMAT_UNKNOWN on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetPixelFormat",
              "kind": "function",
              "type": "PixelFormat",
              "parameters": [],
              "sourceName": "SDL_GetWindowPixelFormat",
              "immutable": true
            },
            "GetID": {
              "doc": "Get the numeric ID of a window.\n\nThe numeric ID is what WindowEvent references, and is necessary to map\nthese events to specific WindowBase objects.\n\n@returns the ID of the window on success or 0 on failure; call\n         GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetWindowFromID",
              "name": "GetID",
              "kind": "function",
              "type": "WindowID",
              "parameters": [],
              "sourceName": "SDL_GetWindowID",
              "immutable": true
            },
            "GetParent": {
              "doc": "Get parent of a window.\n\n@returns the parent of the window on success or nullptr if the window has no\n         parent.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.WindowBase",
              "name": "GetParent",
              "kind": "function",
              "type": "WindowRef",
              "parameters": [],
              "sourceName": "SDL_GetWindowParent",
              "immutable": true
            },
            "GetProperties": {
              "doc": "Get the properties associated with a window.\n\nThe following read-only properties are provided by SDL:\n\n- `prop::Window.SHAPE_POINTER`: the surface associated with a shaped\n  window\n- `prop::Window.HDR_ENABLED_BOOLEAN`: true if the window has HDR\n  headroom above the SDR white point. This property can change dynamically\n  when EVENT_WINDOW_HDR_STATE_CHANGED is sent.\n- `prop::Window.SDR_WHITE_LEVEL_FLOAT`: the value of SDR white in the\n  COLORSPACE_SRGB_LINEAR colorspace. On Windows this corresponds to the\n  SDR white level in scRGB colorspace, and on Apple platforms this is\n  always 1.0 for EDR content. This property can change dynamically when\n  EVENT_WINDOW_HDR_STATE_CHANGED is sent.\n- `prop::Window.HDR_HEADROOM_FLOAT`: the additional high dynamic range\n  that can be displayed, in terms of the SDR white point. When HDR is not\n  enabled, this will be 1.0. This property can change dynamically when\n  EVENT_WINDOW_HDR_STATE_CHANGED is sent.\n\nOn Android:\n\n- `prop::Window.ANDROID_WINDOW_POINTER`: the ANativeWindow associated\n  with the window\n- `prop::Window.ANDROID_SURFACE_POINTER`: the EGLSurface associated with\n  the window\n\nOn iOS:\n\n- `prop::Window.UIKIT_WINDOW_POINTER`: the `(__unsafe_unretained)`\n  UIWindow associated with the window\n- `prop::Window.UIKIT_METAL_VIEW_TAG_NUMBER`: the NSInteger tag\n  associated with metal views on the window\n- `prop::Window.UIKIT_OPENGL_FRAMEBUFFER_NUMBER`: the OpenGL view's\n  framebuffer object. It must be bound when rendering to the screen using\n  OpenGL.\n- `prop::Window.UIKIT_OPENGL_RENDERBUFFER_NUMBER`: the OpenGL view's\n  renderbuffer object. It must be bound when GL_SwapWindow is called.\n- `prop::Window.UIKIT_OPENGL_RESOLVE_FRAMEBUFFER_NUMBER`: the OpenGL\n  view's resolve framebuffer, when MSAA is used.\n\nOn KMS/DRM:\n\n- `prop::Window.KMSDRM_DEVICE_INDEX_NUMBER`: the device index associated\n  with the window (e.g. the X in /dev/dri/cardX)\n- `prop::Window.KMSDRM_DRM_FD_NUMBER`: the DRM FD associated with the\n  window\n- `prop::Window.KMSDRM_GBM_DEVICE_POINTER`: the GBM device associated\n  with the window\n\nOn macOS:\n\n- `prop::Window.COCOA_WINDOW_POINTER`: the `(__unsafe_unretained)`\n  NSWindow associated with the window\n- `prop::Window.COCOA_METAL_VIEW_TAG_NUMBER`: the NSInteger tag\n  assocated with metal views on the window\n\nOn OpenVR:\n\n- `prop::Window.OPENVR_OVERLAY_ID`: the OpenVR Overlay Handle ID for the\n  associated overlay window.\n\nOn Vivante:\n\n- `prop::Window.VIVANTE_DISPLAY_POINTER`: the EGLNativeDisplayType\n  associated with the window\n- `prop::Window.VIVANTE_WINDOW_POINTER`: the EGLNativeWindowType\n  associated with the window\n- `prop::Window.VIVANTE_SURFACE_POINTER`: the EGLSurface associated with\n  the window\n\nOn Windows:\n\n- `prop::Window.WIN32_HWND_POINTER`: the HWND associated with the window\n- `prop::Window.WIN32_HDC_POINTER`: the HDC associated with the window\n- `prop::Window.WIN32_INSTANCE_POINTER`: the HINSTANCE associated with\n  the window\n\nOn Wayland:\n\nNote: The `xdg_*` window objects do not internally persist across window\nshow/hide calls. They will be null if the window is hidden and must be\nqueried each time it is shown.\n\n- `prop::Window.WAYLAND_DISPLAY_POINTER`: the wl_display associated with\n  the window\n- `prop::Window.WAYLAND_SURFACE_POINTER`: the wl_surface associated with\n  the window\n- `prop::Window.WAYLAND_VIEWPORT_POINTER`: the wp_viewport associated\n  with the window\n- `prop::Window.WAYLAND_EGL_WINDOW_POINTER`: the wl_egl_window\n  associated with the window\n- `prop::Window.WAYLAND_XDG_SURFACE_POINTER`: the xdg_surface associated\n  with the window\n- `prop::Window.WAYLAND_XDG_TOPLEVEL_POINTER`: the xdg_toplevel role\n  associated with the window\n- 'prop::Window.WAYLAND_XDG_TOPLEVEL_EXPORT_HANDLE_STRING': the export\n  handle associated with the window\n- `prop::Window.WAYLAND_XDG_POPUP_POINTER`: the xdg_popup role\n  associated with the window\n- `prop::Window.WAYLAND_XDG_POSITIONER_POINTER`: the xdg_positioner\n  associated with the window, in popup mode\n\nOn X11:\n\n- `prop::Window.X11_DISPLAY_POINTER`: the X11 Display associated with\n  the window\n- `prop::Window.X11_SCREEN_NUMBER`: the screen number associated with\n  the window\n- `prop::Window.X11_WINDOW_NUMBER`: the X11 Window associated with the\n  window\n\n@returns a valid property ID on success or 0 on failure; call\n         GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetProperties",
              "kind": "function",
              "type": "PropertiesRef",
              "parameters": [],
              "sourceName": "SDL_GetWindowProperties",
              "immutable": true
            },
            "GetFlags": {
              "doc": "Get the window flags.\n\n@returns a mask of the WindowFlags associated with `window`.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.WindowBase\n@sa WindowBase.Hide\n@sa WindowBase.Maximize\n@sa WindowBase.Minimize\n@sa WindowBase.SetFullscreen\n@sa WindowBase.SetMouseGrab\n@sa WindowBase.Show",
              "name": "GetFlags",
              "kind": "function",
              "type": "WindowFlags",
              "parameters": [],
              "sourceName": "SDL_GetWindowFlags",
              "immutable": true
            },
            "SetTitle": {
              "doc": "Set the title of a window.\n\nThis string is expected to be in UTF-8 encoding.\n\n@param title the desired window title in UTF-8 format.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetTitle",
              "name": "SetTitle",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "title",
                  "type": "StringParam"
                }
              ],
              "sourceName": "SDL_SetWindowTitle"
            },
            "GetTitle": {
              "doc": "Get the title of a window.\n\n@returns the title of the window in UTF-8 format or \"\" if there is no\n         title.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.SetTitle",
              "name": "GetTitle",
              "kind": "function",
              "type": "const char *",
              "parameters": [],
              "sourceName": "SDL_GetWindowTitle",
              "immutable": true
            },
            "SetIcon": {
              "doc": "Set the icon for a window.\n\nIf this function is passed a surface with alternate representations, the\nsurface will be interpreted as the content to be used for 100% display\nscale, and the alternate representations will be used for high DPI\nsituations. For example, if the original surface is 32x32, then on a 2x\nmacOS display or 200% display scale on Windows, a 64x64 version of the\nimage will be used, if available. If a matching version of the image isn't\navailable, the closest larger size image will be downscaled to the\nappropriate size and be used instead, if available. Otherwise, the closest\nsmaller image will be upscaled and be used instead.\n\n@param icon an SurfaceBase structure containing the icon for the window.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "SetIcon",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "icon",
                  "type": "SurfaceRef"
                }
              ],
              "sourceName": "SDL_SetWindowIcon"
            },
            "SetRect": {
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "type": "Rect",
                  "name": "rect"
                }
              ],
              "name": "SetRect",
              "doc": ""
            },
            "GetRect": {
              "kind": "function",
              "type": "std::optional<Rect>",
              "immutable": true,
              "parameters": [],
              "name": "GetRect",
              "doc": ""
            },
            "SetPosition": {
              "doc": "Request that the window's position be set.\n\nIf the window is in an exclusive fullscreen or maximized state, this\nrequest has no effect.\n\nThis can be used to reposition fullscreen-desktop windows onto a different\ndisplay, however, as exclusive fullscreen windows are locked to a specific\ndisplay, they can only be repositioned programmatically via\nWindowBase.SetFullscreenMode().\n\nOn some windowing systems this request is asynchronous and the new\ncoordinates may not have have been applied immediately upon the return of\nthis function. If an immediate change is required, call WindowBase.Sync() to\nblock until the changes have taken effect.\n\nWhen the window position changes, an EVENT_WINDOW_MOVED event will be\nemitted with the window's new coordinates. Note that the new coordinates\nmay not match the exact coordinates requested, as some windowing systems\ncan restrict the position of the window in certain scenarios (e.g.\nconstraining the position so the window is always within desktop bounds).\nAdditionally, as this is just a request, it can be denied by the windowing\nsystem.\n\n@param window the window to reposition.\n@param x the x coordinate of the window, or `SDL_WINDOWPOS_CENTERED` or\n         `SDL_WINDOWPOS_UNDEFINED`.\n@param y the y coordinate of the window, or `SDL_WINDOWPOS_CENTERED` or\n         `SDL_WINDOWPOS_UNDEFINED`.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetPosition\n@sa WindowBase.Sync",
              "name": "SetPosition",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "p",
                  "type": "SDL_Point"
                }
              ],
              "sourceName": "SDL_SetWindowPosition",
              "static": false
            },
            "GetPosition": [
              {
                "kind": "function",
                "type": "std::optional<Point>",
                "immutable": true,
                "parameters": [],
                "name": "GetPosition",
                "doc": ""
              },
              {
                "doc": "Get the position of a window.\n\nThis is the current position of the window as last reported by the\nwindowing system.\n\nIf you do not need the value for one of the positions a nullptr may be passed\nin the `x` or `y` parameter.\n\n@param x a pointer filled in with the x position of the window, may be\n         nullptr.\n@param y a pointer filled in with the y position of the window, may be\n         nullptr.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.SetPosition",
                "name": "GetPosition",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "x",
                    "type": "int *"
                  },
                  {
                    "name": "y",
                    "type": "int *"
                  }
                ],
                "sourceName": "SDL_GetWindowPosition",
                "immutable": true
              }
            ],
            "SetSize": {
              "doc": "Request that the size of a window's client area be set.\n\nIf the window is in a fullscreen or maximized state, this request has no\neffect.\n\nTo change the exclusive fullscreen mode of a window, use\nWindowBase.SetFullscreenMode().\n\nOn some windowing systems, this request is asynchronous and the new window\nsize may not have have been applied immediately upon the return of this\nfunction. If an immediate change is required, call WindowBase.Sync() to\nblock until the changes have taken effect.\n\nWhen the window size changes, an EVENT_WINDOW_RESIZED event will be\nemitted with the new window dimensions. Note that the new dimensions may\nnot match the exact size requested, as some windowing systems can restrict\nthe window size in certain scenarios (e.g. constraining the size of the\ncontent area to remain within the usable desktop bounds). Additionally, as\nthis is just a request, it can be denied by the windowing system.\n\n@param window the window to change.\n@param w the width of the window, must be > 0.\n@param h the height of the window, must be > 0.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetSize\n@sa WindowBase.SetFullscreenMode\n@sa WindowBase.Sync",
              "name": "SetSize",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "p",
                  "type": "SDL_Point"
                }
              ],
              "sourceName": "SDL_SetWindowSize",
              "static": false
            },
            "GetSize": [
              {
                "kind": "function",
                "type": "std::optional<Point>",
                "immutable": true,
                "parameters": [],
                "name": "GetSize",
                "doc": ""
              },
              {
                "doc": "Get the size of a window's client area.\n\nThe window pixel size may differ from its window coordinate size if the\nwindow is on a high pixel density display. Use WindowBase.GetSizeInPixels()\nor RendererBase.GetOutputSize() to get the real client area size in pixels.\n\n@param w a pointer filled in with the width of the window, may be nullptr.\n@param h a pointer filled in with the height of the window, may be nullptr.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.GetOutputSize\n@sa WindowBase.GetSizeInPixels\n@sa WindowBase.SetSize",
                "name": "GetSize",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "w",
                    "type": "int *"
                  },
                  {
                    "name": "h",
                    "type": "int *"
                  }
                ],
                "sourceName": "SDL_GetWindowSize",
                "immutable": true
              }
            ],
            "GetSafeArea": {
              "doc": "Get the safe area for this window.\n\nSome devices have portions of the screen which are partially obscured or\nnot interactive, possibly due to on-screen controls, curved edges, camera\nnotches, TV overscan, etc. This function provides the area of the window\nwhich is safe to have interactable content. You should continue rendering\ninto the rest of the window, but it should not contain visually important\nor interactible content.\n\n@param window the window to query.\n@param rect a pointer filled in with the client area that is safe for\n            interactive content.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetSafeArea",
              "kind": "function",
              "type": "std::optional<Rect>",
              "parameters": [],
              "sourceName": "SDL_GetWindowSafeArea",
              "immutable": true
            },
            "SetAspectRatio": {
              "doc": "Request that the aspect ratio of a window's client area be set.\n\nThe aspect ratio is the ratio of width divided by height, e.g. 2560x1600\nwould be 1.6. Larger aspect ratios are wider and smaller aspect ratios are\nnarrower.\n\nIf, at the time of this request, the window in a fixed-size state, such as\nmaximized or fullscreen, the request will be deferred until the window\nexits this state and becomes resizable again.\n\nOn some windowing systems, this request is asynchronous and the new window\naspect ratio may not have have been applied immediately upon the return of\nthis function. If an immediate change is required, call WindowBase.Sync() to\nblock until the changes have taken effect.\n\nWhen the window size changes, an EVENT_WINDOW_RESIZED event will be\nemitted with the new window dimensions. Note that the new dimensions may\nnot match the exact aspect ratio requested, as some windowing systems can\nrestrict the window size in certain scenarios (e.g. constraining the size\nof the content area to remain within the usable desktop bounds).\nAdditionally, as this is just a request, it can be denied by the windowing\nsystem.\n\n@param min_aspect the minimum aspect ratio of the window, or 0.0f for no\n                  limit.\n@param max_aspect the maximum aspect ratio of the window, or 0.0f for no\n                  limit.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetAspectRatio\n@sa WindowBase.Sync",
              "name": "SetAspectRatio",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "min_aspect",
                  "type": "float"
                },
                {
                  "name": "max_aspect",
                  "type": "float"
                }
              ],
              "sourceName": "SDL_SetWindowAspectRatio"
            },
            "GetAspectRatio": {
              "doc": "Get the size of a window's client area.\n\n@param min_aspect a pointer filled in with the minimum aspect ratio of the\n                  window, may be nullptr.\n@param max_aspect a pointer filled in with the maximum aspect ratio of the\n                  window, may be nullptr.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.SetAspectRatio",
              "name": "GetAspectRatio",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "min_aspect",
                  "type": "float *"
                },
                {
                  "name": "max_aspect",
                  "type": "float *"
                }
              ],
              "sourceName": "SDL_GetWindowAspectRatio",
              "immutable": true
            },
            "GetBordersSize": {
              "doc": "Get the size of a window's borders (decorations) around the client area.\n\nNote: If this function fails (returns false), the size values will be\ninitialized to 0, 0, 0, 0 (if a non-nullptr pointer is provided), as if the\nwindow in question was borderless.\n\nNote: This function may fail on systems where the window has not yet been\ndecorated by the display server (for example, immediately after calling\nWindowBase.WindowBase). It is recommended that you wait at least until the\nwindow has been presented and composited, so that the window system has a\nchance to decorate the window and provide the border dimensions to SDL.\n\nThis function also returns false if getting the information is not\nsupported.\n\n              (decorations) from.\n@param top pointer to variable for storing the size of the top border; nullptr\n           is permitted.\n@param left pointer to variable for storing the size of the left border;\n            nullptr is permitted.\n@param bottom pointer to variable for storing the size of the bottom\n              border; nullptr is permitted.\n@param right pointer to variable for storing the size of the right border;\n             nullptr is permitted.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetSize",
              "name": "GetBordersSize",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "top",
                  "type": "int *"
                },
                {
                  "name": "left",
                  "type": "int *"
                },
                {
                  "name": "bottom",
                  "type": "int *"
                },
                {
                  "name": "right",
                  "type": "int *"
                }
              ],
              "sourceName": "SDL_GetWindowBordersSize",
              "immutable": true
            },
            "GetSizeInPixels": [
              {
                "kind": "function",
                "type": "std::optional<Point>",
                "immutable": true,
                "parameters": [],
                "name": "GetSizeInPixels",
                "doc": ""
              },
              {
                "doc": "Get the size of a window's client area, in pixels.\n\n@param w a pointer to variable for storing the width in pixels, may be\n         nullptr.\n@param h a pointer to variable for storing the height in pixels, may be\n         nullptr.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.WindowBase\n@sa WindowBase.GetSize",
                "name": "GetSizeInPixels",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "w",
                    "type": "int *"
                  },
                  {
                    "name": "h",
                    "type": "int *"
                  }
                ],
                "sourceName": "SDL_GetWindowSizeInPixels",
                "immutable": true
              }
            ],
            "SetMinimumSize": {
              "doc": "Set the minimum size of a window's client area.\n\n@param window the window to change.\n@param min_w the minimum width of the window, or 0 for no limit.\n@param min_h the minimum height of the window, or 0 for no limit.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetMinimumSize\n@sa WindowBase.SetMaximumSize",
              "name": "SetMinimumSize",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "p",
                  "type": "SDL_Point"
                }
              ],
              "sourceName": "SDL_SetWindowMinimumSize",
              "static": false
            },
            "GetMinimumSize": {
              "doc": "Get the minimum size of a window's client area.\n\n@param w a pointer filled in with the minimum width of the window, may be\n         nullptr.\n@param h a pointer filled in with the minimum height of the window, may be\n         nullptr.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetMaximumSize\n@sa WindowBase.SetMinimumSize",
              "name": "GetMinimumSize",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "w",
                  "type": "int *"
                },
                {
                  "name": "h",
                  "type": "int *"
                }
              ],
              "sourceName": "SDL_GetWindowMinimumSize",
              "immutable": true
            },
            "SetMaximumSize": {
              "doc": "Set the maximum size of a window's client area.\n\n@param window the window to change.\n@param max_w the maximum width of the window, or 0 for no limit.\n@param max_h the maximum height of the window, or 0 for no limit.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetMaximumSize\n@sa WindowBase.SetMinimumSize",
              "name": "SetMaximumSize",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "p",
                  "type": "SDL_Point"
                }
              ],
              "sourceName": "SDL_SetWindowMaximumSize",
              "static": false
            },
            "GetMaximumSize": {
              "doc": "Get the maximum size of a window's client area.\n\n@param w a pointer filled in with the maximum width of the window, may be\n         nullptr.\n@param h a pointer filled in with the maximum height of the window, may be\n         nullptr.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetMinimumSize\n@sa WindowBase.SetMaximumSize",
              "name": "GetMaximumSize",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "w",
                  "type": "int *"
                },
                {
                  "name": "h",
                  "type": "int *"
                }
              ],
              "sourceName": "SDL_GetWindowMaximumSize",
              "immutable": true
            },
            "SetBordered": {
              "doc": "Set the border state of a window.\n\nThis will add or remove the window's `WINDOW_BORDERLESS` flag and add\nor remove the border from the actual window. This is a no-op if the\nwindow's border already matches the requested state.\n\nYou can't change the border state of a fullscreen window.\n\n@param bordered false to remove border, true to add border.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetFlags",
              "name": "SetBordered",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "bordered",
                  "type": "bool"
                }
              ],
              "sourceName": "SDL_SetWindowBordered"
            },
            "SetResizable": {
              "doc": "Set the user-resizable state of a window.\n\nThis will add or remove the window's `WINDOW_RESIZABLE` flag and\nallow/disallow user resizing of the window. This is a no-op if the window's\nresizable state already matches the requested state.\n\nYou can't change the resizable state of a fullscreen window.\n\n@param resizable true to allow resizing, false to disallow.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetFlags",
              "name": "SetResizable",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "resizable",
                  "type": "bool"
                }
              ],
              "sourceName": "SDL_SetWindowResizable"
            },
            "SetAlwaysOnTop": {
              "doc": "Set the window to always be above the others.\n\nThis will add or remove the window's `WINDOW_ALWAYS_ON_TOP` flag. This\nwill bring the window to the front and keep the window above the rest.\n\n@param on_top true to set the window always on top, false to disable.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetFlags",
              "name": "SetAlwaysOnTop",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "on_top",
                  "type": "bool"
                }
              ],
              "sourceName": "SDL_SetWindowAlwaysOnTop"
            },
            "Show": {
              "doc": "Show a window.\n\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.Hide\n@sa WindowBase.Raise",
              "name": "Show",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_ShowWindow"
            },
            "Hide": {
              "doc": "Hide a window.\n\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.Show\n@sa WINDOW_HIDDEN",
              "name": "Hide",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_HideWindow"
            },
            "Raise": {
              "doc": "Request that a window be raised above other windows and gain the input\nfocus.\n\nThe result of this request is subject to desktop window manager policy,\nparticularly if raising the requested window would result in stealing focus\nfrom another application. If the window is successfully raised and gains\ninput focus, an EVENT_WINDOW_FOCUS_GAINED event will be emitted, and\nthe window will have the WINDOW_INPUT_FOCUS flag set.\n\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "Raise",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_RaiseWindow"
            },
            "Maximize": {
              "doc": "Request that the window be made as large as possible.\n\nNon-resizable windows can't be maximized. The window must have the\nWINDOW_RESIZABLE flag set, or this will have no effect.\n\nOn some windowing systems this request is asynchronous and the new window\nstate may not have have been applied immediately upon the return of this\nfunction. If an immediate change is required, call WindowBase.Sync() to\nblock until the changes have taken effect.\n\nWhen the window state changes, an EVENT_WINDOW_MAXIMIZED event will be\nemitted. Note that, as this is just a request, the windowing system can\ndeny the state change.\n\nWhen maximizing a window, whether the constraints set via\nWindowBase.SetMaximumSize() are honored depends on the policy of the window\nmanager. Win32 and macOS enforce the constraints when maximizing, while X11\nand Wayland window managers may vary.\n\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.Minimize\n@sa WindowBase.Restore\n@sa WindowBase.Sync",
              "name": "Maximize",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_MaximizeWindow"
            },
            "Minimize": {
              "doc": "Request that the window be minimized to an iconic representation.\n\nIf the window is in a fullscreen state, this request has no direct effect.\nIt may alter the state the window is returned to when leaving fullscreen.\n\nOn some windowing systems this request is asynchronous and the new window\nstate may not have been applied immediately upon the return of this\nfunction. If an immediate change is required, call WindowBase.Sync() to\nblock until the changes have taken effect.\n\nWhen the window state changes, an EVENT_WINDOW_MINIMIZED event will be\nemitted. Note that, as this is just a request, the windowing system can\ndeny the state change.\n\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.Maximize\n@sa WindowBase.Restore\n@sa WindowBase.Sync",
              "name": "Minimize",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_MinimizeWindow"
            },
            "Restore": {
              "doc": "Request that the size and position of a minimized or maximized window be\nrestored.\n\nIf the window is in a fullscreen state, this request has no direct effect.\nIt may alter the state the window is returned to when leaving fullscreen.\n\nOn some windowing systems this request is asynchronous and the new window\nstate may not have have been applied immediately upon the return of this\nfunction. If an immediate change is required, call WindowBase.Sync() to\nblock until the changes have taken effect.\n\nWhen the window state changes, an EVENT_WINDOW_RESTORED event will be\nemitted. Note that, as this is just a request, the windowing system can\ndeny the state change.\n\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.Maximize\n@sa WindowBase.Minimize\n@sa WindowBase.Sync",
              "name": "Restore",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_RestoreWindow"
            },
            "SetFullscreen": {
              "doc": "Request that the window's fullscreen state be changed.\n\nBy default a window in fullscreen state uses borderless fullscreen desktop\nmode, but a specific exclusive display mode can be set using\nWindowBase.SetFullscreenMode().\n\nOn some windowing systems this request is asynchronous and the new\nfullscreen state may not have have been applied immediately upon the return\nof this function. If an immediate change is required, call WindowBase.Sync()\nto block until the changes have taken effect.\n\nWhen the window state changes, an EVENT_WINDOW_ENTER_FULLSCREEN or\nEVENT_WINDOW_LEAVE_FULLSCREEN event will be emitted. Note that, as this\nis just a request, it can be denied by the windowing system.\n\n@param fullscreen true for fullscreen mode, false for windowed mode.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetFullscreenMode\n@sa WindowBase.SetFullscreenMode\n@sa WindowBase.Sync\n@sa WINDOW_FULLSCREEN",
              "name": "SetFullscreen",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "fullscreen",
                  "type": "bool"
                }
              ],
              "sourceName": "SDL_SetWindowFullscreen"
            },
            "Sync": {
              "doc": "Block until any pending window state is finalized.\n\nOn asynchronous windowing systems, this acts as a synchronization barrier\nfor pending window state. It will attempt to wait until any pending window\nstate has been applied and is guaranteed to return within finite time. Note\nthat for how long it can potentially block depends on the underlying window\nsystem, as window state changes may involve somewhat lengthy animations\nthat must complete before the window is in its final requested state.\n\nOn windowing systems where changes are immediate, this does nothing.\n\n              applied.\n@returns true on success or false if the operation timed out before the\n         window was in the requested state.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.SetSize\n@sa WindowBase.SetPosition\n@sa WindowBase.SetFullscreen\n@sa WindowBase.Minimize\n@sa WindowBase.Maximize\n@sa WindowBase.Restore\n@sa SDL_HINT_VIDEO_SYNC_WINDOW_OPERATIONS",
              "name": "Sync",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_SyncWindow"
            },
            "GetRenderer": {
              "kind": "function",
              "type": "RendererRef",
              "immutable": true,
              "parameters": [],
              "name": "GetRenderer",
              "doc": ""
            },
            "HasSurface": {
              "doc": "Return whether the window has a surface associated with it.\n\n@returns true if there is a surface associated with the window, or false\n         otherwise.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetSurface",
              "name": "HasSurface",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_WindowHasSurface",
              "immutable": true
            },
            "GetSurface": {
              "doc": "Get the SDL surface associated with the window.\n\nA new surface will be created with the optimal format for the window, if\nnecessary. This surface will be freed when the window is destroyed. Do not\nfree this surface.\n\nThis surface will be invalidated if the window is resized. After resizing a\nwindow this function must be called again to return a valid surface.\n\nYou may not combine this with 3D or the rendering API on this window.\n\nThis function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.\n\n@returns the surface associated with the window, or nullptr on failure; call\n         GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.DestroySurface\n@sa WindowBase.HasSurface\n@sa WindowBase.UpdateSurface\n@sa WindowBase.UpdateSurfaceRects",
              "name": "GetSurface",
              "kind": "function",
              "type": "SurfaceRef",
              "parameters": [],
              "sourceName": "SDL_GetWindowSurface"
            },
            "SetSurfaceVSync": {
              "doc": "Toggle VSync for the window surface.\n\nWhen a window surface is created, vsync defaults to\nSDL_WINDOW_SURFACE_VSYNC_DISABLED.\n\nThe `vsync` parameter can be 1 to synchronize present with every vertical\nrefresh, 2 to synchronize present with every second vertical refresh, etc.,\nSDL_WINDOW_SURFACE_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync),\nor SDL_WINDOW_SURFACE_VSYNC_DISABLED to disable. Not every value is\nsupported by every driver, so you should check the return value to see\nwhether the requested setting is supported.\n\n@param vsync the vertical refresh sync interval.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetSurfaceVSync",
              "name": "SetSurfaceVSync",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "vsync",
                  "type": "int"
                }
              ],
              "sourceName": "SDL_SetWindowSurfaceVSync"
            },
            "GetSurfaceVSync": {
              "doc": "Get VSync for the window surface.\n\n@param window the window to query.\n@param vsync an int filled with the current vertical refresh sync interval.\n             See WindowBase.SetSurfaceVSync() for the meaning of the value.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.SetSurfaceVSync",
              "name": "GetSurfaceVSync",
              "kind": "function",
              "type": "std::optional<int>",
              "parameters": [],
              "sourceName": "SDL_GetWindowSurfaceVSync",
              "immutable": true
            },
            "UpdateSurface": {
              "doc": "Copy the window surface to the screen.\n\nThis is the function you use to reflect any changes to the surface on the\nscreen.\n\nThis function is equivalent to the SDL 1.2 API SDL_Flip().\n\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetSurface\n@sa WindowBase.UpdateSurfaceRects",
              "name": "UpdateSurface",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_UpdateWindowSurface"
            },
            "UpdateSurfaceRects": {
              "doc": "Copy areas of the window surface to the screen.\n\nThis is the function you use to reflect changes to portions of the surface\non the screen.\n\nThis function is equivalent to the SDL 1.2 API SDL_UpdateRects().\n\nNote that this function will update _at least_ the rectangles specified,\nbut this is only intended as an optimization; in practice, this might\nupdate more of the screen (or all of the screen!), depending on what method\nSDL uses to send pixels to the system.\n\n@param rects an array of Rect structures representing areas of the\n             surface to copy, in pixels.\n@param numrects the number of rectangles.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetSurface\n@sa WindowBase.UpdateSurface",
              "name": "UpdateSurfaceRects",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "rects",
                  "type": "SpanRef<const SDL_Rect>"
                }
              ],
              "sourceName": "SDL_UpdateWindowSurfaceRects"
            },
            "DestroySurface": {
              "doc": "Destroy the surface associated with the window.\n\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetSurface\n@sa WindowBase.HasSurface",
              "name": "DestroySurface",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_DestroyWindowSurface"
            },
            "SetKeyboardGrab": {
              "doc": "Set a window's keyboard grab mode.\n\nKeyboard grab enables capture of system keyboard shortcuts like Alt+Tab or\nthe Meta/Super key. Note that not all system keyboard shortcuts can be\ncaptured by applications (one example is Ctrl+Alt+Del on Windows).\n\nThis is primarily intended for specialized applications such as VNC clients\nor VM frontends. Normal games should not use keyboard grab.\n\nWhen keyboard grab is enabled, SDL will continue to handle Alt+Tab when the\nwindow is full-screen to ensure the user is not trapped in your\napplication. If you have a custom keyboard shortcut to exit fullscreen\nmode, you may suppress this behavior with\n`SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.\n\nIf the caller enables a grab while another window is currently grabbed, the\nother window loses its grab in favor of the caller's window.\n\n@param grabbed this is true to grab keyboard, and false to release.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetKeyboardGrab\n@sa WindowBase.SetMouseGrab",
              "name": "SetKeyboardGrab",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "grabbed",
                  "type": "bool"
                }
              ],
              "sourceName": "SDL_SetWindowKeyboardGrab"
            },
            "SetMouseGrab": {
              "doc": "Set a window's mouse grab mode.\n\nMouse grab confines the mouse cursor to the window.\n\n@param grabbed this is true to grab mouse, and false to release.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetMouseRect\n@sa WindowBase.SetMouseRect\n@sa WindowBase.SetMouseGrab\n@sa WindowBase.SetKeyboardGrab",
              "name": "SetMouseGrab",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "grabbed",
                  "type": "bool"
                }
              ],
              "sourceName": "SDL_SetWindowMouseGrab"
            },
            "GetKeyboardGrab": {
              "doc": "Get a window's keyboard grab mode.\n\n@returns true if keyboard is grabbed, and false otherwise.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.SetKeyboardGrab",
              "name": "GetKeyboardGrab",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_GetWindowKeyboardGrab",
              "immutable": true
            },
            "GetMouseGrab": {
              "doc": "Get a window's mouse grab mode.\n\n@returns true if mouse is grabbed, and false otherwise.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetMouseRect\n@sa WindowBase.SetMouseRect\n@sa WindowBase.SetMouseGrab\n@sa WindowBase.SetKeyboardGrab",
              "name": "GetMouseGrab",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_GetWindowMouseGrab",
              "immutable": true
            },
            "SetMouseRect": {
              "doc": "Confines the cursor to the specified area of a window.\n\nNote that this does NOT grab the cursor, it only defines the area a cursor\nis restricted to when the window has mouse focus.\n\n@param rect a rectangle area in window-relative coordinates. If nullptr the\n            barrier for the specified window will be destroyed.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetMouseRect\n@sa WindowBase.GetMouseGrab\n@sa WindowBase.SetMouseGrab",
              "name": "SetMouseRect",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "rect",
                  "type": "const SDL_Rect &"
                }
              ],
              "sourceName": "SDL_SetWindowMouseRect"
            },
            "GetMouseRect": {
              "doc": "Get the mouse confinement rectangle of a window.\n\n@returns a pointer to the mouse confinement rectangle of a window, or nullptr\n         if there isn't one.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.SetMouseRect\n@sa WindowBase.GetMouseGrab\n@sa WindowBase.SetMouseGrab",
              "name": "GetMouseRect",
              "kind": "function",
              "type": "const Rect *",
              "parameters": [],
              "sourceName": "SDL_GetWindowMouseRect",
              "immutable": true
            },
            "SetOpacity": {
              "doc": "Set the opacity for a window.\n\nThe parameter `opacity` will be clamped internally between 0.0f\n(transparent) and 1.0f (opaque).\n\nThis function also returns false if setting the opacity isn't supported.\n\n@param opacity the opacity value (0.0f - transparent, 1.0f - opaque).\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetOpacity",
              "name": "SetOpacity",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "opacity",
                  "type": "float"
                }
              ],
              "sourceName": "SDL_SetWindowOpacity"
            },
            "GetOpacity": {
              "doc": "Get the opacity of a window.\n\nIf transparency isn't supported on this platform, opacity will be returned\nas 1.0f without error.\n\n@returns the opacity, (0.0f - transparent, 1.0f - opaque), or -1.0f on\n         failure; call GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.SetOpacity",
              "name": "GetOpacity",
              "kind": "function",
              "type": "float",
              "parameters": [],
              "sourceName": "SDL_GetWindowOpacity",
              "immutable": true
            },
            "SetParent": {
              "doc": "Set the window as a child of a parent window.\n\nIf the window is already the child of an existing window, it will be\nreparented to the new owner. Setting the parent window to nullptr unparents\nthe window and removes child window status.\n\nIf a parent window is hidden or destroyed, the operation will be\nrecursively applied to child windows. Child windows hidden with the parent\nthat did not have their hidden status explicitly set will be restored when\nthe parent is shown.\n\nAttempting to set the parent of a window that is currently in the modal\nstate will fail. Use WindowBase.SetModal() to cancel the modal status before\nattempting to change the parent.\n\nPopup windows cannot change parents and attempts to do so will fail.\n\nSetting a parent window that is currently the sibling or descendent of the\nchild window results in undefined behavior.\n\n@param parent the new parent window for the child window.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.SetModal",
              "name": "SetParent",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "parent",
                  "type": "WindowRef"
                }
              ],
              "sourceName": "SDL_SetWindowParent"
            },
            "SetModal": {
              "doc": "Toggle the state of the window as modal.\n\nTo enable modal status on a window, the window must currently be the child\nwindow of a parent, or toggling modal status on will fail.\n\n@param modal true to toggle modal status on, false to toggle it off.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.SetParent\n@sa WINDOW_MODAL",
              "name": "SetModal",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "modal",
                  "type": "bool"
                }
              ],
              "sourceName": "SDL_SetWindowModal"
            },
            "SetFocusable": {
              "doc": "Set whether the window may have input focus.\n\n@param focusable true to allow input focus, false to not allow input focus.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "SetFocusable",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "focusable",
                  "type": "bool"
                }
              ],
              "sourceName": "SDL_SetWindowFocusable"
            },
            "ShowSystemMenu": {
              "doc": "Display the system-level window menu.\n\nThis default window menu is provided by the system and on some platforms\nprovides functionality for setting or changing privileged state on the\nwindow, such as moving it between workspaces or displays, or toggling the\nalways-on-top property.\n\nOn platforms or desktops where this is unsupported, this function does\nnothing.\n\n@param window the window for which the menu will be displayed.\n@param x the x coordinate of the menu, relative to the origin (top-left) of\n         the client area.\n@param y the y coordinate of the menu, relative to the origin (top-left) of\n         the client area.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "ShowSystemMenu",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "p",
                  "type": "SDL_Point"
                }
              ],
              "sourceName": "SDL_ShowWindowSystemMenu",
              "static": false
            },
            "SetHitTest": [
              {
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "callback",
                    "type": "HitTestCB"
                  }
                ],
                "name": "SetHitTest",
                "doc": ""
              },
              {
                "doc": "Provide a callback that decides if a window region has special properties.\n\nNormally windows are dragged and resized by decorations provided by the\nsystem window manager (a title bar, borders, etc), but for some apps, it\nmakes sense to drag them from somewhere else inside the window itself; for\nexample, one might have a borderless window that wants to be draggable from\nany part, or simulate its own title bar, etc.\n\nThis function lets the app provide a callback that designates pieces of a\ngiven window as special. This callback is run during event processing if we\nneed to tell the OS to treat a region of the window specially; the use of\nthis callback is known as \"hit testing.\"\n\nMouse input may not be delivered to your application if it is within a\nspecial area; the OS will often apply that input to moving the window or\nresizing the window and not deliver it to the application.\n\nSpecifying nullptr for a callback disables hit-testing. Hit-testing is\ndisabled by default.\n\nPlatforms that don't support this functionality will return false\nunconditionally, even if you're attempting to disable hit-testing.\n\nYour callback may fire at any time, and its firing does not indicate any\nspecific behavior (for example, on Windows, this certainly might fire when\nthe OS is deciding whether to drag your window, but it fires for lots of\nother reasons, too, some unrelated to anything you probably care about _and\nwhen the mouse isn't actually at the location it is testing_). Since this\ncan fire at any time, you should try to keep your callback efficient,\ndevoid of allocations, etc.\n\n@param callback the function to call when doing a hit-test.\n@param callback_data an app-defined void pointer passed to **callback**.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
                "name": "SetHitTest",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "callback",
                    "type": "HitTest"
                  },
                  {
                    "name": "callback_data",
                    "type": "void *"
                  }
                ],
                "sourceName": "SDL_SetWindowHitTest"
              }
            ],
            "SetShape": {
              "doc": "Set the shape of a transparent window.\n\nThis sets the alpha channel of a transparent window and any fully\ntransparent areas are also transparent to mouse clicks. If you are using\nsomething besides the SDL render API, then you are responsible for drawing\nthe alpha channel of the window to match the shape alpha channel to get\nconsistent cross-platform results.\n\nThe shape is copied inside this function, so you can free it afterwards. If\nyour shape surface changes, you should call WindowBase.SetShape() again to\nupdate the window. This is an expensive operation, so should be done\nsparingly.\n\nThe window must have been created with the WINDOW_TRANSPARENT flag.\n\n@param shape the surface representing the shape of the window, or nullptr to\n             remove any current shape.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "SetShape",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "shape",
                  "type": "SurfaceRef"
                }
              ],
              "sourceName": "SDL_SetWindowShape"
            },
            "Flash": {
              "doc": "Request a window to demand attention from the user.\n\n@param operation the operation to perform.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "Flash",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "operation",
                  "type": "FlashOperation"
                }
              ],
              "sourceName": "SDL_FlashWindow"
            },
            "StartTextInput": [
              {
                "kind": "function",
                "type": "bool",
                "parameters": [],
                "name": "StartTextInput",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "type": "PropertiesRef",
                    "name": "props"
                  }
                ],
                "name": "StartTextInput",
                "doc": ""
              }
            ],
            "IsTextInputActive": {
              "kind": "function",
              "immutable": true,
              "type": "bool",
              "parameters": [],
              "name": "IsTextInputActive",
              "doc": ""
            },
            "StopTextInput": {
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "name": "StopTextInput",
              "doc": ""
            },
            "ClearComposition": {
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "name": "ClearComposition",
              "doc": ""
            },
            "SetTextInputArea": {
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "type": "const SDL_Rect &",
                  "name": "rect"
                },
                {
                  "type": "int",
                  "name": "cursor"
                }
              ],
              "name": "SetTextInputArea",
              "doc": ""
            },
            "GetTextInputArea": {
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "type": "SDL_Rect *",
                  "name": "rect"
                },
                {
                  "type": "int *",
                  "name": "cursor"
                }
              ],
              "name": "GetTextInputArea",
              "doc": ""
            },
            "Destroy": {
              "doc": "Destroy a window.\n\nAny child windows owned by the window will be recursively destroyed as\nwell.\n\nNote that on some platforms, the visible window may not actually be removed\nfrom the screen until the SDL event loop is pumped again, even though the\nWindowBase is no longer valid after this call.\n\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.WindowBase\n@sa WindowBase.WindowBase\n@sa WindowBase.WindowBase",
              "name": "Destroy",
              "kind": "function",
              "type": "void",
              "parameters": [],
              "sourceName": "SDL_DestroyWindow"
            }
          }
        },
        "ObjectRef<SDL_Window>::doFree": {
          "name": "ObjectRef<SDL_Window>::doFree",
          "type": "void",
          "kind": "function",
          "doc": "Callback for window resource cleanup\n\n@private",
          "template": [],
          "parameters": [
            {
              "type": "SDL_Window *",
              "name": "resource"
            }
          ],
          "sourceName": "SDL_DestroyWindow"
        },
        "SDL_WINDOWPOS_UNDEFINED_MASK": {
          "doc": "A magic value used with SDL_WINDOWPOS_UNDEFINED.\n\nGenerally this macro isn't used directly, but rather through\nSDL_WINDOWPOS_UNDEFINED or SDL_WINDOWPOS_UNDEFINED_DISPLAY.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_WINDOWPOS_UNDEFINED_MASK",
          "kind": "def",
          "value": "0x1FFF0000u",
          "sourceName": "SDL_WINDOWPOS_UNDEFINED_MASK"
        },
        "SDL_WINDOWPOS_UNDEFINED_DISPLAY": {
          "doc": "Used to indicate that you don't care what the window position is.\n\nIf you _really_ don't care, SDL_WINDOWPOS_UNDEFINED is the same, but always\nuses the primary display instead of specifying one.\n\n@param X the Display of the display to use.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_WINDOWPOS_UNDEFINED_DISPLAY",
          "kind": "def",
          "parameters": [
            "X"
          ],
          "value": "(SDL_WINDOWPOS_UNDEFINED_MASK|(X))",
          "sourceName": "SDL_WINDOWPOS_UNDEFINED_DISPLAY"
        },
        "SDL_WINDOWPOS_UNDEFINED": {
          "doc": "Used to indicate that you don't care what the window position/display is.\n\nThis always uses the primary display.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_WINDOWPOS_UNDEFINED",
          "kind": "def",
          "value": "SDL_WINDOWPOS_UNDEFINED_DISPLAY(0)",
          "sourceName": "SDL_WINDOWPOS_UNDEFINED"
        },
        "SDL_WINDOWPOS_ISUNDEFINED": {
          "doc": "A macro to test if the window position is marked as \"undefined.\"\n\n@param X the window position value.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_WINDOWPOS_ISUNDEFINED",
          "kind": "def",
          "parameters": [
            "X"
          ],
          "value": "(((X)&0xFFFF0000) == SDL_WINDOWPOS_UNDEFINED_MASK)",
          "sourceName": "SDL_WINDOWPOS_ISUNDEFINED"
        },
        "SDL_WINDOWPOS_CENTERED_MASK": {
          "doc": "A magic value used with SDL_WINDOWPOS_CENTERED.\n\nGenerally this macro isn't used directly, but rather through\nSDL_WINDOWPOS_CENTERED or SDL_WINDOWPOS_CENTERED_DISPLAY.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_WINDOWPOS_CENTERED_MASK",
          "kind": "def",
          "value": "0x2FFF0000u",
          "sourceName": "SDL_WINDOWPOS_CENTERED_MASK"
        },
        "SDL_WINDOWPOS_CENTERED_DISPLAY": {
          "doc": "Used to indicate that the window position should be centered.\n\nSDL_WINDOWPOS_CENTERED is the same, but always uses the primary display\ninstead of specifying one.\n\n@param X the Display of the display to use.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_WINDOWPOS_CENTERED_DISPLAY",
          "kind": "def",
          "parameters": [
            "X"
          ],
          "value": "(SDL_WINDOWPOS_CENTERED_MASK|(X))",
          "sourceName": "SDL_WINDOWPOS_CENTERED_DISPLAY"
        },
        "SDL_WINDOWPOS_CENTERED": {
          "doc": "Used to indicate that the window position should be centered.\n\nThis always uses the primary display.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_WINDOWPOS_CENTERED",
          "kind": "def",
          "value": "SDL_WINDOWPOS_CENTERED_DISPLAY(0)",
          "sourceName": "SDL_WINDOWPOS_CENTERED"
        },
        "SDL_WINDOWPOS_ISCENTERED": {
          "doc": "A macro to test if the window position is marked as \"centered.\"\n\n@param X the window position value.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_WINDOWPOS_ISCENTERED",
          "kind": "def",
          "parameters": [
            "X"
          ],
          "value": "            (((X)&0xFFFF0000) == SDL_WINDOWPOS_CENTERED_MASK)",
          "sourceName": "SDL_WINDOWPOS_ISCENTERED"
        },
        "GLContextBase": {
          "doc": "An opaque handle to an OpenGL context.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa GLContextBase.GLContextBase",
          "name": "GLContextBase",
          "kind": "struct",
          "type": "T",
          "sourceName": "SDL_GLContext",
          "template": [
            {
              "type": "ObjectBox<SDL_GLContextState *>",
              "name": "T"
            }
          ],
          "entries": {
            "T::T": {
              "kind": "alias",
              "name": "T::T",
              "doc": ""
            },
            "GLContextBase": {
              "doc": "Create an OpenGL context for an OpenGL window, and make it current.\n\nWindows users new to OpenGL should note that, for historical reasons, GL\nfunctions added after OpenGL version 1.1 are not available by default.\nThose functions must be loaded at run-time, either with an OpenGL\nextension-handling library or with GL_GetProcAddress() and its related\nfunctions.\n\nGLContextBase is opaque to the application.\n\n@param window the window to associate with the context.\n@post the OpenGL context associated with `window` or nullptr on failure;\n         call GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GLContextBase.Destroy\n@sa GLContextBase.MakeCurrent",
              "name": "GLContextBase",
              "kind": "function",
              "type": "",
              "parameters": [
                {
                  "name": "window",
                  "type": "WindowRef"
                }
              ],
              "sourceName": "SDL_GL_CreateContext"
            },
            "MakeCurrent": {
              "doc": "Set up an OpenGL context for rendering into an OpenGL window.\n\nThe context must have been created with a compatible window.\n\n@param window the window to associate with the context.\n@param context the OpenGL context to associate with the window.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GLContextBase.GLContextBase",
              "name": "MakeCurrent",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "window",
                  "type": "WindowRef"
                }
              ],
              "sourceName": "SDL_GL_MakeCurrent",
              "static": false
            },
            "Destroy": {
              "doc": "Delete an OpenGL context.\n\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GLContextBase.GLContextBase",
              "name": "Destroy",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_GL_DestroyContext"
            }
          }
        },
        "EGLDisplay": {
          "doc": "Opaque type for an EGL display.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "EGLDisplay",
          "kind": "alias",
          "type": "SDL_EGLDisplay",
          "sourceName": "SDL_EGLDisplay"
        },
        "EGLConfig": {
          "doc": "Opaque type for an EGL config.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "EGLConfig",
          "kind": "alias",
          "type": "SDL_EGLConfig",
          "sourceName": "SDL_EGLConfig"
        },
        "EGLSurface": {
          "doc": "Opaque type for an EGL surface.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "EGLSurface",
          "kind": "alias",
          "type": "SDL_EGLSurface",
          "sourceName": "SDL_EGLSurface"
        },
        "EGLAttrib": {
          "doc": "An EGL attribute, used when creating an EGL context.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "EGLAttrib",
          "kind": "alias",
          "type": "SDL_EGLAttrib",
          "sourceName": "SDL_EGLAttrib"
        },
        "EGLint": {
          "doc": "An EGL integer attribute, used when creating an EGL surface.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "EGLint",
          "kind": "alias",
          "type": "SDL_EGLint",
          "sourceName": "SDL_EGLint"
        },
        "EGLAttribArrayCallback": {
          "doc": "EGL platform attribute initialization callback.\n\nThis is called when SDL is attempting to create an EGL context, to let the\napp add extra attributes to its eglGetPlatformDisplay() call.\n\nThe callback should return a pointer to an EGL attribute array terminated\nwith `EGL_NONE`. If this function returns nullptr, the WindowBase.WindowBase\nprocess will fail gracefully.\n\nThe returned pointer should be allocated with malloc() and will be\npassed to free().\n\nThe arrays returned by each callback will be appended to the existing\nattribute arrays defined by SDL.\n\n@param userdata an app-controlled pointer that is passed to the callback.\n@returns a newly-allocated array of attributes, terminated with `EGL_NONE`.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa EGL_SetAttributeCallbacks",
          "name": "EGLAttribArrayCallback",
          "kind": "alias",
          "type": "SDL_EGLAttribArrayCallback",
          "sourceName": "SDL_EGLAttribArrayCallback"
        },
        "EGLIntArrayCallback": {
          "doc": "EGL surface/context attribute initialization callback types.\n\nThis is called when SDL is attempting to create an EGL surface, to let the\napp add extra attributes to its eglCreateWindowSurface() or\neglCreateContext calls.\n\nFor convenience, the EGLDisplay and EGLConfig to use are provided to the\ncallback.\n\nThe callback should return a pointer to an EGL attribute array terminated\nwith `EGL_NONE`. If this function returns nullptr, the WindowBase.WindowBase\nprocess will fail gracefully.\n\nThe returned pointer should be allocated with malloc() and will be\npassed to free().\n\nThe arrays returned by each callback will be appended to the existing\nattribute arrays defined by SDL.\n\n@param userdata an app-controlled pointer that is passed to the callback.\n@param display the EGL display to be used.\n@param config the EGL config to be used.\n@returns a newly-allocated array of attributes, terminated with `EGL_NONE`.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa EGL_SetAttributeCallbacks",
          "name": "EGLIntArrayCallback",
          "kind": "alias",
          "type": "SDL_EGLIntArrayCallback",
          "sourceName": "SDL_EGLIntArrayCallback"
        },
        "GLAttr": {
          "doc": "An enumeration of OpenGL configuration attributes.\n\nWhile you can set most OpenGL attributes normally, the attributes listed\nabove must be known before SDL creates the window that will be used with\nthe OpenGL context. These attributes are set and read with\nGL_SetAttribute() and GL_GetAttribute().\n\nIn some cases, these attributes are minimum requests; the GL does not\npromise to give you exactly what you asked for. It's possible to ask for a\n16-bit depth buffer and get a 24-bit one instead, for example, or to ask\nfor no stencil buffer and still have one available. Context creation should\nfail if the GL can't provide your requested attributes at a minimum, but\nyou should check to see exactly what you got.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "GLAttr",
          "kind": "alias",
          "sourceName": "SDL_GLAttr",
          "type": "SDL_GLAttr"
        },
        "GL_RED_SIZE": {
          "doc": "the minimum number of bits for the red channel of the color buffer; defaults to 8.",
          "name": "GL_RED_SIZE",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_RED_SIZE",
          "constexpr": true
        },
        "GL_GREEN_SIZE": {
          "doc": "the minimum number of bits for the green channel of the color buffer; defaults to 8.",
          "name": "GL_GREEN_SIZE",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_GREEN_SIZE",
          "constexpr": true
        },
        "GL_BLUE_SIZE": {
          "doc": "the minimum number of bits for the blue channel of the color buffer; defaults to 8.",
          "name": "GL_BLUE_SIZE",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_BLUE_SIZE",
          "constexpr": true
        },
        "GL_ALPHA_SIZE": {
          "doc": "the minimum number of bits for the alpha channel of the color buffer; defaults to 8.",
          "name": "GL_ALPHA_SIZE",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_ALPHA_SIZE",
          "constexpr": true
        },
        "GL_BUFFER_SIZE": {
          "doc": "the minimum number of bits for frame buffer size; defaults to 0.",
          "name": "GL_BUFFER_SIZE",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_BUFFER_SIZE",
          "constexpr": true
        },
        "GL_DOUBLEBUFFER": {
          "doc": "whether the output is single or double buffered; defaults to double buffering on.",
          "name": "GL_DOUBLEBUFFER",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_DOUBLEBUFFER",
          "constexpr": true
        },
        "GL_DEPTH_SIZE": {
          "doc": "the minimum number of bits in the depth buffer; defaults to 16.",
          "name": "GL_DEPTH_SIZE",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_DEPTH_SIZE",
          "constexpr": true
        },
        "GL_STENCIL_SIZE": {
          "doc": "the minimum number of bits in the stencil buffer; defaults to 0.",
          "name": "GL_STENCIL_SIZE",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_STENCIL_SIZE",
          "constexpr": true
        },
        "GL_ACCUM_RED_SIZE": {
          "doc": "the minimum number of bits for the red channel of the accumulation buffer; defaults to 0.",
          "name": "GL_ACCUM_RED_SIZE",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_ACCUM_RED_SIZE",
          "constexpr": true
        },
        "GL_ACCUM_GREEN_SIZE": {
          "doc": "the minimum number of bits for the green channel of the accumulation buffer; defaults to 0.",
          "name": "GL_ACCUM_GREEN_SIZE",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_ACCUM_GREEN_SIZE",
          "constexpr": true
        },
        "GL_ACCUM_BLUE_SIZE": {
          "doc": "the minimum number of bits for the blue channel of the accumulation buffer; defaults to 0.",
          "name": "GL_ACCUM_BLUE_SIZE",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_ACCUM_BLUE_SIZE",
          "constexpr": true
        },
        "GL_ACCUM_ALPHA_SIZE": {
          "doc": "the minimum number of bits for the alpha channel of the accumulation buffer; defaults to 0.",
          "name": "GL_ACCUM_ALPHA_SIZE",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_ACCUM_ALPHA_SIZE",
          "constexpr": true
        },
        "GL_STEREO": {
          "doc": "whether the output is stereo 3D; defaults to off.",
          "name": "GL_STEREO",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_STEREO",
          "constexpr": true
        },
        "GL_MULTISAMPLEBUFFERS": {
          "doc": "the number of buffers used for multisample anti-aliasing; defaults to 0.",
          "name": "GL_MULTISAMPLEBUFFERS",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_MULTISAMPLEBUFFERS",
          "constexpr": true
        },
        "GL_MULTISAMPLESAMPLES": {
          "doc": "the number of samples used around the current pixel used for multisample anti-aliasing.",
          "name": "GL_MULTISAMPLESAMPLES",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_MULTISAMPLESAMPLES",
          "constexpr": true
        },
        "GL_ACCELERATED_VISUAL": {
          "doc": "set to 1 to require hardware acceleration, set to 0 to force software rendering; defaults to allow either.",
          "name": "GL_ACCELERATED_VISUAL",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_ACCELERATED_VISUAL",
          "constexpr": true
        },
        "GL_RETAINED_BACKING": {
          "doc": "not used (deprecated).",
          "name": "GL_RETAINED_BACKING",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_RETAINED_BACKING",
          "constexpr": true
        },
        "GL_CONTEXT_MAJOR_VERSION": {
          "doc": "OpenGL context major version.",
          "name": "GL_CONTEXT_MAJOR_VERSION",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_CONTEXT_MAJOR_VERSION",
          "constexpr": true
        },
        "GL_CONTEXT_MINOR_VERSION": {
          "doc": "OpenGL context minor version.",
          "name": "GL_CONTEXT_MINOR_VERSION",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_CONTEXT_MINOR_VERSION",
          "constexpr": true
        },
        "GL_CONTEXT_FLAGS": {
          "doc": "some combination of 0 or more of elements of the GLContextFlag enumeration; defaults to 0.",
          "name": "GL_CONTEXT_FLAGS",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_CONTEXT_FLAGS",
          "constexpr": true
        },
        "GL_CONTEXT_PROFILE_MASK": {
          "doc": "type of GL context (Core, Compatibility, ES).  See GLProfile; default value depends on platform.",
          "name": "GL_CONTEXT_PROFILE_MASK",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_CONTEXT_PROFILE_MASK",
          "constexpr": true
        },
        "GL_SHARE_WITH_CURRENT_CONTEXT": {
          "doc": "OpenGL context sharing; defaults to 0.",
          "name": "GL_SHARE_WITH_CURRENT_CONTEXT",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_SHARE_WITH_CURRENT_CONTEXT",
          "constexpr": true
        },
        "GL_FRAMEBUFFER_SRGB_CAPABLE": {
          "doc": "requests sRGB capable visual; defaults to 0.",
          "name": "GL_FRAMEBUFFER_SRGB_CAPABLE",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_FRAMEBUFFER_SRGB_CAPABLE",
          "constexpr": true
        },
        "GL_CONTEXT_RELEASE_BEHAVIOR": {
          "doc": "sets context the release behavior.  See GLContextReleaseFlag; defaults to FLUSH.",
          "name": "GL_CONTEXT_RELEASE_BEHAVIOR",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_CONTEXT_RELEASE_BEHAVIOR",
          "constexpr": true
        },
        "GL_CONTEXT_RESET_NOTIFICATION": {
          "doc": "set context reset notification.  See GLContextResetNotification; defaults to NO_NOTIFICATION.",
          "name": "GL_CONTEXT_RESET_NOTIFICATION",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_CONTEXT_RESET_NOTIFICATION",
          "constexpr": true
        },
        "GL_CONTEXT_NO_ERROR": {
          "doc": "",
          "name": "GL_CONTEXT_NO_ERROR",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_CONTEXT_NO_ERROR",
          "constexpr": true
        },
        "GL_FLOATBUFFERS": {
          "doc": "",
          "name": "GL_FLOATBUFFERS",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_FLOATBUFFERS",
          "constexpr": true
        },
        "GL_EGL_PLATFORM": {
          "doc": "",
          "name": "GL_EGL_PLATFORM",
          "kind": "var",
          "type": "GLAttr",
          "sourceName": "SDL_GL_EGL_PLATFORM",
          "constexpr": true
        },
        "GLProfile": {
          "doc": "Possible values to be set for the GL_CONTEXT_PROFILE_MASK attribute.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "GLProfile",
          "kind": "alias",
          "type": "SDL_GLProfile",
          "sourceName": "SDL_GLProfile"
        },
        "GL_CONTEXT_PROFILE_CORE": {
          "doc": "OpenGL Core Profile context",
          "name": "GL_CONTEXT_PROFILE_CORE",
          "kind": "var",
          "value": "0x0001",
          "sourceName": "SDL_GL_CONTEXT_PROFILE_CORE",
          "constexpr": true,
          "type": "GLProfile"
        },
        "GL_CONTEXT_PROFILE_COMPATIBILITY": {
          "doc": "OpenGL Compatibility Profile context",
          "name": "GL_CONTEXT_PROFILE_COMPATIBILITY",
          "kind": "var",
          "value": "0x0002",
          "sourceName": "SDL_GL_CONTEXT_PROFILE_COMPATIBILITY",
          "constexpr": true,
          "type": "GLProfile"
        },
        "GL_CONTEXT_PROFILE_ES": {
          "doc": "GLX_CONTEXT_ES2_PROFILE_BIT_EXT",
          "name": "GL_CONTEXT_PROFILE_ES",
          "kind": "var",
          "value": "0x0004",
          "sourceName": "SDL_GL_CONTEXT_PROFILE_ES",
          "constexpr": true,
          "type": "GLProfile"
        },
        "GLContextFlag": {
          "doc": "Possible flags to be set for the GL_CONTEXT_FLAGS attribute.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "GLContextFlag",
          "kind": "alias",
          "type": "SDL_GLContextFlag",
          "sourceName": "SDL_GLContextFlag"
        },
        "GL_CONTEXT_DEBUG_FLAG": {
          "doc": "",
          "name": "GL_CONTEXT_DEBUG_FLAG",
          "kind": "var",
          "value": "0x0001",
          "sourceName": "SDL_GL_CONTEXT_DEBUG_FLAG",
          "constexpr": true,
          "type": "GLContextFlag"
        },
        "GL_CONTEXT_FORWARD_COMPATIBLE_FLAG": {
          "doc": "",
          "name": "GL_CONTEXT_FORWARD_COMPATIBLE_FLAG",
          "kind": "var",
          "value": "0x0002",
          "sourceName": "SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG",
          "constexpr": true,
          "type": "GLContextFlag"
        },
        "GL_CONTEXT_ROBUST_ACCESS_FLAG": {
          "doc": "",
          "name": "GL_CONTEXT_ROBUST_ACCESS_FLAG",
          "kind": "var",
          "value": "0x0004",
          "sourceName": "SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG",
          "constexpr": true,
          "type": "GLContextFlag"
        },
        "GL_CONTEXT_RESET_ISOLATION_FLAG": {
          "doc": "",
          "name": "GL_CONTEXT_RESET_ISOLATION_FLAG",
          "kind": "var",
          "value": "0x0008",
          "sourceName": "SDL_GL_CONTEXT_RESET_ISOLATION_FLAG",
          "constexpr": true,
          "type": "GLContextFlag"
        },
        "GLContextReleaseFlag": {
          "doc": "Possible values to be set for the GL_CONTEXT_RELEASE_BEHAVIOR\nattribute.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "GLContextReleaseFlag",
          "kind": "alias",
          "type": "SDL_GLContextReleaseFlag",
          "sourceName": "SDL_GLContextReleaseFlag"
        },
        "GL_CONTEXT_RELEASE_BEHAVIOR_NONE": {
          "doc": "",
          "name": "GL_CONTEXT_RELEASE_BEHAVIOR_NONE",
          "kind": "var",
          "value": "0x0000",
          "sourceName": "SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE",
          "constexpr": true,
          "type": "GLContextReleaseFlag"
        },
        "GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH": {
          "doc": "",
          "name": "GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH",
          "kind": "var",
          "value": "0x0001",
          "sourceName": "SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH",
          "constexpr": true,
          "type": "GLContextReleaseFlag"
        },
        "GLContextResetNotification": {
          "doc": "Possible values to be set GL_CONTEXT_RESET_NOTIFICATION attribute.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "GLContextResetNotification",
          "kind": "alias",
          "type": "SDL_GLContextResetNotification",
          "sourceName": "SDL_GLContextResetNotification"
        },
        "GL_CONTEXT_RESET_NO_NOTIFICATION": {
          "doc": "",
          "name": "GL_CONTEXT_RESET_NO_NOTIFICATION",
          "kind": "var",
          "value": "0x0000",
          "sourceName": "SDL_GL_CONTEXT_RESET_NO_NOTIFICATION",
          "constexpr": true,
          "type": "GLContextResetNotification"
        },
        "GL_CONTEXT_RESET_LOSE_CONTEXT": {
          "doc": "",
          "name": "GL_CONTEXT_RESET_LOSE_CONTEXT",
          "kind": "var",
          "value": "0x0001",
          "sourceName": "SDL_GL_CONTEXT_RESET_LOSE_CONTEXT",
          "constexpr": true,
          "type": "GLContextResetNotification"
        },
        "GetNumVideoDrivers": {
          "doc": "Get the number of video drivers compiled into SDL.\n\n@returns the number of built in video drivers.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetVideoDriver",
          "name": "GetNumVideoDrivers",
          "kind": "function",
          "type": "int",
          "parameters": [],
          "sourceName": "SDL_GetNumVideoDrivers"
        },
        "GetVideoDriver": {
          "doc": "Get the name of a built in video driver.\n\nThe video drivers are presented in the order in which they are normally\nchecked during initialization.\n\nThe names of drivers are all simple, low-ASCII identifiers, like \"cocoa\",\n\"x11\" or \"windows\". These never have Unicode characters, and are not meant\nto be proper names.\n\n@param index the index of a video driver.\n@returns the name of the video driver with the given **index**.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetNumVideoDrivers",
          "name": "GetVideoDriver",
          "kind": "function",
          "type": "const char *",
          "parameters": [
            {
              "name": "index",
              "type": "int"
            }
          ],
          "sourceName": "SDL_GetVideoDriver"
        },
        "GetCurrentVideoDriver": {
          "doc": "Get the name of the currently initialized video driver.\n\nThe names of drivers are all simple, low-ASCII identifiers, like \"cocoa\",\n\"x11\" or \"windows\". These never have Unicode characters, and are not meant\nto be proper names.\n\n@returns the name of the current video driver or nullptr if no driver has been\n         initialized.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetNumVideoDrivers\n@sa GetVideoDriver",
          "name": "GetCurrentVideoDriver",
          "kind": "function",
          "type": "const char *",
          "parameters": [],
          "sourceName": "SDL_GetCurrentVideoDriver"
        },
        "GetSystemTheme": {
          "doc": "Get the current system theme.\n\n@returns the current system theme, light, dark, or unknown.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetSystemTheme",
          "kind": "function",
          "type": "SystemTheme",
          "parameters": [],
          "sourceName": "SDL_GetSystemTheme"
        },
        "prop::Display": {
          "kind": "ns",
          "name": "prop::Display",
          "entries": {
            "HDR_ENABLED_BOOLEAN": {
              "doc": "",
              "name": "HDR_ENABLED_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.display.HDR_enabled\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_DISPLAY_HDR_ENABLED_BOOLEAN"
            },
            "KMSDRM_PANEL_ORIENTATION_NUMBER": {
              "doc": "",
              "name": "KMSDRM_PANEL_ORIENTATION_NUMBER",
              "kind": "var",
              "value": "\"SDL.display.KMSDRM.panel_orientation\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_DISPLAY_KMSDRM_PANEL_ORIENTATION_NUMBER"
            }
          },
          "doc": ""
        },
        "GetWindows": {
          "doc": "Get a list of valid windows.\n\n@param count a pointer filled in with the number of windows returned, may\n             be nullptr.\n@returns a nullptr terminated array of WindowBase pointers or nullptr on failure;\n         call GetError() for more information. This is a single\n         allocation that should be freed with free() when it is no\n         longer needed.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetWindows",
          "kind": "function",
          "type": "OwnArray<WindowRef>",
          "parameters": [],
          "sourceName": "SDL_GetWindows"
        },
        "prop::Window": {
          "kind": "ns",
          "name": "prop::Window",
          "entries": {
            "CREATE_ALWAYS_ON_TOP_BOOLEAN": {
              "doc": "",
              "name": "CREATE_ALWAYS_ON_TOP_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.window.create.always_on_top\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_ALWAYS_ON_TOP_BOOLEAN"
            },
            "CREATE_BORDERLESS_BOOLEAN": {
              "doc": "",
              "name": "CREATE_BORDERLESS_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.window.create.borderless\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_BORDERLESS_BOOLEAN"
            },
            "CREATE_FOCUSABLE_BOOLEAN": {
              "doc": "",
              "name": "CREATE_FOCUSABLE_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.window.create.focusable\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_FOCUSABLE_BOOLEAN"
            },
            "CREATE_EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN": {
              "doc": "",
              "name": "CREATE_EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.window.create.external_graphics_context\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN"
            },
            "CREATE_FLAGS_NUMBER": {
              "doc": "",
              "name": "CREATE_FLAGS_NUMBER",
              "kind": "var",
              "value": "\"SDL.window.create.flags\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_FLAGS_NUMBER"
            },
            "CREATE_FULLSCREEN_BOOLEAN": {
              "doc": "",
              "name": "CREATE_FULLSCREEN_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.window.create.fullscreen\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_FULLSCREEN_BOOLEAN"
            },
            "CREATE_HEIGHT_NUMBER": {
              "doc": "",
              "name": "CREATE_HEIGHT_NUMBER",
              "kind": "var",
              "value": "\"SDL.window.create.height\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_HEIGHT_NUMBER"
            },
            "CREATE_HIDDEN_BOOLEAN": {
              "doc": "",
              "name": "CREATE_HIDDEN_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.window.create.hidden\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_HIDDEN_BOOLEAN"
            },
            "CREATE_HIGH_PIXEL_DENSITY_BOOLEAN": {
              "doc": "",
              "name": "CREATE_HIGH_PIXEL_DENSITY_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.window.create.high_pixel_density\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_HIGH_PIXEL_DENSITY_BOOLEAN"
            },
            "CREATE_MAXIMIZED_BOOLEAN": {
              "doc": "",
              "name": "CREATE_MAXIMIZED_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.window.create.maximized\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_MAXIMIZED_BOOLEAN"
            },
            "CREATE_MENU_BOOLEAN": {
              "doc": "",
              "name": "CREATE_MENU_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.window.create.menu\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_MENU_BOOLEAN"
            },
            "CREATE_METAL_BOOLEAN": {
              "doc": "",
              "name": "CREATE_METAL_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.window.create.metal\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_METAL_BOOLEAN"
            },
            "CREATE_MINIMIZED_BOOLEAN": {
              "doc": "",
              "name": "CREATE_MINIMIZED_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.window.create.minimized\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_MINIMIZED_BOOLEAN"
            },
            "CREATE_MODAL_BOOLEAN": {
              "doc": "",
              "name": "CREATE_MODAL_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.window.create.modal\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_MODAL_BOOLEAN"
            },
            "CREATE_MOUSE_GRABBED_BOOLEAN": {
              "doc": "",
              "name": "CREATE_MOUSE_GRABBED_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.window.create.mouse_grabbed\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_MOUSE_GRABBED_BOOLEAN"
            },
            "CREATE_OPENGL_BOOLEAN": {
              "doc": "",
              "name": "CREATE_OPENGL_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.window.create.opengl\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_OPENGL_BOOLEAN"
            },
            "CREATE_PARENT_POINTER": {
              "doc": "",
              "name": "CREATE_PARENT_POINTER",
              "kind": "var",
              "value": "\"SDL.window.create.parent\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_PARENT_POINTER"
            },
            "CREATE_RESIZABLE_BOOLEAN": {
              "doc": "",
              "name": "CREATE_RESIZABLE_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.window.create.resizable\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_RESIZABLE_BOOLEAN"
            },
            "CREATE_TITLE_STRING": {
              "doc": "",
              "name": "CREATE_TITLE_STRING",
              "kind": "var",
              "value": "\"SDL.window.create.title\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_TITLE_STRING"
            },
            "CREATE_TRANSPARENT_BOOLEAN": {
              "doc": "",
              "name": "CREATE_TRANSPARENT_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.window.create.transparent\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_TRANSPARENT_BOOLEAN"
            },
            "CREATE_TOOLTIP_BOOLEAN": {
              "doc": "",
              "name": "CREATE_TOOLTIP_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.window.create.tooltip\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_TOOLTIP_BOOLEAN"
            },
            "CREATE_UTILITY_BOOLEAN": {
              "doc": "",
              "name": "CREATE_UTILITY_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.window.create.utility\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_UTILITY_BOOLEAN"
            },
            "CREATE_VULKAN_BOOLEAN": {
              "doc": "",
              "name": "CREATE_VULKAN_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.window.create.vulkan\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_VULKAN_BOOLEAN"
            },
            "CREATE_WIDTH_NUMBER": {
              "doc": "",
              "name": "CREATE_WIDTH_NUMBER",
              "kind": "var",
              "value": "\"SDL.window.create.width\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_WIDTH_NUMBER"
            },
            "CREATE_X_NUMBER": {
              "doc": "",
              "name": "CREATE_X_NUMBER",
              "kind": "var",
              "value": "\"SDL.window.create.x\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_X_NUMBER"
            },
            "CREATE_Y_NUMBER": {
              "doc": "",
              "name": "CREATE_Y_NUMBER",
              "kind": "var",
              "value": "\"SDL.window.create.y\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_Y_NUMBER"
            },
            "CREATE_COCOA_WINDOW_POINTER": {
              "doc": "",
              "name": "CREATE_COCOA_WINDOW_POINTER",
              "kind": "var",
              "value": "\"SDL.window.create.cocoa.window\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_COCOA_WINDOW_POINTER"
            },
            "CREATE_COCOA_VIEW_POINTER": {
              "doc": "",
              "name": "CREATE_COCOA_VIEW_POINTER",
              "kind": "var",
              "value": "\"SDL.window.create.cocoa.view\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_COCOA_VIEW_POINTER"
            },
            "CREATE_WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN": {
              "doc": "",
              "name": "CREATE_WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.window.create.wayland.surface_role_custom\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN"
            },
            "CREATE_WAYLAND_CREATE_EGL_WINDOW_BOOLEAN": {
              "doc": "",
              "name": "CREATE_WAYLAND_CREATE_EGL_WINDOW_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.window.create.wayland.create_egl_window\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_WAYLAND_CREATE_EGL_WINDOW_BOOLEAN"
            },
            "CREATE_WAYLAND_WL_SURFACE_POINTER": {
              "doc": "",
              "name": "CREATE_WAYLAND_WL_SURFACE_POINTER",
              "kind": "var",
              "value": "\"SDL.window.create.wayland.wl_surface\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_WAYLAND_WL_SURFACE_POINTER"
            },
            "CREATE_WIN32_HWND_POINTER": {
              "doc": "",
              "name": "CREATE_WIN32_HWND_POINTER",
              "kind": "var",
              "value": "\"SDL.window.create.win32.hwnd\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_WIN32_HWND_POINTER"
            },
            "CREATE_WIN32_PIXEL_FORMAT_HWND_POINTER": {
              "doc": "",
              "name": "CREATE_WIN32_PIXEL_FORMAT_HWND_POINTER",
              "kind": "var",
              "value": "\"SDL.window.create.win32.pixel_format_hwnd\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_WIN32_PIXEL_FORMAT_HWND_POINTER"
            },
            "CREATE_X11_WINDOW_NUMBER": {
              "doc": "",
              "name": "CREATE_X11_WINDOW_NUMBER",
              "kind": "var",
              "value": "\"SDL.window.create.x11.window\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_CREATE_X11_WINDOW_NUMBER"
            },
            "SHAPE_POINTER": {
              "doc": "",
              "name": "SHAPE_POINTER",
              "kind": "var",
              "value": "\"SDL.window.shape\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_SHAPE_POINTER"
            },
            "HDR_ENABLED_BOOLEAN": {
              "doc": "",
              "name": "HDR_ENABLED_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.window.HDR_enabled\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_HDR_ENABLED_BOOLEAN"
            },
            "SDR_WHITE_LEVEL_FLOAT": {
              "doc": "",
              "name": "SDR_WHITE_LEVEL_FLOAT",
              "kind": "var",
              "value": "\"SDL.window.SDR_white_level\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_SDR_WHITE_LEVEL_FLOAT"
            },
            "HDR_HEADROOM_FLOAT": {
              "doc": "",
              "name": "HDR_HEADROOM_FLOAT",
              "kind": "var",
              "value": "\"SDL.window.HDR_headroom\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_HDR_HEADROOM_FLOAT"
            },
            "ANDROID_WINDOW_POINTER": {
              "doc": "",
              "name": "ANDROID_WINDOW_POINTER",
              "kind": "var",
              "value": "\"SDL.window.android.window\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_ANDROID_WINDOW_POINTER"
            },
            "ANDROID_SURFACE_POINTER": {
              "doc": "",
              "name": "ANDROID_SURFACE_POINTER",
              "kind": "var",
              "value": "\"SDL.window.android.surface\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_ANDROID_SURFACE_POINTER"
            },
            "UIKIT_WINDOW_POINTER": {
              "doc": "",
              "name": "UIKIT_WINDOW_POINTER",
              "kind": "var",
              "value": "\"SDL.window.uikit.window\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_UIKIT_WINDOW_POINTER"
            },
            "UIKIT_METAL_VIEW_TAG_NUMBER": {
              "doc": "",
              "name": "UIKIT_METAL_VIEW_TAG_NUMBER",
              "kind": "var",
              "value": "\"SDL.window.uikit.metal_view_tag\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_UIKIT_METAL_VIEW_TAG_NUMBER"
            },
            "UIKIT_OPENGL_FRAMEBUFFER_NUMBER": {
              "doc": "",
              "name": "UIKIT_OPENGL_FRAMEBUFFER_NUMBER",
              "kind": "var",
              "value": "\"SDL.window.uikit.opengl.framebuffer\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_UIKIT_OPENGL_FRAMEBUFFER_NUMBER"
            },
            "UIKIT_OPENGL_RENDERBUFFER_NUMBER": {
              "doc": "",
              "name": "UIKIT_OPENGL_RENDERBUFFER_NUMBER",
              "kind": "var",
              "value": "\"SDL.window.uikit.opengl.renderbuffer\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_UIKIT_OPENGL_RENDERBUFFER_NUMBER"
            },
            "UIKIT_OPENGL_RESOLVE_FRAMEBUFFER_NUMBER": {
              "doc": "",
              "name": "UIKIT_OPENGL_RESOLVE_FRAMEBUFFER_NUMBER",
              "kind": "var",
              "value": "\"SDL.window.uikit.opengl.resolve_framebuffer\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_UIKIT_OPENGL_RESOLVE_FRAMEBUFFER_NUMBER"
            },
            "KMSDRM_DEVICE_INDEX_NUMBER": {
              "doc": "",
              "name": "KMSDRM_DEVICE_INDEX_NUMBER",
              "kind": "var",
              "value": "\"SDL.window.kmsdrm.dev_index\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_KMSDRM_DEVICE_INDEX_NUMBER"
            },
            "KMSDRM_DRM_FD_NUMBER": {
              "doc": "",
              "name": "KMSDRM_DRM_FD_NUMBER",
              "kind": "var",
              "value": "\"SDL.window.kmsdrm.drm_fd\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_KMSDRM_DRM_FD_NUMBER"
            },
            "KMSDRM_GBM_DEVICE_POINTER": {
              "doc": "",
              "name": "KMSDRM_GBM_DEVICE_POINTER",
              "kind": "var",
              "value": "\"SDL.window.kmsdrm.gbm_dev\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_KMSDRM_GBM_DEVICE_POINTER"
            },
            "COCOA_WINDOW_POINTER": {
              "doc": "",
              "name": "COCOA_WINDOW_POINTER",
              "kind": "var",
              "value": "\"SDL.window.cocoa.window\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_COCOA_WINDOW_POINTER"
            },
            "COCOA_METAL_VIEW_TAG_NUMBER": {
              "doc": "",
              "name": "COCOA_METAL_VIEW_TAG_NUMBER",
              "kind": "var",
              "value": "\"SDL.window.cocoa.metal_view_tag\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_COCOA_METAL_VIEW_TAG_NUMBER"
            },
            "OPENVR_OVERLAY_ID": {
              "doc": "",
              "name": "OPENVR_OVERLAY_ID",
              "kind": "var",
              "value": "\"SDL.window.openvr.overlay_id\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_OPENVR_OVERLAY_ID"
            },
            "VIVANTE_DISPLAY_POINTER": {
              "doc": "",
              "name": "VIVANTE_DISPLAY_POINTER",
              "kind": "var",
              "value": "\"SDL.window.vivante.display\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_VIVANTE_DISPLAY_POINTER"
            },
            "VIVANTE_WINDOW_POINTER": {
              "doc": "",
              "name": "VIVANTE_WINDOW_POINTER",
              "kind": "var",
              "value": "\"SDL.window.vivante.window\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_VIVANTE_WINDOW_POINTER"
            },
            "VIVANTE_SURFACE_POINTER": {
              "doc": "",
              "name": "VIVANTE_SURFACE_POINTER",
              "kind": "var",
              "value": "\"SDL.window.vivante.surface\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_VIVANTE_SURFACE_POINTER"
            },
            "WIN32_HWND_POINTER": {
              "doc": "",
              "name": "WIN32_HWND_POINTER",
              "kind": "var",
              "value": "\"SDL.window.win32.hwnd\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_WIN32_HWND_POINTER"
            },
            "WIN32_HDC_POINTER": {
              "doc": "",
              "name": "WIN32_HDC_POINTER",
              "kind": "var",
              "value": "\"SDL.window.win32.hdc\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_WIN32_HDC_POINTER"
            },
            "WIN32_INSTANCE_POINTER": {
              "doc": "",
              "name": "WIN32_INSTANCE_POINTER",
              "kind": "var",
              "value": "\"SDL.window.win32.instance\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_WIN32_INSTANCE_POINTER"
            },
            "WAYLAND_DISPLAY_POINTER": {
              "doc": "",
              "name": "WAYLAND_DISPLAY_POINTER",
              "kind": "var",
              "value": "\"SDL.window.wayland.display\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_WAYLAND_DISPLAY_POINTER"
            },
            "WAYLAND_SURFACE_POINTER": {
              "doc": "",
              "name": "WAYLAND_SURFACE_POINTER",
              "kind": "var",
              "value": "\"SDL.window.wayland.surface\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_WAYLAND_SURFACE_POINTER"
            },
            "WAYLAND_VIEWPORT_POINTER": {
              "doc": "",
              "name": "WAYLAND_VIEWPORT_POINTER",
              "kind": "var",
              "value": "\"SDL.window.wayland.viewport\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_WAYLAND_VIEWPORT_POINTER"
            },
            "WAYLAND_EGL_WINDOW_POINTER": {
              "doc": "",
              "name": "WAYLAND_EGL_WINDOW_POINTER",
              "kind": "var",
              "value": "\"SDL.window.wayland.egl_window\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_WAYLAND_EGL_WINDOW_POINTER"
            },
            "WAYLAND_XDG_SURFACE_POINTER": {
              "doc": "",
              "name": "WAYLAND_XDG_SURFACE_POINTER",
              "kind": "var",
              "value": "\"SDL.window.wayland.xdg_surface\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_WAYLAND_XDG_SURFACE_POINTER"
            },
            "WAYLAND_XDG_TOPLEVEL_POINTER": {
              "doc": "",
              "name": "WAYLAND_XDG_TOPLEVEL_POINTER",
              "kind": "var",
              "value": "\"SDL.window.wayland.xdg_toplevel\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_POINTER"
            },
            "WAYLAND_XDG_TOPLEVEL_EXPORT_HANDLE_STRING": {
              "doc": "",
              "name": "WAYLAND_XDG_TOPLEVEL_EXPORT_HANDLE_STRING",
              "kind": "var",
              "value": "\"SDL.window.wayland.xdg_toplevel_export_handle\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_EXPORT_HANDLE_STRING"
            },
            "WAYLAND_XDG_POPUP_POINTER": {
              "doc": "",
              "name": "WAYLAND_XDG_POPUP_POINTER",
              "kind": "var",
              "value": "\"SDL.window.wayland.xdg_popup\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_WAYLAND_XDG_POPUP_POINTER"
            },
            "WAYLAND_XDG_POSITIONER_POINTER": {
              "doc": "",
              "name": "WAYLAND_XDG_POSITIONER_POINTER",
              "kind": "var",
              "value": "\"SDL.window.wayland.xdg_positioner\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_WAYLAND_XDG_POSITIONER_POINTER"
            },
            "X11_DISPLAY_POINTER": {
              "doc": "",
              "name": "X11_DISPLAY_POINTER",
              "kind": "var",
              "value": "\"SDL.window.x11.display\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_X11_DISPLAY_POINTER"
            },
            "X11_SCREEN_NUMBER": {
              "doc": "",
              "name": "X11_SCREEN_NUMBER",
              "kind": "var",
              "value": "\"SDL.window.x11.screen\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_X11_SCREEN_NUMBER"
            },
            "X11_WINDOW_NUMBER": {
              "doc": "",
              "name": "X11_WINDOW_NUMBER",
              "kind": "var",
              "value": "\"SDL.window.x11.window\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_WINDOW_X11_WINDOW_NUMBER"
            }
          },
          "doc": ""
        },
        "GetWindowFromID": {
          "doc": "Get a window from a stored ID.\n\nThe numeric ID is what WindowEvent references, and is necessary to map\nthese events to specific WindowBase objects.\n\n@param id the ID of the window.\n@returns the window associated with `id` or nullptr if it doesn't exist; call\n         GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.GetID",
          "name": "GetWindowFromID",
          "kind": "function",
          "type": "WindowRef",
          "parameters": [
            {
              "name": "id",
              "type": "WindowID"
            }
          ],
          "sourceName": "SDL_GetWindowFromID"
        },
        "SDL_WINDOW_SURFACE_VSYNC_DISABLED": {
          "doc": "",
          "name": "SDL_WINDOW_SURFACE_VSYNC_DISABLED",
          "kind": "def",
          "value": "0",
          "sourceName": "SDL_WINDOW_SURFACE_VSYNC_DISABLED"
        },
        "SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE": {
          "doc": "",
          "name": "SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE",
          "kind": "def",
          "value": "(-1)",
          "sourceName": "SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE"
        },
        "GetGrabbedWindow": {
          "doc": "Get the window that currently has an input grab enabled.\n\n@returns the window if input is grabbed or nullptr otherwise.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase.SetMouseGrab\n@sa WindowBase.SetKeyboardGrab",
          "name": "GetGrabbedWindow",
          "kind": "function",
          "type": "WindowRef",
          "parameters": [],
          "sourceName": "SDL_GetGrabbedWindow"
        },
        "ScreenSaverEnabled": {
          "doc": "Check whether the screensaver is currently enabled.\n\nThe screensaver is disabled by default.\n\nThe default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.\n\n@returns true if the screensaver is enabled, false if it is disabled.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa DisableScreenSaver\n@sa EnableScreenSaver",
          "name": "ScreenSaverEnabled",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_ScreenSaverEnabled"
        },
        "EnableScreenSaver": {
          "doc": "Allow the screen to be blanked by a screen saver.\n\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa DisableScreenSaver\n@sa ScreenSaverEnabled",
          "name": "EnableScreenSaver",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_EnableScreenSaver"
        },
        "DisableScreenSaver": {
          "doc": "Prevent the screen from being blanked by a screen saver.\n\nIf you disable the screensaver, it is automatically re-enabled when SDL\nquits.\n\nThe screensaver is disabled by default, but this may by changed by\nSDL_HINT_VIDEO_ALLOW_SCREENSAVER.\n\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa EnableScreenSaver\n@sa ScreenSaverEnabled",
          "name": "DisableScreenSaver",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_DisableScreenSaver"
        },
        "GL_LoadLibrary": {
          "doc": "Dynamically load an OpenGL library.\n\nThis should be done after initializing the video driver, but before\ncreating any OpenGL windows. If no OpenGL library is loaded, the default\nlibrary will be loaded upon creation of the first OpenGL window.\n\nIf you do this, you need to retrieve all of the GL functions used in your\nprogram from the dynamic library using GL_GetProcAddress().\n\n@param path the platform dependent OpenGL library name, or nullptr to open the\n            default OpenGL library.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GL_GetProcAddress\n@sa GL_UnloadLibrary",
          "name": "GL_LoadLibrary",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "path",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_GL_LoadLibrary"
        },
        "GL_GetProcAddress": {
          "doc": "Get an OpenGL function by name.\n\nIf the GL library is loaded at runtime with GL_LoadLibrary(), then all\nGL functions must be retrieved this way. Usually this is used to retrieve\nfunction pointers to OpenGL extensions.\n\nThere are some quirks to looking up OpenGL functions that require some\nextra care from the application. If you code carefully, you can handle\nthese quirks without any platform-specific code, though:\n\n- On Windows, function pointers are specific to the current GL context;\n  this means you need to have created a GL context and made it current\n  before calling GL_GetProcAddress(). If you recreate your context or\n  create a second context, you should assume that any existing function\n  pointers aren't valid to use with it. This is (currently) a\n  Windows-specific limitation, and in practice lots of drivers don't suffer\n  this limitation, but it is still the way the wgl API is documented to\n  work and you should expect crashes if you don't respect it. Store a copy\n  of the function pointers that comes and goes with context lifespan.\n- On X11, function pointers returned by this function are valid for any\n  context, and can even be looked up before a context is created at all.\n  This means that, for at least some common OpenGL implementations, if you\n  look up a function that doesn't exist, you'll get a non-nullptr result that\n  is _NOT_ safe to call. You must always make sure the function is actually\n  available for a given GL context before calling it, by checking for the\n  existence of the appropriate extension with GL_ExtensionSupported(),\n  or verifying that the version of OpenGL you're using offers the function\n  as core functionality.\n- Some OpenGL drivers, on all platforms, *will* return nullptr if a function\n  isn't supported, but you can't count on this behavior. Check for\n  extensions you use, and if you get a nullptr anyway, act as if that\n  extension wasn't available. This is probably a bug in the driver, but you\n  can code defensively for this scenario anyhow.\n- Just because you're on Linux/Unix, don't assume you'll be using X11.\n  Next-gen display servers are waiting to replace it, and may or may not\n  make the same promises about function pointers.\n- OpenGL function pointers must be declared `APIENTRY` as in the example\n  code. This will ensure the proper calling convention is followed on\n  platforms where this matters (Win32) thereby avoiding stack corruption.\n\n@param proc the name of an OpenGL function.\n@returns a pointer to the named OpenGL function. The returned pointer\n         should be cast to the appropriate function signature.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GL_ExtensionSupported\n@sa GL_LoadLibrary\n@sa GL_UnloadLibrary",
          "name": "GL_GetProcAddress",
          "kind": "function",
          "type": "FunctionPointer",
          "parameters": [
            {
              "name": "proc",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_GL_GetProcAddress"
        },
        "EGL_GetProcAddress": {
          "doc": "Get an EGL library function by name.\n\nIf an EGL library is loaded, this function allows applications to get entry\npoints for EGL functions. This is useful to provide to an EGL API and\nextension loader.\n\n@param proc the name of an EGL function.\n@returns a pointer to the named EGL function. The returned pointer should\n         be cast to the appropriate function signature.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa EGL_GetCurrentDisplay",
          "name": "EGL_GetProcAddress",
          "kind": "function",
          "type": "FunctionPointer",
          "parameters": [
            {
              "name": "proc",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_EGL_GetProcAddress"
        },
        "GL_UnloadLibrary": {
          "doc": "Unload the OpenGL library previously loaded by GL_LoadLibrary().\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GL_LoadLibrary",
          "name": "GL_UnloadLibrary",
          "kind": "function",
          "type": "void",
          "parameters": [],
          "sourceName": "SDL_GL_UnloadLibrary"
        },
        "GL_ExtensionSupported": {
          "doc": "Check if an OpenGL extension is supported for the current context.\n\nThis function operates on the current GL context; you must have created a\ncontext and it must be current before calling this function. Do not assume\nthat all contexts you create will have the same set of extensions\navailable, or that recreating an existing context will offer the same\nextensions again.\n\nWhile it's probably not a massive overhead, this function is not an O(1)\noperation. Check the extensions you care about after creating the GL\ncontext and save that information somewhere instead of calling the function\nevery time you need to know.\n\n@param extension the name of the extension to check.\n@returns true if the extension is supported, false otherwise.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GL_ExtensionSupported",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "extension",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_GL_ExtensionSupported"
        },
        "GL_ResetAttributes": {
          "doc": "Reset all previously set OpenGL context attributes to their default values.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GL_GetAttribute\n@sa GL_SetAttribute",
          "name": "GL_ResetAttributes",
          "kind": "function",
          "type": "void",
          "parameters": [],
          "sourceName": "SDL_GL_ResetAttributes"
        },
        "GL_SetAttribute": {
          "doc": "Set an OpenGL window attribute before window creation.\n\nThis function sets the OpenGL attribute `attr` to `value`. The requested\nattributes should be set before creating an OpenGL window. You should use\nGL_GetAttribute() to check the values after creating the OpenGL\ncontext, since the values obtained can differ from the requested ones.\n\n@param attr an GLAttr enum value specifying the OpenGL attribute to\n            set.\n@param value the desired value for the attribute.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GL_GetAttribute\n@sa GL_ResetAttributes",
          "name": "GL_SetAttribute",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "attr",
              "type": "GLAttr"
            },
            {
              "name": "value",
              "type": "int"
            }
          ],
          "sourceName": "SDL_GL_SetAttribute"
        },
        "GL_GetAttribute": {
          "doc": "Get the actual value for an attribute from the current context.\n\n@param attr an GLAttr enum value specifying the OpenGL attribute to\n            get.\n@param value a pointer filled in with the current value of `attr`.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GL_ResetAttributes\n@sa GL_SetAttribute",
          "name": "GL_GetAttribute",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "attr",
              "type": "GLAttr"
            },
            {
              "name": "value",
              "type": "int *"
            }
          ],
          "sourceName": "SDL_GL_GetAttribute"
        },
        "GL_GetCurrentWindow": {
          "doc": "Get the currently active OpenGL window.\n\n@returns the currently active OpenGL window on success or nullptr on failure;\n         call GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GL_GetCurrentWindow",
          "kind": "function",
          "type": "WindowRef",
          "parameters": [],
          "sourceName": "SDL_GL_GetCurrentWindow"
        },
        "GL_GetCurrentContext": {
          "doc": "Get the currently active OpenGL context.\n\n@returns the currently active OpenGL context or nullptr on failure; call\n         GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GLContextBase.MakeCurrent",
          "name": "GL_GetCurrentContext",
          "kind": "function",
          "type": "GLContextRef",
          "parameters": [],
          "sourceName": "SDL_GL_GetCurrentContext"
        },
        "EGL_GetCurrentDisplay": {
          "doc": "Get the currently active EGL display.\n\n@returns the currently active EGL display or nullptr on failure; call\n         GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "EGL_GetCurrentDisplay",
          "kind": "function",
          "type": "EGLDisplay",
          "parameters": [],
          "sourceName": "SDL_EGL_GetCurrentDisplay"
        },
        "EGL_GetCurrentConfig": {
          "doc": "Get the currently active EGL config.\n\n@returns the currently active EGL config or nullptr on failure; call\n         GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "EGL_GetCurrentConfig",
          "kind": "function",
          "type": "EGLConfig",
          "parameters": [],
          "sourceName": "SDL_EGL_GetCurrentConfig"
        },
        "EGL_GetWindowSurface": {
          "doc": "Get the EGL surface associated with the window.\n\n@param window the window to query.\n@returns the EGLSurface pointer associated with the window, or nullptr on\n         failure.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "EGL_GetWindowSurface",
          "kind": "function",
          "type": "EGLSurface",
          "parameters": [
            {
              "name": "window",
              "type": "WindowRef"
            }
          ],
          "sourceName": "SDL_EGL_GetWindowSurface"
        },
        "EGL_SetAttributeCallbacks": {
          "doc": "Sets the callbacks for defining custom EGLAttrib arrays for EGL\ninitialization.\n\nCallbacks that aren't needed can be set to nullptr.\n\nNOTE: These callback pointers will be reset after GL_ResetAttributes.\n\n@param platformAttribCallback callback for attributes to pass to\n                              eglGetPlatformDisplay. May be nullptr.\n@param surfaceAttribCallback callback for attributes to pass to\n                             eglCreateSurface. May be nullptr.\n@param contextAttribCallback callback for attributes to pass to\n                             eglCreateContext. May be nullptr.\n@param userdata a pointer that is passed to the callbacks.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "EGL_SetAttributeCallbacks",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "platformAttribCallback",
              "type": "EGLAttribArrayCallback"
            },
            {
              "name": "surfaceAttribCallback",
              "type": "EGLIntArrayCallback"
            },
            {
              "name": "contextAttribCallback",
              "type": "EGLIntArrayCallback"
            },
            {
              "name": "userdata",
              "type": "void *"
            }
          ],
          "sourceName": "SDL_EGL_SetAttributeCallbacks"
        },
        "GL_SetSwapInterval": {
          "doc": "Set the swap interval for the current OpenGL context.\n\nSome systems allow specifying -1 for the interval, to enable adaptive\nvsync. Adaptive vsync works the same as vsync, but if you've already missed\nthe vertical retrace for a given frame, it swaps buffers immediately, which\nmight be less jarring for the user during occasional framerate drops. If an\napplication requests adaptive vsync and the system does not support it,\nthis function will fail and return false. In such a case, you should\nprobably retry the call with 1 for the interval.\n\nAdaptive vsync is implemented for some glX drivers with\nGLX_EXT_swap_control_tear, and for some Windows drivers with\nWGL_EXT_swap_control_tear.\n\nRead more on the Khronos wiki:\nhttps://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync\n\n@param interval 0 for immediate updates, 1 for updates synchronized with\n                the vertical retrace, -1 for adaptive vsync.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GL_GetSwapInterval",
          "name": "GL_SetSwapInterval",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "interval",
              "type": "int"
            }
          ],
          "sourceName": "SDL_GL_SetSwapInterval"
        },
        "GL_GetSwapInterval": {
          "doc": "Get the swap interval for the current OpenGL context.\n\nIf the system can't determine the swap interval, or there isn't a valid\ncurrent context, this function will set *interval to 0 as a safe default.\n\n@param interval output interval value. 0 if there is no vertical retrace\n                synchronization, 1 if the buffer swap is synchronized with\n                the vertical retrace, and -1 if late swaps happen\n                immediately instead of waiting for the next retrace.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GL_SetSwapInterval",
          "name": "GL_GetSwapInterval",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "interval",
              "type": "int *"
            }
          ],
          "sourceName": "SDL_GL_GetSwapInterval"
        },
        "GL_SwapWindow": {
          "doc": "Update a window with OpenGL rendering.\n\nThis is used with double-buffered OpenGL contexts, which are the default.\n\nOn macOS, make sure you bind 0 to the draw framebuffer before swapping the\nwindow, otherwise nothing will happen. If you aren't using\nglBindFramebuffer(), this is the default and you won't have to do anything\nextra.\n\n@param window the window to change.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GL_SwapWindow",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "window",
              "type": "WindowRef"
            }
          ],
          "sourceName": "SDL_GL_SwapWindow"
        }
      }
    },
    "SDL3pp_render.h": {
      "name": "SDL3pp_render.h",
      "doc": "@defgroup CategoryRender Category Render\n\nHeader file for SDL 2D rendering functions.\n\nThis API supports the following features:\n\n- single pixel points\n- single pixel lines\n- filled rectangles\n- texture images\n- 2D polygons\n\nThe primitives may be drawn in opaque, blended, or additive modes.\n\nThe texture images may be drawn in opaque, blended, or additive modes. They\ncan have an additional color tint or alpha modulation applied to them, and\nmay also be stretched with linear interpolation.\n\nThis API is designed to accelerate simple 2D operations. You may want more\nfunctionality such as polygons and particle effects and in that case you\nshould use SDL's OpenGL/Direct3D support, the SDL3 GPU API, or one of the\nmany good 3D engines.\n\nThese functions must be called from the main thread. See this bug for\ndetails: https://github.com/libsdl-org/SDL/issues/986",
      "entries": {
        "TextureLock-forward": {
          "name": "TextureLock",
          "kind": "forward",
          "doc": ""
        },
        "Renderer": {
          "name": "Renderer",
          "kind": "alias",
          "type": "RendererBase<ObjectUnique<SDL_Renderer>>",
          "doc": ""
        },
        "TextureBase-forward": {
          "name": "TextureBase",
          "kind": "forward",
          "template": [
            {
              "type": "ObjectBox<SDL_Texture *>",
              "name": "T"
            }
          ],
          "doc": ""
        },
        "TextureRef": {
          "name": "TextureRef",
          "kind": "alias",
          "type": "TextureBase<ObjectRef<SDL_Texture>>",
          "doc": "Handle to a non owned texture\n\n@cat resource\n\n@sa TextureBase\n@sa Texture"
        },
        "Texture": {
          "name": "Texture",
          "kind": "alias",
          "type": "TextureBase<ObjectUnique<SDL_Texture>>",
          "doc": "Handle to an owned texture\n\n@cat resource\n\n@sa TextureBase\n@sa TextureRef"
        },
        "SDL_SOFTWARE_RENDERER": {
          "doc": "The name of the software renderer.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_SOFTWARE_RENDERER",
          "kind": "def",
          "value": "\"software\"",
          "sourceName": "SDL_SOFTWARE_RENDERER"
        },
        "Vertex": {
          "doc": "Vertex structure.\n\n@since This struct is available since SDL 3.2.0.",
          "name": "Vertex",
          "kind": "alias",
          "sourceName": "SDL_Vertex",
          "type": "SDL_Vertex"
        },
        "TextureAccess": {
          "doc": "The access pattern allowed for a texture.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "TextureAccess",
          "kind": "alias",
          "sourceName": "SDL_TextureAccess",
          "type": "SDL_TextureAccess"
        },
        "TEXTUREACCESS_STATIC": {
          "doc": "Changes rarely, not lockable.",
          "name": "TEXTUREACCESS_STATIC",
          "kind": "var",
          "type": "TextureAccess",
          "sourceName": "SDL_TEXTUREACCESS_STATIC",
          "constexpr": true
        },
        "TEXTUREACCESS_STREAMING": {
          "doc": "Changes frequently, lockable.",
          "name": "TEXTUREACCESS_STREAMING",
          "kind": "var",
          "type": "TextureAccess",
          "sourceName": "SDL_TEXTUREACCESS_STREAMING",
          "constexpr": true
        },
        "TEXTUREACCESS_TARGET": {
          "doc": "Texture can be used as a render target.",
          "name": "TEXTUREACCESS_TARGET",
          "kind": "var",
          "type": "TextureAccess",
          "sourceName": "SDL_TEXTUREACCESS_TARGET",
          "constexpr": true
        },
        "RendererLogicalPresentation": {
          "doc": "How the logical size is mapped to the output.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "RendererLogicalPresentation",
          "kind": "alias",
          "sourceName": "SDL_RendererLogicalPresentation",
          "type": "SDL_RendererLogicalPresentation"
        },
        "LOGICAL_PRESENTATION_DISABLED": {
          "doc": "There is no logical size in effect.",
          "name": "LOGICAL_PRESENTATION_DISABLED",
          "kind": "var",
          "type": "RendererLogicalPresentation",
          "sourceName": "SDL_LOGICAL_PRESENTATION_DISABLED",
          "constexpr": true
        },
        "LOGICAL_PRESENTATION_STRETCH": {
          "doc": "The rendered content is stretched to the output resolution.",
          "name": "LOGICAL_PRESENTATION_STRETCH",
          "kind": "var",
          "type": "RendererLogicalPresentation",
          "sourceName": "SDL_LOGICAL_PRESENTATION_STRETCH",
          "constexpr": true
        },
        "LOGICAL_PRESENTATION_LETTERBOX": {
          "doc": "The rendered content is fit to the largest dimension and the other dimension is letterboxed with black bars.",
          "name": "LOGICAL_PRESENTATION_LETTERBOX",
          "kind": "var",
          "type": "RendererLogicalPresentation",
          "sourceName": "SDL_LOGICAL_PRESENTATION_LETTERBOX",
          "constexpr": true
        },
        "LOGICAL_PRESENTATION_OVERSCAN": {
          "doc": "The rendered content is fit to the smallest dimension and the other dimension extends beyond the output bounds.",
          "name": "LOGICAL_PRESENTATION_OVERSCAN",
          "kind": "var",
          "type": "RendererLogicalPresentation",
          "sourceName": "SDL_LOGICAL_PRESENTATION_OVERSCAN",
          "constexpr": true
        },
        "LOGICAL_PRESENTATION_INTEGER_SCALE": {
          "doc": "The rendered content is scaled up by integer multiples to fit the output resolution.",
          "name": "LOGICAL_PRESENTATION_INTEGER_SCALE",
          "kind": "var",
          "type": "RendererLogicalPresentation",
          "sourceName": "SDL_LOGICAL_PRESENTATION_INTEGER_SCALE",
          "constexpr": true
        },
        "RendererBase": {
          "doc": "A structure representing rendering state\n\n@since This struct is available since SDL 3.2.0.",
          "name": "RendererBase",
          "kind": "struct",
          "type": "T",
          "sourceName": "SDL_Renderer",
          "template": [
            {
              "type": "ObjectBox<SDL_Renderer *>",
              "name": "T"
            }
          ],
          "entries": {
            "T::T": {
              "kind": "alias",
              "name": "T::T",
              "doc": ""
            },
            "RendererBase": [
              {
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "type": "WindowRef",
                    "name": "window"
                  }
                ],
                "name": "RendererBase",
                "doc": ""
              },
              {
                "doc": "Create a 2D rendering context for a window.\n\nIf you want a specific renderer, you can specify its name here. A list of\navailable renderers can be obtained by calling GetRenderDriver()\nmultiple times, with indices from 0 to GetNumRenderDrivers()-1. If you\ndon't need a specific renderer, specify nullptr and SDL will attempt to choose\nthe best option for you, based on what is available on the user's system.\n\nIf `name` is a comma-separated list, SDL will try each name, in the order\nlisted, until one succeeds or all of them fail.\n\nBy default the rendering size matches the window size in pixels, but you\ncan call RendererBase.SetLogicalPresentation() to change the content size and\nscaling options.\n\n@param window the window where rendering is displayed.\n@param name the name of the rendering driver to initialize, or nullptr to let\n            SDL choose one.\n@post a valid rendering context or nullptr if there was an error; call\n         GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.RendererBase\n@sa RendererBase.RendererBase\n@sa RendererBase.Destroy\n@sa GetNumRenderDrivers\n@sa GetRenderDriver\n@sa RendererBase.GetName",
                "name": "RendererBase",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "window",
                    "type": "WindowRef"
                  },
                  {
                    "name": "name",
                    "type": "StringParam"
                  }
                ],
                "sourceName": "SDL_CreateRenderer"
              },
              {
                "doc": "Create a 2D rendering context for a window, with the specified properties.\n\nThese are the supported properties:\n\n- `SDL_PROP_RENDERER_CREATE_NAME_STRING`: the name of the rendering driver\n  to use, if a specific one is desired\n- `prop::Renderer.CREATE_WINDOW_POINTER`: the window where rendering is\n  displayed, required if this isn't a software renderer using a surface\n- `prop::Renderer.CREATE_SURFACE_POINTER`: the surface where rendering\n  is displayed, if you want a software renderer without a window\n- `prop::Renderer.CREATE_OUTPUT_COLORSPACE_NUMBER`: an Colorspace\n  value describing the colorspace for output to the display, defaults to\n  COLORSPACE_SRGB. The direct3d11, direct3d12, and metal renderers\n  support COLORSPACE_SRGB_LINEAR, which is a linear color space and\n  supports HDR output. If you select COLORSPACE_SRGB_LINEAR, drawing\n  still uses the sRGB colorspace, but values can go beyond 1.0 and float\n  (linear) format textures can be used for HDR content.\n- `prop::Renderer.CREATE_PRESENT_VSYNC_NUMBER`: non-zero if you want\n  present synchronized with the refresh rate. This property can take any\n  value that is supported by RendererBase.SetVSync() for the renderer.\n\nWith the vulkan renderer:\n\n- `prop::Renderer.CREATE_VULKAN_INSTANCE_POINTER`: the VkInstance to use\n  with the renderer, optional.\n- `prop::Renderer.CREATE_VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR to use\n  with the renderer, optional.\n- `prop::Renderer.CREATE_VULKAN_PHYSICAL_DEVICE_POINTER`: the\n  VkPhysicalDevice to use with the renderer, optional.\n- `prop::Renderer.CREATE_VULKAN_DEVICE_POINTER`: the VkDevice to use\n  with the renderer, optional.\n- `prop::Renderer.CREATE_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the\n  queue family index used for rendering.\n- `prop::Renderer.CREATE_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the\n  queue family index used for presentation.\n\n@param props the properties to use.\n@post a valid rendering context or nullptr if there was an error; call\n         GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa CreateProperties\n@sa RendererBase.RendererBase\n@sa RendererBase.RendererBase\n@sa RendererBase.Destroy\n@sa RendererBase.GetName",
                "name": "RendererBase",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "props",
                    "type": "PropertiesRef"
                  }
                ],
                "sourceName": "SDL_CreateRendererWithProperties"
              },
              {
                "doc": "Create a 2D software rendering context for a surface.\n\nTwo other API which can be used to create RendererBase:\nRendererBase.RendererBase() and CreateWindowAndRenderer(). These can _also_\ncreate a software renderer, but they are intended to be used with an\nWindowBase as the final destination and not an SurfaceBase.\n\n@param surface the SurfaceBase structure representing the surface where\n               rendering is done.\n@post a valid rendering context or nullptr if there was an error; call\n         GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.Destroy",
                "name": "RendererBase",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "surface",
                    "type": "SurfaceRef"
                  }
                ],
                "sourceName": "SDL_CreateSoftwareRenderer"
              }
            ],
            "GetWindow": {
              "doc": "Get the window associated with a renderer.\n\n@returns the window on success or nullptr on failure; call GetError() for\n         more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetWindow",
              "kind": "function",
              "type": "WindowRef",
              "parameters": [],
              "sourceName": "SDL_GetRenderWindow"
            },
            "GetName": {
              "doc": "Get the name of a renderer.\n\n@returns the name of the selected renderer, or nullptr on failure; call\n         GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.RendererBase\n@sa RendererBase.RendererBase",
              "name": "GetName",
              "kind": "function",
              "type": "const char *",
              "parameters": [],
              "sourceName": "SDL_GetRendererName",
              "immutable": true
            },
            "GetOutputSize": [
              {
                "kind": "function",
                "type": "std::optional<Point>",
                "immutable": true,
                "parameters": [],
                "name": "GetOutputSize",
                "doc": ""
              },
              {
                "doc": "Get the output size in pixels of a rendering context.\n\nThis returns the true output size in pixels, ignoring any render targets or\nlogical size and presentation.\n\nFor the output size of the current rendering target, with logical size\nadjustments, use RendererBase.GetCurrentOutputSize() instead.\n\n@param w a pointer filled in with the width in pixels.\n@param h a pointer filled in with the height in pixels.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.GetCurrentOutputSize",
                "name": "GetOutputSize",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "w",
                    "type": "int *"
                  },
                  {
                    "name": "h",
                    "type": "int *"
                  }
                ],
                "sourceName": "SDL_GetRenderOutputSize",
                "immutable": true
              }
            ],
            "GetCurrentOutputSize": [
              {
                "kind": "function",
                "type": "std::optional<Point>",
                "immutable": true,
                "parameters": [],
                "name": "GetCurrentOutputSize",
                "doc": ""
              },
              {
                "doc": "Get the current output size in pixels of a rendering context.\n\nIf a rendering target is active, this will return the size of the rendering\ntarget in pixels, otherwise return the value of RendererBase.GetOutputSize().\n\nRendering target or not, the output will be adjusted by the current logical\npresentation state, dictated by RendererBase.SetLogicalPresentation().\n\n@param w a pointer filled in with the current width.\n@param h a pointer filled in with the current height.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.GetOutputSize",
                "name": "GetCurrentOutputSize",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "w",
                    "type": "int *"
                  },
                  {
                    "name": "h",
                    "type": "int *"
                  }
                ],
                "sourceName": "SDL_GetCurrentRenderOutputSize",
                "immutable": true
              }
            ],
            "GetProperties": {
              "doc": "Get the properties associated with a renderer.\n\nThe following read-only properties are provided by SDL:\n\n- `prop::Renderer.NAME_STRING`: the name of the rendering driver\n- `prop::Renderer.WINDOW_POINTER`: the window where rendering is\n  displayed, if any\n- `prop::Renderer.SURFACE_POINTER`: the surface where rendering is\n  displayed, if this is a software renderer without a window\n- `prop::Renderer.VSYNC_NUMBER`: the current vsync setting\n- `prop::Renderer.MAX_TEXTURE_SIZE_NUMBER`: the maximum texture width\n  and height\n- `prop::Renderer.TEXTURE_FORMATS_POINTER`: a (const PixelFormat *)\n  array of pixel formats, terminated with PIXELFORMAT_UNKNOWN,\n  representing the available texture formats for this renderer.\n- `prop::Renderer.OUTPUT_COLORSPACE_NUMBER`: an Colorspace value\n  describing the colorspace for output to the display, defaults to\n  COLORSPACE_SRGB.\n- `prop::Renderer.HDR_ENABLED_BOOLEAN`: true if the output colorspace is\n  COLORSPACE_SRGB_LINEAR and the renderer is showing on a display with\n  HDR enabled. This property can change dynamically when\n  EVENT_WINDOW_HDR_STATE_CHANGED is sent.\n- `prop::Renderer.SDR_WHITE_POINT_FLOAT`: the value of SDR white in the\n  COLORSPACE_SRGB_LINEAR colorspace. When HDR is enabled, this value is\n  automatically multiplied into the color scale. This property can change\n  dynamically when EVENT_WINDOW_HDR_STATE_CHANGED is sent.\n- `prop::Renderer.HDR_HEADROOM_FLOAT`: the additional high dynamic range\n  that can be displayed, in terms of the SDR white point. When HDR is not\n  enabled, this will be 1.0. This property can change dynamically when\n  EVENT_WINDOW_HDR_STATE_CHANGED is sent.\n\nWith the direct3d renderer:\n\n- `prop::Renderer.D3D9_DEVICE_POINTER`: the IDirect3DDevice9 associated\n  with the renderer\n\nWith the direct3d11 renderer:\n\n- `prop::Renderer.D3D11_DEVICE_POINTER`: the ID3D11Device associated\n  with the renderer\n- `prop::Renderer.D3D11_SWAPCHAIN_POINTER`: the IDXGISwapChain1\n  associated with the renderer. This may change when the window is resized.\n\nWith the direct3d12 renderer:\n\n- `prop::Renderer.D3D12_DEVICE_POINTER`: the ID3D12Device associated\n  with the renderer\n- `prop::Renderer.D3D12_SWAPCHAIN_POINTER`: the IDXGISwapChain4\n  associated with the renderer.\n- `prop::Renderer.D3D12_COMMAND_QUEUE_POINTER`: the ID3D12CommandQueue\n  associated with the renderer\n\nWith the vulkan renderer:\n\n- `prop::Renderer.VULKAN_INSTANCE_POINTER`: the VkInstance associated\n  with the renderer\n- `prop::Renderer.VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR associated\n  with the renderer\n- `prop::Renderer.VULKAN_PHYSICAL_DEVICE_POINTER`: the VkPhysicalDevice\n  associated with the renderer\n- `prop::Renderer.VULKAN_DEVICE_POINTER`: the VkDevice associated with\n  the renderer\n- `prop::Renderer.VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the queue\n  family index used for rendering\n- `prop::Renderer.VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the queue\n  family index used for presentation\n- `prop::Renderer.VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER`: the number of\n  swapchain images, or potential frames in flight, used by the Vulkan\n  renderer\n\nWith the gpu renderer:\n\n- `prop::Renderer.GPU_DEVICE_POINTER`: the SDL_GPUDevice associated with\n  the renderer\n\n@returns a valid property ID on success or 0 on failure; call\n         GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetProperties",
              "kind": "function",
              "type": "PropertiesRef",
              "parameters": [],
              "sourceName": "SDL_GetRendererProperties",
              "immutable": true
            },
            "ResetTarget": {
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "name": "ResetTarget",
              "doc": ""
            },
            "SetTarget": {
              "doc": "Set a texture as the current rendering target.\n\nThe default render target is the window for which the renderer was created.\nTo stop rendering to a texture and render to the window again, call this\nfunction with a nullptr `texture`.\n\nViewport, cliprect, scale, and logical presentation are unique to each\nrender target. Get and set functions for these states apply to the current\nrender target set by this function, and those states persist on each target\nwhen the current render target changes.\n\n@param texture the targeted texture, which must be created with the\n               `TEXTUREACCESS_TARGET` flag, or nullptr to render to the\n               window instead of a texture.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.GetTarget",
              "name": "SetTarget",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "texture",
                  "type": "TextureRef"
                }
              ],
              "sourceName": "SDL_SetRenderTarget"
            },
            "GetTarget": {
              "doc": "Get the current render target.\n\nThe default render target is the window for which the renderer was created,\nand is reported a nullptr here.\n\n@returns the current render target or nullptr for the default render target.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.SetTarget",
              "name": "GetTarget",
              "kind": "function",
              "type": "TextureRef",
              "parameters": [],
              "sourceName": "SDL_GetRenderTarget",
              "immutable": true
            },
            "SetLogicalPresentation": {
              "doc": "Set a device-independent resolution and presentation mode for rendering.\n\nThis function sets the width and height of the logical rendering output.\nThe renderer will act as if the current render target is always the\nrequested dimensions, scaling to the actual resolution as necessary.\n\nThis can be useful for games that expect a fixed size, but would like to\nscale the output to whatever is available, regardless of how a user resizes\na window, or if the display is high DPI.\n\nLogical presentation can be used with both render target textures and the\nrenderer's window; the state is unique to each render target, and this\nfunction sets the state for the current render target. It might be useful\nto draw to a texture that matches the window dimensions with logical\npresentation enabled, and then draw that texture across the entire window\nwith logical presentation disabled. Be careful not to render both with\nlogical presentation enabled, however, as this could produce\ndouble-letterboxing, etc.\n\nYou can disable logical coordinates by setting the mode to\nLOGICAL_PRESENTATION_DISABLED, and in that case you get the full pixel\nresolution of the render target; it is safe to toggle logical presentation\nduring the rendering of a frame: perhaps most of the rendering is done to\nspecific dimensions but to make fonts look sharp, the app turns off logical\npresentation while drawing text, for example.\n\nFor the renderer's window, letterboxing is drawn into the framebuffer if\nlogical presentation is enabled during RendererBase.Present; be sure to\nreenable it before presenting if you were toggling it, otherwise the\nletterbox areas might have artifacts from previous frames (or artifacts\nfrom external overlays, etc). Letterboxing is never drawn into texture\nrender targets; be sure to call RendererBase.RenderClear() before drawing into the\ntexture so the letterboxing areas are cleared, if appropriate.\n\nYou can convert coordinates in an event into rendering coordinates using\nRendererBase.ConvertEventToRenderCoordinates().\n\n@param renderer the rendering context.\n@param w the width of the logical resolution.\n@param h the height of the logical resolution.\n@param mode the presentation mode used.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.ConvertEventToRenderCoordinates\n@sa RendererBase.GetLogicalPresentation\n@sa RendererBase.GetLogicalPresentationRect",
              "name": "SetLogicalPresentation",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "size",
                  "type": "SDL_Point"
                },
                {
                  "name": "mode",
                  "type": "RendererLogicalPresentation"
                }
              ],
              "sourceName": "SDL_SetRenderLogicalPresentation",
              "static": false
            },
            "GetLogicalPresentation": [
              {
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "type": "SDL_Point *",
                    "name": "size"
                  },
                  {
                    "name": "mode",
                    "type": "RendererLogicalPresentation *"
                  }
                ],
                "name": "GetLogicalPresentation",
                "doc": ""
              },
              {
                "doc": "Get device independent resolution and presentation mode for rendering.\n\nThis function gets the width and height of the logical rendering output, or\nthe output size in pixels if a logical resolution is not enabled.\n\nEach render target has its own logical presentation state. This function\ngets the state for the current render target.\n\n@param w an int to be filled with the width.\n@param h an int to be filled with the height.\n@param mode the presentation mode used.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.SetLogicalPresentation",
                "name": "GetLogicalPresentation",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "w",
                    "type": "int *"
                  },
                  {
                    "name": "h",
                    "type": "int *"
                  },
                  {
                    "name": "mode",
                    "type": "RendererLogicalPresentation *"
                  }
                ],
                "sourceName": "SDL_GetRenderLogicalPresentation",
                "immutable": true
              }
            ],
            "GetLogicalPresentationRect": {
              "doc": "Get the final presentation rectangle for rendering.\n\nThis function returns the calculated rectangle used for logical\npresentation, based on the presentation mode and output size. If logical\npresentation is disabled, it will fill the rectangle with the output size,\nin pixels.\n\nEach render target has its own logical presentation state. This function\ngets the rectangle for the current render target.\n\n@param renderer the rendering context.\n@param rect a pointer filled in with the final presentation rectangle, may\n            be nullptr.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.SetLogicalPresentation",
              "name": "GetLogicalPresentationRect",
              "kind": "function",
              "type": "std::optional<FRect>",
              "parameters": [],
              "sourceName": "SDL_GetRenderLogicalPresentationRect",
              "immutable": true
            },
            "RenderCoordinatesFromWindow": {
              "doc": "Get a point in render coordinates when given a point in window coordinates.\n\nThis takes into account several states:\n\n- The window dimensions.\n- The logical presentation settings (RendererBase.SetLogicalPresentation)\n- The scale (RendererBase.SetScale)\n- The viewport (RendererBase.SetViewport)\n\n@param renderer the rendering context.\n@param window_x the x coordinate in window coordinates.\n@param window_y the y coordinate in window coordinates.\n@param x a pointer filled with the x coordinate in render coordinates.\n@param y a pointer filled with the y coordinate in render coordinates.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.SetLogicalPresentation\n@sa RendererBase.SetScale",
              "name": "RenderCoordinatesFromWindow",
              "kind": "function",
              "type": "std::optional<FPoint>",
              "parameters": [
                {
                  "name": "window_coord",
                  "type": "const SDL_FPoint &"
                }
              ],
              "sourceName": "SDL_RenderCoordinatesFromWindow",
              "immutable": true,
              "static": false
            },
            "RenderCoordinatesToWindow": {
              "doc": "Get a point in window coordinates when given a point in render coordinates.\n\nThis takes into account several states:\n\n- The window dimensions.\n- The logical presentation settings (RendererBase.SetLogicalPresentation)\n- The scale (RendererBase.SetScale)\n- The viewport (RendererBase.SetViewport)\n\n@param renderer the rendering context.\n@param x the x coordinate in render coordinates.\n@param y the y coordinate in render coordinates.\n@param window_x a pointer filled with the x coordinate in window\n                coordinates.\n@param window_y a pointer filled with the y coordinate in window\n                coordinates.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.SetLogicalPresentation\n@sa RendererBase.SetScale\n@sa RendererBase.SetViewport",
              "name": "RenderCoordinatesToWindow",
              "kind": "function",
              "type": "std::optional<FPoint>",
              "parameters": [
                {
                  "name": "coord",
                  "type": "const SDL_FPoint &"
                }
              ],
              "sourceName": "SDL_RenderCoordinatesToWindow",
              "immutable": true,
              "static": false
            },
            "ConvertEventToRenderCoordinates": {
              "doc": "Convert the coordinates in an event to render coordinates.\n\nThis takes into account several states:\n\n- The window dimensions.\n- The logical presentation settings (RendererBase.SetLogicalPresentation)\n- The scale (RendererBase.SetScale)\n- The viewport (RendererBase.SetViewport)\n\nVarious event types are converted with this function: mouse, touch, pen,\netc.\n\nTouch coordinates are converted from normalized coordinates in the window\nto non-normalized rendering coordinates.\n\nRelative mouse coordinates (xrel and yrel event fields) are _also_\nconverted. Applications that do not want these fields converted should use\nRendererBase.RenderCoordinatesFromWindow() on the specific event fields instead of\nconverting the entire event structure.\n\nOnce converted, coordinates may be outside the rendering area.\n\n@param event the event to modify.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.RenderCoordinatesFromWindow",
              "name": "ConvertEventToRenderCoordinates",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "event",
                  "type": "SDL_Event *"
                }
              ],
              "sourceName": "SDL_ConvertEventToRenderCoordinates",
              "immutable": true
            },
            "ResetViewport": {
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "name": "ResetViewport",
              "doc": ""
            },
            "SetViewport": {
              "doc": "Set the drawing area for rendering on the current target.\n\nDrawing will clip to this area (separately from any clipping done with\nRendererBase.SetClipRect), and the top left of the area will become coordinate\n(0, 0) for future drawing commands.\n\nThe area's width and height must be >= 0.\n\nEach render target has its own viewport. This function sets the viewport\nfor the current render target.\n\n@param renderer the rendering context.\n@param rect the Rect structure representing the drawing area, or nullptr\n            to set the viewport to the entire target.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.GetViewport\n@sa RendererBase.IsViewportSet",
              "name": "SetViewport",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "rect",
                  "type": "OptionalRef<const SDL_Rect>"
                }
              ],
              "sourceName": "SDL_SetRenderViewport",
              "static": false
            },
            "GetViewport": {
              "doc": "Get the drawing area for the current target.\n\nEach render target has its own viewport. This function gets the viewport\nfor the current render target.\n\n@param renderer the rendering context.\n@param rect an Rect structure filled in with the current drawing area.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.IsViewportSet\n@sa RendererBase.SetViewport",
              "name": "GetViewport",
              "kind": "function",
              "type": "std::optional<Rect>",
              "parameters": [],
              "sourceName": "SDL_GetRenderViewport",
              "immutable": true
            },
            "IsViewportSet": {
              "doc": "Return whether an explicit rectangle was set as the viewport.\n\nThis is useful if you're saving and restoring the viewport and want to know\nwhether you should restore a specific rectangle or nullptr. Note that the\nviewport is always reset when changing rendering targets.\n\nEach render target has its own viewport. This function checks the viewport\nfor the current render target.\n\n@returns true if the viewport was set to a specific rectangle, or false if\n         it was set to nullptr (the entire target).\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.GetViewport\n@sa RendererBase.SetViewport",
              "name": "IsViewportSet",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_RenderViewportSet",
              "immutable": true
            },
            "GetSafeArea": {
              "doc": "Get the safe area for rendering within the current viewport.\n\nSome devices have portions of the screen which are partially obscured or\nnot interactive, possibly due to on-screen controls, curved edges, camera\nnotches, TV overscan, etc. This function provides the area of the current\nviewport which is safe to have interactible content. You should continue\nrendering into the rest of the render target, but it should not contain\nvisually important or interactible content.\n\n@param renderer the rendering context.\n@param rect a pointer filled in with the area that is safe for interactive\n            content.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetSafeArea",
              "kind": "function",
              "type": "std::optional<Rect>",
              "parameters": [],
              "sourceName": "SDL_GetRenderSafeArea",
              "immutable": true
            },
            "ResetClipRect": {
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "name": "ResetClipRect",
              "doc": ""
            },
            "SetClipRect": {
              "doc": "Set the clip rectangle for rendering on the specified target.\n\nEach render target has its own clip rectangle. This function sets the\ncliprect for the current render target.\n\n@param renderer the rendering context.\n@param rect an Rect structure representing the clip area, relative to\n            the viewport, or nullptr to disable clipping.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.GetClipRect\n@sa RendererBase.IsClipEnabled",
              "name": "SetClipRect",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "rect",
                  "type": "OptionalRef<const SDL_Rect>"
                }
              ],
              "sourceName": "SDL_SetRenderClipRect",
              "static": false
            },
            "GetClipRect": {
              "doc": "Get the clip rectangle for the current target.\n\nEach render target has its own clip rectangle. This function gets the\ncliprect for the current render target.\n\n@param renderer the rendering context.\n@param rect an Rect structure filled in with the current clipping area\n            or an empty rectangle if clipping is disabled.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.IsClipEnabled\n@sa RendererBase.SetClipRect",
              "name": "GetClipRect",
              "kind": "function",
              "type": "std::optional<Rect>",
              "parameters": [],
              "sourceName": "SDL_GetRenderClipRect",
              "immutable": true
            },
            "IsClipEnabled": {
              "doc": "Get whether clipping is enabled on the given render target.\n\nEach render target has its own clip rectangle. This function checks the\ncliprect for the current render target.\n\n@returns true if clipping is enabled or false if not; call GetError()\n         for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.GetClipRect\n@sa RendererBase.SetClipRect",
              "name": "IsClipEnabled",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_RenderClipEnabled",
              "immutable": true
            },
            "SetScale": {
              "doc": "Set the drawing scale for rendering on the current target.\n\nThe drawing coordinates are scaled by the x/y scaling factors before they\nare used by the renderer. This allows resolution independent drawing with a\nsingle coordinate system.\n\nIf this results in scaling or subpixel drawing by the rendering backend, it\nwill be handled using the appropriate quality hints. For best results use\ninteger scaling factors.\n\nEach render target has its own scale. This function sets the scale for the\ncurrent render target.\n\n@param renderer the rendering context.\n@param scaleX the horizontal scaling factor.\n@param scaleY the vertical scaling factor.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.GetScale",
              "name": "SetScale",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "scale",
                  "type": "SDL_FPoint"
                }
              ],
              "sourceName": "SDL_SetRenderScale",
              "static": false
            },
            "GetScale": [
              {
                "kind": "function",
                "immutable": true,
                "type": "std::optional<FPoint>",
                "parameters": [],
                "name": "GetScale",
                "doc": ""
              },
              {
                "doc": "Get the drawing scale for the current target.\n\nEach render target has its own scale. This function gets the scale for the\ncurrent render target.\n\n@param scaleX a pointer filled in with the horizontal scaling factor.\n@param scaleY a pointer filled in with the vertical scaling factor.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.SetScale",
                "name": "GetScale",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "scaleX",
                    "type": "float *"
                  },
                  {
                    "name": "scaleY",
                    "type": "float *"
                  }
                ],
                "sourceName": "SDL_GetRenderScale",
                "immutable": true
              }
            ],
            "SetDrawColor": [
              {
                "doc": "Set the color used for drawing operations.\n\nSet the color for drawing or filling rectangles, lines, and points, and for\nRendererBase.RenderClear().\n\n@param renderer the rendering context.\n@param r the red value used to draw on the rendering target.\n@param g the green value used to draw on the rendering target.\n@param b the blue value used to draw on the rendering target.\n@param a the alpha value used to draw on the rendering target; usually\n         `SDL_ALPHA_OPAQUE` (255). Use RendererBase.SetDrawBlendMode to\n         specify how the alpha channel is used.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.GetDrawColor\n@sa RendererBase.SetDrawColor",
                "name": "SetDrawColor",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "c",
                    "type": "SDL_Color"
                  }
                ],
                "sourceName": "SDL_SetRenderDrawColor",
                "static": false
              },
              {
                "doc": "Set the color used for drawing operations (Rect, Line and Clear).\n\nSet the color for drawing or filling rectangles, lines, and points, and for\nRendererBase.RenderClear().\n\n@param renderer the rendering context.\n@param r the red value used to draw on the rendering target.\n@param g the green value used to draw on the rendering target.\n@param b the blue value used to draw on the rendering target.\n@param a the alpha value used to draw on the rendering target. Use\n         RendererBase.SetDrawBlendMode to specify how the alpha channel is\n         used.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.GetDrawColor\n@sa RendererBase.SetDrawColor",
                "name": "SetDrawColor",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "c",
                    "type": "SDL_FColor"
                  }
                ],
                "sourceName": "SDL_SetRenderDrawColorFloat",
                "static": false
              }
            ],
            "GetDrawColor": [
              {
                "kind": "function",
                "immutable": true,
                "type": "std::optional<FColor>",
                "parameters": [],
                "name": "GetDrawColor",
                "doc": ""
              },
              {
                "kind": "function",
                "immutable": true,
                "type": "bool",
                "parameters": [
                  {
                    "type": "SDL_Color *",
                    "name": "c"
                  }
                ],
                "name": "GetDrawColor",
                "doc": ""
              },
              {
                "kind": "function",
                "immutable": true,
                "type": "bool",
                "parameters": [
                  {
                    "type": "SDL_FColor *",
                    "name": "c"
                  }
                ],
                "name": "GetDrawColor",
                "doc": ""
              },
              {
                "doc": "Get the color used for drawing operations (Rect, Line and Clear).\n\n@param r a pointer filled in with the red value used to draw on the\n         rendering target.\n@param g a pointer filled in with the green value used to draw on the\n         rendering target.\n@param b a pointer filled in with the blue value used to draw on the\n         rendering target.\n@param a a pointer filled in with the alpha value used to draw on the\n         rendering target; usually `SDL_ALPHA_OPAQUE` (255).\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.GetDrawColor\n@sa RendererBase.SetDrawColor",
                "name": "GetDrawColor",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "r",
                    "type": "Uint8 *"
                  },
                  {
                    "name": "g",
                    "type": "Uint8 *"
                  },
                  {
                    "name": "b",
                    "type": "Uint8 *"
                  },
                  {
                    "name": "a",
                    "type": "Uint8 *"
                  }
                ],
                "sourceName": "SDL_GetRenderDrawColor",
                "immutable": true
              },
              {
                "doc": "Get the color used for drawing operations (Rect, Line and Clear).\n\n@param r a pointer filled in with the red value used to draw on the\n         rendering target.\n@param g a pointer filled in with the green value used to draw on the\n         rendering target.\n@param b a pointer filled in with the blue value used to draw on the\n         rendering target.\n@param a a pointer filled in with the alpha value used to draw on the\n         rendering target.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.SetDrawColor\n@sa RendererBase.GetDrawColor",
                "name": "GetDrawColor",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "r",
                    "type": "float *"
                  },
                  {
                    "name": "g",
                    "type": "float *"
                  },
                  {
                    "name": "b",
                    "type": "float *"
                  },
                  {
                    "name": "a",
                    "type": "float *"
                  }
                ],
                "sourceName": "SDL_GetRenderDrawColorFloat",
                "immutable": true
              }
            ],
            "SetColorScale": {
              "doc": "Set the color scale used for render operations.\n\nThe color scale is an additional scale multiplied into the pixel color\nvalue while rendering. This can be used to adjust the brightness of colors\nduring HDR rendering, or changing HDR video brightness when playing on an\nSDR display.\n\nThe color scale does not affect the alpha channel, only the color\nbrightness.\n\n@param scale the color scale value.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.GetColorScale",
              "name": "SetColorScale",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "scale",
                  "type": "float"
                }
              ],
              "sourceName": "SDL_SetRenderColorScale"
            },
            "GetColorScale": {
              "doc": "Get the color scale used for render operations.\n\n@param renderer the rendering context.\n@param scale a pointer filled in with the current color scale value.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.SetColorScale",
              "name": "GetColorScale",
              "kind": "function",
              "type": "std::optional<float>",
              "parameters": [],
              "sourceName": "SDL_GetRenderColorScale",
              "immutable": true
            },
            "SetDrawBlendMode": {
              "doc": "Set the blend mode used for drawing operations (Fill and Line).\n\nIf the blend mode is not supported, the closest supported mode is chosen.\n\n@param blendMode the BlendMode to use for blending.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.GetDrawBlendMode",
              "name": "SetDrawBlendMode",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "blendMode",
                  "type": "BlendMode"
                }
              ],
              "sourceName": "SDL_SetRenderDrawBlendMode"
            },
            "GetDrawBlendMode": {
              "doc": "Get the blend mode used for drawing operations.\n\n@param renderer the rendering context.\n@param blendMode a pointer filled in with the current BlendMode.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.SetDrawBlendMode",
              "name": "GetDrawBlendMode",
              "kind": "function",
              "type": "std::optional<BlendMode>",
              "parameters": [],
              "sourceName": "SDL_GetRenderDrawBlendMode",
              "immutable": true
            },
            "RenderClear": {
              "doc": "Clear the current rendering target with the drawing color.\n\nThis function clears the entire rendering target, ignoring the viewport and\nthe clip rectangle. Note, that clearing will also set/fill all pixels of\nthe rendering target to current renderer draw color, so make sure to invoke\nRendererBase.SetDrawColor() when needed.\n\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.SetDrawColor",
              "name": "RenderClear",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_RenderClear"
            },
            "RenderPoint": {
              "doc": "Draw a point on the current rendering target at subpixel precision.\n\n@param renderer the renderer which should draw a point.\n@param x the x coordinate of the point.\n@param y the y coordinate of the point.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.RenderPoints",
              "name": "RenderPoint",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "p",
                  "type": "SDL_FPoint"
                }
              ],
              "sourceName": "SDL_RenderPoint",
              "static": false
            },
            "RenderPoints": {
              "doc": "Draw multiple points on the current rendering target at subpixel precision.\n\n@param renderer the renderer which should draw multiple points.\n@param points the points to draw.\n@param count the number of points to draw.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.RenderPoint",
              "name": "RenderPoints",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "points",
                  "type": "SpanRef<const SDL_FPoint>"
                }
              ],
              "sourceName": "SDL_RenderPoints",
              "static": false
            },
            "RenderLine": {
              "doc": "Draw a line on the current rendering target at subpixel precision.\n\n@param renderer the renderer which should draw a line.\n@param x1 the x coordinate of the start point.\n@param y1 the y coordinate of the start point.\n@param x2 the x coordinate of the end point.\n@param y2 the y coordinate of the end point.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.RenderLines",
              "name": "RenderLine",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "p1",
                  "type": "SDL_FPoint"
                },
                {
                  "name": "p2",
                  "type": "SDL_FPoint"
                }
              ],
              "sourceName": "SDL_RenderLine",
              "static": false
            },
            "RenderLines": {
              "doc": "Draw a series of connected lines on the current rendering target at\nsubpixel precision.\n\n@param renderer the renderer which should draw multiple lines.\n@param points the points along the lines.\n@param count the number of points, drawing count-1 lines.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.RenderLine",
              "name": "RenderLines",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "points",
                  "type": "SpanRef<const SDL_FPoint>"
                }
              ],
              "sourceName": "SDL_RenderLines",
              "static": false
            },
            "RenderRect": {
              "doc": "Draw a rectangle on the current rendering target at subpixel precision.\n\n@param renderer the renderer which should draw a rectangle.\n@param rect a pointer to the destination rectangle, or nullptr to outline the\n            entire rendering target.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.RenderRects",
              "name": "RenderRect",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "rect",
                  "type": "OptionalRef<const SDL_FRect>"
                }
              ],
              "sourceName": "SDL_RenderRect",
              "static": false
            },
            "RenderRects": {
              "doc": "Draw some number of rectangles on the current rendering target at subpixel\nprecision.\n\n@param renderer the renderer which should draw multiple rectangles.\n@param rects a pointer to an array of destination rectangles.\n@param count the number of rectangles.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.RenderRect",
              "name": "RenderRects",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "rects",
                  "type": "SpanRef<const SDL_FRect>"
                }
              ],
              "sourceName": "SDL_RenderRects",
              "static": false
            },
            "RenderFillRect": {
              "doc": "Fill a rectangle on the current rendering target with the drawing color at\nsubpixel precision.\n\n@param renderer the renderer which should fill a rectangle.\n@param rect a pointer to the destination rectangle, or nullptr for the entire\n            rendering target.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.RenderFillRects",
              "name": "RenderFillRect",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "rect",
                  "type": "OptionalRef<const SDL_FRect>"
                }
              ],
              "sourceName": "SDL_RenderFillRect",
              "static": false
            },
            "RenderFillRects": {
              "doc": "Fill some number of rectangles on the current rendering target with the\ndrawing color at subpixel precision.\n\n@param renderer the renderer which should fill multiple rectangles.\n@param rects a pointer to an array of destination rectangles.\n@param count the number of rectangles.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.RenderFillRect",
              "name": "RenderFillRects",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "rects",
                  "type": "SpanRef<const SDL_FRect>"
                }
              ],
              "sourceName": "SDL_RenderFillRects",
              "static": false
            },
            "RenderTexture": {
              "doc": "Copy a portion of the texture to the current rendering target at subpixel\nprecision.\n\n@param renderer the renderer which should copy parts of a texture.\n@param texture the source texture.\n@param srcrect a pointer to the source rectangle, or nullptr for the entire\n               texture.\n@param dstrect a pointer to the destination rectangle, or nullptr for the\n               entire rendering target.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.RenderTextureRotated\n@sa RendererBase.RenderTextureTiled",
              "name": "RenderTexture",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "texture",
                  "type": "TextureRef"
                },
                {
                  "name": "srcrect",
                  "type": "OptionalRef<const SDL_FRect>"
                },
                {
                  "name": "dstrect",
                  "type": "OptionalRef<const SDL_FRect>"
                }
              ],
              "sourceName": "SDL_RenderTexture",
              "static": false
            },
            "RenderTextureRotated": {
              "doc": "Copy a portion of the source texture to the current rendering target, with\nrotation and flipping, at subpixel precision.\n\n@param renderer the renderer which should copy parts of a texture.\n@param texture the source texture.\n@param srcrect a pointer to the source rectangle, or nullptr for the entire\n               texture.\n@param dstrect a pointer to the destination rectangle, or nullptr for the\n               entire rendering target.\n@param angle an angle in degrees that indicates the rotation that will be\n             applied to dstrect, rotating it in a clockwise direction.\n@param center a pointer to a point indicating the point around which\n              dstrect will be rotated (if nullptr, rotation will be done\n              around dstrect.w/2, dstrect.h/2).\n@param flip an FlipMode value stating which flipping actions should be\n            performed on the texture.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.RenderTexture",
              "name": "RenderTextureRotated",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "texture",
                  "type": "TextureRef"
                },
                {
                  "name": "srcrect",
                  "type": "OptionalRef<const SDL_FRect>"
                },
                {
                  "name": "dstrect",
                  "type": "OptionalRef<const SDL_FRect>"
                },
                {
                  "name": "angle",
                  "type": "double"
                },
                {
                  "name": "center",
                  "type": "OptionalRef<const SDL_FPoint>",
                  "default": "{}"
                },
                {
                  "name": "flip",
                  "type": "FlipMode",
                  "default": "SDL_FLIP_NONE"
                }
              ],
              "sourceName": "SDL_RenderTextureRotated",
              "static": false
            },
            "RenderTextureAffine": {
              "doc": "Copy a portion of the source texture to the current rendering target, with\naffine transform, at subpixel precision.\n\n@param renderer the renderer which should copy parts of a texture.\n@param texture the source texture.\n@param srcrect a pointer to the source rectangle, or nullptr for the entire\n               texture.\n@param origin a pointer to a point indicating where the top-left corner of\n              srcrect should be mapped to, or nullptr for the rendering\n              target's origin.\n@param right a pointer to a point indicating where the top-right corner of\n             srcrect should be mapped to, or nullptr for the rendering\n             target's top-right corner.\n@param down a pointer to a point indicating where the bottom-left corner of\n            srcrect should be mapped to, or nullptr for the rendering target's\n            bottom-left corner.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety You may only call this function from the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.RenderTexture",
              "name": "RenderTextureAffine",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "texture",
                  "type": "TextureRef"
                },
                {
                  "name": "srcrect",
                  "type": "OptionalRef<const SDL_FRect>"
                },
                {
                  "name": "origin",
                  "type": "OptionalRef<const SDL_FPoint>"
                },
                {
                  "name": "right",
                  "type": "OptionalRef<const SDL_FPoint>"
                },
                {
                  "name": "down",
                  "type": "OptionalRef<const SDL_FPoint>"
                }
              ],
              "sourceName": "SDL_RenderTextureAffine",
              "static": false
            },
            "RenderTextureTiled": {
              "doc": "Tile a portion of the texture to the current rendering target at subpixel\nprecision.\n\nThe pixels in `srcrect` will be repeated as many times as needed to\ncompletely fill `dstrect`.\n\n@param renderer the renderer which should copy parts of a texture.\n@param texture the source texture.\n@param srcrect a pointer to the source rectangle, or nullptr for the entire\n               texture.\n@param scale the scale used to transform srcrect into the destination\n             rectangle, e.g. a 32x32 texture with a scale of 2 would fill\n             64x64 tiles.\n@param dstrect a pointer to the destination rectangle, or nullptr for the\n               entire rendering target.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.RenderTexture",
              "name": "RenderTextureTiled",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "texture",
                  "type": "TextureRef"
                },
                {
                  "name": "srcrect",
                  "type": "OptionalRef<const SDL_FRect>"
                },
                {
                  "name": "scale",
                  "type": "float"
                },
                {
                  "name": "dstrect",
                  "type": "OptionalRef<const SDL_FRect>"
                }
              ],
              "sourceName": "SDL_RenderTextureTiled",
              "static": false
            },
            "RenderTexture9Grid": {
              "doc": "Perform a scaled copy using the 9-grid algorithm to the current rendering\ntarget at subpixel precision.\n\nThe pixels in the texture are split into a 3x3 grid, using the different\ncorner sizes for each corner, and the sides and center making up the\nremaining pixels. The corners are then scaled using `scale` and fit into\nthe corners of the destination rectangle. The sides and center are then\nstretched into place to cover the remaining destination rectangle.\n\n@param renderer the renderer which should copy parts of a texture.\n@param texture the source texture.\n@param srcrect the Rect structure representing the rectangle to be used\n               for the 9-grid, or nullptr to use the entire texture.\n@param left_width the width, in pixels, of the left corners in `srcrect`.\n@param right_width the width, in pixels, of the right corners in `srcrect`.\n@param top_height the height, in pixels, of the top corners in `srcrect`.\n@param bottom_height the height, in pixels, of the bottom corners in\n                     `srcrect`.\n@param scale the scale used to transform the corner of `srcrect` into the\n             corner of `dstrect`, or 0.0f for an unscaled copy.\n@param dstrect a pointer to the destination rectangle, or nullptr for the\n               entire rendering target.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.RenderTexture",
              "name": "RenderTexture9Grid",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "texture",
                  "type": "TextureRef"
                },
                {
                  "name": "srcrect",
                  "type": "OptionalRef<const SDL_FRect>"
                },
                {
                  "name": "left_width",
                  "type": "float"
                },
                {
                  "name": "right_width",
                  "type": "float"
                },
                {
                  "name": "top_height",
                  "type": "float"
                },
                {
                  "name": "bottom_height",
                  "type": "float"
                },
                {
                  "name": "scale",
                  "type": "float"
                },
                {
                  "name": "dstrect",
                  "type": "OptionalRef<const SDL_FRect>"
                }
              ],
              "sourceName": "SDL_RenderTexture9Grid",
              "static": false
            },
            "RenderGeometry": {
              "doc": "Render a list of triangles, optionally using a texture and indices into the\nvertex array Color and alpha modulation is done per vertex\n(TextureBase.SetColorMod and TextureBase.SetAlphaMod are ignored).\n\n@param renderer the rendering context.\n@param texture (optional) The SDL texture to use.\n@param vertices vertices.\n@param num_vertices number of vertices.\n@param indices (optional) An array of integer indices into the 'vertices'\n               array, if nullptr all vertices will be rendered in sequential\n               order.\n@param num_indices number of indices.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.RenderGeometryRaw",
              "name": "RenderGeometry",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "texture",
                  "type": "TextureRef"
                },
                {
                  "name": "vertices",
                  "type": "std::span<const Vertex>"
                },
                {
                  "name": "indices",
                  "type": "std::span<const int>",
                  "default": "{}"
                }
              ],
              "sourceName": "SDL_RenderGeometry",
              "static": false
            },
            "RenderGeometryRaw": {
              "doc": "Render a list of triangles, optionally using a texture and indices into the\nvertex arrays Color and alpha modulation is done per vertex\n(TextureBase.SetColorMod and TextureBase.SetAlphaMod are ignored).\n\n@param texture (optional) The SDL texture to use.\n@param xy vertex positions.\n@param xy_stride byte size to move from one element to the next element.\n@param color vertex colors (as FColor).\n@param color_stride byte size to move from one element to the next element.\n@param uv vertex normalized texture coordinates.\n@param uv_stride byte size to move from one element to the next element.\n@param num_vertices number of vertices.\n@param indices (optional) An array of indices into the 'vertices' arrays,\n               if nullptr all vertices will be rendered in sequential order.\n@param num_indices number of indices.\n@param size_indices index size: 1 (byte), 2 (short), 4 (int).\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.RenderGeometry",
              "name": "RenderGeometryRaw",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "texture",
                  "type": "TextureRef"
                },
                {
                  "name": "xy",
                  "type": "const float *"
                },
                {
                  "name": "xy_stride",
                  "type": "int"
                },
                {
                  "name": "color",
                  "type": "const FColor *"
                },
                {
                  "name": "color_stride",
                  "type": "int"
                },
                {
                  "name": "uv",
                  "type": "const float *"
                },
                {
                  "name": "uv_stride",
                  "type": "int"
                },
                {
                  "name": "num_vertices",
                  "type": "int"
                },
                {
                  "name": "indices",
                  "type": "const void *"
                },
                {
                  "name": "num_indices",
                  "type": "int"
                },
                {
                  "name": "size_indices",
                  "type": "int"
                }
              ],
              "sourceName": "SDL_RenderGeometryRaw"
            },
            "RenderReadPixels": {
              "doc": "Read pixels from the current rendering target.\n\nThe returned surface contains pixels inside the desired area clipped to the\ncurrent viewport, and should be freed with SurfaceBase.Destroy().\n\nNote that this returns the actual pixels on the screen, so if you are using\nlogical presentation you should use RendererBase.GetLogicalPresentationRect()\nto get the area containing your content.\n\n**WARNING**: This is a very slow operation, and should not be used\nfrequently. If you're using this on the main rendering target, it should be\ncalled after rendering and before RendererBase.Present().\n\n@param renderer the rendering context.\n@param rect an Rect structure representing the area to read, which will\n            be clipped to the current viewport, or nullptr for the entire\n            viewport.\n@returns a new SurfaceBase on success or nullptr on failure; call\n         GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "RenderReadPixels",
              "kind": "function",
              "type": "Surface",
              "parameters": [
                {
                  "name": "rect",
                  "type": "OptionalRef<const SDL_Rect>"
                }
              ],
              "sourceName": "SDL_RenderReadPixels",
              "immutable": true,
              "static": false
            },
            "Present": {
              "doc": "Update the screen with any rendering performed since the previous call.\n\nSDL's rendering functions operate on a backbuffer; that is, calling a\nrendering function such as RendererBase.RenderLine() does not directly put a line on\nthe screen, but rather updates the backbuffer. As such, you compose your\nentire scene and *present* the composed backbuffer to the screen as a\ncomplete picture.\n\nTherefore, when using SDL's rendering API, one does all drawing intended\nfor the frame, and then calls this function once per frame to present the\nfinal drawing to the user.\n\nThe backbuffer should be considered invalidated after each present; do not\nassume that previous contents will exist between frames. You are strongly\nencouraged to call RendererBase.RenderClear() to initialize the backbuffer before\nstarting each new frame's drawing, even if you plan to overwrite every\npixel.\n\nPlease note, that in case of rendering to a texture - there is **no need**\nto call `RendererBase.Present` after drawing needed objects to a texture, and\nshould not be done; you are only required to change back the rendering\ntarget to default via `RendererBase.SetTarget(renderer, nullptr)` afterwards, as\ntextures by themselves do not have a concept of backbuffers. Calling\nRendererBase.Present while rendering to a texture will still update the screen\nwith any current drawing that has been done _to the window itself_.\n\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.RendererBase\n@sa RendererBase.RenderClear\n@sa RendererBase.RenderFillRect\n@sa RendererBase.RenderFillRects\n@sa RendererBase.RenderLine\n@sa RendererBase.RenderLines\n@sa RendererBase.RenderPoint\n@sa RendererBase.RenderPoints\n@sa RendererBase.RenderRect\n@sa RendererBase.RenderRects\n@sa RendererBase.SetDrawBlendMode\n@sa RendererBase.SetDrawColor",
              "name": "Present",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_RenderPresent"
            },
            "Flush": {
              "doc": "Force the rendering context to flush any pending commands and state.\n\nYou do not need to (and in fact, shouldn't) call this function unless you\nare planning to call into OpenGL/Direct3D/Metal/whatever directly, in\naddition to using an RendererBase.\n\nThis is for a very-specific case: if you are using SDL's render API, and\nyou plan to make OpenGL/D3D/whatever calls in addition to SDL render API\ncalls. If this applies, you should call this function between calls to\nSDL's render API and the low-level API you're using in cooperation.\n\nIn all other cases, you can ignore this function.\n\nThis call makes SDL flush any pending rendering work it was queueing up to\ndo later in a single batch, and marks any internal cached state as invalid,\nso it'll prepare all its state again later, from scratch.\n\nThis means you do not need to save state in your rendering code to protect\nthe SDL renderer. However, there lots of arbitrary pieces of Direct3D and\nOpenGL state that can confuse things; you should use your best judgment and\nbe prepared to make changes if specific state needs to be protected.\n\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "Flush",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_FlushRenderer"
            },
            "SetVSync": {
              "doc": "Toggle VSync of the given renderer.\n\nWhen a renderer is created, vsync defaults to SDL_RENDERER_VSYNC_DISABLED.\n\nThe `vsync` parameter can be 1 to synchronize present with every vertical\nrefresh, 2 to synchronize present with every second vertical refresh, etc.,\nSDL_RENDERER_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync), or\nSDL_RENDERER_VSYNC_DISABLED to disable. Not every value is supported by\nevery driver, so you should check the return value to see whether the\nrequested setting is supported.\n\n@param vsync the vertical refresh sync interval.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.GetVSync",
              "name": "SetVSync",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "vsync",
                  "type": "int"
                }
              ],
              "sourceName": "SDL_SetRenderVSync"
            },
            "GetVSync": {
              "doc": "Get VSync of the given renderer.\n\n@param renderer the renderer to toggle.\n@param vsync an int filled with the current vertical refresh sync interval.\n             See RendererBase.SetVSync() for the meaning of the value.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.SetVSync",
              "name": "GetVSync",
              "kind": "function",
              "type": "std::optional<int>",
              "parameters": [],
              "sourceName": "SDL_GetRenderVSync",
              "immutable": true
            },
            "RenderDebugText": {
              "doc": "Draw debug text to an RendererBase.\n\nThis function will render a string of text to an RendererBase. Note that\nthis is a convenience function for debugging, with severe limitations, and\nnot intended to be used for production apps and games.\n\nAmong these limitations:\n\n- It accepts UTF-8 strings, but will only renders ASCII characters.\n- It has a single, tiny size (8x8 pixels). One can use logical presentation\n  or scaling to adjust it, but it will be blurry.\n- It uses a simple, hardcoded bitmap font. It does not allow different font\n  selections and it does not support truetype, for proper scaling.\n- It does no word-wrapping and does not treat newline characters as a line\n  break. If the text goes out of the window, it's gone.\n\nFor serious text rendering, there are several good options, such as\nSDL_ttf, stb_truetype, or other external libraries.\n\nOn first use, this will create an internal texture for rendering glyphs.\nThis texture will live until the renderer is destroyed.\n\nThe text is drawn in the color specified by RendererBase.SetDrawColor().\n\n@param x the x coordinate where the top-left corner of the text will draw.\n@param y the y coordinate where the top-left corner of the text will draw.\n@param str the string to render.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SDL_RenderDebugTextFormat\n@sa SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE",
              "name": "RenderDebugText",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "p",
                  "type": "FPoint"
                },
                {
                  "name": "str",
                  "type": "StringParam"
                }
              ],
              "sourceName": "SDL_RenderDebugText"
            },
            "RenderDebugTextFormat": {
              "kind": "function",
              "type": "bool",
              "template": [
                {
                  "type": "class...",
                  "name": "ARGS"
                }
              ],
              "parameters": [
                {
                  "type": "FPoint",
                  "name": "p"
                },
                {
                  "type": "std::string_view",
                  "name": "fmt"
                },
                {
                  "type": "ARGS...",
                  "name": "args"
                }
              ],
              "name": "RenderDebugTextFormat",
              "doc": ""
            },
            "Destroy": {
              "doc": "Destroy the rendering context for a window and free all associated\ntextures.\n\nThis should be called before destroying the associated window.\n\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.RendererBase",
              "name": "Destroy",
              "kind": "function",
              "type": "void",
              "parameters": [],
              "sourceName": "SDL_DestroyRenderer"
            }
          }
        },
        "ObjectRef<SDL_Renderer>::doFree": {
          "name": "ObjectRef<SDL_Renderer>::doFree",
          "type": "void",
          "kind": "function",
          "doc": "Callback for renderer resource cleanup\n\n@private",
          "template": [],
          "parameters": [
            {
              "type": "SDL_Renderer *",
              "name": "resource"
            }
          ],
          "sourceName": "SDL_DestroyRenderer"
        },
        "TextureBase": {
          "doc": "An efficient driver-specific representation of pixel data\n\n@since This struct is available since SDL 3.2.0.\n\n@sa TextureBase.TextureBase\n@sa TextureBase.TextureBase\n@sa TextureBase.TextureBase\n@sa TextureBase.Destroy",
          "name": "TextureBase",
          "kind": "struct",
          "sourceName": "SDL_Texture",
          "type": "T",
          "template": [
            {
              "type": "ObjectBox<SDL_Texture *>",
              "name": "T"
            }
          ],
          "entries": {
            "T::T": {
              "kind": "alias",
              "name": "T::T",
              "doc": ""
            },
            "TextureBase": [
              {
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "type": "RendererRef",
                    "name": "renderer"
                  },
                  {
                    "type": "StringParam",
                    "name": "file"
                  }
                ],
                "name": "TextureBase",
                "doc": ""
              },
              {
                "doc": "Create a texture for a rendering context.\n\nThe contents of a texture when first created are not defined.\n\n@param renderer the rendering context.\n@param format one of the enumerated values in PixelFormat.\n@param access one of the enumerated values in TextureAccess.\n@param w the width of the texture in pixels.\n@param h the height of the texture in pixels.\n@post the created texture or nullptr on failure; call GetError() for\n         more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa TextureBase.TextureBase\n@sa TextureBase.TextureBase\n@sa TextureBase.Destroy\n@sa SDL_GetTextureSize\n@sa TextureBase.Update",
                "name": "TextureBase",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "renderer",
                    "type": "RendererRef"
                  },
                  {
                    "name": "format",
                    "type": "PixelFormat"
                  },
                  {
                    "name": "access",
                    "type": "TextureAccess"
                  },
                  {
                    "name": "w",
                    "type": "int"
                  },
                  {
                    "name": "h",
                    "type": "int"
                  }
                ],
                "sourceName": "SDL_CreateTexture"
              },
              {
                "doc": "Create a texture from an existing surface.\n\nThe surface is not modified or freed by this function.\n\nThe TextureAccess hint for the created texture is\n`TEXTUREACCESS_STATIC`.\n\nThe pixel format of the created texture may be different from the pixel\nformat of the surface, and can be queried using the\nprop::Texture.FORMAT_NUMBER property.\n\n@param renderer the rendering context.\n@param surface the SurfaceBase structure containing pixel data used to fill\n               the texture.\n@post the created texture or nullptr on failure; call GetError() for\n         more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa TextureBase.TextureBase\n@sa TextureBase.TextureBase\n@sa TextureBase.Destroy",
                "name": "TextureBase",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "renderer",
                    "type": "RendererRef"
                  },
                  {
                    "name": "surface",
                    "type": "SurfaceRef"
                  }
                ],
                "sourceName": "SDL_CreateTextureFromSurface"
              },
              {
                "doc": "Create a texture for a rendering context with the specified properties.\n\nThese are the supported properties:\n\n- `SDL_PROP_TEXTURE_CREATE_COLORSPACE_NUMBER`: an Colorspace value\n  describing the texture colorspace, defaults to COLORSPACE_SRGB_LINEAR\n  for floating point textures, COLORSPACE_HDR10 for 10-bit textures,\n  COLORSPACE_SRGB for other RGB textures and COLORSPACE_JPEG for\n  YUV textures.\n- `prop::Texture.CREATE_FORMAT_NUMBER`: one of the enumerated values in\n  PixelFormat, defaults to the best RGBA format for the renderer\n- `prop::Texture.CREATE_ACCESS_NUMBER`: one of the enumerated values in\n  TextureAccess, defaults to TEXTUREACCESS_STATIC\n- `prop::Texture.CREATE_WIDTH_NUMBER`: the width of the texture in\n  pixels, required\n- `prop::Texture.CREATE_HEIGHT_NUMBER`: the height of the texture in\n  pixels, required\n- `prop::Texture.CREATE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating\n  point textures, this defines the value of 100% diffuse white, with higher\n  values being displayed in the High Dynamic Range headroom. This defaults\n  to 100 for HDR10 textures and 1.0 for floating point textures.\n- `prop::Texture.CREATE_HDR_HEADROOM_FLOAT`: for HDR10 and floating\n  point textures, this defines the maximum dynamic range used by the\n  content, in terms of the SDR white point. This would be equivalent to\n  maxCLL / prop::Texture.CREATE_SDR_WHITE_POINT_FLOAT for HDR10 content.\n  If this is defined, any values outside the range supported by the display\n  will be scaled into the available HDR headroom, otherwise they are\n  clipped.\n\nWith the direct3d11 renderer:\n\n- `prop::Texture.CREATE_D3D11_TEXTURE_POINTER`: the ID3D11Texture2D\n  associated with the texture, if you want to wrap an existing texture.\n- `prop::Texture.CREATE_D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D\n  associated with the U plane of a YUV texture, if you want to wrap an\n  existing texture.\n- `prop::Texture.CREATE_D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D\n  associated with the V plane of a YUV texture, if you want to wrap an\n  existing texture.\n\nWith the direct3d12 renderer:\n\n- `prop::Texture.CREATE_D3D12_TEXTURE_POINTER`: the ID3D12Resource\n  associated with the texture, if you want to wrap an existing texture.\n- `prop::Texture.CREATE_D3D12_TEXTURE_U_POINTER`: the ID3D12Resource\n  associated with the U plane of a YUV texture, if you want to wrap an\n  existing texture.\n- `prop::Texture.CREATE_D3D12_TEXTURE_V_POINTER`: the ID3D12Resource\n  associated with the V plane of a YUV texture, if you want to wrap an\n  existing texture.\n\nWith the metal renderer:\n\n- `prop::Texture.CREATE_METAL_PIXELBUFFER_POINTER`: the CVPixelBufferRef\n  associated with the texture, if you want to create a texture from an\n  existing pixel buffer.\n\nWith the opengl renderer:\n\n- `prop::Texture.CREATE_OPENGL_TEXTURE_NUMBER`: the GLuint texture\n  associated with the texture, if you want to wrap an existing texture.\n- `prop::Texture.CREATE_OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture\n  associated with the UV plane of an NV12 texture, if you want to wrap an\n  existing texture.\n- `prop::Texture.CREATE_OPENGL_TEXTURE_U_NUMBER`: the GLuint texture\n  associated with the U plane of a YUV texture, if you want to wrap an\n  existing texture.\n- `prop::Texture.CREATE_OPENGL_TEXTURE_V_NUMBER`: the GLuint texture\n  associated with the V plane of a YUV texture, if you want to wrap an\n  existing texture.\n\nWith the opengles2 renderer:\n\n- `prop::Texture.CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture\n  associated with the texture, if you want to wrap an existing texture.\n- `prop::Texture.CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture\n  associated with the texture, if you want to wrap an existing texture.\n- `prop::Texture.CREATE_OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture\n  associated with the UV plane of an NV12 texture, if you want to wrap an\n  existing texture.\n- `prop::Texture.CREATE_OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture\n  associated with the U plane of a YUV texture, if you want to wrap an\n  existing texture.\n- `prop::Texture.CREATE_OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture\n  associated with the V plane of a YUV texture, if you want to wrap an\n  existing texture.\n\nWith the vulkan renderer:\n\n- `prop::Texture.CREATE_VULKAN_TEXTURE_NUMBER`: the VkImage with layout\n  VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL associated with the texture, if\n  you want to wrap an existing texture.\n\n@param renderer the rendering context.\n@param props the properties to use.\n@post the created texture or nullptr on failure; call GetError() for\n         more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa CreateProperties\n@sa TextureBase.TextureBase\n@sa TextureBase.TextureBase\n@sa TextureBase.Destroy\n@sa SDL_GetTextureSize\n@sa TextureBase.Update",
                "name": "TextureBase",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "renderer",
                    "type": "RendererRef"
                  },
                  {
                    "name": "props",
                    "type": "PropertiesRef"
                  }
                ],
                "sourceName": "SDL_CreateTextureWithProperties"
              }
            ],
            "GetProperties": {
              "doc": "Get the properties associated with a texture.\n\nThe following read-only properties are provided by SDL:\n\n- `prop::Texture.COLORSPACE_NUMBER`: an Colorspace value describing\n  the texture colorspace.\n- `prop::Texture.FORMAT_NUMBER`: one of the enumerated values in\n  PixelFormat.\n- `prop::Texture.ACCESS_NUMBER`: one of the enumerated values in\n  TextureAccess.\n- `prop::Texture.WIDTH_NUMBER`: the width of the texture in pixels.\n- `prop::Texture.HEIGHT_NUMBER`: the height of the texture in pixels.\n- `prop::Texture.SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point\n  textures, this defines the value of 100% diffuse white, with higher\n  values being displayed in the High Dynamic Range headroom. This defaults\n  to 100 for HDR10 textures and 1.0 for other textures.\n- `prop::Texture.HDR_HEADROOM_FLOAT`: for HDR10 and floating point\n  textures, this defines the maximum dynamic range used by the content, in\n  terms of the SDR white point. If this is defined, any values outside the\n  range supported by the display will be scaled into the available HDR\n  headroom, otherwise they are clipped. This defaults to 1.0 for SDR\n  textures, 4.0 for HDR10 textures, and no default for floating point\n  textures.\n\nWith the direct3d11 renderer:\n\n- `prop::Texture.D3D11_TEXTURE_POINTER`: the ID3D11Texture2D associated\n  with the texture\n- `prop::Texture.D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D\n  associated with the U plane of a YUV texture\n- `prop::Texture.D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D\n  associated with the V plane of a YUV texture\n\nWith the direct3d12 renderer:\n\n- `prop::Texture.D3D12_TEXTURE_POINTER`: the ID3D12Resource associated\n  with the texture\n- `prop::Texture.D3D12_TEXTURE_U_POINTER`: the ID3D12Resource associated\n  with the U plane of a YUV texture\n- `prop::Texture.D3D12_TEXTURE_V_POINTER`: the ID3D12Resource associated\n  with the V plane of a YUV texture\n\nWith the vulkan renderer:\n\n- `prop::Texture.VULKAN_TEXTURE_NUMBER`: the VkImage associated with the\n  texture\n\nWith the opengl renderer:\n\n- `prop::Texture.OPENGL_TEXTURE_NUMBER`: the GLuint texture associated\n  with the texture\n- `prop::Texture.OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture\n  associated with the UV plane of an NV12 texture\n- `prop::Texture.OPENGL_TEXTURE_U_NUMBER`: the GLuint texture associated\n  with the U plane of a YUV texture\n- `prop::Texture.OPENGL_TEXTURE_V_NUMBER`: the GLuint texture associated\n  with the V plane of a YUV texture\n- `prop::Texture.OPENGL_TEXTURE_TARGET_NUMBER`: the GLenum for the\n  texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE_ARB`, etc)\n- `prop::Texture.OPENGL_TEX_W_FLOAT`: the texture coordinate width of\n  the texture (0.0 - 1.0)\n- `prop::Texture.OPENGL_TEX_H_FLOAT`: the texture coordinate height of\n  the texture (0.0 - 1.0)\n\nWith the opengles2 renderer:\n\n- `prop::Texture.OPENGLES2_TEXTURE_NUMBER`: the GLuint texture\n  associated with the texture\n- `prop::Texture.OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture\n  associated with the UV plane of an NV12 texture\n- `prop::Texture.OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture\n  associated with the U plane of a YUV texture\n- `prop::Texture.OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture\n  associated with the V plane of a YUV texture\n- `prop::Texture.OPENGLES2_TEXTURE_TARGET_NUMBER`: the GLenum for the\n  texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_EXTERNAL_OES`, etc)\n\n@returns a valid property ID on success or 0 on failure; call\n         GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetProperties",
              "kind": "function",
              "type": "PropertiesRef",
              "parameters": [],
              "sourceName": "SDL_GetTextureProperties",
              "immutable": true
            },
            "GetRenderer": {
              "doc": "Get the renderer that created an TextureBase.\n\n@returns a pointer to the RendererBase that created the texture, or nullptr on\n         failure; call GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetRenderer",
              "kind": "function",
              "type": "RendererRef",
              "parameters": [],
              "sourceName": "SDL_GetRendererFromTexture",
              "immutable": true
            },
            "SetColorAndAlphaMod": [
              {
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "type": "Color",
                    "name": "c"
                  }
                ],
                "name": "SetColorAndAlphaMod",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "type": "FColor",
                    "name": "c"
                  }
                ],
                "name": "SetColorAndAlphaMod",
                "doc": ""
              }
            ],
            "GetColorAndAlphaMod": [
              {
                "kind": "function",
                "type": "std::optional<FColor>",
                "immutable": true,
                "parameters": [],
                "name": "GetColorAndAlphaMod",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "bool",
                "immutable": true,
                "parameters": [
                  {
                    "type": "Color *",
                    "name": "c"
                  }
                ],
                "name": "GetColorAndAlphaMod",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "bool",
                "immutable": true,
                "parameters": [
                  {
                    "type": "FColor *",
                    "name": "c"
                  }
                ],
                "name": "GetColorAndAlphaMod",
                "doc": ""
              }
            ],
            "SetColorMod": [
              {
                "doc": "Set an additional color value multiplied into render copy operations.\n\nWhen this texture is rendered, during the copy operation each source color\nchannel is modulated by the appropriate color value according to the\nfollowing formula:\n\n`srcC = srcC * (color / 255)`\n\nColor modulation is not always supported by the renderer; it will return\nfalse if color modulation is not supported.\n\n@param r the red color value multiplied into copy operations.\n@param g the green color value multiplied into copy operations.\n@param b the blue color value multiplied into copy operations.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa TextureBase.GetColorMod\n@sa TextureBase.SetAlphaMod\n@sa TextureBase.SetColorMod",
                "name": "SetColorMod",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "r",
                    "type": "Uint8"
                  },
                  {
                    "name": "g",
                    "type": "Uint8"
                  },
                  {
                    "name": "b",
                    "type": "Uint8"
                  }
                ],
                "sourceName": "SDL_SetTextureColorMod"
              },
              {
                "doc": "Set an additional color value multiplied into render copy operations.\n\nWhen this texture is rendered, during the copy operation each source color\nchannel is modulated by the appropriate color value according to the\nfollowing formula:\n\n`srcC = srcC * color`\n\nColor modulation is not always supported by the renderer; it will return\nfalse if color modulation is not supported.\n\n@param r the red color value multiplied into copy operations.\n@param g the green color value multiplied into copy operations.\n@param b the blue color value multiplied into copy operations.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa TextureBase.GetColorMod\n@sa TextureBase.SetAlphaMod\n@sa TextureBase.SetColorMod",
                "name": "SetColorMod",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "r",
                    "type": "float"
                  },
                  {
                    "name": "g",
                    "type": "float"
                  },
                  {
                    "name": "b",
                    "type": "float"
                  }
                ],
                "sourceName": "SDL_SetTextureColorModFloat"
              }
            ],
            "GetColorMod": [
              {
                "doc": "Get the additional color value multiplied into render copy operations.\n\n@param r a pointer filled in with the current red color value.\n@param g a pointer filled in with the current green color value.\n@param b a pointer filled in with the current blue color value.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa TextureBase.GetAlphaMod\n@sa TextureBase.GetColorMod\n@sa TextureBase.SetColorMod",
                "name": "GetColorMod",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "r",
                    "type": "Uint8 *"
                  },
                  {
                    "name": "g",
                    "type": "Uint8 *"
                  },
                  {
                    "name": "b",
                    "type": "Uint8 *"
                  }
                ],
                "sourceName": "SDL_GetTextureColorMod",
                "immutable": true
              },
              {
                "doc": "Get the additional color value multiplied into render copy operations.\n\n@param r a pointer filled in with the current red color value.\n@param g a pointer filled in with the current green color value.\n@param b a pointer filled in with the current blue color value.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa TextureBase.GetAlphaMod\n@sa TextureBase.GetColorMod\n@sa TextureBase.SetColorMod",
                "name": "GetColorMod",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "r",
                    "type": "float *"
                  },
                  {
                    "name": "g",
                    "type": "float *"
                  },
                  {
                    "name": "b",
                    "type": "float *"
                  }
                ],
                "sourceName": "SDL_GetTextureColorModFloat",
                "immutable": true
              }
            ],
            "SetAlphaMod": [
              {
                "doc": "Set an additional alpha value multiplied into render copy operations.\n\nWhen this texture is rendered, during the copy operation the source alpha\nvalue is modulated by this alpha value according to the following formula:\n\n`srcA = srcA * (alpha / 255)`\n\nAlpha modulation is not always supported by the renderer; it will return\nfalse if alpha modulation is not supported.\n\n@param alpha the source alpha value multiplied into copy operations.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa TextureBase.GetAlphaMod\n@sa TextureBase.SetAlphaMod\n@sa TextureBase.SetColorMod",
                "name": "SetAlphaMod",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "alpha",
                    "type": "Uint8"
                  }
                ],
                "sourceName": "SDL_SetTextureAlphaMod"
              },
              {
                "doc": "Set an additional alpha value multiplied into render copy operations.\n\nWhen this texture is rendered, during the copy operation the source alpha\nvalue is modulated by this alpha value according to the following formula:\n\n`srcA = srcA * alpha`\n\nAlpha modulation is not always supported by the renderer; it will return\nfalse if alpha modulation is not supported.\n\n@param alpha the source alpha value multiplied into copy operations.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa TextureBase.GetAlphaMod\n@sa TextureBase.SetAlphaMod\n@sa TextureBase.SetColorMod",
                "name": "SetAlphaMod",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "alpha",
                    "type": "float"
                  }
                ],
                "sourceName": "SDL_SetTextureAlphaModFloat"
              }
            ],
            "GetAlphaMod": [
              {
                "kind": "function",
                "immutable": true,
                "type": "std::optional<float>",
                "parameters": [],
                "name": "GetAlphaMod",
                "doc": ""
              },
              {
                "doc": "Get the additional alpha value multiplied into render copy operations.\n\n@param alpha a pointer filled in with the current alpha value.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa TextureBase.GetAlphaMod\n@sa TextureBase.GetColorMod\n@sa TextureBase.SetAlphaMod",
                "name": "GetAlphaMod",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "alpha",
                    "type": "Uint8 *"
                  }
                ],
                "sourceName": "SDL_GetTextureAlphaMod",
                "immutable": true
              },
              {
                "doc": "Get the additional alpha value multiplied into render copy operations.\n\n@param alpha a pointer filled in with the current alpha value.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa TextureBase.GetAlphaMod\n@sa TextureBase.GetColorMod\n@sa TextureBase.SetAlphaMod",
                "name": "GetAlphaMod",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "alpha",
                    "type": "float *"
                  }
                ],
                "sourceName": "SDL_GetTextureAlphaModFloat",
                "immutable": true
              }
            ],
            "SetBlendMode": {
              "doc": "Set the blend mode for a texture, used by RendererBase.RenderTexture().\n\nIf the blend mode is not supported, the closest supported mode is chosen\nand this function returns false.\n\n@param blendMode the BlendMode to use for texture blending.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa TextureBase.GetBlendMode",
              "name": "SetBlendMode",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "blendMode",
                  "type": "BlendMode"
                }
              ],
              "sourceName": "SDL_SetTextureBlendMode"
            },
            "GetBlendMode": {
              "doc": "Get the blend mode used for texture copy operations.\n\n@param texture the texture to query.\n@param blendMode a pointer filled in with the current BlendMode.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa TextureBase.SetBlendMode",
              "name": "GetBlendMode",
              "kind": "function",
              "type": "std::optional<BlendMode>",
              "parameters": [],
              "sourceName": "SDL_GetTextureBlendMode",
              "immutable": true
            },
            "SetScaleMode": {
              "doc": "Set the scale mode used for texture scale operations.\n\nThe default texture scale mode is SCALEMODE_LINEAR.\n\nIf the scale mode is not supported, the closest supported mode is chosen.\n\n@param scaleMode the ScaleMode to use for texture scaling.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa TextureBase.GetScaleMode",
              "name": "SetScaleMode",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "scaleMode",
                  "type": "ScaleMode"
                }
              ],
              "sourceName": "SDL_SetTextureScaleMode"
            },
            "GetScaleMode": {
              "doc": "Get the scale mode used for texture scale operations.\n\n@param texture the texture to query.\n@param scaleMode a pointer filled in with the current scale mode.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa TextureBase.SetScaleMode",
              "name": "GetScaleMode",
              "kind": "function",
              "type": "std::optional<ScaleMode>",
              "parameters": [],
              "sourceName": "SDL_GetTextureScaleMode",
              "immutable": true
            },
            "Update": {
              "doc": "Update the given texture rectangle with new pixel data.\n\nThe pixel data must be in the pixel format of the texture, which can be\nqueried using the prop::Texture.FORMAT_NUMBER property.\n\nThis is a fairly slow function, intended for use with static textures that\ndo not change often.\n\nIf the texture is intended to be updated often, it is preferred to create\nthe texture as streaming and use the locking functions referenced below.\nWhile this function will work with streaming textures, for optimization\nreasons you may not get the pixels back if you lock the texture afterward.\n\n@param rect an Rect structure representing the area to update, or nullptr\n            to update the entire texture.\n@param pixels the raw pixel data in the format of the texture.\n@param pitch the number of bytes in a row of pixel data, including padding\n             between lines.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa TextureBase.Lock\n@sa TextureLock.Unlock\n@sa TextureBase.UpdateNV\n@sa TextureBase.UpdateYUV",
              "name": "Update",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "rect",
                  "type": "OptionalRef<const SDL_Rect>"
                },
                {
                  "name": "pixels",
                  "type": "const void *"
                },
                {
                  "name": "pitch",
                  "type": "int"
                }
              ],
              "sourceName": "SDL_UpdateTexture"
            },
            "UpdateYUV": {
              "doc": "Update a rectangle within a planar YV12 or IYUV texture with new pixel\ndata.\n\nYou can use TextureBase.Update() as long as your pixel data is a contiguous\nblock of Y and U/V planes in the proper order, but this function is\navailable if your pixel data is not contiguous.\n\n@param rect a pointer to the rectangle of pixels to update, or nullptr to\n            update the entire texture.\n@param Yplane the raw pixel data for the Y plane.\n@param Ypitch the number of bytes between rows of pixel data for the Y\n              plane.\n@param Uplane the raw pixel data for the U plane.\n@param Upitch the number of bytes between rows of pixel data for the U\n              plane.\n@param Vplane the raw pixel data for the V plane.\n@param Vpitch the number of bytes between rows of pixel data for the V\n              plane.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa TextureBase.UpdateNV\n@sa TextureBase.Update",
              "name": "UpdateYUV",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "rect",
                  "type": "OptionalRef<const SDL_Rect>"
                },
                {
                  "name": "Yplane",
                  "type": "const Uint8 *"
                },
                {
                  "name": "Ypitch",
                  "type": "int"
                },
                {
                  "name": "Uplane",
                  "type": "const Uint8 *"
                },
                {
                  "name": "Upitch",
                  "type": "int"
                },
                {
                  "name": "Vplane",
                  "type": "const Uint8 *"
                },
                {
                  "name": "Vpitch",
                  "type": "int"
                }
              ],
              "sourceName": "SDL_UpdateYUVTexture"
            },
            "UpdateNV": {
              "doc": "Update a rectangle within a planar NV12 or NV21 texture with new pixels.\n\nYou can use TextureBase.Update() as long as your pixel data is a contiguous\nblock of NV12/21 planes in the proper order, but this function is available\nif your pixel data is not contiguous.\n\n@param rect a pointer to the rectangle of pixels to update, or nullptr to\n            update the entire texture.\n@param Yplane the raw pixel data for the Y plane.\n@param Ypitch the number of bytes between rows of pixel data for the Y\n              plane.\n@param UVplane the raw pixel data for the UV plane.\n@param UVpitch the number of bytes between rows of pixel data for the UV\n               plane.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa TextureBase.Update\n@sa TextureBase.UpdateYUV",
              "name": "UpdateNV",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "rect",
                  "type": "OptionalRef<const SDL_Rect>"
                },
                {
                  "name": "Yplane",
                  "type": "const Uint8 *"
                },
                {
                  "name": "Ypitch",
                  "type": "int"
                },
                {
                  "name": "UVplane",
                  "type": "const Uint8 *"
                },
                {
                  "name": "UVpitch",
                  "type": "int"
                }
              ],
              "sourceName": "SDL_UpdateNVTexture"
            },
            "Lock": {
              "doc": "Lock a portion of the texture for **write-only** pixel access.\n\nAs an optimization, the pixels made available for editing don't necessarily\ncontain the old texture data. This is a write-only operation, and if you\nneed to keep a copy of the texture data you should do that at the\napplication level.\n\nYou must use TextureLock.Unlock() to unlock the pixels and apply any\nchanges.\n\n@param texture the texture to lock for access, which was created with\n               `TEXTUREACCESS_STREAMING`.\n@param rect an Rect structure representing the area to lock for access;\n            nullptr to lock the entire texture.\n@param pixels this is filled in with a pointer to the locked pixels,\n              appropriately offset by the locked area.\n@param pitch this is filled in with the pitch of the locked pixels; the\n             pitch is the length of one row in bytes.\n@returns true on success or false if the texture is not valid or was not\n         created with `TEXTUREACCESS_STREAMING`; call GetError()\n         for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SDL_LockTextureToSurface\n@sa TextureLock.Unlock",
              "name": "Lock",
              "kind": "function",
              "type": "TextureLock",
              "parameters": [
                {
                  "name": "rect",
                  "type": "OptionalRef<const SDL_Rect>"
                }
              ],
              "sourceName": "SDL_LockTexture",
              "static": false,
              "reference": 1
            },
            "GetWidth": {
              "kind": "function",
              "immutable": true,
              "type": "int",
              "parameters": [],
              "name": "GetWidth",
              "doc": ""
            },
            "GetHeight": {
              "kind": "function",
              "immutable": true,
              "type": "int",
              "parameters": [],
              "name": "GetHeight",
              "doc": ""
            },
            "GetSize": {
              "kind": "function",
              "immutable": true,
              "type": "Point",
              "parameters": [],
              "name": "GetSize",
              "doc": ""
            },
            "GetFormat": {
              "kind": "function",
              "immutable": true,
              "type": "PixelFormat",
              "parameters": [],
              "name": "GetFormat",
              "doc": ""
            },
            "Destroy": {
              "doc": "Destroy the specified texture.\n\nPassing nullptr or an otherwise invalid texture will set the SDL error message\nto \"Invalid texture\".\n\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa TextureBase.TextureBase\n@sa TextureBase.TextureBase",
              "name": "Destroy",
              "kind": "function",
              "type": "void",
              "parameters": [],
              "sourceName": "SDL_DestroyTexture"
            }
          }
        },
        "ObjectRef<SDL_Texture>::doFree": {
          "name": "ObjectRef<SDL_Texture>::doFree",
          "type": "void",
          "kind": "function",
          "doc": "Callback for texture resource cleanup\n\n@private",
          "template": [],
          "parameters": [
            {
              "type": "SDL_Texture *",
              "name": "resource"
            }
          ],
          "sourceName": "SDL_DestroyTexture"
        },
        "TextureLock": {
          "name": "TextureLock",
          "kind": "struct",
          "entries": {
            "texture": {
              "kind": "var",
              "type": "TextureRef",
              "name": "texture",
              "doc": ""
            },
            "surface": {
              "kind": "var",
              "type": "SurfaceRef",
              "name": "surface",
              "doc": ""
            },
            "TextureLock": [
              {
                "doc": "@sa TextureBase.Lock()",
                "kind": "function",
                "type": "",
                "explicit": true,
                "parameters": [
                  {
                    "name": "texture",
                    "type": "TextureRef"
                  },
                  {
                    "name": "rect",
                    "type": "OptionalRef<const SDL_Rect>"
                  }
                ],
                "name": "TextureLock"
              },
              {
                "kind": "function",
                "type": "",
                "parameters": [],
                "name": "TextureLock",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "type": "const TextureLock &",
                    "name": "other"
                  }
                ],
                "name": "TextureLock",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "type": "TextureLock &&",
                    "name": "other"
                  }
                ],
                "name": "TextureLock",
                "doc": ""
              }
            ],
            "~TextureLock": {
              "kind": "function",
              "doc": "@sa Unlock()",
              "type": "",
              "parameters": [],
              "name": "~TextureLock"
            },
            "operator=": {
              "kind": "function",
              "type": "TextureLock &",
              "parameters": [
                {
                  "type": "TextureLock",
                  "name": "other"
                }
              ],
              "name": "operator=",
              "doc": ""
            },
            "operator bool": {
              "kind": "function",
              "type": "",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "name": "operator bool",
              "doc": ""
            },
            "Unlock": {
              "doc": "Unlock a texture, uploading the changes to video memory, if needed.\n\n**Warning**: Please note that TextureBase.Lock() is intended to be\nwrite-only; it will not guarantee the previous contents of the texture will\nbe provided. You must fully initialize any area of a texture that you lock\nbefore unlocking it, as the pixels might otherwise be uninitialized memory.\n\nWhich is to say: locking and immediately unlocking a texture can result in\ncorrupted textures, depending on the renderer in use.\n\n@param texture a texture locked by TextureBase.Lock().\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa TextureBase.Lock",
              "name": "Unlock",
              "kind": "function",
              "type": "void",
              "parameters": [],
              "sourceName": "SDL_UnlockTexture"
            },
            "GetPixels": {
              "kind": "function",
              "type": "void *",
              "immutable": true,
              "parameters": [],
              "name": "GetPixels",
              "doc": ""
            },
            "GetPitch": {
              "kind": "function",
              "type": "int",
              "immutable": true,
              "parameters": [],
              "name": "GetPitch",
              "doc": ""
            },
            "GetFormat": {
              "kind": "function",
              "type": "PixelFormat",
              "immutable": true,
              "parameters": [],
              "name": "GetFormat",
              "doc": ""
            }
          },
          "doc": ""
        },
        "GetNumRenderDrivers": {
          "doc": "Get the number of 2D rendering drivers available for the current display.\n\nA render driver is a set of code that handles rendering and texture\nmanagement on a particular display. Normally there is only one, but some\ndrivers may have several available with different capabilities.\n\nThere may be none if SDL was compiled without render support.\n\n@returns the number of built in render drivers.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.RendererBase\n@sa GetRenderDriver",
          "name": "GetNumRenderDrivers",
          "kind": "function",
          "type": "int",
          "parameters": [],
          "sourceName": "SDL_GetNumRenderDrivers"
        },
        "GetRenderDriver": {
          "doc": "Use this function to get the name of a built in 2D rendering driver.\n\nThe list of rendering drivers is given in the order that they are normally\ninitialized by default; the drivers that seem more reasonable to choose\nfirst (as far as the SDL developers believe) are earlier in the list.\n\nThe names of drivers are all simple, low-ASCII identifiers, like \"opengl\",\n\"direct3d12\" or \"metal\". These never have Unicode characters, and are not\nmeant to be proper names.\n\n@param index the index of the rendering driver; the value ranges from 0 to\n             GetNumRenderDrivers() - 1.\n@returns the name of the rendering driver at the requested index, or nullptr\n         if an invalid index was specified.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetNumRenderDrivers",
          "name": "GetRenderDriver",
          "kind": "function",
          "type": "const char *",
          "parameters": [
            {
              "name": "index",
              "type": "int"
            }
          ],
          "sourceName": "SDL_GetRenderDriver"
        },
        "CreateWindowAndRenderer": {
          "doc": "Create a window and default renderer.\n\n@param title the title of the window, in UTF-8 encoding.\n@param width the width of the window.\n@param height the height of the window.\n@param window_flags the flags used to create the window (see\n                    WindowBase.WindowBase()).\n@param window a pointer filled with the window, or nullptr on error.\n@param renderer a pointer filled with the renderer, or nullptr on error.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RendererBase.RendererBase\n@sa WindowBase.WindowBase",
          "name": "CreateWindowAndRenderer",
          "kind": "function",
          "type": "std::pair<Window, Renderer>",
          "parameters": [
            {
              "name": "title",
              "type": "StringParam"
            },
            {
              "name": "size",
              "type": "SDL_Point"
            },
            {
              "name": "window_flags",
              "type": "WindowFlags",
              "default": "0"
            }
          ],
          "sourceName": "SDL_CreateWindowAndRenderer"
        },
        "prop::Renderer": {
          "kind": "ns",
          "name": "prop::Renderer",
          "entries": {
            "CREATE_NAME_STRING": {
              "doc": "",
              "name": "CREATE_NAME_STRING",
              "kind": "var",
              "value": "\"SDL.renderer.create.name\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_CREATE_NAME_STRING"
            },
            "CREATE_WINDOW_POINTER": {
              "doc": "",
              "name": "CREATE_WINDOW_POINTER",
              "kind": "var",
              "value": "\"SDL.renderer.create.window\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_CREATE_WINDOW_POINTER"
            },
            "CREATE_SURFACE_POINTER": {
              "doc": "",
              "name": "CREATE_SURFACE_POINTER",
              "kind": "var",
              "value": "\"SDL.renderer.create.surface\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_CREATE_SURFACE_POINTER"
            },
            "CREATE_OUTPUT_COLORSPACE_NUMBER": {
              "doc": "",
              "name": "CREATE_OUTPUT_COLORSPACE_NUMBER",
              "kind": "var",
              "value": "\"SDL.renderer.create.output_colorspace\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_CREATE_OUTPUT_COLORSPACE_NUMBER"
            },
            "CREATE_PRESENT_VSYNC_NUMBER": {
              "doc": "",
              "name": "CREATE_PRESENT_VSYNC_NUMBER",
              "kind": "var",
              "value": "\"SDL.renderer.create.present_vsync\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_CREATE_PRESENT_VSYNC_NUMBER"
            },
            "CREATE_VULKAN_INSTANCE_POINTER": {
              "doc": "",
              "name": "CREATE_VULKAN_INSTANCE_POINTER",
              "kind": "var",
              "value": "\"SDL.renderer.create.vulkan.instance\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_CREATE_VULKAN_INSTANCE_POINTER"
            },
            "CREATE_VULKAN_SURFACE_NUMBER": {
              "doc": "",
              "name": "CREATE_VULKAN_SURFACE_NUMBER",
              "kind": "var",
              "value": "\"SDL.renderer.create.vulkan.surface\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_CREATE_VULKAN_SURFACE_NUMBER"
            },
            "CREATE_VULKAN_PHYSICAL_DEVICE_POINTER": {
              "doc": "",
              "name": "CREATE_VULKAN_PHYSICAL_DEVICE_POINTER",
              "kind": "var",
              "value": "\"SDL.renderer.create.vulkan.physical_device\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_CREATE_VULKAN_PHYSICAL_DEVICE_POINTER"
            },
            "CREATE_VULKAN_DEVICE_POINTER": {
              "doc": "",
              "name": "CREATE_VULKAN_DEVICE_POINTER",
              "kind": "var",
              "value": "\"SDL.renderer.create.vulkan.device\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_CREATE_VULKAN_DEVICE_POINTER"
            },
            "CREATE_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER": {
              "doc": "",
              "name": "CREATE_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER",
              "kind": "var",
              "value": "\"SDL.renderer.create.vulkan.graphics_queue_family_index\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_CREATE_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER"
            },
            "CREATE_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER": {
              "doc": "",
              "name": "CREATE_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER",
              "kind": "var",
              "value": "\"SDL.renderer.create.vulkan.present_queue_family_index\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_CREATE_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER"
            },
            "NAME_STRING": {
              "doc": "",
              "name": "NAME_STRING",
              "kind": "var",
              "value": "\"SDL.renderer.name\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_NAME_STRING"
            },
            "WINDOW_POINTER": {
              "doc": "",
              "name": "WINDOW_POINTER",
              "kind": "var",
              "value": "\"SDL.renderer.window\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_WINDOW_POINTER"
            },
            "SURFACE_POINTER": {
              "doc": "",
              "name": "SURFACE_POINTER",
              "kind": "var",
              "value": "\"SDL.renderer.surface\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_SURFACE_POINTER"
            },
            "VSYNC_NUMBER": {
              "doc": "",
              "name": "VSYNC_NUMBER",
              "kind": "var",
              "value": "\"SDL.renderer.vsync\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_VSYNC_NUMBER"
            },
            "MAX_TEXTURE_SIZE_NUMBER": {
              "doc": "",
              "name": "MAX_TEXTURE_SIZE_NUMBER",
              "kind": "var",
              "value": "\"SDL.renderer.max_texture_size\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_MAX_TEXTURE_SIZE_NUMBER"
            },
            "TEXTURE_FORMATS_POINTER": {
              "doc": "",
              "name": "TEXTURE_FORMATS_POINTER",
              "kind": "var",
              "value": "\"SDL.renderer.texture_formats\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_TEXTURE_FORMATS_POINTER"
            },
            "OUTPUT_COLORSPACE_NUMBER": {
              "doc": "",
              "name": "OUTPUT_COLORSPACE_NUMBER",
              "kind": "var",
              "value": "\"SDL.renderer.output_colorspace\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_OUTPUT_COLORSPACE_NUMBER"
            },
            "HDR_ENABLED_BOOLEAN": {
              "doc": "",
              "name": "HDR_ENABLED_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.renderer.HDR_enabled\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_HDR_ENABLED_BOOLEAN"
            },
            "SDR_WHITE_POINT_FLOAT": {
              "doc": "",
              "name": "SDR_WHITE_POINT_FLOAT",
              "kind": "var",
              "value": "\"SDL.renderer.SDR_white_point\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_SDR_WHITE_POINT_FLOAT"
            },
            "HDR_HEADROOM_FLOAT": {
              "doc": "",
              "name": "HDR_HEADROOM_FLOAT",
              "kind": "var",
              "value": "\"SDL.renderer.HDR_headroom\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_HDR_HEADROOM_FLOAT"
            },
            "D3D9_DEVICE_POINTER": {
              "doc": "",
              "name": "D3D9_DEVICE_POINTER",
              "kind": "var",
              "value": "\"SDL.renderer.d3d9.device\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_D3D9_DEVICE_POINTER"
            },
            "D3D11_DEVICE_POINTER": {
              "doc": "",
              "name": "D3D11_DEVICE_POINTER",
              "kind": "var",
              "value": "\"SDL.renderer.d3d11.device\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_D3D11_DEVICE_POINTER"
            },
            "D3D11_SWAPCHAIN_POINTER": {
              "doc": "",
              "name": "D3D11_SWAPCHAIN_POINTER",
              "kind": "var",
              "value": "\"SDL.renderer.d3d11.swap_chain\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_D3D11_SWAPCHAIN_POINTER"
            },
            "D3D12_DEVICE_POINTER": {
              "doc": "",
              "name": "D3D12_DEVICE_POINTER",
              "kind": "var",
              "value": "\"SDL.renderer.d3d12.device\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_D3D12_DEVICE_POINTER"
            },
            "D3D12_SWAPCHAIN_POINTER": {
              "doc": "",
              "name": "D3D12_SWAPCHAIN_POINTER",
              "kind": "var",
              "value": "\"SDL.renderer.d3d12.swap_chain\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_D3D12_SWAPCHAIN_POINTER"
            },
            "D3D12_COMMAND_QUEUE_POINTER": {
              "doc": "",
              "name": "D3D12_COMMAND_QUEUE_POINTER",
              "kind": "var",
              "value": "\"SDL.renderer.d3d12.command_queue\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_D3D12_COMMAND_QUEUE_POINTER"
            },
            "VULKAN_INSTANCE_POINTER": {
              "doc": "",
              "name": "VULKAN_INSTANCE_POINTER",
              "kind": "var",
              "value": "\"SDL.renderer.vulkan.instance\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_VULKAN_INSTANCE_POINTER"
            },
            "VULKAN_SURFACE_NUMBER": {
              "doc": "",
              "name": "VULKAN_SURFACE_NUMBER",
              "kind": "var",
              "value": "\"SDL.renderer.vulkan.surface\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_VULKAN_SURFACE_NUMBER"
            },
            "VULKAN_PHYSICAL_DEVICE_POINTER": {
              "doc": "",
              "name": "VULKAN_PHYSICAL_DEVICE_POINTER",
              "kind": "var",
              "value": "\"SDL.renderer.vulkan.physical_device\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_VULKAN_PHYSICAL_DEVICE_POINTER"
            },
            "VULKAN_DEVICE_POINTER": {
              "doc": "",
              "name": "VULKAN_DEVICE_POINTER",
              "kind": "var",
              "value": "\"SDL.renderer.vulkan.device\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_VULKAN_DEVICE_POINTER"
            },
            "VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER": {
              "doc": "",
              "name": "VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER",
              "kind": "var",
              "value": "\"SDL.renderer.vulkan.graphics_queue_family_index\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER"
            },
            "VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER": {
              "doc": "",
              "name": "VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER",
              "kind": "var",
              "value": "\"SDL.renderer.vulkan.present_queue_family_index\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER"
            },
            "VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER": {
              "doc": "",
              "name": "VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER",
              "kind": "var",
              "value": "\"SDL.renderer.vulkan.swapchain_image_count\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER"
            },
            "GPU_DEVICE_POINTER": {
              "doc": "",
              "name": "GPU_DEVICE_POINTER",
              "kind": "var",
              "value": "\"SDL.renderer.gpu.device\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_RENDERER_GPU_DEVICE_POINTER"
            }
          },
          "doc": ""
        },
        "prop::Texture": {
          "kind": "ns",
          "name": "prop::Texture",
          "entries": {
            "CREATE_COLORSPACE_NUMBER": {
              "doc": "",
              "name": "CREATE_COLORSPACE_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.create.colorspace\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_COLORSPACE_NUMBER"
            },
            "CREATE_FORMAT_NUMBER": {
              "doc": "",
              "name": "CREATE_FORMAT_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.create.format\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_FORMAT_NUMBER"
            },
            "CREATE_ACCESS_NUMBER": {
              "doc": "",
              "name": "CREATE_ACCESS_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.create.access\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_ACCESS_NUMBER"
            },
            "CREATE_WIDTH_NUMBER": {
              "doc": "",
              "name": "CREATE_WIDTH_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.create.width\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_WIDTH_NUMBER"
            },
            "CREATE_HEIGHT_NUMBER": {
              "doc": "",
              "name": "CREATE_HEIGHT_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.create.height\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_HEIGHT_NUMBER"
            },
            "CREATE_SDR_WHITE_POINT_FLOAT": {
              "doc": "",
              "name": "CREATE_SDR_WHITE_POINT_FLOAT",
              "kind": "var",
              "value": "\"SDL.texture.create.SDR_white_point\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT"
            },
            "CREATE_HDR_HEADROOM_FLOAT": {
              "doc": "",
              "name": "CREATE_HDR_HEADROOM_FLOAT",
              "kind": "var",
              "value": "\"SDL.texture.create.HDR_headroom\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_HDR_HEADROOM_FLOAT"
            },
            "CREATE_D3D11_TEXTURE_POINTER": {
              "doc": "",
              "name": "CREATE_D3D11_TEXTURE_POINTER",
              "kind": "var",
              "value": "\"SDL.texture.create.d3d11.texture\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_POINTER"
            },
            "CREATE_D3D11_TEXTURE_U_POINTER": {
              "doc": "",
              "name": "CREATE_D3D11_TEXTURE_U_POINTER",
              "kind": "var",
              "value": "\"SDL.texture.create.d3d11.texture_u\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_U_POINTER"
            },
            "CREATE_D3D11_TEXTURE_V_POINTER": {
              "doc": "",
              "name": "CREATE_D3D11_TEXTURE_V_POINTER",
              "kind": "var",
              "value": "\"SDL.texture.create.d3d11.texture_v\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_V_POINTER"
            },
            "CREATE_D3D12_TEXTURE_POINTER": {
              "doc": "",
              "name": "CREATE_D3D12_TEXTURE_POINTER",
              "kind": "var",
              "value": "\"SDL.texture.create.d3d12.texture\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_POINTER"
            },
            "CREATE_D3D12_TEXTURE_U_POINTER": {
              "doc": "",
              "name": "CREATE_D3D12_TEXTURE_U_POINTER",
              "kind": "var",
              "value": "\"SDL.texture.create.d3d12.texture_u\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_U_POINTER"
            },
            "CREATE_D3D12_TEXTURE_V_POINTER": {
              "doc": "",
              "name": "CREATE_D3D12_TEXTURE_V_POINTER",
              "kind": "var",
              "value": "\"SDL.texture.create.d3d12.texture_v\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_V_POINTER"
            },
            "CREATE_METAL_PIXELBUFFER_POINTER": {
              "doc": "",
              "name": "CREATE_METAL_PIXELBUFFER_POINTER",
              "kind": "var",
              "value": "\"SDL.texture.create.metal.pixelbuffer\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_METAL_PIXELBUFFER_POINTER"
            },
            "CREATE_OPENGL_TEXTURE_NUMBER": {
              "doc": "",
              "name": "CREATE_OPENGL_TEXTURE_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.create.opengl.texture\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_NUMBER"
            },
            "CREATE_OPENGL_TEXTURE_UV_NUMBER": {
              "doc": "",
              "name": "CREATE_OPENGL_TEXTURE_UV_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.create.opengl.texture_uv\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_UV_NUMBER"
            },
            "CREATE_OPENGL_TEXTURE_U_NUMBER": {
              "doc": "",
              "name": "CREATE_OPENGL_TEXTURE_U_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.create.opengl.texture_u\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_U_NUMBER"
            },
            "CREATE_OPENGL_TEXTURE_V_NUMBER": {
              "doc": "",
              "name": "CREATE_OPENGL_TEXTURE_V_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.create.opengl.texture_v\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_V_NUMBER"
            },
            "CREATE_OPENGLES2_TEXTURE_NUMBER": {
              "doc": "",
              "name": "CREATE_OPENGLES2_TEXTURE_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.create.opengles2.texture\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER"
            },
            "CREATE_OPENGLES2_TEXTURE_UV_NUMBER": {
              "doc": "",
              "name": "CREATE_OPENGLES2_TEXTURE_UV_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.create.opengles2.texture_uv\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_UV_NUMBER"
            },
            "CREATE_OPENGLES2_TEXTURE_U_NUMBER": {
              "doc": "",
              "name": "CREATE_OPENGLES2_TEXTURE_U_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.create.opengles2.texture_u\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_U_NUMBER"
            },
            "CREATE_OPENGLES2_TEXTURE_V_NUMBER": {
              "doc": "",
              "name": "CREATE_OPENGLES2_TEXTURE_V_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.create.opengles2.texture_v\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_V_NUMBER"
            },
            "CREATE_VULKAN_TEXTURE_NUMBER": {
              "doc": "",
              "name": "CREATE_VULKAN_TEXTURE_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.create.vulkan.texture\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_CREATE_VULKAN_TEXTURE_NUMBER"
            },
            "COLORSPACE_NUMBER": {
              "doc": "",
              "name": "COLORSPACE_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.colorspace\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_COLORSPACE_NUMBER"
            },
            "FORMAT_NUMBER": {
              "doc": "",
              "name": "FORMAT_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.format\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_FORMAT_NUMBER"
            },
            "ACCESS_NUMBER": {
              "doc": "",
              "name": "ACCESS_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.access\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_ACCESS_NUMBER"
            },
            "WIDTH_NUMBER": {
              "doc": "",
              "name": "WIDTH_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.width\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_WIDTH_NUMBER"
            },
            "HEIGHT_NUMBER": {
              "doc": "",
              "name": "HEIGHT_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.height\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_HEIGHT_NUMBER"
            },
            "SDR_WHITE_POINT_FLOAT": {
              "doc": "",
              "name": "SDR_WHITE_POINT_FLOAT",
              "kind": "var",
              "value": "\"SDL.texture.SDR_white_point\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_SDR_WHITE_POINT_FLOAT"
            },
            "HDR_HEADROOM_FLOAT": {
              "doc": "",
              "name": "HDR_HEADROOM_FLOAT",
              "kind": "var",
              "value": "\"SDL.texture.HDR_headroom\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_HDR_HEADROOM_FLOAT"
            },
            "D3D11_TEXTURE_POINTER": {
              "doc": "",
              "name": "D3D11_TEXTURE_POINTER",
              "kind": "var",
              "value": "\"SDL.texture.d3d11.texture\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_D3D11_TEXTURE_POINTER"
            },
            "D3D11_TEXTURE_U_POINTER": {
              "doc": "",
              "name": "D3D11_TEXTURE_U_POINTER",
              "kind": "var",
              "value": "\"SDL.texture.d3d11.texture_u\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_D3D11_TEXTURE_U_POINTER"
            },
            "D3D11_TEXTURE_V_POINTER": {
              "doc": "",
              "name": "D3D11_TEXTURE_V_POINTER",
              "kind": "var",
              "value": "\"SDL.texture.d3d11.texture_v\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_D3D11_TEXTURE_V_POINTER"
            },
            "D3D12_TEXTURE_POINTER": {
              "doc": "",
              "name": "D3D12_TEXTURE_POINTER",
              "kind": "var",
              "value": "\"SDL.texture.d3d12.texture\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_D3D12_TEXTURE_POINTER"
            },
            "D3D12_TEXTURE_U_POINTER": {
              "doc": "",
              "name": "D3D12_TEXTURE_U_POINTER",
              "kind": "var",
              "value": "\"SDL.texture.d3d12.texture_u\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_D3D12_TEXTURE_U_POINTER"
            },
            "D3D12_TEXTURE_V_POINTER": {
              "doc": "",
              "name": "D3D12_TEXTURE_V_POINTER",
              "kind": "var",
              "value": "\"SDL.texture.d3d12.texture_v\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_D3D12_TEXTURE_V_POINTER"
            },
            "OPENGL_TEXTURE_NUMBER": {
              "doc": "",
              "name": "OPENGL_TEXTURE_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.opengl.texture\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_OPENGL_TEXTURE_NUMBER"
            },
            "OPENGL_TEXTURE_UV_NUMBER": {
              "doc": "",
              "name": "OPENGL_TEXTURE_UV_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.opengl.texture_uv\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_OPENGL_TEXTURE_UV_NUMBER"
            },
            "OPENGL_TEXTURE_U_NUMBER": {
              "doc": "",
              "name": "OPENGL_TEXTURE_U_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.opengl.texture_u\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_OPENGL_TEXTURE_U_NUMBER"
            },
            "OPENGL_TEXTURE_V_NUMBER": {
              "doc": "",
              "name": "OPENGL_TEXTURE_V_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.opengl.texture_v\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_OPENGL_TEXTURE_V_NUMBER"
            },
            "OPENGL_TEXTURE_TARGET_NUMBER": {
              "doc": "",
              "name": "OPENGL_TEXTURE_TARGET_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.opengl.target\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_OPENGL_TEXTURE_TARGET_NUMBER"
            },
            "OPENGL_TEX_W_FLOAT": {
              "doc": "",
              "name": "OPENGL_TEX_W_FLOAT",
              "kind": "var",
              "value": "\"SDL.texture.opengl.tex_w\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_OPENGL_TEX_W_FLOAT"
            },
            "OPENGL_TEX_H_FLOAT": {
              "doc": "",
              "name": "OPENGL_TEX_H_FLOAT",
              "kind": "var",
              "value": "\"SDL.texture.opengl.tex_h\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_OPENGL_TEX_H_FLOAT"
            },
            "OPENGLES2_TEXTURE_NUMBER": {
              "doc": "",
              "name": "OPENGLES2_TEXTURE_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.opengles2.texture\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_NUMBER"
            },
            "OPENGLES2_TEXTURE_UV_NUMBER": {
              "doc": "",
              "name": "OPENGLES2_TEXTURE_UV_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.opengles2.texture_uv\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_UV_NUMBER"
            },
            "OPENGLES2_TEXTURE_U_NUMBER": {
              "doc": "",
              "name": "OPENGLES2_TEXTURE_U_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.opengles2.texture_u\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_U_NUMBER"
            },
            "OPENGLES2_TEXTURE_V_NUMBER": {
              "doc": "",
              "name": "OPENGLES2_TEXTURE_V_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.opengles2.texture_v\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_V_NUMBER"
            },
            "OPENGLES2_TEXTURE_TARGET_NUMBER": {
              "doc": "",
              "name": "OPENGLES2_TEXTURE_TARGET_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.opengles2.target\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_TARGET_NUMBER"
            },
            "VULKAN_TEXTURE_NUMBER": {
              "doc": "",
              "name": "VULKAN_TEXTURE_NUMBER",
              "kind": "var",
              "value": "\"SDL.texture.vulkan.texture\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTURE_VULKAN_TEXTURE_NUMBER"
            }
          },
          "doc": ""
        },
        "GetRenderMetalLayer": {
          "doc": "Get the CAMetalLayer associated with the given Metal renderer.\n\nThis function returns `void *`, so SDL doesn't have to include Metal's\nheaders, but it can be safely cast to a `CAMetalLayer *`.\n\n@param renderer the renderer to query.\n@returns a `CAMetalLayer *` on success, or nullptr if the renderer isn't a\n         Metal renderer.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetRenderMetalCommandEncoder",
          "name": "GetRenderMetalLayer",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "renderer",
              "type": "RendererRef"
            }
          ],
          "sourceName": "SDL_GetRenderMetalLayer"
        },
        "GetRenderMetalCommandEncoder": {
          "doc": "Get the Metal command encoder for the current frame.\n\nThis function returns `void *`, so SDL doesn't have to include Metal's\nheaders, but it can be safely cast to an `id<MTLRenderCommandEncoder>`.\n\nThis will return nullptr if Metal refuses to give SDL a drawable to render to,\nwhich might happen if the window is hidden/minimized/offscreen. This\ndoesn't apply to command encoders for render targets, just the window's\nbackbuffer. Check your return values!\n\n@param renderer the renderer to query.\n@returns an `id<MTLRenderCommandEncoder>` on success, or nullptr if the\n         renderer isn't a Metal renderer or there was an error.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetRenderMetalLayer",
          "name": "GetRenderMetalCommandEncoder",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "renderer",
              "type": "RendererRef"
            }
          ],
          "sourceName": "SDL_GetRenderMetalCommandEncoder"
        },
        "AddVulkanRenderSemaphores": {
          "doc": "Add a set of synchronization semaphores for the current frame.\n\nThe Vulkan renderer will wait for `wait_semaphore` before submitting\nrendering commands and signal `signal_semaphore` after rendering commands\nare complete for this frame.\n\nThis should be called each frame that you want semaphore synchronization.\nThe Vulkan renderer may have multiple frames in flight on the GPU, so you\nshould have multiple semaphores that are used for synchronization. Querying\nprop::Renderer.VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER will give you the\nmaximum number of semaphores you'll need.\n\n@param renderer the rendering context.\n@param wait_stage_mask the VkPipelineStageFlags for the wait.\n@param wait_semaphore a VkSempahore to wait on before rendering the current\n                      frame, or 0 if not needed.\n@param signal_semaphore a VkSempahore that SDL will signal when rendering\n                        for the current frame is complete, or 0 if not\n                        needed.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is **NOT** safe to call this function from two threads at\n              once.\n\n@since This function is available since SDL 3.2.0.",
          "name": "AddVulkanRenderSemaphores",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "renderer",
              "type": "RendererRef"
            },
            {
              "name": "wait_stage_mask",
              "type": "Uint32"
            },
            {
              "name": "wait_semaphore",
              "type": "Sint64"
            },
            {
              "name": "signal_semaphore",
              "type": "Sint64"
            }
          ],
          "sourceName": "SDL_AddVulkanRenderSemaphores"
        },
        "SDL_RENDERER_VSYNC_DISABLED": {
          "doc": "",
          "name": "SDL_RENDERER_VSYNC_DISABLED",
          "kind": "def",
          "value": "0",
          "sourceName": "SDL_RENDERER_VSYNC_DISABLED"
        },
        "SDL_RENDERER_VSYNC_ADAPTIVE": {
          "doc": "",
          "name": "SDL_RENDERER_VSYNC_ADAPTIVE",
          "kind": "def",
          "value": "(-1)",
          "sourceName": "SDL_RENDERER_VSYNC_ADAPTIVE"
        },
        "SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE": {
          "doc": "The size, in pixels, of a single RendererBase.RenderDebugText() character.\n\nThe font is monospaced and square, so this applies to all characters.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa RendererBase.RenderDebugText",
          "name": "SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE",
          "kind": "def",
          "value": "8",
          "sourceName": "SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE"
        }
      }
    },
    "SDL3pp_timer.h": {
      "name": "SDL3pp_timer.h",
      "doc": "@defgroup CategoryTimer Category Timer\n\nSDL provides time management functionality. It is useful for dealing with\n(usually) small durations of time.\n\nThis is not to be confused with _calendar time_ management, which is\nprovided by [CategoryTime](CategoryTime).\n\nThis category covers measuring time elapsed (SDL_GetTicks(),\nGetPerformanceCounter()), putting a thread to sleep for a certain\namount of time (Delay(), SDL_DelayNS(), DelayPrecise()), and firing\na callback function after a certain amount of time has elasped\n(AddTimer(), etc).\n\nThere are also useful macros to convert between time units, like\nTime::FromPosix() and such.",
      "entries": {
        "Time::FromPosix": {
          "doc": "Convert seconds to nanoseconds.\n\nThis only converts whole numbers, not fractional seconds.\n\n@param S the number of seconds to convert.\n@returns S, expressed in nanoseconds.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "Time::FromPosix",
          "kind": "function",
          "parameters": [
            {
              "type": "Sint64",
              "name": "time"
            }
          ],
          "value": "(((Uint64)(S)) * SDL_NS_PER_SECOND)",
          "sourceName": "SDL_SECONDS_TO_NS",
          "type": "Time",
          "constexpr": true
        },
        "Time::ToPosix": {
          "doc": "Convert nanoseconds to seconds.\n\nThis performs a division, so the results can be dramatically different if\n`NS` is an integer or floating point value.\n\n@param NS the number of nanoseconds to convert.\n@returns NS, expressed in seconds.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "Time::ToPosix",
          "kind": "function",
          "parameters": [],
          "value": "((NS) / SDL_NS_PER_SECOND)",
          "sourceName": "SDL_NS_TO_SECONDS",
          "type": "Sint64",
          "constexpr": true,
          "immutable": true
        },
        "GetTicks": {
          "doc": "Get the number of nanoseconds since SDL library initialization.\n\n@returns an unsigned 64-bit value representing the number of nanoseconds\n         since the SDL library initialized.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetTicks",
          "kind": "function",
          "type": "std::chrono::nanoseconds",
          "parameters": [],
          "sourceName": "SDL_GetTicksNS"
        },
        "GetPerformanceCounter": {
          "doc": "Get the current value of the high resolution counter.\n\nThis function is typically used for profiling.\n\nThe counter values are only meaningful relative to each other. Differences\nbetween values can be converted to times by using\nGetPerformanceFrequency().\n\n@returns the current counter value.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetPerformanceFrequency",
          "name": "GetPerformanceCounter",
          "kind": "function",
          "type": "Uint64",
          "parameters": [],
          "sourceName": "SDL_GetPerformanceCounter"
        },
        "GetPerformanceFrequency": {
          "doc": "Get the count per second of the high resolution counter.\n\n@returns a platform-specific count per second.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetPerformanceCounter",
          "name": "GetPerformanceFrequency",
          "kind": "function",
          "type": "Uint64",
          "parameters": [],
          "sourceName": "SDL_GetPerformanceFrequency"
        },
        "Delay": {
          "doc": "Wait a specified number of milliseconds before returning.\n\nThis function waits a specified number of milliseconds before returning. It\nwaits at least the specified time, but possibly longer due to OS\nscheduling.\n\n@param ms the number of milliseconds to delay.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SDL_DelayNS\n@sa DelayPrecise",
          "name": "Delay",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "duration",
              "type": "std::chrono::nanoseconds"
            }
          ],
          "sourceName": "SDL_Delay"
        },
        "DelayPrecise": {
          "doc": "Wait a specified number of nanoseconds before returning.\n\nThis function waits a specified number of nanoseconds before returning. It\nwill attempt to wait as close to the requested time as possible, busy\nwaiting if necessary, but could return later due to OS scheduling.\n\n@param ns the number of nanoseconds to delay.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Delay\n@sa SDL_DelayNS",
          "name": "DelayPrecise",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "duration",
              "type": "std::chrono::nanoseconds"
            }
          ],
          "sourceName": "SDL_DelayPrecise"
        },
        "TimerID": {
          "doc": "Definition of the timer ID type.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "TimerID",
          "kind": "alias",
          "type": "SDL_TimerID",
          "sourceName": "SDL_TimerID"
        },
        "TimerCallback": {
          "doc": "Function prototype for the millisecond timer callback function.\n\nThe callback function is passed the current timer interval and returns the\nnext timer interval, in milliseconds. If the returned value is the same as\nthe one passed in, the periodic alarm continues, otherwise a new alarm is\nscheduled. If the callback returns 0, the periodic alarm is canceled and\nwill be removed.\n\n@param userdata an arbitrary pointer provided by the app through\n                AddTimer, for its own use.\n@param timerID the current timer being processed.\n@param interval the current callback time interval.\n@returns the new callback time interval, or 0 to disable further runs of\n         the callback.\n\n@threadsafety SDL may call this callback at any time from a background\n              thread; the application is responsible for locking resources\n              the callback touches that need to be protected.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa AddTimer",
          "name": "TimerCallback",
          "kind": "alias",
          "type": "SDL_TimerCallback",
          "sourceName": "SDL_TimerCallback"
        },
        "NSTimerCallback": {
          "doc": "Function prototype for the nanosecond timer callback function.\n\nThe callback function is passed the current timer interval and returns the\nnext timer interval, in nanoseconds. If the returned value is the same as\nthe one passed in, the periodic alarm continues, otherwise a new alarm is\nscheduled. If the callback returns 0, the periodic alarm is canceled and\nwill be removed.\n\n@param userdata an arbitrary pointer provided by the app through\n                AddTimer, for its own use.\n@param timerID the current timer being processed.\n@param interval the current callback time interval.\n@returns the new callback time interval, or 0 to disable further runs of\n         the callback.\n\n@threadsafety SDL may call this callback at any time from a background\n              thread; the application is responsible for locking resources\n              the callback touches that need to be protected.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa AddTimer",
          "name": "NSTimerCallback",
          "kind": "alias",
          "type": "SDL_NSTimerCallback",
          "sourceName": "SDL_NSTimerCallback"
        },
        "TimerCB": {
          "kind": "alias",
          "name": "TimerCB",
          "doc": ""
        },
        "AddTimer": [
          {
            "doc": "Call a callback function at a future time.\n\nThe callback function is passed the current timer interval and the user\nsupplied parameter from the AddTimer() call and should return the next\ntimer interval. If the value returned from the callback is 0, the timer is\ncanceled and will be removed.\n\nThe callback is run on a separate thread, and for short timeouts can\npotentially be called before this function returns.\n\nTimers take into account the amount of time it took to execute the\ncallback. For example, if the callback took 250 ms to execute and returned\n1000 (ms), the timer would only wait another 750 ms before its next\niteration.\n\nTiming may be inexact due to OS scheduling. Be sure to note the current\ntime with GetTicks() or GetPerformanceCounter() in case your\ncallback needs to adjust for variances.\n\n@param interval the timer delay, in milliseconds, passed to `callback`.\n@param callback the TimerCallback function to call when the specified\n                `interval` elapses.\n@param userdata a pointer that is passed to `callback`.\n@returns a timer ID or 0 on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa AddTimer\n@sa RemoveTimer",
            "name": "AddTimer",
            "kind": "function",
            "type": "TimerID",
            "parameters": [
              {
                "name": "interval",
                "type": "std::chrono::milliseconds"
              },
              {
                "name": "callback",
                "type": "TimerCallback"
              },
              {
                "name": "userdata",
                "type": "void *"
              }
            ],
            "sourceName": "SDL_AddTimer"
          },
          {
            "doc": "Call a callback function at a future time.\n\nThe callback function is passed the current timer interval and the user\nsupplied parameter from the AddTimer() call and should return the\nnext timer interval. If the value returned from the callback is 0, the\ntimer is canceled and will be removed.\n\nThe callback is run on a separate thread, and for short timeouts can\npotentially be called before this function returns.\n\nTimers take into account the amount of time it took to execute the\ncallback. For example, if the callback took 250 ns to execute and returned\n1000 (ns), the timer would only wait another 750 ns before its next\niteration.\n\nTiming may be inexact due to OS scheduling. Be sure to note the current\ntime with GetTicks() or GetPerformanceCounter() in case your\ncallback needs to adjust for variances.\n\n@param interval the timer delay, in nanoseconds, passed to `callback`.\n@param callback the TimerCallback function to call when the specified\n                `interval` elapses.\n@param userdata a pointer that is passed to `callback`.\n@returns a timer ID or 0 on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa AddTimer\n@sa RemoveTimer",
            "name": "AddTimer",
            "kind": "function",
            "type": "TimerID",
            "parameters": [
              {
                "name": "interval",
                "type": "std::chrono::nanoseconds"
              },
              {
                "name": "callback",
                "type": "NSTimerCallback"
              },
              {
                "name": "userdata",
                "type": "void *"
              }
            ],
            "sourceName": "SDL_AddTimerNS"
          },
          {
            "kind": "function",
            "name": "AddTimer",
            "type": "TimerID",
            "parameters": [
              {
                "type": "std::chrono::nanoseconds",
                "name": "interval"
              },
              {
                "type": "TimerCB",
                "name": "callback"
              }
            ],
            "doc": ""
          }
        ],
        "RemoveTimer": {
          "doc": "Remove a timer created with AddTimer().\n\n@param id the ID of the timer to remove.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa AddTimer",
          "name": "RemoveTimer",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "id",
              "type": "TimerID"
            }
          ],
          "sourceName": "SDL_RemoveTimer"
        }
      }
    },
    "SDL3pp_time.h": {
      "name": "SDL3pp_time.h",
      "doc": "@defgroup CategoryTime Category Time\n\nSDL realtime clock and date/time routines.\n\nThere are two data types that are used in this category: Time, which\nrepresents the nanoseconds since a specific moment (an \"epoch\"), and\nDateTime, which breaks time down into human-understandable components:\nyears, months, days, hours, etc.\n\nMuch of the functionality is involved in converting those two types to\nother useful forms.",
      "entries": {
        "DateTime": {
          "doc": "A structure holding a calendar date and time broken down into its\ncomponents.\n\n@since This struct is available since SDL 3.2.0.",
          "name": "DateTime",
          "kind": "struct",
          "sourceName": "SDL_DateTime",
          "type": "SDL_DateTime",
          "entries": {
            "DateTime": [
              {
                "kind": "function",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "const SDL_DateTime &",
                    "name": "dt"
                  }
                ],
                "name": "DateTime",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "int",
                    "name": "year"
                  },
                  {
                    "type": "int",
                    "name": "month"
                  },
                  {
                    "type": "int",
                    "name": "day"
                  },
                  {
                    "type": "int",
                    "name": "hour"
                  },
                  {
                    "type": "int",
                    "name": "minute"
                  },
                  {
                    "type": "int",
                    "name": "second"
                  },
                  {
                    "type": "int",
                    "name": "nanosecond"
                  },
                  {
                    "type": "int",
                    "name": "day_of_week"
                  },
                  {
                    "type": "int",
                    "name": "utc_offset"
                  }
                ],
                "name": "DateTime",
                "doc": ""
              },
              {
                "doc": "Converts an Time in nanoseconds since the epoch to a calendar time in\nthe DateTime format.\n\n@param ticks the Time to be converted.\n@param dt the resulting DateTime.\n@param localTime the resulting DateTime will be expressed in local time\n                 if true, otherwise it will be in Universal Coordinated\n                 Time (UTC).\n@post true on success or false on failure; call GetError() for more\n         information.\n\n@since This function is available since SDL 3.2.0.",
                "name": "DateTime",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "ticks",
                    "type": "Time"
                  },
                  {
                    "name": "localTime",
                    "type": "bool",
                    "default": "true"
                  }
                ],
                "sourceName": "SDL_TimeToDateTime"
              }
            ],
            "operator bool": {
              "kind": "function",
              "type": "",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "name": "operator bool",
              "doc": ""
            },
            "operator Time": {
              "doc": "Converts a calendar time to an Time in nanoseconds since the epoch.\n\nThis function ignores the day_of_week member of the DateTime struct, so\nit may remain unset.\n\n@param dt the source DateTime.\n@param ticks the resulting Time.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@since This function is available since SDL 3.2.0.",
              "name": "operator Time",
              "kind": "function",
              "type": "",
              "parameters": [],
              "sourceName": "SDL_DateTimeToTime",
              "immutable": true
            }
          }
        },
        "DateFormat": {
          "doc": "The preferred date format of the current system locale.\n\n@since This enum is available since SDL 3.2.0.\n\n@sa GetDateTimeLocalePreferences",
          "name": "DateFormat",
          "kind": "alias",
          "sourceName": "SDL_DateFormat",
          "type": "SDL_DateFormat"
        },
        "DATE_FORMAT_YYYYMMDD": {
          "doc": "Year/Month/Day.",
          "name": "DATE_FORMAT_YYYYMMDD",
          "kind": "var",
          "type": "DateFormat",
          "sourceName": "SDL_DATE_FORMAT_YYYYMMDD",
          "constexpr": true
        },
        "DATE_FORMAT_DDMMYYYY": {
          "doc": "Day/Month/Year.",
          "name": "DATE_FORMAT_DDMMYYYY",
          "kind": "var",
          "type": "DateFormat",
          "sourceName": "SDL_DATE_FORMAT_DDMMYYYY",
          "constexpr": true
        },
        "DATE_FORMAT_MMDDYYYY": {
          "doc": "Month/Day/Year.",
          "name": "DATE_FORMAT_MMDDYYYY",
          "kind": "var",
          "type": "DateFormat",
          "sourceName": "SDL_DATE_FORMAT_MMDDYYYY",
          "constexpr": true
        },
        "TimeFormat": {
          "doc": "The preferred time format of the current system locale.\n\n@since This enum is available since SDL 3.2.0.\n\n@sa GetDateTimeLocalePreferences",
          "name": "TimeFormat",
          "kind": "alias",
          "sourceName": "SDL_TimeFormat",
          "type": "SDL_TimeFormat"
        },
        "TIME_FORMAT_24HR": {
          "doc": "24 hour time",
          "name": "TIME_FORMAT_24HR",
          "kind": "var",
          "type": "TimeFormat",
          "sourceName": "SDL_TIME_FORMAT_24HR",
          "constexpr": true
        },
        "TIME_FORMAT_12HR": {
          "doc": "12 hour time",
          "name": "TIME_FORMAT_12HR",
          "kind": "var",
          "type": "TimeFormat",
          "sourceName": "SDL_TIME_FORMAT_12HR",
          "constexpr": true
        },
        "GetDateTimeLocalePreferences": {
          "doc": "Gets the current preferred date and time format for the system locale.\n\nThis might be a \"slow\" call that has to query the operating system. It's\nbest to ask for this once and save the results. However, the preferred\nformats can change, usually because the user has changed a system\npreference outside of your program.\n\n@param dateFormat a pointer to the DateFormat to hold the returned date\n                  format, may be nullptr.\n@param timeFormat a pointer to the TimeFormat to hold the returned time\n                  format, may be nullptr.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetDateTimeLocalePreferences",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "dateFormat",
              "type": "DateFormat *"
            },
            {
              "name": "timeFormat",
              "type": "TimeFormat *"
            }
          ],
          "sourceName": "SDL_GetDateTimeLocalePreferences"
        },
        "Time::Current": {
          "doc": "Gets the current value of the system realtime clock in nanoseconds since\nJan 1, 1970 in Universal Coordinated Time (UTC).\n\n@param ticks the Time to hold the returned tick count.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@since This function is available since SDL 3.2.0.",
          "name": "Time::Current",
          "kind": "function",
          "type": "Time",
          "parameters": [],
          "sourceName": "SDL_GetCurrentTime"
        },
        "Time::ToWindows": {
          "doc": "Converts an SDL time into a Windows FILETIME (100-nanosecond intervals\nsince January 1, 1601).\n\nThis function fills in the two 32-bit values of the FILETIME structure.\n\n@param ticks the time to convert.\n@param dwLowDateTime a pointer filled in with the low portion of the\n                     Windows FILETIME value.\n@param dwHighDateTime a pointer filled in with the high portion of the\n                      Windows FILETIME value.\n\n@since This function is available since SDL 3.2.0.",
          "name": "Time::ToWindows",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "dwLowDateTime",
              "type": "Uint32 *"
            },
            {
              "name": "dwHighDateTime",
              "type": "Uint32 *"
            }
          ],
          "sourceName": "SDL_TimeToWindows",
          "immutable": true
        },
        "Time::FromWindows": {
          "doc": "Converts a Windows FILETIME (100-nanosecond intervals since January 1,\n1601) to an SDL time.\n\nThis function takes the two 32-bit values of the FILETIME structure as\nparameters.\n\n@param dwLowDateTime the low portion of the Windows FILETIME value.\n@param dwHighDateTime the high portion of the Windows FILETIME value.\n@returns the converted SDL time.\n\n@since This function is available since SDL 3.2.0.",
          "name": "Time::FromWindows",
          "kind": "function",
          "type": "Time",
          "parameters": [
            {
              "name": "dwLowDateTime",
              "type": "Uint32"
            },
            {
              "name": "dwHighDateTime",
              "type": "Uint32"
            }
          ],
          "sourceName": "SDL_TimeFromWindows"
        },
        "GetDaysInMonth": {
          "doc": "Get the number of days in a month for a given year.\n\n@param year the year.\n@param month the month [1-12].\n@returns the number of days in the requested month or -1 on failure; call\n         GetError() for more information.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetDaysInMonth",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "year",
              "type": "int"
            },
            {
              "name": "month",
              "type": "int"
            }
          ],
          "sourceName": "SDL_GetDaysInMonth"
        },
        "GetDayOfYear": {
          "doc": "Get the day of year for a calendar date.\n\n@param year the year component of the date.\n@param month the month component of the date.\n@param day the day component of the date.\n@returns the day of year [0-365] if the date is valid or -1 on failure;\n         call GetError() for more information.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetDayOfYear",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "year",
              "type": "int"
            },
            {
              "name": "month",
              "type": "int"
            },
            {
              "name": "day",
              "type": "int"
            }
          ],
          "sourceName": "SDL_GetDayOfYear"
        },
        "GetDayOfWeek": {
          "doc": "Get the day of week for a calendar date.\n\n@param year the year component of the date.\n@param month the month component of the date.\n@param day the day component of the date.\n@returns a value between 0 and 6 (0 being Sunday) if the date is valid or\n         -1 on failure; call GetError() for more information.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetDayOfWeek",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "year",
              "type": "int"
            },
            {
              "name": "month",
              "type": "int"
            },
            {
              "name": "day",
              "type": "int"
            }
          ],
          "sourceName": "SDL_GetDayOfWeek"
        }
      }
    },
    "SDL3pp_events.h": {
      "name": "SDL3pp_events.h",
      "doc": "@defgroup CategoryEvents Category Events\n\nEvent queue management.\n\nIt's extremely common--often required--that an app deal with SDL's event\nqueue. Almost all useful information about interactions with the real world\nflow through here: the user interacting with the computer and app, hardware\ncoming and going, the system changing in some way, etc.\n\nAn app generally takes a moment, perhaps at the start of a new frame, to\nexamine any events that have occured since the last time and process or\nignore them. This is generally done by calling PollEvent() in a loop\nuntil it returns false (or, if using the main callbacks, events are\nprovided one at a time in calls to SDL_AppEvent() before the next call to\nSDL_AppIterate(); in this scenario, the app does not call PollEvent()\nat all).\n\nThere is other forms of control, too: PeepEvents() has more\nfunctionality at the cost of more complexity, and WaitEvent() can block\nthe process until something interesting happens, which might be beneficial\nfor certain types of programs on low-power hardware. One may also call\nAddEventWatch() to set a callback when new events arrive.\n\nThe app is free to generate their own events, too: PushEvent allows the\napp to put events onto the queue for later retrieval; RegisterEvents\ncan guarantee that these events have a type that isn't in use by other\nparts of the system.",
      "entries": {
        "EventType": {
          "doc": "The types of events that can be delivered.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "EventType",
          "kind": "alias",
          "sourceName": "SDL_EventType",
          "type": "SDL_EventType"
        },
        "EVENT_FIRST": {
          "doc": "Unused (do not remove)",
          "name": "EVENT_FIRST",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_FIRST",
          "constexpr": true
        },
        "EVENT_QUIT": {
          "doc": "User-requested quit.",
          "name": "EVENT_QUIT",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_QUIT",
          "constexpr": true
        },
        "EVENT_TERMINATING": {
          "doc": "The application is being terminated by the OS.  This event must be handled in a callback set with AddEventWatch(). Called on iOS in applicationWillTerminate() Called on Android in onDestroy()",
          "name": "EVENT_TERMINATING",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_TERMINATING",
          "constexpr": true
        },
        "EVENT_LOW_MEMORY": {
          "doc": "The application is low on memory, free memory if possible.  This event must be handled in a callback set with AddEventWatch(). Called on iOS in applicationDidReceiveMemoryWarning() Called on Android in onTrimMemory()",
          "name": "EVENT_LOW_MEMORY",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_LOW_MEMORY",
          "constexpr": true
        },
        "EVENT_WILL_ENTER_BACKGROUND": {
          "doc": "The application is about to enter the background.  This event must be handled in a callback set with AddEventWatch(). Called on iOS in applicationWillResignActive() Called on Android in onPause()",
          "name": "EVENT_WILL_ENTER_BACKGROUND",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WILL_ENTER_BACKGROUND",
          "constexpr": true
        },
        "EVENT_DID_ENTER_BACKGROUND": {
          "doc": "The application did enter the background and may not get CPU for some time.  This event must be handled in a callback set with AddEventWatch(). Called on iOS in applicationDidEnterBackground() Called on Android in onPause()",
          "name": "EVENT_DID_ENTER_BACKGROUND",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_DID_ENTER_BACKGROUND",
          "constexpr": true
        },
        "EVENT_WILL_ENTER_FOREGROUND": {
          "doc": "The application is about to enter the foreground.  This event must be handled in a callback set with AddEventWatch(). Called on iOS in applicationWillEnterForeground() Called on Android in onResume()",
          "name": "EVENT_WILL_ENTER_FOREGROUND",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WILL_ENTER_FOREGROUND",
          "constexpr": true
        },
        "EVENT_DID_ENTER_FOREGROUND": {
          "doc": "The application is now interactive.  This event must be handled in a callback set with AddEventWatch(). Called on iOS in applicationDidBecomeActive() Called on Android in onResume()",
          "name": "EVENT_DID_ENTER_FOREGROUND",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_DID_ENTER_FOREGROUND",
          "constexpr": true
        },
        "EVENT_LOCALE_CHANGED": {
          "doc": "The user's locale preferences have changed.",
          "name": "EVENT_LOCALE_CHANGED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_LOCALE_CHANGED",
          "constexpr": true
        },
        "EVENT_SYSTEM_THEME_CHANGED": {
          "doc": "The system theme changed.",
          "name": "EVENT_SYSTEM_THEME_CHANGED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_SYSTEM_THEME_CHANGED",
          "constexpr": true
        },
        "EVENT_DISPLAY_ORIENTATION": {
          "doc": "Display orientation has changed to data1.",
          "name": "EVENT_DISPLAY_ORIENTATION",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_DISPLAY_ORIENTATION",
          "constexpr": true
        },
        "EVENT_DISPLAY_ADDED": {
          "doc": "Display has been added to the system.",
          "name": "EVENT_DISPLAY_ADDED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_DISPLAY_ADDED",
          "constexpr": true
        },
        "EVENT_DISPLAY_REMOVED": {
          "doc": "Display has been removed from the system.",
          "name": "EVENT_DISPLAY_REMOVED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_DISPLAY_REMOVED",
          "constexpr": true
        },
        "EVENT_DISPLAY_MOVED": {
          "doc": "Display has changed position.",
          "name": "EVENT_DISPLAY_MOVED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_DISPLAY_MOVED",
          "constexpr": true
        },
        "EVENT_DISPLAY_DESKTOP_MODE_CHANGED": {
          "doc": "Display has changed desktop mode.",
          "name": "EVENT_DISPLAY_DESKTOP_MODE_CHANGED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_DISPLAY_DESKTOP_MODE_CHANGED",
          "constexpr": true
        },
        "EVENT_DISPLAY_CURRENT_MODE_CHANGED": {
          "doc": "Display has changed current mode.",
          "name": "EVENT_DISPLAY_CURRENT_MODE_CHANGED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_DISPLAY_CURRENT_MODE_CHANGED",
          "constexpr": true
        },
        "EVENT_DISPLAY_CONTENT_SCALE_CHANGED": {
          "doc": "Display has changed content scale.",
          "name": "EVENT_DISPLAY_CONTENT_SCALE_CHANGED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_DISPLAY_CONTENT_SCALE_CHANGED",
          "constexpr": true
        },
        "EVENT_DISPLAY_FIRST": {
          "doc": "",
          "name": "EVENT_DISPLAY_FIRST",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_DISPLAY_FIRST",
          "constexpr": true
        },
        "EVENT_DISPLAY_LAST": {
          "doc": "",
          "name": "EVENT_DISPLAY_LAST",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_DISPLAY_LAST",
          "constexpr": true
        },
        "EVENT_WINDOW_SHOWN": {
          "doc": "Window has been shown.",
          "name": "EVENT_WINDOW_SHOWN",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_SHOWN",
          "constexpr": true
        },
        "EVENT_WINDOW_HIDDEN": {
          "doc": "Window has been hidden.",
          "name": "EVENT_WINDOW_HIDDEN",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_HIDDEN",
          "constexpr": true
        },
        "EVENT_WINDOW_EXPOSED": {
          "doc": "Window has been exposed and should be redrawn, and can be redrawn directly from event watchers for this event.",
          "name": "EVENT_WINDOW_EXPOSED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_EXPOSED",
          "constexpr": true
        },
        "EVENT_WINDOW_MOVED": {
          "doc": "Window has been moved to data1, data2.",
          "name": "EVENT_WINDOW_MOVED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_MOVED",
          "constexpr": true
        },
        "EVENT_WINDOW_RESIZED": {
          "doc": "Window has been resized to data1xdata2.",
          "name": "EVENT_WINDOW_RESIZED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_RESIZED",
          "constexpr": true
        },
        "EVENT_WINDOW_PIXEL_SIZE_CHANGED": {
          "doc": "The pixel size of the window has changed to data1xdata2.",
          "name": "EVENT_WINDOW_PIXEL_SIZE_CHANGED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED",
          "constexpr": true
        },
        "EVENT_WINDOW_METAL_VIEW_RESIZED": {
          "doc": "The pixel size of a Metal view associated with the window has changed.",
          "name": "EVENT_WINDOW_METAL_VIEW_RESIZED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_METAL_VIEW_RESIZED",
          "constexpr": true
        },
        "EVENT_WINDOW_MINIMIZED": {
          "doc": "Window has been minimized.",
          "name": "EVENT_WINDOW_MINIMIZED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_MINIMIZED",
          "constexpr": true
        },
        "EVENT_WINDOW_MAXIMIZED": {
          "doc": "Window has been maximized.",
          "name": "EVENT_WINDOW_MAXIMIZED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_MAXIMIZED",
          "constexpr": true
        },
        "EVENT_WINDOW_RESTORED": {
          "doc": "Window has been restored to normal size and position.",
          "name": "EVENT_WINDOW_RESTORED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_RESTORED",
          "constexpr": true
        },
        "EVENT_WINDOW_MOUSE_ENTER": {
          "doc": "Window has gained mouse focus.",
          "name": "EVENT_WINDOW_MOUSE_ENTER",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_MOUSE_ENTER",
          "constexpr": true
        },
        "EVENT_WINDOW_MOUSE_LEAVE": {
          "doc": "Window has lost mouse focus.",
          "name": "EVENT_WINDOW_MOUSE_LEAVE",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_MOUSE_LEAVE",
          "constexpr": true
        },
        "EVENT_WINDOW_FOCUS_GAINED": {
          "doc": "Window has gained keyboard focus.",
          "name": "EVENT_WINDOW_FOCUS_GAINED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_FOCUS_GAINED",
          "constexpr": true
        },
        "EVENT_WINDOW_FOCUS_LOST": {
          "doc": "Window has lost keyboard focus.",
          "name": "EVENT_WINDOW_FOCUS_LOST",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_FOCUS_LOST",
          "constexpr": true
        },
        "EVENT_WINDOW_CLOSE_REQUESTED": {
          "doc": "The window manager requests that the window be closed.",
          "name": "EVENT_WINDOW_CLOSE_REQUESTED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_CLOSE_REQUESTED",
          "constexpr": true
        },
        "EVENT_WINDOW_HIT_TEST": {
          "doc": "Window had a hit test that wasn't HITTEST_NORMAL.",
          "name": "EVENT_WINDOW_HIT_TEST",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_HIT_TEST",
          "constexpr": true
        },
        "EVENT_WINDOW_ICCPROF_CHANGED": {
          "doc": "The ICC profile of the window's display has changed.",
          "name": "EVENT_WINDOW_ICCPROF_CHANGED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_ICCPROF_CHANGED",
          "constexpr": true
        },
        "EVENT_WINDOW_DISPLAY_CHANGED": {
          "doc": "Window has been moved to display data1.",
          "name": "EVENT_WINDOW_DISPLAY_CHANGED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_DISPLAY_CHANGED",
          "constexpr": true
        },
        "EVENT_WINDOW_DISPLAY_SCALE_CHANGED": {
          "doc": "Window display scale has been changed.",
          "name": "EVENT_WINDOW_DISPLAY_SCALE_CHANGED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_DISPLAY_SCALE_CHANGED",
          "constexpr": true
        },
        "EVENT_WINDOW_SAFE_AREA_CHANGED": {
          "doc": "The window safe area has been changed.",
          "name": "EVENT_WINDOW_SAFE_AREA_CHANGED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_SAFE_AREA_CHANGED",
          "constexpr": true
        },
        "EVENT_WINDOW_OCCLUDED": {
          "doc": "The window has been occluded.",
          "name": "EVENT_WINDOW_OCCLUDED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_OCCLUDED",
          "constexpr": true
        },
        "EVENT_WINDOW_ENTER_FULLSCREEN": {
          "doc": "The window has entered fullscreen mode.",
          "name": "EVENT_WINDOW_ENTER_FULLSCREEN",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_ENTER_FULLSCREEN",
          "constexpr": true
        },
        "EVENT_WINDOW_LEAVE_FULLSCREEN": {
          "doc": "The window has left fullscreen mode.",
          "name": "EVENT_WINDOW_LEAVE_FULLSCREEN",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_LEAVE_FULLSCREEN",
          "constexpr": true
        },
        "EVENT_WINDOW_DESTROYED": {
          "doc": "The window with the associated ID is being or has been destroyed.  If this message is being handled in an event watcher, the window handle is still valid and can still be used to retrieve any properties associated with the window. Otherwise, the handle has already been destroyed and all resources associated with it are invalid",
          "name": "EVENT_WINDOW_DESTROYED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_DESTROYED",
          "constexpr": true
        },
        "EVENT_WINDOW_HDR_STATE_CHANGED": {
          "doc": "Window HDR properties have changed.",
          "name": "EVENT_WINDOW_HDR_STATE_CHANGED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_HDR_STATE_CHANGED",
          "constexpr": true
        },
        "EVENT_WINDOW_FIRST": {
          "doc": "",
          "name": "EVENT_WINDOW_FIRST",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_FIRST",
          "constexpr": true
        },
        "EVENT_WINDOW_LAST": {
          "doc": "",
          "name": "EVENT_WINDOW_LAST",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_WINDOW_LAST",
          "constexpr": true
        },
        "EVENT_KEY_DOWN": {
          "doc": "Key pressed.",
          "name": "EVENT_KEY_DOWN",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_KEY_DOWN",
          "constexpr": true
        },
        "EVENT_KEY_UP": {
          "doc": "Key released.",
          "name": "EVENT_KEY_UP",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_KEY_UP",
          "constexpr": true
        },
        "EVENT_TEXT_EDITING": {
          "doc": "Keyboard text editing (composition)",
          "name": "EVENT_TEXT_EDITING",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_TEXT_EDITING",
          "constexpr": true
        },
        "EVENT_TEXT_INPUT": {
          "doc": "Keyboard text input.",
          "name": "EVENT_TEXT_INPUT",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_TEXT_INPUT",
          "constexpr": true
        },
        "EVENT_KEYMAP_CHANGED": {
          "doc": "Keymap changed due to a system event such as an input language or keyboard layout change.",
          "name": "EVENT_KEYMAP_CHANGED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_KEYMAP_CHANGED",
          "constexpr": true
        },
        "EVENT_KEYBOARD_ADDED": {
          "doc": "A new keyboard has been inserted into the system.",
          "name": "EVENT_KEYBOARD_ADDED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_KEYBOARD_ADDED",
          "constexpr": true
        },
        "EVENT_KEYBOARD_REMOVED": {
          "doc": "A keyboard has been removed.",
          "name": "EVENT_KEYBOARD_REMOVED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_KEYBOARD_REMOVED",
          "constexpr": true
        },
        "EVENT_TEXT_EDITING_CANDIDATES": {
          "doc": "Keyboard text editing candidates.",
          "name": "EVENT_TEXT_EDITING_CANDIDATES",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_TEXT_EDITING_CANDIDATES",
          "constexpr": true
        },
        "EVENT_MOUSE_MOTION": {
          "doc": "Mouse moved.",
          "name": "EVENT_MOUSE_MOTION",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_MOUSE_MOTION",
          "constexpr": true
        },
        "EVENT_MOUSE_BUTTON_DOWN": {
          "doc": "Mouse button pressed.",
          "name": "EVENT_MOUSE_BUTTON_DOWN",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_MOUSE_BUTTON_DOWN",
          "constexpr": true
        },
        "EVENT_MOUSE_BUTTON_UP": {
          "doc": "Mouse button released.",
          "name": "EVENT_MOUSE_BUTTON_UP",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_MOUSE_BUTTON_UP",
          "constexpr": true
        },
        "EVENT_MOUSE_WHEEL": {
          "doc": "Mouse wheel motion.",
          "name": "EVENT_MOUSE_WHEEL",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_MOUSE_WHEEL",
          "constexpr": true
        },
        "EVENT_MOUSE_ADDED": {
          "doc": "A new mouse has been inserted into the system.",
          "name": "EVENT_MOUSE_ADDED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_MOUSE_ADDED",
          "constexpr": true
        },
        "EVENT_MOUSE_REMOVED": {
          "doc": "A mouse has been removed.",
          "name": "EVENT_MOUSE_REMOVED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_MOUSE_REMOVED",
          "constexpr": true
        },
        "EVENT_JOYSTICK_AXIS_MOTION": {
          "doc": "Joystick axis motion.",
          "name": "EVENT_JOYSTICK_AXIS_MOTION",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_JOYSTICK_AXIS_MOTION",
          "constexpr": true
        },
        "EVENT_JOYSTICK_BALL_MOTION": {
          "doc": "Joystick trackball motion.",
          "name": "EVENT_JOYSTICK_BALL_MOTION",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_JOYSTICK_BALL_MOTION",
          "constexpr": true
        },
        "EVENT_JOYSTICK_HAT_MOTION": {
          "doc": "Joystick hat position change.",
          "name": "EVENT_JOYSTICK_HAT_MOTION",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_JOYSTICK_HAT_MOTION",
          "constexpr": true
        },
        "EVENT_JOYSTICK_BUTTON_DOWN": {
          "doc": "Joystick button pressed.",
          "name": "EVENT_JOYSTICK_BUTTON_DOWN",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_JOYSTICK_BUTTON_DOWN",
          "constexpr": true
        },
        "EVENT_JOYSTICK_BUTTON_UP": {
          "doc": "Joystick button released.",
          "name": "EVENT_JOYSTICK_BUTTON_UP",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_JOYSTICK_BUTTON_UP",
          "constexpr": true
        },
        "EVENT_JOYSTICK_ADDED": {
          "doc": "A new joystick has been inserted into the system.",
          "name": "EVENT_JOYSTICK_ADDED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_JOYSTICK_ADDED",
          "constexpr": true
        },
        "EVENT_JOYSTICK_REMOVED": {
          "doc": "An opened joystick has been removed.",
          "name": "EVENT_JOYSTICK_REMOVED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_JOYSTICK_REMOVED",
          "constexpr": true
        },
        "EVENT_JOYSTICK_BATTERY_UPDATED": {
          "doc": "Joystick battery level change.",
          "name": "EVENT_JOYSTICK_BATTERY_UPDATED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_JOYSTICK_BATTERY_UPDATED",
          "constexpr": true
        },
        "EVENT_JOYSTICK_UPDATE_COMPLETE": {
          "doc": "Joystick update is complete.",
          "name": "EVENT_JOYSTICK_UPDATE_COMPLETE",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_JOYSTICK_UPDATE_COMPLETE",
          "constexpr": true
        },
        "EVENT_GAMEPAD_AXIS_MOTION": {
          "doc": "Gamepad axis motion.",
          "name": "EVENT_GAMEPAD_AXIS_MOTION",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_GAMEPAD_AXIS_MOTION",
          "constexpr": true
        },
        "EVENT_GAMEPAD_BUTTON_DOWN": {
          "doc": "Gamepad button pressed.",
          "name": "EVENT_GAMEPAD_BUTTON_DOWN",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_GAMEPAD_BUTTON_DOWN",
          "constexpr": true
        },
        "EVENT_GAMEPAD_BUTTON_UP": {
          "doc": "Gamepad button released.",
          "name": "EVENT_GAMEPAD_BUTTON_UP",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_GAMEPAD_BUTTON_UP",
          "constexpr": true
        },
        "EVENT_GAMEPAD_ADDED": {
          "doc": "A new gamepad has been inserted into the system.",
          "name": "EVENT_GAMEPAD_ADDED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_GAMEPAD_ADDED",
          "constexpr": true
        },
        "EVENT_GAMEPAD_REMOVED": {
          "doc": "A gamepad has been removed.",
          "name": "EVENT_GAMEPAD_REMOVED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_GAMEPAD_REMOVED",
          "constexpr": true
        },
        "EVENT_GAMEPAD_REMAPPED": {
          "doc": "The gamepad mapping was updated.",
          "name": "EVENT_GAMEPAD_REMAPPED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_GAMEPAD_REMAPPED",
          "constexpr": true
        },
        "EVENT_GAMEPAD_TOUCHPAD_DOWN": {
          "doc": "Gamepad touchpad was touched.",
          "name": "EVENT_GAMEPAD_TOUCHPAD_DOWN",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_GAMEPAD_TOUCHPAD_DOWN",
          "constexpr": true
        },
        "EVENT_GAMEPAD_TOUCHPAD_MOTION": {
          "doc": "Gamepad touchpad finger was moved.",
          "name": "EVENT_GAMEPAD_TOUCHPAD_MOTION",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_GAMEPAD_TOUCHPAD_MOTION",
          "constexpr": true
        },
        "EVENT_GAMEPAD_TOUCHPAD_UP": {
          "doc": "Gamepad touchpad finger was lifted.",
          "name": "EVENT_GAMEPAD_TOUCHPAD_UP",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_GAMEPAD_TOUCHPAD_UP",
          "constexpr": true
        },
        "EVENT_GAMEPAD_SENSOR_UPDATE": {
          "doc": "Gamepad sensor was updated.",
          "name": "EVENT_GAMEPAD_SENSOR_UPDATE",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_GAMEPAD_SENSOR_UPDATE",
          "constexpr": true
        },
        "EVENT_GAMEPAD_UPDATE_COMPLETE": {
          "doc": "Gamepad update is complete.",
          "name": "EVENT_GAMEPAD_UPDATE_COMPLETE",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_GAMEPAD_UPDATE_COMPLETE",
          "constexpr": true
        },
        "EVENT_GAMEPAD_STEAM_HANDLE_UPDATED": {
          "doc": "Gamepad Steam handle has changed.",
          "name": "EVENT_GAMEPAD_STEAM_HANDLE_UPDATED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_GAMEPAD_STEAM_HANDLE_UPDATED",
          "constexpr": true
        },
        "EVENT_FINGER_DOWN": {
          "doc": "",
          "name": "EVENT_FINGER_DOWN",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_FINGER_DOWN",
          "constexpr": true
        },
        "EVENT_FINGER_UP": {
          "doc": "",
          "name": "EVENT_FINGER_UP",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_FINGER_UP",
          "constexpr": true
        },
        "EVENT_FINGER_MOTION": {
          "doc": "",
          "name": "EVENT_FINGER_MOTION",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_FINGER_MOTION",
          "constexpr": true
        },
        "EVENT_FINGER_CANCELED": {
          "doc": "",
          "name": "EVENT_FINGER_CANCELED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_FINGER_CANCELED",
          "constexpr": true
        },
        "EVENT_CLIPBOARD_UPDATE": {
          "doc": "The clipboard or primary selection changed.",
          "name": "EVENT_CLIPBOARD_UPDATE",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_CLIPBOARD_UPDATE",
          "constexpr": true
        },
        "EVENT_DROP_FILE": {
          "doc": "The system requests a file open.",
          "name": "EVENT_DROP_FILE",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_DROP_FILE",
          "constexpr": true
        },
        "EVENT_DROP_TEXT": {
          "doc": "text/plain drag-and-drop event",
          "name": "EVENT_DROP_TEXT",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_DROP_TEXT",
          "constexpr": true
        },
        "EVENT_DROP_BEGIN": {
          "doc": "A new set of drops is beginning (NULL filename)",
          "name": "EVENT_DROP_BEGIN",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_DROP_BEGIN",
          "constexpr": true
        },
        "EVENT_DROP_COMPLETE": {
          "doc": "Current set of drops is now complete (NULL filename)",
          "name": "EVENT_DROP_COMPLETE",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_DROP_COMPLETE",
          "constexpr": true
        },
        "EVENT_DROP_POSITION": {
          "doc": "Position while moving over the window.",
          "name": "EVENT_DROP_POSITION",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_DROP_POSITION",
          "constexpr": true
        },
        "EVENT_AUDIO_DEVICE_ADDED": {
          "doc": "A new audio device is available.",
          "name": "EVENT_AUDIO_DEVICE_ADDED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_AUDIO_DEVICE_ADDED",
          "constexpr": true
        },
        "EVENT_AUDIO_DEVICE_REMOVED": {
          "doc": "An audio device has been removed.",
          "name": "EVENT_AUDIO_DEVICE_REMOVED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_AUDIO_DEVICE_REMOVED",
          "constexpr": true
        },
        "EVENT_AUDIO_DEVICE_FORMAT_CHANGED": {
          "doc": "An audio device's format has been changed by the system.",
          "name": "EVENT_AUDIO_DEVICE_FORMAT_CHANGED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_AUDIO_DEVICE_FORMAT_CHANGED",
          "constexpr": true
        },
        "EVENT_SENSOR_UPDATE": {
          "doc": "A sensor was updated.",
          "name": "EVENT_SENSOR_UPDATE",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_SENSOR_UPDATE",
          "constexpr": true
        },
        "EVENT_PEN_PROXIMITY_IN": {
          "doc": "Pressure-sensitive pen has become available.",
          "name": "EVENT_PEN_PROXIMITY_IN",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_PEN_PROXIMITY_IN",
          "constexpr": true
        },
        "EVENT_PEN_PROXIMITY_OUT": {
          "doc": "Pressure-sensitive pen has become unavailable.",
          "name": "EVENT_PEN_PROXIMITY_OUT",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_PEN_PROXIMITY_OUT",
          "constexpr": true
        },
        "EVENT_PEN_DOWN": {
          "doc": "Pressure-sensitive pen touched drawing surface.",
          "name": "EVENT_PEN_DOWN",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_PEN_DOWN",
          "constexpr": true
        },
        "EVENT_PEN_UP": {
          "doc": "Pressure-sensitive pen stopped touching drawing surface.",
          "name": "EVENT_PEN_UP",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_PEN_UP",
          "constexpr": true
        },
        "EVENT_PEN_BUTTON_DOWN": {
          "doc": "Pressure-sensitive pen button pressed.",
          "name": "EVENT_PEN_BUTTON_DOWN",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_PEN_BUTTON_DOWN",
          "constexpr": true
        },
        "EVENT_PEN_BUTTON_UP": {
          "doc": "Pressure-sensitive pen button released.",
          "name": "EVENT_PEN_BUTTON_UP",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_PEN_BUTTON_UP",
          "constexpr": true
        },
        "EVENT_PEN_MOTION": {
          "doc": "Pressure-sensitive pen is moving on the tablet.",
          "name": "EVENT_PEN_MOTION",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_PEN_MOTION",
          "constexpr": true
        },
        "EVENT_PEN_AXIS": {
          "doc": "Pressure-sensitive pen angle/pressure/etc changed.",
          "name": "EVENT_PEN_AXIS",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_PEN_AXIS",
          "constexpr": true
        },
        "EVENT_CAMERA_DEVICE_ADDED": {
          "doc": "A new camera device is available.",
          "name": "EVENT_CAMERA_DEVICE_ADDED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_CAMERA_DEVICE_ADDED",
          "constexpr": true
        },
        "EVENT_CAMERA_DEVICE_REMOVED": {
          "doc": "A camera device has been removed.",
          "name": "EVENT_CAMERA_DEVICE_REMOVED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_CAMERA_DEVICE_REMOVED",
          "constexpr": true
        },
        "EVENT_CAMERA_DEVICE_APPROVED": {
          "doc": "A camera device has been approved for use by the user.",
          "name": "EVENT_CAMERA_DEVICE_APPROVED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_CAMERA_DEVICE_APPROVED",
          "constexpr": true
        },
        "EVENT_CAMERA_DEVICE_DENIED": {
          "doc": "A camera device has been denied for use by the user.",
          "name": "EVENT_CAMERA_DEVICE_DENIED",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_CAMERA_DEVICE_DENIED",
          "constexpr": true
        },
        "EVENT_RENDER_TARGETS_RESET": {
          "doc": "The render targets have been reset and their contents need to be updated.",
          "name": "EVENT_RENDER_TARGETS_RESET",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_RENDER_TARGETS_RESET",
          "constexpr": true
        },
        "EVENT_RENDER_DEVICE_RESET": {
          "doc": "The device has been reset and all textures need to be recreated.",
          "name": "EVENT_RENDER_DEVICE_RESET",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_RENDER_DEVICE_RESET",
          "constexpr": true
        },
        "EVENT_RENDER_DEVICE_LOST": {
          "doc": "The device has been lost and can't be recovered.",
          "name": "EVENT_RENDER_DEVICE_LOST",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_RENDER_DEVICE_LOST",
          "constexpr": true
        },
        "EVENT_PRIVATE0": {
          "doc": "",
          "name": "EVENT_PRIVATE0",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_PRIVATE0",
          "constexpr": true
        },
        "EVENT_PRIVATE1": {
          "doc": "",
          "name": "EVENT_PRIVATE1",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_PRIVATE1",
          "constexpr": true
        },
        "EVENT_PRIVATE2": {
          "doc": "",
          "name": "EVENT_PRIVATE2",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_PRIVATE2",
          "constexpr": true
        },
        "EVENT_PRIVATE3": {
          "doc": "",
          "name": "EVENT_PRIVATE3",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_PRIVATE3",
          "constexpr": true
        },
        "EVENT_POLL_SENTINEL": {
          "doc": "Signals the end of an event poll cycle.",
          "name": "EVENT_POLL_SENTINEL",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_POLL_SENTINEL",
          "constexpr": true
        },
        "EVENT_USER": {
          "doc": "Events EVENT_USER through EVENT_LAST are for your use, and should be allocated with RegisterEvents()",
          "name": "EVENT_USER",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_USER",
          "constexpr": true
        },
        "EVENT_LAST": {
          "doc": "This last event is only for bounding internal arrays.",
          "name": "EVENT_LAST",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_LAST",
          "constexpr": true
        },
        "EVENT_ENUM_PADDING": {
          "doc": "",
          "name": "EVENT_ENUM_PADDING",
          "kind": "var",
          "type": "EventType",
          "sourceName": "SDL_EVENT_ENUM_PADDING",
          "constexpr": true
        },
        "CommonEvent": {
          "doc": "Fields shared by every event\n\n@since This struct is available since SDL 3.2.0.",
          "name": "CommonEvent",
          "kind": "alias",
          "sourceName": "SDL_CommonEvent",
          "type": "SDL_CommonEvent"
        },
        "DisplayEvent": {
          "doc": "Display state change event data (event.display.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "DisplayEvent",
          "kind": "alias",
          "sourceName": "SDL_DisplayEvent",
          "type": "SDL_DisplayEvent"
        },
        "WindowEvent": {
          "doc": "Window state change event data (event.window.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "WindowEvent",
          "kind": "alias",
          "sourceName": "SDL_WindowEvent",
          "type": "SDL_WindowEvent"
        },
        "KeyboardDeviceEvent": {
          "doc": "Keyboard device event structure (event.kdevice.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "KeyboardDeviceEvent",
          "kind": "alias",
          "sourceName": "SDL_KeyboardDeviceEvent",
          "type": "SDL_KeyboardDeviceEvent"
        },
        "KeyboardEvent": {
          "doc": "Keyboard button event structure (event.key.*)\n\nThe `key` is the base Keycode generated by pressing the `scancode`\nusing the current keyboard layout, applying any options specified in\nSDL_HINT_KEYCODE_OPTIONS. You can get the Keycode corresponding to the\nevent scancode and modifiers directly from the keyboard layout, bypassing\nSDL_HINT_KEYCODE_OPTIONS, by calling Keycode::Keycode().\n\n@since This struct is available since SDL 3.2.0.\n\n@sa Keycode::Keycode\n@sa SDL_HINT_KEYCODE_OPTIONS",
          "name": "KeyboardEvent",
          "kind": "alias",
          "sourceName": "SDL_KeyboardEvent",
          "type": "SDL_KeyboardEvent"
        },
        "TextEditingEvent": {
          "doc": "Keyboard text editing event structure (event.edit.*)\n\nThe start cursor is the position, in UTF-8 characters, where new typing\nwill be inserted into the editing text. The length is the number of UTF-8\ncharacters that will be replaced by new typing.\n\n@since This struct is available since SDL 3.2.0.",
          "name": "TextEditingEvent",
          "kind": "alias",
          "sourceName": "SDL_TextEditingEvent",
          "type": "SDL_TextEditingEvent"
        },
        "TextEditingCandidatesEvent": {
          "doc": "Keyboard IME candidates event structure (event.edit_candidates.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "TextEditingCandidatesEvent",
          "kind": "alias",
          "sourceName": "SDL_TextEditingCandidatesEvent",
          "type": "SDL_TextEditingCandidatesEvent"
        },
        "TextInputEvent": {
          "doc": "Keyboard text input event structure (event.text.*)\n\nThis event will never be delivered unless text input is enabled by calling\nWindowBase<T>::StartTextInput(). Text input is disabled by default!\n\n@since This struct is available since SDL 3.2.0.\n\n@sa WindowBase<T>::StartTextInput\n@sa WindowBase<T>::StopTextInput",
          "name": "TextInputEvent",
          "kind": "alias",
          "sourceName": "SDL_TextInputEvent",
          "type": "SDL_TextInputEvent"
        },
        "MouseDeviceEvent": {
          "doc": "Mouse device event structure (event.mdevice.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "MouseDeviceEvent",
          "kind": "alias",
          "sourceName": "SDL_MouseDeviceEvent",
          "type": "SDL_MouseDeviceEvent"
        },
        "MouseMotionEvent": {
          "doc": "Mouse motion event structure (event.motion.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "MouseMotionEvent",
          "kind": "alias",
          "sourceName": "SDL_MouseMotionEvent",
          "type": "SDL_MouseMotionEvent"
        },
        "MouseButtonEvent": {
          "doc": "Mouse button event structure (event.button.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "MouseButtonEvent",
          "kind": "alias",
          "sourceName": "SDL_MouseButtonEvent",
          "type": "SDL_MouseButtonEvent"
        },
        "MouseWheelEvent": {
          "doc": "Mouse wheel event structure (event.wheel.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "MouseWheelEvent",
          "kind": "alias",
          "sourceName": "SDL_MouseWheelEvent",
          "type": "SDL_MouseWheelEvent"
        },
        "JoyAxisEvent": {
          "doc": "Joystick axis motion event structure (event.jaxis.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "JoyAxisEvent",
          "kind": "alias",
          "sourceName": "SDL_JoyAxisEvent",
          "type": "SDL_JoyAxisEvent"
        },
        "JoyBallEvent": {
          "doc": "Joystick trackball motion event structure (event.jball.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "JoyBallEvent",
          "kind": "alias",
          "sourceName": "SDL_JoyBallEvent",
          "type": "SDL_JoyBallEvent"
        },
        "JoyHatEvent": {
          "doc": "Joystick hat position change event structure (event.jhat.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "JoyHatEvent",
          "kind": "alias",
          "sourceName": "SDL_JoyHatEvent",
          "type": "SDL_JoyHatEvent"
        },
        "JoyButtonEvent": {
          "doc": "Joystick button event structure (event.jbutton.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "JoyButtonEvent",
          "kind": "alias",
          "sourceName": "SDL_JoyButtonEvent",
          "type": "SDL_JoyButtonEvent"
        },
        "JoyDeviceEvent": {
          "doc": "Joystick device event structure (event.jdevice.*)\n\nSDL will send JOYSTICK_ADDED events for devices that are already plugged in\nduring InitSubSystem.\n\n@since This struct is available since SDL 3.2.0.\n\n@sa GamepadDeviceEvent",
          "name": "JoyDeviceEvent",
          "kind": "alias",
          "sourceName": "SDL_JoyDeviceEvent",
          "type": "SDL_JoyDeviceEvent"
        },
        "JoyBatteryEvent": {
          "doc": "Joystick battery level change event structure (event.jbattery.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "JoyBatteryEvent",
          "kind": "alias",
          "sourceName": "SDL_JoyBatteryEvent",
          "type": "SDL_JoyBatteryEvent"
        },
        "GamepadAxisEvent": {
          "doc": "Gamepad axis motion event structure (event.gaxis.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "GamepadAxisEvent",
          "kind": "alias",
          "sourceName": "SDL_GamepadAxisEvent",
          "type": "SDL_GamepadAxisEvent"
        },
        "GamepadButtonEvent": {
          "doc": "Gamepad button event structure (event.gbutton.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "GamepadButtonEvent",
          "kind": "alias",
          "sourceName": "SDL_GamepadButtonEvent",
          "type": "SDL_GamepadButtonEvent"
        },
        "GamepadDeviceEvent": {
          "doc": "Gamepad device event structure (event.gdevice.*)\n\nJoysticks that are supported gamepads receive both an JoyDeviceEvent\nand an GamepadDeviceEvent.\n\nSDL will send GAMEPAD_ADDED events for joysticks that are already plugged\nin during InitSubSystem() and are recognized as gamepads. It will also send\nevents for joysticks that get gamepad mappings at runtime.\n\n@since This struct is available since SDL 3.2.0.\n\n@sa JoyDeviceEvent",
          "name": "GamepadDeviceEvent",
          "kind": "alias",
          "sourceName": "SDL_GamepadDeviceEvent",
          "type": "SDL_GamepadDeviceEvent"
        },
        "GamepadTouchpadEvent": {
          "doc": "Gamepad touchpad event structure (event.gtouchpad.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "GamepadTouchpadEvent",
          "kind": "alias",
          "sourceName": "SDL_GamepadTouchpadEvent",
          "type": "SDL_GamepadTouchpadEvent"
        },
        "GamepadSensorEvent": {
          "doc": "Gamepad sensor event structure (event.gsensor.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "GamepadSensorEvent",
          "kind": "alias",
          "sourceName": "SDL_GamepadSensorEvent",
          "type": "SDL_GamepadSensorEvent"
        },
        "AudioDeviceEvent": {
          "doc": "Audio device event structure (event.adevice.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "AudioDeviceEvent",
          "kind": "alias",
          "sourceName": "SDL_AudioDeviceEvent",
          "type": "SDL_AudioDeviceEvent"
        },
        "CameraDeviceEvent": {
          "doc": "Camera device event structure (event.cdevice.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "CameraDeviceEvent",
          "kind": "alias",
          "sourceName": "SDL_CameraDeviceEvent",
          "type": "SDL_CameraDeviceEvent"
        },
        "RenderEvent": {
          "doc": "Renderer event structure (event.render.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "RenderEvent",
          "kind": "alias",
          "sourceName": "SDL_RenderEvent",
          "type": "SDL_RenderEvent"
        },
        "TouchFingerEvent": {
          "doc": "Touch finger event structure (event.tfinger.*)\n\nCoordinates in this event are normalized. `x` and `y` are normalized to a\nrange between 0.0f and 1.0f, relative to the window, so (0,0) is the top\nleft and (1,1) is the bottom right. Delta coordinates `dx` and `dy` are\nnormalized in the ranges of -1.0f (traversed all the way from the bottom or\nright to all the way up or left) to 1.0f (traversed all the way from the\ntop or left to all the way down or right).\n\nNote that while the coordinates are _normalized_, they are not _clamped_,\nwhich means in some circumstances you can get a value outside of this\nrange. For example, a renderer using logical presentation might give a\nnegative value when the touch is in the letterboxing. Some platforms might\nreport a touch outside of the window, which will also be outside of the\nrange.\n\n@since This struct is available since SDL 3.2.0.",
          "name": "TouchFingerEvent",
          "kind": "alias",
          "sourceName": "SDL_TouchFingerEvent",
          "type": "SDL_TouchFingerEvent"
        },
        "PenProximityEvent": {
          "doc": "Pressure-sensitive pen proximity event structure (event.pmotion.*)\n\nWhen a pen becomes visible to the system (it is close enough to a tablet,\netc), SDL will send an EVENT_PEN_PROXIMITY_IN event with the new pen's\nID. This ID is valid until the pen leaves proximity again (has been removed\nfrom the tablet's area, the tablet has been unplugged, etc). If the same\npen reenters proximity again, it will be given a new ID.\n\nNote that \"proximity\" means \"close enough for the tablet to know the tool\nis there.\" The pen touching and lifting off from the tablet while not\nleaving the area are handled by EVENT_PEN_DOWN and EVENT_PEN_UP.\n\n@since This struct is available since SDL 3.2.0.",
          "name": "PenProximityEvent",
          "kind": "alias",
          "sourceName": "SDL_PenProximityEvent",
          "type": "SDL_PenProximityEvent"
        },
        "PenMotionEvent": {
          "doc": "Pressure-sensitive pen motion event structure (event.pmotion.*)\n\nDepending on the hardware, you may get motion events when the pen is not\ntouching a tablet, for tracking a pen even when it isn't drawing. You\nshould listen for EVENT_PEN_DOWN and EVENT_PEN_UP events, or check\n`pen_state & SDL_PEN_INPUT_DOWN` to decide if a pen is \"drawing\" when\ndealing with pen motion.\n\n@since This struct is available since SDL 3.2.0.",
          "name": "PenMotionEvent",
          "kind": "alias",
          "sourceName": "SDL_PenMotionEvent",
          "type": "SDL_PenMotionEvent"
        },
        "PenTouchEvent": {
          "doc": "Pressure-sensitive pen touched event structure (event.ptouch.*)\n\nThese events come when a pen touches a surface (a tablet, etc), or lifts\noff from one.\n\n@since This struct is available since SDL 3.2.0.",
          "name": "PenTouchEvent",
          "kind": "alias",
          "sourceName": "SDL_PenTouchEvent",
          "type": "SDL_PenTouchEvent"
        },
        "PenButtonEvent": {
          "doc": "Pressure-sensitive pen button event structure (event.pbutton.*)\n\nThis is for buttons on the pen itself that the user might click. The pen\nitself pressing down to draw triggers a EVENT_PEN_DOWN event instead.\n\n@since This struct is available since SDL 3.2.0.",
          "name": "PenButtonEvent",
          "kind": "alias",
          "sourceName": "SDL_PenButtonEvent",
          "type": "SDL_PenButtonEvent"
        },
        "PenAxisEvent": {
          "doc": "Pressure-sensitive pen pressure / angle event structure (event.paxis.*)\n\nYou might get some of these events even if the pen isn't touching the\ntablet.\n\n@since This struct is available since SDL 3.2.0.",
          "name": "PenAxisEvent",
          "kind": "alias",
          "sourceName": "SDL_PenAxisEvent",
          "type": "SDL_PenAxisEvent"
        },
        "DropEvent": {
          "doc": "An event used to drop text or request a file open by the system\n(event.drop.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "DropEvent",
          "kind": "alias",
          "sourceName": "SDL_DropEvent",
          "type": "SDL_DropEvent"
        },
        "ClipboardEvent": {
          "doc": "An event triggered when the clipboard contents have changed\n(event.clipboard.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "ClipboardEvent",
          "kind": "alias",
          "sourceName": "SDL_ClipboardEvent",
          "type": "SDL_ClipboardEvent"
        },
        "SensorEvent": {
          "doc": "Sensor event structure (event.sensor.*)\n\n@since This struct is available since SDL 3.2.0.",
          "name": "SensorEvent",
          "kind": "alias",
          "sourceName": "SDL_SensorEvent",
          "type": "SDL_SensorEvent"
        },
        "QuitEvent": {
          "doc": "The \"quit requested\" event\n\n@since This struct is available since SDL 3.2.0.",
          "name": "QuitEvent",
          "kind": "alias",
          "sourceName": "SDL_QuitEvent",
          "type": "SDL_QuitEvent"
        },
        "UserEvent": {
          "doc": "A user-defined event type (event.user.*)\n\nThis event is unique; it is never created by SDL, but only by the\napplication. The event can be pushed onto the event queue using\nPushEvent(). The contents of the structure members are completely up to\nthe programmer; the only requirement is that '''type''' is a value obtained\nfrom RegisterEvents().\n\n@since This struct is available since SDL 3.2.0.",
          "name": "UserEvent",
          "kind": "alias",
          "sourceName": "SDL_UserEvent",
          "type": "SDL_UserEvent"
        },
        "Event": {
          "doc": "The structure for all events in SDL.\n\nThe Event structure is the core of all event handling in SDL. Event\nis a union of all event structures used in SDL.\n\n@since This struct is available since SDL 3.2.0.",
          "name": "Event",
          "kind": "alias",
          "sourceName": "SDL_Event",
          "type": "SDL_Event"
        },
        "PumpEvents": {
          "doc": "Pump the event loop, gathering events from the input devices.\n\nThis function updates the event queue and internal input device state.\n\nPumpEvents() gathers all the pending input information from devices and\nplaces it in the event queue. Without calls to PumpEvents() no events\nwould ever be placed on the queue. Often the need for calls to\nPumpEvents() is hidden from the user since PollEvent() and\nWaitEvent() implicitly call PumpEvents(). However, if you are not\npolling or waiting for events (e.g. you are filtering them), then you must\ncall PumpEvents() to force an event queue update.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PollEvent\n@sa WaitEvent",
          "name": "PumpEvents",
          "kind": "function",
          "type": "void",
          "parameters": [],
          "sourceName": "SDL_PumpEvents"
        },
        "EventAction": {
          "doc": "The type of action to request from PeepEvents().\n\n@since This enum is available since SDL 3.2.0.",
          "name": "EventAction",
          "kind": "alias",
          "sourceName": "SDL_EventAction",
          "type": "SDL_EventAction"
        },
        "ADDEVENT": {
          "doc": "Add events to the back of the queue.",
          "name": "ADDEVENT",
          "kind": "var",
          "type": "EventAction",
          "sourceName": "SDL_ADDEVENT",
          "constexpr": true
        },
        "PEEKEVENT": {
          "doc": "Check but don't remove events from the queue front.",
          "name": "PEEKEVENT",
          "kind": "var",
          "type": "EventAction",
          "sourceName": "SDL_PEEKEVENT",
          "constexpr": true
        },
        "GETEVENT": {
          "doc": "Retrieve/remove events from the front of the queue.",
          "name": "GETEVENT",
          "kind": "var",
          "type": "EventAction",
          "sourceName": "SDL_GETEVENT",
          "constexpr": true
        },
        "PeepEvents": {
          "doc": "Check the event queue for messages and optionally return them.\n\n`action` may be any of the following:\n\n- `ADDEVENT`: up to `numevents` events will be added to the back of the\n  event queue.\n- `PEEKEVENT`: `numevents` events at the front of the event queue,\n  within the specified minimum and maximum type, will be returned to the\n  caller and will _not_ be removed from the queue. If you pass nullptr for\n  `events`, then `numevents` is ignored and the total number of matching\n  events will be returned.\n- `GETEVENT`: up to `numevents` events at the front of the event queue,\n  within the specified minimum and maximum type, will be returned to the\n  caller and will be removed from the queue.\n\nYou may have to call PumpEvents() before calling this function.\nOtherwise, the events may not be ready to be filtered when you call\nPeepEvents().\n\n@param events destination buffer for the retrieved events, may be nullptr to\n              leave the events in the queue and return the number of events\n              that would have been stored.\n@param numevents if action is ADDEVENT, the number of events to add\n                 back to the event queue; if action is PEEKEVENT or\n                 GETEVENT, the maximum number of events to retrieve.\n@param action action to take; see [Remarks](#remarks) for details.\n@param minType minimum value of the event type to be considered;\n               EVENT_FIRST is a safe choice.\n@param maxType maximum value of the event type to be considered;\n               EVENT_LAST is a safe choice.\n@returns the number of events actually stored or -1 on failure; call\n         GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PollEvent\n@sa PumpEvents\n@sa PushEvent",
          "name": "PeepEvents",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "events",
              "type": "Event *"
            },
            {
              "name": "numevents",
              "type": "int"
            },
            {
              "name": "action",
              "type": "EventAction"
            },
            {
              "name": "minType",
              "type": "Uint32"
            },
            {
              "name": "maxType",
              "type": "Uint32"
            }
          ],
          "sourceName": "SDL_PeepEvents"
        },
        "HasEvent": {
          "doc": "Check for the existence of a certain event type in the event queue.\n\nIf you need to check for a range of event types, use HasEvents()\ninstead.\n\n@param type the type of event to be queried; see EventType for details.\n@returns true if events matching `type` are present, or false if events\n         matching `type` are not present.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa HasEvents",
          "name": "HasEvent",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "type",
              "type": "Uint32"
            }
          ],
          "sourceName": "SDL_HasEvent"
        },
        "HasEvents": {
          "doc": "Check for the existence of certain event types in the event queue.\n\nIf you need to check for a single event type, use HasEvent() instead.\n\n@param minType the low end of event type to be queried, inclusive; see\n               EventType for details.\n@param maxType the high end of event type to be queried, inclusive; see\n               EventType for details.\n@returns true if events with type >= `minType` and <= `maxType` are\n         present, or false if not.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa HasEvents",
          "name": "HasEvents",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "minType",
              "type": "Uint32"
            },
            {
              "name": "maxType",
              "type": "Uint32"
            }
          ],
          "sourceName": "SDL_HasEvents"
        },
        "FlushEvent": {
          "doc": "Clear events of a specific type from the event queue.\n\nThis will unconditionally remove any events from the queue that match\n`type`. If you need to remove a range of event types, use FlushEvents()\ninstead.\n\nIt's also normal to just ignore events you don't care about in your event\nloop without calling this function.\n\nThis function only affects currently queued events. If you want to make\nsure that all pending OS events are flushed, you can call PumpEvents()\non the main thread immediately before the flush call.\n\nIf you have user events with custom data that needs to be freed, you should\nuse PeepEvents() to remove and clean up those events before calling\nthis function.\n\n@param type the type of event to be cleared; see EventType for details.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa FlushEvents",
          "name": "FlushEvent",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "type",
              "type": "Uint32"
            }
          ],
          "sourceName": "SDL_FlushEvent"
        },
        "FlushEvents": {
          "doc": "Clear events of a range of types from the event queue.\n\nThis will unconditionally remove any events from the queue that are in the\nrange of `minType` to `maxType`, inclusive. If you need to remove a single\nevent type, use FlushEvent() instead.\n\nIt's also normal to just ignore events you don't care about in your event\nloop without calling this function.\n\nThis function only affects currently queued events. If you want to make\nsure that all pending OS events are flushed, you can call PumpEvents()\non the main thread immediately before the flush call.\n\n@param minType the low end of event type to be cleared, inclusive; see\n               EventType for details.\n@param maxType the high end of event type to be cleared, inclusive; see\n               EventType for details.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa FlushEvent",
          "name": "FlushEvents",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "minType",
              "type": "Uint32"
            },
            {
              "name": "maxType",
              "type": "Uint32"
            }
          ],
          "sourceName": "SDL_FlushEvents"
        },
        "PollEvent": [
          {
            "doc": "Poll for currently pending events.\n\nIf `event` is not nullptr, the next event is removed from the queue and stored\nin the Event structure pointed to by `event`. The 1 returned refers to\nthis event, immediately stored in the SDL Event structure -- not an event\nto follow.\n\nIf `event` is nullptr, it simply returns 1 if there is an event in the queue,\nbut will not remove it from the queue.\n\nAs this function may implicitly call PumpEvents(), you can only call\nthis function in the thread that set the video mode.\n\nPollEvent() is the favored way of receiving system events since it can\nbe done from the main loop and does not suspend the main loop while waiting\non an event to be posted.\n\nThe common practice is to fully process the event queue once every frame,\nusually as a first step before updating the game's state:\n\n```c\nwhile (game_is_still_running) {\n    Event event;\n    while (PollEvent(&event)) {  // poll until all events are handled!\n        // decide what to do with this event.\n    }\n\n    // update game state, draw the current frame\n}\n```\n\n@param event the Event structure to be filled with the next event from\n             the queue, or nullptr.\n@returns true if this got an event or false if there are none available.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PushEvent\n@sa WaitEvent\n@sa WaitEventTimeout",
            "name": "PollEvent",
            "kind": "function",
            "type": "bool",
            "parameters": [
              {
                "name": "event",
                "type": "Event *"
              }
            ],
            "sourceName": "SDL_PollEvent"
          },
          {
            "kind": "function",
            "name": "PollEvent",
            "type": "std::optional<Event>",
            "parameters": [],
            "doc": ""
          }
        ],
        "WaitEvent": [
          {
            "doc": "Wait indefinitely for the next available event.\n\nIf `event` is not nullptr, the next event is removed from the queue and stored\nin the Event structure pointed to by `event`.\n\nAs this function may implicitly call PumpEvents(), you can only call\nthis function in the thread that initialized the video subsystem.\n\n@param event the Event structure to be filled in with the next event\n             from the queue, or nullptr.\n@returns true on success or false if there was an error while waiting for\n         events; call GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PollEvent\n@sa PushEvent\n@sa WaitEventTimeout",
            "name": "WaitEvent",
            "kind": "function",
            "type": "bool",
            "parameters": [
              {
                "name": "event",
                "type": "Event *"
              }
            ],
            "sourceName": "SDL_WaitEvent"
          },
          {
            "kind": "function",
            "name": "WaitEvent",
            "type": "std::optional<Event>",
            "parameters": [],
            "doc": ""
          }
        ],
        "WaitEventTimeout": [
          {
            "doc": "Wait until the specified timeout (in milliseconds) for the next available\nevent.\n\nIf `event` is not nullptr, the next event is removed from the queue and stored\nin the Event structure pointed to by `event`.\n\nAs this function may implicitly call PumpEvents(), you can only call\nthis function in the thread that initialized the video subsystem.\n\nThe timeout is not guaranteed, the actual wait time could be longer due to\nsystem scheduling.\n\n@param event the Event structure to be filled in with the next event\n             from the queue, or nullptr.\n@param timeoutMS the maximum number of milliseconds to wait for the next\n                 available event.\n@returns true if this got an event or false if the timeout elapsed without\n         any events available.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PollEvent\n@sa PushEvent\n@sa WaitEvent",
            "name": "WaitEventTimeout",
            "kind": "function",
            "type": "bool",
            "parameters": [
              {
                "name": "event",
                "type": "Event *"
              },
              {
                "name": "timeoutMS",
                "type": "Sint32"
              }
            ],
            "sourceName": "SDL_WaitEventTimeout"
          },
          {
            "kind": "function",
            "name": "WaitEventTimeout",
            "type": "std::optional<Event>",
            "parameters": [
              {
                "type": "Sint32",
                "name": "timeoutMS"
              }
            ],
            "doc": ""
          },
          {
            "kind": "function",
            "name": "WaitEventTimeout",
            "type": "bool",
            "parameters": [
              {
                "type": "Event *",
                "name": "event"
              },
              {
                "type": "std::chrono::milliseconds",
                "name": "timeoutDuration"
              }
            ],
            "doc": ""
          },
          {
            "kind": "function",
            "name": "WaitEventTimeout",
            "type": "std::optional<Event>",
            "parameters": [
              {
                "type": "std::chrono::milliseconds",
                "name": "timeoutDuration"
              }
            ],
            "doc": ""
          }
        ],
        "PushEvent": [
          {
            "doc": "Add an event to the event queue.\n\nThe event queue can actually be used as a two way communication channel.\nNot only can events be read from the queue, but the user can also push\ntheir own events onto it. `event` is a pointer to the event structure you\nwish to push onto the queue. The event is copied into the queue, and the\ncaller may dispose of the memory pointed to after PushEvent() returns.\n\nNote: Pushing device input events onto the queue doesn't modify the state\nof the device within SDL.\n\nNote: Events pushed onto the queue with PushEvent() get passed through\nthe event filter but events added with PeepEvents() do not.\n\nFor pushing application-specific events, please use RegisterEvents() to\nget an event type that does not conflict with other code that also wants\nits own custom event types.\n\n@param event the Event to be added to the queue.\n@returns true on success, false if the event was filtered or on failure;\n         call GetError() for more information. A common reason for\n         error is the event queue being full.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PeepEvents\n@sa PollEvent\n@sa RegisterEvents",
            "name": "PushEvent",
            "kind": "function",
            "type": "bool",
            "parameters": [
              {
                "name": "event",
                "type": "Event *"
              }
            ],
            "sourceName": "SDL_PushEvent"
          },
          {
            "kind": "function",
            "name": "PushEvent",
            "type": "bool",
            "parameters": [
              {
                "type": "const Event &",
                "name": "event"
              }
            ],
            "doc": ""
          }
        ],
        "EventFilter": {
          "doc": "A function pointer used for callbacks that watch the event queue.\n\n@param userdata what was passed as `userdata` to SetEventFilter() or\n                AddEventWatch, etc.\n@param event the event that triggered the callback.\n@returns true to permit event to be added to the queue, and false to\n         disallow it. When used with AddEventWatch, the return value is\n         ignored.\n\n@threadsafety SDL may call this callback at any time from any thread; the\n              application is responsible for locking resources the callback\n              touches that need to be protected.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa SetEventFilter\n@sa AddEventWatch",
          "name": "EventFilter",
          "kind": "alias",
          "type": "SDL_EventFilter",
          "sourceName": "SDL_EventFilter"
        },
        "EventFilterCB": {
          "kind": "alias",
          "name": "EventFilterCB",
          "type": "std::function<bool(const Event &)>",
          "doc": ""
        },
        "EventWatchHandle": {
          "doc": "Handle returned by AddEventWatch()",
          "kind": "struct",
          "name": "EventWatchHandle",
          "entries": {
            "id": {
              "kind": "var",
              "type": "void *",
              "name": "id",
              "doc": ""
            },
            "EventWatchHandle": {
              "kind": "function",
              "type": "",
              "explicit": true,
              "constexpr": true,
              "parameters": [
                {
                  "type": "void *",
                  "name": "id",
                  "default": "nullptr"
                }
              ],
              "name": "EventWatchHandle",
              "doc": ""
            },
            "get": {
              "kind": "function",
              "type": "void *",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "name": "get",
              "doc": ""
            },
            "operator bool": {
              "kind": "function",
              "type": "",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "name": "operator bool",
              "doc": ""
            }
          }
        },
        "SetEventFilter": [
          {
            "doc": "Set up a filter to process all events before they are added to the internal\nevent queue.\n\nIf you just want to see events without modifying them or preventing them\nfrom being queued, you should use AddEventWatch() instead.\n\nIf the filter function returns true when called, then the event will be\nadded to the internal queue. If it returns false, then the event will be\ndropped from the queue, but the internal state will still be updated. This\nallows selective filtering of dynamically arriving events.\n\n**WARNING**: Be very careful of what you do in the event filter function,\nas it may run in a different thread!\n\nOn platforms that support it, if the quit event is generated by an\ninterrupt signal (e.g. pressing Ctrl-C), it will be delivered to the\napplication at the next event poll.\n\nNote: Disabled events never make it to the event filter function; see\nSetEventEnabled().\n\nNote: Events pushed onto the queue with PushEvent() get passed through\nthe event filter, but events pushed onto the queue with PeepEvents() do\nnot.\n\n@param filter an EventFilter function to call when an event happens.\n@param userdata a pointer that is passed to `filter`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa AddEventWatch\n@sa SetEventEnabled\n@sa GetEventFilter\n@sa PeepEvents\n@sa PushEvent",
            "name": "SetEventFilter",
            "kind": "function",
            "type": "void",
            "parameters": [
              {
                "name": "filter",
                "type": "EventFilter"
              },
              {
                "name": "userdata",
                "type": "void *"
              }
            ],
            "sourceName": "SDL_SetEventFilter"
          },
          {
            "kind": "function",
            "name": "SetEventFilter",
            "type": "void",
            "parameters": [
              {
                "type": "EventFilterCB",
                "name": "filter",
                "default": "{}"
              }
            ],
            "doc": ""
          }
        ],
        "GetEventFilter": [
          {
            "doc": "Query the current event filter.\n\nThis function can be used to \"chain\" filters, by saving the existing filter\nbefore replacing it with a function that will call that saved filter.\n\n@param filter the current callback function will be stored here.\n@param userdata the pointer that is passed to the current event filter will\n                be stored here.\n@returns true on success or false if there is no event filter set.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SetEventFilter",
            "name": "GetEventFilter",
            "kind": "function",
            "type": "bool",
            "parameters": [
              {
                "name": "filter",
                "type": "EventFilter *"
              },
              {
                "name": "userdata",
                "type": "void **"
              }
            ],
            "sourceName": "SDL_GetEventFilter"
          },
          {
            "kind": "function",
            "name": "GetEventFilter",
            "type": "EventFilterCB",
            "parameters": [],
            "doc": ""
          }
        ],
        "EventWatchAuxCallback": {
          "kind": "function",
          "name": "EventWatchAuxCallback",
          "type": "bool",
          "parameters": [
            {
              "type": "void *",
              "name": "userdata"
            },
            {
              "type": "Event *",
              "name": "event"
            }
          ],
          "doc": ""
        },
        "AddEventWatch": [
          {
            "doc": "Add a callback to be triggered when an event is added to the event queue.\n\n`filter` will be called when an event happens, and its return value is\nignored.\n\n**WARNING**: Be very careful of what you do in the event filter function,\nas it may run in a different thread!\n\nIf the quit event is generated by a signal (e.g. SIGINT), it will bypass\nthe internal queue and be delivered to the watch callback immediately, and\narrive at the next event poll.\n\nNote: the callback is called for events posted by the user through\nPushEvent(), but not for disabled events, nor for events by a filter\ncallback set with SetEventFilter(), nor for events posted by the user\nthrough PeepEvents().\n\n@param filter an EventFilter function to call when an event happens.\n@param userdata a pointer that is passed to `filter`.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RemoveEventWatch\n@sa SetEventFilter",
            "name": "AddEventWatch",
            "kind": "function",
            "type": "bool",
            "parameters": [
              {
                "name": "filter",
                "type": "EventFilter"
              },
              {
                "name": "userdata",
                "type": "void *"
              }
            ],
            "sourceName": "SDL_AddEventWatch"
          },
          {
            "kind": "function",
            "name": "AddEventWatch",
            "type": "EventWatchHandle",
            "parameters": [
              {
                "type": "EventFilterCB",
                "name": "filter"
              }
            ],
            "doc": ""
          }
        ],
        "RemoveEventWatch": [
          {
            "doc": "Remove an event watch callback added with AddEventWatch().\n\nThis function takes the same input as AddEventWatch() to identify and\ndelete the corresponding callback.\n\n@param filter the function originally passed to AddEventWatch().\n@param userdata the pointer originally passed to AddEventWatch().\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa AddEventWatch",
            "name": "RemoveEventWatch",
            "kind": "function",
            "type": "void",
            "parameters": [
              {
                "name": "filter",
                "type": "EventFilter"
              },
              {
                "name": "userdata",
                "type": "void *"
              }
            ],
            "sourceName": "SDL_RemoveEventWatch"
          },
          {
            "kind": "function",
            "name": "RemoveEventWatch",
            "type": "void",
            "parameters": [
              {
                "type": "EventWatchHandle",
                "name": "handle"
              }
            ],
            "doc": ""
          }
        ],
        "FilterEvents": [
          {
            "doc": "Run a specific filter function on the current event queue, removing any\nevents for which the filter returns false.\n\nSee SetEventFilter() for more information. Unlike SetEventFilter(),\nthis function does not change the filter permanently, it only uses the\nsupplied filter until this function returns.\n\n@param filter the EventFilter function to call when an event happens.\n@param userdata a pointer that is passed to `filter`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetEventFilter\n@sa SetEventFilter",
            "name": "FilterEvents",
            "kind": "function",
            "type": "void",
            "parameters": [
              {
                "name": "filter",
                "type": "EventFilter"
              },
              {
                "name": "userdata",
                "type": "void *"
              }
            ],
            "sourceName": "SDL_FilterEvents"
          },
          {
            "kind": "function",
            "name": "FilterEvents",
            "type": "void",
            "parameters": [
              {
                "type": "EventFilterCB",
                "name": "filter"
              }
            ],
            "doc": ""
          }
        ],
        "SetEventEnabled": {
          "doc": "Set the state of processing events by type.\n\n@param type the type of event; see EventType for details.\n@param enabled whether to process the event or not.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa EventEnabled",
          "name": "SetEventEnabled",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "type",
              "type": "Uint32"
            },
            {
              "name": "enabled",
              "type": "bool"
            }
          ],
          "sourceName": "SDL_SetEventEnabled"
        },
        "EventEnabled": {
          "doc": "Query the state of processing events by type.\n\n@param type the type of event; see EventType for details.\n@returns true if the event is being processed, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SetEventEnabled",
          "name": "EventEnabled",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "type",
              "type": "Uint32"
            }
          ],
          "sourceName": "SDL_EventEnabled"
        },
        "RegisterEvents": {
          "doc": "Allocate a set of user-defined events, and return the beginning event\nnumber for that set of events.\n\n@param numevents the number of events to be allocated.\n@returns the beginning event number, or 0 if numevents is invalid or if\n         there are not enough user-defined events left.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PushEvent",
          "name": "RegisterEvents",
          "kind": "function",
          "type": "Uint32",
          "parameters": [
            {
              "name": "numevents",
              "type": "int"
            }
          ],
          "sourceName": "SDL_RegisterEvents"
        },
        "GetWindowFromEvent": {
          "doc": "Get window associated with an event.\n\n@param event an event containing a `windowID`.\n@returns the associated window on success or nullptr if there is none.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PollEvent\n@sa WaitEvent\n@sa WaitEventTimeout",
          "name": "GetWindowFromEvent",
          "kind": "function",
          "type": "WindowRef",
          "parameters": [
            {
              "name": "event",
              "type": "const Event *"
            }
          ],
          "sourceName": "SDL_GetWindowFromEvent"
        }
      }
    },
    "SDL3pp_scancode.h": {
      "name": "SDL3pp_scancode.h",
      "doc": "@defgroup CategoryScancode Category Scancode\n\nDefines keyboard scancodes.\n\nPlease refer to the Best Keyboard Practices document for details on what\nthis information means and how best to use it.\n\nhttps://wiki.libsdl.org/SDL3/BestKeyboardPractices",
      "entries": {
        "Keycode-forward": {
          "name": "Keycode",
          "kind": "forward",
          "doc": ""
        },
        "Scancode": {
          "doc": "The SDL keyboard scancode representation.\n\nAn SDL scancode is the physical representation of a key on the keyboard,\nindependent of language and keyboard mapping.\n\nValues of this type are used to represent keyboard keys, among other places\nin the `scancode` field of the KeyboardEvent structure.\n\nThe values in this enumeration are based on the USB usage page standard:\nhttps://usb.org/sites/default/files/hut1_5.pdf\n\n@since This enum is available since SDL 3.2.0.",
          "name": "Scancode",
          "kind": "struct",
          "sourceName": "SDL_Scancode",
          "type": "",
          "entries": {
            "m_scancode": {
              "kind": "var",
              "name": "m_scancode",
              "type": "SDL_Scancode",
              "doc": ""
            },
            "Scancode": [
              {
                "kind": "function",
                "name": "Scancode",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "SDL_Scancode",
                    "name": "scancode",
                    "default": "{}"
                  }
                ],
                "doc": "Wraps Scancode.\n\n@param scancode the value to be wrapped"
              },
              {
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "type": "StringParam",
                    "name": "name"
                  }
                ],
                "name": "Scancode",
                "doc": ""
              }
            ],
            "operator<=>": {
              "kind": "function",
              "name": "operator<=>",
              "type": "auto",
              "constexpr": true,
              "immutable": true,
              "parameters": [
                {
                  "type": "const Scancode &",
                  "name": "other"
                }
              ],
              "doc": ""
            },
            "operator SDL_Scancode": {
              "kind": "function",
              "name": "operator SDL_Scancode",
              "type": "",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Unwraps to the underlying Scancode.\n\n@returns the underlying Scancode."
            },
            "operator bool": {
              "kind": "function",
              "name": "operator bool",
              "type": "",
              "constexpr": true,
              "explicit": true,
              "immutable": true,
              "parameters": [],
              "doc": "Check if valid.\n\n@returns True if valid state, false otherwise."
            },
            "SetName": {
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "type": "StringParam",
                  "name": "name"
                }
              ],
              "name": "SetName",
              "doc": ""
            },
            "GetName": {
              "kind": "function",
              "type": "const char *",
              "immutable": true,
              "parameters": [],
              "name": "GetName",
              "doc": ""
            }
          }
        },
        "SCANCODE_UNKNOWN": {
          "doc": "",
          "name": "SCANCODE_UNKNOWN",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_UNKNOWN",
          "constexpr": true
        },
        "SCANCODE_A": {
          "doc": "",
          "name": "SCANCODE_A",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_A",
          "constexpr": true
        },
        "SCANCODE_B": {
          "doc": "",
          "name": "SCANCODE_B",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_B",
          "constexpr": true
        },
        "SCANCODE_C": {
          "doc": "",
          "name": "SCANCODE_C",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_C",
          "constexpr": true
        },
        "SCANCODE_D": {
          "doc": "",
          "name": "SCANCODE_D",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_D",
          "constexpr": true
        },
        "SCANCODE_E": {
          "doc": "",
          "name": "SCANCODE_E",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_E",
          "constexpr": true
        },
        "SCANCODE_F": {
          "doc": "",
          "name": "SCANCODE_F",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F",
          "constexpr": true
        },
        "SCANCODE_G": {
          "doc": "",
          "name": "SCANCODE_G",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_G",
          "constexpr": true
        },
        "SCANCODE_H": {
          "doc": "",
          "name": "SCANCODE_H",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_H",
          "constexpr": true
        },
        "SCANCODE_I": {
          "doc": "",
          "name": "SCANCODE_I",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_I",
          "constexpr": true
        },
        "SCANCODE_J": {
          "doc": "",
          "name": "SCANCODE_J",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_J",
          "constexpr": true
        },
        "SCANCODE_K": {
          "doc": "",
          "name": "SCANCODE_K",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_K",
          "constexpr": true
        },
        "SCANCODE_L": {
          "doc": "",
          "name": "SCANCODE_L",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_L",
          "constexpr": true
        },
        "SCANCODE_M": {
          "doc": "",
          "name": "SCANCODE_M",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_M",
          "constexpr": true
        },
        "SCANCODE_N": {
          "doc": "",
          "name": "SCANCODE_N",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_N",
          "constexpr": true
        },
        "SCANCODE_O": {
          "doc": "",
          "name": "SCANCODE_O",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_O",
          "constexpr": true
        },
        "SCANCODE_P": {
          "doc": "",
          "name": "SCANCODE_P",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_P",
          "constexpr": true
        },
        "SCANCODE_Q": {
          "doc": "",
          "name": "SCANCODE_Q",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_Q",
          "constexpr": true
        },
        "SCANCODE_R": {
          "doc": "",
          "name": "SCANCODE_R",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_R",
          "constexpr": true
        },
        "SCANCODE_S": {
          "doc": "",
          "name": "SCANCODE_S",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_S",
          "constexpr": true
        },
        "SCANCODE_T": {
          "doc": "",
          "name": "SCANCODE_T",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_T",
          "constexpr": true
        },
        "SCANCODE_U": {
          "doc": "",
          "name": "SCANCODE_U",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_U",
          "constexpr": true
        },
        "SCANCODE_V": {
          "doc": "",
          "name": "SCANCODE_V",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_V",
          "constexpr": true
        },
        "SCANCODE_W": {
          "doc": "",
          "name": "SCANCODE_W",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_W",
          "constexpr": true
        },
        "SCANCODE_X": {
          "doc": "",
          "name": "SCANCODE_X",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_X",
          "constexpr": true
        },
        "SCANCODE_Y": {
          "doc": "",
          "name": "SCANCODE_Y",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_Y",
          "constexpr": true
        },
        "SCANCODE_Z": {
          "doc": "",
          "name": "SCANCODE_Z",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_Z",
          "constexpr": true
        },
        "SCANCODE_1": {
          "doc": "",
          "name": "SCANCODE_1",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_1",
          "constexpr": true
        },
        "SCANCODE_2": {
          "doc": "",
          "name": "SCANCODE_2",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_2",
          "constexpr": true
        },
        "SCANCODE_3": {
          "doc": "",
          "name": "SCANCODE_3",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_3",
          "constexpr": true
        },
        "SCANCODE_4": {
          "doc": "",
          "name": "SCANCODE_4",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_4",
          "constexpr": true
        },
        "SCANCODE_5": {
          "doc": "",
          "name": "SCANCODE_5",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_5",
          "constexpr": true
        },
        "SCANCODE_6": {
          "doc": "",
          "name": "SCANCODE_6",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_6",
          "constexpr": true
        },
        "SCANCODE_7": {
          "doc": "",
          "name": "SCANCODE_7",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_7",
          "constexpr": true
        },
        "SCANCODE_8": {
          "doc": "",
          "name": "SCANCODE_8",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_8",
          "constexpr": true
        },
        "SCANCODE_9": {
          "doc": "",
          "name": "SCANCODE_9",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_9",
          "constexpr": true
        },
        "SCANCODE_0": {
          "doc": "",
          "name": "SCANCODE_0",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_0",
          "constexpr": true
        },
        "SCANCODE_RETURN": {
          "doc": "",
          "name": "SCANCODE_RETURN",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_RETURN",
          "constexpr": true
        },
        "SCANCODE_ESCAPE": {
          "doc": "",
          "name": "SCANCODE_ESCAPE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_ESCAPE",
          "constexpr": true
        },
        "SCANCODE_BACKSPACE": {
          "doc": "",
          "name": "SCANCODE_BACKSPACE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_BACKSPACE",
          "constexpr": true
        },
        "SCANCODE_TAB": {
          "doc": "",
          "name": "SCANCODE_TAB",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_TAB",
          "constexpr": true
        },
        "SCANCODE_SPACE": {
          "doc": "",
          "name": "SCANCODE_SPACE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_SPACE",
          "constexpr": true
        },
        "SCANCODE_MINUS": {
          "doc": "",
          "name": "SCANCODE_MINUS",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_MINUS",
          "constexpr": true
        },
        "SCANCODE_EQUALS": {
          "doc": "",
          "name": "SCANCODE_EQUALS",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_EQUALS",
          "constexpr": true
        },
        "SCANCODE_LEFTBRACKET": {
          "doc": "",
          "name": "SCANCODE_LEFTBRACKET",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_LEFTBRACKET",
          "constexpr": true
        },
        "SCANCODE_RIGHTBRACKET": {
          "doc": "",
          "name": "SCANCODE_RIGHTBRACKET",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_RIGHTBRACKET",
          "constexpr": true
        },
        "SCANCODE_BACKSLASH": {
          "doc": "Located at the lower left of the return key on ISO keyboards and at the right end of the QWERTY row on ANSI keyboards.  Produces REVERSE SOLIDUS (backslash) and VERTICAL LINE in a US layout, REVERSE SOLIDUS and VERTICAL LINE in a UK Mac layout, NUMBER SIGN and TILDE in a UK Windows layout, DOLLAR SIGN and POUND SIGN in a Swiss German layout, NUMBER SIGN and APOSTROPHE in a German layout, GRAVE ACCENT and POUND SIGN in a French Mac layout, and ASTERISK and MICRO SIGN in a French Windows layout.",
          "name": "SCANCODE_BACKSLASH",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_BACKSLASH",
          "constexpr": true
        },
        "SCANCODE_NONUSHASH": {
          "doc": "ISO USB keyboards actually use this code instead of 49 for the same key, but all OSes I've seen treat the two codes identically.  So, as an implementor, unless your keyboard generates both of those codes and your OS treats them differently, you should generate SCANCODE_BACKSLASH instead of this code. As a user, you should not rely on this code because SDL will never generate it with most (all?) keyboards.",
          "name": "SCANCODE_NONUSHASH",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_NONUSHASH",
          "constexpr": true
        },
        "SCANCODE_SEMICOLON": {
          "doc": "",
          "name": "SCANCODE_SEMICOLON",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_SEMICOLON",
          "constexpr": true
        },
        "SCANCODE_APOSTROPHE": {
          "doc": "",
          "name": "SCANCODE_APOSTROPHE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_APOSTROPHE",
          "constexpr": true
        },
        "SCANCODE_GRAVE": {
          "doc": "Located in the top left corner (on both ANSI and ISO keyboards).  Produces GRAVE ACCENT and TILDE in a US Windows layout and in US and UK Mac layouts on ANSI keyboards, GRAVE ACCENT and NOT SIGN in a UK Windows layout, SECTION SIGN and PLUS-MINUS SIGN in US and UK Mac layouts on ISO keyboards, SECTION SIGN and DEGREE SIGN in a Swiss German layout (Mac: only on ISO keyboards), CIRCUMFLEX ACCENT and DEGREE SIGN in a German layout (Mac: only on ISO keyboards), SUPERSCRIPT TWO and TILDE in a French Windows layout, COMMERCIAL AT and NUMBER SIGN in a French Mac layout on ISO keyboards, and LESS-THAN SIGN and GREATER-THAN SIGN in a Swiss German, German, or French Mac layout on ANSI keyboards.",
          "name": "SCANCODE_GRAVE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_GRAVE",
          "constexpr": true
        },
        "SCANCODE_COMMA": {
          "doc": "",
          "name": "SCANCODE_COMMA",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_COMMA",
          "constexpr": true
        },
        "SCANCODE_PERIOD": {
          "doc": "",
          "name": "SCANCODE_PERIOD",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_PERIOD",
          "constexpr": true
        },
        "SCANCODE_SLASH": {
          "doc": "",
          "name": "SCANCODE_SLASH",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_SLASH",
          "constexpr": true
        },
        "SCANCODE_CAPSLOCK": {
          "doc": "",
          "name": "SCANCODE_CAPSLOCK",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_CAPSLOCK",
          "constexpr": true
        },
        "SCANCODE_F1": {
          "doc": "",
          "name": "SCANCODE_F1",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F1",
          "constexpr": true
        },
        "SCANCODE_F2": {
          "doc": "",
          "name": "SCANCODE_F2",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F2",
          "constexpr": true
        },
        "SCANCODE_F3": {
          "doc": "",
          "name": "SCANCODE_F3",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F3",
          "constexpr": true
        },
        "SCANCODE_F4": {
          "doc": "",
          "name": "SCANCODE_F4",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F4",
          "constexpr": true
        },
        "SCANCODE_F5": {
          "doc": "",
          "name": "SCANCODE_F5",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F5",
          "constexpr": true
        },
        "SCANCODE_F6": {
          "doc": "",
          "name": "SCANCODE_F6",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F6",
          "constexpr": true
        },
        "SCANCODE_F7": {
          "doc": "",
          "name": "SCANCODE_F7",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F7",
          "constexpr": true
        },
        "SCANCODE_F8": {
          "doc": "",
          "name": "SCANCODE_F8",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F8",
          "constexpr": true
        },
        "SCANCODE_F9": {
          "doc": "",
          "name": "SCANCODE_F9",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F9",
          "constexpr": true
        },
        "SCANCODE_F10": {
          "doc": "",
          "name": "SCANCODE_F10",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F10",
          "constexpr": true
        },
        "SCANCODE_F11": {
          "doc": "",
          "name": "SCANCODE_F11",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F11",
          "constexpr": true
        },
        "SCANCODE_F12": {
          "doc": "",
          "name": "SCANCODE_F12",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F12",
          "constexpr": true
        },
        "SCANCODE_PRINTSCREEN": {
          "doc": "",
          "name": "SCANCODE_PRINTSCREEN",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_PRINTSCREEN",
          "constexpr": true
        },
        "SCANCODE_SCROLLLOCK": {
          "doc": "",
          "name": "SCANCODE_SCROLLLOCK",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_SCROLLLOCK",
          "constexpr": true
        },
        "SCANCODE_PAUSE": {
          "doc": "",
          "name": "SCANCODE_PAUSE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_PAUSE",
          "constexpr": true
        },
        "SCANCODE_INSERT": {
          "doc": "insert on PC, help on some Mac keyboards (but does send code 73, not 117)",
          "name": "SCANCODE_INSERT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_INSERT",
          "constexpr": true
        },
        "SCANCODE_HOME": {
          "doc": "",
          "name": "SCANCODE_HOME",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_HOME",
          "constexpr": true
        },
        "SCANCODE_PAGEUP": {
          "doc": "",
          "name": "SCANCODE_PAGEUP",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_PAGEUP",
          "constexpr": true
        },
        "SCANCODE_DELETE": {
          "doc": "",
          "name": "SCANCODE_DELETE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_DELETE",
          "constexpr": true
        },
        "SCANCODE_END": {
          "doc": "",
          "name": "SCANCODE_END",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_END",
          "constexpr": true
        },
        "SCANCODE_PAGEDOWN": {
          "doc": "",
          "name": "SCANCODE_PAGEDOWN",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_PAGEDOWN",
          "constexpr": true
        },
        "SCANCODE_RIGHT": {
          "doc": "",
          "name": "SCANCODE_RIGHT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_RIGHT",
          "constexpr": true
        },
        "SCANCODE_LEFT": {
          "doc": "",
          "name": "SCANCODE_LEFT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_LEFT",
          "constexpr": true
        },
        "SCANCODE_DOWN": {
          "doc": "",
          "name": "SCANCODE_DOWN",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_DOWN",
          "constexpr": true
        },
        "SCANCODE_UP": {
          "doc": "",
          "name": "SCANCODE_UP",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_UP",
          "constexpr": true
        },
        "SCANCODE_NUMLOCKCLEAR": {
          "doc": "num lock on PC, clear on Mac keyboards",
          "name": "SCANCODE_NUMLOCKCLEAR",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_NUMLOCKCLEAR",
          "constexpr": true
        },
        "SCANCODE_KP_DIVIDE": {
          "doc": "",
          "name": "SCANCODE_KP_DIVIDE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_DIVIDE",
          "constexpr": true
        },
        "SCANCODE_KP_MULTIPLY": {
          "doc": "",
          "name": "SCANCODE_KP_MULTIPLY",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_MULTIPLY",
          "constexpr": true
        },
        "SCANCODE_KP_MINUS": {
          "doc": "",
          "name": "SCANCODE_KP_MINUS",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_MINUS",
          "constexpr": true
        },
        "SCANCODE_KP_PLUS": {
          "doc": "",
          "name": "SCANCODE_KP_PLUS",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_PLUS",
          "constexpr": true
        },
        "SCANCODE_KP_ENTER": {
          "doc": "",
          "name": "SCANCODE_KP_ENTER",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_ENTER",
          "constexpr": true
        },
        "SCANCODE_KP_1": {
          "doc": "",
          "name": "SCANCODE_KP_1",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_1",
          "constexpr": true
        },
        "SCANCODE_KP_2": {
          "doc": "",
          "name": "SCANCODE_KP_2",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_2",
          "constexpr": true
        },
        "SCANCODE_KP_3": {
          "doc": "",
          "name": "SCANCODE_KP_3",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_3",
          "constexpr": true
        },
        "SCANCODE_KP_4": {
          "doc": "",
          "name": "SCANCODE_KP_4",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_4",
          "constexpr": true
        },
        "SCANCODE_KP_5": {
          "doc": "",
          "name": "SCANCODE_KP_5",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_5",
          "constexpr": true
        },
        "SCANCODE_KP_6": {
          "doc": "",
          "name": "SCANCODE_KP_6",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_6",
          "constexpr": true
        },
        "SCANCODE_KP_7": {
          "doc": "",
          "name": "SCANCODE_KP_7",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_7",
          "constexpr": true
        },
        "SCANCODE_KP_8": {
          "doc": "",
          "name": "SCANCODE_KP_8",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_8",
          "constexpr": true
        },
        "SCANCODE_KP_9": {
          "doc": "",
          "name": "SCANCODE_KP_9",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_9",
          "constexpr": true
        },
        "SCANCODE_KP_0": {
          "doc": "",
          "name": "SCANCODE_KP_0",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_0",
          "constexpr": true
        },
        "SCANCODE_KP_PERIOD": {
          "doc": "",
          "name": "SCANCODE_KP_PERIOD",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_PERIOD",
          "constexpr": true
        },
        "SCANCODE_NONUSBACKSLASH": {
          "doc": "This is the additional key that ISO keyboards have over ANSI ones, located between left shift and Y.  Produces GRAVE ACCENT and TILDE in a US or UK Mac layout, REVERSE SOLIDUS (backslash) and VERTICAL LINE in a US or UK Windows layout, and LESS-THAN SIGN and GREATER-THAN SIGN in a Swiss German, German, or French layout.",
          "name": "SCANCODE_NONUSBACKSLASH",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_NONUSBACKSLASH",
          "constexpr": true
        },
        "SCANCODE_APPLICATION": {
          "doc": "windows contextual menu, compose",
          "name": "SCANCODE_APPLICATION",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_APPLICATION",
          "constexpr": true
        },
        "SCANCODE_POWER": {
          "doc": "The USB document says this is a status flag, not a physical key - but some Mac keyboards do have a power key.",
          "name": "SCANCODE_POWER",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_POWER",
          "constexpr": true
        },
        "SCANCODE_KP_EQUALS": {
          "doc": "",
          "name": "SCANCODE_KP_EQUALS",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_EQUALS",
          "constexpr": true
        },
        "SCANCODE_F13": {
          "doc": "",
          "name": "SCANCODE_F13",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F13",
          "constexpr": true
        },
        "SCANCODE_F14": {
          "doc": "",
          "name": "SCANCODE_F14",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F14",
          "constexpr": true
        },
        "SCANCODE_F15": {
          "doc": "",
          "name": "SCANCODE_F15",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F15",
          "constexpr": true
        },
        "SCANCODE_F16": {
          "doc": "",
          "name": "SCANCODE_F16",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F16",
          "constexpr": true
        },
        "SCANCODE_F17": {
          "doc": "",
          "name": "SCANCODE_F17",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F17",
          "constexpr": true
        },
        "SCANCODE_F18": {
          "doc": "",
          "name": "SCANCODE_F18",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F18",
          "constexpr": true
        },
        "SCANCODE_F19": {
          "doc": "",
          "name": "SCANCODE_F19",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F19",
          "constexpr": true
        },
        "SCANCODE_F20": {
          "doc": "",
          "name": "SCANCODE_F20",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F20",
          "constexpr": true
        },
        "SCANCODE_F21": {
          "doc": "",
          "name": "SCANCODE_F21",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F21",
          "constexpr": true
        },
        "SCANCODE_F22": {
          "doc": "",
          "name": "SCANCODE_F22",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F22",
          "constexpr": true
        },
        "SCANCODE_F23": {
          "doc": "",
          "name": "SCANCODE_F23",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F23",
          "constexpr": true
        },
        "SCANCODE_F24": {
          "doc": "",
          "name": "SCANCODE_F24",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_F24",
          "constexpr": true
        },
        "SCANCODE_EXECUTE": {
          "doc": "",
          "name": "SCANCODE_EXECUTE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_EXECUTE",
          "constexpr": true
        },
        "SCANCODE_HELP": {
          "doc": "AL Integrated Help Center.",
          "name": "SCANCODE_HELP",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_HELP",
          "constexpr": true
        },
        "SCANCODE_MENU": {
          "doc": "Menu (show menu)",
          "name": "SCANCODE_MENU",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_MENU",
          "constexpr": true
        },
        "SCANCODE_SELECT": {
          "doc": "",
          "name": "SCANCODE_SELECT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_SELECT",
          "constexpr": true
        },
        "SCANCODE_STOP": {
          "doc": "AC Stop.",
          "name": "SCANCODE_STOP",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_STOP",
          "constexpr": true
        },
        "SCANCODE_AGAIN": {
          "doc": "AC Redo/Repeat.",
          "name": "SCANCODE_AGAIN",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_AGAIN",
          "constexpr": true
        },
        "SCANCODE_UNDO": {
          "doc": "AC Undo.",
          "name": "SCANCODE_UNDO",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_UNDO",
          "constexpr": true
        },
        "SCANCODE_CUT": {
          "doc": "AC Cut.",
          "name": "SCANCODE_CUT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_CUT",
          "constexpr": true
        },
        "SCANCODE_COPY": {
          "doc": "AC Copy.",
          "name": "SCANCODE_COPY",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_COPY",
          "constexpr": true
        },
        "SCANCODE_PASTE": {
          "doc": "AC Paste.",
          "name": "SCANCODE_PASTE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_PASTE",
          "constexpr": true
        },
        "SCANCODE_FIND": {
          "doc": "AC Find.",
          "name": "SCANCODE_FIND",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_FIND",
          "constexpr": true
        },
        "SCANCODE_MUTE": {
          "doc": "",
          "name": "SCANCODE_MUTE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_MUTE",
          "constexpr": true
        },
        "SCANCODE_VOLUMEUP": {
          "doc": "",
          "name": "SCANCODE_VOLUMEUP",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_VOLUMEUP",
          "constexpr": true
        },
        "SCANCODE_VOLUMEDOWN": {
          "doc": "",
          "name": "SCANCODE_VOLUMEDOWN",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_VOLUMEDOWN",
          "constexpr": true
        },
        "SCANCODE_KP_COMMA": {
          "doc": "",
          "name": "SCANCODE_KP_COMMA",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_COMMA",
          "constexpr": true
        },
        "SCANCODE_KP_EQUALSAS400": {
          "doc": "",
          "name": "SCANCODE_KP_EQUALSAS400",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_EQUALSAS400",
          "constexpr": true
        },
        "SCANCODE_INTERNATIONAL1": {
          "doc": "used on Asian keyboards, see footnotes in USB doc",
          "name": "SCANCODE_INTERNATIONAL1",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_INTERNATIONAL1",
          "constexpr": true
        },
        "SCANCODE_INTERNATIONAL2": {
          "doc": "",
          "name": "SCANCODE_INTERNATIONAL2",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_INTERNATIONAL2",
          "constexpr": true
        },
        "SCANCODE_INTERNATIONAL3": {
          "doc": "Yen.",
          "name": "SCANCODE_INTERNATIONAL3",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_INTERNATIONAL3",
          "constexpr": true
        },
        "SCANCODE_INTERNATIONAL4": {
          "doc": "",
          "name": "SCANCODE_INTERNATIONAL4",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_INTERNATIONAL4",
          "constexpr": true
        },
        "SCANCODE_INTERNATIONAL5": {
          "doc": "",
          "name": "SCANCODE_INTERNATIONAL5",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_INTERNATIONAL5",
          "constexpr": true
        },
        "SCANCODE_INTERNATIONAL6": {
          "doc": "",
          "name": "SCANCODE_INTERNATIONAL6",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_INTERNATIONAL6",
          "constexpr": true
        },
        "SCANCODE_INTERNATIONAL7": {
          "doc": "",
          "name": "SCANCODE_INTERNATIONAL7",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_INTERNATIONAL7",
          "constexpr": true
        },
        "SCANCODE_INTERNATIONAL8": {
          "doc": "",
          "name": "SCANCODE_INTERNATIONAL8",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_INTERNATIONAL8",
          "constexpr": true
        },
        "SCANCODE_INTERNATIONAL9": {
          "doc": "",
          "name": "SCANCODE_INTERNATIONAL9",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_INTERNATIONAL9",
          "constexpr": true
        },
        "SCANCODE_LANG1": {
          "doc": "Hangul/English toggle.",
          "name": "SCANCODE_LANG1",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_LANG1",
          "constexpr": true
        },
        "SCANCODE_LANG2": {
          "doc": "Hanja conversion.",
          "name": "SCANCODE_LANG2",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_LANG2",
          "constexpr": true
        },
        "SCANCODE_LANG3": {
          "doc": "Katakana.",
          "name": "SCANCODE_LANG3",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_LANG3",
          "constexpr": true
        },
        "SCANCODE_LANG4": {
          "doc": "Hiragana.",
          "name": "SCANCODE_LANG4",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_LANG4",
          "constexpr": true
        },
        "SCANCODE_LANG5": {
          "doc": "Zenkaku/Hankaku.",
          "name": "SCANCODE_LANG5",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_LANG5",
          "constexpr": true
        },
        "SCANCODE_LANG6": {
          "doc": "reserved",
          "name": "SCANCODE_LANG6",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_LANG6",
          "constexpr": true
        },
        "SCANCODE_LANG7": {
          "doc": "reserved",
          "name": "SCANCODE_LANG7",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_LANG7",
          "constexpr": true
        },
        "SCANCODE_LANG8": {
          "doc": "reserved",
          "name": "SCANCODE_LANG8",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_LANG8",
          "constexpr": true
        },
        "SCANCODE_LANG9": {
          "doc": "reserved",
          "name": "SCANCODE_LANG9",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_LANG9",
          "constexpr": true
        },
        "SCANCODE_ALTERASE": {
          "doc": "Erase-Eaze.",
          "name": "SCANCODE_ALTERASE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_ALTERASE",
          "constexpr": true
        },
        "SCANCODE_SYSREQ": {
          "doc": "",
          "name": "SCANCODE_SYSREQ",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_SYSREQ",
          "constexpr": true
        },
        "SCANCODE_CANCEL": {
          "doc": "AC Cancel.",
          "name": "SCANCODE_CANCEL",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_CANCEL",
          "constexpr": true
        },
        "SCANCODE_CLEAR": {
          "doc": "",
          "name": "SCANCODE_CLEAR",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_CLEAR",
          "constexpr": true
        },
        "SCANCODE_PRIOR": {
          "doc": "",
          "name": "SCANCODE_PRIOR",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_PRIOR",
          "constexpr": true
        },
        "SCANCODE_RETURN2": {
          "doc": "",
          "name": "SCANCODE_RETURN2",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_RETURN2",
          "constexpr": true
        },
        "SCANCODE_SEPARATOR": {
          "doc": "",
          "name": "SCANCODE_SEPARATOR",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_SEPARATOR",
          "constexpr": true
        },
        "SCANCODE_OUT": {
          "doc": "",
          "name": "SCANCODE_OUT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_OUT",
          "constexpr": true
        },
        "SCANCODE_OPER": {
          "doc": "",
          "name": "SCANCODE_OPER",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_OPER",
          "constexpr": true
        },
        "SCANCODE_CLEARAGAIN": {
          "doc": "",
          "name": "SCANCODE_CLEARAGAIN",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_CLEARAGAIN",
          "constexpr": true
        },
        "SCANCODE_CRSEL": {
          "doc": "",
          "name": "SCANCODE_CRSEL",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_CRSEL",
          "constexpr": true
        },
        "SCANCODE_EXSEL": {
          "doc": "",
          "name": "SCANCODE_EXSEL",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_EXSEL",
          "constexpr": true
        },
        "SCANCODE_KP_00": {
          "doc": "",
          "name": "SCANCODE_KP_00",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_00",
          "constexpr": true
        },
        "SCANCODE_KP_000": {
          "doc": "",
          "name": "SCANCODE_KP_000",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_000",
          "constexpr": true
        },
        "SCANCODE_THOUSANDSSEPARATOR": {
          "doc": "",
          "name": "SCANCODE_THOUSANDSSEPARATOR",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_THOUSANDSSEPARATOR",
          "constexpr": true
        },
        "SCANCODE_DECIMALSEPARATOR": {
          "doc": "",
          "name": "SCANCODE_DECIMALSEPARATOR",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_DECIMALSEPARATOR",
          "constexpr": true
        },
        "SCANCODE_CURRENCYUNIT": {
          "doc": "",
          "name": "SCANCODE_CURRENCYUNIT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_CURRENCYUNIT",
          "constexpr": true
        },
        "SCANCODE_CURRENCYSUBUNIT": {
          "doc": "",
          "name": "SCANCODE_CURRENCYSUBUNIT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_CURRENCYSUBUNIT",
          "constexpr": true
        },
        "SCANCODE_KP_LEFTPAREN": {
          "doc": "",
          "name": "SCANCODE_KP_LEFTPAREN",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_LEFTPAREN",
          "constexpr": true
        },
        "SCANCODE_KP_RIGHTPAREN": {
          "doc": "",
          "name": "SCANCODE_KP_RIGHTPAREN",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_RIGHTPAREN",
          "constexpr": true
        },
        "SCANCODE_KP_LEFTBRACE": {
          "doc": "",
          "name": "SCANCODE_KP_LEFTBRACE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_LEFTBRACE",
          "constexpr": true
        },
        "SCANCODE_KP_RIGHTBRACE": {
          "doc": "",
          "name": "SCANCODE_KP_RIGHTBRACE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_RIGHTBRACE",
          "constexpr": true
        },
        "SCANCODE_KP_TAB": {
          "doc": "",
          "name": "SCANCODE_KP_TAB",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_TAB",
          "constexpr": true
        },
        "SCANCODE_KP_BACKSPACE": {
          "doc": "",
          "name": "SCANCODE_KP_BACKSPACE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_BACKSPACE",
          "constexpr": true
        },
        "SCANCODE_KP_A": {
          "doc": "",
          "name": "SCANCODE_KP_A",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_A",
          "constexpr": true
        },
        "SCANCODE_KP_B": {
          "doc": "",
          "name": "SCANCODE_KP_B",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_B",
          "constexpr": true
        },
        "SCANCODE_KP_C": {
          "doc": "",
          "name": "SCANCODE_KP_C",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_C",
          "constexpr": true
        },
        "SCANCODE_KP_D": {
          "doc": "",
          "name": "SCANCODE_KP_D",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_D",
          "constexpr": true
        },
        "SCANCODE_KP_E": {
          "doc": "",
          "name": "SCANCODE_KP_E",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_E",
          "constexpr": true
        },
        "SCANCODE_KP_F": {
          "doc": "",
          "name": "SCANCODE_KP_F",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_F",
          "constexpr": true
        },
        "SCANCODE_KP_XOR": {
          "doc": "",
          "name": "SCANCODE_KP_XOR",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_XOR",
          "constexpr": true
        },
        "SCANCODE_KP_POWER": {
          "doc": "",
          "name": "SCANCODE_KP_POWER",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_POWER",
          "constexpr": true
        },
        "SCANCODE_KP_PERCENT": {
          "doc": "",
          "name": "SCANCODE_KP_PERCENT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_PERCENT",
          "constexpr": true
        },
        "SCANCODE_KP_LESS": {
          "doc": "",
          "name": "SCANCODE_KP_LESS",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_LESS",
          "constexpr": true
        },
        "SCANCODE_KP_GREATER": {
          "doc": "",
          "name": "SCANCODE_KP_GREATER",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_GREATER",
          "constexpr": true
        },
        "SCANCODE_KP_AMPERSAND": {
          "doc": "",
          "name": "SCANCODE_KP_AMPERSAND",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_AMPERSAND",
          "constexpr": true
        },
        "SCANCODE_KP_DBLAMPERSAND": {
          "doc": "",
          "name": "SCANCODE_KP_DBLAMPERSAND",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_DBLAMPERSAND",
          "constexpr": true
        },
        "SCANCODE_KP_VERTICALBAR": {
          "doc": "",
          "name": "SCANCODE_KP_VERTICALBAR",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_VERTICALBAR",
          "constexpr": true
        },
        "SCANCODE_KP_DBLVERTICALBAR": {
          "doc": "",
          "name": "SCANCODE_KP_DBLVERTICALBAR",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_DBLVERTICALBAR",
          "constexpr": true
        },
        "SCANCODE_KP_COLON": {
          "doc": "",
          "name": "SCANCODE_KP_COLON",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_COLON",
          "constexpr": true
        },
        "SCANCODE_KP_HASH": {
          "doc": "",
          "name": "SCANCODE_KP_HASH",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_HASH",
          "constexpr": true
        },
        "SCANCODE_KP_SPACE": {
          "doc": "",
          "name": "SCANCODE_KP_SPACE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_SPACE",
          "constexpr": true
        },
        "SCANCODE_KP_AT": {
          "doc": "",
          "name": "SCANCODE_KP_AT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_AT",
          "constexpr": true
        },
        "SCANCODE_KP_EXCLAM": {
          "doc": "",
          "name": "SCANCODE_KP_EXCLAM",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_EXCLAM",
          "constexpr": true
        },
        "SCANCODE_KP_MEMSTORE": {
          "doc": "",
          "name": "SCANCODE_KP_MEMSTORE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_MEMSTORE",
          "constexpr": true
        },
        "SCANCODE_KP_MEMRECALL": {
          "doc": "",
          "name": "SCANCODE_KP_MEMRECALL",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_MEMRECALL",
          "constexpr": true
        },
        "SCANCODE_KP_MEMCLEAR": {
          "doc": "",
          "name": "SCANCODE_KP_MEMCLEAR",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_MEMCLEAR",
          "constexpr": true
        },
        "SCANCODE_KP_MEMADD": {
          "doc": "",
          "name": "SCANCODE_KP_MEMADD",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_MEMADD",
          "constexpr": true
        },
        "SCANCODE_KP_MEMSUBTRACT": {
          "doc": "",
          "name": "SCANCODE_KP_MEMSUBTRACT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_MEMSUBTRACT",
          "constexpr": true
        },
        "SCANCODE_KP_MEMMULTIPLY": {
          "doc": "",
          "name": "SCANCODE_KP_MEMMULTIPLY",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_MEMMULTIPLY",
          "constexpr": true
        },
        "SCANCODE_KP_MEMDIVIDE": {
          "doc": "",
          "name": "SCANCODE_KP_MEMDIVIDE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_MEMDIVIDE",
          "constexpr": true
        },
        "SCANCODE_KP_PLUSMINUS": {
          "doc": "",
          "name": "SCANCODE_KP_PLUSMINUS",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_PLUSMINUS",
          "constexpr": true
        },
        "SCANCODE_KP_CLEAR": {
          "doc": "",
          "name": "SCANCODE_KP_CLEAR",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_CLEAR",
          "constexpr": true
        },
        "SCANCODE_KP_CLEARENTRY": {
          "doc": "",
          "name": "SCANCODE_KP_CLEARENTRY",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_CLEARENTRY",
          "constexpr": true
        },
        "SCANCODE_KP_BINARY": {
          "doc": "",
          "name": "SCANCODE_KP_BINARY",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_BINARY",
          "constexpr": true
        },
        "SCANCODE_KP_OCTAL": {
          "doc": "",
          "name": "SCANCODE_KP_OCTAL",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_OCTAL",
          "constexpr": true
        },
        "SCANCODE_KP_DECIMAL": {
          "doc": "",
          "name": "SCANCODE_KP_DECIMAL",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_DECIMAL",
          "constexpr": true
        },
        "SCANCODE_KP_HEXADECIMAL": {
          "doc": "",
          "name": "SCANCODE_KP_HEXADECIMAL",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_KP_HEXADECIMAL",
          "constexpr": true
        },
        "SCANCODE_LCTRL": {
          "doc": "",
          "name": "SCANCODE_LCTRL",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_LCTRL",
          "constexpr": true
        },
        "SCANCODE_LSHIFT": {
          "doc": "",
          "name": "SCANCODE_LSHIFT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_LSHIFT",
          "constexpr": true
        },
        "SCANCODE_LALT": {
          "doc": "alt, option",
          "name": "SCANCODE_LALT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_LALT",
          "constexpr": true
        },
        "SCANCODE_LGUI": {
          "doc": "windows, command (apple), meta",
          "name": "SCANCODE_LGUI",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_LGUI",
          "constexpr": true
        },
        "SCANCODE_RCTRL": {
          "doc": "",
          "name": "SCANCODE_RCTRL",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_RCTRL",
          "constexpr": true
        },
        "SCANCODE_RSHIFT": {
          "doc": "",
          "name": "SCANCODE_RSHIFT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_RSHIFT",
          "constexpr": true
        },
        "SCANCODE_RALT": {
          "doc": "alt gr, option",
          "name": "SCANCODE_RALT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_RALT",
          "constexpr": true
        },
        "SCANCODE_RGUI": {
          "doc": "windows, command (apple), meta",
          "name": "SCANCODE_RGUI",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_RGUI",
          "constexpr": true
        },
        "SCANCODE_MODE": {
          "doc": "I'm not sure if this is really not covered by any of the above, but since there's a special KMOD_MODE for it I'm adding it here.",
          "name": "SCANCODE_MODE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_MODE",
          "constexpr": true
        },
        "SCANCODE_SLEEP": {
          "doc": "Sleep.",
          "name": "SCANCODE_SLEEP",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_SLEEP",
          "constexpr": true
        },
        "SCANCODE_WAKE": {
          "doc": "Wake.",
          "name": "SCANCODE_WAKE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_WAKE",
          "constexpr": true
        },
        "SCANCODE_CHANNEL_INCREMENT": {
          "doc": "Channel Increment.",
          "name": "SCANCODE_CHANNEL_INCREMENT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_CHANNEL_INCREMENT",
          "constexpr": true
        },
        "SCANCODE_CHANNEL_DECREMENT": {
          "doc": "Channel Decrement.",
          "name": "SCANCODE_CHANNEL_DECREMENT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_CHANNEL_DECREMENT",
          "constexpr": true
        },
        "SCANCODE_MEDIA_PLAY": {
          "doc": "Play.",
          "name": "SCANCODE_MEDIA_PLAY",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_MEDIA_PLAY",
          "constexpr": true
        },
        "SCANCODE_MEDIA_PAUSE": {
          "doc": "Pause.",
          "name": "SCANCODE_MEDIA_PAUSE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_MEDIA_PAUSE",
          "constexpr": true
        },
        "SCANCODE_MEDIA_RECORD": {
          "doc": "Record.",
          "name": "SCANCODE_MEDIA_RECORD",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_MEDIA_RECORD",
          "constexpr": true
        },
        "SCANCODE_MEDIA_FAST_FORWARD": {
          "doc": "Fast Forward.",
          "name": "SCANCODE_MEDIA_FAST_FORWARD",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_MEDIA_FAST_FORWARD",
          "constexpr": true
        },
        "SCANCODE_MEDIA_REWIND": {
          "doc": "Rewind.",
          "name": "SCANCODE_MEDIA_REWIND",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_MEDIA_REWIND",
          "constexpr": true
        },
        "SCANCODE_MEDIA_NEXT_TRACK": {
          "doc": "Next Track.",
          "name": "SCANCODE_MEDIA_NEXT_TRACK",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_MEDIA_NEXT_TRACK",
          "constexpr": true
        },
        "SCANCODE_MEDIA_PREVIOUS_TRACK": {
          "doc": "Previous Track.",
          "name": "SCANCODE_MEDIA_PREVIOUS_TRACK",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_MEDIA_PREVIOUS_TRACK",
          "constexpr": true
        },
        "SCANCODE_MEDIA_STOP": {
          "doc": "Stop.",
          "name": "SCANCODE_MEDIA_STOP",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_MEDIA_STOP",
          "constexpr": true
        },
        "SCANCODE_MEDIA_EJECT": {
          "doc": "Eject.",
          "name": "SCANCODE_MEDIA_EJECT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_MEDIA_EJECT",
          "constexpr": true
        },
        "SCANCODE_MEDIA_PLAY_PAUSE": {
          "doc": "Play / Pause.",
          "name": "SCANCODE_MEDIA_PLAY_PAUSE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_MEDIA_PLAY_PAUSE",
          "constexpr": true
        },
        "SCANCODE_MEDIA_SELECT": {
          "doc": "",
          "name": "SCANCODE_MEDIA_SELECT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_MEDIA_SELECT",
          "constexpr": true
        },
        "SCANCODE_AC_NEW": {
          "doc": "AC New.",
          "name": "SCANCODE_AC_NEW",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_AC_NEW",
          "constexpr": true
        },
        "SCANCODE_AC_OPEN": {
          "doc": "AC Open.",
          "name": "SCANCODE_AC_OPEN",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_AC_OPEN",
          "constexpr": true
        },
        "SCANCODE_AC_CLOSE": {
          "doc": "AC Close.",
          "name": "SCANCODE_AC_CLOSE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_AC_CLOSE",
          "constexpr": true
        },
        "SCANCODE_AC_EXIT": {
          "doc": "AC Exit.",
          "name": "SCANCODE_AC_EXIT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_AC_EXIT",
          "constexpr": true
        },
        "SCANCODE_AC_SAVE": {
          "doc": "AC Save.",
          "name": "SCANCODE_AC_SAVE",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_AC_SAVE",
          "constexpr": true
        },
        "SCANCODE_AC_PRINT": {
          "doc": "AC Print.",
          "name": "SCANCODE_AC_PRINT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_AC_PRINT",
          "constexpr": true
        },
        "SCANCODE_AC_PROPERTIES": {
          "doc": "AC Properties.",
          "name": "SCANCODE_AC_PROPERTIES",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_AC_PROPERTIES",
          "constexpr": true
        },
        "SCANCODE_AC_SEARCH": {
          "doc": "AC Search.",
          "name": "SCANCODE_AC_SEARCH",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_AC_SEARCH",
          "constexpr": true
        },
        "SCANCODE_AC_HOME": {
          "doc": "AC Home.",
          "name": "SCANCODE_AC_HOME",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_AC_HOME",
          "constexpr": true
        },
        "SCANCODE_AC_BACK": {
          "doc": "AC Back.",
          "name": "SCANCODE_AC_BACK",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_AC_BACK",
          "constexpr": true
        },
        "SCANCODE_AC_FORWARD": {
          "doc": "AC Forward.",
          "name": "SCANCODE_AC_FORWARD",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_AC_FORWARD",
          "constexpr": true
        },
        "SCANCODE_AC_STOP": {
          "doc": "AC Stop.",
          "name": "SCANCODE_AC_STOP",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_AC_STOP",
          "constexpr": true
        },
        "SCANCODE_AC_REFRESH": {
          "doc": "AC Refresh.",
          "name": "SCANCODE_AC_REFRESH",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_AC_REFRESH",
          "constexpr": true
        },
        "SCANCODE_AC_BOOKMARKS": {
          "doc": "AC Bookmarks.",
          "name": "SCANCODE_AC_BOOKMARKS",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_AC_BOOKMARKS",
          "constexpr": true
        },
        "SCANCODE_SOFTLEFT": {
          "doc": "Usually situated below the display on phones and used as a multi-function feature key for selecting a software defined function shown on the bottom left of the display.",
          "name": "SCANCODE_SOFTLEFT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_SOFTLEFT",
          "constexpr": true
        },
        "SCANCODE_SOFTRIGHT": {
          "doc": "Usually situated below the display on phones and used as a multi-function feature key for selecting a software defined function shown on the bottom right of the display.",
          "name": "SCANCODE_SOFTRIGHT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_SOFTRIGHT",
          "constexpr": true
        },
        "SCANCODE_CALL": {
          "doc": "Used for accepting phone calls.",
          "name": "SCANCODE_CALL",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_CALL",
          "constexpr": true
        },
        "SCANCODE_ENDCALL": {
          "doc": "Used for rejecting phone calls.",
          "name": "SCANCODE_ENDCALL",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_ENDCALL",
          "constexpr": true
        },
        "SCANCODE_RESERVED": {
          "doc": "400-500 reserved for dynamic keycodes",
          "name": "SCANCODE_RESERVED",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_RESERVED",
          "constexpr": true
        },
        "SCANCODE_COUNT": {
          "doc": "not a key, just marks the number of scancodes for array bounds",
          "name": "SCANCODE_COUNT",
          "kind": "var",
          "type": "Scancode",
          "sourceName": "SDL_SCANCODE_COUNT",
          "constexpr": true
        }
      }
    },
    "SDL3pp_keycode.h": {
      "name": "SDL3pp_keycode.h",
      "doc": "@defgroup CategoryKeycode Category Keycode\n\nDefines constants which identify keyboard keys and modifiers.\n\nPlease refer to the Best Keyboard Practices document for details on what\nthis information means and how best to use it.\n\nhttps://wiki.libsdl.org/SDL3/BestKeyboardPractices",
      "entries": {
        "Keymod": {
          "doc": "Valid key modifiers (possibly OR'd together).\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "Keymod",
          "kind": "alias",
          "type": "SDL_Keymod",
          "sourceName": "SDL_Keymod"
        },
        "KMOD_NONE": {
          "doc": "no modifier is applicable.",
          "name": "KMOD_NONE",
          "kind": "var",
          "value": "0x0000u",
          "sourceName": "SDL_KMOD_NONE",
          "constexpr": true,
          "type": "Keymod"
        },
        "KMOD_LSHIFT": {
          "doc": "the left Shift key is down.",
          "name": "KMOD_LSHIFT",
          "kind": "var",
          "value": "0x0001u",
          "sourceName": "SDL_KMOD_LSHIFT",
          "constexpr": true,
          "type": "Keymod"
        },
        "KMOD_RSHIFT": {
          "doc": "the right Shift key is down.",
          "name": "KMOD_RSHIFT",
          "kind": "var",
          "value": "0x0002u",
          "sourceName": "SDL_KMOD_RSHIFT",
          "constexpr": true,
          "type": "Keymod"
        },
        "KMOD_LEVEL5": {
          "doc": "the Level 5 Shift key is down.",
          "name": "KMOD_LEVEL5",
          "kind": "var",
          "value": "0x0004u",
          "sourceName": "SDL_KMOD_LEVEL5",
          "constexpr": true,
          "type": "Keymod"
        },
        "KMOD_LCTRL": {
          "doc": "the left Ctrl (Control) key is down.",
          "name": "KMOD_LCTRL",
          "kind": "var",
          "value": "0x0040u",
          "sourceName": "SDL_KMOD_LCTRL",
          "constexpr": true,
          "type": "Keymod"
        },
        "KMOD_RCTRL": {
          "doc": "the right Ctrl (Control) key is down.",
          "name": "KMOD_RCTRL",
          "kind": "var",
          "value": "0x0080u",
          "sourceName": "SDL_KMOD_RCTRL",
          "constexpr": true,
          "type": "Keymod"
        },
        "KMOD_LALT": {
          "doc": "the left Alt key is down.",
          "name": "KMOD_LALT",
          "kind": "var",
          "value": "0x0100u",
          "sourceName": "SDL_KMOD_LALT",
          "constexpr": true,
          "type": "Keymod"
        },
        "KMOD_RALT": {
          "doc": "the right Alt key is down.",
          "name": "KMOD_RALT",
          "kind": "var",
          "value": "0x0200u",
          "sourceName": "SDL_KMOD_RALT",
          "constexpr": true,
          "type": "Keymod"
        },
        "KMOD_LGUI": {
          "doc": "the left GUI key (often the Windows key) is down.",
          "name": "KMOD_LGUI",
          "kind": "var",
          "value": "0x0400u",
          "sourceName": "SDL_KMOD_LGUI",
          "constexpr": true,
          "type": "Keymod"
        },
        "KMOD_RGUI": {
          "doc": "the right GUI key (often the Windows key) is down.",
          "name": "KMOD_RGUI",
          "kind": "var",
          "value": "0x0800u",
          "sourceName": "SDL_KMOD_RGUI",
          "constexpr": true,
          "type": "Keymod"
        },
        "KMOD_NUM": {
          "doc": "the Num Lock key (may be located on an extended keypad) is down.",
          "name": "KMOD_NUM",
          "kind": "var",
          "value": "0x1000u",
          "sourceName": "SDL_KMOD_NUM",
          "constexpr": true,
          "type": "Keymod"
        },
        "KMOD_CAPS": {
          "doc": "the Caps Lock key is down.",
          "name": "KMOD_CAPS",
          "kind": "var",
          "value": "0x2000u",
          "sourceName": "SDL_KMOD_CAPS",
          "constexpr": true,
          "type": "Keymod"
        },
        "KMOD_MODE": {
          "doc": "the !AltGr key is down.",
          "name": "KMOD_MODE",
          "kind": "var",
          "value": "0x4000u",
          "sourceName": "SDL_KMOD_MODE",
          "constexpr": true,
          "type": "Keymod"
        },
        "KMOD_SCROLL": {
          "doc": "the Scroll Lock key is down.",
          "name": "KMOD_SCROLL",
          "kind": "var",
          "value": "0x8000u",
          "sourceName": "SDL_KMOD_SCROLL",
          "constexpr": true,
          "type": "Keymod"
        },
        "KMOD_CTRL": {
          "doc": "Any Ctrl key is down.",
          "name": "KMOD_CTRL",
          "kind": "var",
          "value": "(SDL_KMOD_LCTRL | SDL_KMOD_RCTRL)",
          "sourceName": "SDL_KMOD_CTRL",
          "constexpr": true,
          "type": "Keymod"
        },
        "KMOD_SHIFT": {
          "doc": "Any Shift key is down.",
          "name": "KMOD_SHIFT",
          "kind": "var",
          "value": "(SDL_KMOD_LSHIFT | SDL_KMOD_RSHIFT)",
          "sourceName": "SDL_KMOD_SHIFT",
          "constexpr": true,
          "type": "Keymod"
        },
        "KMOD_ALT": {
          "doc": "Any Alt key is down.",
          "name": "KMOD_ALT",
          "kind": "var",
          "value": "(SDL_KMOD_LALT | SDL_KMOD_RALT)",
          "sourceName": "SDL_KMOD_ALT",
          "constexpr": true,
          "type": "Keymod"
        },
        "KMOD_GUI": {
          "doc": "Any GUI key is down.",
          "name": "KMOD_GUI",
          "kind": "var",
          "value": "(SDL_KMOD_LGUI | SDL_KMOD_RGUI)",
          "sourceName": "SDL_KMOD_GUI",
          "constexpr": true,
          "type": "Keymod"
        },
        "Keycode": {
          "doc": "The SDL virtual key representation.\n\nValues of this type are used to represent keyboard keys using the current\nlayout of the keyboard. These values include Unicode values representing\nthe unmodified character that would be generated by pressing the key, or an\n`SDLK_*` constant for those keys that do not generate characters.\n\nA special exception is the number keys at the top of the keyboard which map\nto SDLK_0...SDLK_9 on AZERTY layouts.\n\nKeys with the `SDLK_EXTENDED_MASK` bit set do not map to a scancode or\nunicode code point.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "Keycode",
          "kind": "struct",
          "type": "",
          "sourceName": "SDL_Keycode",
          "entries": {
            "m_keycode": {
              "kind": "var",
              "name": "m_keycode",
              "type": "SDL_Keycode",
              "doc": ""
            },
            "Keycode": [
              {
                "kind": "function",
                "name": "Keycode",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "SDL_Keycode",
                    "name": "keycode",
                    "default": "{}"
                  }
                ],
                "doc": "Wraps Keycode.\n\n@param keycode the value to be wrapped"
              },
              {
                "kind": "function",
                "type": "",
                "explicit": true,
                "parameters": [
                  {
                    "type": "Scancode",
                    "name": "scancode"
                  },
                  {
                    "type": "Keymod",
                    "name": "keymodstate",
                    "default": "0"
                  },
                  {
                    "type": "bool",
                    "name": "key_event",
                    "default": "false"
                  }
                ],
                "name": "Keycode",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "",
                "explicit": true,
                "parameters": [
                  {
                    "type": "StringParam",
                    "name": "name"
                  }
                ],
                "name": "Keycode",
                "doc": ""
              }
            ],
            "operator<=>": {
              "kind": "function",
              "name": "operator<=>",
              "type": "auto",
              "constexpr": true,
              "immutable": true,
              "parameters": [
                {
                  "type": "const Keycode &",
                  "name": "other"
                }
              ],
              "doc": ""
            },
            "operator SDL_Keycode": {
              "kind": "function",
              "name": "operator SDL_Keycode",
              "type": "",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Unwraps to the underlying Keycode.\n\n@returns the underlying Keycode."
            },
            "operator bool": {
              "kind": "function",
              "name": "operator bool",
              "type": "",
              "constexpr": true,
              "explicit": true,
              "immutable": true,
              "parameters": [],
              "doc": "Check if valid.\n\n@returns True if valid state, false otherwise."
            },
            "GetName": {
              "kind": "function",
              "type": "const char *",
              "immutable": true,
              "parameters": [],
              "name": "GetName",
              "doc": ""
            },
            "GetScancode": {
              "kind": "function",
              "type": "Scancode",
              "immutable": true,
              "parameters": [
                {
                  "type": "Keymod *",
                  "name": "keymodstate",
                  "default": "nullptr"
                }
              ],
              "name": "GetScancode",
              "doc": ""
            },
            "IsExtended": {
              "kind": "function",
              "name": "IsExtended",
              "type": "bool",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": ""
            },
            "IsScancode": {
              "kind": "function",
              "name": "IsScancode",
              "type": "bool",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": ""
            }
          }
        },
        "KEYCODE_EXTENDED_MASK": {
          "doc": "",
          "name": "KEYCODE_EXTENDED_MASK",
          "kind": "var",
          "value": "(1u << 29)",
          "sourceName": "SDLK_EXTENDED_MASK",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_SCANCODE_MASK": {
          "doc": "",
          "name": "KEYCODE_SCANCODE_MASK",
          "kind": "var",
          "value": "(1u << 30)",
          "sourceName": "SDLK_SCANCODE_MASK",
          "constexpr": true,
          "type": "Keycode"
        },
        "ScancodeToKeycode": {
          "doc": "",
          "name": "ScancodeToKeycode",
          "kind": "function",
          "parameters": [
            {
              "type": "Scancode",
              "name": "x"
            }
          ],
          "value": "(X | SDLK_SCANCODE_MASK)",
          "sourceName": "SDL_SCANCODE_TO_KEYCODE",
          "type": "Keycode",
          "constexpr": true
        },
        "KEYCODE_UNKNOWN": {
          "doc": "0",
          "name": "KEYCODE_UNKNOWN",
          "kind": "var",
          "value": "0x00000000u",
          "sourceName": "SDLK_UNKNOWN",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_RETURN": {
          "doc": "'@r'",
          "name": "KEYCODE_RETURN",
          "kind": "var",
          "value": "0x0000000du",
          "sourceName": "SDLK_RETURN",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_ESCAPE": {
          "doc": "'@x1B'",
          "name": "KEYCODE_ESCAPE",
          "kind": "var",
          "value": "0x0000001bu",
          "sourceName": "SDLK_ESCAPE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_BACKSPACE": {
          "doc": "'@b'",
          "name": "KEYCODE_BACKSPACE",
          "kind": "var",
          "value": "0x00000008u",
          "sourceName": "SDLK_BACKSPACE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_TAB": {
          "doc": "'@t'",
          "name": "KEYCODE_TAB",
          "kind": "var",
          "value": "0x00000009u",
          "sourceName": "SDLK_TAB",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_SPACE": {
          "doc": "' '",
          "name": "KEYCODE_SPACE",
          "kind": "var",
          "value": "0x00000020u",
          "sourceName": "SDLK_SPACE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_EXCLAIM": {
          "doc": "'!'",
          "name": "KEYCODE_EXCLAIM",
          "kind": "var",
          "value": "0x00000021u",
          "sourceName": "SDLK_EXCLAIM",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_DBLAPOSTROPHE": {
          "doc": "'\"'",
          "name": "KEYCODE_DBLAPOSTROPHE",
          "kind": "var",
          "value": "0x00000022u",
          "sourceName": "SDLK_DBLAPOSTROPHE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_HASH": {
          "doc": "'#'",
          "name": "KEYCODE_HASH",
          "kind": "var",
          "value": "0x00000023u",
          "sourceName": "SDLK_HASH",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_DOLLAR": {
          "doc": "'$'",
          "name": "KEYCODE_DOLLAR",
          "kind": "var",
          "value": "0x00000024u",
          "sourceName": "SDLK_DOLLAR",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_PERCENT": {
          "doc": "'%'",
          "name": "KEYCODE_PERCENT",
          "kind": "var",
          "value": "0x00000025u",
          "sourceName": "SDLK_PERCENT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_AMPERSAND": {
          "doc": "'&'",
          "name": "KEYCODE_AMPERSAND",
          "kind": "var",
          "value": "0x00000026u",
          "sourceName": "SDLK_AMPERSAND",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_APOSTROPHE": {
          "doc": "'\\''",
          "name": "KEYCODE_APOSTROPHE",
          "kind": "var",
          "value": "0x00000027u",
          "sourceName": "SDLK_APOSTROPHE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_LEFTPAREN": {
          "doc": "'('",
          "name": "KEYCODE_LEFTPAREN",
          "kind": "var",
          "value": "0x00000028u",
          "sourceName": "SDLK_LEFTPAREN",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_RIGHTPAREN": {
          "doc": "')'",
          "name": "KEYCODE_RIGHTPAREN",
          "kind": "var",
          "value": "0x00000029u",
          "sourceName": "SDLK_RIGHTPAREN",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_ASTERISK": {
          "doc": "'*'",
          "name": "KEYCODE_ASTERISK",
          "kind": "var",
          "value": "0x0000002au",
          "sourceName": "SDLK_ASTERISK",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_PLUS": {
          "doc": "'+'",
          "name": "KEYCODE_PLUS",
          "kind": "var",
          "value": "0x0000002bu",
          "sourceName": "SDLK_PLUS",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_COMMA": {
          "doc": "','",
          "name": "KEYCODE_COMMA",
          "kind": "var",
          "value": "0x0000002cu",
          "sourceName": "SDLK_COMMA",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_MINUS": {
          "doc": "'-'",
          "name": "KEYCODE_MINUS",
          "kind": "var",
          "value": "0x0000002du",
          "sourceName": "SDLK_MINUS",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_PERIOD": {
          "doc": "'.'",
          "name": "KEYCODE_PERIOD",
          "kind": "var",
          "value": "0x0000002eu",
          "sourceName": "SDLK_PERIOD",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_SLASH": {
          "doc": "'/'",
          "name": "KEYCODE_SLASH",
          "kind": "var",
          "value": "0x0000002fu",
          "sourceName": "SDLK_SLASH",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_0": {
          "doc": "'0'",
          "name": "KEYCODE_0",
          "kind": "var",
          "value": "0x00000030u",
          "sourceName": "SDLK_0",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_1": {
          "doc": "'1'",
          "name": "KEYCODE_1",
          "kind": "var",
          "value": "0x00000031u",
          "sourceName": "SDLK_1",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_2": {
          "doc": "'2'",
          "name": "KEYCODE_2",
          "kind": "var",
          "value": "0x00000032u",
          "sourceName": "SDLK_2",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_3": {
          "doc": "'3'",
          "name": "KEYCODE_3",
          "kind": "var",
          "value": "0x00000033u",
          "sourceName": "SDLK_3",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_4": {
          "doc": "'4'",
          "name": "KEYCODE_4",
          "kind": "var",
          "value": "0x00000034u",
          "sourceName": "SDLK_4",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_5": {
          "doc": "'5'",
          "name": "KEYCODE_5",
          "kind": "var",
          "value": "0x00000035u",
          "sourceName": "SDLK_5",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_6": {
          "doc": "'6'",
          "name": "KEYCODE_6",
          "kind": "var",
          "value": "0x00000036u",
          "sourceName": "SDLK_6",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_7": {
          "doc": "'7'",
          "name": "KEYCODE_7",
          "kind": "var",
          "value": "0x00000037u",
          "sourceName": "SDLK_7",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_8": {
          "doc": "'8'",
          "name": "KEYCODE_8",
          "kind": "var",
          "value": "0x00000038u",
          "sourceName": "SDLK_8",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_9": {
          "doc": "'9'",
          "name": "KEYCODE_9",
          "kind": "var",
          "value": "0x00000039u",
          "sourceName": "SDLK_9",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_COLON": {
          "doc": "':'",
          "name": "KEYCODE_COLON",
          "kind": "var",
          "value": "0x0000003au",
          "sourceName": "SDLK_COLON",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_SEMICOLON": {
          "doc": "';'",
          "name": "KEYCODE_SEMICOLON",
          "kind": "var",
          "value": "0x0000003bu",
          "sourceName": "SDLK_SEMICOLON",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_LESS": {
          "doc": "'<'",
          "name": "KEYCODE_LESS",
          "kind": "var",
          "value": "0x0000003cu",
          "sourceName": "SDLK_LESS",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_EQUALS": {
          "doc": "'='",
          "name": "KEYCODE_EQUALS",
          "kind": "var",
          "value": "0x0000003du",
          "sourceName": "SDLK_EQUALS",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_GREATER": {
          "doc": "'>'",
          "name": "KEYCODE_GREATER",
          "kind": "var",
          "value": "0x0000003eu",
          "sourceName": "SDLK_GREATER",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_QUESTION": {
          "doc": "'?'",
          "name": "KEYCODE_QUESTION",
          "kind": "var",
          "value": "0x0000003fu",
          "sourceName": "SDLK_QUESTION",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_AT": {
          "doc": "'@'",
          "name": "KEYCODE_AT",
          "kind": "var",
          "value": "0x00000040u",
          "sourceName": "SDLK_AT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_LEFTBRACKET": {
          "doc": "'['",
          "name": "KEYCODE_LEFTBRACKET",
          "kind": "var",
          "value": "0x0000005bu",
          "sourceName": "SDLK_LEFTBRACKET",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_BACKSLASH": {
          "doc": "'\\\\'",
          "name": "KEYCODE_BACKSLASH",
          "kind": "var",
          "value": "0x0000005cu",
          "sourceName": "SDLK_BACKSLASH",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_RIGHTBRACKET": {
          "doc": "']'",
          "name": "KEYCODE_RIGHTBRACKET",
          "kind": "var",
          "value": "0x0000005du",
          "sourceName": "SDLK_RIGHTBRACKET",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_CARET": {
          "doc": "'^'",
          "name": "KEYCODE_CARET",
          "kind": "var",
          "value": "0x0000005eu",
          "sourceName": "SDLK_CARET",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_UNDERSCORE": {
          "doc": "'_'",
          "name": "KEYCODE_UNDERSCORE",
          "kind": "var",
          "value": "0x0000005fu",
          "sourceName": "SDLK_UNDERSCORE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_GRAVE": {
          "doc": "'`'",
          "name": "KEYCODE_GRAVE",
          "kind": "var",
          "value": "0x00000060u",
          "sourceName": "SDLK_GRAVE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_A": {
          "doc": "'a'",
          "name": "KEYCODE_A",
          "kind": "var",
          "value": "0x00000061u",
          "sourceName": "SDLK_A",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_B": {
          "doc": "'b'",
          "name": "KEYCODE_B",
          "kind": "var",
          "value": "0x00000062u",
          "sourceName": "SDLK_B",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_C": {
          "doc": "'c'",
          "name": "KEYCODE_C",
          "kind": "var",
          "value": "0x00000063u",
          "sourceName": "SDLK_C",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_D": {
          "doc": "'d'",
          "name": "KEYCODE_D",
          "kind": "var",
          "value": "0x00000064u",
          "sourceName": "SDLK_D",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_E": {
          "doc": "'e'",
          "name": "KEYCODE_E",
          "kind": "var",
          "value": "0x00000065u",
          "sourceName": "SDLK_E",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F": {
          "doc": "'f'",
          "name": "KEYCODE_F",
          "kind": "var",
          "value": "0x00000066u",
          "sourceName": "SDLK_F",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_G": {
          "doc": "'g'",
          "name": "KEYCODE_G",
          "kind": "var",
          "value": "0x00000067u",
          "sourceName": "SDLK_G",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_H": {
          "doc": "'h'",
          "name": "KEYCODE_H",
          "kind": "var",
          "value": "0x00000068u",
          "sourceName": "SDLK_H",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_I": {
          "doc": "'i'",
          "name": "KEYCODE_I",
          "kind": "var",
          "value": "0x00000069u",
          "sourceName": "SDLK_I",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_J": {
          "doc": "'j'",
          "name": "KEYCODE_J",
          "kind": "var",
          "value": "0x0000006au",
          "sourceName": "SDLK_J",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_K": {
          "doc": "'k'",
          "name": "KEYCODE_K",
          "kind": "var",
          "value": "0x0000006bu",
          "sourceName": "SDLK_K",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_L": {
          "doc": "'l'",
          "name": "KEYCODE_L",
          "kind": "var",
          "value": "0x0000006cu",
          "sourceName": "SDLK_L",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_M": {
          "doc": "'m'",
          "name": "KEYCODE_M",
          "kind": "var",
          "value": "0x0000006du",
          "sourceName": "SDLK_M",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_N": {
          "doc": "'n'",
          "name": "KEYCODE_N",
          "kind": "var",
          "value": "0x0000006eu",
          "sourceName": "SDLK_N",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_O": {
          "doc": "'o'",
          "name": "KEYCODE_O",
          "kind": "var",
          "value": "0x0000006fu",
          "sourceName": "SDLK_O",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_P": {
          "doc": "'p'",
          "name": "KEYCODE_P",
          "kind": "var",
          "value": "0x00000070u",
          "sourceName": "SDLK_P",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_Q": {
          "doc": "'q'",
          "name": "KEYCODE_Q",
          "kind": "var",
          "value": "0x00000071u",
          "sourceName": "SDLK_Q",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_R": {
          "doc": "'r'",
          "name": "KEYCODE_R",
          "kind": "var",
          "value": "0x00000072u",
          "sourceName": "SDLK_R",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_S": {
          "doc": "'s'",
          "name": "KEYCODE_S",
          "kind": "var",
          "value": "0x00000073u",
          "sourceName": "SDLK_S",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_T": {
          "doc": "'t'",
          "name": "KEYCODE_T",
          "kind": "var",
          "value": "0x00000074u",
          "sourceName": "SDLK_T",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_U": {
          "doc": "'u'",
          "name": "KEYCODE_U",
          "kind": "var",
          "value": "0x00000075u",
          "sourceName": "SDLK_U",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_V": {
          "doc": "'v'",
          "name": "KEYCODE_V",
          "kind": "var",
          "value": "0x00000076u",
          "sourceName": "SDLK_V",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_W": {
          "doc": "'w'",
          "name": "KEYCODE_W",
          "kind": "var",
          "value": "0x00000077u",
          "sourceName": "SDLK_W",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_X": {
          "doc": "'x'",
          "name": "KEYCODE_X",
          "kind": "var",
          "value": "0x00000078u",
          "sourceName": "SDLK_X",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_Y": {
          "doc": "'y'",
          "name": "KEYCODE_Y",
          "kind": "var",
          "value": "0x00000079u",
          "sourceName": "SDLK_Y",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_Z": {
          "doc": "'z'",
          "name": "KEYCODE_Z",
          "kind": "var",
          "value": "0x0000007au",
          "sourceName": "SDLK_Z",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_LEFTBRACE": {
          "doc": "'{'",
          "name": "KEYCODE_LEFTBRACE",
          "kind": "var",
          "value": "0x0000007bu",
          "sourceName": "SDLK_LEFTBRACE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_PIPE": {
          "doc": "'|'",
          "name": "KEYCODE_PIPE",
          "kind": "var",
          "value": "0x0000007cu",
          "sourceName": "SDLK_PIPE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_RIGHTBRACE": {
          "doc": "'}'",
          "name": "KEYCODE_RIGHTBRACE",
          "kind": "var",
          "value": "0x0000007du",
          "sourceName": "SDLK_RIGHTBRACE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_TILDE": {
          "doc": "'~'",
          "name": "KEYCODE_TILDE",
          "kind": "var",
          "value": "0x0000007eu",
          "sourceName": "SDLK_TILDE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_DELETE": {
          "doc": "'@x7F'",
          "name": "KEYCODE_DELETE",
          "kind": "var",
          "value": "0x0000007fu",
          "sourceName": "SDLK_DELETE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_PLUSMINUS": {
          "doc": "'@xB1'",
          "name": "KEYCODE_PLUSMINUS",
          "kind": "var",
          "value": "0x000000b1u",
          "sourceName": "SDLK_PLUSMINUS",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_CAPSLOCK": {
          "doc": "ScancodeToKeycode(SCANCODE_CAPSLOCK)",
          "name": "KEYCODE_CAPSLOCK",
          "kind": "var",
          "value": "0x40000039u",
          "sourceName": "SDLK_CAPSLOCK",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F1": {
          "doc": "ScancodeToKeycode(SCANCODE_F1)",
          "name": "KEYCODE_F1",
          "kind": "var",
          "value": "0x4000003au",
          "sourceName": "SDLK_F1",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F2": {
          "doc": "ScancodeToKeycode(SCANCODE_F2)",
          "name": "KEYCODE_F2",
          "kind": "var",
          "value": "0x4000003bu",
          "sourceName": "SDLK_F2",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F3": {
          "doc": "ScancodeToKeycode(SCANCODE_F3)",
          "name": "KEYCODE_F3",
          "kind": "var",
          "value": "0x4000003cu",
          "sourceName": "SDLK_F3",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F4": {
          "doc": "ScancodeToKeycode(SCANCODE_F4)",
          "name": "KEYCODE_F4",
          "kind": "var",
          "value": "0x4000003du",
          "sourceName": "SDLK_F4",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F5": {
          "doc": "ScancodeToKeycode(SCANCODE_F5)",
          "name": "KEYCODE_F5",
          "kind": "var",
          "value": "0x4000003eu",
          "sourceName": "SDLK_F5",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F6": {
          "doc": "ScancodeToKeycode(SCANCODE_F6)",
          "name": "KEYCODE_F6",
          "kind": "var",
          "value": "0x4000003fu",
          "sourceName": "SDLK_F6",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F7": {
          "doc": "ScancodeToKeycode(SCANCODE_F7)",
          "name": "KEYCODE_F7",
          "kind": "var",
          "value": "0x40000040u",
          "sourceName": "SDLK_F7",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F8": {
          "doc": "ScancodeToKeycode(SCANCODE_F8)",
          "name": "KEYCODE_F8",
          "kind": "var",
          "value": "0x40000041u",
          "sourceName": "SDLK_F8",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F9": {
          "doc": "ScancodeToKeycode(SCANCODE_F9)",
          "name": "KEYCODE_F9",
          "kind": "var",
          "value": "0x40000042u",
          "sourceName": "SDLK_F9",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F10": {
          "doc": "ScancodeToKeycode(SCANCODE_F10)",
          "name": "KEYCODE_F10",
          "kind": "var",
          "value": "0x40000043u",
          "sourceName": "SDLK_F10",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F11": {
          "doc": "ScancodeToKeycode(SCANCODE_F11)",
          "name": "KEYCODE_F11",
          "kind": "var",
          "value": "0x40000044u",
          "sourceName": "SDLK_F11",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F12": {
          "doc": "ScancodeToKeycode(SCANCODE_F12)",
          "name": "KEYCODE_F12",
          "kind": "var",
          "value": "0x40000045u",
          "sourceName": "SDLK_F12",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_PRINTSCREEN": {
          "doc": "ScancodeToKeycode(SCANCODE_PRINTSCREEN)",
          "name": "KEYCODE_PRINTSCREEN",
          "kind": "var",
          "value": "0x40000046u",
          "sourceName": "SDLK_PRINTSCREEN",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_SCROLLLOCK": {
          "doc": "ScancodeToKeycode(SCANCODE_SCROLLLOCK)",
          "name": "KEYCODE_SCROLLLOCK",
          "kind": "var",
          "value": "0x40000047u",
          "sourceName": "SDLK_SCROLLLOCK",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_PAUSE": {
          "doc": "ScancodeToKeycode(SCANCODE_PAUSE)",
          "name": "KEYCODE_PAUSE",
          "kind": "var",
          "value": "0x40000048u",
          "sourceName": "SDLK_PAUSE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_INSERT": {
          "doc": "ScancodeToKeycode(SCANCODE_INSERT)",
          "name": "KEYCODE_INSERT",
          "kind": "var",
          "value": "0x40000049u",
          "sourceName": "SDLK_INSERT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_HOME": {
          "doc": "ScancodeToKeycode(SCANCODE_HOME)",
          "name": "KEYCODE_HOME",
          "kind": "var",
          "value": "0x4000004au",
          "sourceName": "SDLK_HOME",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_PAGEUP": {
          "doc": "ScancodeToKeycode(SCANCODE_PAGEUP)",
          "name": "KEYCODE_PAGEUP",
          "kind": "var",
          "value": "0x4000004bu",
          "sourceName": "SDLK_PAGEUP",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_END": {
          "doc": "ScancodeToKeycode(SCANCODE_END)",
          "name": "KEYCODE_END",
          "kind": "var",
          "value": "0x4000004du",
          "sourceName": "SDLK_END",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_PAGEDOWN": {
          "doc": "ScancodeToKeycode(SCANCODE_PAGEDOWN)",
          "name": "KEYCODE_PAGEDOWN",
          "kind": "var",
          "value": "0x4000004eu",
          "sourceName": "SDLK_PAGEDOWN",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_RIGHT": {
          "doc": "ScancodeToKeycode(SCANCODE_RIGHT)",
          "name": "KEYCODE_RIGHT",
          "kind": "var",
          "value": "0x4000004fu",
          "sourceName": "SDLK_RIGHT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_LEFT": {
          "doc": "ScancodeToKeycode(SCANCODE_LEFT)",
          "name": "KEYCODE_LEFT",
          "kind": "var",
          "value": "0x40000050u",
          "sourceName": "SDLK_LEFT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_DOWN": {
          "doc": "ScancodeToKeycode(SCANCODE_DOWN)",
          "name": "KEYCODE_DOWN",
          "kind": "var",
          "value": "0x40000051u",
          "sourceName": "SDLK_DOWN",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_UP": {
          "doc": "ScancodeToKeycode(SCANCODE_UP)",
          "name": "KEYCODE_UP",
          "kind": "var",
          "value": "0x40000052u",
          "sourceName": "SDLK_UP",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_NUMLOCKCLEAR": {
          "doc": "ScancodeToKeycode(SCANCODE_NUMLOCKCLEAR)",
          "name": "KEYCODE_NUMLOCKCLEAR",
          "kind": "var",
          "value": "0x40000053u",
          "sourceName": "SDLK_NUMLOCKCLEAR",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_DIVIDE": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_DIVIDE)",
          "name": "KEYCODE_KP_DIVIDE",
          "kind": "var",
          "value": "0x40000054u",
          "sourceName": "SDLK_KP_DIVIDE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_MULTIPLY": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_MULTIPLY)",
          "name": "KEYCODE_KP_MULTIPLY",
          "kind": "var",
          "value": "0x40000055u",
          "sourceName": "SDLK_KP_MULTIPLY",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_MINUS": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_MINUS)",
          "name": "KEYCODE_KP_MINUS",
          "kind": "var",
          "value": "0x40000056u",
          "sourceName": "SDLK_KP_MINUS",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_PLUS": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_PLUS)",
          "name": "KEYCODE_KP_PLUS",
          "kind": "var",
          "value": "0x40000057u",
          "sourceName": "SDLK_KP_PLUS",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_ENTER": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_ENTER)",
          "name": "KEYCODE_KP_ENTER",
          "kind": "var",
          "value": "0x40000058u",
          "sourceName": "SDLK_KP_ENTER",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_1": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_1)",
          "name": "KEYCODE_KP_1",
          "kind": "var",
          "value": "0x40000059u",
          "sourceName": "SDLK_KP_1",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_2": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_2)",
          "name": "KEYCODE_KP_2",
          "kind": "var",
          "value": "0x4000005au",
          "sourceName": "SDLK_KP_2",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_3": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_3)",
          "name": "KEYCODE_KP_3",
          "kind": "var",
          "value": "0x4000005bu",
          "sourceName": "SDLK_KP_3",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_4": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_4)",
          "name": "KEYCODE_KP_4",
          "kind": "var",
          "value": "0x4000005cu",
          "sourceName": "SDLK_KP_4",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_5": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_5)",
          "name": "KEYCODE_KP_5",
          "kind": "var",
          "value": "0x4000005du",
          "sourceName": "SDLK_KP_5",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_6": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_6)",
          "name": "KEYCODE_KP_6",
          "kind": "var",
          "value": "0x4000005eu",
          "sourceName": "SDLK_KP_6",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_7": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_7)",
          "name": "KEYCODE_KP_7",
          "kind": "var",
          "value": "0x4000005fu",
          "sourceName": "SDLK_KP_7",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_8": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_8)",
          "name": "KEYCODE_KP_8",
          "kind": "var",
          "value": "0x40000060u",
          "sourceName": "SDLK_KP_8",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_9": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_9)",
          "name": "KEYCODE_KP_9",
          "kind": "var",
          "value": "0x40000061u",
          "sourceName": "SDLK_KP_9",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_0": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_0)",
          "name": "KEYCODE_KP_0",
          "kind": "var",
          "value": "0x40000062u",
          "sourceName": "SDLK_KP_0",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_PERIOD": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_PERIOD)",
          "name": "KEYCODE_KP_PERIOD",
          "kind": "var",
          "value": "0x40000063u",
          "sourceName": "SDLK_KP_PERIOD",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_APPLICATION": {
          "doc": "ScancodeToKeycode(SCANCODE_APPLICATION)",
          "name": "KEYCODE_APPLICATION",
          "kind": "var",
          "value": "0x40000065u",
          "sourceName": "SDLK_APPLICATION",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_POWER": {
          "doc": "ScancodeToKeycode(SCANCODE_POWER)",
          "name": "KEYCODE_POWER",
          "kind": "var",
          "value": "0x40000066u",
          "sourceName": "SDLK_POWER",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_EQUALS": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_EQUALS)",
          "name": "KEYCODE_KP_EQUALS",
          "kind": "var",
          "value": "0x40000067u",
          "sourceName": "SDLK_KP_EQUALS",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F13": {
          "doc": "ScancodeToKeycode(SCANCODE_F13)",
          "name": "KEYCODE_F13",
          "kind": "var",
          "value": "0x40000068u",
          "sourceName": "SDLK_F13",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F14": {
          "doc": "ScancodeToKeycode(SCANCODE_F14)",
          "name": "KEYCODE_F14",
          "kind": "var",
          "value": "0x40000069u",
          "sourceName": "SDLK_F14",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F15": {
          "doc": "ScancodeToKeycode(SCANCODE_F15)",
          "name": "KEYCODE_F15",
          "kind": "var",
          "value": "0x4000006au",
          "sourceName": "SDLK_F15",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F16": {
          "doc": "ScancodeToKeycode(SCANCODE_F16)",
          "name": "KEYCODE_F16",
          "kind": "var",
          "value": "0x4000006bu",
          "sourceName": "SDLK_F16",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F17": {
          "doc": "ScancodeToKeycode(SCANCODE_F17)",
          "name": "KEYCODE_F17",
          "kind": "var",
          "value": "0x4000006cu",
          "sourceName": "SDLK_F17",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F18": {
          "doc": "ScancodeToKeycode(SCANCODE_F18)",
          "name": "KEYCODE_F18",
          "kind": "var",
          "value": "0x4000006du",
          "sourceName": "SDLK_F18",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F19": {
          "doc": "ScancodeToKeycode(SCANCODE_F19)",
          "name": "KEYCODE_F19",
          "kind": "var",
          "value": "0x4000006eu",
          "sourceName": "SDLK_F19",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F20": {
          "doc": "ScancodeToKeycode(SCANCODE_F20)",
          "name": "KEYCODE_F20",
          "kind": "var",
          "value": "0x4000006fu",
          "sourceName": "SDLK_F20",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F21": {
          "doc": "ScancodeToKeycode(SCANCODE_F21)",
          "name": "KEYCODE_F21",
          "kind": "var",
          "value": "0x40000070u",
          "sourceName": "SDLK_F21",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F22": {
          "doc": "ScancodeToKeycode(SCANCODE_F22)",
          "name": "KEYCODE_F22",
          "kind": "var",
          "value": "0x40000071u",
          "sourceName": "SDLK_F22",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F23": {
          "doc": "ScancodeToKeycode(SCANCODE_F23)",
          "name": "KEYCODE_F23",
          "kind": "var",
          "value": "0x40000072u",
          "sourceName": "SDLK_F23",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_F24": {
          "doc": "ScancodeToKeycode(SCANCODE_F24)",
          "name": "KEYCODE_F24",
          "kind": "var",
          "value": "0x40000073u",
          "sourceName": "SDLK_F24",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_EXECUTE": {
          "doc": "ScancodeToKeycode(SCANCODE_EXECUTE)",
          "name": "KEYCODE_EXECUTE",
          "kind": "var",
          "value": "0x40000074u",
          "sourceName": "SDLK_EXECUTE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_HELP": {
          "doc": "ScancodeToKeycode(SCANCODE_HELP)",
          "name": "KEYCODE_HELP",
          "kind": "var",
          "value": "0x40000075u",
          "sourceName": "SDLK_HELP",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_MENU": {
          "doc": "ScancodeToKeycode(SCANCODE_MENU)",
          "name": "KEYCODE_MENU",
          "kind": "var",
          "value": "0x40000076u",
          "sourceName": "SDLK_MENU",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_SELECT": {
          "doc": "ScancodeToKeycode(SCANCODE_SELECT)",
          "name": "KEYCODE_SELECT",
          "kind": "var",
          "value": "0x40000077u",
          "sourceName": "SDLK_SELECT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_STOP": {
          "doc": "ScancodeToKeycode(SCANCODE_STOP)",
          "name": "KEYCODE_STOP",
          "kind": "var",
          "value": "0x40000078u",
          "sourceName": "SDLK_STOP",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_AGAIN": {
          "doc": "ScancodeToKeycode(SCANCODE_AGAIN)",
          "name": "KEYCODE_AGAIN",
          "kind": "var",
          "value": "0x40000079u",
          "sourceName": "SDLK_AGAIN",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_UNDO": {
          "doc": "ScancodeToKeycode(SCANCODE_UNDO)",
          "name": "KEYCODE_UNDO",
          "kind": "var",
          "value": "0x4000007au",
          "sourceName": "SDLK_UNDO",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_CUT": {
          "doc": "ScancodeToKeycode(SCANCODE_CUT)",
          "name": "KEYCODE_CUT",
          "kind": "var",
          "value": "0x4000007bu",
          "sourceName": "SDLK_CUT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_COPY": {
          "doc": "ScancodeToKeycode(SCANCODE_COPY)",
          "name": "KEYCODE_COPY",
          "kind": "var",
          "value": "0x4000007cu",
          "sourceName": "SDLK_COPY",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_PASTE": {
          "doc": "ScancodeToKeycode(SCANCODE_PASTE)",
          "name": "KEYCODE_PASTE",
          "kind": "var",
          "value": "0x4000007du",
          "sourceName": "SDLK_PASTE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_FIND": {
          "doc": "ScancodeToKeycode(SCANCODE_FIND)",
          "name": "KEYCODE_FIND",
          "kind": "var",
          "value": "0x4000007eu",
          "sourceName": "SDLK_FIND",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_MUTE": {
          "doc": "ScancodeToKeycode(SCANCODE_MUTE)",
          "name": "KEYCODE_MUTE",
          "kind": "var",
          "value": "0x4000007fu",
          "sourceName": "SDLK_MUTE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_VOLUMEUP": {
          "doc": "ScancodeToKeycode(SCANCODE_VOLUMEUP)",
          "name": "KEYCODE_VOLUMEUP",
          "kind": "var",
          "value": "0x40000080u",
          "sourceName": "SDLK_VOLUMEUP",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_VOLUMEDOWN": {
          "doc": "ScancodeToKeycode(SCANCODE_VOLUMEDOWN)",
          "name": "KEYCODE_VOLUMEDOWN",
          "kind": "var",
          "value": "0x40000081u",
          "sourceName": "SDLK_VOLUMEDOWN",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_COMMA": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_COMMA)",
          "name": "KEYCODE_KP_COMMA",
          "kind": "var",
          "value": "0x40000085u",
          "sourceName": "SDLK_KP_COMMA",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_EQUALSAS400": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_EQUALSAS400)",
          "name": "KEYCODE_KP_EQUALSAS400",
          "kind": "var",
          "value": "0x40000086u",
          "sourceName": "SDLK_KP_EQUALSAS400",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_ALTERASE": {
          "doc": "ScancodeToKeycode(SCANCODE_ALTERASE)",
          "name": "KEYCODE_ALTERASE",
          "kind": "var",
          "value": "0x40000099u",
          "sourceName": "SDLK_ALTERASE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_SYSREQ": {
          "doc": "ScancodeToKeycode(SCANCODE_SYSREQ)",
          "name": "KEYCODE_SYSREQ",
          "kind": "var",
          "value": "0x4000009au",
          "sourceName": "SDLK_SYSREQ",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_CANCEL": {
          "doc": "ScancodeToKeycode(SCANCODE_CANCEL)",
          "name": "KEYCODE_CANCEL",
          "kind": "var",
          "value": "0x4000009bu",
          "sourceName": "SDLK_CANCEL",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_CLEAR": {
          "doc": "ScancodeToKeycode(SCANCODE_CLEAR)",
          "name": "KEYCODE_CLEAR",
          "kind": "var",
          "value": "0x4000009cu",
          "sourceName": "SDLK_CLEAR",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_PRIOR": {
          "doc": "ScancodeToKeycode(SCANCODE_PRIOR)",
          "name": "KEYCODE_PRIOR",
          "kind": "var",
          "value": "0x4000009du",
          "sourceName": "SDLK_PRIOR",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_RETURN2": {
          "doc": "ScancodeToKeycode(SCANCODE_RETURN2)",
          "name": "KEYCODE_RETURN2",
          "kind": "var",
          "value": "0x4000009eu",
          "sourceName": "SDLK_RETURN2",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_SEPARATOR": {
          "doc": "ScancodeToKeycode(SCANCODE_SEPARATOR)",
          "name": "KEYCODE_SEPARATOR",
          "kind": "var",
          "value": "0x4000009fu",
          "sourceName": "SDLK_SEPARATOR",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_OUT": {
          "doc": "ScancodeToKeycode(SCANCODE_OUT)",
          "name": "KEYCODE_OUT",
          "kind": "var",
          "value": "0x400000a0u",
          "sourceName": "SDLK_OUT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_OPER": {
          "doc": "ScancodeToKeycode(SCANCODE_OPER)",
          "name": "KEYCODE_OPER",
          "kind": "var",
          "value": "0x400000a1u",
          "sourceName": "SDLK_OPER",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_CLEARAGAIN": {
          "doc": "ScancodeToKeycode(SCANCODE_CLEARAGAIN)",
          "name": "KEYCODE_CLEARAGAIN",
          "kind": "var",
          "value": "0x400000a2u",
          "sourceName": "SDLK_CLEARAGAIN",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_CRSEL": {
          "doc": "ScancodeToKeycode(SCANCODE_CRSEL)",
          "name": "KEYCODE_CRSEL",
          "kind": "var",
          "value": "0x400000a3u",
          "sourceName": "SDLK_CRSEL",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_EXSEL": {
          "doc": "ScancodeToKeycode(SCANCODE_EXSEL)",
          "name": "KEYCODE_EXSEL",
          "kind": "var",
          "value": "0x400000a4u",
          "sourceName": "SDLK_EXSEL",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_00": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_00)",
          "name": "KEYCODE_KP_00",
          "kind": "var",
          "value": "0x400000b0u",
          "sourceName": "SDLK_KP_00",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_000": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_000)",
          "name": "KEYCODE_KP_000",
          "kind": "var",
          "value": "0x400000b1u",
          "sourceName": "SDLK_KP_000",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_THOUSANDSSEPARATOR": {
          "doc": "ScancodeToKeycode(SCANCODE_THOUSANDSSEPARATOR)",
          "name": "KEYCODE_THOUSANDSSEPARATOR",
          "kind": "var",
          "value": "0x400000b2u",
          "sourceName": "SDLK_THOUSANDSSEPARATOR",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_DECIMALSEPARATOR": {
          "doc": "ScancodeToKeycode(SCANCODE_DECIMALSEPARATOR)",
          "name": "KEYCODE_DECIMALSEPARATOR",
          "kind": "var",
          "value": "0x400000b3u",
          "sourceName": "SDLK_DECIMALSEPARATOR",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_CURRENCYUNIT": {
          "doc": "ScancodeToKeycode(SCANCODE_CURRENCYUNIT)",
          "name": "KEYCODE_CURRENCYUNIT",
          "kind": "var",
          "value": "0x400000b4u",
          "sourceName": "SDLK_CURRENCYUNIT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_CURRENCYSUBUNIT": {
          "doc": "ScancodeToKeycode(SCANCODE_CURRENCYSUBUNIT)",
          "name": "KEYCODE_CURRENCYSUBUNIT",
          "kind": "var",
          "value": "0x400000b5u",
          "sourceName": "SDLK_CURRENCYSUBUNIT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_LEFTPAREN": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_LEFTPAREN)",
          "name": "KEYCODE_KP_LEFTPAREN",
          "kind": "var",
          "value": "0x400000b6u",
          "sourceName": "SDLK_KP_LEFTPAREN",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_RIGHTPAREN": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_RIGHTPAREN)",
          "name": "KEYCODE_KP_RIGHTPAREN",
          "kind": "var",
          "value": "0x400000b7u",
          "sourceName": "SDLK_KP_RIGHTPAREN",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_LEFTBRACE": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_LEFTBRACE)",
          "name": "KEYCODE_KP_LEFTBRACE",
          "kind": "var",
          "value": "0x400000b8u",
          "sourceName": "SDLK_KP_LEFTBRACE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_RIGHTBRACE": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_RIGHTBRACE)",
          "name": "KEYCODE_KP_RIGHTBRACE",
          "kind": "var",
          "value": "0x400000b9u",
          "sourceName": "SDLK_KP_RIGHTBRACE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_TAB": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_TAB)",
          "name": "KEYCODE_KP_TAB",
          "kind": "var",
          "value": "0x400000bau",
          "sourceName": "SDLK_KP_TAB",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_BACKSPACE": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_BACKSPACE)",
          "name": "KEYCODE_KP_BACKSPACE",
          "kind": "var",
          "value": "0x400000bbu",
          "sourceName": "SDLK_KP_BACKSPACE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_A": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_A)",
          "name": "KEYCODE_KP_A",
          "kind": "var",
          "value": "0x400000bcu",
          "sourceName": "SDLK_KP_A",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_B": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_B)",
          "name": "KEYCODE_KP_B",
          "kind": "var",
          "value": "0x400000bdu",
          "sourceName": "SDLK_KP_B",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_C": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_C)",
          "name": "KEYCODE_KP_C",
          "kind": "var",
          "value": "0x400000beu",
          "sourceName": "SDLK_KP_C",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_D": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_D)",
          "name": "KEYCODE_KP_D",
          "kind": "var",
          "value": "0x400000bfu",
          "sourceName": "SDLK_KP_D",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_E": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_E)",
          "name": "KEYCODE_KP_E",
          "kind": "var",
          "value": "0x400000c0u",
          "sourceName": "SDLK_KP_E",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_F": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_F)",
          "name": "KEYCODE_KP_F",
          "kind": "var",
          "value": "0x400000c1u",
          "sourceName": "SDLK_KP_F",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_XOR": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_XOR)",
          "name": "KEYCODE_KP_XOR",
          "kind": "var",
          "value": "0x400000c2u",
          "sourceName": "SDLK_KP_XOR",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_POWER": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_POWER)",
          "name": "KEYCODE_KP_POWER",
          "kind": "var",
          "value": "0x400000c3u",
          "sourceName": "SDLK_KP_POWER",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_PERCENT": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_PERCENT)",
          "name": "KEYCODE_KP_PERCENT",
          "kind": "var",
          "value": "0x400000c4u",
          "sourceName": "SDLK_KP_PERCENT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_LESS": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_LESS)",
          "name": "KEYCODE_KP_LESS",
          "kind": "var",
          "value": "0x400000c5u",
          "sourceName": "SDLK_KP_LESS",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_GREATER": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_GREATER)",
          "name": "KEYCODE_KP_GREATER",
          "kind": "var",
          "value": "0x400000c6u",
          "sourceName": "SDLK_KP_GREATER",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_AMPERSAND": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_AMPERSAND)",
          "name": "KEYCODE_KP_AMPERSAND",
          "kind": "var",
          "value": "0x400000c7u",
          "sourceName": "SDLK_KP_AMPERSAND",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_DBLAMPERSAND": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_DBLAMPERSAND)",
          "name": "KEYCODE_KP_DBLAMPERSAND",
          "kind": "var",
          "value": "0x400000c8u",
          "sourceName": "SDLK_KP_DBLAMPERSAND",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_VERTICALBAR": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_VERTICALBAR)",
          "name": "KEYCODE_KP_VERTICALBAR",
          "kind": "var",
          "value": "0x400000c9u",
          "sourceName": "SDLK_KP_VERTICALBAR",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_DBLVERTICALBAR": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_DBLVERTICALBAR)",
          "name": "KEYCODE_KP_DBLVERTICALBAR",
          "kind": "var",
          "value": "0x400000cau",
          "sourceName": "SDLK_KP_DBLVERTICALBAR",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_COLON": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_COLON)",
          "name": "KEYCODE_KP_COLON",
          "kind": "var",
          "value": "0x400000cbu",
          "sourceName": "SDLK_KP_COLON",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_HASH": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_HASH)",
          "name": "KEYCODE_KP_HASH",
          "kind": "var",
          "value": "0x400000ccu",
          "sourceName": "SDLK_KP_HASH",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_SPACE": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_SPACE)",
          "name": "KEYCODE_KP_SPACE",
          "kind": "var",
          "value": "0x400000cdu",
          "sourceName": "SDLK_KP_SPACE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_AT": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_AT)",
          "name": "KEYCODE_KP_AT",
          "kind": "var",
          "value": "0x400000ceu",
          "sourceName": "SDLK_KP_AT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_EXCLAM": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_EXCLAM)",
          "name": "KEYCODE_KP_EXCLAM",
          "kind": "var",
          "value": "0x400000cfu",
          "sourceName": "SDLK_KP_EXCLAM",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_MEMSTORE": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_MEMSTORE)",
          "name": "KEYCODE_KP_MEMSTORE",
          "kind": "var",
          "value": "0x400000d0u",
          "sourceName": "SDLK_KP_MEMSTORE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_MEMRECALL": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_MEMRECALL)",
          "name": "KEYCODE_KP_MEMRECALL",
          "kind": "var",
          "value": "0x400000d1u",
          "sourceName": "SDLK_KP_MEMRECALL",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_MEMCLEAR": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_MEMCLEAR)",
          "name": "KEYCODE_KP_MEMCLEAR",
          "kind": "var",
          "value": "0x400000d2u",
          "sourceName": "SDLK_KP_MEMCLEAR",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_MEMADD": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_MEMADD)",
          "name": "KEYCODE_KP_MEMADD",
          "kind": "var",
          "value": "0x400000d3u",
          "sourceName": "SDLK_KP_MEMADD",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_MEMSUBTRACT": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_MEMSUBTRACT)",
          "name": "KEYCODE_KP_MEMSUBTRACT",
          "kind": "var",
          "value": "0x400000d4u",
          "sourceName": "SDLK_KP_MEMSUBTRACT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_MEMMULTIPLY": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_MEMMULTIPLY)",
          "name": "KEYCODE_KP_MEMMULTIPLY",
          "kind": "var",
          "value": "0x400000d5u",
          "sourceName": "SDLK_KP_MEMMULTIPLY",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_MEMDIVIDE": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_MEMDIVIDE)",
          "name": "KEYCODE_KP_MEMDIVIDE",
          "kind": "var",
          "value": "0x400000d6u",
          "sourceName": "SDLK_KP_MEMDIVIDE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_PLUSMINUS": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_PLUSMINUS)",
          "name": "KEYCODE_KP_PLUSMINUS",
          "kind": "var",
          "value": "0x400000d7u",
          "sourceName": "SDLK_KP_PLUSMINUS",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_CLEAR": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_CLEAR)",
          "name": "KEYCODE_KP_CLEAR",
          "kind": "var",
          "value": "0x400000d8u",
          "sourceName": "SDLK_KP_CLEAR",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_CLEARENTRY": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_CLEARENTRY)",
          "name": "KEYCODE_KP_CLEARENTRY",
          "kind": "var",
          "value": "0x400000d9u",
          "sourceName": "SDLK_KP_CLEARENTRY",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_BINARY": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_BINARY)",
          "name": "KEYCODE_KP_BINARY",
          "kind": "var",
          "value": "0x400000dau",
          "sourceName": "SDLK_KP_BINARY",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_OCTAL": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_OCTAL)",
          "name": "KEYCODE_KP_OCTAL",
          "kind": "var",
          "value": "0x400000dbu",
          "sourceName": "SDLK_KP_OCTAL",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_DECIMAL": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_DECIMAL)",
          "name": "KEYCODE_KP_DECIMAL",
          "kind": "var",
          "value": "0x400000dcu",
          "sourceName": "SDLK_KP_DECIMAL",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_KP_HEXADECIMAL": {
          "doc": "ScancodeToKeycode(SCANCODE_KP_HEXADECIMAL)",
          "name": "KEYCODE_KP_HEXADECIMAL",
          "kind": "var",
          "value": "0x400000ddu",
          "sourceName": "SDLK_KP_HEXADECIMAL",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_LCTRL": {
          "doc": "ScancodeToKeycode(SCANCODE_LCTRL)",
          "name": "KEYCODE_LCTRL",
          "kind": "var",
          "value": "0x400000e0u",
          "sourceName": "SDLK_LCTRL",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_LSHIFT": {
          "doc": "ScancodeToKeycode(SCANCODE_LSHIFT)",
          "name": "KEYCODE_LSHIFT",
          "kind": "var",
          "value": "0x400000e1u",
          "sourceName": "SDLK_LSHIFT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_LALT": {
          "doc": "ScancodeToKeycode(SCANCODE_LALT)",
          "name": "KEYCODE_LALT",
          "kind": "var",
          "value": "0x400000e2u",
          "sourceName": "SDLK_LALT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_LGUI": {
          "doc": "ScancodeToKeycode(SCANCODE_LGUI)",
          "name": "KEYCODE_LGUI",
          "kind": "var",
          "value": "0x400000e3u",
          "sourceName": "SDLK_LGUI",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_RCTRL": {
          "doc": "ScancodeToKeycode(SCANCODE_RCTRL)",
          "name": "KEYCODE_RCTRL",
          "kind": "var",
          "value": "0x400000e4u",
          "sourceName": "SDLK_RCTRL",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_RSHIFT": {
          "doc": "ScancodeToKeycode(SCANCODE_RSHIFT)",
          "name": "KEYCODE_RSHIFT",
          "kind": "var",
          "value": "0x400000e5u",
          "sourceName": "SDLK_RSHIFT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_RALT": {
          "doc": "ScancodeToKeycode(SCANCODE_RALT)",
          "name": "KEYCODE_RALT",
          "kind": "var",
          "value": "0x400000e6u",
          "sourceName": "SDLK_RALT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_RGUI": {
          "doc": "ScancodeToKeycode(SCANCODE_RGUI)",
          "name": "KEYCODE_RGUI",
          "kind": "var",
          "value": "0x400000e7u",
          "sourceName": "SDLK_RGUI",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_MODE": {
          "doc": "ScancodeToKeycode(SCANCODE_MODE)",
          "name": "KEYCODE_MODE",
          "kind": "var",
          "value": "0x40000101u",
          "sourceName": "SDLK_MODE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_SLEEP": {
          "doc": "ScancodeToKeycode(SCANCODE_SLEEP)",
          "name": "KEYCODE_SLEEP",
          "kind": "var",
          "value": "0x40000102u",
          "sourceName": "SDLK_SLEEP",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_WAKE": {
          "doc": "ScancodeToKeycode(SCANCODE_WAKE)",
          "name": "KEYCODE_WAKE",
          "kind": "var",
          "value": "0x40000103u",
          "sourceName": "SDLK_WAKE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_CHANNEL_INCREMENT": {
          "doc": "ScancodeToKeycode(SCANCODE_CHANNEL_INCREMENT)",
          "name": "KEYCODE_CHANNEL_INCREMENT",
          "kind": "var",
          "value": "0x40000104u",
          "sourceName": "SDLK_CHANNEL_INCREMENT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_CHANNEL_DECREMENT": {
          "doc": "ScancodeToKeycode(SCANCODE_CHANNEL_DECREMENT)",
          "name": "KEYCODE_CHANNEL_DECREMENT",
          "kind": "var",
          "value": "0x40000105u",
          "sourceName": "SDLK_CHANNEL_DECREMENT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_MEDIA_PLAY": {
          "doc": "ScancodeToKeycode(SCANCODE_MEDIA_PLAY)",
          "name": "KEYCODE_MEDIA_PLAY",
          "kind": "var",
          "value": "0x40000106u",
          "sourceName": "SDLK_MEDIA_PLAY",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_MEDIA_PAUSE": {
          "doc": "ScancodeToKeycode(SCANCODE_MEDIA_PAUSE)",
          "name": "KEYCODE_MEDIA_PAUSE",
          "kind": "var",
          "value": "0x40000107u",
          "sourceName": "SDLK_MEDIA_PAUSE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_MEDIA_RECORD": {
          "doc": "ScancodeToKeycode(SCANCODE_MEDIA_RECORD)",
          "name": "KEYCODE_MEDIA_RECORD",
          "kind": "var",
          "value": "0x40000108u",
          "sourceName": "SDLK_MEDIA_RECORD",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_MEDIA_FAST_FORWARD": {
          "doc": "ScancodeToKeycode(SCANCODE_MEDIA_FAST_FORWARD)",
          "name": "KEYCODE_MEDIA_FAST_FORWARD",
          "kind": "var",
          "value": "0x40000109u",
          "sourceName": "SDLK_MEDIA_FAST_FORWARD",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_MEDIA_REWIND": {
          "doc": "ScancodeToKeycode(SCANCODE_MEDIA_REWIND)",
          "name": "KEYCODE_MEDIA_REWIND",
          "kind": "var",
          "value": "0x4000010au",
          "sourceName": "SDLK_MEDIA_REWIND",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_MEDIA_NEXT_TRACK": {
          "doc": "ScancodeToKeycode(SCANCODE_MEDIA_NEXT_TRACK)",
          "name": "KEYCODE_MEDIA_NEXT_TRACK",
          "kind": "var",
          "value": "0x4000010bu",
          "sourceName": "SDLK_MEDIA_NEXT_TRACK",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_MEDIA_PREVIOUS_TRACK": {
          "doc": "ScancodeToKeycode(SCANCODE_MEDIA_PREVIOUS_TRACK)",
          "name": "KEYCODE_MEDIA_PREVIOUS_TRACK",
          "kind": "var",
          "value": "0x4000010cu",
          "sourceName": "SDLK_MEDIA_PREVIOUS_TRACK",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_MEDIA_STOP": {
          "doc": "ScancodeToKeycode(SCANCODE_MEDIA_STOP)",
          "name": "KEYCODE_MEDIA_STOP",
          "kind": "var",
          "value": "0x4000010du",
          "sourceName": "SDLK_MEDIA_STOP",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_MEDIA_EJECT": {
          "doc": "ScancodeToKeycode(SCANCODE_MEDIA_EJECT)",
          "name": "KEYCODE_MEDIA_EJECT",
          "kind": "var",
          "value": "0x4000010eu",
          "sourceName": "SDLK_MEDIA_EJECT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_MEDIA_PLAY_PAUSE": {
          "doc": "ScancodeToKeycode(SCANCODE_MEDIA_PLAY_PAUSE)",
          "name": "KEYCODE_MEDIA_PLAY_PAUSE",
          "kind": "var",
          "value": "0x4000010fu",
          "sourceName": "SDLK_MEDIA_PLAY_PAUSE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_MEDIA_SELECT": {
          "doc": "ScancodeToKeycode(SCANCODE_MEDIA_SELECT)",
          "name": "KEYCODE_MEDIA_SELECT",
          "kind": "var",
          "value": "0x40000110u",
          "sourceName": "SDLK_MEDIA_SELECT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_AC_NEW": {
          "doc": "ScancodeToKeycode(SCANCODE_AC_NEW)",
          "name": "KEYCODE_AC_NEW",
          "kind": "var",
          "value": "0x40000111u",
          "sourceName": "SDLK_AC_NEW",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_AC_OPEN": {
          "doc": "ScancodeToKeycode(SCANCODE_AC_OPEN)",
          "name": "KEYCODE_AC_OPEN",
          "kind": "var",
          "value": "0x40000112u",
          "sourceName": "SDLK_AC_OPEN",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_AC_CLOSE": {
          "doc": "ScancodeToKeycode(SCANCODE_AC_CLOSE)",
          "name": "KEYCODE_AC_CLOSE",
          "kind": "var",
          "value": "0x40000113u",
          "sourceName": "SDLK_AC_CLOSE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_AC_EXIT": {
          "doc": "ScancodeToKeycode(SCANCODE_AC_EXIT)",
          "name": "KEYCODE_AC_EXIT",
          "kind": "var",
          "value": "0x40000114u",
          "sourceName": "SDLK_AC_EXIT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_AC_SAVE": {
          "doc": "ScancodeToKeycode(SCANCODE_AC_SAVE)",
          "name": "KEYCODE_AC_SAVE",
          "kind": "var",
          "value": "0x40000115u",
          "sourceName": "SDLK_AC_SAVE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_AC_PRINT": {
          "doc": "ScancodeToKeycode(SCANCODE_AC_PRINT)",
          "name": "KEYCODE_AC_PRINT",
          "kind": "var",
          "value": "0x40000116u",
          "sourceName": "SDLK_AC_PRINT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_AC_PROPERTIES": {
          "doc": "ScancodeToKeycode(SCANCODE_AC_PROPERTIES)",
          "name": "KEYCODE_AC_PROPERTIES",
          "kind": "var",
          "value": "0x40000117u",
          "sourceName": "SDLK_AC_PROPERTIES",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_AC_SEARCH": {
          "doc": "ScancodeToKeycode(SCANCODE_AC_SEARCH)",
          "name": "KEYCODE_AC_SEARCH",
          "kind": "var",
          "value": "0x40000118u",
          "sourceName": "SDLK_AC_SEARCH",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_AC_HOME": {
          "doc": "ScancodeToKeycode(SCANCODE_AC_HOME)",
          "name": "KEYCODE_AC_HOME",
          "kind": "var",
          "value": "0x40000119u",
          "sourceName": "SDLK_AC_HOME",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_AC_BACK": {
          "doc": "ScancodeToKeycode(SCANCODE_AC_BACK)",
          "name": "KEYCODE_AC_BACK",
          "kind": "var",
          "value": "0x4000011au",
          "sourceName": "SDLK_AC_BACK",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_AC_FORWARD": {
          "doc": "ScancodeToKeycode(SCANCODE_AC_FORWARD)",
          "name": "KEYCODE_AC_FORWARD",
          "kind": "var",
          "value": "0x4000011bu",
          "sourceName": "SDLK_AC_FORWARD",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_AC_STOP": {
          "doc": "ScancodeToKeycode(SCANCODE_AC_STOP)",
          "name": "KEYCODE_AC_STOP",
          "kind": "var",
          "value": "0x4000011cu",
          "sourceName": "SDLK_AC_STOP",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_AC_REFRESH": {
          "doc": "ScancodeToKeycode(SCANCODE_AC_REFRESH)",
          "name": "KEYCODE_AC_REFRESH",
          "kind": "var",
          "value": "0x4000011du",
          "sourceName": "SDLK_AC_REFRESH",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_AC_BOOKMARKS": {
          "doc": "ScancodeToKeycode(SCANCODE_AC_BOOKMARKS)",
          "name": "KEYCODE_AC_BOOKMARKS",
          "kind": "var",
          "value": "0x4000011eu",
          "sourceName": "SDLK_AC_BOOKMARKS",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_SOFTLEFT": {
          "doc": "ScancodeToKeycode(SCANCODE_SOFTLEFT)",
          "name": "KEYCODE_SOFTLEFT",
          "kind": "var",
          "value": "0x4000011fu",
          "sourceName": "SDLK_SOFTLEFT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_SOFTRIGHT": {
          "doc": "ScancodeToKeycode(SCANCODE_SOFTRIGHT)",
          "name": "KEYCODE_SOFTRIGHT",
          "kind": "var",
          "value": "0x40000120u",
          "sourceName": "SDLK_SOFTRIGHT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_CALL": {
          "doc": "ScancodeToKeycode(SCANCODE_CALL)",
          "name": "KEYCODE_CALL",
          "kind": "var",
          "value": "0x40000121u",
          "sourceName": "SDLK_CALL",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_ENDCALL": {
          "doc": "ScancodeToKeycode(SCANCODE_ENDCALL)",
          "name": "KEYCODE_ENDCALL",
          "kind": "var",
          "value": "0x40000122u",
          "sourceName": "SDLK_ENDCALL",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_LEFT_TAB": {
          "doc": "Extended key Left Tab",
          "name": "KEYCODE_LEFT_TAB",
          "kind": "var",
          "value": "0x20000001u",
          "sourceName": "SDLK_LEFT_TAB",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_LEVEL5_SHIFT": {
          "doc": "Extended key Level 5 Shift",
          "name": "KEYCODE_LEVEL5_SHIFT",
          "kind": "var",
          "value": "0x20000002u",
          "sourceName": "SDLK_LEVEL5_SHIFT",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_MULTI_KEY_COMPOSE": {
          "doc": "Extended key Multi-key Compose",
          "name": "KEYCODE_MULTI_KEY_COMPOSE",
          "kind": "var",
          "value": "0x20000003u",
          "sourceName": "SDLK_MULTI_KEY_COMPOSE",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_LMETA": {
          "doc": "Extended key Left Meta",
          "name": "KEYCODE_LMETA",
          "kind": "var",
          "value": "0x20000004u",
          "sourceName": "SDLK_LMETA",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_RMETA": {
          "doc": "Extended key Right Meta",
          "name": "KEYCODE_RMETA",
          "kind": "var",
          "value": "0x20000005u",
          "sourceName": "SDLK_RMETA",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_LHYPER": {
          "doc": "Extended key Left Hyper",
          "name": "KEYCODE_LHYPER",
          "kind": "var",
          "value": "0x20000006u",
          "sourceName": "SDLK_LHYPER",
          "constexpr": true,
          "type": "Keycode"
        },
        "KEYCODE_RHYPER": {
          "doc": "Extended key Right Hyper",
          "name": "KEYCODE_RHYPER",
          "kind": "var",
          "value": "0x20000007u",
          "sourceName": "SDLK_RHYPER",
          "constexpr": true,
          "type": "Keycode"
        }
      }
    },
    "SDL3pp_keyboard.h": {
      "name": "SDL3pp_keyboard.h",
      "doc": "@defgroup CategoryKeyboard Category Keyboard\n\nSDL keyboard management.\n\nPlease refer to the Best Keyboard Practices document for details on how\nbest to accept keyboard input in various types of programs:\n\nhttps://wiki.libsdl.org/SDL3/BestKeyboardPractices",
      "entries": {
        "KeyboardID": {
          "doc": "This is a unique ID for a keyboard for the time it is connected to the\nsystem, and is never reused for the lifetime of the application.\n\nIf the keyboard is disconnected and reconnected, it will get a new ID.\n\nThe value 0 is an invalid ID.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "KeyboardID",
          "kind": "alias",
          "type": "SDL_KeyboardID",
          "sourceName": "SDL_KeyboardID"
        },
        "HasKeyboard": {
          "doc": "Return whether a keyboard is currently connected.\n\n@returns true if a keyboard is connected, false otherwise.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetKeyboards",
          "name": "HasKeyboard",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_HasKeyboard"
        },
        "GetKeyboards": {
          "doc": "Get a list of currently connected keyboards.\n\nNote that this will include any device or virtual driver that includes\nkeyboard functionality, including some mice, KVM switches, motherboard\npower buttons, etc. You should wait for input from a device before you\nconsider it actively in use.\n\n@param count a pointer filled in with the number of keyboards returned, may\n             be nullptr.\n@returns a 0 terminated array of keyboards instance IDs or nullptr on failure;\n         call GetError() for more information. This should be freed\n         with free() when it is no longer needed.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetKeyboardNameForID\n@sa HasKeyboard",
          "name": "GetKeyboards",
          "kind": "function",
          "type": "KeyboardID *",
          "parameters": [
            {
              "name": "count",
              "type": "int *"
            }
          ],
          "sourceName": "SDL_GetKeyboards"
        },
        "GetKeyboardNameForID": {
          "doc": "Get the name of a keyboard.\n\nThis function returns \"\" if the keyboard doesn't have a name.\n\n@param instance_id the keyboard instance ID.\n@returns the name of the selected keyboard or nullptr on failure; call\n         GetError() for more information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetKeyboards",
          "name": "GetKeyboardNameForID",
          "kind": "function",
          "type": "const char *",
          "parameters": [
            {
              "name": "instance_id",
              "type": "KeyboardID"
            }
          ],
          "sourceName": "SDL_GetKeyboardNameForID"
        },
        "GetKeyboardFocus": {
          "doc": "Query the window which currently has keyboard focus.\n\n@returns the window with keyboard focus.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetKeyboardFocus",
          "kind": "function",
          "type": "WindowRef",
          "parameters": [],
          "sourceName": "SDL_GetKeyboardFocus"
        },
        "GetKeyboardState": {
          "doc": "Get a snapshot of the current state of the keyboard.\n\nThe pointer returned is a pointer to an internal SDL array. It will be\nvalid for the whole lifetime of the application and should not be freed by\nthe caller.\n\nA array element with a value of true means that the key is pressed and a\nvalue of false means that it is not. Indexes into this array are obtained\nby using Scancode values.\n\nUse PumpEvents() to update the state array.\n\nThis function gives you the current state after all events have been\nprocessed, so if a key or button has been pressed and released before you\nprocess events, then the pressed state will never show up in the\nGetKeyboardState() calls.\n\nNote: This function doesn't take into account whether shift has been\npressed or not.\n\n@param numkeys if non-nullptr, receives the length of the returned array.\n@returns a pointer to an array of key states.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PumpEvents\n@sa ResetKeyboard",
          "name": "GetKeyboardState",
          "kind": "function",
          "type": "const bool *",
          "parameters": [
            {
              "name": "numkeys",
              "type": "int *"
            }
          ],
          "sourceName": "SDL_GetKeyboardState"
        },
        "ResetKeyboard": {
          "doc": "Clear the state of the keyboard.\n\nThis function will generate key up events for all pressed keys.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetKeyboardState",
          "name": "ResetKeyboard",
          "kind": "function",
          "type": "void",
          "parameters": [],
          "sourceName": "SDL_ResetKeyboard"
        },
        "GetModState": {
          "doc": "Get the current key modifier state for the keyboard.\n\n@returns an OR'd combination of the modifier keys for the keyboard. See\n         Keymod for details.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetKeyboardState\n@sa SetModState",
          "name": "GetModState",
          "kind": "function",
          "type": "Keymod",
          "parameters": [],
          "sourceName": "SDL_GetModState"
        },
        "SetModState": {
          "doc": "Set the current key modifier state for the keyboard.\n\nThe inverse of GetModState(), SetModState() allows you to impose\nmodifier key states on your application. Simply pass your desired modifier\nstates into `modstate`. This value may be a bitwise, OR'd combination of\nKeymod values.\n\nThis does not change the keyboard state, only the key modifier flags that\nSDL reports.\n\n@param modstate the desired Keymod for the keyboard.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetModState",
          "name": "SetModState",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "modstate",
              "type": "Keymod"
            }
          ],
          "sourceName": "SDL_SetModState"
        },
        "Keycode::Keycode": [
          {
            "doc": "Get the key code corresponding to the given scancode according to the\ncurrent keyboard layout.\n\nIf you want to get the keycode as it would be delivered in key events,\nincluding options specified in SDL_HINT_KEYCODE_OPTIONS, then you should\npass `key_event` as true. Otherwise this function simply translates the\nscancode based on the given modifier state.\n\n@param scancode the desired Scancode to query.\n@param modstate the modifier state to use when translating the scancode to\n                a keycode.\n@param key_event true if the keycode will be used in key events.\n@returns the Keycode that corresponds to the given Scancode.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Keycode::GetName\n@sa Keycode::GetScancode",
            "name": "Keycode::Keycode",
            "kind": "function",
            "type": "",
            "parameters": [
              {
                "name": "scancode",
                "type": "Scancode"
              },
              {
                "name": "modstate",
                "type": "SDL_Keymod"
              },
              {
                "name": "key_event",
                "type": "bool"
              }
            ],
            "sourceName": "SDL_GetKeyFromScancode"
          },
          {
            "doc": "Get a key code from a human-readable name.\n\n@param name the human-readable key name.\n@returns key code, or `SDLK_UNKNOWN` if the name wasn't recognized; call\n         GetError() for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Keycode::Keycode\n@sa Keycode::GetName\n@sa Scancode::Scancode",
            "name": "Keycode::Keycode",
            "kind": "function",
            "type": "",
            "parameters": [
              {
                "name": "name",
                "type": "StringParam"
              }
            ],
            "sourceName": "SDL_GetKeyFromName"
          }
        ],
        "Keycode::GetScancode": {
          "doc": "Get the scancode corresponding to the given key code according to the\ncurrent keyboard layout.\n\nNote that there may be multiple scancode+modifier states that can generate\nthis keycode, this will just return the first one found.\n\n@param key the desired Keycode to query.\n@param modstate a pointer to the modifier state that would be used when the\n                scancode generates this key, may be nullptr.\n@returns the Scancode that corresponds to the given Keycode.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Keycode::Keycode\n@sa Scancode::GetName",
          "name": "Keycode::GetScancode",
          "kind": "function",
          "type": "Scancode",
          "parameters": [
            {
              "name": "modstate",
              "type": "Keymod *"
            }
          ],
          "sourceName": "SDL_GetScancodeFromKey",
          "immutable": true
        },
        "Scancode::SetName": {
          "doc": "Set a human-readable name for a scancode.\n\n@param scancode the desired Scancode.\n@param name the name to use for the scancode, encoded as UTF-8. The string\n            is not copied, so the pointer given to this function must stay\n            valid while SDL is being used.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Scancode::GetName",
          "name": "Scancode::SetName",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "name",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_SetScancodeName"
        },
        "Scancode::GetName": {
          "doc": "Get a human-readable name for a scancode.\n\n**Warning**: The returned name is by design not stable across platforms,\ne.g. the name for `SCANCODE_LGUI` is \"Left GUI\" under Linux but \"Left\nWindows\" under Microsoft Windows, and some scancodes like\n`SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even\nscancodes that share names, e.g. `SCANCODE_RETURN` and\n`SCANCODE_RETURN2` (both called \"Return\"). This function is therefore\nunsuitable for creating a stable cross-platform two-way mapping between\nstrings and scancodes.\n\n@param scancode the desired Scancode to query.\n@returns a pointer to the name for the scancode. If the scancode doesn't\n         have a name this function returns an empty string (\"\").\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Keycode::GetScancode\n@sa Scancode::Scancode\n@sa Scancode::SetName",
          "name": "Scancode::GetName",
          "kind": "function",
          "type": "const char *",
          "parameters": [],
          "sourceName": "SDL_GetScancodeName",
          "immutable": true
        },
        "Scancode::Scancode": {
          "doc": "Get a scancode from a human-readable name.\n\n@param name the human-readable scancode name.\n@returns the Scancode, or `SCANCODE_UNKNOWN` if the name wasn't\n         recognized; call GetError() for more information.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Keycode::Keycode\n@sa Keycode::GetScancode\n@sa Scancode::GetName",
          "name": "Scancode::Scancode",
          "kind": "function",
          "type": "",
          "parameters": [
            {
              "name": "name",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_GetScancodeFromName"
        },
        "Keycode::GetName": {
          "doc": "Get a human-readable name for a key.\n\nIf the key doesn't have a name, this function returns an empty string (\"\").\n\nLetters will be presented in their uppercase form, if applicable.\n\n@param key the desired Keycode to query.\n@returns a UTF-8 encoded string of the key name.\n\n@threadsafety This function is not thread safe.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Keycode::Keycode\n@sa Keycode::Keycode\n@sa Keycode::GetScancode",
          "name": "Keycode::GetName",
          "kind": "function",
          "type": "const char *",
          "parameters": [],
          "sourceName": "SDL_GetKeyName",
          "immutable": true
        },
        "WindowBase<T>::StartTextInput": [
          {
            "doc": "Start accepting Unicode text input events in a window.\n\nThis function will enable text input (EVENT_TEXT_INPUT and\nEVENT_TEXT_EDITING events) in the specified window. Please use this\nfunction paired with WindowBase<T>::StopTextInput().\n\nText input events are not received by default.\n\nOn some platforms using this function shows the screen keyboard and/or\nactivates an IME, which can prevent some key press events from being passed\nthrough.\n\n@param window the window to enable text input.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase<T>::SetTextInputArea\n@sa WindowBase<T>::StartTextInput\n@sa WindowBase<T>::StopTextInput\n@sa WindowBase<T>::IsTextInputActive",
            "name": "WindowBase<T>::StartTextInput",
            "kind": "function",
            "type": "bool",
            "parameters": [],
            "sourceName": "SDL_StartTextInput",
            "template": [
              {
                "type": "ObjectBox<SDL_Window *>",
                "name": "T"
              }
            ]
          },
          {
            "doc": "Start accepting Unicode text input events in a window, with properties\ndescribing the input.\n\nThis function will enable text input (EVENT_TEXT_INPUT and\nEVENT_TEXT_EDITING events) in the specified window. Please use this\nfunction paired with WindowBase<T>::StopTextInput().\n\nText input events are not received by default.\n\nOn some platforms using this function shows the screen keyboard and/or\nactivates an IME, which can prevent some key press events from being passed\nthrough.\n\nThese are the supported properties:\n\n- `SDL_PROP_TEXTINPUT_TYPE_NUMBER` - an TextInputType value that\n  describes text being input, defaults to TEXTINPUT_TYPE_TEXT.\n- `prop::TextInput.CAPITALIZATION_NUMBER` - an Capitalization value\n  that describes how text should be capitalized, defaults to\n  CAPITALIZE_SENTENCES for normal text entry, CAPITALIZE_WORDS for\n  TEXTINPUT_TYPE_TEXT_NAME, and CAPITALIZE_NONE for e-mail\n  addresses, usernames, and passwords.\n- `prop::TextInput.AUTOCORRECT_BOOLEAN` - true to enable auto completion\n  and auto correction, defaults to true.\n- `prop::TextInput.MULTILINE_BOOLEAN` - true if multiple lines of text\n  are allowed. This defaults to true if SDL_HINT_RETURN_KEY_HIDES_IME is\n  \"0\" or is not set, and defaults to false if SDL_HINT_RETURN_KEY_HIDES_IME\n  is \"1\".\n\nOn Android you can directly specify the input type:\n\n- `prop::TextInput.ANDROID_INPUTTYPE_NUMBER` - the text input type to\n  use, overriding other properties. This is documented at\n  https://developer.android.com/reference/android/text/InputType\n\n@param window the window to enable text input.\n@param props the properties to use.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase<T>::SetTextInputArea\n@sa WindowBase<T>::StartTextInput\n@sa WindowBase<T>::StopTextInput\n@sa WindowBase<T>::IsTextInputActive",
            "name": "WindowBase<T>::StartTextInput",
            "kind": "function",
            "type": "bool",
            "parameters": [
              {
                "name": "props",
                "type": "PropertiesRef"
              }
            ],
            "sourceName": "SDL_StartTextInputWithProperties",
            "template": [
              {
                "type": "ObjectBox<SDL_Window *>",
                "name": "T"
              }
            ]
          }
        ],
        "TextInputType": {
          "doc": "Text input type.\n\nThese are the valid values for SDL_PROP_TEXTINPUT_TYPE_NUMBER. Not every\nvalue is valid on every platform, but where a value isn't supported, a\nreasonable fallback will be used.\n\n@since This enum is available since SDL 3.2.0.\n\n@sa WindowBase<T>::StartTextInput",
          "name": "TextInputType",
          "kind": "alias",
          "sourceName": "SDL_TextInputType",
          "type": "SDL_TextInputType"
        },
        "TEXTINPUT_TYPE_TEXT": {
          "doc": "The input is text.",
          "name": "TEXTINPUT_TYPE_TEXT",
          "kind": "var",
          "type": "TextInputType",
          "sourceName": "SDL_TEXTINPUT_TYPE_TEXT",
          "constexpr": true
        },
        "TEXTINPUT_TYPE_TEXT_NAME": {
          "doc": "The input is a person's name.",
          "name": "TEXTINPUT_TYPE_TEXT_NAME",
          "kind": "var",
          "type": "TextInputType",
          "sourceName": "SDL_TEXTINPUT_TYPE_TEXT_NAME",
          "constexpr": true
        },
        "TEXTINPUT_TYPE_TEXT_EMAIL": {
          "doc": "The input is an e-mail address.",
          "name": "TEXTINPUT_TYPE_TEXT_EMAIL",
          "kind": "var",
          "type": "TextInputType",
          "sourceName": "SDL_TEXTINPUT_TYPE_TEXT_EMAIL",
          "constexpr": true
        },
        "TEXTINPUT_TYPE_TEXT_USERNAME": {
          "doc": "The input is a username.",
          "name": "TEXTINPUT_TYPE_TEXT_USERNAME",
          "kind": "var",
          "type": "TextInputType",
          "sourceName": "SDL_TEXTINPUT_TYPE_TEXT_USERNAME",
          "constexpr": true
        },
        "TEXTINPUT_TYPE_TEXT_PASSWORD_HIDDEN": {
          "doc": "The input is a secure password that is hidden.",
          "name": "TEXTINPUT_TYPE_TEXT_PASSWORD_HIDDEN",
          "kind": "var",
          "type": "TextInputType",
          "sourceName": "SDL_TEXTINPUT_TYPE_TEXT_PASSWORD_HIDDEN",
          "constexpr": true
        },
        "TEXTINPUT_TYPE_TEXT_PASSWORD_VISIBLE": {
          "doc": "The input is a secure password that is visible.",
          "name": "TEXTINPUT_TYPE_TEXT_PASSWORD_VISIBLE",
          "kind": "var",
          "type": "TextInputType",
          "sourceName": "SDL_TEXTINPUT_TYPE_TEXT_PASSWORD_VISIBLE",
          "constexpr": true
        },
        "TEXTINPUT_TYPE_NUMBER": {
          "doc": "The input is a number.",
          "name": "TEXTINPUT_TYPE_NUMBER",
          "kind": "var",
          "type": "TextInputType",
          "sourceName": "SDL_TEXTINPUT_TYPE_NUMBER",
          "constexpr": true
        },
        "TEXTINPUT_TYPE_NUMBER_PASSWORD_HIDDEN": {
          "doc": "The input is a secure PIN that is hidden.",
          "name": "TEXTINPUT_TYPE_NUMBER_PASSWORD_HIDDEN",
          "kind": "var",
          "type": "TextInputType",
          "sourceName": "SDL_TEXTINPUT_TYPE_NUMBER_PASSWORD_HIDDEN",
          "constexpr": true
        },
        "TEXTINPUT_TYPE_NUMBER_PASSWORD_VISIBLE": {
          "doc": "The input is a secure PIN that is visible.",
          "name": "TEXTINPUT_TYPE_NUMBER_PASSWORD_VISIBLE",
          "kind": "var",
          "type": "TextInputType",
          "sourceName": "SDL_TEXTINPUT_TYPE_NUMBER_PASSWORD_VISIBLE",
          "constexpr": true
        },
        "Capitalization": {
          "doc": "Auto capitalization type.\n\nThese are the valid values for prop::TextInput.CAPITALIZATION_NUMBER.\nNot every value is valid on every platform, but where a value isn't\nsupported, a reasonable fallback will be used.\n\n@since This enum is available since SDL 3.2.0.\n\n@sa WindowBase<T>::StartTextInput",
          "name": "Capitalization",
          "kind": "alias",
          "sourceName": "SDL_Capitalization",
          "type": "SDL_Capitalization"
        },
        "CAPITALIZE_NONE": {
          "doc": "No auto-capitalization will be done.",
          "name": "CAPITALIZE_NONE",
          "kind": "var",
          "type": "Capitalization",
          "sourceName": "SDL_CAPITALIZE_NONE",
          "constexpr": true
        },
        "CAPITALIZE_SENTENCES": {
          "doc": "The first letter of sentences will be capitalized.",
          "name": "CAPITALIZE_SENTENCES",
          "kind": "var",
          "type": "Capitalization",
          "sourceName": "SDL_CAPITALIZE_SENTENCES",
          "constexpr": true
        },
        "CAPITALIZE_WORDS": {
          "doc": "The first letter of words will be capitalized.",
          "name": "CAPITALIZE_WORDS",
          "kind": "var",
          "type": "Capitalization",
          "sourceName": "SDL_CAPITALIZE_WORDS",
          "constexpr": true
        },
        "CAPITALIZE_LETTERS": {
          "doc": "All letters will be capitalized.",
          "name": "CAPITALIZE_LETTERS",
          "kind": "var",
          "type": "Capitalization",
          "sourceName": "SDL_CAPITALIZE_LETTERS",
          "constexpr": true
        },
        "prop::TextInput": {
          "kind": "ns",
          "name": "prop::TextInput",
          "entries": {
            "TYPE_NUMBER": {
              "doc": "",
              "name": "TYPE_NUMBER",
              "kind": "var",
              "value": "\"SDL.textinput.type\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTINPUT_TYPE_NUMBER"
            },
            "CAPITALIZATION_NUMBER": {
              "doc": "",
              "name": "CAPITALIZATION_NUMBER",
              "kind": "var",
              "value": "\"SDL.textinput.capitalization\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTINPUT_CAPITALIZATION_NUMBER"
            },
            "AUTOCORRECT_BOOLEAN": {
              "doc": "",
              "name": "AUTOCORRECT_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.textinput.autocorrect\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTINPUT_AUTOCORRECT_BOOLEAN"
            },
            "MULTILINE_BOOLEAN": {
              "doc": "",
              "name": "MULTILINE_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.textinput.multiline\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTINPUT_MULTILINE_BOOLEAN"
            },
            "ANDROID_INPUTTYPE_NUMBER": {
              "doc": "",
              "name": "ANDROID_INPUTTYPE_NUMBER",
              "kind": "var",
              "value": "\"SDL.textinput.android.inputtype\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_TEXTINPUT_ANDROID_INPUTTYPE_NUMBER"
            }
          },
          "doc": ""
        },
        "WindowBase<T>::IsTextInputActive": {
          "doc": "Check whether or not Unicode text input events are enabled for a window.\n\n@param window the window to check.\n@returns true if text input events are enabled else false.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase<T>::StartTextInput",
          "name": "WindowBase<T>::IsTextInputActive",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_TextInputActive",
          "immutable": true,
          "template": [
            {
              "type": "ObjectBox<SDL_Window *>",
              "name": "T"
            }
          ]
        },
        "WindowBase<T>::StopTextInput": {
          "doc": "Stop receiving any text input events in a window.\n\nIf WindowBase<T>::StartTextInput() showed the screen keyboard, this function will hide\nit.\n\n@param window the window to disable text input.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase<T>::StartTextInput",
          "name": "WindowBase<T>::StopTextInput",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_StopTextInput",
          "template": [
            {
              "type": "ObjectBox<SDL_Window *>",
              "name": "T"
            }
          ]
        },
        "WindowBase<T>::ClearComposition": {
          "doc": "Dismiss the composition window/IME without disabling the subsystem.\n\n@param window the window to affect.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase<T>::StartTextInput\n@sa WindowBase<T>::StopTextInput",
          "name": "WindowBase<T>::ClearComposition",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_ClearComposition",
          "template": [
            {
              "type": "ObjectBox<SDL_Window *>",
              "name": "T"
            }
          ]
        },
        "WindowBase<T>::SetTextInputArea": {
          "doc": "Set the area used to type Unicode text input.\n\nNative input methods may place a window with word suggestions near the\ncursor, without covering the text being entered.\n\n@param window the window for which to set the text input area.\n@param rect the Rect representing the text input area, in window\n            coordinates, or nullptr to clear it.\n@param cursor the offset of the current cursor location relative to\n              `rect->x`, in window coordinates.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase<T>::GetTextInputArea\n@sa WindowBase<T>::StartTextInput",
          "name": "WindowBase<T>::SetTextInputArea",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "rect",
              "type": "const SDL_Rect &"
            },
            {
              "name": "cursor",
              "type": "int"
            }
          ],
          "sourceName": "SDL_SetTextInputArea",
          "template": [
            {
              "type": "ObjectBox<SDL_Window *>",
              "name": "T"
            }
          ]
        },
        "WindowBase<T>::GetTextInputArea": {
          "doc": "Get the area used to type Unicode text input.\n\nThis returns the values previously set by WindowBase<T>::SetTextInputArea().\n\n@param window the window for which to query the text input area.\n@param rect a pointer to an Rect filled in with the text input area,\n            may be nullptr.\n@param cursor a pointer to the offset of the current cursor location\n              relative to `rect->x`, may be nullptr.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase<T>::SetTextInputArea",
          "name": "WindowBase<T>::GetTextInputArea",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "rect",
              "type": "SDL_Rect *"
            },
            {
              "name": "cursor",
              "type": "int *"
            }
          ],
          "sourceName": "SDL_GetTextInputArea",
          "template": [
            {
              "type": "ObjectBox<SDL_Window *>",
              "name": "T"
            }
          ]
        },
        "HasScreenKeyboardSupport": {
          "doc": "Check whether the platform has screen keyboard support.\n\n@returns true if the platform has some screen keyboard support or false if\n         not.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa WindowBase<T>::StartTextInput\n@sa ScreenKeyboardShown",
          "name": "HasScreenKeyboardSupport",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_HasScreenKeyboardSupport"
        },
        "ScreenKeyboardShown": {
          "doc": "Check whether the screen keyboard is shown for given window.\n\n@param window the window for which screen keyboard should be queried.\n@returns true if screen keyboard is shown or false if not.\n\n@threadsafety This function should only be called on the main thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa HasScreenKeyboardSupport",
          "name": "ScreenKeyboardShown",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "window",
              "type": "WindowRef"
            }
          ],
          "sourceName": "SDL_ScreenKeyboardShown"
        }
      }
    },
    "SDL3pp_platform.h": {
      "name": "SDL3pp_platform.h",
      "doc": "@defgroup CategoryPlatform Category Platform\n\nSDL provides a means to identify the app's platform, both at compile time\nand runtime.",
      "entries": {
        "GetPlatform": {
          "doc": "Get the name of the platform.\n\nHere are the names returned for some (but not all) supported platforms:\n\n- \"Windows\"\n- \"macOS\"\n- \"Linux\"\n- \"iOS\"\n- \"Android\"\n\n@returns the name of the platform. If the correct platform name is not\n         available, returns a string beginning with the text \"Unknown\".\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetPlatform",
          "kind": "function",
          "type": "const char *",
          "parameters": [],
          "sourceName": "SDL_GetPlatform"
        }
      }
    },
    "SDL3pp_cpuinfo.h": {
      "name": "SDL3pp_cpuinfo.h",
      "doc": "@defgroup CategoryCPUInfo Category CPUInfo\n\nCPU feature detection for SDL.\n\nThese functions are largely concerned with reporting if the system has\naccess to various SIMD instruction sets, but also has other important info\nto share, such as system RAM size and number of logical CPU cores.\n\nCPU instruction set checks, like HasSSE() and HasNEON(), are\navailable on all platforms, even if they don't make sense (an ARM processor\nwill never have SSE and an x86 processor will never have NEON, for example,\nbut these functions still exist and will simply return false in these\ncases).",
      "entries": {
        "CACHELINE_SIZE": {
          "doc": "A guess for the cacheline size used for padding.\n\nMost x86 processors have a 64 byte cache line. The 64-bit PowerPC\nprocessors have a 128 byte cache line. We use the larger value to be\ngenerally safe.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "CACHELINE_SIZE",
          "kind": "var",
          "value": "128",
          "sourceName": "SDL_CACHELINE_SIZE",
          "type": "int",
          "constexpr": true
        },
        "GetNumLogicalCPUCores": {
          "doc": "Get the number of logical CPU cores available.\n\n@returns the total number of logical CPU cores. On CPUs that include\n         technologies such as hyperthreading, the number of logical cores\n         may be more than the number of physical cores.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetNumLogicalCPUCores",
          "kind": "function",
          "type": "int",
          "parameters": [],
          "sourceName": "SDL_GetNumLogicalCPUCores"
        },
        "GetCPUCacheLineSize": {
          "doc": "Determine the L1 cache line size of the CPU.\n\nThis is useful for determining multi-threaded structure padding or SIMD\nprefetch sizes.\n\n@returns the L1 cache line size of the CPU, in bytes.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetCPUCacheLineSize",
          "kind": "function",
          "type": "int",
          "parameters": [],
          "sourceName": "SDL_GetCPUCacheLineSize"
        },
        "HasAltiVec": {
          "doc": "Determine whether the CPU has AltiVec features.\n\nThis always returns false on CPUs that aren't using PowerPC instruction\nsets.\n\n@returns true if the CPU has AltiVec features or false if not.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "HasAltiVec",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_HasAltiVec"
        },
        "HasMMX": {
          "doc": "Determine whether the CPU has MMX features.\n\nThis always returns false on CPUs that aren't using Intel instruction sets.\n\n@returns true if the CPU has MMX features or false if not.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "HasMMX",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_HasMMX"
        },
        "HasSSE": {
          "doc": "Determine whether the CPU has SSE features.\n\nThis always returns false on CPUs that aren't using Intel instruction sets.\n\n@returns true if the CPU has SSE features or false if not.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa HasSSE2\n@sa HasSSE3\n@sa HasSSE41\n@sa HasSSE42",
          "name": "HasSSE",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_HasSSE"
        },
        "HasSSE2": {
          "doc": "Determine whether the CPU has SSE2 features.\n\nThis always returns false on CPUs that aren't using Intel instruction sets.\n\n@returns true if the CPU has SSE2 features or false if not.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa HasSSE\n@sa HasSSE3\n@sa HasSSE41\n@sa HasSSE42",
          "name": "HasSSE2",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_HasSSE2"
        },
        "HasSSE3": {
          "doc": "Determine whether the CPU has SSE3 features.\n\nThis always returns false on CPUs that aren't using Intel instruction sets.\n\n@returns true if the CPU has SSE3 features or false if not.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa HasSSE\n@sa HasSSE2\n@sa HasSSE41\n@sa HasSSE42",
          "name": "HasSSE3",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_HasSSE3"
        },
        "HasSSE41": {
          "doc": "Determine whether the CPU has SSE4.1 features.\n\nThis always returns false on CPUs that aren't using Intel instruction sets.\n\n@returns true if the CPU has SSE4.1 features or false if not.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa HasSSE\n@sa HasSSE2\n@sa HasSSE3\n@sa HasSSE42",
          "name": "HasSSE41",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_HasSSE41"
        },
        "HasSSE42": {
          "doc": "Determine whether the CPU has SSE4.2 features.\n\nThis always returns false on CPUs that aren't using Intel instruction sets.\n\n@returns true if the CPU has SSE4.2 features or false if not.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa HasSSE\n@sa HasSSE2\n@sa HasSSE3\n@sa HasSSE41",
          "name": "HasSSE42",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_HasSSE42"
        },
        "HasAVX": {
          "doc": "Determine whether the CPU has AVX features.\n\nThis always returns false on CPUs that aren't using Intel instruction sets.\n\n@returns true if the CPU has AVX features or false if not.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa HasAVX2\n@sa HasAVX512F",
          "name": "HasAVX",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_HasAVX"
        },
        "HasAVX2": {
          "doc": "Determine whether the CPU has AVX2 features.\n\nThis always returns false on CPUs that aren't using Intel instruction sets.\n\n@returns true if the CPU has AVX2 features or false if not.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa HasAVX\n@sa HasAVX512F",
          "name": "HasAVX2",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_HasAVX2"
        },
        "HasAVX512F": {
          "doc": "Determine whether the CPU has AVX-512F (foundation) features.\n\nThis always returns false on CPUs that aren't using Intel instruction sets.\n\n@returns true if the CPU has AVX-512F features or false if not.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa HasAVX\n@sa HasAVX2",
          "name": "HasAVX512F",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_HasAVX512F"
        },
        "HasARMSIMD": {
          "doc": "Determine whether the CPU has ARM SIMD (ARMv6) features.\n\nThis is different from ARM NEON, which is a different instruction set.\n\nThis always returns false on CPUs that aren't using ARM instruction sets.\n\n@returns true if the CPU has ARM SIMD features or false if not.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa HasNEON",
          "name": "HasARMSIMD",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_HasARMSIMD"
        },
        "HasNEON": {
          "doc": "Determine whether the CPU has NEON (ARM SIMD) features.\n\nThis always returns false on CPUs that aren't using ARM instruction sets.\n\n@returns true if the CPU has ARM NEON features or false if not.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "HasNEON",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_HasNEON"
        },
        "HasLSX": {
          "doc": "Determine whether the CPU has LSX (LOONGARCH SIMD) features.\n\nThis always returns false on CPUs that aren't using LOONGARCH instruction\nsets.\n\n@returns true if the CPU has LOONGARCH LSX features or false if not.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "HasLSX",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_HasLSX"
        },
        "HasLASX": {
          "doc": "Determine whether the CPU has LASX (LOONGARCH SIMD) features.\n\nThis always returns false on CPUs that aren't using LOONGARCH instruction\nsets.\n\n@returns true if the CPU has LOONGARCH LASX features or false if not.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "HasLASX",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_HasLASX"
        },
        "GetSystemRAM": {
          "doc": "Get the amount of RAM configured in the system.\n\n@returns the amount of RAM configured in the system in MiB.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetSystemRAM",
          "kind": "function",
          "type": "int",
          "parameters": [],
          "sourceName": "SDL_GetSystemRAM"
        },
        "GetSIMDAlignment": {
          "doc": "Report the alignment this system needs for SIMD allocations.\n\nThis will return the minimum number of bytes to which a pointer must be\naligned to be compatible with SIMD instructions on the current machine. For\nexample, if the machine supports SSE only, it will return 16, but if it\nsupports AVX-512F, it'll return 64 (etc). This only reports values for\ninstruction sets SDL knows about, so if your SDL build doesn't have\nHasAVX512F(), then it might return 16 for the SSE support it sees and\nnot 64 for the AVX-512 instructions that exist but SDL doesn't know about.\nPlan accordingly.\n\n@returns the alignment in bytes needed for available, known SIMD\n         instructions.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa aligned_alloc\n@sa aligned_free",
          "name": "GetSIMDAlignment",
          "kind": "function",
          "type": "size_t",
          "parameters": [],
          "sourceName": "SDL_GetSIMDAlignment"
        }
      }
    },
    "SDL3pp_intrin.h": {
      "name": "SDL3pp_intrin.h",
      "doc": "@defgroup CategoryIntrinsics Category Intrinsics\n\nSDL does some preprocessor gymnastics to determine if any CPU-specific\ncompiler intrinsics are available, as this is not necessarily an easy thing\nto calculate, and sometimes depends on quirks of a system, versions of\nbuild tools, and other external forces.\n\nApps including SDL's headers will be able to check consistent preprocessor\ndefinitions to decide if it's safe to use compiler intrinsics for a\nspecific CPU architecture. This check only tells you that the compiler is\ncapable of using those intrinsics; at runtime, you should still check if\nthey are available on the current system with the\n[CPU info functions](https://wiki.libsdl.org/SDL3/CategoryCPUInfo)\n, such as HasSSE() or HasNEON(). Otherwise, the process might crash\nfor using an unsupported CPU instruction.\n\nSDL only sets preprocessor defines for CPU intrinsics if they are\nsupported, so apps should check with `#ifdef` and not `#if`.\n\nSDL will also include the appropriate instruction-set-specific support\nheaders, so if SDL decides to define SDL_SSE2_INTRINSICS, it will also\n`#include <emmintrin.h>` as well.",
      "entries": {
        "SDL_LSX_INTRINSICS": {
          "doc": "Defined if (and only if) the compiler supports Loongarch LSX intrinsics.\n\nIf this macro is defined, SDL will have already included `<lsxintrin.h>`\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_LASX_INTRINSICS",
          "name": "SDL_LSX_INTRINSICS",
          "kind": "def",
          "value": "1",
          "sourceName": "SDL_LSX_INTRINSICS"
        },
        "SDL_LASX_INTRINSICS": {
          "doc": "Defined if (and only if) the compiler supports Loongarch LSX intrinsics.\n\nIf this macro is defined, SDL will have already included `<lasxintrin.h>`\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_LASX_INTRINSICS",
          "name": "SDL_LASX_INTRINSICS",
          "kind": "def",
          "value": "1",
          "sourceName": "SDL_LASX_INTRINSICS"
        },
        "SDL_NEON_INTRINSICS": {
          "doc": "Defined if (and only if) the compiler supports ARM NEON intrinsics.\n\nIf this macro is defined, SDL will have already included `<armintr.h>`\n`<arm_neon.h>`, `<arm64intr.h>`, and `<arm64_neon.h>`, as appropriate.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_NEON_INTRINSICS",
          "kind": "def",
          "value": "1",
          "sourceName": "SDL_NEON_INTRINSICS"
        },
        "SDL_ALTIVEC_INTRINSICS": {
          "doc": "Defined if (and only if) the compiler supports PowerPC Altivec intrinsics.\n\nIf this macro is defined, SDL will have already included `<altivec.h>`\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_ALTIVEC_INTRINSICS",
          "kind": "def",
          "value": "1",
          "sourceName": "SDL_ALTIVEC_INTRINSICS"
        },
        "SDL_MMX_INTRINSICS": {
          "doc": "Defined if (and only if) the compiler supports Intel MMX intrinsics.\n\nIf this macro is defined, SDL will have already included `<mmintrin.h>`\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_SSE_INTRINSICS",
          "name": "SDL_MMX_INTRINSICS",
          "kind": "def",
          "value": "1",
          "sourceName": "SDL_MMX_INTRINSICS"
        },
        "SDL_SSE_INTRINSICS": {
          "doc": "Defined if (and only if) the compiler supports Intel SSE intrinsics.\n\nIf this macro is defined, SDL will have already included `<xmmintrin.h>`\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_SSE2_INTRINSICS\n@sa SDL_SSE3_INTRINSICS\n@sa SDL_SSE4_1_INTRINSICS\n@sa SDL_SSE4_2_INTRINSICS",
          "name": "SDL_SSE_INTRINSICS",
          "kind": "def",
          "value": "1",
          "sourceName": "SDL_SSE_INTRINSICS"
        },
        "SDL_SSE2_INTRINSICS": {
          "doc": "Defined if (and only if) the compiler supports Intel SSE2 intrinsics.\n\nIf this macro is defined, SDL will have already included `<emmintrin.h>`\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_SSE_INTRINSICS\n@sa SDL_SSE3_INTRINSICS\n@sa SDL_SSE4_1_INTRINSICS\n@sa SDL_SSE4_2_INTRINSICS",
          "name": "SDL_SSE2_INTRINSICS",
          "kind": "def",
          "value": "1",
          "sourceName": "SDL_SSE2_INTRINSICS"
        },
        "SDL_SSE3_INTRINSICS": {
          "doc": "Defined if (and only if) the compiler supports Intel SSE3 intrinsics.\n\nIf this macro is defined, SDL will have already included `<pmmintrin.h>`\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_SSE_INTRINSICS\n@sa SDL_SSE2_INTRINSICS\n@sa SDL_SSE4_1_INTRINSICS\n@sa SDL_SSE4_2_INTRINSICS",
          "name": "SDL_SSE3_INTRINSICS",
          "kind": "def",
          "value": "1",
          "sourceName": "SDL_SSE3_INTRINSICS"
        },
        "SDL_SSE4_1_INTRINSICS": {
          "doc": "Defined if (and only if) the compiler supports Intel SSE4.1 intrinsics.\n\nIf this macro is defined, SDL will have already included `<smmintrin.h>`\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_SSE_INTRINSICS\n@sa SDL_SSE2_INTRINSICS\n@sa SDL_SSE3_INTRINSICS\n@sa SDL_SSE4_2_INTRINSICS",
          "name": "SDL_SSE4_1_INTRINSICS",
          "kind": "def",
          "value": "1",
          "sourceName": "SDL_SSE4_1_INTRINSICS"
        },
        "SDL_SSE4_2_INTRINSICS": {
          "doc": "Defined if (and only if) the compiler supports Intel SSE4.2 intrinsics.\n\nIf this macro is defined, SDL will have already included `<nmmintrin.h>`\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_SSE_INTRINSICS\n@sa SDL_SSE2_INTRINSICS\n@sa SDL_SSE3_INTRINSICS\n@sa SDL_SSE4_1_INTRINSICS",
          "name": "SDL_SSE4_2_INTRINSICS",
          "kind": "def",
          "value": "1",
          "sourceName": "SDL_SSE4_2_INTRINSICS"
        },
        "SDL_AVX_INTRINSICS": {
          "doc": "Defined if (and only if) the compiler supports Intel AVX intrinsics.\n\nIf this macro is defined, SDL will have already included `<immintrin.h>`\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_AVX2_INTRINSICS\n@sa SDL_AVX512F_INTRINSICS",
          "name": "SDL_AVX_INTRINSICS",
          "kind": "def",
          "value": "1",
          "sourceName": "SDL_AVX_INTRINSICS"
        },
        "SDL_AVX2_INTRINSICS": {
          "doc": "Defined if (and only if) the compiler supports Intel AVX2 intrinsics.\n\nIf this macro is defined, SDL will have already included `<immintrin.h>`\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_AVX_INTRINSICS\n@sa SDL_AVX512F_INTRINSICS",
          "name": "SDL_AVX2_INTRINSICS",
          "kind": "def",
          "value": "1",
          "sourceName": "SDL_AVX2_INTRINSICS"
        },
        "SDL_AVX512F_INTRINSICS": {
          "doc": "Defined if (and only if) the compiler supports Intel AVX-512F intrinsics.\n\nAVX-512F is also sometimes referred to as \"AVX-512 Foundation.\"\n\nIf this macro is defined, SDL will have already included `<immintrin.h>`\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_AVX_INTRINSICS\n@sa SDL_AVX2_INTRINSICS",
          "name": "SDL_AVX512F_INTRINSICS",
          "kind": "def",
          "value": "1",
          "sourceName": "SDL_AVX512F_INTRINSICS"
        },
        "SDL_HAS_TARGET_ATTRIBS": {
          "doc": "A macro to decide if the compiler supports `__attribute__((target))`.\n\nEven though this is defined in SDL's public headers, it is generally not\nused directly by apps. Apps should probably just use SDL_TARGETING\ndirectly, instead.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_TARGETING",
          "name": "SDL_HAS_TARGET_ATTRIBS",
          "kind": "def",
          "sourceName": "SDL_HAS_TARGET_ATTRIBS"
        },
        "SDL_TARGETING": {
          "doc": "A macro to tag a function as targeting a specific CPU architecture.\n\nThis is a hint to the compiler that a function should be built with support\nfor a CPU instruction set that might be different than the rest of the\nprogram.\n\nThe particulars of this are explained in the GCC documentation:\n\nhttps://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-target-function-attribute\n\nAn example of using this feature is to turn on SSE2 support for a specific\nfunction, even if the rest of the source code is not compiled to use SSE2\ncode:\n\n```c\n#ifdef SDL_SSE2_INTRINSICS\nstatic void SDL_TARGETING(\"sse2\") DoSomethingWithSSE2(char *x) {\n   ...use SSE2 intrinsic functions, etc...\n}\n#endif\n\n// later...\n#ifdef SDL_SSE2_INTRINSICS\nif (HasSSE2()) {\n    DoSomethingWithSSE2(str);\n}\n#endif\n```\n\nThe application is, on a whole, built without SSE2 instructions, so it will\nrun on Intel machines that don't support SSE2. But then at runtime, it\nchecks if the system supports the instructions, and then calls into a\nfunction that uses SSE2 opcodes. The ifdefs make sure that this code isn't\nused on platforms that don't have SSE2 at all.\n\nOn compilers without target support, this is defined to nothing.\n\nThis symbol is used by SDL internally, but apps and other libraries are\nwelcome to use it for their own interfaces as well.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_TARGETING",
          "kind": "def",
          "parameters": [
            "x"
          ],
          "value": "__attribute__((target(x)))",
          "sourceName": "SDL_TARGETING"
        }
      }
    },
    "SDL3pp_endian.h": {
      "name": "SDL3pp_endian.h",
      "doc": "@defgroup CategoryEndian Category Endian\n\nFunctions converting endian-specific values to different byte orders.\n\nThese functions either unconditionally swap byte order (Swap16,\nSwap32, Swap64, SwapFloat), or they swap to/from the system's\nnative byte order (Swap16LE, Swap16BE, Swap32LE, Swap32BE,\nSwap32LE, Swap32BE, SwapFloatLE, SwapFloatBE). In the\nlatter case, the functionality is provided by macros that become no-ops if\na swap isn't necessary: on an x86 (littleendian) processor, Swap32LE\ndoes nothing, but Swap32BE reverses the bytes of the data. On a PowerPC\nprocessor (bigendian), the macros behavior is reversed.\n\nThe swap routines are inline functions, and attempt to use compiler\nintrinsics, inline assembly, and other magic to make byteswapping\nefficient.",
      "entries": {
        "SDL_LIL_ENDIAN": {
          "doc": "A value to represent littleendian byteorder.\n\nThis is used with the preprocessor macro SDL_BYTEORDER, to determine a\nplatform's byte ordering:\n\n```c\n#if SDL_BYTEORDER == SDL_LIL_ENDIAN\nLog(\"This system is littleendian.\");\n#endif\n```\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_BYTEORDER\n@sa SDL_BIG_ENDIAN",
          "name": "SDL_LIL_ENDIAN",
          "kind": "def",
          "value": "1234",
          "sourceName": "SDL_LIL_ENDIAN"
        },
        "SDL_BIG_ENDIAN": {
          "doc": "A value to represent bigendian byteorder.\n\nThis is used with the preprocessor macro SDL_BYTEORDER, to determine a\nplatform's byte ordering:\n\n```c\n#if SDL_BYTEORDER == SDL_BIG_ENDIAN\nLog(\"This system is bigendian.\");\n#endif\n```\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_BYTEORDER\n@sa SDL_LIL_ENDIAN",
          "name": "SDL_BIG_ENDIAN",
          "kind": "def",
          "value": "4321",
          "sourceName": "SDL_BIG_ENDIAN"
        },
        "SDL_BYTEORDER": {
          "doc": "A macro that reports the target system's byte order.\n\nThis is set to either SDL_LIL_ENDIAN or SDL_BIG_ENDIAN (and maybe other\nvalues in the future, if something else becomes popular). This can be\ntested with the preprocessor, so decisions can be made at compile time.\n\n```c\n#if SDL_BYTEORDER == SDL_BIG_ENDIAN\nLog(\"This system is bigendian.\");\n#endif\n```\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_LIL_ENDIAN\n@sa SDL_BIG_ENDIAN",
          "name": "SDL_BYTEORDER",
          "kind": "def",
          "value": "SDL_LIL_ENDIAN___or_maybe___SDL_BIG_ENDIAN",
          "sourceName": "SDL_BYTEORDER"
        },
        "SDL_FLOATWORDORDER": {
          "doc": "A macro that reports the target system's floating point word order.\n\nThis is set to either SDL_LIL_ENDIAN or SDL_BIG_ENDIAN (and maybe other\nvalues in the future, if something else becomes popular). This can be\ntested with the preprocessor, so decisions can be made at compile time.\n\n```c\n#if SDL_FLOATWORDORDER == SDL_BIG_ENDIAN\nLog(\"This system's floats are bigendian.\");\n#endif\n```\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_LIL_ENDIAN\n@sa SDL_BIG_ENDIAN",
          "name": "SDL_FLOATWORDORDER",
          "kind": "def",
          "value": "SDL_LIL_ENDIAN___or_maybe___SDL_BIG_ENDIAN",
          "sourceName": "SDL_FLOATWORDORDER"
        },
        "SwapFloat": {
          "doc": "Byte-swap a floating point number.\n\nThis will always byte-swap the value, whether it's currently in the native\nbyteorder of the system or not. You should use SwapFloatLE or\nSwapFloatBE instead, in most cases.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param x the value to byte-swap.\n@returns x, with its bytes in the opposite endian order.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "SwapFloat",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "x",
              "type": "float"
            }
          ],
          "sourceName": "SDL_SwapFloat"
        },
        "Swap16": {
          "doc": "Byte-swap an unsigned 16-bit number.\n\nThis will always byte-swap the value, whether it's currently in the native\nbyteorder of the system or not. You should use Swap16LE or Swap16BE\ninstead, in most cases.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param x the value to byte-swap.\n@returns `x`, with its bytes in the opposite endian order.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "Swap16",
          "kind": "function",
          "type": "Uint16",
          "parameters": [
            {
              "name": "x",
              "type": "Uint16"
            }
          ],
          "sourceName": "SDL_Swap16"
        },
        "Swap32": {
          "doc": "Byte-swap an unsigned 32-bit number.\n\nThis will always byte-swap the value, whether it's currently in the native\nbyteorder of the system or not. You should use Swap32LE or Swap32BE\ninstead, in most cases.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param x the value to byte-swap.\n@returns `x`, with its bytes in the opposite endian order.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "Swap32",
          "kind": "function",
          "type": "Uint32",
          "parameters": [
            {
              "name": "x",
              "type": "Uint32"
            }
          ],
          "sourceName": "SDL_Swap32"
        },
        "Swap64": {
          "doc": "Byte-swap an unsigned 64-bit number.\n\nThis will always byte-swap the value, whether it's currently in the native\nbyteorder of the system or not. You should use Swap64LE or Swap64BE\ninstead, in most cases.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param x the value to byte-swap.\n@returns `x`, with its bytes in the opposite endian order.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "Swap64",
          "kind": "function",
          "type": "Uint32",
          "parameters": [
            {
              "name": "x",
              "type": "Uint64"
            }
          ],
          "sourceName": "SDL_Swap64"
        },
        "Swap16LE": {
          "doc": "Swap a 16-bit value from littleendian to native byte order.\n\nIf this is running on a littleendian system, `x` is returned unchanged.\n\nThis macro never references `x` more than once, avoiding side effects.\n\n@param x the value to swap, in littleendian byte order.\n@returns `x` in native byte order.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "Swap16LE",
          "kind": "function",
          "parameters": [
            {
              "type": "Uint16",
              "name": "x"
            }
          ],
          "value": "SwapOnlyIfNecessary(x)",
          "sourceName": "SDL_Swap16LE",
          "type": "Uint16",
          "constexpr": true
        },
        "Swap32LE": {
          "doc": "Swap a 32-bit value from littleendian to native byte order.\n\nIf this is running on a littleendian system, `x` is returned unchanged.\n\nThis macro never references `x` more than once, avoiding side effects.\n\n@param x the value to swap, in littleendian byte order.\n@returns `x` in native byte order.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "Swap32LE",
          "kind": "function",
          "parameters": [
            {
              "type": "Uint32",
              "name": "x"
            }
          ],
          "value": "SwapOnlyIfNecessary(x)",
          "sourceName": "SDL_Swap32LE",
          "type": "Uint32",
          "constexpr": true
        },
        "Swap64LE": {
          "doc": "Swap a 64-bit value from littleendian to native byte order.\n\nIf this is running on a littleendian system, `x` is returned unchanged.\n\nThis macro never references `x` more than once, avoiding side effects.\n\n@param x the value to swap, in littleendian byte order.\n@returns `x` in native byte order.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "Swap64LE",
          "kind": "function",
          "parameters": [
            {
              "type": "Uint64",
              "name": "x"
            }
          ],
          "value": "SwapOnlyIfNecessary(x)",
          "sourceName": "SDL_Swap64LE",
          "type": "Uint64",
          "constexpr": true
        },
        "SwapFloatLE": {
          "doc": "Swap a floating point value from littleendian to native byte order.\n\nIf this is running on a littleendian system, `x` is returned unchanged.\n\nThis macro never references `x` more than once, avoiding side effects.\n\n@param x the value to swap, in littleendian byte order.\n@returns `x` in native byte order.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SwapFloatLE",
          "kind": "function",
          "parameters": [
            {
              "type": "float",
              "name": "x"
            }
          ],
          "value": "SwapOnlyIfNecessary(x)",
          "sourceName": "SDL_SwapFloatLE",
          "type": "float",
          "constexpr": true
        },
        "Swap16BE": {
          "doc": "Swap a 16-bit value from bigendian to native byte order.\n\nIf this is running on a bigendian system, `x` is returned unchanged.\n\nThis macro never references `x` more than once, avoiding side effects.\n\n@param x the value to swap, in bigendian byte order.\n@returns `x` in native byte order.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "Swap16BE",
          "kind": "function",
          "parameters": [
            {
              "type": "Uint16",
              "name": "x"
            }
          ],
          "value": "SwapOnlyIfNecessary(x)",
          "sourceName": "SDL_Swap16BE",
          "type": "Uint16",
          "constexpr": true
        },
        "Swap32BE": {
          "doc": "Swap a 32-bit value from bigendian to native byte order.\n\nIf this is running on a bigendian system, `x` is returned unchanged.\n\nThis macro never references `x` more than once, avoiding side effects.\n\n@param x the value to swap, in bigendian byte order.\n@returns `x` in native byte order.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "Swap32BE",
          "kind": "function",
          "parameters": [
            {
              "type": "Uint32",
              "name": "x"
            }
          ],
          "value": "SwapOnlyIfNecessary(x)",
          "sourceName": "SDL_Swap32BE",
          "type": "Uint32",
          "constexpr": true
        },
        "Swap64BE": {
          "doc": "Swap a 64-bit value from bigendian to native byte order.\n\nIf this is running on a bigendian system, `x` is returned unchanged.\n\nThis macro never references `x` more than once, avoiding side effects.\n\n@param x the value to swap, in bigendian byte order.\n@returns `x` in native byte order.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "Swap64BE",
          "kind": "function",
          "parameters": [
            {
              "type": "Uint64",
              "name": "x"
            }
          ],
          "value": "SwapOnlyIfNecessary(x)",
          "sourceName": "SDL_Swap64BE",
          "type": "Uint64",
          "constexpr": true
        },
        "SwapFloatBE": {
          "doc": "Swap a floating point value from bigendian to native byte order.\n\nIf this is running on a bigendian system, `x` is returned unchanged.\n\nThis macro never references `x` more than once, avoiding side effects.\n\n@param x the value to swap, in bigendian byte order.\n@returns `x` in native byte order.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SwapFloatBE",
          "kind": "function",
          "parameters": [
            {
              "type": "float",
              "name": "x"
            }
          ],
          "value": "SwapOnlyIfNecessary(x)",
          "sourceName": "SDL_SwapFloatBE",
          "type": "float",
          "constexpr": true
        }
      }
    },
    "SDL3pp_bits.h": {
      "name": "SDL3pp_bits.h",
      "doc": "@defgroup CategoryBits Category Bits\n\nFunctions for fiddling with bits and bitmasks.",
      "entries": {
        "MostSignificantBitIndex32": {
          "doc": "Get the index of the most significant (set) bit in a 32-bit number.\n\nResult is undefined when called with 0. This operation can also be stated\nas \"count leading zeroes\" and \"log base 2\".\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param x the 32-bit value to examine.\n@returns the index of the most significant bit, or -1 if the value is 0.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "MostSignificantBitIndex32",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "Uint32"
            }
          ],
          "sourceName": "SDL_MostSignificantBitIndex32"
        },
        "HasExactlyOneBitSet32": {
          "doc": "Determine if a unsigned 32-bit value has exactly one bit set.\n\nIf there are no bits set (`x` is zero), or more than one bit set, this\nreturns false. If any one bit is exclusively set, this returns true.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param x the 32-bit value to examine.\n@returns true if exactly one bit is set in `x`, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "HasExactlyOneBitSet32",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "x",
              "type": "Uint32"
            }
          ],
          "sourceName": "SDL_HasExactlyOneBitSet32"
        }
      }
    },
    "SDL3pp_loadso.h": {
      "name": "SDL3pp_loadso.h",
      "doc": "@defgroup CategorySharedObject Category SharedObject\n\nSystem-dependent library loading routines.\n\nShared objects are code that is programmatically loadable at runtime.\nWindows calls these \"DLLs\", Linux calls them \"shared libraries\", etc.\n\nTo use them, build such a library, then call SharedObjectBase.SharedObjectBase() on it. Once\nloaded, you can use SharedObjectBase.LoadFunction() on that object to find the address\nof its exported symbols. When done with the object, call SharedObjectBase.Unload()\nto dispose of it.\n\nSome things to keep in mind:\n\n- These functions only work on C function names. Other languages may have\n  name mangling and intrinsic language support that varies from compiler to\n  compiler.\n- Make sure you declare your function pointers with the same calling\n  convention as the actual library function. Your code will crash\n  mysteriously if you do not do this.\n- Avoid namespace collisions. If you load a symbol from the library, it is\n  not defined whether or not it goes into the global symbol namespace for\n  the application. If it does and it conflicts with symbols in your code or\n  other shared libraries, you will not get the results you expect. :)\n- Once a library is unloaded, all pointers into it obtained through\n  SharedObjectBase.LoadFunction() become invalid, even if the library is later reloaded.\n  Don't unload a library if you plan to use these pointers in the future.\n  Notably: beware of giving one of these pointers to atexit(), since it may\n  call that pointer after the library unloads.",
      "entries": {
        "SharedObjectBase-forward": {
          "name": "SharedObjectBase",
          "kind": "forward",
          "template": [
            {
              "type": "ObjectBox<SDL_SharedObject *>",
              "name": "T"
            }
          ],
          "doc": ""
        },
        "SharedObjectRef": {
          "name": "SharedObjectRef",
          "kind": "alias",
          "type": "SharedObjectBase<ObjectRef<SDL_SharedObject>>",
          "doc": "Handle to a non owned sharedObject\n\n@cat resource\n\n@sa SharedObjectBase\n@sa SharedObject"
        },
        "SharedObject": {
          "name": "SharedObject",
          "kind": "alias",
          "type": "SharedObjectBase<ObjectUnique<SDL_SharedObject>>",
          "doc": "Handle to an owned sharedObject\n\n@cat resource\n\n@sa SharedObjectBase\n@sa SharedObjectRef"
        },
        "SharedObjectBase": {
          "doc": "An opaque datatype that represents a loaded shared object.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa SharedObjectBase.SharedObjectBase\n@sa SharedObjectBase.LoadFunction\n@sa SharedObjectBase.Unload",
          "name": "SharedObjectBase",
          "kind": "struct",
          "type": "T",
          "sourceName": "SDL_SharedObject",
          "template": [
            {
              "type": "ObjectBox<SDL_SharedObject *>",
              "name": "T"
            }
          ],
          "entries": {
            "T::T": {
              "kind": "alias",
              "name": "T::T",
              "doc": ""
            },
            "SharedObjectBase": {
              "doc": "Dynamically load a shared object.\n\n@param sofile a system-dependent name of the object file.\n@post an opaque pointer to the object handle or nullptr on failure; call\n         GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SharedObjectBase.LoadFunction\n@sa SharedObjectBase.Unload",
              "name": "SharedObjectBase",
              "kind": "function",
              "type": "",
              "parameters": [
                {
                  "name": "sofile",
                  "type": "StringParam"
                }
              ],
              "sourceName": "SDL_LoadObject"
            },
            "LoadFunction": {
              "doc": "Look up the address of the named function in a shared object.\n\nThis function pointer is no longer valid after calling SharedObjectBase.Unload().\n\nThis function can only look up C function names. Other languages may have\nname mangling and intrinsic language support that varies from compiler to\ncompiler.\n\nMake sure you declare your function pointers with the same calling\nconvention as the actual library function. Your code will crash\nmysteriously if you do not do this.\n\nIf the requested function doesn't exist, nullptr is returned.\n\n@param name the name of the function to look up.\n@returns a pointer to the function or nullptr on failure; call GetError()\n         for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SharedObjectBase.SharedObjectBase",
              "name": "LoadFunction",
              "kind": "function",
              "type": "FunctionPointer",
              "parameters": [
                {
                  "name": "name",
                  "type": "StringParam"
                }
              ],
              "sourceName": "SDL_LoadFunction"
            },
            "Unload": {
              "doc": "Unload a shared object from memory.\n\nNote that any pointers from this object looked up through\nSharedObjectBase.LoadFunction() will no longer be valid.\n\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SharedObjectBase.SharedObjectBase",
              "name": "Unload",
              "kind": "function",
              "type": "void",
              "parameters": [],
              "sourceName": "SDL_UnloadObject"
            }
          }
        },
        "ObjectRef<SDL_SharedObject>::doFree": {
          "name": "ObjectRef<SDL_SharedObject>::doFree",
          "type": "void",
          "kind": "function",
          "doc": "Callback for sharedObject resource cleanup\n\n@private",
          "template": [],
          "parameters": [
            {
              "type": "SDL_SharedObject *",
              "name": "resource"
            }
          ],
          "sourceName": "SDL_UnloadObject"
        }
      }
    },
    "SDL3pp_dialog.h": {
      "name": "SDL3pp_dialog.h",
      "doc": "@defgroup CategoryDialog Category Dialog\n\nFile dialog support.\n\nSDL offers file dialogs, to let users select files with native GUI\ninterfaces. There are \"open\" dialogs, \"save\" dialogs, and folder selection\ndialogs. The app can control some details, such as filtering to specific\nfiles, or whether multiple files can be selected by the user.\n\nNote that launching a file dialog is a non-blocking operation; control\nreturns to the app immediately, and a callback is called later (possibly in\nanother thread) when the user makes a choice.",
      "entries": {
        "DialogFileFilter": {
          "doc": "An entry for filters for file dialogs.\n\n`name` is a user-readable label for the filter (for example, \"Office\ndocument\").\n\n`pattern` is a semicolon-separated list of file extensions (for example,\n\"doc;docx\"). File extensions may only contain alphanumeric characters,\nhyphens, underscores and periods. Alternatively, the whole string can be a\nsingle asterisk (\"*\"), which serves as an \"All files\" filter.\n\n@since This struct is available since SDL 3.2.0.\n\n@sa DialogFileCallback\n@sa ShowOpenFileDialog\n@sa ShowSaveFileDialog\n@sa ShowOpenFolderDialog\n@sa ShowFileDialogWithProperties",
          "name": "DialogFileFilter",
          "kind": "alias",
          "sourceName": "SDL_DialogFileFilter",
          "type": "SDL_DialogFileFilter"
        },
        "DialogFileCallback": {
          "doc": "Callback used by file dialog functions.\n\nThe specific usage is described in each function.\n\nIf `filelist` is:\n\n- nullptr, an error occurred. Details can be obtained with GetError().\n- A pointer to nullptr, the user either didn't choose any file or canceled the\n  dialog.\n- A pointer to non-`nullptr`, the user chose one or more files. The argument\n  is a null-terminated array of pointers to UTF-8 encoded strings, each\n  containing a path.\n\nThe filelist argument should not be freed; it will automatically be freed\nwhen the callback returns.\n\nThe filter argument is the index of the filter that was selected, or -1 if\nno filter was selected or if the platform or method doesn't support\nfetching the selected filter.\n\nIn Android, the `filelist` are `content://` URIs. They should be opened\nusing IOStreamBase.IOStreamBase() with appropriate modes. This applies both to open\nand save file dialog.\n\n@param userdata an app-provided pointer, for the callback's use.\n@param filelist the file(s) chosen by the user.\n@param filter index of the selected filter.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa DialogFileFilter\n@sa ShowOpenFileDialog\n@sa ShowSaveFileDialog\n@sa ShowOpenFolderDialog\n@sa ShowFileDialogWithProperties",
          "name": "DialogFileCallback",
          "kind": "alias",
          "type": "SDL_DialogFileCallback",
          "sourceName": "SDL_DialogFileCallback"
        },
        "DialogFileCB": {
          "name": "DialogFileCB",
          "kind": "alias",
          "type": "std::function<void(const char *const *, int)>",
          "doc": ""
        },
        "ShowOpenFileDialog": [
          {
            "doc": "Displays a dialog that lets the user select a file on their filesystem.\n\nThis is an asynchronous function; it will return immediately, and the\nresult will be passed to the callback.\n\nThe callback will be invoked with a null-terminated list of files the user\nchose. The list will be empty if the user canceled the dialog, and it will\nbe nullptr if an error occurred.\n\nNote that the callback may be called from a different thread than the one\nthe function was invoked on.\n\nDepending on the platform, the user may be allowed to input paths that\ndon't yet exist.\n\nOn Linux, dialogs may require XDG Portals, which requires DBus, which\nrequires an event-handling loop. Apps that do not use SDL to handle events\nshould add a call to PumpEvents in their main loop.\n\n@param callback a function pointer to be invoked when the user selects a\n                file and accepts, or cancels the dialog, or an error\n                occurs.\n@param userdata an optional pointer to pass extra data to the callback when\n                it will be invoked.\n@param window the window that the dialog should be modal for, may be nullptr.\n              Not all platforms support this option.\n@param filters a list of filters, may be nullptr. Not all platforms support\n               this option, and platforms that do support it may allow the\n               user to ignore the filters. If non-nullptr, it must remain\n               valid at least until the callback is invoked.\n@param nfilters the number of filters. Ignored if filters is nullptr.\n@param default_location the default folder or file to start the dialog at,\n                        may be nullptr. Not all platforms support this option.\n@param allow_many if non-zero, the user will be allowed to select multiple\n                  entries. Not all platforms support this option.\n\n@threadsafety This function should be called only from the main thread. The\n              callback may be invoked from the same thread or from a\n              different one, depending on the OS's constraints.\n\n@since This function is available since SDL 3.2.0.\n\n@sa DialogFileCallback\n@sa DialogFileFilter\n@sa ShowSaveFileDialog\n@sa ShowOpenFolderDialog\n@sa ShowFileDialogWithProperties",
            "name": "ShowOpenFileDialog",
            "kind": "function",
            "type": "void",
            "parameters": [
              {
                "name": "callback",
                "type": "DialogFileCallback"
              },
              {
                "name": "userdata",
                "type": "void *"
              },
              {
                "name": "window",
                "type": "WindowRef"
              },
              {
                "name": "filters",
                "type": "const DialogFileFilter *"
              },
              {
                "name": "nfilters",
                "type": "int"
              },
              {
                "name": "default_location",
                "type": "StringParam"
              },
              {
                "name": "allow_many",
                "type": "bool"
              }
            ],
            "sourceName": "SDL_ShowOpenFileDialog"
          },
          {
            "name": "ShowOpenFileDialog",
            "kind": "function",
            "type": "void",
            "parameters": [
              {
                "type": "DialogFileCB",
                "name": "callback"
              },
              {
                "name": "window",
                "type": "WindowRef"
              },
              {
                "name": "filters",
                "type": "std::span<const DialogFileFilter>"
              },
              {
                "name": "default_location",
                "type": "StringParam"
              },
              {
                "name": "allow_many",
                "type": "bool"
              }
            ],
            "doc": ""
          }
        ],
        "ShowSaveFileDialog": [
          {
            "doc": "Displays a dialog that lets the user choose a new or existing file on their\nfilesystem.\n\nThis is an asynchronous function; it will return immediately, and the\nresult will be passed to the callback.\n\nThe callback will be invoked with a null-terminated list of files the user\nchose. The list will be empty if the user canceled the dialog, and it will\nbe nullptr if an error occurred.\n\nNote that the callback may be called from a different thread than the one\nthe function was invoked on.\n\nThe chosen file may or may not already exist.\n\nOn Linux, dialogs may require XDG Portals, which requires DBus, which\nrequires an event-handling loop. Apps that do not use SDL to handle events\nshould add a call to PumpEvents in their main loop.\n\n@param callback a function pointer to be invoked when the user selects a\n                file and accepts, or cancels the dialog, or an error\n                occurs.\n@param userdata an optional pointer to pass extra data to the callback when\n                it will be invoked.\n@param window the window that the dialog should be modal for, may be nullptr.\n              Not all platforms support this option.\n@param filters a list of filters, may be nullptr. Not all platforms support\n               this option, and platforms that do support it may allow the\n               user to ignore the filters. If non-nullptr, it must remain\n               valid at least until the callback is invoked.\n@param nfilters the number of filters. Ignored if filters is nullptr.\n@param default_location the default folder or file to start the dialog at,\n                        may be nullptr. Not all platforms support this option.\n\n@threadsafety This function should be called only from the main thread. The\n              callback may be invoked from the same thread or from a\n              different one, depending on the OS's constraints.\n\n@since This function is available since SDL 3.2.0.\n\n@sa DialogFileCallback\n@sa DialogFileFilter\n@sa ShowOpenFileDialog\n@sa ShowOpenFolderDialog\n@sa ShowFileDialogWithProperties",
            "name": "ShowSaveFileDialog",
            "kind": "function",
            "type": "void",
            "parameters": [
              {
                "name": "callback",
                "type": "DialogFileCallback"
              },
              {
                "name": "userdata",
                "type": "void *"
              },
              {
                "name": "window",
                "type": "WindowRef"
              },
              {
                "name": "filters",
                "type": "const DialogFileFilter *"
              },
              {
                "name": "nfilters",
                "type": "int"
              },
              {
                "name": "default_location",
                "type": "StringParam"
              }
            ],
            "sourceName": "SDL_ShowSaveFileDialog"
          },
          {
            "name": "ShowSaveFileDialog",
            "kind": "function",
            "type": "void",
            "parameters": [
              {
                "name": "callback",
                "type": "DialogFileCB"
              },
              {
                "name": "window",
                "type": "WindowRef"
              },
              {
                "name": "filters",
                "type": "std::span<const DialogFileFilter>"
              },
              {
                "name": "default_location",
                "type": "StringParam"
              }
            ],
            "doc": ""
          }
        ],
        "ShowOpenFolderDialog": [
          {
            "doc": "Displays a dialog that lets the user select a folder on their filesystem.\n\nThis is an asynchronous function; it will return immediately, and the\nresult will be passed to the callback.\n\nThe callback will be invoked with a null-terminated list of files the user\nchose. The list will be empty if the user canceled the dialog, and it will\nbe nullptr if an error occurred.\n\nNote that the callback may be called from a different thread than the one\nthe function was invoked on.\n\nDepending on the platform, the user may be allowed to input paths that\ndon't yet exist.\n\nOn Linux, dialogs may require XDG Portals, which requires DBus, which\nrequires an event-handling loop. Apps that do not use SDL to handle events\nshould add a call to PumpEvents in their main loop.\n\n@param callback a function pointer to be invoked when the user selects a\n                file and accepts, or cancels the dialog, or an error\n                occurs.\n@param userdata an optional pointer to pass extra data to the callback when\n                it will be invoked.\n@param window the window that the dialog should be modal for, may be nullptr.\n              Not all platforms support this option.\n@param default_location the default folder or file to start the dialog at,\n                        may be nullptr. Not all platforms support this option.\n@param allow_many if non-zero, the user will be allowed to select multiple\n                  entries. Not all platforms support this option.\n\n@threadsafety This function should be called only from the main thread. The\n              callback may be invoked from the same thread or from a\n              different one, depending on the OS's constraints.\n\n@since This function is available since SDL 3.2.0.\n\n@sa DialogFileCallback\n@sa ShowOpenFileDialog\n@sa ShowSaveFileDialog\n@sa ShowFileDialogWithProperties",
            "name": "ShowOpenFolderDialog",
            "kind": "function",
            "type": "void",
            "parameters": [
              {
                "name": "callback",
                "type": "DialogFileCallback"
              },
              {
                "name": "userdata",
                "type": "void *"
              },
              {
                "name": "window",
                "type": "WindowRef"
              },
              {
                "name": "default_location",
                "type": "StringParam"
              },
              {
                "name": "allow_many",
                "type": "bool"
              }
            ],
            "sourceName": "SDL_ShowOpenFolderDialog"
          },
          {
            "name": "ShowOpenFolderDialog",
            "kind": "function",
            "type": "void",
            "parameters": [
              {
                "name": "callback",
                "type": "DialogFileCB"
              },
              {
                "name": "window",
                "type": "WindowRef"
              },
              {
                "name": "default_location",
                "type": "StringParam"
              },
              {
                "name": "allow_many",
                "type": "bool"
              }
            ],
            "doc": ""
          }
        ],
        "FileDialogType": {
          "doc": "Various types of file dialogs.\n\nThis is used by ShowFileDialogWithProperties() to decide what kind of\ndialog to present to the user.\n\n@since This enum is available since SDL 3.2.0.\n\n@sa ShowFileDialogWithProperties",
          "name": "FileDialogType",
          "kind": "alias",
          "sourceName": "SDL_FileDialogType",
          "type": "SDL_FileDialogType"
        },
        "FILEDIALOG_OPENFILE": {
          "doc": "",
          "name": "FILEDIALOG_OPENFILE",
          "kind": "var",
          "type": "FileDialogType",
          "sourceName": "SDL_FILEDIALOG_OPENFILE",
          "constexpr": true
        },
        "FILEDIALOG_SAVEFILE": {
          "doc": "",
          "name": "FILEDIALOG_SAVEFILE",
          "kind": "var",
          "type": "FileDialogType",
          "sourceName": "SDL_FILEDIALOG_SAVEFILE",
          "constexpr": true
        },
        "FILEDIALOG_OPENFOLDER": {
          "doc": "",
          "name": "FILEDIALOG_OPENFOLDER",
          "kind": "var",
          "type": "FileDialogType",
          "sourceName": "SDL_FILEDIALOG_OPENFOLDER",
          "constexpr": true
        },
        "ShowFileDialogWithProperties": [
          {
            "doc": "Create and launch a file dialog with the specified properties.\n\nThese are the supported properties:\n\n- `SDL_PROP_FILE_DIALOG_FILTERS_POINTER`: a pointer to a list of\n  DialogFileFilter structs, which will be used as filters for\n  file-based selections. Ignored if the dialog is an \"Open Folder\" dialog.\n  If non-nullptr, the array of filters must remain valid at least until the\n  callback is invoked.\n- `prop::FileDialog.NFILTERS_NUMBER`: the number of filters in the\n  array of filters, if it exists.\n- `prop::FileDialog.WINDOW_POINTER`: the window that the dialog should\n  be modal for.\n- `prop::FileDialog.LOCATION_STRING`: the default folder or file to\n  start the dialog at.\n- `prop::FileDialog.MANY_BOOLEAN`: true to allow the user to select\n  more than one entry.\n- `prop::FileDialog.TITLE_STRING`: the title for the dialog.\n- `prop::FileDialog.ACCEPT_STRING`: the label that the accept button\n  should have.\n- `prop::FileDialog.CANCEL_STRING`: the label that the cancel button\n  should have.\n\nNote that each platform may or may not support any of the properties.\n\n@param type the type of file dialog.\n@param callback a function pointer to be invoked when the user selects a\n                file and accepts, or cancels the dialog, or an error\n                occurs.\n@param userdata an optional pointer to pass extra data to the callback when\n                it will be invoked.\n@param props the properties to use.\n\n@threadsafety This function should be called only from the main thread. The\n              callback may be invoked from the same thread or from a\n              different one, depending on the OS's constraints.\n\n@since This function is available since SDL 3.2.0.\n\n@sa FileDialogType\n@sa DialogFileCallback\n@sa DialogFileFilter\n@sa ShowOpenFileDialog\n@sa ShowSaveFileDialog\n@sa ShowOpenFolderDialog",
            "name": "ShowFileDialogWithProperties",
            "kind": "function",
            "type": "void",
            "parameters": [
              {
                "name": "type",
                "type": "FileDialogType"
              },
              {
                "name": "callback",
                "type": "DialogFileCallback"
              },
              {
                "name": "userdata",
                "type": "void *"
              },
              {
                "name": "props",
                "type": "PropertiesRef"
              }
            ],
            "sourceName": "SDL_ShowFileDialogWithProperties"
          },
          {
            "name": "ShowFileDialogWithProperties",
            "kind": "function",
            "type": "void",
            "parameters": [
              {
                "name": "type",
                "type": "FileDialogType"
              },
              {
                "name": "callback",
                "type": "DialogFileCB"
              },
              {
                "name": "props",
                "type": "PropertiesRef"
              }
            ],
            "doc": ""
          }
        ],
        "prop::FileDialog": {
          "kind": "ns",
          "name": "prop::FileDialog",
          "entries": {
            "FILTERS_POINTER": {
              "doc": "",
              "name": "FILTERS_POINTER",
              "kind": "var",
              "value": "\"SDL.filedialog.filters\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_FILE_DIALOG_FILTERS_POINTER"
            },
            "NFILTERS_NUMBER": {
              "doc": "",
              "name": "NFILTERS_NUMBER",
              "kind": "var",
              "value": "\"SDL.filedialog.nfilters\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_FILE_DIALOG_NFILTERS_NUMBER"
            },
            "WINDOW_POINTER": {
              "doc": "",
              "name": "WINDOW_POINTER",
              "kind": "var",
              "value": "\"SDL.filedialog.window\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_FILE_DIALOG_WINDOW_POINTER"
            },
            "LOCATION_STRING": {
              "doc": "",
              "name": "LOCATION_STRING",
              "kind": "var",
              "value": "\"SDL.filedialog.location\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_FILE_DIALOG_LOCATION_STRING"
            },
            "MANY_BOOLEAN": {
              "doc": "",
              "name": "MANY_BOOLEAN",
              "kind": "var",
              "value": "\"SDL.filedialog.many\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_FILE_DIALOG_MANY_BOOLEAN"
            },
            "TITLE_STRING": {
              "doc": "",
              "name": "TITLE_STRING",
              "kind": "var",
              "value": "\"SDL.filedialog.title\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_FILE_DIALOG_TITLE_STRING"
            },
            "ACCEPT_STRING": {
              "doc": "",
              "name": "ACCEPT_STRING",
              "kind": "var",
              "value": "\"SDL.filedialog.accept\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_FILE_DIALOG_ACCEPT_STRING"
            },
            "CANCEL_STRING": {
              "doc": "",
              "name": "CANCEL_STRING",
              "kind": "var",
              "value": "\"SDL.filedialog.cancel\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_FILE_DIALOG_CANCEL_STRING"
            }
          },
          "doc": ""
        }
      }
    },
    "SDL3pp_power.h": {
      "name": "SDL3pp_power.h",
      "doc": "@defgroup CategoryPower Category Power\n\nSDL power management routines.\n\nThere is a single function in this category: GetPowerInfo().\n\nThis function is useful for games on the go. This allows an app to know if\nit's running on a draining battery, which can be useful if the app wants to\nreduce processing, or perhaps framerate, to extend the duration of the\nbattery's charge. Perhaps the app just wants to show a battery meter when\nfullscreen, or alert the user when the power is getting extremely low, so\nthey can save their game.",
      "entries": {
        "PowerState": {
          "doc": "The basic state for the system's power supply.\n\nThese are results returned by GetPowerInfo().\n\n@since This enum is available since SDL 3.2.0.",
          "name": "PowerState",
          "kind": "alias",
          "sourceName": "SDL_PowerState",
          "type": "SDL_PowerState"
        },
        "POWERSTATE_ERROR": {
          "doc": "error determining power status",
          "name": "POWERSTATE_ERROR",
          "kind": "var",
          "type": "PowerState",
          "sourceName": "SDL_POWERSTATE_ERROR",
          "constexpr": true
        },
        "POWERSTATE_UNKNOWN": {
          "doc": "cannot determine power status",
          "name": "POWERSTATE_UNKNOWN",
          "kind": "var",
          "type": "PowerState",
          "sourceName": "SDL_POWERSTATE_UNKNOWN",
          "constexpr": true
        },
        "POWERSTATE_ON_BATTERY": {
          "doc": "Not plugged in, running on the battery.",
          "name": "POWERSTATE_ON_BATTERY",
          "kind": "var",
          "type": "PowerState",
          "sourceName": "SDL_POWERSTATE_ON_BATTERY",
          "constexpr": true
        },
        "POWERSTATE_NO_BATTERY": {
          "doc": "Plugged in, no battery available.",
          "name": "POWERSTATE_NO_BATTERY",
          "kind": "var",
          "type": "PowerState",
          "sourceName": "SDL_POWERSTATE_NO_BATTERY",
          "constexpr": true
        },
        "POWERSTATE_CHARGING": {
          "doc": "Plugged in, charging battery.",
          "name": "POWERSTATE_CHARGING",
          "kind": "var",
          "type": "PowerState",
          "sourceName": "SDL_POWERSTATE_CHARGING",
          "constexpr": true
        },
        "POWERSTATE_CHARGED": {
          "doc": "Plugged in, battery charged.",
          "name": "POWERSTATE_CHARGED",
          "kind": "var",
          "type": "PowerState",
          "sourceName": "SDL_POWERSTATE_CHARGED",
          "constexpr": true
        },
        "GetPowerInfo": {
          "doc": "Get the current power supply details.\n\nYou should never take a battery status as absolute truth. Batteries\n(especially failing batteries) are delicate hardware, and the values\nreported here are best estimates based on what that hardware reports. It's\nnot uncommon for older batteries to lose stored power much faster than it\nreports, or completely drain when reporting it has 20 percent left, etc.\n\nBattery status can change at any time; if you are concerned with power\nstate, you should call this function frequently, and perhaps ignore changes\nuntil they seem to be stable for a few seconds.\n\nIt's possible a platform can only report battery percentage or time left\nbut not both.\n\nOn some platforms, retrieving power supply details might be expensive. If\nyou want to display continuous status you could call this function every\nminute or so.\n\n@param seconds a pointer filled in with the seconds of battery life left,\n               or nullptr to ignore. This will be filled in with -1 if we\n               can't determine a value or there is no battery.\n@param percent a pointer filled in with the percentage of battery life\n               left, between 0 and 100, or nullptr to ignore. This will be\n               filled in with -1 we can't determine a value or there is no\n               battery.\n@returns the current battery state or `POWERSTATE_ERROR` on failure;\n         call GetError() for more information.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetPowerInfo",
          "kind": "function",
          "type": "PowerState",
          "parameters": [
            {
              "name": "seconds",
              "type": "int *"
            },
            {
              "name": "percent",
              "type": "int *"
            }
          ],
          "sourceName": "SDL_GetPowerInfo"
        }
      }
    },
    "SDL3pp_init.h": {
      "name": "SDL3pp_init.h",
      "doc": "@defgroup CategoryInit Category Init\n\nAll SDL programs need to initialize the library before starting to work\nwith it.\n\nAlmost everything can simply call InitSubSystem() near startup, with a handful\nof flags to specify subsystems to touch. These are here to make sure SDL\ndoes not even attempt to touch low-level pieces of the operating system\nthat you don't intend to use. For example, you might be using SDL for video\nand input but chose an external library for audio, and in this case you\nwould just need to leave off the `INIT_AUDIO` flag to make sure that\nexternal library has complete control.\n\nMost apps, when terminating, should call Quit(). This will clean up\n(nearly) everything that SDL might have allocated, and crucially, it'll\nmake sure that the display's resolution is back to what the user expects if\nyou had previously changed it for your game.\n\nSDL3 apps are strongly encouraged to call SetAppMetadata() at startup\nto fill in details about the program. This is completely optional, but it\nhelps in small ways (we can provide an About dialog box for the macOS menu,\nwe can name the app in the system's audio mixer, etc). Those that want to\nprovide a _lot_ of information should look at the more-detailed\nSetAppMetadataProperty().",
      "entries": {
        "InitFlags": {
          "doc": "Initialization flags for InitSubSystem and/or SDL_InitSubSystem\n\nThese are the flags which may be passed to InitSubSystem(). You should specify\nthe subsystems which you will be using in your application.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa InitSubSystem\n@sa Quit\n@sa SDL_InitSubSystem\n@sa QuitSubSystem\n@sa WasInit",
          "name": "InitFlags",
          "kind": "alias",
          "type": "SDL_InitFlags",
          "sourceName": "SDL_InitFlags"
        },
        "InitFlagsExtra": {
          "kind": "struct",
          "name": "InitFlagsExtra",
          "doc": "",
          "entries": {}
        },
        "INIT_AUDIO": {
          "doc": "`INIT_AUDIO` implies `INIT_EVENTS`",
          "name": "INIT_AUDIO",
          "kind": "var",
          "value": "0x00000010u",
          "sourceName": "SDL_INIT_AUDIO",
          "constexpr": true,
          "type": "InitFlags"
        },
        "INIT_VIDEO": {
          "doc": "`INIT_VIDEO` implies `INIT_EVENTS`, should be initialized on the main thread",
          "name": "INIT_VIDEO",
          "kind": "var",
          "value": "0x00000020u",
          "sourceName": "SDL_INIT_VIDEO",
          "constexpr": true,
          "type": "InitFlags"
        },
        "INIT_JOYSTICK": {
          "doc": "`INIT_JOYSTICK` implies `INIT_EVENTS`, should be initialized on the same thread as INIT_VIDEO on Windows if you don't set SDL_HINT_JOYSTICK_THREAD",
          "name": "INIT_JOYSTICK",
          "kind": "var",
          "value": "0x00000200u",
          "sourceName": "SDL_INIT_JOYSTICK",
          "constexpr": true,
          "type": "InitFlags"
        },
        "INIT_HAPTIC": {
          "doc": "",
          "name": "INIT_HAPTIC",
          "kind": "var",
          "value": "0x00001000u",
          "sourceName": "SDL_INIT_HAPTIC",
          "constexpr": true,
          "type": "InitFlags"
        },
        "INIT_GAMEPAD": {
          "doc": "`INIT_GAMEPAD` implies `INIT_JOYSTICK`",
          "name": "INIT_GAMEPAD",
          "kind": "var",
          "value": "0x00002000u",
          "sourceName": "SDL_INIT_GAMEPAD",
          "constexpr": true,
          "type": "InitFlags"
        },
        "INIT_EVENTS": {
          "doc": "",
          "name": "INIT_EVENTS",
          "kind": "var",
          "value": "0x00004000u",
          "sourceName": "SDL_INIT_EVENTS",
          "constexpr": true,
          "type": "InitFlags"
        },
        "INIT_SENSOR": {
          "doc": "`INIT_SENSOR` implies `INIT_EVENTS`",
          "name": "INIT_SENSOR",
          "kind": "var",
          "value": "0x00008000u",
          "sourceName": "SDL_INIT_SENSOR",
          "constexpr": true,
          "type": "InitFlags"
        },
        "INIT_CAMERA": {
          "doc": "`INIT_CAMERA` implies `INIT_EVENTS`",
          "name": "INIT_CAMERA",
          "kind": "var",
          "value": "0x00010000u",
          "sourceName": "SDL_INIT_CAMERA",
          "constexpr": true,
          "type": "InitFlags"
        },
        "AppResult": {
          "doc": "Return values for optional main callbacks.\n\nReturning APP_SUCCESS or APP_FAILURE from SDL_AppInit,\nSDL_AppEvent, or SDL_AppIterate will terminate the program and report\nsuccess/failure to the operating system. What that means is\nplatform-dependent. On Unix, for example, on success, the process error\ncode will be zero, and on failure it will be 1. This interface doesn't\nallow you to return specific exit codes, just whether there was an error\ngenerally or not.\n\nReturning APP_CONTINUE from these functions will let the app continue\nto run.\n\nSee\n[Main callbacks in SDL3](https://wiki.libsdl.org/SDL3/README/main-functions#main-callbacks-in-sdl3)\nfor complete details.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "AppResult",
          "kind": "alias",
          "sourceName": "SDL_AppResult",
          "type": "SDL_AppResult"
        },
        "APP_CONTINUE": {
          "doc": "Value that requests that the app continue from the main callbacks.",
          "name": "APP_CONTINUE",
          "kind": "var",
          "type": "AppResult",
          "sourceName": "SDL_APP_CONTINUE",
          "constexpr": true
        },
        "APP_SUCCESS": {
          "doc": "Value that requests termination with success from the main callbacks.",
          "name": "APP_SUCCESS",
          "kind": "var",
          "type": "AppResult",
          "sourceName": "SDL_APP_SUCCESS",
          "constexpr": true
        },
        "APP_FAILURE": {
          "doc": "Value that requests termination with error from the main callbacks.",
          "name": "APP_FAILURE",
          "kind": "var",
          "type": "AppResult",
          "sourceName": "SDL_APP_FAILURE",
          "constexpr": true
        },
        "AppInit_func": {
          "doc": "Function pointer typedef for SDL_AppInit.\n\nThese are used by EnterAppMainCallbacks. This mechanism operates behind\nthe scenes for apps using the optional main callbacks. Apps that want to\nuse this should just implement SDL_AppInit directly.\n\n@param appstate a place where the app can optionally store a pointer for\n                future use.\n@param argc the standard ANSI C main's argc; number of elements in `argv`.\n@param argv the standard ANSI C main's argv; array of command line\n            arguments.\n@returns APP_FAILURE to terminate with an error, APP_SUCCESS to\n         terminate with success, APP_CONTINUE to continue.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "AppInit_func",
          "kind": "alias",
          "type": "SDL_AppInit_func",
          "sourceName": "SDL_AppInit_func"
        },
        "AppIterate_func": {
          "doc": "Function pointer typedef for SDL_AppIterate.\n\nThese are used by EnterAppMainCallbacks. This mechanism operates behind\nthe scenes for apps using the optional main callbacks. Apps that want to\nuse this should just implement SDL_AppIterate directly.\n\n@param appstate an optional pointer, provided by the app in SDL_AppInit.\n@returns APP_FAILURE to terminate with an error, APP_SUCCESS to\n         terminate with success, APP_CONTINUE to continue.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "AppIterate_func",
          "kind": "alias",
          "type": "SDL_AppIterate_func",
          "sourceName": "SDL_AppIterate_func"
        },
        "AppEvent_func": {
          "doc": "Function pointer typedef for SDL_AppEvent.\n\nThese are used by EnterAppMainCallbacks. This mechanism operates behind\nthe scenes for apps using the optional main callbacks. Apps that want to\nuse this should just implement SDL_AppEvent directly.\n\n@param appstate an optional pointer, provided by the app in SDL_AppInit.\n@param event the new event for the app to examine.\n@returns APP_FAILURE to terminate with an error, APP_SUCCESS to\n         terminate with success, APP_CONTINUE to continue.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "AppEvent_func",
          "kind": "alias",
          "type": "SDL_AppEvent_func",
          "sourceName": "SDL_AppEvent_func"
        },
        "AppQuit_func": {
          "doc": "Function pointer typedef for SDL_AppQuit.\n\nThese are used by EnterAppMainCallbacks. This mechanism operates behind\nthe scenes for apps using the optional main callbacks. Apps that want to\nuse this should just implement SDL_AppEvent directly.\n\n@param appstate an optional pointer, provided by the app in SDL_AppInit.\n@param result the result code that terminated the app (success or failure).\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "AppQuit_func",
          "kind": "alias",
          "type": "SDL_AppQuit_func",
          "sourceName": "SDL_AppQuit_func"
        },
        "InitSubSystem": [
          {
            "doc": "Initialize the SDL library.\n\nInitSubSystem() simply forwards to calling SDL_InitSubSystem(). Therefore, the\ntwo may be used interchangeably. Though for readability of your code\nSDL_InitSubSystem() might be preferred.\n\nThe file I/O (for example: IOStreamBase.IOStreamBase) and threading (SDL_CreateThread)\nsubsystems are initialized by default. Message boxes\n(SDL_ShowSimpleMessageBox) also attempt to work without initializing the\nvideo subsystem, in hopes of being useful in showing an error dialog when\nInitSubSystem fails. You must specifically initialize other subsystems if you\nuse them in your application.\n\nLogging (such as Log) works without initialization, too.\n\n`flags` may be any of the following OR'd together:\n\n- `INIT_AUDIO`: audio subsystem; automatically initializes the events\n  subsystem\n- `INIT_VIDEO`: video subsystem; automatically initializes the events\n  subsystem, should be initialized on the main thread.\n- `INIT_JOYSTICK`: joystick subsystem; automatically initializes the\n  events subsystem\n- `INIT_HAPTIC`: haptic (force feedback) subsystem\n- `INIT_GAMEPAD`: gamepad subsystem; automatically initializes the\n  joystick subsystem\n- `INIT_EVENTS`: events subsystem\n- `INIT_SENSOR`: sensor subsystem; automatically initializes the events\n  subsystem\n- `INIT_CAMERA`: camera subsystem; automatically initializes the events\n  subsystem\n\nSubsystem initialization is ref-counted, you must call QuitSubSystem()\nfor each SDL_InitSubSystem() to correctly shutdown a subsystem manually (or\ncall Quit() to force shutdown). If a subsystem is already loaded then\nthis call will increase the ref-count and return.\n\nConsider reporting some basic metadata about your application before\ncalling InitSubSystem, using either SetAppMetadata() or\nSetAppMetadataProperty().\n\n@param flags subsystem initialization flags.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SetAppMetadata\n@sa SetAppMetadataProperty\n@sa SDL_InitSubSystem\n@sa Quit\n@sa SetMainReady\n@sa WasInit",
            "name": "InitSubSystem",
            "kind": "function",
            "type": "bool",
            "parameters": [
              {
                "name": "flags",
                "type": "InitFlags"
              }
            ],
            "sourceName": "SDL_Init"
          },
          {
            "kind": "function",
            "name": "InitSubSystem",
            "type": "bool",
            "template": [
              {
                "type": "class",
                "name": "FLAG0"
              },
              {
                "type": "class",
                "name": "FLAG1"
              },
              {
                "type": "class...",
                "name": "FLAGS"
              }
            ],
            "parameters": [
              {
                "type": "FLAG0",
                "name": "flag0"
              },
              {
                "type": "FLAG1",
                "name": "flag1"
              },
              {
                "type": "FLAGS...",
                "name": "flags"
              }
            ],
            "doc": ""
          },
          {
            "kind": "function",
            "name": "InitSubSystem",
            "type": "bool",
            "template": [
              {
                "type": "class",
                "name": "FLAG"
              },
              {
                "type": "class...",
                "name": "FLAGS"
              }
            ],
            "parameters": [
              {
                "type": "FLAG",
                "name": "flag0"
              },
              {
                "type": "FLAG",
                "name": "flag1"
              },
              {
                "type": "FLAGS...",
                "name": "flags"
              }
            ],
            "doc": ""
          }
        ],
        "QuitSubSystem": [
          {
            "doc": "Shut down specific SDL subsystems.\n\nYou still need to call Quit() even if you close all open subsystems\nwith QuitSubSystem().\n\n@param flags any of the flags used by InitSubSystem(); see InitSubSystem for details.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SDL_InitSubSystem\n@sa Quit",
            "name": "QuitSubSystem",
            "kind": "function",
            "type": "void",
            "parameters": [
              {
                "name": "flags",
                "type": "InitFlags"
              }
            ],
            "sourceName": "SDL_QuitSubSystem"
          },
          {
            "kind": "function",
            "name": "QuitSubSystem",
            "type": "void",
            "template": [
              {
                "type": "class",
                "name": "FLAG0"
              },
              {
                "type": "class",
                "name": "FLAG1"
              },
              {
                "type": "class...",
                "name": "FLAGS"
              }
            ],
            "parameters": [
              {
                "type": "FLAG0",
                "name": "flag0"
              },
              {
                "type": "FLAG1",
                "name": "flag1"
              },
              {
                "type": "FLAGS...",
                "name": "flags"
              }
            ],
            "doc": ""
          },
          {
            "kind": "function",
            "name": "QuitSubSystem",
            "type": "void",
            "template": [
              {
                "type": "class",
                "name": "FLAG"
              },
              {
                "type": "class...",
                "name": "FLAGS"
              }
            ],
            "parameters": [
              {
                "type": "FLAG",
                "name": "flag0"
              },
              {
                "type": "FLAG",
                "name": "flag1"
              },
              {
                "type": "FLAGS...",
                "name": "flags"
              }
            ],
            "doc": ""
          }
        ],
        "WasInit": [
          {
            "doc": "Get a mask of the specified subsystems which are currently initialized.\n\n@param flags any of the flags used by InitSubSystem(); see InitSubSystem for details.\n@returns a mask of all initialized subsystems if `flags` is 0, otherwise it\n         returns the initialization status of the specified subsystems.\n\n@since This function is available since SDL 3.2.0.\n\n@sa InitSubSystem\n@sa SDL_InitSubSystem",
            "name": "WasInit",
            "kind": "function",
            "type": "bool",
            "parameters": [
              {
                "name": "flags",
                "type": "InitFlags"
              }
            ],
            "sourceName": "SDL_WasInit"
          },
          {
            "kind": "function",
            "name": "WasInit",
            "type": "bool",
            "template": [
              {
                "type": "class",
                "name": "FLAG0"
              },
              {
                "type": "class",
                "name": "FLAG1"
              },
              {
                "type": "class...",
                "name": "FLAGS"
              }
            ],
            "parameters": [
              {
                "type": "FLAG0",
                "name": "flag0"
              },
              {
                "type": "FLAG1",
                "name": "flag1"
              },
              {
                "type": "FLAGS...",
                "name": "flags"
              }
            ],
            "doc": ""
          },
          {
            "kind": "function",
            "name": "WasInit",
            "type": "bool",
            "template": [
              {
                "type": "class",
                "name": "FLAG"
              },
              {
                "type": "class...",
                "name": "FLAGS"
              }
            ],
            "parameters": [
              {
                "type": "FLAG",
                "name": "flag0"
              },
              {
                "type": "FLAG",
                "name": "flag1"
              },
              {
                "type": "FLAGS...",
                "name": "flags"
              }
            ],
            "doc": ""
          }
        ],
        "Quit": {
          "doc": "Clean up all initialized subsystems.\n\nYou should call this function even if you have already shutdown each\ninitialized subsystem with QuitSubSystem(). It is safe to call this\nfunction even in the case of errors in initialization.\n\nYou can use this function with atexit() to ensure that it is run when your\napplication is shutdown, but it is not wise to do this from a library or\nother dynamically loaded code.\n\n@since This function is available since SDL 3.2.0.\n\n@sa InitSubSystem\n@sa QuitSubSystem",
          "name": "Quit",
          "kind": "function",
          "type": "void",
          "parameters": [],
          "sourceName": "SDL_Quit"
        },
        "SDL": {
          "kind": "struct",
          "name": "SDL",
          "entries": {
            "m_active": {
              "kind": "var",
              "type": "bool",
              "name": "m_active",
              "doc": ""
            },
            "updateActive": {
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "type": "bool",
                  "name": "active"
                }
              ],
              "name": "updateActive",
              "doc": ""
            },
            "SDL": [
              {
                "kind": "function",
                "type": "",
                "template": [
                  {
                    "type": "class...",
                    "name": "FLAGS"
                  }
                ],
                "parameters": [
                  {
                    "type": "FLAGS...",
                    "name": "flags"
                  }
                ],
                "name": "SDL",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "",
                "constexpr": true,
                "parameters": [],
                "name": "SDL",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "type": "const SDL &",
                    "name": "other"
                  }
                ],
                "name": "SDL",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "type": "SDL &&",
                    "name": "other"
                  }
                ],
                "name": "SDL",
                "doc": ""
              }
            ]
          },
          "doc": ""
        },
        "IsMainThread": {
          "doc": "Return whether this is the main thread.\n\nOn Apple platforms, the main thread is the thread that runs your program's\nmain() entry point. On other platforms, the main thread is the one that\ncalls InitSubSystem(INIT_VIDEO), which should usually be the one that runs\nyour program's main() entry point. If you are using the main callbacks,\nSDL_AppInit(), SDL_AppIterate(), and SDL_AppQuit() are all called on the\nmain thread.\n\n@returns true if this thread is the main thread, or false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa RunOnMainThread",
          "name": "IsMainThread",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_IsMainThread"
        },
        "MainThreadCallback": {
          "doc": "Callback run on the main thread.\n\n@param userdata an app-controlled pointer that is passed to the callback.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa RunOnMainThread",
          "name": "MainThreadCallback",
          "kind": "alias",
          "type": "SDL_MainThreadCallback",
          "sourceName": "SDL_MainThreadCallback"
        },
        "MainThreadCB": {
          "kind": "alias",
          "name": "MainThreadCB",
          "type": "std::function<void()>",
          "doc": ""
        },
        "RunOnMainThread": [
          {
            "doc": "Call a function on the main thread during event processing.\n\nIf this is called on the main thread, the callback is executed immediately.\nIf this is called on another thread, this callback is queued for execution\non the main thread during event processing.\n\nBe careful of deadlocks when using this functionality. You should not have\nthe main thread wait for the current thread while this function is being\ncalled with `wait_complete` true.\n\n@param callback the callback to call on the main thread.\n@param userdata a pointer that is passed to `callback`.\n@param wait_complete true to wait for the callback to complete, false to\n                     return immediately.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa IsMainThread",
            "name": "RunOnMainThread",
            "kind": "function",
            "type": "bool",
            "parameters": [
              {
                "name": "callback",
                "type": "MainThreadCallback"
              },
              {
                "name": "userdata",
                "type": "void *"
              },
              {
                "name": "wait_complete",
                "type": "bool"
              }
            ],
            "sourceName": "SDL_RunOnMainThread"
          },
          {
            "kind": "function",
            "name": "RunOnMainThread",
            "type": "bool",
            "parameters": [
              {
                "type": "MainThreadCB",
                "name": "callback"
              },
              {
                "type": "bool",
                "name": "wait_complete"
              }
            ],
            "doc": ""
          }
        ],
        "SetAppMetadata": {
          "doc": "Specify basic metadata about your app.\n\nYou can optionally provide metadata about your app to SDL. This is not\nrequired, but strongly encouraged.\n\nThere are several locations where SDL can make use of metadata (an \"About\"\nbox in the macOS menu bar, the name of the app can be shown on some audio\nmixers, etc). Any piece of metadata can be left as nullptr, if a specific\ndetail doesn't make sense for the app.\n\nThis function should be called as early as possible, before InitSubSystem.\nMultiple calls to this function are allowed, but various state might not\nchange once it has been set up with a previous call to this function.\n\nPassing a nullptr removes any previous metadata.\n\nThis is a simplified interface for the most important information. You can\nsupply significantly more detailed metadata with\nSetAppMetadataProperty().\n\n@param appname The name of the application (\"My Game 2: Bad Guy's\n               Revenge!\").\n@param appversion The version of the application (\"1.0.0beta5\" or a git\n                  hash, or whatever makes sense).\n@param appidentifier A unique string in reverse-domain format that\n                     identifies this app (\"com.example.mygame2\").\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SetAppMetadataProperty",
          "name": "SetAppMetadata",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "appname",
              "type": "StringParam"
            },
            {
              "name": "appversion",
              "type": "StringParam"
            },
            {
              "name": "appidentifier",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_SetAppMetadata"
        },
        "SetAppMetadataProperty": {
          "doc": "Specify metadata about your app through a set of properties.\n\nYou can optionally provide metadata about your app to SDL. This is not\nrequired, but strongly encouraged.\n\nThere are several locations where SDL can make use of metadata (an \"About\"\nbox in the macOS menu bar, the name of the app can be shown on some audio\nmixers, etc). Any piece of metadata can be left out, if a specific detail\ndoesn't make sense for the app.\n\nThis function should be called as early as possible, before InitSubSystem.\nMultiple calls to this function are allowed, but various state might not\nchange once it has been set up with a previous call to this function.\n\nOnce set, this metadata can be read using GetAppMetadataProperty().\n\nThese are the supported properties:\n\n- `SDL_PROP_APP_METADATA_NAME_STRING`: The human-readable name of the\n  application, like \"My Game 2: Bad Guy's Revenge!\". This will show up\n  anywhere the OS shows the name of the application separately from window\n  titles, such as volume control applets, etc. This defaults to \"SDL\n  Application\".\n- `prop::appMetaData.VERSION_STRING`: The version of the app that is\n  running; there are no rules on format, so \"1.0.3beta2\" and \"April 22nd,\n  2024\" and a git hash are all valid options. This has no default.\n- `prop::appMetaData.IDENTIFIER_STRING`: A unique string that\n  identifies this app. This must be in reverse-domain format, like\n  \"com.example.mygame2\". This string is used by desktop compositors to\n  identify and group windows together, as well as match applications with\n  associated desktop settings and icons. If you plan to package your\n  application in a container such as Flatpak, the app ID should match the\n  name of your Flatpak container as well. This has no default.\n- `prop::appMetaData.CREATOR_STRING`: The human-readable name of the\n  creator/developer/maker of this app, like \"MojoWorkshop, LLC\"\n- `prop::appMetaData.COPYRIGHT_STRING`: The human-readable copyright\n  notice, like \"Copyright (c) 2024 MojoWorkshop, LLC\" or whatnot. Keep this\n  to one line, don't paste a copy of a whole software license in here. This\n  has no default.\n- `prop::appMetaData.URL_STRING`: A URL to the app on the web. Maybe a\n  product page, or a storefront, or even a GitHub repository, for user's\n  further information This has no default.\n- `prop::appMetaData.TYPE_STRING`: The type of application this is.\n  Currently this string can be \"game\" for a video game, \"mediaplayer\" for a\n  media player, or generically \"application\" if nothing else applies.\n  Future versions of SDL might add new types. This defaults to\n  \"application\".\n\n@param name the name of the metadata property to set.\n@param value the value of the property, or nullptr to remove that property.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetAppMetadataProperty\n@sa SetAppMetadata",
          "name": "SetAppMetadataProperty",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "name",
              "type": "StringParam"
            },
            {
              "name": "value",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_SetAppMetadataProperty"
        },
        "prop::appMetaData": {
          "kind": "ns",
          "name": "prop::appMetaData",
          "entries": {
            "NAME_STRING": {
              "doc": "",
              "name": "NAME_STRING",
              "kind": "var",
              "value": "\"SDL.app.metadata.name\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_APP_METADATA_NAME_STRING"
            },
            "VERSION_STRING": {
              "doc": "",
              "name": "VERSION_STRING",
              "kind": "var",
              "value": "\"SDL.app.metadata.version\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_APP_METADATA_VERSION_STRING"
            },
            "IDENTIFIER_STRING": {
              "doc": "",
              "name": "IDENTIFIER_STRING",
              "kind": "var",
              "value": "\"SDL.app.metadata.identifier\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_APP_METADATA_IDENTIFIER_STRING"
            },
            "CREATOR_STRING": {
              "doc": "",
              "name": "CREATOR_STRING",
              "kind": "var",
              "value": "\"SDL.app.metadata.creator\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_APP_METADATA_CREATOR_STRING"
            },
            "COPYRIGHT_STRING": {
              "doc": "",
              "name": "COPYRIGHT_STRING",
              "kind": "var",
              "value": "\"SDL.app.metadata.copyright\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_APP_METADATA_COPYRIGHT_STRING"
            },
            "URL_STRING": {
              "doc": "",
              "name": "URL_STRING",
              "kind": "var",
              "value": "\"SDL.app.metadata.url\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_APP_METADATA_URL_STRING"
            },
            "TYPE_STRING": {
              "doc": "",
              "name": "TYPE_STRING",
              "kind": "var",
              "value": "\"SDL.app.metadata.type\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "SDL_PROP_APP_METADATA_TYPE_STRING"
            }
          },
          "doc": ""
        },
        "GetAppMetadataProperty": {
          "doc": "Get metadata about your app.\n\nThis returns metadata previously set using SetAppMetadata() or\nSetAppMetadataProperty(). See SetAppMetadataProperty() for the list\nof available properties and their meanings.\n\n@param name the name of the metadata property to get.\n@returns the current value of the metadata property, or the default if it\n         is not set, nullptr for properties with no default.\n\n@threadsafety It is safe to call this function from any thread, although\n              the string returned is not protected and could potentially be\n              freed if you call SetAppMetadataProperty() to set that\n              property from another thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SetAppMetadata\n@sa SetAppMetadataProperty",
          "name": "GetAppMetadataProperty",
          "kind": "function",
          "type": "const char *",
          "parameters": [
            {
              "name": "name",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_GetAppMetadataProperty"
        }
      }
    },
    "SDL3pp_main.h": {
      "name": "SDL3pp_main.h",
      "doc": "@defgroup CategoryMain Category Main\n\nRedefine main() if necessary so that it is called by SDL.\n\nIn order to make this consistent on all platforms, the application's main()\nshould look like this:\n\n```c\n#include <SDL3/SDL.h>\n#include <SDL3/SDL_main.h>\n\nint main(int argc, char *argv[])\n{\n}\n```\n\nSDL will take care of platform specific details on how it gets called.\n\nThis is also where an app can be configured to use the main callbacks, via\nthe SDL3PP_MAIN_USE_CALLBACKS macro.\n\nSDL_main.h is a \"single-header library,\" which is to say that including\nthis header inserts code into your program, and you should only include it\nonce in most cases. SDL.h does not include this header automatically.\n\nFor more information, see:\n\nhttps://wiki.libsdl.org/SDL3/README/main-functions",
      "entries": {
        "SDL_MAIN_HANDLED": {
          "kind": "def",
          "name": "SDL_MAIN_HANDLED",
          "doc": ""
        },
        "SDL_MAIN_USE_CALLBACKS": {
          "kind": "def",
          "name": "SDL_MAIN_USE_CALLBACKS",
          "doc": ""
        },
        "SDL3PP_MAIN_HANDLED": {
          "doc": "Inform SDL that the app is providing an entry point instead of SDL.\n\nSDL does not define this macro, but will check if it is defined when\nincluding `SDL_main.h`. If defined, SDL will expect the app to provide the\nproper entry point for the platform, and all the other magic details\nneeded, like manually calling SetMainReady.\n\nPlease see [README/main-functions](README/main-functions), (or\ndocs/README-main-functions.md in the source tree) for a more detailed\nexplanation.\n\n@since This macro is used by the headers since SDL 3.2.0.",
          "name": "SDL3PP_MAIN_HANDLED",
          "kind": "def",
          "value": "1",
          "sourceName": "SDL_MAIN_HANDLED"
        },
        "SDL3PP_MAIN_USE_CALLBACKS": {
          "doc": "Inform SDL to use the main callbacks instead of main.\n\nSDL does not define this macro, but will check if it is defined when\nincluding `SDL_main.h`. If defined, SDL will expect the app to provide\nseveral functions: SDL_AppInit, SDL_AppEvent, SDL_AppIterate, and\nSDL_AppQuit. The app should not provide a `main` function in this case, and\ndoing so will likely cause the build to fail.\n\nPlease see [README/main-functions](README/main-functions), (or\ndocs/README-main-functions.md in the source tree) for a more detailed\nexplanation.\n\n@since This macro is used by the headers since SDL 3.2.0.\n\n@sa SDL_AppInit\n@sa SDL_AppEvent\n@sa SDL_AppIterate\n@sa SDL_AppQuit",
          "name": "SDL3PP_MAIN_USE_CALLBACKS",
          "kind": "def",
          "value": "1",
          "sourceName": "SDL_MAIN_USE_CALLBACKS"
        },
        "main_func": {
          "doc": "The prototype for the application's main() function\n\n@param argc an ANSI-C style main function's argc.\n@param argv an ANSI-C style main function's argv.\n@returns an ANSI-C main return code; generally 0 is considered successful\n         program completion, and small non-zero values are considered\n         errors.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "main_func",
          "kind": "alias",
          "type": "SDL_main_func",
          "sourceName": "SDL_main_func"
        },
        "SetMainReady": {
          "doc": "Circumvent failure of InitSubSystem() when not using SDL_main() as an entry\npoint.\n\nThis function is defined in SDL_main.h, along with the preprocessor rule to\nredefine main() as SDL_main(). Thus to ensure that your main() function\nwill not be changed it is necessary to define SDL3PP_MAIN_HANDLED before\nincluding SDL.h.\n\n@since This function is available since SDL 3.2.0.\n\n@sa InitSubSystem",
          "name": "SetMainReady",
          "kind": "function",
          "type": "void",
          "parameters": [],
          "sourceName": "SDL_SetMainReady"
        },
        "RunApp": {
          "doc": "Initializes and launches an SDL application, by doing platform-specific\ninitialization before calling your mainFunction and cleanups after it\nreturns, if that is needed for a specific platform, otherwise it just calls\nmainFunction.\n\nYou can use this if you want to use your own main() implementation without\nusing SDL_main (like when using SDL3PP_MAIN_HANDLED). When using this, you do\n*not* need SetMainReady().\n\n@param argc the argc parameter from the application's main() function, or 0\n            if the platform's main-equivalent has no argc.\n@param argv the argv parameter from the application's main() function, or\n            nullptr if the platform's main-equivalent has no argv.\n@param mainFunction your SDL app's C-style main(). NOT the function you're\n                    calling this from! Its name doesn't matter; it doesn't\n                    literally have to be `main`.\n@param reserved should be nullptr (reserved for future use, will probably be\n                platform-specific then).\n@returns the return value from mainFunction: 0 on success, otherwise\n         failure; GetError() might have more information on the\n         failure.\n\n@threadsafety Generally this is called once, near startup, from the\n              process's initial thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "RunApp",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "argc",
              "type": "int"
            },
            {
              "name": "argv[]",
              "type": "char *"
            },
            {
              "name": "mainFunction",
              "type": "main_func"
            },
            {
              "name": "reserved",
              "type": "void *"
            }
          ],
          "sourceName": "SDL_RunApp"
        },
        "EnterAppMainCallbacks": {
          "doc": "An entry point for SDL's use in SDL3PP_MAIN_USE_CALLBACKS.\n\nGenerally, you should not call this function directly. This only exists to\nhand off work into SDL as soon as possible, where it has a lot more control\nand functionality available, and make the inline code in SDL_main.h as\nsmall as possible.\n\nNot all platforms use this, it's actual use is hidden in a magic\nheader-only library, and you should not call this directly unless you\n_really_ know what you're doing.\n\n@param argc standard Unix main argc.\n@param argv standard Unix main argv.\n@param appinit the application's SDL_AppInit function.\n@param appiter the application's SDL_AppIterate function.\n@param appevent the application's SDL_AppEvent function.\n@param appquit the application's SDL_AppQuit function.\n@returns standard Unix main return value.\n\n@threadsafety It is not safe to call this anywhere except as the only\n              function call in SDL_main.\n\n@since This function is available since SDL 3.2.0.",
          "name": "EnterAppMainCallbacks",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "argc",
              "type": "int"
            },
            {
              "name": "argv[]",
              "type": "char *"
            },
            {
              "name": "appinit",
              "type": "AppInit_func"
            },
            {
              "name": "appiter",
              "type": "AppIterate_func"
            },
            {
              "name": "appevent",
              "type": "AppEvent_func"
            },
            {
              "name": "appquit",
              "type": "AppQuit_func"
            }
          ],
          "sourceName": "SDL_EnterAppMainCallbacks"
        },
        "GDKSuspendComplete": {
          "doc": "Callback from the application to let the suspend continue.\n\nThis function is only needed for Xbox GDK support; all other platforms will\ndo nothing and set an \"unsupported\" error message.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GDKSuspendComplete",
          "kind": "function",
          "type": "void",
          "parameters": [],
          "sourceName": "SDL_GDKSuspendComplete"
        }
      }
    },
    "SDL3pp_image.h": {
      "name": "SDL3pp_image.h",
      "doc": "@defgroup CategorySDLImage Category SDLImage\n\nHeader file for SDL_image library\n\nA simple library to load images of various formats as SDL surfaces",
      "entries": {
        "SDL3PP_ENABLE_IMAGE": {
          "name": "SDL3PP_ENABLE_IMAGE",
          "doc": ""
        },
        "AnimationBase-forward": {
          "name": "AnimationBase",
          "kind": "forward",
          "template": [
            {
              "type": "ObjectBox<IMG_Animation *>",
              "name": "T"
            }
          ],
          "doc": ""
        },
        "AnimationRef": {
          "name": "AnimationRef",
          "kind": "alias",
          "type": "AnimationBase<ObjectRef<IMG_Animation>>",
          "doc": "Handle to a non owned animation\n\n@cat resource\n\n@sa AnimationBase\n@sa Animation"
        },
        "Animation": {
          "name": "Animation",
          "kind": "alias",
          "type": "AnimationBase<ObjectUnique<IMG_Animation>>",
          "doc": "Handle to an owned animation\n\n@cat resource\n\n@sa AnimationBase\n@sa AnimationRef"
        },
        "SDL_IMAGE_MAJOR_VERSION": {
          "doc": "Printable format: \"%d.%d.%d\", MAJOR, MINOR, MICRO",
          "name": "SDL_IMAGE_MAJOR_VERSION",
          "kind": "def",
          "value": "3",
          "sourceName": "SDL_IMAGE_MAJOR_VERSION"
        },
        "SDL_IMAGE_MINOR_VERSION": {
          "doc": "",
          "name": "SDL_IMAGE_MINOR_VERSION",
          "kind": "def",
          "value": "2",
          "sourceName": "SDL_IMAGE_MINOR_VERSION"
        },
        "SDL_IMAGE_MICRO_VERSION": {
          "doc": "",
          "name": "SDL_IMAGE_MICRO_VERSION",
          "kind": "def",
          "value": "5",
          "sourceName": "SDL_IMAGE_MICRO_VERSION"
        },
        "SDL_IMAGE_VERSION": {
          "doc": "This is the version number macro for the current SDL_image version.",
          "name": "SDL_IMAGE_VERSION",
          "kind": "def",
          "value": "    SDL_VERSIONNUM(SDL_IMAGE_MAJOR_VERSION, SDL_IMAGE_MINOR_VERSION, SDL_IMAGE_MICRO_VERSION)",
          "sourceName": "SDL_IMAGE_VERSION"
        },
        "SDL_IMAGE_VERSION_ATLEAST": {
          "doc": "This macro will evaluate to true if compiled with SDL_image at least X.Y.Z.",
          "name": "SDL_IMAGE_VERSION_ATLEAST",
          "kind": "def",
          "parameters": [
            "X",
            "Y",
            "Z"
          ],
          "value": "    ((SDL_IMAGE_MAJOR_VERSION >= X) && \\\n     (SDL_IMAGE_MAJOR_VERSION > X || SDL_IMAGE_MINOR_VERSION >= Y) && \\\n     (SDL_IMAGE_MAJOR_VERSION > X || SDL_IMAGE_MINOR_VERSION > Y || SDL_IMAGE_MICRO_VERSION >= Z))",
          "sourceName": "SDL_IMAGE_VERSION_ATLEAST"
        },
        "IMG_Version": {
          "doc": "This function gets the version of the dynamically linked SDL_image library.\n\n@returns SDL_image version.\n\n@since This function is available since SDL_image 3.0.0.",
          "name": "IMG_Version",
          "kind": "function",
          "type": "int",
          "parameters": [],
          "sourceName": "IMG_Version"
        },
        "LoadSurface": [
          {
            "doc": "Load an image from an SDL data source into a software surface.\n\nAn SurfaceBase is a buffer of pixels in memory accessible by the CPU. Use\nthis if you plan to hand the data to something else or manipulate it\nfurther in code.\n\nThere are no guarantees about what format the new SurfaceBase data will be;\nin many cases, SDL_image will attempt to supply a surface that exactly\nmatches the provided image, but in others it might have to convert (either\nbecause the image is in a format that SDL doesn't directly support or\nbecause it's compressed data that could reasonably uncompress to various\nformats and SDL_image had to pick one). You can inspect an SurfaceBase for\nits specifics, and use SurfaceBase.Convert to then migrate to any supported\nformat.\n\nIf the image format supports a transparent pixel, SDL will set the colorkey\nfor the surface. You can enable RLE acceleration on the surface afterwards\nby calling: SurfaceBase.SetColorKey(image, SDL_RLEACCEL,\nimage->format->colorkey);\n\nIf `closeio` is true, `src` will be closed before returning, whether this\nfunction succeeds or not. SDL_image reads everything it needs from `src`\nduring this call in any case.\n\nEven though this function accepts a file type, SDL_image may still try\nother decoders that are capable of detecting file type from the contents of\nthe image data, but may rely on the caller-provided type string for formats\nthat it cannot autodetect. If `type` is nullptr, SDL_image will rely solely on\nits ability to guess the format.\n\nThere is a separate function to read files from disk without having to deal\nwith IOStreamBase: `LoadSurface(\"filename.jpg\")` will call this function and\nmanage those details for you, determining the file type from the filename's\nextension.\n\nThere is also LoadSurface(), which is equivalent to this function except\nthat it will rely on SDL_image to determine what type of data it is\nloading, much like passing a nullptr for type.\n\nIf you are using SDL's 2D rendering API, there is an equivalent call to\nload images directly into an TextureBase for use by the GPU without using a\nsoftware surface: call LoadTexture() instead.\n\nWhen done with the returned surface, the app should dispose of it with a\ncall to SurfaceBase.Destroy().\n\n@param src an IOStreamBase that data will be read from.\n@param closeio true to close/free the IOStreamBase before returning, false\n               to leave it open.\n@param type a filename extension that represent this data (\"BMP\", \"GIF\",\n            \"PNG\", etc).\n@returns a new SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadSurface\n@sa LoadSurface\n@sa SurfaceBase.Destroy",
            "name": "LoadSurface",
            "kind": "function",
            "type": "Surface",
            "parameters": [
              {
                "name": "src",
                "type": "ObjectBox<SDL_IOStream> auto &&"
              },
              {
                "name": "type",
                "type": "StringParam"
              }
            ],
            "sourceName": "IMG_LoadTyped_IO"
          },
          {
            "doc": "Load an image from a filesystem path into a software surface.\n\nAn SurfaceBase is a buffer of pixels in memory accessible by the CPU. Use\nthis if you plan to hand the data to something else or manipulate it\nfurther in code.\n\nThere are no guarantees about what format the new SurfaceBase data will be;\nin many cases, SDL_image will attempt to supply a surface that exactly\nmatches the provided image, but in others it might have to convert (either\nbecause the image is in a format that SDL doesn't directly support or\nbecause it's compressed data that could reasonably uncompress to various\nformats and SDL_image had to pick one). You can inspect an SurfaceBase for\nits specifics, and use SurfaceBase.Convert to then migrate to any supported\nformat.\n\nIf the image format supports a transparent pixel, SDL will set the colorkey\nfor the surface. You can enable RLE acceleration on the surface afterwards\nby calling: SurfaceBase.SetColorKey(image, SDL_RLEACCEL,\nimage->format->colorkey);\n\nThere is a separate function to read files from an IOStreamBase, if you\nneed an i/o abstraction to provide data from anywhere instead of a simple\nfilesystem read; that function is LoadSurface().\n\nIf you are using SDL's 2D rendering API, there is an equivalent call to\nload images directly into an TextureBase for use by the GPU without using a\nsoftware surface: call LoadTexture() instead.\n\nWhen done with the returned surface, the app should dispose of it with a\ncall to\n[SurfaceBase.Destroy](https://wiki.libsdl.org/SDL3/SurfaceBase.Destroy)\n().\n\n@param file a path on the filesystem to load an image from.\n@returns a new SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadSurface\n@sa LoadSurface\n@sa SurfaceBase.Destroy",
            "name": "LoadSurface",
            "kind": "function",
            "type": "Surface",
            "parameters": [
              {
                "name": "file",
                "type": "StringParam"
              }
            ],
            "sourceName": "IMG_Load"
          },
          {
            "doc": "Load an image from an SDL data source into a software surface.\n\nAn SurfaceBase is a buffer of pixels in memory accessible by the CPU. Use\nthis if you plan to hand the data to something else or manipulate it\nfurther in code.\n\nThere are no guarantees about what format the new SurfaceBase data will be;\nin many cases, SDL_image will attempt to supply a surface that exactly\nmatches the provided image, but in others it might have to convert (either\nbecause the image is in a format that SDL doesn't directly support or\nbecause it's compressed data that could reasonably uncompress to various\nformats and SDL_image had to pick one). You can inspect an SurfaceBase for\nits specifics, and use SurfaceBase.Convert to then migrate to any supported\nformat.\n\nIf the image format supports a transparent pixel, SDL will set the colorkey\nfor the surface. You can enable RLE acceleration on the surface afterwards\nby calling: SurfaceBase.SetColorKey(image, SDL_RLEACCEL,\nimage->format->colorkey);\n\nIf `closeio` is true, `src` will be closed before returning, whether this\nfunction succeeds or not. SDL_image reads everything it needs from `src`\nduring this call in any case.\n\nThere is a separate function to read files from disk without having to deal\nwith IOStreamBase: `LoadSurface(\"filename.jpg\")` will call this function and\nmanage those details for you, determining the file type from the filename's\nextension.\n\nThere is also LoadSurface(), which is equivalent to this function\nexcept a file extension (like \"BMP\", \"JPG\", etc) can be specified, in case\nSDL_image cannot autodetect the file format.\n\nIf you are using SDL's 2D rendering API, there is an equivalent call to\nload images directly into an TextureBase for use by the GPU without using a\nsoftware surface: call LoadTexture() instead.\n\nWhen done with the returned surface, the app should dispose of it with a\ncall to SurfaceBase.Destroy().\n\n@param src an IOStreamBase that data will be read from.\n@param closeio true to close/free the IOStreamBase before returning, false\n               to leave it open.\n@returns a new SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadSurface\n@sa LoadSurface\n@sa SurfaceBase.Destroy",
            "name": "LoadSurface",
            "kind": "function",
            "type": "Surface",
            "parameters": [
              {
                "name": "src",
                "type": "ObjectBox<SDL_IOStream> auto &&"
              }
            ],
            "sourceName": "IMG_Load_IO"
          }
        ],
        "LoadTexture": [
          {
            "doc": "Load an image from a filesystem path into a GPU texture.\n\nAn TextureBase represents an image in GPU memory, usable by SDL's 2D Render\nAPI. This can be significantly more efficient than using a CPU-bound\nSurfaceBase if you don't need to manipulate the image directly after\nloading it.\n\nIf the loaded image has transparency or a colorkey, a texture with an alpha\nchannel will be created. Otherwise, SDL_image will attempt to create an\nTextureBase in the most format that most reasonably represents the image\ndata (but in many cases, this will just end up being 32-bit RGB or 32-bit\nRGBA).\n\nThere is a separate function to read files from an IOStreamBase, if you\nneed an i/o abstraction to provide data from anywhere instead of a simple\nfilesystem read; that function is LoadTexture().\n\nIf you would rather decode an image to an SurfaceBase (a buffer of pixels\nin CPU memory), call LoadSurface() instead.\n\nWhen done with the returned texture, the app should dispose of it with a\ncall to TextureBase.Destroy().\n\n@param renderer the RendererBase to use to create the GPU texture.\n@param file a path on the filesystem to load an image from.\n@returns a new texture, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadTexture\n@sa LoadTexture",
            "name": "LoadTexture",
            "kind": "function",
            "type": "Texture",
            "parameters": [
              {
                "name": "renderer",
                "type": "RendererRef"
              },
              {
                "name": "file",
                "type": "StringParam"
              }
            ],
            "sourceName": "IMG_LoadTexture"
          },
          {
            "doc": "Load an image from an SDL data source into a GPU texture.\n\nAn TextureBase represents an image in GPU memory, usable by SDL's 2D Render\nAPI. This can be significantly more efficient than using a CPU-bound\nSurfaceBase if you don't need to manipulate the image directly after\nloading it.\n\nIf the loaded image has transparency or a colorkey, a texture with an alpha\nchannel will be created. Otherwise, SDL_image will attempt to create an\nTextureBase in the most format that most reasonably represents the image\ndata (but in many cases, this will just end up being 32-bit RGB or 32-bit\nRGBA).\n\nIf `closeio` is true, `src` will be closed before returning, whether this\nfunction succeeds or not. SDL_image reads everything it needs from `src`\nduring this call in any case.\n\nThere is a separate function to read files from disk without having to deal\nwith IOStreamBase: `LoadTexture(renderer, \"filename.jpg\")` will call\nthis function and manage those details for you, determining the file type\nfrom the filename's extension.\n\nThere is also LoadTexture(), which is equivalent to this\nfunction except a file extension (like \"BMP\", \"JPG\", etc) can be specified,\nin case SDL_image cannot autodetect the file format.\n\nIf you would rather decode an image to an SurfaceBase (a buffer of pixels\nin CPU memory), call LoadSurface() instead.\n\nWhen done with the returned texture, the app should dispose of it with a\ncall to TextureBase.Destroy().\n\n@param renderer the RendererBase to use to create the GPU texture.\n@param src an IOStreamBase that data will be read from.\n@param closeio true to close/free the IOStreamBase before returning, false\n               to leave it open.\n@returns a new texture, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadTexture\n@sa LoadTexture\n@sa TextureBase.Destroy",
            "name": "LoadTexture",
            "kind": "function",
            "type": "Texture",
            "parameters": [
              {
                "name": "renderer",
                "type": "RendererRef"
              },
              {
                "name": "src",
                "type": "ObjectBox<SDL_IOStream> auto &&"
              }
            ],
            "sourceName": "IMG_LoadTexture_IO"
          },
          {
            "doc": "Load an image from an SDL data source into a GPU texture.\n\nAn TextureBase represents an image in GPU memory, usable by SDL's 2D Render\nAPI. This can be significantly more efficient than using a CPU-bound\nSurfaceBase if you don't need to manipulate the image directly after\nloading it.\n\nIf the loaded image has transparency or a colorkey, a texture with an alpha\nchannel will be created. Otherwise, SDL_image will attempt to create an\nTextureBase in the most format that most reasonably represents the image\ndata (but in many cases, this will just end up being 32-bit RGB or 32-bit\nRGBA).\n\nIf `closeio` is true, `src` will be closed before returning, whether this\nfunction succeeds or not. SDL_image reads everything it needs from `src`\nduring this call in any case.\n\nEven though this function accepts a file type, SDL_image may still try\nother decoders that are capable of detecting file type from the contents of\nthe image data, but may rely on the caller-provided type string for formats\nthat it cannot autodetect. If `type` is nullptr, SDL_image will rely solely on\nits ability to guess the format.\n\nThere is a separate function to read files from disk without having to deal\nwith IOStreamBase: `LoadTexture(\"filename.jpg\")` will call this\nfunction and manage those details for you, determining the file type from\nthe filename's extension.\n\nThere is also LoadTexture(), which is equivalent to this function\nexcept that it will rely on SDL_image to determine what type of data it is\nloading, much like passing a nullptr for type.\n\nIf you would rather decode an image to an SurfaceBase (a buffer of pixels\nin CPU memory), call LoadSurface() instead.\n\nWhen done with the returned texture, the app should dispose of it with a\ncall to TextureBase.Destroy().\n\n@param renderer the RendererBase to use to create the GPU texture.\n@param src an IOStreamBase that data will be read from.\n@param closeio true to close/free the IOStreamBase before returning, false\n               to leave it open.\n@param type a filename extension that represent this data (\"BMP\", \"GIF\",\n            \"PNG\", etc).\n@returns a new texture, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadTexture\n@sa LoadTexture\n@sa TextureBase.Destroy",
            "name": "LoadTexture",
            "kind": "function",
            "type": "Texture",
            "parameters": [
              {
                "name": "renderer",
                "type": "RendererRef"
              },
              {
                "name": "src",
                "type": "ObjectBox<SDL_IOStream> auto &&"
              },
              {
                "name": "type",
                "type": "StringParam"
              }
            ],
            "sourceName": "IMG_LoadTextureTyped_IO"
          }
        ],
        "isAVIF": {
          "doc": "Detect AVIF image data on a readable/seekable IOStreamBase.\n\nThis function attempts to determine if a file is a given filetype, reading\nthe least amount possible from the IOStreamBase (usually a few bytes).\n\nThere is no distinction made between \"not the filetype in question\" and\nbasic i/o errors.\n\nThis function will always attempt to seek `src` back to where it started\nwhen this function was called, but it will not report any errors in doing\nso, but assuming seeking works, this means you can immediately use this\nwith a different IMG_isTYPE function, or load the image without further\nseeking.\n\nYou do not need to call this function to load data; SDL_image can work to\ndetermine file type in many cases in its standard load functions.\n\n@param src a seekable/readable IOStreamBase to provide image data.\n@returns non-zero if this is AVIF data, zero otherwise.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa isAVIF\n@sa isICO\n@sa isCUR\n@sa isBMP\n@sa isGIF\n@sa isJPG\n@sa isJXL\n@sa isLBM\n@sa isPCX\n@sa isPNG\n@sa isPNM\n@sa isSVG\n@sa isQOI\n@sa isTIF\n@sa isXCF\n@sa isXPM\n@sa isXV\n@sa isWEBP",
          "name": "isAVIF",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_isAVIF"
        },
        "isICO": {
          "doc": "Detect ICO image data on a readable/seekable IOStreamBase.\n\nThis function attempts to determine if a file is a given filetype, reading\nthe least amount possible from the IOStreamBase (usually a few bytes).\n\nThere is no distinction made between \"not the filetype in question\" and\nbasic i/o errors.\n\nThis function will always attempt to seek `src` back to where it started\nwhen this function was called, but it will not report any errors in doing\nso, but assuming seeking works, this means you can immediately use this\nwith a different IMG_isTYPE function, or load the image without further\nseeking.\n\nYou do not need to call this function to load data; SDL_image can work to\ndetermine file type in many cases in its standard load functions.\n\n@param src a seekable/readable IOStreamBase to provide image data.\n@returns non-zero if this is ICO data, zero otherwise.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa isAVIF\n@sa isCUR\n@sa isBMP\n@sa isGIF\n@sa isJPG\n@sa isJXL\n@sa isLBM\n@sa isPCX\n@sa isPNG\n@sa isPNM\n@sa isSVG\n@sa isQOI\n@sa isTIF\n@sa isXCF\n@sa isXPM\n@sa isXV\n@sa isWEBP",
          "name": "isICO",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_isICO"
        },
        "isCUR": {
          "doc": "Detect CUR image data on a readable/seekable IOStreamBase.\n\nThis function attempts to determine if a file is a given filetype, reading\nthe least amount possible from the IOStreamBase (usually a few bytes).\n\nThere is no distinction made between \"not the filetype in question\" and\nbasic i/o errors.\n\nThis function will always attempt to seek `src` back to where it started\nwhen this function was called, but it will not report any errors in doing\nso, but assuming seeking works, this means you can immediately use this\nwith a different IMG_isTYPE function, or load the image without further\nseeking.\n\nYou do not need to call this function to load data; SDL_image can work to\ndetermine file type in many cases in its standard load functions.\n\n@param src a seekable/readable IOStreamBase to provide image data.\n@returns non-zero if this is CUR data, zero otherwise.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa isAVIF\n@sa isICO\n@sa isBMP\n@sa isGIF\n@sa isJPG\n@sa isJXL\n@sa isLBM\n@sa isPCX\n@sa isPNG\n@sa isPNM\n@sa isSVG\n@sa isQOI\n@sa isTIF\n@sa isXCF\n@sa isXPM\n@sa isXV\n@sa isWEBP",
          "name": "isCUR",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_isCUR"
        },
        "isBMP": {
          "doc": "Detect BMP image data on a readable/seekable IOStreamBase.\n\nThis function attempts to determine if a file is a given filetype, reading\nthe least amount possible from the IOStreamBase (usually a few bytes).\n\nThere is no distinction made between \"not the filetype in question\" and\nbasic i/o errors.\n\nThis function will always attempt to seek `src` back to where it started\nwhen this function was called, but it will not report any errors in doing\nso, but assuming seeking works, this means you can immediately use this\nwith a different IMG_isTYPE function, or load the image without further\nseeking.\n\nYou do not need to call this function to load data; SDL_image can work to\ndetermine file type in many cases in its standard load functions.\n\n@param src a seekable/readable IOStreamBase to provide image data.\n@returns non-zero if this is BMP data, zero otherwise.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa isAVIF\n@sa isICO\n@sa isCUR\n@sa isGIF\n@sa isJPG\n@sa isJXL\n@sa isLBM\n@sa isPCX\n@sa isPNG\n@sa isPNM\n@sa isSVG\n@sa isQOI\n@sa isTIF\n@sa isXCF\n@sa isXPM\n@sa isXV\n@sa isWEBP",
          "name": "isBMP",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_isBMP"
        },
        "isGIF": {
          "doc": "Detect GIF image data on a readable/seekable IOStreamBase.\n\nThis function attempts to determine if a file is a given filetype, reading\nthe least amount possible from the IOStreamBase (usually a few bytes).\n\nThere is no distinction made between \"not the filetype in question\" and\nbasic i/o errors.\n\nThis function will always attempt to seek `src` back to where it started\nwhen this function was called, but it will not report any errors in doing\nso, but assuming seeking works, this means you can immediately use this\nwith a different IMG_isTYPE function, or load the image without further\nseeking.\n\nYou do not need to call this function to load data; SDL_image can work to\ndetermine file type in many cases in its standard load functions.\n\n@param src a seekable/readable IOStreamBase to provide image data.\n@returns non-zero if this is GIF data, zero otherwise.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa isAVIF\n@sa isICO\n@sa isCUR\n@sa isBMP\n@sa isJPG\n@sa isJXL\n@sa isLBM\n@sa isPCX\n@sa isPNG\n@sa isPNM\n@sa isSVG\n@sa isQOI\n@sa isTIF\n@sa isXCF\n@sa isXPM\n@sa isXV\n@sa isWEBP",
          "name": "isGIF",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_isGIF"
        },
        "isJPG": {
          "doc": "Detect JPG image data on a readable/seekable IOStreamBase.\n\nThis function attempts to determine if a file is a given filetype, reading\nthe least amount possible from the IOStreamBase (usually a few bytes).\n\nThere is no distinction made between \"not the filetype in question\" and\nbasic i/o errors.\n\nThis function will always attempt to seek `src` back to where it started\nwhen this function was called, but it will not report any errors in doing\nso, but assuming seeking works, this means you can immediately use this\nwith a different IMG_isTYPE function, or load the image without further\nseeking.\n\nYou do not need to call this function to load data; SDL_image can work to\ndetermine file type in many cases in its standard load functions.\n\n@param src a seekable/readable IOStreamBase to provide image data.\n@returns non-zero if this is JPG data, zero otherwise.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa isAVIF\n@sa isICO\n@sa isCUR\n@sa isBMP\n@sa isGIF\n@sa isJXL\n@sa isLBM\n@sa isPCX\n@sa isPNG\n@sa isPNM\n@sa isSVG\n@sa isQOI\n@sa isTIF\n@sa isXCF\n@sa isXPM\n@sa isXV\n@sa isWEBP",
          "name": "isJPG",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_isJPG"
        },
        "isJXL": {
          "doc": "Detect JXL image data on a readable/seekable IOStreamBase.\n\nThis function attempts to determine if a file is a given filetype, reading\nthe least amount possible from the IOStreamBase (usually a few bytes).\n\nThere is no distinction made between \"not the filetype in question\" and\nbasic i/o errors.\n\nThis function will always attempt to seek `src` back to where it started\nwhen this function was called, but it will not report any errors in doing\nso, but assuming seeking works, this means you can immediately use this\nwith a different IMG_isTYPE function, or load the image without further\nseeking.\n\nYou do not need to call this function to load data; SDL_image can work to\ndetermine file type in many cases in its standard load functions.\n\n@param src a seekable/readable IOStreamBase to provide image data.\n@returns non-zero if this is JXL data, zero otherwise.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa isAVIF\n@sa isICO\n@sa isCUR\n@sa isBMP\n@sa isGIF\n@sa isJPG\n@sa isLBM\n@sa isPCX\n@sa isPNG\n@sa isPNM\n@sa isSVG\n@sa isQOI\n@sa isTIF\n@sa isXCF\n@sa isXPM\n@sa isXV\n@sa isWEBP",
          "name": "isJXL",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_isJXL"
        },
        "isLBM": {
          "doc": "Detect LBM image data on a readable/seekable IOStreamBase.\n\nThis function attempts to determine if a file is a given filetype, reading\nthe least amount possible from the IOStreamBase (usually a few bytes).\n\nThere is no distinction made between \"not the filetype in question\" and\nbasic i/o errors.\n\nThis function will always attempt to seek `src` back to where it started\nwhen this function was called, but it will not report any errors in doing\nso, but assuming seeking works, this means you can immediately use this\nwith a different IMG_isTYPE function, or load the image without further\nseeking.\n\nYou do not need to call this function to load data; SDL_image can work to\ndetermine file type in many cases in its standard load functions.\n\n@param src a seekable/readable IOStreamBase to provide image data.\n@returns non-zero if this is LBM data, zero otherwise.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa isAVIF\n@sa isICO\n@sa isCUR\n@sa isBMP\n@sa isGIF\n@sa isJPG\n@sa isJXL\n@sa isPCX\n@sa isPNG\n@sa isPNM\n@sa isSVG\n@sa isQOI\n@sa isTIF\n@sa isXCF\n@sa isXPM\n@sa isXV\n@sa isWEBP",
          "name": "isLBM",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_isLBM"
        },
        "isPCX": {
          "doc": "Detect PCX image data on a readable/seekable IOStreamBase.\n\nThis function attempts to determine if a file is a given filetype, reading\nthe least amount possible from the IOStreamBase (usually a few bytes).\n\nThere is no distinction made between \"not the filetype in question\" and\nbasic i/o errors.\n\nThis function will always attempt to seek `src` back to where it started\nwhen this function was called, but it will not report any errors in doing\nso, but assuming seeking works, this means you can immediately use this\nwith a different IMG_isTYPE function, or load the image without further\nseeking.\n\nYou do not need to call this function to load data; SDL_image can work to\ndetermine file type in many cases in its standard load functions.\n\n@param src a seekable/readable IOStreamBase to provide image data.\n@returns non-zero if this is PCX data, zero otherwise.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa isAVIF\n@sa isICO\n@sa isCUR\n@sa isBMP\n@sa isGIF\n@sa isJPG\n@sa isJXL\n@sa isLBM\n@sa isPNG\n@sa isPNM\n@sa isSVG\n@sa isQOI\n@sa isTIF\n@sa isXCF\n@sa isXPM\n@sa isXV\n@sa isWEBP",
          "name": "isPCX",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_isPCX"
        },
        "isPNG": {
          "doc": "Detect PNG image data on a readable/seekable IOStreamBase.\n\nThis function attempts to determine if a file is a given filetype, reading\nthe least amount possible from the IOStreamBase (usually a few bytes).\n\nThere is no distinction made between \"not the filetype in question\" and\nbasic i/o errors.\n\nThis function will always attempt to seek `src` back to where it started\nwhen this function was called, but it will not report any errors in doing\nso, but assuming seeking works, this means you can immediately use this\nwith a different IMG_isTYPE function, or load the image without further\nseeking.\n\nYou do not need to call this function to load data; SDL_image can work to\ndetermine file type in many cases in its standard load functions.\n\n@param src a seekable/readable IOStreamBase to provide image data.\n@returns non-zero if this is PNG data, zero otherwise.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa isAVIF\n@sa isICO\n@sa isCUR\n@sa isBMP\n@sa isGIF\n@sa isJPG\n@sa isJXL\n@sa isLBM\n@sa isPCX\n@sa isPNM\n@sa isSVG\n@sa isQOI\n@sa isTIF\n@sa isXCF\n@sa isXPM\n@sa isXV\n@sa isWEBP",
          "name": "isPNG",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_isPNG"
        },
        "isPNM": {
          "doc": "Detect PNM image data on a readable/seekable IOStreamBase.\n\nThis function attempts to determine if a file is a given filetype, reading\nthe least amount possible from the IOStreamBase (usually a few bytes).\n\nThere is no distinction made between \"not the filetype in question\" and\nbasic i/o errors.\n\nThis function will always attempt to seek `src` back to where it started\nwhen this function was called, but it will not report any errors in doing\nso, but assuming seeking works, this means you can immediately use this\nwith a different IMG_isTYPE function, or load the image without further\nseeking.\n\nYou do not need to call this function to load data; SDL_image can work to\ndetermine file type in many cases in its standard load functions.\n\n@param src a seekable/readable IOStreamBase to provide image data.\n@returns non-zero if this is PNM data, zero otherwise.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa isAVIF\n@sa isICO\n@sa isCUR\n@sa isBMP\n@sa isGIF\n@sa isJPG\n@sa isJXL\n@sa isLBM\n@sa isPCX\n@sa isPNG\n@sa isSVG\n@sa isQOI\n@sa isTIF\n@sa isXCF\n@sa isXPM\n@sa isXV\n@sa isWEBP",
          "name": "isPNM",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_isPNM"
        },
        "isSVG": {
          "doc": "Detect SVG image data on a readable/seekable IOStreamBase.\n\nThis function attempts to determine if a file is a given filetype, reading\nthe least amount possible from the IOStreamBase (usually a few bytes).\n\nThere is no distinction made between \"not the filetype in question\" and\nbasic i/o errors.\n\nThis function will always attempt to seek `src` back to where it started\nwhen this function was called, but it will not report any errors in doing\nso, but assuming seeking works, this means you can immediately use this\nwith a different IMG_isTYPE function, or load the image without further\nseeking.\n\nYou do not need to call this function to load data; SDL_image can work to\ndetermine file type in many cases in its standard load functions.\n\n@param src a seekable/readable IOStreamBase to provide image data.\n@returns non-zero if this is SVG data, zero otherwise.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa isAVIF\n@sa isICO\n@sa isCUR\n@sa isBMP\n@sa isGIF\n@sa isJPG\n@sa isJXL\n@sa isLBM\n@sa isPCX\n@sa isPNG\n@sa isPNM\n@sa isQOI\n@sa isTIF\n@sa isXCF\n@sa isXPM\n@sa isXV\n@sa isWEBP",
          "name": "isSVG",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_isSVG"
        },
        "isQOI": {
          "doc": "Detect QOI image data on a readable/seekable IOStreamBase.\n\nThis function attempts to determine if a file is a given filetype, reading\nthe least amount possible from the IOStreamBase (usually a few bytes).\n\nThere is no distinction made between \"not the filetype in question\" and\nbasic i/o errors.\n\nThis function will always attempt to seek `src` back to where it started\nwhen this function was called, but it will not report any errors in doing\nso, but assuming seeking works, this means you can immediately use this\nwith a different IMG_isTYPE function, or load the image without further\nseeking.\n\nYou do not need to call this function to load data; SDL_image can work to\ndetermine file type in many cases in its standard load functions.\n\n@param src a seekable/readable IOStreamBase to provide image data.\n@returns non-zero if this is QOI data, zero otherwise.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa isAVIF\n@sa isICO\n@sa isCUR\n@sa isBMP\n@sa isGIF\n@sa isJPG\n@sa isJXL\n@sa isLBM\n@sa isPCX\n@sa isPNG\n@sa isPNM\n@sa isSVG\n@sa isTIF\n@sa isXCF\n@sa isXPM\n@sa isXV\n@sa isWEBP",
          "name": "isQOI",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_isQOI"
        },
        "isTIF": {
          "doc": "Detect TIFF image data on a readable/seekable IOStreamBase.\n\nThis function attempts to determine if a file is a given filetype, reading\nthe least amount possible from the IOStreamBase (usually a few bytes).\n\nThere is no distinction made between \"not the filetype in question\" and\nbasic i/o errors.\n\nThis function will always attempt to seek `src` back to where it started\nwhen this function was called, but it will not report any errors in doing\nso, but assuming seeking works, this means you can immediately use this\nwith a different IMG_isTYPE function, or load the image without further\nseeking.\n\nYou do not need to call this function to load data; SDL_image can work to\ndetermine file type in many cases in its standard load functions.\n\n@param src a seekable/readable IOStreamBase to provide image data.\n@returns non-zero if this is TIFF data, zero otherwise.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa isAVIF\n@sa isICO\n@sa isCUR\n@sa isBMP\n@sa isGIF\n@sa isJPG\n@sa isJXL\n@sa isLBM\n@sa isPCX\n@sa isPNG\n@sa isPNM\n@sa isSVG\n@sa isQOI\n@sa isXCF\n@sa isXPM\n@sa isXV\n@sa isWEBP",
          "name": "isTIF",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_isTIF"
        },
        "isXCF": {
          "doc": "Detect XCF image data on a readable/seekable IOStreamBase.\n\nThis function attempts to determine if a file is a given filetype, reading\nthe least amount possible from the IOStreamBase (usually a few bytes).\n\nThere is no distinction made between \"not the filetype in question\" and\nbasic i/o errors.\n\nThis function will always attempt to seek `src` back to where it started\nwhen this function was called, but it will not report any errors in doing\nso, but assuming seeking works, this means you can immediately use this\nwith a different IMG_isTYPE function, or load the image without further\nseeking.\n\nYou do not need to call this function to load data; SDL_image can work to\ndetermine file type in many cases in its standard load functions.\n\n@param src a seekable/readable IOStreamBase to provide image data.\n@returns non-zero if this is XCF data, zero otherwise.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa isAVIF\n@sa isICO\n@sa isCUR\n@sa isBMP\n@sa isGIF\n@sa isJPG\n@sa isJXL\n@sa isLBM\n@sa isPCX\n@sa isPNG\n@sa isPNM\n@sa isSVG\n@sa isQOI\n@sa isTIF\n@sa isXPM\n@sa isXV\n@sa isWEBP",
          "name": "isXCF",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_isXCF"
        },
        "isXPM": {
          "doc": "Detect XPM image data on a readable/seekable IOStreamBase.\n\nThis function attempts to determine if a file is a given filetype, reading\nthe least amount possible from the IOStreamBase (usually a few bytes).\n\nThere is no distinction made between \"not the filetype in question\" and\nbasic i/o errors.\n\nThis function will always attempt to seek `src` back to where it started\nwhen this function was called, but it will not report any errors in doing\nso, but assuming seeking works, this means you can immediately use this\nwith a different IMG_isTYPE function, or load the image without further\nseeking.\n\nYou do not need to call this function to load data; SDL_image can work to\ndetermine file type in many cases in its standard load functions.\n\n@param src a seekable/readable IOStreamBase to provide image data.\n@returns non-zero if this is XPM data, zero otherwise.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa isAVIF\n@sa isICO\n@sa isCUR\n@sa isBMP\n@sa isGIF\n@sa isJPG\n@sa isJXL\n@sa isLBM\n@sa isPCX\n@sa isPNG\n@sa isPNM\n@sa isSVG\n@sa isQOI\n@sa isTIF\n@sa isXCF\n@sa isXV\n@sa isWEBP",
          "name": "isXPM",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_isXPM"
        },
        "isXV": {
          "doc": "Detect XV image data on a readable/seekable IOStreamBase.\n\nThis function attempts to determine if a file is a given filetype, reading\nthe least amount possible from the IOStreamBase (usually a few bytes).\n\nThere is no distinction made between \"not the filetype in question\" and\nbasic i/o errors.\n\nThis function will always attempt to seek `src` back to where it started\nwhen this function was called, but it will not report any errors in doing\nso, but assuming seeking works, this means you can immediately use this\nwith a different IMG_isTYPE function, or load the image without further\nseeking.\n\nYou do not need to call this function to load data; SDL_image can work to\ndetermine file type in many cases in its standard load functions.\n\n@param src a seekable/readable IOStreamBase to provide image data.\n@returns non-zero if this is XV data, zero otherwise.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa isAVIF\n@sa isICO\n@sa isCUR\n@sa isBMP\n@sa isGIF\n@sa isJPG\n@sa isJXL\n@sa isLBM\n@sa isPCX\n@sa isPNG\n@sa isPNM\n@sa isSVG\n@sa isQOI\n@sa isTIF\n@sa isXCF\n@sa isXPM\n@sa isWEBP",
          "name": "isXV",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_isXV"
        },
        "isWEBP": {
          "doc": "Detect WEBP image data on a readable/seekable IOStreamBase.\n\nThis function attempts to determine if a file is a given filetype, reading\nthe least amount possible from the IOStreamBase (usually a few bytes).\n\nThere is no distinction made between \"not the filetype in question\" and\nbasic i/o errors.\n\nThis function will always attempt to seek `src` back to where it started\nwhen this function was called, but it will not report any errors in doing\nso, but assuming seeking works, this means you can immediately use this\nwith a different IMG_isTYPE function, or load the image without further\nseeking.\n\nYou do not need to call this function to load data; SDL_image can work to\ndetermine file type in many cases in its standard load functions.\n\n@param src a seekable/readable IOStreamBase to provide image data.\n@returns non-zero if this is WEBP data, zero otherwise.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa isAVIF\n@sa isICO\n@sa isCUR\n@sa isBMP\n@sa isGIF\n@sa isJPG\n@sa isJXL\n@sa isLBM\n@sa isPCX\n@sa isPNG\n@sa isPNM\n@sa isSVG\n@sa isQOI\n@sa isTIF\n@sa isXCF\n@sa isXPM\n@sa isXV",
          "name": "isWEBP",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_isWEBP"
        },
        "LoadAVIF": {
          "doc": "Load a AVIF image directly.\n\nIf you know you definitely have a AVIF image, you can call this function,\nwhich will skip SDL_image's file format detection routines. Generally it's\nbetter to use the abstract interfaces; also, there is only an IOStreamBase\ninterface available here.\n\n@param src an IOStreamBase to load image data from.\n@returns SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadICO\n@sa LoadCUR\n@sa IMG_LoadBMP_IO\n@sa LoadGIF\n@sa LoadJPG\n@sa LoadJXL\n@sa LoadLBM\n@sa LoadPCX\n@sa LoadPNG\n@sa LoadPNM\n@sa LoadSVG\n@sa LoadQOI\n@sa LoadTGA\n@sa LoadTIF\n@sa LoadXCF\n@sa LoadXPM\n@sa LoadXV\n@sa LoadWEBP",
          "name": "LoadAVIF",
          "kind": "function",
          "type": "Surface",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_LoadAVIF_IO"
        },
        "LoadICO": {
          "doc": "Load a ICO image directly.\n\nIf you know you definitely have a ICO image, you can call this function,\nwhich will skip SDL_image's file format detection routines. Generally it's\nbetter to use the abstract interfaces; also, there is only an IOStreamBase\ninterface available here.\n\n@param src an IOStreamBase to load image data from.\n@returns SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadAVIF\n@sa LoadCUR\n@sa IMG_LoadBMP_IO\n@sa LoadGIF\n@sa LoadJPG\n@sa LoadJXL\n@sa LoadLBM\n@sa LoadPCX\n@sa LoadPNG\n@sa LoadPNM\n@sa LoadSVG\n@sa LoadQOI\n@sa LoadTGA\n@sa LoadTIF\n@sa LoadXCF\n@sa LoadXPM\n@sa LoadXV\n@sa LoadWEBP",
          "name": "LoadICO",
          "kind": "function",
          "type": "Surface",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_LoadICO_IO"
        },
        "LoadCUR": {
          "doc": "Load a CUR image directly.\n\nIf you know you definitely have a CUR image, you can call this function,\nwhich will skip SDL_image's file format detection routines. Generally it's\nbetter to use the abstract interfaces; also, there is only an IOStreamBase\ninterface available here.\n\n@param src an IOStreamBase to load image data from.\n@returns SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadAVIF\n@sa LoadICO\n@sa IMG_LoadBMP_IO\n@sa LoadGIF\n@sa LoadJPG\n@sa LoadJXL\n@sa LoadLBM\n@sa LoadPCX\n@sa LoadPNG\n@sa LoadPNM\n@sa LoadSVG\n@sa LoadQOI\n@sa LoadTGA\n@sa LoadTIF\n@sa LoadXCF\n@sa LoadXPM\n@sa LoadXV\n@sa LoadWEBP",
          "name": "LoadCUR",
          "kind": "function",
          "type": "Surface",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_LoadCUR_IO"
        },
        "LoadGIF": {
          "doc": "Load a GIF image directly.\n\nIf you know you definitely have a GIF image, you can call this function,\nwhich will skip SDL_image's file format detection routines. Generally it's\nbetter to use the abstract interfaces; also, there is only an IOStreamBase\ninterface available here.\n\n@param src an IOStreamBase to load image data from.\n@returns SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadAVIF\n@sa LoadICO\n@sa LoadCUR\n@sa IMG_LoadBMP_IO\n@sa LoadJPG\n@sa LoadJXL\n@sa LoadLBM\n@sa LoadPCX\n@sa LoadPNG\n@sa LoadPNM\n@sa LoadSVG\n@sa LoadQOI\n@sa LoadTGA\n@sa LoadTIF\n@sa LoadXCF\n@sa LoadXPM\n@sa LoadXV\n@sa LoadWEBP",
          "name": "LoadGIF",
          "kind": "function",
          "type": "Surface",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_LoadGIF_IO"
        },
        "LoadJPG": {
          "doc": "Load a JPG image directly.\n\nIf you know you definitely have a JPG image, you can call this function,\nwhich will skip SDL_image's file format detection routines. Generally it's\nbetter to use the abstract interfaces; also, there is only an IOStreamBase\ninterface available here.\n\n@param src an IOStreamBase to load image data from.\n@returns SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadAVIF\n@sa LoadICO\n@sa LoadCUR\n@sa IMG_LoadBMP_IO\n@sa LoadGIF\n@sa LoadJXL\n@sa LoadLBM\n@sa LoadPCX\n@sa LoadPNG\n@sa LoadPNM\n@sa LoadSVG\n@sa LoadQOI\n@sa LoadTGA\n@sa LoadTIF\n@sa LoadXCF\n@sa LoadXPM\n@sa LoadXV\n@sa LoadWEBP",
          "name": "LoadJPG",
          "kind": "function",
          "type": "Surface",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_LoadJPG_IO"
        },
        "LoadJXL": {
          "doc": "Load a JXL image directly.\n\nIf you know you definitely have a JXL image, you can call this function,\nwhich will skip SDL_image's file format detection routines. Generally it's\nbetter to use the abstract interfaces; also, there is only an IOStreamBase\ninterface available here.\n\n@param src an IOStreamBase to load image data from.\n@returns SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadAVIF\n@sa LoadICO\n@sa LoadCUR\n@sa IMG_LoadBMP_IO\n@sa LoadGIF\n@sa LoadJPG\n@sa LoadLBM\n@sa LoadPCX\n@sa LoadPNG\n@sa LoadPNM\n@sa LoadSVG\n@sa LoadQOI\n@sa LoadTGA\n@sa LoadTIF\n@sa LoadXCF\n@sa LoadXPM\n@sa LoadXV\n@sa LoadWEBP",
          "name": "LoadJXL",
          "kind": "function",
          "type": "Surface",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_LoadJXL_IO"
        },
        "LoadLBM": {
          "doc": "Load a LBM image directly.\n\nIf you know you definitely have a LBM image, you can call this function,\nwhich will skip SDL_image's file format detection routines. Generally it's\nbetter to use the abstract interfaces; also, there is only an IOStreamBase\ninterface available here.\n\n@param src an IOStreamBase to load image data from.\n@returns SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadAVIF\n@sa LoadICO\n@sa LoadCUR\n@sa IMG_LoadBMP_IO\n@sa LoadGIF\n@sa LoadJPG\n@sa LoadJXL\n@sa LoadPCX\n@sa LoadPNG\n@sa LoadPNM\n@sa LoadSVG\n@sa LoadQOI\n@sa LoadTGA\n@sa LoadTIF\n@sa LoadXCF\n@sa LoadXPM\n@sa LoadXV\n@sa LoadWEBP",
          "name": "LoadLBM",
          "kind": "function",
          "type": "Surface",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_LoadLBM_IO"
        },
        "LoadPCX": {
          "doc": "Load a PCX image directly.\n\nIf you know you definitely have a PCX image, you can call this function,\nwhich will skip SDL_image's file format detection routines. Generally it's\nbetter to use the abstract interfaces; also, there is only an IOStreamBase\ninterface available here.\n\n@param src an IOStreamBase to load image data from.\n@returns SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadAVIF\n@sa LoadICO\n@sa LoadCUR\n@sa IMG_LoadBMP_IO\n@sa LoadGIF\n@sa LoadJPG\n@sa LoadJXL\n@sa LoadLBM\n@sa LoadPNG\n@sa LoadPNM\n@sa LoadSVG\n@sa LoadQOI\n@sa LoadTGA\n@sa LoadTIF\n@sa LoadXCF\n@sa LoadXPM\n@sa LoadXV\n@sa LoadWEBP",
          "name": "LoadPCX",
          "kind": "function",
          "type": "Surface",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_LoadPCX_IO"
        },
        "LoadPNG": {
          "doc": "Load a PNG image directly.\n\nIf you know you definitely have a PNG image, you can call this function,\nwhich will skip SDL_image's file format detection routines. Generally it's\nbetter to use the abstract interfaces; also, there is only an IOStreamBase\ninterface available here.\n\n@param src an IOStreamBase to load image data from.\n@returns SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadAVIF\n@sa LoadICO\n@sa LoadCUR\n@sa IMG_LoadBMP_IO\n@sa LoadGIF\n@sa LoadJPG\n@sa LoadJXL\n@sa LoadLBM\n@sa LoadPCX\n@sa LoadPNM\n@sa LoadSVG\n@sa LoadQOI\n@sa LoadTGA\n@sa LoadTIF\n@sa LoadXCF\n@sa LoadXPM\n@sa LoadXV\n@sa LoadWEBP",
          "name": "LoadPNG",
          "kind": "function",
          "type": "Surface",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_LoadPNG_IO"
        },
        "LoadPNM": {
          "doc": "Load a PNM image directly.\n\nIf you know you definitely have a PNM image, you can call this function,\nwhich will skip SDL_image's file format detection routines. Generally it's\nbetter to use the abstract interfaces; also, there is only an IOStreamBase\ninterface available here.\n\n@param src an IOStreamBase to load image data from.\n@returns SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadAVIF\n@sa LoadICO\n@sa LoadCUR\n@sa IMG_LoadBMP_IO\n@sa LoadGIF\n@sa LoadJPG\n@sa LoadJXL\n@sa LoadLBM\n@sa LoadPCX\n@sa LoadPNG\n@sa LoadSVG\n@sa LoadQOI\n@sa LoadTGA\n@sa LoadTIF\n@sa LoadXCF\n@sa LoadXPM\n@sa LoadXV\n@sa LoadWEBP",
          "name": "LoadPNM",
          "kind": "function",
          "type": "Surface",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_LoadPNM_IO"
        },
        "LoadSVG": {
          "doc": "Load a SVG image directly.\n\nIf you know you definitely have a SVG image, you can call this function,\nwhich will skip SDL_image's file format detection routines. Generally it's\nbetter to use the abstract interfaces; also, there is only an IOStreamBase\ninterface available here.\n\n@param src an IOStreamBase to load image data from.\n@returns SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadAVIF\n@sa LoadICO\n@sa LoadCUR\n@sa IMG_LoadBMP_IO\n@sa LoadGIF\n@sa LoadJPG\n@sa LoadJXL\n@sa LoadLBM\n@sa LoadPCX\n@sa LoadPNG\n@sa LoadPNM\n@sa LoadQOI\n@sa LoadTGA\n@sa LoadTIF\n@sa LoadXCF\n@sa LoadXPM\n@sa LoadXV\n@sa LoadWEBP",
          "name": "LoadSVG",
          "kind": "function",
          "type": "Surface",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_LoadSVG_IO"
        },
        "LoadQOI": {
          "doc": "Load a QOI image directly.\n\nIf you know you definitely have a QOI image, you can call this function,\nwhich will skip SDL_image's file format detection routines. Generally it's\nbetter to use the abstract interfaces; also, there is only an IOStreamBase\ninterface available here.\n\n@param src an IOStreamBase to load image data from.\n@returns SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadAVIF\n@sa LoadICO\n@sa LoadCUR\n@sa IMG_LoadBMP_IO\n@sa LoadGIF\n@sa LoadJPG\n@sa LoadJXL\n@sa LoadLBM\n@sa LoadPCX\n@sa LoadPNG\n@sa LoadPNM\n@sa LoadSVG\n@sa LoadTGA\n@sa LoadTIF\n@sa LoadXCF\n@sa LoadXPM\n@sa LoadXV\n@sa LoadWEBP",
          "name": "LoadQOI",
          "kind": "function",
          "type": "Surface",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_LoadQOI_IO"
        },
        "LoadTGA": {
          "doc": "Load a TGA image directly.\n\nIf you know you definitely have a TGA image, you can call this function,\nwhich will skip SDL_image's file format detection routines. Generally it's\nbetter to use the abstract interfaces; also, there is only an IOStreamBase\ninterface available here.\n\n@param src an IOStreamBase to load image data from.\n@returns SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadAVIF\n@sa LoadICO\n@sa LoadCUR\n@sa IMG_LoadBMP_IO\n@sa LoadGIF\n@sa LoadJPG\n@sa LoadJXL\n@sa LoadLBM\n@sa LoadPCX\n@sa LoadPNG\n@sa LoadPNM\n@sa LoadSVG\n@sa LoadQOI\n@sa LoadTIF\n@sa LoadXCF\n@sa LoadXPM\n@sa LoadXV\n@sa LoadWEBP",
          "name": "LoadTGA",
          "kind": "function",
          "type": "Surface",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_LoadTGA_IO"
        },
        "LoadTIF": {
          "doc": "Load a TIFF image directly.\n\nIf you know you definitely have a TIFF image, you can call this function,\nwhich will skip SDL_image's file format detection routines. Generally it's\nbetter to use the abstract interfaces; also, there is only an IOStreamBase\ninterface available here.\n\n@param src an IOStreamBase to load image data from.\n@returns SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadAVIF\n@sa LoadICO\n@sa LoadCUR\n@sa IMG_LoadBMP_IO\n@sa LoadGIF\n@sa LoadJPG\n@sa LoadJXL\n@sa LoadLBM\n@sa LoadPCX\n@sa LoadPNG\n@sa LoadPNM\n@sa LoadSVG\n@sa LoadQOI\n@sa LoadTGA\n@sa LoadXCF\n@sa LoadXPM\n@sa LoadXV\n@sa LoadWEBP",
          "name": "LoadTIF",
          "kind": "function",
          "type": "Surface",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_LoadTIF_IO"
        },
        "LoadXCF": {
          "doc": "Load a XCF image directly.\n\nIf you know you definitely have a XCF image, you can call this function,\nwhich will skip SDL_image's file format detection routines. Generally it's\nbetter to use the abstract interfaces; also, there is only an IOStreamBase\ninterface available here.\n\n@param src an IOStreamBase to load image data from.\n@returns SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadAVIF\n@sa LoadICO\n@sa LoadCUR\n@sa IMG_LoadBMP_IO\n@sa LoadGIF\n@sa LoadJPG\n@sa LoadJXL\n@sa LoadLBM\n@sa LoadPCX\n@sa LoadPNG\n@sa LoadPNM\n@sa LoadSVG\n@sa LoadQOI\n@sa LoadTGA\n@sa LoadTIF\n@sa LoadXPM\n@sa LoadXV\n@sa LoadWEBP",
          "name": "LoadXCF",
          "kind": "function",
          "type": "Surface",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_LoadXCF_IO"
        },
        "LoadXPM": {
          "doc": "Load a XPM image directly.\n\nIf you know you definitely have a XPM image, you can call this function,\nwhich will skip SDL_image's file format detection routines. Generally it's\nbetter to use the abstract interfaces; also, there is only an IOStreamBase\ninterface available here.\n\n@param src an IOStreamBase to load image data from.\n@returns SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadAVIF\n@sa LoadICO\n@sa LoadCUR\n@sa IMG_LoadBMP_IO\n@sa LoadGIF\n@sa LoadJPG\n@sa LoadJXL\n@sa LoadLBM\n@sa LoadPCX\n@sa LoadPNG\n@sa LoadPNM\n@sa LoadSVG\n@sa LoadQOI\n@sa LoadTGA\n@sa LoadTIF\n@sa LoadXCF\n@sa LoadXV\n@sa LoadWEBP",
          "name": "LoadXPM",
          "kind": "function",
          "type": "Surface",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_LoadXPM_IO"
        },
        "LoadXV": {
          "doc": "Load a XV image directly.\n\nIf you know you definitely have a XV image, you can call this function,\nwhich will skip SDL_image's file format detection routines. Generally it's\nbetter to use the abstract interfaces; also, there is only an IOStreamBase\ninterface available here.\n\n@param src an IOStreamBase to load image data from.\n@returns SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadAVIF\n@sa LoadICO\n@sa LoadCUR\n@sa IMG_LoadBMP_IO\n@sa LoadGIF\n@sa LoadJPG\n@sa LoadJXL\n@sa LoadLBM\n@sa LoadPCX\n@sa LoadPNG\n@sa LoadPNM\n@sa LoadSVG\n@sa LoadQOI\n@sa LoadTGA\n@sa LoadTIF\n@sa LoadXCF\n@sa LoadXPM\n@sa LoadWEBP",
          "name": "LoadXV",
          "kind": "function",
          "type": "Surface",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_LoadXV_IO"
        },
        "LoadWEBP": {
          "doc": "Load a WEBP image directly.\n\nIf you know you definitely have a WEBP image, you can call this function,\nwhich will skip SDL_image's file format detection routines. Generally it's\nbetter to use the abstract interfaces; also, there is only an IOStreamBase\ninterface available here.\n\n@param src an IOStreamBase to load image data from.\n@returns SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa LoadAVIF\n@sa LoadICO\n@sa LoadCUR\n@sa IMG_LoadBMP_IO\n@sa LoadGIF\n@sa LoadJPG\n@sa LoadJXL\n@sa LoadLBM\n@sa LoadPCX\n@sa LoadPNG\n@sa LoadPNM\n@sa LoadSVG\n@sa LoadQOI\n@sa LoadTGA\n@sa LoadTIF\n@sa LoadXCF\n@sa LoadXPM\n@sa LoadXV",
          "name": "LoadWEBP",
          "kind": "function",
          "type": "Surface",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_LoadWEBP_IO"
        },
        "LoadSizedSVG": {
          "doc": "Load an SVG image, scaled to a specific size.\n\nSince SVG files are resolution-independent, you specify the size you would\nlike the output image to be and it will be generated at those dimensions.\n\nEither width or height may be 0 and the image will be auto-sized to\npreserve aspect ratio.\n\nWhen done with the returned surface, the app should dispose of it with a\ncall to SurfaceBase.Destroy().\n\n@param src an IOStreamBase to load SVG data from.\n@param width desired width of the generated surface, in pixels.\n@param height desired height of the generated surface, in pixels.\n@returns a new SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.",
          "name": "LoadSizedSVG",
          "kind": "function",
          "type": "Surface",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            },
            {
              "name": "width",
              "type": "int"
            },
            {
              "name": "height",
              "type": "int"
            }
          ],
          "sourceName": "IMG_LoadSizedSVG_IO"
        },
        "ReadXPMFromArray": {
          "doc": "Load an XPM image from a memory array.\n\nThe returned surface will be an 8bpp indexed surface, if possible,\notherwise it will be 32bpp. If you always want 32-bit data, use\nReadXPMFromArrayToRGB888() instead.\n\nWhen done with the returned surface, the app should dispose of it with a\ncall to SurfaceBase.Destroy().\n\n@param xpm a null-terminated array of strings that comprise XPM data.\n@returns a new SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa ReadXPMFromArrayToRGB888",
          "name": "ReadXPMFromArray",
          "kind": "function",
          "type": "Surface",
          "parameters": [
            {
              "name": "xpm",
              "type": "char **"
            }
          ],
          "sourceName": "IMG_ReadXPMFromArray"
        },
        "ReadXPMFromArrayToRGB888": {
          "doc": "Load an XPM image from a memory array.\n\nThe returned surface will always be a 32-bit RGB surface. If you want 8-bit\nindexed colors (and the XPM data allows it), use ReadXPMFromArray()\ninstead.\n\nWhen done with the returned surface, the app should dispose of it with a\ncall to SurfaceBase.Destroy().\n\n@param xpm a null-terminated array of strings that comprise XPM data.\n@returns a new SDL surface, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa ReadXPMFromArray",
          "name": "ReadXPMFromArrayToRGB888",
          "kind": "function",
          "type": "Surface",
          "parameters": [
            {
              "name": "xpm",
              "type": "char **"
            }
          ],
          "sourceName": "IMG_ReadXPMFromArrayToRGB888"
        },
        "SaveAVIF": [
          {
            "doc": "Save an SurfaceBase into a AVIF image file.\n\nIf the file already exists, it will be overwritten.\n\n@param surface the SDL surface to save.\n@param file path on the filesystem to write new file to.\n@param quality the desired quality, ranging between 0 (lowest) and 100\n               (highest).\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa SaveAVIF",
            "name": "SaveAVIF",
            "kind": "function",
            "type": "bool",
            "parameters": [
              {
                "name": "surface",
                "type": "SurfaceRef"
              },
              {
                "name": "file",
                "type": "StringParam"
              },
              {
                "name": "quality",
                "type": "int"
              }
            ],
            "sourceName": "IMG_SaveAVIF"
          },
          {
            "doc": "Save an SurfaceBase into AVIF image data, via an IOStreamBase.\n\nIf you just want to save to a filename, you can use SaveAVIF() instead.\n\nIf `closeio` is true, `dst` will be closed before returning, whether this\nfunction succeeds or not.\n\n@param surface the SDL surface to save.\n@param dst the IOStreamBase to save the image data to.\n@param closeio true to close/free the IOStreamBase before returning, false\n               to leave it open.\n@param quality the desired quality, ranging between 0 (lowest) and 100\n               (highest).\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa SaveAVIF",
            "name": "SaveAVIF",
            "kind": "function",
            "type": "bool",
            "parameters": [
              {
                "name": "surface",
                "type": "SurfaceRef"
              },
              {
                "name": "dst",
                "type": "ObjectBox<SDL_IOStream> auto &&"
              },
              {
                "name": "quality",
                "type": "int"
              }
            ],
            "sourceName": "IMG_SaveAVIF_IO"
          }
        ],
        "SavePNG": [
          {
            "doc": "Save an SurfaceBase into a PNG image file.\n\nIf the file already exists, it will be overwritten.\n\n@param surface the SDL surface to save.\n@param file path on the filesystem to write new file to.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa SavePNG",
            "name": "SavePNG",
            "kind": "function",
            "type": "bool",
            "parameters": [
              {
                "name": "surface",
                "type": "SurfaceRef"
              },
              {
                "name": "file",
                "type": "StringParam"
              }
            ],
            "sourceName": "IMG_SavePNG"
          },
          {
            "doc": "Save an SurfaceBase into PNG image data, via an IOStreamBase.\n\nIf you just want to save to a filename, you can use SavePNG() instead.\n\nIf `closeio` is true, `dst` will be closed before returning, whether this\nfunction succeeds or not.\n\n@param surface the SDL surface to save.\n@param dst the IOStreamBase to save the image data to.\n@param closeio true to close/free the IOStreamBase before returning, false\n               to leave it open.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa SavePNG",
            "name": "SavePNG",
            "kind": "function",
            "type": "bool",
            "parameters": [
              {
                "name": "surface",
                "type": "SurfaceRef"
              },
              {
                "name": "dst",
                "type": "ObjectBox<SDL_IOStream> auto &&"
              }
            ],
            "sourceName": "IMG_SavePNG_IO"
          }
        ],
        "SaveJPG": [
          {
            "doc": "Save an SurfaceBase into a JPEG image file.\n\nIf the file already exists, it will be overwritten.\n\n@param surface the SDL surface to save.\n@param file path on the filesystem to write new file to.\n@param quality [0; 33] is Lowest quality, [34; 66] is Middle quality, [67;\n               100] is Highest quality.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa SaveJPG",
            "name": "SaveJPG",
            "kind": "function",
            "type": "bool",
            "parameters": [
              {
                "name": "surface",
                "type": "SurfaceRef"
              },
              {
                "name": "file",
                "type": "StringParam"
              },
              {
                "name": "quality",
                "type": "int"
              }
            ],
            "sourceName": "IMG_SaveJPG"
          },
          {
            "doc": "Save an SurfaceBase into JPEG image data, via an IOStreamBase.\n\nIf you just want to save to a filename, you can use SaveJPG() instead.\n\nIf `closeio` is true, `dst` will be closed before returning, whether this\nfunction succeeds or not.\n\n@param surface the SDL surface to save.\n@param dst the IOStreamBase to save the image data to.\n@param closeio true to close/free the IOStreamBase before returning, false\n               to leave it open.\n@param quality [0; 33] is Lowest quality, [34; 66] is Middle quality, [67;\n               100] is Highest quality.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa SaveJPG",
            "name": "SaveJPG",
            "kind": "function",
            "type": "bool",
            "parameters": [
              {
                "name": "surface",
                "type": "SurfaceRef"
              },
              {
                "name": "dst",
                "type": "ObjectBox<SDL_IOStream> auto &&"
              },
              {
                "name": "quality",
                "type": "int"
              }
            ],
            "sourceName": "IMG_SaveJPG_IO"
          }
        ],
        "AnimationBase": {
          "doc": "Animated image support\n\nCurrently only animated GIFs and WEBP images are supported.",
          "name": "AnimationBase",
          "kind": "struct",
          "sourceName": "IMG_Animation",
          "type": "T",
          "template": [
            {
              "type": "ObjectBox<IMG_Animation *>",
              "name": "T"
            }
          ],
          "entries": {
            "T::T": {
              "kind": "alias",
              "name": "T::T",
              "doc": ""
            },
            "AnimationBase": [
              {
                "doc": "Load an animation from a file.\n\nWhen done with the returned animation, the app should dispose of it with a\ncall to AnimationBase.Free().\n\n@param file path on the filesystem containing an animated image.\n@post a new AnimationBase, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa AnimationBase.Free",
                "name": "AnimationBase",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "file",
                    "type": "StringParam"
                  }
                ],
                "sourceName": "IMG_LoadAnimation"
              },
              {
                "doc": "Load an animation from an IOStreamBase.\n\nIf `closeio` is true, `src` will be closed before returning, whether this\nfunction succeeds or not. SDL_image reads everything it needs from `src`\nduring this call in any case.\n\nWhen done with the returned animation, the app should dispose of it with a\ncall to AnimationBase.Free().\n\n@param src an IOStreamBase that data will be read from.\n@param closeio true to close/free the IOStreamBase before returning, false\n               to leave it open.\n@post a new AnimationBase, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa AnimationBase.Free",
                "name": "AnimationBase",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "src",
                    "type": "ObjectBox<SDL_IOStream> auto &&"
                  }
                ],
                "sourceName": "IMG_LoadAnimation_IO",
                "static": false
              },
              {
                "doc": "Load an animation from an SDL datasource\n\nEven though this function accepts a file type, SDL_image may still try\nother decoders that are capable of detecting file type from the contents of\nthe image data, but may rely on the caller-provided type string for formats\nthat it cannot autodetect. If `type` is nullptr, SDL_image will rely solely on\nits ability to guess the format.\n\nIf `closeio` is true, `src` will be closed before returning, whether this\nfunction succeeds or not. SDL_image reads everything it needs from `src`\nduring this call in any case.\n\nWhen done with the returned animation, the app should dispose of it with a\ncall to AnimationBase.Free().\n\n@param src an IOStreamBase that data will be read from.\n@param closeio true to close/free the IOStreamBase before returning, false\n               to leave it open.\n@param type a filename extension that represent this data (\"GIF\", etc).\n@post a new AnimationBase, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa AnimationBase.AnimationBase\n@sa AnimationBase.AnimationBase\n@sa AnimationBase.Free",
                "name": "AnimationBase",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "src",
                    "type": "ObjectBox<SDL_IOStream> auto &&"
                  },
                  {
                    "name": "type",
                    "type": "StringParam"
                  }
                ],
                "sourceName": "IMG_LoadAnimationTyped_IO",
                "static": false
              }
            ],
            "GetWidth": {
              "kind": "function",
              "immutable": true,
              "type": "int",
              "parameters": [],
              "name": "GetWidth",
              "doc": ""
            },
            "GetHeight": {
              "kind": "function",
              "immutable": true,
              "type": "int",
              "parameters": [],
              "name": "GetHeight",
              "doc": ""
            },
            "GetSize": {
              "kind": "function",
              "immutable": true,
              "type": "Point",
              "parameters": [],
              "name": "GetSize",
              "doc": ""
            },
            "GetCount": {
              "kind": "function",
              "immutable": true,
              "type": "int",
              "parameters": [],
              "name": "GetCount",
              "doc": ""
            },
            "GetFrame": {
              "kind": "function",
              "type": "SurfaceRef",
              "immutable": true,
              "parameters": [
                {
                  "type": "int",
                  "name": "index"
                }
              ],
              "name": "GetFrame",
              "doc": ""
            },
            "GetDelay": {
              "kind": "function",
              "type": "int",
              "immutable": true,
              "parameters": [
                {
                  "type": "int",
                  "name": "index"
                }
              ],
              "name": "GetDelay",
              "doc": ""
            },
            "Free": {
              "doc": "Dispose of an AnimationBase and free its resources.\n\nThe provided `anim` pointer is not valid once this call returns.\n\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa AnimationBase.AnimationBase\n@sa AnimationBase.AnimationBase\n@sa AnimationBase.AnimationBase",
              "name": "Free",
              "kind": "function",
              "type": "void",
              "parameters": [],
              "sourceName": "IMG_FreeAnimation"
            }
          }
        },
        "ObjectRef<IMG_Animation>::doFree": {
          "name": "ObjectRef<IMG_Animation>::doFree",
          "type": "void",
          "kind": "function",
          "doc": "Callback for animation resource cleanup\n\n@private",
          "template": [],
          "parameters": [
            {
              "type": "IMG_Animation *",
              "name": "resource"
            }
          ],
          "sourceName": "IMG_FreeAnimation"
        },
        "LoadGIFAnimation": {
          "doc": "Load a GIF animation directly.\n\nIf you know you definitely have a GIF image, you can call this function,\nwhich will skip SDL_image's file format detection routines. Generally it's\nbetter to use the abstract interfaces; also, there is only an IOStreamBase\ninterface available here.\n\n@param src an IOStreamBase that data will be read from.\n@returns a new AnimationBase, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa AnimationBase.AnimationBase\n@sa AnimationBase.AnimationBase\n@sa AnimationBase.AnimationBase\n@sa AnimationBase.Free",
          "name": "LoadGIFAnimation",
          "kind": "function",
          "type": "Animation",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_LoadGIFAnimation_IO"
        },
        "LoadWEBPAnimation": {
          "doc": "Load a WEBP animation directly.\n\nIf you know you definitely have a WEBP image, you can call this function,\nwhich will skip SDL_image's file format detection routines. Generally it's\nbetter to use the abstract interfaces; also, there is only an IOStreamBase\ninterface available here.\n\n@param src an IOStreamBase that data will be read from.\n@returns a new AnimationBase, or nullptr on error.\n\n@since This function is available since SDL_image 3.0.0.\n\n@sa AnimationBase.AnimationBase\n@sa AnimationBase.AnimationBase\n@sa AnimationBase.AnimationBase\n@sa AnimationBase.Free",
          "name": "LoadWEBPAnimation",
          "kind": "function",
          "type": "Animation",
          "parameters": [
            {
              "name": "src",
              "type": "ObjectBox<SDL_IOStream> auto &&"
            }
          ],
          "sourceName": "IMG_LoadWEBPAnimation_IO"
        }
      }
    },
    "SDL3pp_ttf.h": {
      "name": "SDL3pp_ttf.h",
      "doc": "@defgroup CategorySDLTTF Category SDLTTF\n\nHeader file for SDL_ttf library\n\nThis library is a wrapper around the excellent FreeType 2.0 library,\navailable at: https://www.freetype.org/",
      "entries": {
        "SDL3PP_ENABLE_TTF": {
          "name": "SDL3PP_ENABLE_TTF",
          "kind": "def",
          "doc": ""
        },
        "TtfInitFlag": {
          "kind": "struct",
          "name": "TtfInitFlag",
          "type": "InitFlagsExtra",
          "doc": "",
          "entries": {}
        },
        "TextEngineWrapper": {
          "name": "TextEngineWrapper",
          "kind": "struct",
          "entries": {
            "m_ptr": {
              "kind": "var",
              "type": "TTF_TextEngine *",
              "name": "m_ptr",
              "doc": ""
            }
          },
          "doc": ""
        },
        "FontBase-forward": {
          "name": "FontBase",
          "kind": "forward",
          "template": [
            {
              "type": "ObjectBox<TTF_Font *>",
              "name": "T"
            }
          ],
          "doc": ""
        },
        "FontRef": {
          "name": "FontRef",
          "kind": "alias",
          "type": "FontBase<ObjectRef<TTF_Font>>",
          "doc": "Handle to a non owned font\n\n@cat resource\n\n@sa FontBase\n@sa Font"
        },
        "Font": {
          "name": "Font",
          "kind": "alias",
          "type": "FontBase<ObjectUnique<TTF_Font>>",
          "doc": "Handle to an owned font\n\n@cat resource\n\n@sa FontBase\n@sa FontRef"
        },
        "TextEngineBase-forward": {
          "name": "TextEngineBase",
          "kind": "forward",
          "template": [
            {
              "type": "ObjectBox<TextEngineWrapper>",
              "name": "T"
            }
          ],
          "doc": ""
        },
        "TextEngineRef": {
          "name": "TextEngineRef",
          "kind": "alias",
          "type": "TextEngineBase<ObjectRef<TTF_TextEngine, TextEngineWrapper>>",
          "doc": "Handle to a non owned textEngine\n\n@cat resource\n\n@sa TextEngineBase\n@sa TextEngine"
        },
        "TextEngine": {
          "name": "TextEngine",
          "kind": "alias",
          "type": "TextEngineBase<ObjectUnique<TTF_TextEngine, ObjectDeleter<ObjectRef<TTF_TextEngine, TextEngineWrapper>>>>",
          "doc": "Handle to an owned textEngine\n\n@cat resource\n\n@sa TextEngineBase\n@sa TextEngineRef"
        },
        "TextBase-forward": {
          "name": "TextBase",
          "kind": "forward",
          "template": [
            {
              "type": "ObjectBox<TTF_Text *>",
              "name": "T"
            }
          ],
          "doc": ""
        },
        "TextRef": {
          "name": "TextRef",
          "kind": "alias",
          "type": "TextBase<ObjectRef<TTF_Text>>",
          "doc": "Handle to a non owned text\n\n@cat resource\n\n@sa TextBase\n@sa Text"
        },
        "Text": {
          "name": "Text",
          "kind": "alias",
          "type": "TextBase<ObjectUnique<TTF_Text>>",
          "doc": "Handle to an owned text\n\n@cat resource\n\n@sa TextBase\n@sa TextRef"
        },
        "FontStyleFlags": {
          "doc": "Font style flags for FontBase\n\nThese are the flags which can be used to set the style of a font in\nSDL_ttf. A combination of these flags can be used with functions that set\nor query font style, such as FontBase.SetStyle or FontBase.GetStyle.\n\n@since This datatype is available since SDL_ttf 3.0.0.\n\n@sa FontBase.SetStyle\n@sa FontBase.GetStyle",
          "name": "FontStyleFlags",
          "kind": "alias",
          "type": "TTF_FontStyleFlags",
          "sourceName": "TTF_FontStyleFlags"
        },
        "STYLE_NORMAL": {
          "doc": "No special style",
          "name": "STYLE_NORMAL",
          "kind": "var",
          "value": "0x00",
          "sourceName": "TTF_STYLE_NORMAL",
          "constexpr": true,
          "type": "FontStyleFlags"
        },
        "STYLE_BOLD": {
          "doc": "Bold style",
          "name": "STYLE_BOLD",
          "kind": "var",
          "value": "0x01",
          "sourceName": "TTF_STYLE_BOLD",
          "constexpr": true,
          "type": "FontStyleFlags"
        },
        "STYLE_ITALIC": {
          "doc": "Italic style",
          "name": "STYLE_ITALIC",
          "kind": "var",
          "value": "0x02",
          "sourceName": "TTF_STYLE_ITALIC",
          "constexpr": true,
          "type": "FontStyleFlags"
        },
        "STYLE_UNDERLINE": {
          "doc": "Underlined text",
          "name": "STYLE_UNDERLINE",
          "kind": "var",
          "value": "0x04",
          "sourceName": "TTF_STYLE_UNDERLINE",
          "constexpr": true,
          "type": "FontStyleFlags"
        },
        "STYLE_STRIKETHROUGH": {
          "doc": "Strikethrough text",
          "name": "STYLE_STRIKETHROUGH",
          "kind": "var",
          "value": "0x08",
          "sourceName": "TTF_STYLE_STRIKETHROUGH",
          "constexpr": true,
          "type": "FontStyleFlags"
        },
        "HintingFlags": {
          "doc": "Hinting flags for TTF (TrueType Fonts)\n\nThis enum specifies the level of hinting to be applied to the font\nrendering. The hinting level determines how much the font's outlines are\nadjusted for better alignment on the pixel grid.\n\n@since This enum is available since SDL_ttf 3.0.0.\n\n@sa FontBase.SetHinting\n@sa FontBase.GetHinting",
          "name": "HintingFlags",
          "kind": "alias",
          "sourceName": "TTF_HintingFlags",
          "type": "TTF_HintingFlags"
        },
        "HINTING_INVALID": {
          "doc": "",
          "name": "HINTING_INVALID",
          "kind": "var",
          "type": "HintingFlags",
          "sourceName": "TTF_HINTING_INVALID",
          "constexpr": true
        },
        "HINTING_NORMAL": {
          "doc": "Normal hinting applies standard grid-fitting.",
          "name": "HINTING_NORMAL",
          "kind": "var",
          "type": "HintingFlags",
          "sourceName": "TTF_HINTING_NORMAL",
          "constexpr": true
        },
        "HINTING_LIGHT": {
          "doc": "Light hinting applies subtle adjustments to improve rendering.",
          "name": "HINTING_LIGHT",
          "kind": "var",
          "type": "HintingFlags",
          "sourceName": "TTF_HINTING_LIGHT",
          "constexpr": true
        },
        "HINTING_MONO": {
          "doc": "Monochrome hinting adjusts the font for better rendering at lower resolutions.",
          "name": "HINTING_MONO",
          "kind": "var",
          "type": "HintingFlags",
          "sourceName": "TTF_HINTING_MONO",
          "constexpr": true
        },
        "HINTING_NONE": {
          "doc": "No hinting, the font is rendered without any grid-fitting.",
          "name": "HINTING_NONE",
          "kind": "var",
          "type": "HintingFlags",
          "sourceName": "TTF_HINTING_NONE",
          "constexpr": true
        },
        "HINTING_LIGHT_SUBPIXEL": {
          "doc": "Light hinting with subpixel rendering for more precise font edges.",
          "name": "HINTING_LIGHT_SUBPIXEL",
          "kind": "var",
          "type": "HintingFlags",
          "sourceName": "TTF_HINTING_LIGHT_SUBPIXEL",
          "constexpr": true
        },
        "HorizontalAlignment": {
          "doc": "The horizontal alignment used when rendering wrapped text.\n\n@since This enum is available since SDL_ttf 3.0.0.",
          "name": "HorizontalAlignment",
          "kind": "alias",
          "sourceName": "TTF_HorizontalAlignment",
          "type": "TTF_HorizontalAlignment"
        },
        "HORIZONTAL_ALIGN_INVALID": {
          "doc": "",
          "name": "HORIZONTAL_ALIGN_INVALID",
          "kind": "var",
          "type": "HorizontalAlignment",
          "sourceName": "TTF_HORIZONTAL_ALIGN_INVALID",
          "constexpr": true
        },
        "HORIZONTAL_ALIGN_LEFT": {
          "doc": "",
          "name": "HORIZONTAL_ALIGN_LEFT",
          "kind": "var",
          "type": "HorizontalAlignment",
          "sourceName": "TTF_HORIZONTAL_ALIGN_LEFT",
          "constexpr": true
        },
        "HORIZONTAL_ALIGN_CENTER": {
          "doc": "",
          "name": "HORIZONTAL_ALIGN_CENTER",
          "kind": "var",
          "type": "HorizontalAlignment",
          "sourceName": "TTF_HORIZONTAL_ALIGN_CENTER",
          "constexpr": true
        },
        "HORIZONTAL_ALIGN_RIGHT": {
          "doc": "",
          "name": "HORIZONTAL_ALIGN_RIGHT",
          "kind": "var",
          "type": "HorizontalAlignment",
          "sourceName": "TTF_HORIZONTAL_ALIGN_RIGHT",
          "constexpr": true
        },
        "Direction": {
          "doc": "Direction flags\n\nThe values here are chosen to match\n[hb_direction_t](https://harfbuzz.github.io/harfbuzz-hb-common.html#hb-direction-t)\n.\n\n@since This enum is available since SDL_ttf 3.0.0.\n\n@sa FontBase.SetDirection",
          "name": "Direction",
          "kind": "alias",
          "sourceName": "TTF_Direction",
          "type": "TTF_Direction"
        },
        "DIRECTION_INVALID": {
          "doc": "",
          "name": "DIRECTION_INVALID",
          "kind": "var",
          "type": "Direction",
          "sourceName": "TTF_DIRECTION_INVALID",
          "constexpr": true
        },
        "DIRECTION_LTR": {
          "doc": "Left to Right.",
          "name": "DIRECTION_LTR",
          "kind": "var",
          "type": "Direction",
          "sourceName": "TTF_DIRECTION_LTR",
          "constexpr": true
        },
        "DIRECTION_RTL": {
          "doc": "Right to Left.",
          "name": "DIRECTION_RTL",
          "kind": "var",
          "type": "Direction",
          "sourceName": "TTF_DIRECTION_RTL",
          "constexpr": true
        },
        "DIRECTION_TTB": {
          "doc": "Top to Bottom.",
          "name": "DIRECTION_TTB",
          "kind": "var",
          "type": "Direction",
          "sourceName": "TTF_DIRECTION_TTB",
          "constexpr": true
        },
        "DIRECTION_BTT": {
          "doc": "Bottom to Top.",
          "name": "DIRECTION_BTT",
          "kind": "var",
          "type": "Direction",
          "sourceName": "TTF_DIRECTION_BTT",
          "constexpr": true
        },
        "ImageType": {
          "doc": "The type of data in a glyph image\n\n@since This enum is available since SDL_ttf 3.0.0.",
          "name": "ImageType",
          "kind": "alias",
          "sourceName": "TTF_ImageType",
          "type": "TTF_ImageType"
        },
        "IMAGE_INVALID": {
          "doc": "",
          "name": "IMAGE_INVALID",
          "kind": "var",
          "type": "ImageType",
          "sourceName": "TTF_IMAGE_INVALID",
          "constexpr": true
        },
        "IMAGE_ALPHA": {
          "doc": "The color channels are white.",
          "name": "IMAGE_ALPHA",
          "kind": "var",
          "type": "ImageType",
          "sourceName": "TTF_IMAGE_ALPHA",
          "constexpr": true
        },
        "IMAGE_COLOR": {
          "doc": "The color channels have image data.",
          "name": "IMAGE_COLOR",
          "kind": "var",
          "type": "ImageType",
          "sourceName": "TTF_IMAGE_COLOR",
          "constexpr": true
        },
        "IMAGE_SDF": {
          "doc": "The alpha channel has signed distance field information.",
          "name": "IMAGE_SDF",
          "kind": "var",
          "type": "ImageType",
          "sourceName": "TTF_IMAGE_SDF",
          "constexpr": true
        },
        "SubStringFlags": {
          "doc": "Flags for SubString\n\n@since This datatype is available since SDL_ttf 3.0.0.\n\n@sa SubString",
          "name": "SubStringFlags",
          "kind": "alias",
          "type": "TTF_SubStringFlags",
          "sourceName": "TTF_SubStringFlags"
        },
        "SUBSTRING_DIRECTION_MASK": {
          "doc": "The mask for the flow direction for this substring",
          "name": "SUBSTRING_DIRECTION_MASK",
          "kind": "var",
          "value": "0x000000FF",
          "sourceName": "TTF_SUBSTRING_DIRECTION_MASK",
          "constexpr": true,
          "type": "SubStringFlags"
        },
        "SUBSTRING_TEXT_START": {
          "doc": "This substring contains the beginning of the text",
          "name": "SUBSTRING_TEXT_START",
          "kind": "var",
          "value": "0x00000100",
          "sourceName": "TTF_SUBSTRING_TEXT_START",
          "constexpr": true,
          "type": "SubStringFlags"
        },
        "SUBSTRING_LINE_START": {
          "doc": "This substring contains the beginning of line `line_index`",
          "name": "SUBSTRING_LINE_START",
          "kind": "var",
          "value": "0x00000200",
          "sourceName": "TTF_SUBSTRING_LINE_START",
          "constexpr": true,
          "type": "SubStringFlags"
        },
        "SUBSTRING_LINE_END": {
          "doc": "This substring contains the end of line `line_index`",
          "name": "SUBSTRING_LINE_END",
          "kind": "var",
          "value": "0x00000400",
          "sourceName": "TTF_SUBSTRING_LINE_END",
          "constexpr": true,
          "type": "SubStringFlags"
        },
        "SUBSTRING_TEXT_END": {
          "doc": "This substring contains the end of the text",
          "name": "SUBSTRING_TEXT_END",
          "kind": "var",
          "value": "0x00000800",
          "sourceName": "TTF_SUBSTRING_TEXT_END",
          "constexpr": true,
          "type": "SubStringFlags"
        },
        "GPUTextEngineWinding": {
          "doc": "The winding order of the vertices returned by TextBase.GetGPUDrawData\n\n@since This enum is available since SDL_ttf 3.0.0.",
          "name": "GPUTextEngineWinding",
          "kind": "alias",
          "sourceName": "TTF_GPUTextEngineWinding",
          "type": "TTF_GPUTextEngineWinding"
        },
        "GPU_TEXTENGINE_WINDING_INVALID": {
          "doc": "",
          "name": "GPU_TEXTENGINE_WINDING_INVALID",
          "kind": "var",
          "type": "GPUTextEngineWinding",
          "sourceName": "TTF_GPU_TEXTENGINE_WINDING_INVALID",
          "constexpr": true
        },
        "GPU_TEXTENGINE_WINDING_CLOCKWISE": {
          "doc": "",
          "name": "GPU_TEXTENGINE_WINDING_CLOCKWISE",
          "kind": "var",
          "type": "GPUTextEngineWinding",
          "sourceName": "TTF_GPU_TEXTENGINE_WINDING_CLOCKWISE",
          "constexpr": true
        },
        "GPU_TEXTENGINE_WINDING_COUNTER_CLOCKWISE": {
          "doc": "",
          "name": "GPU_TEXTENGINE_WINDING_COUNTER_CLOCKWISE",
          "kind": "var",
          "type": "GPUTextEngineWinding",
          "sourceName": "TTF_GPU_TEXTENGINE_WINDING_COUNTER_CLOCKWISE",
          "constexpr": true
        },
        "SDL_TTF_MAJOR_VERSION": {
          "doc": "Printable format: \"%d.%d.%d\", MAJOR, MINOR, MICRO",
          "name": "SDL_TTF_MAJOR_VERSION",
          "kind": "def",
          "value": "3",
          "sourceName": "SDL_TTF_MAJOR_VERSION"
        },
        "SDL_TTF_MINOR_VERSION": {
          "doc": "",
          "name": "SDL_TTF_MINOR_VERSION",
          "kind": "def",
          "value": "2",
          "sourceName": "SDL_TTF_MINOR_VERSION"
        },
        "SDL_TTF_MICRO_VERSION": {
          "doc": "",
          "name": "SDL_TTF_MICRO_VERSION",
          "kind": "def",
          "value": "3",
          "sourceName": "SDL_TTF_MICRO_VERSION"
        },
        "SDL_TTF_VERSION": {
          "doc": "This is the version number macro for the current SDL_ttf version.",
          "name": "SDL_TTF_VERSION",
          "kind": "def",
          "value": "    SDL_VERSIONNUM(SDL_TTF_MAJOR_VERSION, SDL_TTF_MINOR_VERSION, SDL_TTF_MICRO_VERSION)",
          "sourceName": "SDL_TTF_VERSION"
        },
        "SDL_TTF_VERSION_ATLEAST": {
          "doc": "This macro will evaluate to true if compiled with SDL_ttf at least X.Y.Z.",
          "name": "SDL_TTF_VERSION_ATLEAST",
          "kind": "def",
          "parameters": [
            "X",
            "Y",
            "Z"
          ],
          "value": "    ((SDL_TTF_MAJOR_VERSION >= X) && \\\n     (SDL_TTF_MAJOR_VERSION > X || SDL_TTF_MINOR_VERSION >= Y) && \\\n     (SDL_TTF_MAJOR_VERSION > X || SDL_TTF_MINOR_VERSION > Y || SDL_TTF_MICRO_VERSION >= Z))",
          "sourceName": "SDL_TTF_VERSION_ATLEAST"
        },
        "TTF_Version": {
          "doc": "This function gets the version of the dynamically linked SDL_ttf library.\n\n@returns SDL_ttf version.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.",
          "name": "TTF_Version",
          "kind": "function",
          "type": "int",
          "parameters": [],
          "sourceName": "TTF_Version"
        },
        "GetFreeTypeVersion": {
          "doc": "Query the version of the FreeType library in use.\n\nInitSubSystem() should be called before calling this function.\n\n@param major to be filled in with the major version number. Can be nullptr.\n@param minor to be filled in with the minor version number. Can be nullptr.\n@param patch to be filled in with the param version number. Can be nullptr.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa InitSubSystem",
          "name": "GetFreeTypeVersion",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "major",
              "type": "int *"
            },
            {
              "name": "minor",
              "type": "int *"
            },
            {
              "name": "patch",
              "type": "int *"
            }
          ],
          "sourceName": "TTF_GetFreeTypeVersion"
        },
        "GetHarfBuzzVersion": {
          "doc": "Query the version of the HarfBuzz library in use.\n\nIf HarfBuzz is not available, the version reported is 0.0.0.\n\n@param major to be filled in with the major version number. Can be nullptr.\n@param minor to be filled in with the minor version number. Can be nullptr.\n@param patch to be filled in with the param version number. Can be nullptr.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.",
          "name": "GetHarfBuzzVersion",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "major",
              "type": "int *"
            },
            {
              "name": "minor",
              "type": "int *"
            },
            {
              "name": "patch",
              "type": "int *"
            }
          ],
          "sourceName": "TTF_GetHarfBuzzVersion"
        },
        "TextData": {
          "doc": "",
          "name": "TextData",
          "kind": "alias",
          "sourceName": "TTF_TextData",
          "type": "TTF_TextData"
        },
        "FontBase": {
          "doc": "The internal structure containing font information.\n\nOpaque data!",
          "name": "FontBase",
          "kind": "struct",
          "type": "T",
          "sourceName": "TTF_Font",
          "template": [
            {
              "type": "ObjectBox<TTF_Font *>",
              "name": "T"
            }
          ],
          "entries": {
            "T::T": {
              "kind": "alias",
              "name": "T::T",
              "doc": ""
            },
            "FontBase": [
              {
                "doc": "Create a font from a file, using a specified point size.\n\nSome .fon fonts will have several sizes embedded in the file, so the point\nsize becomes the index of choosing which size. If the value is too high,\nthe last indexed size will be the default.\n\nWhen done with the returned FontBase, use FontBase.Close() to dispose of it.\n\n@param file path to font file.\n@param ptsize point size to use for the newly-opened font.\n@post a valid FontBase, or nullptr on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.Close",
                "name": "FontBase",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "file",
                    "type": "StringParam"
                  },
                  {
                    "name": "ptsize",
                    "type": "float"
                  }
                ],
                "sourceName": "TTF_OpenFont"
              },
              {
                "doc": "Create a font from an IOStreamBase, using a specified point size.\n\nSome .fon fonts will have several sizes embedded in the file, so the point\nsize becomes the index of choosing which size. If the value is too high,\nthe last indexed size will be the default.\n\nIf `closeio` is true, `src` will be automatically closed once the font is\nclosed. Otherwise you should keep `src` open until the font is closed.\n\nWhen done with the returned FontBase, use FontBase.Close() to dispose of it.\n\n@param src an IOStreamBase to provide a font file's data.\n@param closeio true to close `src` when the font is closed, false to leave\n               it open.\n@param ptsize point size to use for the newly-opened font.\n@post a valid FontBase, or nullptr on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.Close",
                "name": "FontBase",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "src",
                    "type": "ObjectBox<SDL_IOStream> auto &&"
                  },
                  {
                    "name": "closeio",
                    "type": "bool"
                  },
                  {
                    "name": "ptsize",
                    "type": "float"
                  }
                ],
                "sourceName": "TTF_OpenFontIO"
              },
              {
                "doc": "Create a font with the specified properties.\n\nThese are the supported properties:\n\n- `TTF_PROP_FONT_CREATE_FILENAME_STRING`: the font file to open, if an\n  IOStreamBase isn't being used. This is required if\n  `prop::Font.CREATE_IOSTREAM_POINTER` and\n  `prop::Font.CREATE_EXISTING_FONT` aren't set.\n- `prop::Font.CREATE_IOSTREAM_POINTER`: an IOStreamBase containing the\n  font to be opened. This should not be closed until the font is closed.\n  This is required if `TTF_PROP_FONT_CREATE_FILENAME_STRING` and\n  `prop::Font.CREATE_EXISTING_FONT` aren't set.\n- `prop::Font.CREATE_IOSTREAM_OFFSET_NUMBER`: the offset in the iostream\n  for the beginning of the font, defaults to 0.\n- `prop::Font.CREATE_IOSTREAM_AUTOCLOSE_BOOLEAN`: true if closing the\n  font should also close the associated IOStreamBase.\n- `prop::Font.CREATE_SIZE_FLOAT`: the point size of the font. Some .fon\n  fonts will have several sizes embedded in the file, so the point size\n  becomes the index of choosing which size. If the value is too high, the\n  last indexed size will be the default.\n- `prop::Font.CREATE_FACE_NUMBER`: the face index of the font, if the\n  font contains multiple font faces.\n- `prop::Font.CREATE_HORIZONTAL_DPI_NUMBER`: the horizontal DPI to use\n  for font rendering, defaults to\n  `prop::Font.CREATE_VERTICAL_DPI_NUMBER` if set, or 72 otherwise.\n- `prop::Font.CREATE_VERTICAL_DPI_NUMBER`: the vertical DPI to use for\n  font rendering, defaults to `prop::Font.CREATE_HORIZONTAL_DPI_NUMBER`\n  if set, or 72 otherwise.\n- `prop::Font.CREATE_EXISTING_FONT`: an optional FontBase that, if set,\n  will be used as the font data source and the initial size and style of\n  the new font.\n\n@param props the properties to use.\n@post a valid FontBase, or nullptr on failure; call GetError() for more\n         information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.Close",
                "name": "FontBase",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "props",
                    "type": "PropertiesRef"
                  }
                ],
                "sourceName": "TTF_OpenFontWithProperties"
              }
            ],
            "Copy": {
              "doc": "Create a copy of an existing font.\n\nThe copy will be distinct from the original, but will share the font file\nand have the same size and style as the original.\n\nWhen done with the returned FontBase, use FontBase.Close() to dispose of it.\n\n@returns a valid FontBase, or nullptr on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              original font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.Close",
              "name": "Copy",
              "kind": "function",
              "type": "Font",
              "parameters": [],
              "sourceName": "TTF_CopyFont",
              "immutable": true
            },
            "GetProperties": {
              "doc": "Get the properties associated with a font.\n\nThe following read-write properties are provided by SDL:\n\n- `prop::Font.OUTLINE_LINE_CAP_NUMBER`: The FT_Stroker_LineCap value\n  used when setting the font outline, defaults to\n  `FT_STROKER_LINECAP_ROUND`.\n- `prop::Font.OUTLINE_LINE_JOIN_NUMBER`: The FT_Stroker_LineJoin value\n  used when setting the font outline, defaults to\n  `FT_STROKER_LINEJOIN_ROUND`.\n- `prop::Font.OUTLINE_MITER_LIMIT_NUMBER`: The FT_Fixed miter limit used\n  when setting the font outline, defaults to 0.\n\n@returns a valid property ID on success or 0 on failure; call\n         GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "GetProperties",
              "kind": "function",
              "type": "PropertiesRef",
              "parameters": [],
              "sourceName": "TTF_GetFontProperties"
            },
            "GetGeneration": {
              "doc": "Get the font generation.\n\nThe generation is incremented each time font properties change that require\nrebuilding glyphs, such as style, size, etc.\n\n@returns the font generation or 0 on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "GetGeneration",
              "kind": "function",
              "type": "Uint32",
              "parameters": [],
              "sourceName": "TTF_GetFontGeneration",
              "immutable": true
            },
            "AddFallback": {
              "doc": "Add a fallback font.\n\nAdd a font that will be used for glyphs that are not in the current font.\nThe fallback font should have the same size and style as the current font.\n\nIf there are multiple fallback fonts, they are used in the order added.\n\nThis updates any TextBase objects using this font.\n\n@param fallback the font to add as a fallback.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created\n              both fonts.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.ClearFallbacks\n@sa FontBase.RemoveFallback",
              "name": "AddFallback",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "fallback",
                  "type": "FontRef"
                }
              ],
              "sourceName": "TTF_AddFallbackFont"
            },
            "RemoveFallback": {
              "doc": "Remove a fallback font.\n\nThis updates any TextBase objects using this font.\n\n@param fallback the font to remove as a fallback.\n\n@threadsafety This function should be called on the thread that created\n              both fonts.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.AddFallback\n@sa FontBase.ClearFallbacks",
              "name": "RemoveFallback",
              "kind": "function",
              "type": "void",
              "parameters": [
                {
                  "name": "fallback",
                  "type": "FontRef"
                }
              ],
              "sourceName": "TTF_RemoveFallbackFont"
            },
            "ClearFallbacks": {
              "doc": "Remove all fallback fonts.\n\nThis updates any TextBase objects using this font.\n\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.AddFallback\n@sa FontBase.RemoveFallback",
              "name": "ClearFallbacks",
              "kind": "function",
              "type": "void",
              "parameters": [],
              "sourceName": "TTF_ClearFallbackFonts"
            },
            "SetSize": {
              "doc": "Set a font's size dynamically.\n\nThis updates any TextBase objects using this font, and clears\nalready-generated glyphs, if any, from the cache.\n\n@param ptsize the new point size.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.GetSize",
              "name": "SetSize",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "ptsize",
                  "type": "float"
                }
              ],
              "sourceName": "TTF_SetFontSize"
            },
            "SetSizeDPI": {
              "doc": "Set font size dynamically with target resolutions, in dots per inch.\n\nThis updates any TextBase objects using this font, and clears\nalready-generated glyphs, if any, from the cache.\n\n@param ptsize the new point size.\n@param hdpi the target horizontal DPI.\n@param vdpi the target vertical DPI.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.GetSize\n@sa TTF_GetFontSizeDPI",
              "name": "SetSizeDPI",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "ptsize",
                  "type": "float"
                },
                {
                  "name": "hdpi",
                  "type": "int"
                },
                {
                  "name": "vdpi",
                  "type": "int"
                }
              ],
              "sourceName": "TTF_SetFontSizeDPI"
            },
            "GetSize": {
              "doc": "Get the size of a font.\n\n@returns the size of the font, or 0.0f on failure; call GetError() for\n         more information.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.SetSize\n@sa FontBase.SetSizeDPI",
              "name": "GetSize",
              "kind": "function",
              "type": "float",
              "parameters": [],
              "sourceName": "TTF_GetFontSize",
              "immutable": true
            },
            "GetDPI": {
              "doc": "Get font target resolutions, in dots per inch.\n\n@param hdpi a pointer filled in with the target horizontal DPI.\n@param vdpi a pointer filled in with the target vertical DPI.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.SetSizeDPI",
              "name": "GetDPI",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "hdpi",
                  "type": "int *"
                },
                {
                  "name": "vdpi",
                  "type": "int *"
                }
              ],
              "sourceName": "TTF_GetFontDPI",
              "immutable": true
            },
            "SetStyle": {
              "doc": "Set a font's current style.\n\nThis updates any TextBase objects using this font, and clears\nalready-generated glyphs, if any, from the cache.\n\nThe font styles are a set of bit flags, OR'd together:\n\n- `STYLE_NORMAL` (is zero)\n- `STYLE_BOLD`\n- `STYLE_ITALIC`\n- `STYLE_UNDERLINE`\n- `STYLE_STRIKETHROUGH`\n\n@param style the new style values to set, OR'd together.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.GetStyle",
              "name": "SetStyle",
              "kind": "function",
              "type": "void",
              "parameters": [
                {
                  "name": "style",
                  "type": "FontStyleFlags"
                }
              ],
              "sourceName": "TTF_SetFontStyle"
            },
            "GetStyle": {
              "doc": "Query a font's current style.\n\nThe font styles are a set of bit flags, OR'd together:\n\n- `STYLE_NORMAL` (is zero)\n- `STYLE_BOLD`\n- `STYLE_ITALIC`\n- `STYLE_UNDERLINE`\n- `STYLE_STRIKETHROUGH`\n\n@returns the current font style, as a set of bit flags.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.SetStyle",
              "name": "GetStyle",
              "kind": "function",
              "type": "FontStyleFlags",
              "parameters": [],
              "sourceName": "TTF_GetFontStyle",
              "immutable": true
            },
            "SetOutline": {
              "doc": "Set a font's current outline.\n\nThis uses the font properties `prop::Font.OUTLINE_LINE_CAP_NUMBER`,\n`prop::Font.OUTLINE_LINE_JOIN_NUMBER`, and\n`prop::Font.OUTLINE_MITER_LIMIT_NUMBER` when setting the font outline.\n\nThis updates any TextBase objects using this font, and clears\nalready-generated glyphs, if any, from the cache.\n\n@param outline positive outline value, 0 to default.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.GetOutline",
              "name": "SetOutline",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "outline",
                  "type": "int"
                }
              ],
              "sourceName": "TTF_SetFontOutline"
            },
            "GetOutline": {
              "doc": "Query a font's current outline.\n\n@returns the font's current outline value.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.SetOutline",
              "name": "GetOutline",
              "kind": "function",
              "type": "int",
              "parameters": [],
              "sourceName": "TTF_GetFontOutline",
              "immutable": true
            },
            "SetHinting": {
              "doc": "Set a font's current hinter setting.\n\nThis updates any TextBase objects using this font, and clears\nalready-generated glyphs, if any, from the cache.\n\nThe hinter setting is a single value:\n\n- `HINTING_NORMAL`\n- `HINTING_LIGHT`\n- `HINTING_MONO`\n- `HINTING_NONE`\n- `HINTING_LIGHT_SUBPIXEL` (available in SDL_ttf 3.0.0 and later)\n\n@param hinting the new hinter setting.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.GetHinting",
              "name": "SetHinting",
              "kind": "function",
              "type": "void",
              "parameters": [
                {
                  "name": "hinting",
                  "type": "HintingFlags"
                }
              ],
              "sourceName": "TTF_SetFontHinting"
            },
            "GetNumFaces": {
              "doc": "Query the number of faces of a font.\n\n@returns the number of FreeType font faces.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "GetNumFaces",
              "kind": "function",
              "type": "int",
              "parameters": [],
              "sourceName": "TTF_GetNumFontFaces",
              "immutable": true
            },
            "GetHinting": {
              "doc": "Query a font's current FreeType hinter setting.\n\nThe hinter setting is a single value:\n\n- `HINTING_NORMAL`\n- `HINTING_LIGHT`\n- `HINTING_MONO`\n- `HINTING_NONE`\n- `HINTING_LIGHT_SUBPIXEL` (available in SDL_ttf 3.0.0 and later)\n\n@returns the font's current hinter value, or HINTING_INVALID if the\n         font is invalid.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.SetHinting",
              "name": "GetHinting",
              "kind": "function",
              "type": "HintingFlags",
              "parameters": [],
              "sourceName": "TTF_GetFontHinting",
              "immutable": true
            },
            "SetSDF": {
              "doc": "Enable Signed Distance Field rendering for a font.\n\nSDF is a technique that helps fonts look sharp even when scaling and\nrotating, and requires special shader support for display.\n\nThis works with Blended APIs, and generates the raw signed distance values\nin the alpha channel of the resulting texture.\n\nThis updates any TextBase objects using this font, and clears\nalready-generated glyphs, if any, from the cache.\n\n@param enabled true to enable SDF, false to disable.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.GetSDF",
              "name": "SetSDF",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "enabled",
                  "type": "bool"
                }
              ],
              "sourceName": "TTF_SetFontSDF"
            },
            "GetSDF": {
              "doc": "Query whether Signed Distance Field rendering is enabled for a font.\n\n@returns true if enabled, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.SetSDF",
              "name": "GetSDF",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "TTF_GetFontSDF",
              "immutable": true
            },
            "GetWeight": {
              "doc": "Query a font's weight, in terms of the lightness/heaviness of the strokes.\n\n@returns the font's current weight.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.2.2.",
              "name": "GetWeight",
              "kind": "function",
              "type": "int",
              "parameters": [],
              "sourceName": "TTF_GetFontWeight",
              "immutable": true
            },
            "SetWrapAlignment": {
              "doc": "Set a font's current wrap alignment option.\n\nThis updates any TextBase objects using this font.\n\n@param align the new wrap alignment option.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.GetWrapAlignment",
              "name": "SetWrapAlignment",
              "kind": "function",
              "type": "void",
              "parameters": [
                {
                  "name": "align",
                  "type": "HorizontalAlignment"
                }
              ],
              "sourceName": "TTF_SetFontWrapAlignment"
            },
            "GetWrapAlignment": {
              "doc": "Query a font's current wrap alignment option.\n\n@returns the font's current wrap alignment option.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.SetWrapAlignment",
              "name": "GetWrapAlignment",
              "kind": "function",
              "type": "HorizontalAlignment",
              "parameters": [],
              "sourceName": "TTF_GetFontWrapAlignment",
              "immutable": true
            },
            "GetHeight": {
              "doc": "Query the total height of a font.\n\nThis is usually equal to point size.\n\n@returns the font's height.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "GetHeight",
              "kind": "function",
              "type": "int",
              "parameters": [],
              "sourceName": "TTF_GetFontHeight",
              "immutable": true
            },
            "GetAscent": {
              "doc": "Query the offset from the baseline to the top of a font.\n\nThis is a positive value, relative to the baseline.\n\n@returns the font's ascent.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "GetAscent",
              "kind": "function",
              "type": "int",
              "parameters": [],
              "sourceName": "TTF_GetFontAscent",
              "immutable": true
            },
            "GetDescent": {
              "doc": "Query the offset from the baseline to the bottom of a font.\n\nThis is a negative value, relative to the baseline.\n\n@returns the font's descent.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "GetDescent",
              "kind": "function",
              "type": "int",
              "parameters": [],
              "sourceName": "TTF_GetFontDescent",
              "immutable": true
            },
            "SetLineSkip": {
              "doc": "Set the spacing between lines of text for a font.\n\nThis updates any TextBase objects using this font.\n\n@param lineskip the new line spacing for the font.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.GetLineSkip",
              "name": "SetLineSkip",
              "kind": "function",
              "type": "void",
              "parameters": [
                {
                  "name": "lineskip",
                  "type": "int"
                }
              ],
              "sourceName": "TTF_SetFontLineSkip"
            },
            "GetLineSkip": {
              "doc": "Query the spacing between lines of text for a font.\n\n@returns the font's recommended spacing.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.SetLineSkip",
              "name": "GetLineSkip",
              "kind": "function",
              "type": "int",
              "parameters": [],
              "sourceName": "TTF_GetFontLineSkip",
              "immutable": true
            },
            "SetKerning": {
              "doc": "Set if kerning is enabled for a font.\n\nNewly-opened fonts default to allowing kerning. This is generally a good\npolicy unless you have a strong reason to disable it, as it tends to\nproduce better rendering (with kerning disabled, some fonts might render\nthe word `kerning` as something that looks like `keming` for example).\n\nThis updates any TextBase objects using this font.\n\n@param enabled true to enable kerning, false to disable.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.GetKerning",
              "name": "SetKerning",
              "kind": "function",
              "type": "void",
              "parameters": [
                {
                  "name": "enabled",
                  "type": "bool"
                }
              ],
              "sourceName": "TTF_SetFontKerning"
            },
            "GetKerning": {
              "doc": "Query whether or not kerning is enabled for a font.\n\n@returns true if kerning is enabled, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.SetKerning",
              "name": "GetKerning",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "TTF_GetFontKerning",
              "immutable": true
            },
            "IsFixedWidth": {
              "doc": "Query whether a font is fixed-width.\n\nA \"fixed-width\" font means all glyphs are the same width across; a\nlowercase 'i' will be the same size across as a capital 'W', for example.\nThis is common for terminals and text editors, and other apps that treat\ntext as a grid. Most other things (WYSIWYG word processors, web pages, etc)\nare more likely to not be fixed-width in most cases.\n\n@returns true if the font is fixed-width, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "IsFixedWidth",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "TTF_FontIsFixedWidth",
              "immutable": true
            },
            "IsScalable": {
              "doc": "Query whether a font is scalable or not.\n\nScalability lets us distinguish between outline and bitmap fonts.\n\n@returns true if the font is scalable, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.SetSDF",
              "name": "IsScalable",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "TTF_FontIsScalable",
              "immutable": true
            },
            "GetFamilyName": {
              "doc": "Query a font's family name.\n\nThis string is dictated by the contents of the font file.\n\nNote that the returned string is to internal storage, and should not be\nmodified or free'd by the caller. The string becomes invalid, with the rest\nof the font, when `font` is handed to FontBase.Close().\n\n@returns the font's family name.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "GetFamilyName",
              "kind": "function",
              "type": "const char *",
              "parameters": [],
              "sourceName": "TTF_GetFontFamilyName",
              "immutable": true
            },
            "GetStyleName": {
              "doc": "Query a font's style name.\n\nThis string is dictated by the contents of the font file.\n\nNote that the returned string is to internal storage, and should not be\nmodified or free'd by the caller. The string becomes invalid, with the rest\nof the font, when `font` is handed to FontBase.Close().\n\n@returns the font's style name.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "GetStyleName",
              "kind": "function",
              "type": "const char *",
              "parameters": [],
              "sourceName": "TTF_GetFontStyleName",
              "immutable": true
            },
            "SetDirection": {
              "doc": "Set the direction to be used for text shaping by a font.\n\nThis function only supports left-to-right text shaping if SDL_ttf was not\nbuilt with HarfBuzz support.\n\nThis updates any TextBase objects using this font.\n\n@param direction the new direction for text to flow.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "SetDirection",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "direction",
                  "type": "Direction"
                }
              ],
              "sourceName": "TTF_SetFontDirection"
            },
            "GetDirection": {
              "doc": "Get the direction to be used for text shaping by a font.\n\nThis defaults to DIRECTION_INVALID if it hasn't been set.\n\n@returns the direction to be used for text shaping.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "GetDirection",
              "kind": "function",
              "type": "Direction",
              "parameters": [],
              "sourceName": "TTF_GetFontDirection",
              "immutable": true
            },
            "SetScript": {
              "doc": "Set the script to be used for text shaping by a font.\n\nThis returns false if SDL_ttf isn't built with HarfBuzz support.\n\nThis updates any TextBase objects using this font.\n\n@param script an\n              [ISO 15924 code](https://unicode.org/iso15924/iso15924-codes.html)\n              .\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa StringToTag",
              "name": "SetScript",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "script",
                  "type": "Uint32"
                }
              ],
              "sourceName": "TTF_SetFontScript"
            },
            "GetScript": {
              "doc": "Get the script used for text shaping a font.\n\n@returns an\n         [ISO 15924 code](https://unicode.org/iso15924/iso15924-codes.html)\n         or 0 if a script hasn't been set.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TagToString",
              "name": "GetScript",
              "kind": "function",
              "type": "Uint32",
              "parameters": [],
              "sourceName": "TTF_GetFontScript",
              "immutable": true
            },
            "GetGlyphScript": {
              "doc": "Get the script used by a 32-bit codepoint.\n\n@param ch the character code to check.\n@returns an\n         [ISO 15924 code](https://unicode.org/iso15924/iso15924-codes.html)\n         on success, or 0 on failure; call GetError() for more\n         information.\n\n@threadsafety This function is thread-safe.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TagToString",
              "name": "GetGlyphScript",
              "kind": "function",
              "type": "Uint32",
              "parameters": [
                {
                  "name": "ch",
                  "type": "Uint32"
                }
              ],
              "sourceName": "TTF_GetGlyphScript",
              "immutable": true,
              "static": false
            },
            "SetLanguage": {
              "doc": "Set language to be used for text shaping by a font.\n\nIf SDL_ttf was not built with HarfBuzz support, this function returns\nfalse.\n\nThis updates any TextBase objects using this font.\n\n@param language_bcp47 a null-terminated string containing the desired\n                      language's BCP47 code. Or null to reset the value.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "SetLanguage",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "language_bcp47",
                  "type": "StringParam"
                }
              ],
              "sourceName": "TTF_SetFontLanguage"
            },
            "HasGlyph": {
              "doc": "Check whether a glyph is provided by the font for a UNICODE codepoint.\n\n@param ch the codepoint to check.\n@returns true if font provides a glyph for this character, false if not.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "HasGlyph",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "ch",
                  "type": "Uint32"
                }
              ],
              "sourceName": "TTF_FontHasGlyph",
              "immutable": true
            },
            "GetGlyphImage": {
              "doc": "Get the pixel image for a UNICODE codepoint.\n\n@param ch the codepoint to check.\n@param image_type a pointer filled in with the glyph image type, may be\n                  nullptr.\n@returns an SurfaceBase containing the glyph, or nullptr on failure; call\n         GetError() for more information.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "GetGlyphImage",
              "kind": "function",
              "type": "SurfaceRef",
              "parameters": [
                {
                  "name": "ch",
                  "type": "Uint32"
                },
                {
                  "name": "image_type",
                  "type": "ImageType *"
                }
              ],
              "sourceName": "TTF_GetGlyphImage",
              "immutable": true
            },
            "GetGlyphImageForIndex": {
              "doc": "Get the pixel image for a character index.\n\nThis is useful for text engine implementations, which can call this with\nthe `glyph_index` in a TTF_CopyOperation\n\n@param glyph_index the index of the glyph to return.\n@param image_type a pointer filled in with the glyph image type, may be\n                  nullptr.\n@returns an SurfaceBase containing the glyph, or nullptr on failure; call\n         GetError() for more information.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "GetGlyphImageForIndex",
              "kind": "function",
              "type": "SurfaceRef",
              "parameters": [
                {
                  "name": "glyph_index",
                  "type": "Uint32"
                },
                {
                  "name": "image_type",
                  "type": "ImageType *"
                }
              ],
              "sourceName": "TTF_GetGlyphImageForIndex",
              "immutable": true
            },
            "GetGlyphMetrics": {
              "doc": "Query the metrics (dimensions) of a font's glyph for a UNICODE codepoint.\n\nTo understand what these metrics mean, here is a useful link:\n\nhttps://freetype.sourceforge.net/freetype2/docs/tutorial/step2.html\n\n@param ch the codepoint to check.\n@param minx a pointer filled in with the minimum x coordinate of the glyph\n            from the left edge of its bounding box. This value may be\n            negative.\n@param maxx a pointer filled in with the maximum x coordinate of the glyph\n            from the left edge of its bounding box.\n@param miny a pointer filled in with the minimum y coordinate of the glyph\n            from the bottom edge of its bounding box. This value may be\n            negative.\n@param maxy a pointer filled in with the maximum y coordinate of the glyph\n            from the bottom edge of its bounding box.\n@param advance a pointer filled in with the distance to the next glyph from\n               the left edge of this glyph's bounding box.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "GetGlyphMetrics",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "ch",
                  "type": "Uint32"
                },
                {
                  "name": "minx",
                  "type": "int *"
                },
                {
                  "name": "maxx",
                  "type": "int *"
                },
                {
                  "name": "miny",
                  "type": "int *"
                },
                {
                  "name": "maxy",
                  "type": "int *"
                },
                {
                  "name": "advance",
                  "type": "int *"
                }
              ],
              "sourceName": "TTF_GetGlyphMetrics",
              "immutable": true
            },
            "GetGlyphKerning": {
              "doc": "Query the kerning size between the glyphs of two UNICODE codepoints.\n\n@param previous_ch the previous codepoint.\n@param ch the current codepoint.\n@param kerning a pointer filled in with the kerning size between the two\n               glyphs, in pixels, may be nullptr.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "GetGlyphKerning",
              "kind": "function",
              "type": "std::optional<int>",
              "parameters": [
                {
                  "name": "previous_ch",
                  "type": "Uint32"
                },
                {
                  "name": "ch",
                  "type": "Uint32"
                }
              ],
              "sourceName": "TTF_GetGlyphKerning",
              "immutable": true
            },
            "GetStringSize": [
              {
                "kind": "function",
                "immutable": true,
                "type": "std::optional<Point>",
                "parameters": [
                  {
                    "name": "text",
                    "type": "std::string_view"
                  }
                ],
                "name": "GetStringSize",
                "doc": ""
              },
              {
                "doc": "Calculate the dimensions of a rendered string of UTF-8 text.\n\nThis will report the width and height, in pixels, of the space that the\nspecified string will take to fully render.\n\n@param font the font to query.\n@param text text to calculate, in UTF-8 encoding.\n@param length the length of the text, in bytes, or 0 for null terminated\n              text.\n@param w will be filled with width, in pixels, on return.\n@param h will be filled with height, in pixels, on return.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.",
                "name": "GetStringSize",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "text",
                    "type": "std::string_view"
                  },
                  {
                    "name": "w",
                    "type": "int *"
                  },
                  {
                    "name": "h",
                    "type": "int *"
                  }
                ],
                "sourceName": "TTF_GetStringSize",
                "immutable": true,
                "static": false
              }
            ],
            "GetStringSizeWrapped": [
              {
                "kind": "function",
                "immutable": true,
                "type": "std::optional<Point>",
                "parameters": [
                  {
                    "name": "text",
                    "type": "std::string_view"
                  },
                  {
                    "name": "wrap_width",
                    "type": "int"
                  }
                ],
                "name": "GetStringSizeWrapped",
                "doc": ""
              },
              {
                "doc": "Calculate the dimensions of a rendered string of UTF-8 text.\n\nThis will report the width and height, in pixels, of the space that the\nspecified string will take to fully render.\n\nText is wrapped to multiple lines on line endings and on word boundaries if\nit extends beyond `wrap_width` in pixels.\n\nIf wrap_width is 0, this function will only wrap on newline characters.\n\n@param font the font to query.\n@param text text to calculate, in UTF-8 encoding.\n@param length the length of the text, in bytes, or 0 for null terminated\n              text.\n@param wrap_width the maximum width or 0 to wrap on newline characters.\n@param w will be filled with width, in pixels, on return.\n@param h will be filled with height, in pixels, on return.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.",
                "name": "GetStringSizeWrapped",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "text",
                    "type": "std::string_view"
                  },
                  {
                    "name": "wrap_width",
                    "type": "int"
                  },
                  {
                    "name": "w",
                    "type": "int *"
                  },
                  {
                    "name": "h",
                    "type": "int *"
                  }
                ],
                "sourceName": "TTF_GetStringSizeWrapped",
                "immutable": true,
                "static": false
              }
            ],
            "MeasureString": {
              "doc": "Calculate how much of a UTF-8 string will fit in a given width.\n\nThis reports the number of characters that can be rendered before reaching\n`max_width`.\n\nThis does not need to render the string to do this calculation.\n\n@param font the font to query.\n@param text text to calculate, in UTF-8 encoding.\n@param length the length of the text, in bytes, or 0 for null terminated\n              text.\n@param max_width maximum width, in pixels, available for the string, or 0\n                 for unbounded width.\n@param measured_width a pointer filled in with the width, in pixels, of the\n                      string that will fit, may be nullptr.\n@param measured_length a pointer filled in with the length, in bytes, of\n                       the string that will fit, may be nullptr.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "MeasureString",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "text",
                  "type": "std::string_view"
                },
                {
                  "name": "max_width",
                  "type": "int"
                },
                {
                  "name": "measured_width",
                  "type": "int *"
                },
                {
                  "name": "measured_length",
                  "type": "size_t *"
                }
              ],
              "sourceName": "TTF_MeasureString",
              "immutable": true,
              "static": false
            },
            "RenderText_Solid": {
              "doc": "Render UTF-8 text at fast quality to a new 8-bit surface.\n\nThis function will allocate a new 8-bit, palettized surface. The surface's\n0 pixel will be the colorkey, giving a transparent background. The 1 pixel\nwill be set to the text color.\n\nThis will not word-wrap the string; you'll get a surface with a single line\nof text, as long as the string requires. You can use\nFontBase.RenderText_Solid_Wrapped() instead if you need to wrap the output to\nmultiple lines.\n\nThis will not wrap on newline characters.\n\nYou can render at other quality levels with FontBase.RenderText_Shaded,\nFontBase.RenderText_Blended, and FontBase.RenderText_LCD.\n\n@param font the font to render with.\n@param text text to render, in UTF-8 encoding.\n@param length the length of the text, in bytes, or 0 for null terminated\n              text.\n@param fg the foreground color for the text.\n@returns a new 8-bit, palettized surface, or nullptr if there was an error.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.RenderText_Blended\n@sa FontBase.RenderText_LCD\n@sa FontBase.RenderText_Shaded\n@sa FontBase.RenderText_Solid\n@sa FontBase.RenderText_Solid_Wrapped",
              "name": "RenderText_Solid",
              "kind": "function",
              "type": "Surface",
              "parameters": [
                {
                  "name": "text",
                  "type": "std::string_view"
                },
                {
                  "name": "fg",
                  "type": "Color"
                }
              ],
              "sourceName": "TTF_RenderText_Solid",
              "immutable": true,
              "static": false
            },
            "RenderText_Solid_Wrapped": {
              "doc": "Render word-wrapped UTF-8 text at fast quality to a new 8-bit surface.\n\nThis function will allocate a new 8-bit, palettized surface. The surface's\n0 pixel will be the colorkey, giving a transparent background. The 1 pixel\nwill be set to the text color.\n\nText is wrapped to multiple lines on line endings and on word boundaries if\nit extends beyond `wrapLength` in pixels.\n\nIf wrapLength is 0, this function will only wrap on newline characters.\n\nYou can render at other quality levels with FontBase.RenderText_Shaded_Wrapped,\nFontBase.RenderText_Blended_Wrapped, and FontBase.RenderText_LCD_Wrapped.\n\n@param font the font to render with.\n@param text text to render, in UTF-8 encoding.\n@param length the length of the text, in bytes, or 0 for null terminated\n              text.\n@param fg the foreground color for the text.\n@param wrapLength the maximum width of the text surface or 0 to wrap on\n                  newline characters.\n@returns a new 8-bit, palettized surface, or nullptr if there was an error.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.RenderText_Blended_Wrapped\n@sa FontBase.RenderText_LCD_Wrapped\n@sa FontBase.RenderText_Shaded_Wrapped\n@sa FontBase.RenderText_Solid",
              "name": "RenderText_Solid_Wrapped",
              "kind": "function",
              "type": "Surface",
              "parameters": [
                {
                  "name": "text",
                  "type": "std::string_view"
                },
                {
                  "name": "fg",
                  "type": "Color"
                },
                {
                  "name": "wrapLength",
                  "type": "int"
                }
              ],
              "sourceName": "TTF_RenderText_Solid_Wrapped",
              "immutable": true,
              "static": false
            },
            "RenderGlyph_Solid": {
              "doc": "Render a single 32-bit glyph at fast quality to a new 8-bit surface.\n\nThis function will allocate a new 8-bit, palettized surface. The surface's\n0 pixel will be the colorkey, giving a transparent background. The 1 pixel\nwill be set to the text color.\n\nThe glyph is rendered without any padding or centering in the X direction,\nand aligned normally in the Y direction.\n\nYou can render at other quality levels with FontBase.RenderGlyph_Shaded,\nFontBase.RenderGlyph_Blended, and FontBase.RenderGlyph_LCD.\n\n@param ch the character to render.\n@param fg the foreground color for the text.\n@returns a new 8-bit, palettized surface, or nullptr if there was an error.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.RenderGlyph_Blended\n@sa FontBase.RenderGlyph_LCD\n@sa FontBase.RenderGlyph_Shaded",
              "name": "RenderGlyph_Solid",
              "kind": "function",
              "type": "Surface",
              "parameters": [
                {
                  "name": "ch",
                  "type": "Uint32"
                },
                {
                  "name": "fg",
                  "type": "Color"
                }
              ],
              "sourceName": "TTF_RenderGlyph_Solid",
              "immutable": true
            },
            "RenderText_Shaded": {
              "doc": "Render UTF-8 text at high quality to a new 8-bit surface.\n\nThis function will allocate a new 8-bit, palettized surface. The surface's\n0 pixel will be the specified background color, while other pixels have\nvarying degrees of the foreground color. This function returns the new\nsurface, or nullptr if there was an error.\n\nThis will not word-wrap the string; you'll get a surface with a single line\nof text, as long as the string requires. You can use\nFontBase.RenderText_Shaded_Wrapped() instead if you need to wrap the output to\nmultiple lines.\n\nThis will not wrap on newline characters.\n\nYou can render at other quality levels with FontBase.RenderText_Solid,\nFontBase.RenderText_Blended, and FontBase.RenderText_LCD.\n\n@param font the font to render with.\n@param text text to render, in UTF-8 encoding.\n@param length the length of the text, in bytes, or 0 for null terminated\n              text.\n@param fg the foreground color for the text.\n@param bg the background color for the text.\n@returns a new 8-bit, palettized surface, or nullptr if there was an error.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.RenderText_Blended\n@sa FontBase.RenderText_LCD\n@sa FontBase.RenderText_Shaded_Wrapped\n@sa FontBase.RenderText_Solid",
              "name": "RenderText_Shaded",
              "kind": "function",
              "type": "Surface",
              "parameters": [
                {
                  "name": "text",
                  "type": "std::string_view"
                },
                {
                  "name": "fg",
                  "type": "Color"
                },
                {
                  "name": "bg",
                  "type": "Color"
                }
              ],
              "sourceName": "TTF_RenderText_Shaded",
              "immutable": true,
              "static": false
            },
            "RenderText_Shaded_Wrapped": {
              "doc": "Render word-wrapped UTF-8 text at high quality to a new 8-bit surface.\n\nThis function will allocate a new 8-bit, palettized surface. The surface's\n0 pixel will be the specified background color, while other pixels have\nvarying degrees of the foreground color. This function returns the new\nsurface, or nullptr if there was an error.\n\nText is wrapped to multiple lines on line endings and on word boundaries if\nit extends beyond `wrap_width` in pixels.\n\nIf wrap_width is 0, this function will only wrap on newline characters.\n\nYou can render at other quality levels with FontBase.RenderText_Solid_Wrapped,\nFontBase.RenderText_Blended_Wrapped, and FontBase.RenderText_LCD_Wrapped.\n\n@param font the font to render with.\n@param text text to render, in UTF-8 encoding.\n@param length the length of the text, in bytes, or 0 for null terminated\n              text.\n@param fg the foreground color for the text.\n@param bg the background color for the text.\n@param wrap_width the maximum width of the text surface or 0 to wrap on\n                  newline characters.\n@returns a new 8-bit, palettized surface, or nullptr if there was an error.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.RenderText_Blended_Wrapped\n@sa FontBase.RenderText_LCD_Wrapped\n@sa FontBase.RenderText_Shaded\n@sa FontBase.RenderText_Solid_Wrapped",
              "name": "RenderText_Shaded_Wrapped",
              "kind": "function",
              "type": "Surface",
              "parameters": [
                {
                  "name": "text",
                  "type": "std::string_view"
                },
                {
                  "name": "fg",
                  "type": "Color"
                },
                {
                  "name": "bg",
                  "type": "Color"
                },
                {
                  "name": "wrap_width",
                  "type": "int"
                }
              ],
              "sourceName": "TTF_RenderText_Shaded_Wrapped",
              "immutable": true,
              "static": false
            },
            "RenderGlyph_Shaded": {
              "doc": "Render a single UNICODE codepoint at high quality to a new 8-bit surface.\n\nThis function will allocate a new 8-bit, palettized surface. The surface's\n0 pixel will be the specified background color, while other pixels have\nvarying degrees of the foreground color. This function returns the new\nsurface, or nullptr if there was an error.\n\nThe glyph is rendered without any padding or centering in the X direction,\nand aligned normally in the Y direction.\n\nYou can render at other quality levels with FontBase.RenderGlyph_Solid,\nFontBase.RenderGlyph_Blended, and FontBase.RenderGlyph_LCD.\n\n@param ch the codepoint to render.\n@param fg the foreground color for the text.\n@param bg the background color for the text.\n@returns a new 8-bit, palettized surface, or nullptr if there was an error.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.RenderGlyph_Blended\n@sa FontBase.RenderGlyph_LCD\n@sa FontBase.RenderGlyph_Solid",
              "name": "RenderGlyph_Shaded",
              "kind": "function",
              "type": "Surface",
              "parameters": [
                {
                  "name": "ch",
                  "type": "Uint32"
                },
                {
                  "name": "fg",
                  "type": "Color"
                },
                {
                  "name": "bg",
                  "type": "Color"
                }
              ],
              "sourceName": "TTF_RenderGlyph_Shaded",
              "immutable": true
            },
            "RenderText_Blended": {
              "doc": "Render UTF-8 text at high quality to a new ARGB surface.\n\nThis function will allocate a new 32-bit, ARGB surface, using alpha\nblending to dither the font with the given color. This function returns the\nnew surface, or nullptr if there was an error.\n\nThis will not word-wrap the string; you'll get a surface with a single line\nof text, as long as the string requires. You can use\nFontBase.RenderText_Blended_Wrapped() instead if you need to wrap the output to\nmultiple lines.\n\nThis will not wrap on newline characters.\n\nYou can render at other quality levels with FontBase.RenderText_Solid,\nFontBase.RenderText_Shaded, and FontBase.RenderText_LCD.\n\n@param font the font to render with.\n@param text text to render, in UTF-8 encoding.\n@param length the length of the text, in bytes, or 0 for null terminated\n              text.\n@param fg the foreground color for the text.\n@returns a new 32-bit, ARGB surface, or nullptr if there was an error.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.RenderText_Blended_Wrapped\n@sa FontBase.RenderText_LCD\n@sa FontBase.RenderText_Shaded\n@sa FontBase.RenderText_Solid",
              "name": "RenderText_Blended",
              "kind": "function",
              "type": "Surface",
              "parameters": [
                {
                  "name": "text",
                  "type": "std::string_view"
                },
                {
                  "name": "fg",
                  "type": "Color"
                }
              ],
              "sourceName": "TTF_RenderText_Blended",
              "immutable": true,
              "static": false
            },
            "RenderText_Blended_Wrapped": {
              "doc": "Render word-wrapped UTF-8 text at high quality to a new ARGB surface.\n\nThis function will allocate a new 32-bit, ARGB surface, using alpha\nblending to dither the font with the given color. This function returns the\nnew surface, or nullptr if there was an error.\n\nText is wrapped to multiple lines on line endings and on word boundaries if\nit extends beyond `wrap_width` in pixels.\n\nIf wrap_width is 0, this function will only wrap on newline characters.\n\nYou can render at other quality levels with FontBase.RenderText_Solid_Wrapped,\nFontBase.RenderText_Shaded_Wrapped, and FontBase.RenderText_LCD_Wrapped.\n\n@param font the font to render with.\n@param text text to render, in UTF-8 encoding.\n@param length the length of the text, in bytes, or 0 for null terminated\n              text.\n@param fg the foreground color for the text.\n@param wrap_width the maximum width of the text surface or 0 to wrap on\n                  newline characters.\n@returns a new 32-bit, ARGB surface, or nullptr if there was an error.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.RenderText_Blended\n@sa FontBase.RenderText_LCD_Wrapped\n@sa FontBase.RenderText_Shaded_Wrapped\n@sa FontBase.RenderText_Solid_Wrapped",
              "name": "RenderText_Blended_Wrapped",
              "kind": "function",
              "type": "Surface",
              "parameters": [
                {
                  "name": "text",
                  "type": "std::string_view"
                },
                {
                  "name": "fg",
                  "type": "Color"
                },
                {
                  "name": "wrap_width",
                  "type": "int"
                }
              ],
              "sourceName": "TTF_RenderText_Blended_Wrapped",
              "immutable": true,
              "static": false
            },
            "RenderGlyph_Blended": {
              "doc": "Render a single UNICODE codepoint at high quality to a new ARGB surface.\n\nThis function will allocate a new 32-bit, ARGB surface, using alpha\nblending to dither the font with the given color. This function returns the\nnew surface, or nullptr if there was an error.\n\nThe glyph is rendered without any padding or centering in the X direction,\nand aligned normally in the Y direction.\n\nYou can render at other quality levels with FontBase.RenderGlyph_Solid,\nFontBase.RenderGlyph_Shaded, and FontBase.RenderGlyph_LCD.\n\n@param ch the codepoint to render.\n@param fg the foreground color for the text.\n@returns a new 32-bit, ARGB surface, or nullptr if there was an error.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.RenderGlyph_LCD\n@sa FontBase.RenderGlyph_Shaded\n@sa FontBase.RenderGlyph_Solid",
              "name": "RenderGlyph_Blended",
              "kind": "function",
              "type": "Surface",
              "parameters": [
                {
                  "name": "ch",
                  "type": "Uint32"
                },
                {
                  "name": "fg",
                  "type": "Color"
                }
              ],
              "sourceName": "TTF_RenderGlyph_Blended",
              "immutable": true
            },
            "RenderText_LCD": {
              "doc": "Render UTF-8 text at LCD subpixel quality to a new ARGB surface.\n\nThis function will allocate a new 32-bit, ARGB surface, and render\nalpha-blended text using FreeType's LCD subpixel rendering. This function\nreturns the new surface, or nullptr if there was an error.\n\nThis will not word-wrap the string; you'll get a surface with a single line\nof text, as long as the string requires. You can use\nFontBase.RenderText_LCD_Wrapped() instead if you need to wrap the output to\nmultiple lines.\n\nThis will not wrap on newline characters.\n\nYou can render at other quality levels with FontBase.RenderText_Solid,\nFontBase.RenderText_Shaded, and FontBase.RenderText_Blended.\n\n@param font the font to render with.\n@param text text to render, in UTF-8 encoding.\n@param length the length of the text, in bytes, or 0 for null terminated\n              text.\n@param fg the foreground color for the text.\n@param bg the background color for the text.\n@returns a new 32-bit, ARGB surface, or nullptr if there was an error.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.RenderText_Blended\n@sa FontBase.RenderText_LCD_Wrapped\n@sa FontBase.RenderText_Shaded\n@sa FontBase.RenderText_Solid",
              "name": "RenderText_LCD",
              "kind": "function",
              "type": "Surface",
              "parameters": [
                {
                  "name": "text",
                  "type": "std::string_view"
                },
                {
                  "name": "fg",
                  "type": "Color"
                },
                {
                  "name": "bg",
                  "type": "Color"
                }
              ],
              "sourceName": "TTF_RenderText_LCD",
              "immutable": true,
              "static": false
            },
            "RenderText_LCD_Wrapped": {
              "doc": "Render word-wrapped UTF-8 text at LCD subpixel quality to a new ARGB\nsurface.\n\nThis function will allocate a new 32-bit, ARGB surface, and render\nalpha-blended text using FreeType's LCD subpixel rendering. This function\nreturns the new surface, or nullptr if there was an error.\n\nText is wrapped to multiple lines on line endings and on word boundaries if\nit extends beyond `wrap_width` in pixels.\n\nIf wrap_width is 0, this function will only wrap on newline characters.\n\nYou can render at other quality levels with FontBase.RenderText_Solid_Wrapped,\nFontBase.RenderText_Shaded_Wrapped, and FontBase.RenderText_Blended_Wrapped.\n\n@param font the font to render with.\n@param text text to render, in UTF-8 encoding.\n@param length the length of the text, in bytes, or 0 for null terminated\n              text.\n@param fg the foreground color for the text.\n@param bg the background color for the text.\n@param wrap_width the maximum width of the text surface or 0 to wrap on\n                  newline characters.\n@returns a new 32-bit, ARGB surface, or nullptr if there was an error.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.RenderText_Blended_Wrapped\n@sa FontBase.RenderText_LCD\n@sa FontBase.RenderText_Shaded_Wrapped\n@sa FontBase.RenderText_Solid_Wrapped",
              "name": "RenderText_LCD_Wrapped",
              "kind": "function",
              "type": "Surface",
              "parameters": [
                {
                  "name": "text",
                  "type": "std::string_view"
                },
                {
                  "name": "fg",
                  "type": "Color"
                },
                {
                  "name": "bg",
                  "type": "Color"
                },
                {
                  "name": "wrap_width",
                  "type": "int"
                }
              ],
              "sourceName": "TTF_RenderText_LCD_Wrapped",
              "immutable": true,
              "static": false
            },
            "RenderGlyph_LCD": {
              "doc": "Render a single UNICODE codepoint at LCD subpixel quality to a new ARGB\nsurface.\n\nThis function will allocate a new 32-bit, ARGB surface, and render\nalpha-blended text using FreeType's LCD subpixel rendering. This function\nreturns the new surface, or nullptr if there was an error.\n\nThe glyph is rendered without any padding or centering in the X direction,\nand aligned normally in the Y direction.\n\nYou can render at other quality levels with FontBase.RenderGlyph_Solid,\nFontBase.RenderGlyph_Shaded, and FontBase.RenderGlyph_Blended.\n\n@param ch the codepoint to render.\n@param fg the foreground color for the text.\n@param bg the background color for the text.\n@returns a new 32-bit, ARGB surface, or nullptr if there was an error.\n\n@threadsafety This function should be called on the thread that created the\n              font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.RenderGlyph_Blended\n@sa FontBase.RenderGlyph_Shaded\n@sa FontBase.RenderGlyph_Solid",
              "name": "RenderGlyph_LCD",
              "kind": "function",
              "type": "Surface",
              "parameters": [
                {
                  "name": "ch",
                  "type": "Uint32"
                },
                {
                  "name": "fg",
                  "type": "Color"
                },
                {
                  "name": "bg",
                  "type": "Color"
                }
              ],
              "sourceName": "TTF_RenderGlyph_LCD",
              "immutable": true
            },
            "Close": {
              "doc": "Dispose of a previously-created font.\n\nCall this when done with a font. This function will free any resources\nassociated with it. It is safe to call this function on nullptr, for example\non the result of a failed call to FontBase.FontBase().\n\nThe font is not valid after being passed to this function. String pointers\nfrom functions that return information on this font, such as\nFontBase.GetFamilyName() and FontBase.GetStyleName(), are no longer valid\nafter this call, as well.\n\n\n@threadsafety This function should not be called while any other thread is\n              using the font.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa FontBase.FontBase\n@sa FontBase.FontBase",
              "name": "Close",
              "kind": "function",
              "type": "void",
              "parameters": [],
              "sourceName": "TTF_CloseFont"
            }
          }
        },
        "ObjectRef<TTF_Font>::doFree": {
          "name": "ObjectRef<TTF_Font>::doFree",
          "type": "void",
          "kind": "function",
          "doc": "Callback for font resource cleanup\n\n@private",
          "template": [],
          "parameters": [
            {
              "type": "TTF_Font *",
              "name": "resource"
            }
          ],
          "sourceName": "TTF_CloseFont"
        },
        "InitSubSystem": {
          "doc": "Initialize SDL_ttf.\n\nYou must successfully call this function before it is safe to call any\nother function in this library.\n\nIt is safe to call this more than once, and each successful InitSubSystem() call\nshould be paired with a matching QuitSubSystem() call.\n\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa QuitSubSystem",
          "name": "InitSubSystem",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "type": "TtfInitFlag",
              "name": "_"
            }
          ],
          "sourceName": "TTF_Init"
        },
        "TextEngineBase": {
          "doc": "",
          "name": "TextEngineBase",
          "kind": "struct",
          "sourceName": "TTF_TextEngine",
          "type": "T",
          "template": [
            {
              "type": "ObjectBox<TextEngineWrapper>",
              "name": "T"
            }
          ],
          "entries": {
            "T::T": {
              "kind": "alias",
              "name": "T::T",
              "doc": ""
            },
            "SetGPUWinding": {
              "doc": "Sets the winding order of the vertices returned by TextBase.GetGPUDrawData\nfor a particular GPU text engine.\n\n              CreateGPUTextEngine().\n@param winding the new winding order option.\n\n@threadsafety This function should be called on the thread that created the\n              engine.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TextEngineBase.GetGPUWinding",
              "name": "SetGPUWinding",
              "kind": "function",
              "type": "void",
              "parameters": [
                {
                  "name": "winding",
                  "type": "GPUTextEngineWinding"
                }
              ],
              "sourceName": "TTF_SetGPUTextEngineWinding"
            },
            "GetGPUWinding": {
              "doc": "Get the winding order of the vertices returned by TextBase.GetGPUDrawData\nfor a particular GPU text engine\n\n              CreateGPUTextEngine().\n@returns the winding order used by the GPU text engine or\n         GPU_TEXTENGINE_WINDING_INVALID in case of error.\n\n@threadsafety This function should be called on the thread that created the\n              engine.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TextEngineBase.SetGPUWinding",
              "name": "GetGPUWinding",
              "kind": "function",
              "type": "GPUTextEngineWinding",
              "parameters": [],
              "sourceName": "TTF_GetGPUTextEngineWinding",
              "immutable": true
            },
            "Destroy": {
              "kind": "function",
              "type": "void",
              "parameters": [],
              "name": "Destroy",
              "doc": ""
            }
          }
        },
        "ObjectRef<TTF_TextEngine, TextEngineWrapper>::doFree": {
          "name": "ObjectRef<TTF_TextEngine, TextEngineWrapper>::doFree",
          "kind": "function",
          "type": "void",
          "template": [],
          "parameters": [
            {
              "type": "TextEngineWrapper",
              "name": "resource"
            }
          ],
          "doc": ""
        },
        "GPUAtlasDrawSequence": {
          "doc": "Draw sequence returned by TextBase.GetGPUDrawData\n\n@since This struct is available since SDL_ttf 3.0.0.\n\n@sa TextBase.GetGPUDrawData",
          "name": "GPUAtlasDrawSequence",
          "kind": "alias",
          "sourceName": "TTF_GPUAtlasDrawSequence",
          "type": "TTF_GPUAtlasDrawSequence"
        },
        "SubString": {
          "doc": "The representation of a substring within text.\n\n@since This struct is available since SDL_ttf 3.0.0.\n\n@sa TextBase.GetNextSubString\n@sa TextBase.GetPreviousSubString\n@sa TextBase.GetSubString\n@sa TextBase.GetSubStringForLine\n@sa TextBase.GetSubStringForPoint\n@sa TextBase.GetSubStringsForRange",
          "name": "SubString",
          "kind": "alias",
          "sourceName": "TTF_SubString",
          "type": "TTF_SubString"
        },
        "SubStringIterator-forward": {
          "name": "SubStringIterator",
          "kind": "forward",
          "doc": ""
        },
        "prop::Font": {
          "kind": "ns",
          "name": "prop::Font",
          "entries": {
            "CREATE_FILENAME_STRING": {
              "doc": "",
              "name": "CREATE_FILENAME_STRING",
              "kind": "var",
              "value": "\"SDL_ttf.font.create.filename\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "TTF_PROP_FONT_CREATE_FILENAME_STRING"
            },
            "CREATE_IOSTREAM_POINTER": {
              "doc": "",
              "name": "CREATE_IOSTREAM_POINTER",
              "kind": "var",
              "value": "\"SDL_ttf.font.create.iostream\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "TTF_PROP_FONT_CREATE_IOSTREAM_POINTER"
            },
            "CREATE_IOSTREAM_OFFSET_NUMBER": {
              "doc": "",
              "name": "CREATE_IOSTREAM_OFFSET_NUMBER",
              "kind": "var",
              "value": "\"SDL_ttf.font.create.iostream.offset\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "TTF_PROP_FONT_CREATE_IOSTREAM_OFFSET_NUMBER"
            },
            "CREATE_IOSTREAM_AUTOCLOSE_BOOLEAN": {
              "doc": "",
              "name": "CREATE_IOSTREAM_AUTOCLOSE_BOOLEAN",
              "kind": "var",
              "value": "\"SDL_ttf.font.create.iostream.autoclose\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "TTF_PROP_FONT_CREATE_IOSTREAM_AUTOCLOSE_BOOLEAN"
            },
            "CREATE_SIZE_FLOAT": {
              "doc": "",
              "name": "CREATE_SIZE_FLOAT",
              "kind": "var",
              "value": "\"SDL_ttf.font.create.size\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "TTF_PROP_FONT_CREATE_SIZE_FLOAT"
            },
            "CREATE_FACE_NUMBER": {
              "doc": "",
              "name": "CREATE_FACE_NUMBER",
              "kind": "var",
              "value": "\"SDL_ttf.font.create.face\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "TTF_PROP_FONT_CREATE_FACE_NUMBER"
            },
            "CREATE_HORIZONTAL_DPI_NUMBER": {
              "doc": "",
              "name": "CREATE_HORIZONTAL_DPI_NUMBER",
              "kind": "var",
              "value": "\"SDL_ttf.font.create.hdpi\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "TTF_PROP_FONT_CREATE_HORIZONTAL_DPI_NUMBER"
            },
            "CREATE_VERTICAL_DPI_NUMBER": {
              "doc": "",
              "name": "CREATE_VERTICAL_DPI_NUMBER",
              "kind": "var",
              "value": "\"SDL_ttf.font.create.vdpi\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "TTF_PROP_FONT_CREATE_VERTICAL_DPI_NUMBER"
            },
            "CREATE_EXISTING_FONT": {
              "doc": "",
              "name": "CREATE_EXISTING_FONT",
              "kind": "var",
              "value": "\"SDL_ttf.font.create.existing_font\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "TTF_PROP_FONT_CREATE_EXISTING_FONT"
            },
            "OUTLINE_LINE_CAP_NUMBER": {
              "doc": "",
              "name": "OUTLINE_LINE_CAP_NUMBER",
              "kind": "var",
              "value": "\"SDL_ttf.font.outline.line_cap\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "TTF_PROP_FONT_OUTLINE_LINE_CAP_NUMBER"
            },
            "OUTLINE_LINE_JOIN_NUMBER": {
              "doc": "",
              "name": "OUTLINE_LINE_JOIN_NUMBER",
              "kind": "var",
              "value": "\"SDL_ttf.font.outline.line_join\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "TTF_PROP_FONT_OUTLINE_LINE_JOIN_NUMBER"
            },
            "OUTLINE_MITER_LIMIT_NUMBER": {
              "doc": "",
              "name": "OUTLINE_MITER_LIMIT_NUMBER",
              "kind": "var",
              "value": "\"SDL_ttf.font.outline.miter_limit\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "TTF_PROP_FONT_OUTLINE_MITER_LIMIT_NUMBER"
            }
          },
          "doc": ""
        },
        "SDL_FONT_WEIGHT_THIN": {
          "doc": "Thin (100) named font weight value",
          "name": "SDL_FONT_WEIGHT_THIN",
          "kind": "def",
          "value": "100",
          "sourceName": "TTF_FONT_WEIGHT_THIN"
        },
        "SDL_FONT_WEIGHT_EXTRA_LIGHT": {
          "doc": "ExtraLight (200) named font weight value",
          "name": "SDL_FONT_WEIGHT_EXTRA_LIGHT",
          "kind": "def",
          "value": "200",
          "sourceName": "TTF_FONT_WEIGHT_EXTRA_LIGHT"
        },
        "SDL_FONT_WEIGHT_LIGHT": {
          "doc": "Light (300) named font weight value",
          "name": "SDL_FONT_WEIGHT_LIGHT",
          "kind": "def",
          "value": "300",
          "sourceName": "TTF_FONT_WEIGHT_LIGHT"
        },
        "SDL_FONT_WEIGHT_NORMAL": {
          "doc": "Normal (400) named font weight value",
          "name": "SDL_FONT_WEIGHT_NORMAL",
          "kind": "def",
          "value": "400",
          "sourceName": "TTF_FONT_WEIGHT_NORMAL"
        },
        "SDL_FONT_WEIGHT_MEDIUM": {
          "doc": "Medium (500) named font weight value",
          "name": "SDL_FONT_WEIGHT_MEDIUM",
          "kind": "def",
          "value": "500",
          "sourceName": "TTF_FONT_WEIGHT_MEDIUM"
        },
        "SDL_FONT_WEIGHT_SEMI_BOLD": {
          "doc": "SemiBold (600) named font weight value",
          "name": "SDL_FONT_WEIGHT_SEMI_BOLD",
          "kind": "def",
          "value": "600",
          "sourceName": "TTF_FONT_WEIGHT_SEMI_BOLD"
        },
        "SDL_FONT_WEIGHT_BOLD": {
          "doc": "Bold (700) named font weight value",
          "name": "SDL_FONT_WEIGHT_BOLD",
          "kind": "def",
          "value": "700",
          "sourceName": "TTF_FONT_WEIGHT_BOLD"
        },
        "SDL_FONT_WEIGHT_EXTRA_BOLD": {
          "doc": "ExtraBold (800) named font weight value",
          "name": "SDL_FONT_WEIGHT_EXTRA_BOLD",
          "kind": "def",
          "value": "800",
          "sourceName": "TTF_FONT_WEIGHT_EXTRA_BOLD"
        },
        "SDL_FONT_WEIGHT_BLACK": {
          "doc": "Black (900) named font weight value",
          "name": "SDL_FONT_WEIGHT_BLACK",
          "kind": "def",
          "value": "900",
          "sourceName": "TTF_FONT_WEIGHT_BLACK"
        },
        "SDL_FONT_WEIGHT_EXTRA_BLACK": {
          "doc": "ExtraBlack (950) named font weight value",
          "name": "SDL_FONT_WEIGHT_EXTRA_BLACK",
          "kind": "def",
          "value": "950",
          "sourceName": "TTF_FONT_WEIGHT_EXTRA_BLACK"
        },
        "StringToTag": {
          "doc": "Convert from a 4 character string to a 32-bit tag.\n\n@param string the 4 character string to convert.\n@returns the 32-bit representation of the string.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TagToString",
          "name": "StringToTag",
          "kind": "function",
          "type": "Uint32",
          "parameters": [
            {
              "name": "string",
              "type": "StringParam"
            }
          ],
          "sourceName": "TTF_StringToTag"
        },
        "TagToString": {
          "doc": "Convert from a 32-bit tag to a 4 character string.\n\n@param tag the 32-bit tag to convert.\n@param string a pointer filled in with the 4 character representation of\n              the tag.\n@param size the size of the buffer pointed at by string, should be at least\n            4.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TagToString",
          "name": "TagToString",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "tag",
              "type": "Uint32"
            },
            {
              "name": "string",
              "type": "char *"
            },
            {
              "name": "size",
              "type": "size_t"
            }
          ],
          "sourceName": "TTF_TagToString"
        },
        "TextBase": {
          "doc": "Text created with TextBase.TextBase()\n\n@since This struct is available since SDL_ttf 3.0.0.\n\n@sa TextBase.TextBase\n@sa TextBase.GetProperties\n@sa TextBase.Destroy",
          "name": "TextBase",
          "kind": "struct",
          "sourceName": "TTF_Text",
          "type": "T",
          "template": [
            {
              "type": "ObjectBox<TTF_Text *>",
              "name": "T"
            }
          ],
          "entries": {
            "T::T": {
              "kind": "alias",
              "name": "T::T",
              "doc": ""
            },
            "DrawSurface": {
              "doc": "Draw text to an SDL surface.\n\n`text` must have been created using a TextEngineBase from\nCreateSurfaceTextEngine().\n\n@param text the text to draw.\n@param x the x coordinate in pixels, positive from the left edge towards\n         the right.\n@param y the y coordinate in pixels, positive from the top edge towards the\n         bottom.\n@param surface the surface to draw on.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa CreateSurfaceTextEngine\n@sa TextBase.TextBase",
              "name": "DrawSurface",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "p",
                  "type": "Point"
                },
                {
                  "name": "surface",
                  "type": "SurfaceRef"
                }
              ],
              "sourceName": "TTF_DrawSurfaceText",
              "immutable": true,
              "static": false
            },
            "DrawRenderer": {
              "doc": "Draw text to an SDL renderer.\n\n`text` must have been created using a TextEngineBase from\nCreateRendererTextEngine(), and will draw using the renderer passed to\nthat function.\n\n@param text the text to draw.\n@param x the x coordinate in pixels, positive from the left edge towards\n         the right.\n@param y the y coordinate in pixels, positive from the top edge towards the\n         bottom.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa CreateRendererTextEngine\n@sa TextBase.TextBase",
              "name": "DrawRenderer",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "p",
                  "type": "FPoint"
                }
              ],
              "sourceName": "TTF_DrawRendererText",
              "immutable": true,
              "static": false
            },
            "GetGPUDrawData": {
              "doc": "Get the geometry data needed for drawing the text.\n\n`text` must have been created using a TextEngineBase from\nCreateGPUTextEngine().\n\nThe positive X-axis is taken towards the right and the positive Y-axis is\ntaken upwards for both the vertex and the texture coordinates, i.e, it\nfollows the same convention used by the SDL_GPU API. If you want to use a\ndifferent coordinate system you will need to transform the vertices\nyourself.\n\nIf the text looks blocky use linear filtering.\n\n@returns a nullptr terminated linked list of GPUAtlasDrawSequence objects\n         or nullptr if the passed text is empty or in case of failure; call\n         GetError() for more information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa CreateGPUTextEngine\n@sa TextBase.TextBase",
              "name": "GetGPUDrawData",
              "kind": "function",
              "type": "GPUAtlasDrawSequence *",
              "parameters": [],
              "sourceName": "TTF_GetGPUTextDrawData",
              "immutable": true
            },
            "TextBase": {
              "doc": "Create a text object from UTF-8 text and a text engine.\n\n@param engine the text engine to use when creating the text object, may be\n              nullptr.\n@param font the font to render with.\n@param text the text to use, in UTF-8 encoding.\n@param length the length of the text, in bytes, or 0 for null terminated\n              text.\n@post a TextBase object or nullptr on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              font and text engine.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TextBase.Destroy",
              "name": "TextBase",
              "kind": "function",
              "type": "",
              "parameters": [
                {
                  "name": "engine",
                  "type": "TextEngineRef"
                },
                {
                  "name": "font",
                  "type": "FontRef"
                },
                {
                  "name": "text",
                  "type": "std::string_view"
                }
              ],
              "sourceName": "TTF_CreateText"
            },
            "GetProperties": {
              "doc": "Get the properties associated with a text object.\n\n@returns a valid property ID on success or 0 on failure; call\n         GetError() for more information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "GetProperties",
              "kind": "function",
              "type": "PropertiesRef",
              "parameters": [],
              "sourceName": "TTF_GetTextProperties",
              "immutable": true
            },
            "SetEngine": {
              "doc": "Set the text engine used by a text object.\n\nThis function may cause the internal text representation to be rebuilt.\n\n@param engine the text engine to use for drawing.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TextBase.GetEngine",
              "name": "SetEngine",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "engine",
                  "type": "TextEngineRef"
                }
              ],
              "sourceName": "TTF_SetTextEngine"
            },
            "GetEngine": {
              "doc": "Get the text engine used by a text object.\n\n@returns the TextEngineBase used by the text on success or nullptr on failure;\n         call GetError() for more information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TextBase.SetEngine",
              "name": "GetEngine",
              "kind": "function",
              "type": "TextEngineRef",
              "parameters": [],
              "sourceName": "TTF_GetTextEngine",
              "immutable": true
            },
            "SetFont": {
              "doc": "Set the font used by a text object.\n\nWhen a text object has a font, any changes to the font will automatically\nregenerate the text. If you set the font to nullptr, the text will continue to\nrender but changes to the font will no longer affect the text.\n\nThis function may cause the internal text representation to be rebuilt.\n\n@param font the font to use, may be nullptr.\n@returns false if the text pointer is null; otherwise, true. call\n         GetError() for more information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TextBase.GetFont",
              "name": "SetFont",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "font",
                  "type": "FontRef"
                }
              ],
              "sourceName": "TTF_SetTextFont"
            },
            "GetFont": {
              "doc": "Get the font used by a text object.\n\n@returns the FontBase used by the text on success or nullptr on failure; call\n         GetError() for more information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TextBase.SetFont",
              "name": "GetFont",
              "kind": "function",
              "type": "FontRef",
              "parameters": [],
              "sourceName": "TTF_GetTextFont",
              "immutable": true
            },
            "SetDirection": {
              "doc": "Set the direction to be used for text shaping a text object.\n\nThis function only supports left-to-right text shaping if SDL_ttf was not\nbuilt with HarfBuzz support.\n\n@param direction the new direction for text to flow.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "SetDirection",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "direction",
                  "type": "Direction"
                }
              ],
              "sourceName": "TTF_SetTextDirection"
            },
            "GetDirection": {
              "doc": "Get the direction to be used for text shaping a text object.\n\nThis defaults to the direction of the font used by the text object.\n\n@returns the direction to be used for text shaping.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "GetDirection",
              "kind": "function",
              "type": "Direction",
              "parameters": [],
              "sourceName": "TTF_GetTextDirection",
              "immutable": true
            },
            "SetScript": {
              "doc": "Set the script to be used for text shaping a text object.\n\nThis returns false if SDL_ttf isn't built with HarfBuzz support.\n\n@param script an\n              [ISO 15924 code](https://unicode.org/iso15924/iso15924-codes.html)\n              .\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa StringToTag",
              "name": "SetScript",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "script",
                  "type": "Uint32"
                }
              ],
              "sourceName": "TTF_SetTextScript"
            },
            "GetScript": {
              "doc": "Get the script used for text shaping a text object.\n\nThis defaults to the script of the font used by the text object.\n\n@returns an\n         [ISO 15924 code](https://unicode.org/iso15924/iso15924-codes.html)\n         or 0 if a script hasn't been set on either the text object or the\n         font.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TagToString",
              "name": "GetScript",
              "kind": "function",
              "type": "Uint32",
              "parameters": [],
              "sourceName": "TTF_GetTextScript",
              "immutable": true
            },
            "SetColor": [
              {
                "doc": "Set the color of a text object.\n\nThe default text color is white (255, 255, 255, 255).\n\n@param text the TextBase to modify.\n@param r the red color value in the range of 0-255.\n@param g the green color value in the range of 0-255.\n@param b the blue color value in the range of 0-255.\n@param a the alpha value in the range of 0-255.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TextBase.GetColor\n@sa TextBase.SetColor",
                "name": "SetColor",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "c",
                    "type": "Color"
                  }
                ],
                "sourceName": "TTF_SetTextColor",
                "static": false
              },
              {
                "doc": "Set the color of a text object.\n\nThe default text color is white (1.0f, 1.0f, 1.0f, 1.0f).\n\n@param text the TextBase to modify.\n@param r the red color value, normally in the range of 0-1.\n@param g the green color value, normally in the range of 0-1.\n@param b the blue color value, normally in the range of 0-1.\n@param a the alpha value in the range of 0-1.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TextBase.GetColor\n@sa TextBase.SetColor",
                "name": "SetColor",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "c",
                    "type": "FColor"
                  }
                ],
                "sourceName": "TTF_SetTextColorFloat",
                "static": false
              }
            ],
            "GetColor": [
              {
                "kind": "function",
                "type": "std::optional<FColor>",
                "immutable": true,
                "parameters": [],
                "name": "GetColor",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "bool",
                "immutable": true,
                "parameters": [
                  {
                    "type": "Color *",
                    "name": "c"
                  }
                ],
                "name": "GetColor",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "bool",
                "immutable": true,
                "parameters": [
                  {
                    "type": "FColor *",
                    "name": "c"
                  }
                ],
                "name": "GetColor",
                "doc": ""
              },
              {
                "doc": "Get the color of a text object.\n\n@param r a pointer filled in with the red color value in the range of\n         0-255, may be nullptr.\n@param g a pointer filled in with the green color value in the range of\n         0-255, may be nullptr.\n@param b a pointer filled in with the blue color value in the range of\n         0-255, may be nullptr.\n@param a a pointer filled in with the alpha value in the range of 0-255,\n         may be nullptr.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TextBase.GetColor\n@sa TextBase.SetColor",
                "name": "GetColor",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "r",
                    "type": "Uint8 *"
                  },
                  {
                    "name": "g",
                    "type": "Uint8 *"
                  },
                  {
                    "name": "b",
                    "type": "Uint8 *"
                  },
                  {
                    "name": "a",
                    "type": "Uint8 *"
                  }
                ],
                "sourceName": "TTF_GetTextColor",
                "immutable": true
              },
              {
                "doc": "Get the color of a text object.\n\n@param r a pointer filled in with the red color value, normally in the\n         range of 0-1, may be nullptr.\n@param g a pointer filled in with the green color value, normally in the\n         range of 0-1, may be nullptr.\n@param b a pointer filled in with the blue color value, normally in the\n         range of 0-1, may be nullptr.\n@param a a pointer filled in with the alpha value in the range of 0-1, may\n         be nullptr.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TextBase.GetColor\n@sa TextBase.SetColor",
                "name": "GetColor",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "r",
                    "type": "float *"
                  },
                  {
                    "name": "g",
                    "type": "float *"
                  },
                  {
                    "name": "b",
                    "type": "float *"
                  },
                  {
                    "name": "a",
                    "type": "float *"
                  }
                ],
                "sourceName": "TTF_GetTextColorFloat",
                "immutable": true
              }
            ],
            "SetPosition": {
              "doc": "Set the position of a text object.\n\nThis can be used to position multiple text objects within a single wrapping\ntext area.\n\nThis function may cause the internal text representation to be rebuilt.\n\n@param text the TextBase to modify.\n@param x the x offset of the upper left corner of this text in pixels.\n@param y the y offset of the upper left corner of this text in pixels.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TextBase.GetPosition",
              "name": "SetPosition",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "p",
                  "type": "Point"
                }
              ],
              "sourceName": "TTF_SetTextPosition",
              "static": false
            },
            "GetPosition": [
              {
                "kind": "function",
                "immutable": true,
                "type": "std::optional<Point>",
                "parameters": [],
                "name": "GetPosition",
                "doc": ""
              },
              {
                "doc": "Get the position of a text object.\n\n@param x a pointer filled in with the x offset of the upper left corner of\n         this text in pixels, may be nullptr.\n@param y a pointer filled in with the y offset of the upper left corner of\n         this text in pixels, may be nullptr.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TextBase.SetPosition",
                "name": "GetPosition",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "x",
                    "type": "int *"
                  },
                  {
                    "name": "y",
                    "type": "int *"
                  }
                ],
                "sourceName": "TTF_GetTextPosition",
                "immutable": true
              }
            ],
            "SetWrapWidth": {
              "doc": "Set whether wrapping is enabled on a text object.\n\nThis function may cause the internal text representation to be rebuilt.\n\n@param wrap_width the maximum width in pixels, 0 to wrap on newline\n                  characters.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TextBase.GetWrapWidth",
              "name": "SetWrapWidth",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "wrap_width",
                  "type": "int"
                }
              ],
              "sourceName": "TTF_SetTextWrapWidth"
            },
            "GetWrapWidth": {
              "doc": "Get whether wrapping is enabled on a text object.\n\n@param text the TextBase to query.\n@param wrap_width a pointer filled in with the maximum width in pixels or 0\n                  if the text is being wrapped on newline characters.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TextBase.SetWrapWidth",
              "name": "GetWrapWidth",
              "kind": "function",
              "type": "std::optional<int>",
              "parameters": [],
              "sourceName": "TTF_GetTextWrapWidth",
              "immutable": true
            },
            "SetWrapWhitespaceVisible": {
              "doc": "Set whether whitespace should be visible when wrapping a text object.\n\nIf the whitespace is visible, it will take up space for purposes of\nalignment and wrapping. This is good for editing, but looks better when\ncentered or aligned if whitespace around line wrapping is hidden. This\ndefaults false.\n\nThis function may cause the internal text representation to be rebuilt.\n\n@param visible true to show whitespace when wrapping text, false to hide\n               it.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TextBase.IsWrapWhitespaceVisible",
              "name": "SetWrapWhitespaceVisible",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "visible",
                  "type": "bool"
                }
              ],
              "sourceName": "TTF_SetTextWrapWhitespaceVisible"
            },
            "IsWrapWhitespaceVisible": {
              "doc": "Return whether whitespace is shown when wrapping a text object.\n\n@returns true if whitespace is shown when wrapping text, or false\n         otherwise.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TextBase.SetWrapWhitespaceVisible",
              "name": "IsWrapWhitespaceVisible",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "TTF_TextWrapWhitespaceVisible",
              "immutable": true
            },
            "SetString": {
              "doc": "Set the UTF-8 text used by a text object.\n\nThis function may cause the internal text representation to be rebuilt.\n\n@param text the TextBase to modify.\n@param string the UTF-8 text to use, may be nullptr.\n@param length the length of the text, in bytes, or 0 for null terminated\n              text.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TextBase.AppendString\n@sa TextBase.DeleteString\n@sa TextBase.InsertString",
              "name": "SetString",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "string",
                  "type": "std::string_view"
                }
              ],
              "sourceName": "TTF_SetTextString",
              "static": false
            },
            "InsertString": {
              "doc": "Insert UTF-8 text into a text object.\n\nThis function may cause the internal text representation to be rebuilt.\n\n@param text the TextBase to modify.\n@param offset the offset, in bytes, from the beginning of the string if >=\n              0, the offset from the end of the string if < 0. Note that\n              this does not do UTF-8 validation, so you should only insert\n              at UTF-8 sequence boundaries.\n@param string the UTF-8 text to insert.\n@param length the length of the text, in bytes, or 0 for null terminated\n              text.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TextBase.AppendString\n@sa TextBase.DeleteString\n@sa TextBase.SetString",
              "name": "InsertString",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "offset",
                  "type": "int"
                },
                {
                  "name": "string",
                  "type": "std::string_view"
                }
              ],
              "sourceName": "TTF_InsertTextString",
              "static": false
            },
            "AppendString": {
              "doc": "Append UTF-8 text to a text object.\n\nThis function may cause the internal text representation to be rebuilt.\n\n@param text the TextBase to modify.\n@param string the UTF-8 text to insert.\n@param length the length of the text, in bytes, or 0 for null terminated\n              text.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TextBase.DeleteString\n@sa TextBase.InsertString\n@sa TextBase.SetString",
              "name": "AppendString",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "string",
                  "type": "std::string_view"
                }
              ],
              "sourceName": "TTF_AppendTextString",
              "static": false
            },
            "DeleteString": {
              "doc": "Delete UTF-8 text from a text object.\n\nThis function may cause the internal text representation to be rebuilt.\n\n@param offset the offset, in bytes, from the beginning of the string if >=\n              0, the offset from the end of the string if < 0. Note that\n              this does not do UTF-8 validation, so you should only delete\n              at UTF-8 sequence boundaries.\n@param length the length of text to delete, in bytes, or -1 for the\n              remainder of the string.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TextBase.AppendString\n@sa TextBase.InsertString\n@sa TextBase.SetString",
              "name": "DeleteString",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "offset",
                  "type": "int"
                },
                {
                  "name": "length",
                  "type": "int"
                }
              ],
              "sourceName": "TTF_DeleteTextString"
            },
            "GetSize": [
              {
                "kind": "function",
                "type": "std::optional<Point>",
                "immutable": true,
                "parameters": [],
                "name": "GetSize",
                "doc": ""
              },
              {
                "doc": "Get the size of a text object.\n\nThe size of the text may change when the font or font style and size\nchange.\n\n@param w a pointer filled in with the width of the text, in pixels, may be\n         nullptr.\n@param h a pointer filled in with the height of the text, in pixels, may be\n         nullptr.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.",
                "name": "GetSize",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "w",
                    "type": "int *"
                  },
                  {
                    "name": "h",
                    "type": "int *"
                  }
                ],
                "sourceName": "TTF_GetTextSize",
                "immutable": true
              }
            ],
            "GetSubString": {
              "doc": "Get the substring of a text object that surrounds a text offset.\n\nIf `offset` is less than 0, this will return a zero length substring at the\nbeginning of the text with the SUBSTRING_TEXT_START flag set. If\n`offset` is greater than or equal to the length of the text string, this\nwill return a zero length substring at the end of the text with the\nSUBSTRING_TEXT_END flag set.\n\n@param offset a byte offset into the text string.\n@param substring a pointer filled in with the substring containing the\n                 offset.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "GetSubString",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "offset",
                  "type": "int"
                },
                {
                  "name": "substring",
                  "type": "SubString *"
                }
              ],
              "sourceName": "TTF_GetTextSubString",
              "immutable": true
            },
            "begin": {
              "kind": "function",
              "type": "SubStringIterator",
              "immutable": true,
              "parameters": [],
              "name": "begin",
              "doc": ""
            },
            "end": {
              "kind": "function",
              "type": "SubStringIterator",
              "immutable": true,
              "parameters": [],
              "name": "end",
              "doc": ""
            },
            "GetSubStringForLine": [
              {
                "kind": "function",
                "type": "SubStringIterator",
                "immutable": true,
                "parameters": [
                  {
                    "type": "int",
                    "name": "line"
                  }
                ],
                "name": "GetSubStringForLine",
                "doc": ""
              },
              {
                "doc": "Get the substring of a text object that contains the given line.\n\nIf `line` is less than 0, this will return a zero length substring at the\nbeginning of the text with the SUBSTRING_TEXT_START flag set. If `line`\nis greater than or equal to `text->num_lines` this will return a zero\nlength substring at the end of the text with the SUBSTRING_TEXT_END\nflag set.\n\n@param line a zero-based line index, in the range [0 .. text->num_lines-1].\n@param substring a pointer filled in with the substring containing the\n                 offset.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.",
                "name": "GetSubStringForLine",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "line",
                    "type": "int"
                  },
                  {
                    "name": "substring",
                    "type": "SubString *"
                  }
                ],
                "sourceName": "TTF_GetTextSubStringForLine",
                "immutable": true
              }
            ],
            "GetSubStrings": {
              "kind": "function",
              "immutable": true,
              "type": "OwnArray<SubString *>",
              "parameters": [],
              "name": "GetSubStrings",
              "doc": ""
            },
            "GetSubStringsForRange": {
              "doc": "Get the substrings of a text object that contain a range of text.\n\n@param offset a byte offset into the text string.\n@param length the length of the range being queried, in bytes, or -1 for\n              the remainder of the string.\n@param count a pointer filled in with the number of substrings returned,\n             may be nullptr.\n@returns a nullptr terminated array of substring pointers or nullptr on failure;\n         call GetError() for more information. This is a single\n         allocation that should be freed with free() when it is no\n         longer needed.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "GetSubStringsForRange",
              "kind": "function",
              "type": "OwnArray<SubString *>",
              "parameters": [
                {
                  "name": "offset",
                  "type": "int"
                },
                {
                  "name": "length",
                  "type": "int"
                }
              ],
              "sourceName": "TTF_GetTextSubStringsForRange",
              "immutable": true
            },
            "GetSubStringForPoint": [
              {
                "kind": "function",
                "immutable": true,
                "type": "SubStringIterator",
                "parameters": [
                  {
                    "type": "Point",
                    "name": "p"
                  }
                ],
                "name": "GetSubStringForPoint",
                "doc": ""
              },
              {
                "doc": "Get the portion of a text string that is closest to a point.\n\nThis will return the closest substring of text to the given point.\n\n@param text the TextBase to query.\n@param x the x coordinate relative to the left side of the text, may be\n         outside the bounds of the text area.\n@param y the y coordinate relative to the top side of the text, may be\n         outside the bounds of the text area.\n@param substring a pointer filled in with the closest substring of text to\n                 the given point.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.",
                "name": "GetSubStringForPoint",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "p",
                    "type": "Point"
                  },
                  {
                    "name": "substring",
                    "type": "SubString *"
                  }
                ],
                "sourceName": "TTF_GetTextSubStringForPoint",
                "immutable": true,
                "static": false
              }
            ],
            "GetPreviousSubString": {
              "doc": "Get the previous substring in a text object\n\nIf called at the start of the text, this will return a zero length\nsubstring with the SUBSTRING_TEXT_START flag set.\n\n@param substring the SubString to query.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "GetPreviousSubString",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "substring",
                  "type": "const SubString *"
                },
                {
                  "name": "previous",
                  "type": "SubString *"
                }
              ],
              "sourceName": "TTF_GetPreviousTextSubString",
              "immutable": true
            },
            "GetNextSubString": {
              "doc": "Get the next substring in a text object\n\nIf called at the end of the text, this will return a zero length substring\nwith the SUBSTRING_TEXT_END flag set.\n\n@param substring the SubString to query.\n@param next a pointer filled in with the next substring.\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "GetNextSubString",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "substring",
                  "type": "const SubString *"
                },
                {
                  "name": "next",
                  "type": "SubString *"
                }
              ],
              "sourceName": "TTF_GetNextTextSubString",
              "immutable": true
            },
            "Update": {
              "doc": "Update the layout of a text object.\n\nThis is automatically done when the layout is requested or the text is\nrendered, but you can call this if you need more control over the timing of\nwhen the layout and text engine representation are updated.\n\n@returns true on success or false on failure; call GetError() for more\n         information.\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.",
              "name": "Update",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "TTF_UpdateText"
            },
            "GetText": {
              "kind": "function",
              "type": "const char *",
              "immutable": true,
              "doc": "A copy of the UTF-8 string that this text object represents, useful for layout, debugging and retrieving substring text",
              "parameters": [],
              "name": "GetText"
            },
            "GetNumLines": {
              "kind": "function",
              "type": "int",
              "immutable": true,
              "doc": "The number of lines in the text, 0 if it's empty",
              "parameters": [],
              "name": "GetNumLines"
            },
            "Destroy": {
              "doc": "Destroy a text object created by a text engine.\n\n\n@threadsafety This function should be called on the thread that created the\n              text.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TextBase.TextBase",
              "name": "Destroy",
              "kind": "function",
              "type": "void",
              "parameters": [],
              "sourceName": "TTF_DestroyText"
            }
          }
        },
        "ObjectRef<TTF_Text>::doFree": {
          "name": "ObjectRef<TTF_Text>::doFree",
          "type": "void",
          "kind": "function",
          "doc": "Callback for text resource cleanup\n\n@private",
          "template": [],
          "parameters": [
            {
              "type": "TTF_Text *",
              "name": "resource"
            }
          ],
          "sourceName": "TTF_DestroyText"
        },
        "SubStringIterator": {
          "name": "SubStringIterator",
          "kind": "struct",
          "entries": {
            "m_text": {
              "kind": "var",
              "type": "TextRef",
              "name": "m_text",
              "doc": ""
            },
            "m_subString": {
              "kind": "var",
              "type": "SubString",
              "name": "m_subString",
              "doc": ""
            },
            "SubStringIterator": [
              {
                "kind": "function",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "name": "text",
                    "type": "TextRef"
                  }
                ],
                "name": "SubStringIterator",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "",
                "constexpr": true,
                "parameters": [],
                "name": "SubStringIterator",
                "doc": ""
              }
            ],
            "operator bool": {
              "kind": "function",
              "type": "",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "name": "operator bool",
              "doc": ""
            },
            "operator*": {
              "kind": "function",
              "type": "const SubString &",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "name": "operator*",
              "doc": ""
            },
            "operator->": {
              "kind": "function",
              "type": "const SubString *",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "name": "operator->",
              "doc": ""
            },
            "operator==": {
              "kind": "function",
              "type": "bool",
              "constexpr": true,
              "immutable": true,
              "parameters": [
                {
                  "name": "other",
                  "type": "const SubStringIterator &"
                }
              ],
              "name": "operator==",
              "doc": ""
            },
            "operator++": [
              {
                "kind": "function",
                "type": "SubStringIterator &",
                "constexpr": true,
                "parameters": [],
                "name": "operator++",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "SubStringIterator",
                "constexpr": true,
                "parameters": [
                  "int"
                ],
                "name": "operator++",
                "doc": ""
              }
            ],
            "operator--": [
              {
                "kind": "function",
                "type": "SubStringIterator &",
                "constexpr": true,
                "parameters": [],
                "name": "operator--",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "SubStringIterator",
                "constexpr": true,
                "parameters": [
                  "int"
                ],
                "name": "operator--",
                "doc": ""
              }
            ]
          },
          "doc": ""
        },
        "CreateSurfaceTextEngine": {
          "doc": "Create a text engine for drawing text on SDL surfaces.\n\n@returns a TextEngineBase object or nullptr on failure; call GetError()\n         for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TTF_DestroySurfaceTextEngine\n@sa TextBase.DrawSurface",
          "name": "CreateSurfaceTextEngine",
          "kind": "function",
          "type": "TextEngine",
          "parameters": [],
          "sourceName": "TTF_CreateSurfaceTextEngine"
        },
        "CreateRendererTextEngine": {
          "doc": "Create a text engine for drawing text on an SDL renderer.\n\n@param renderer the renderer to use for creating textures and drawing text.\n@returns a TextEngineBase object or nullptr on failure; call GetError()\n         for more information.\n\n@threadsafety This function should be called on the thread that created the\n              renderer.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa TTF_DestroyRendererTextEngine\n@sa TextBase.DrawRenderer\n@sa CreateRendererTextEngineWithProperties",
          "name": "CreateRendererTextEngine",
          "kind": "function",
          "type": "TextEngine",
          "parameters": [
            {
              "name": "renderer",
              "type": "RendererRef"
            }
          ],
          "sourceName": "TTF_CreateRendererTextEngine"
        },
        "CreateRendererTextEngineWithProperties": {
          "doc": "Create a text engine for drawing text on an SDL renderer, with the\nspecified properties.\n\nThese are the supported properties:\n\n- `TTF_PROP_RENDERER_TEXT_ENGINE_RENDERER`: the renderer to use for\n  creating textures and drawing text\n- `prop::RendererTextEngine.ATLAS_TEXTURE_SIZE`: the size of the\n  texture atlas\n\n@param props the properties to use.\n@returns a TextEngineBase object or nullptr on failure; call GetError()\n         for more information.\n\n@threadsafety This function should be called on the thread that created the\n              renderer.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa CreateRendererTextEngine\n@sa TTF_DestroyRendererTextEngine\n@sa TextBase.DrawRenderer",
          "name": "CreateRendererTextEngineWithProperties",
          "kind": "function",
          "type": "TextEngine",
          "parameters": [
            {
              "name": "props",
              "type": "PropertiesRef"
            }
          ],
          "sourceName": "TTF_CreateRendererTextEngineWithProperties"
        },
        "prop::RendererTextEngine": {
          "kind": "ns",
          "name": "prop::RendererTextEngine",
          "entries": {
            "RENDERER": {
              "doc": "",
              "name": "RENDERER",
              "kind": "var",
              "value": "\"SDL_ttf.renderer_text_engine.create.renderer\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "TTF_PROP_RENDERER_TEXT_ENGINE_RENDERER"
            },
            "ATLAS_TEXTURE_SIZE": {
              "doc": "",
              "name": "ATLAS_TEXTURE_SIZE",
              "kind": "var",
              "value": "\"SDL_ttf.renderer_text_engine.create.atlas_texture_size\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "TTF_PROP_RENDERER_TEXT_ENGINE_ATLAS_TEXTURE_SIZE"
            }
          },
          "doc": ""
        },
        "CreateGPUTextEngine": {
          "doc": "Create a text engine for drawing text with the SDL GPU API.\n\n@param device the SDL_GPUDevice to use for creating textures and drawing\n              text.\n@returns a TextEngineBase object or nullptr on failure; call GetError()\n         for more information.\n\n@threadsafety This function should be called on the thread that created the\n              device.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa CreateGPUTextEngineWithProperties\n@sa TTF_DestroyGPUTextEngine\n@sa TextBase.GetGPUDrawData",
          "name": "CreateGPUTextEngine",
          "kind": "function",
          "type": "TextEngine",
          "parameters": [
            {
              "name": "device",
              "type": "SDL_GPUDevice *"
            }
          ],
          "sourceName": "TTF_CreateGPUTextEngine"
        },
        "CreateGPUTextEngineWithProperties": {
          "doc": "Create a text engine for drawing text with the SDL GPU API, with the\nspecified properties.\n\nThese are the supported properties:\n\n- `TTF_PROP_GPU_TEXT_ENGINE_DEVICE`: the SDL_GPUDevice to use for creating\n  textures and drawing text.\n- `prop::GpuTextEngine.ATLAS_TEXTURE_SIZE`: the size of the texture\n  atlas\n\n@param props the properties to use.\n@returns a TextEngineBase object or nullptr on failure; call GetError()\n         for more information.\n\n@threadsafety This function should be called on the thread that created the\n              device.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa CreateGPUTextEngine\n@sa TTF_DestroyGPUTextEngine\n@sa TextBase.GetGPUDrawData",
          "name": "CreateGPUTextEngineWithProperties",
          "kind": "function",
          "type": "TextEngine",
          "parameters": [
            {
              "name": "props",
              "type": "PropertiesRef"
            }
          ],
          "sourceName": "TTF_CreateGPUTextEngineWithProperties"
        },
        "prop::GpuTextEngine": {
          "kind": "ns",
          "name": "prop::GpuTextEngine",
          "entries": {
            "DEVICE": {
              "doc": "",
              "name": "DEVICE",
              "kind": "var",
              "value": "\"SDL_ttf.gpu_text_engine.create.device\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "TTF_PROP_GPU_TEXT_ENGINE_DEVICE"
            },
            "ATLAS_TEXTURE_SIZE": {
              "doc": "",
              "name": "ATLAS_TEXTURE_SIZE",
              "kind": "var",
              "value": "\"SDL_ttf.gpu_text_engine.create.atlas_texture_size\"",
              "type": "auto",
              "constexpr": true,
              "sourceName": "TTF_PROP_GPU_TEXT_ENGINE_ATLAS_TEXTURE_SIZE"
            }
          },
          "doc": ""
        },
        "QuitSubSystem": {
          "doc": "Deinitialize SDL_ttf.\n\nYou must call this when done with the library, to free internal resources.\nIt is safe to call this when the library isn't initialized, as it will just\nreturn immediately.\n\nOnce you have as many quit calls as you have had successful calls to\nInitSubSystem, the library will actually deinitialize.\n\nPlease note that this does not automatically close any fonts that are still\nopen at the time of deinitialization, and it is possibly not safe to close\nthem afterwards, as parts of the library will no longer be initialized to\ndeal with it. A well-written program should call FontBase.Close() on any\nopen fonts before calling this function!\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.",
          "name": "QuitSubSystem",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "type": "TtfInitFlag",
              "name": "_"
            }
          ],
          "sourceName": "TTF_Quit"
        },
        "WasInit": {
          "doc": "Check if SDL_ttf is initialized.\n\nThis reports the number of times the library has been initialized by a call\nto InitSubSystem(), without a paired deinitialization request from QuitSubSystem().\n\nIn short: if it's greater than zero, the library is currently initialized\nand ready to work. If zero, it is not initialized.\n\nDespite the return value being a signed integer, this function should not\nreturn a negative number.\n\n@returns the current number of initialization calls, that need to\n         eventually be paired with this many calls to QuitSubSystem().\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL_ttf 3.0.0.\n\n@sa InitSubSystem\n@sa QuitSubSystem",
          "name": "WasInit",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "type": "TtfInitFlag",
              "name": "_"
            }
          ],
          "sourceName": "TTF_WasInit"
        }
      }
    }
  }
}
