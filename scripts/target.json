{
  "files": {
    "SDL3pp_properties.h": {
      "name": "SDL3pp_properties.h",
      "doc": "@defgroup CategoryProperties Category Properties\n\nA property is a variable that can be created and retrieved by name at\nruntime.\n\nAll properties are part of a property group (Properties). A property\ngroup can be created with the Properties.Create function and destroyed\nwith the Properties.Destroy function.\n\nProperties can be added to and retrieved from a property group through the\nfollowing functions:\n\n- SetPointerProperty and GetPointerProperty operate on `void*`\n  pointer types.\n- SetStringProperty and GetStringProperty operate on string types.\n- SetNumberProperty and GetNumberProperty operate on signed 64-bit\n  integer types.\n- SetFloatProperty and GetFloatProperty operate on floating point\n  types.\n- SetBooleanProperty and GetBooleanProperty operate on boolean\n  types.\n\nProperties can be removed from a group by using ClearProperty.",
      "entries": {
        "Properties-forward": {
          "name": "Properties",
          "kind": "forward",
          "doc": ""
        },
        "PropertiesID": {
          "name": "PropertiesID",
          "kind": "alias",
          "type": "SDL_PropertiesID",
          "doc": ""
        },
        "PropertiesParam": {
          "name": "PropertiesParam",
          "kind": "struct",
          "doc": "Safely wrap Properties for non owning parameters",
          "entries": {
            "value": {
              "kind": "var",
              "name": "value",
              "type": "PropertiesID",
              "doc": ""
            },
            "PropertiesParam": [
              {
                "kind": "function",
                "name": "PropertiesParam",
                "constexpr": true,
                "type": "",
                "parameters": [
                  {
                    "type": "PropertiesID",
                    "name": "value"
                  }
                ],
                "hints": {
                  "init": [
                    "value(value)"
                  ]
                },
                "doc": ""
              },
              {
                "kind": "function",
                "name": "PropertiesParam",
                "constexpr": true,
                "type": "",
                "parameters": [
                  {
                    "type": "std::nullptr_t",
                    "name": "_"
                  }
                ],
                "hints": {
                  "init": [
                    "value(0)"
                  ]
                },
                "doc": ""
              }
            ],
            "operator PropertiesID": {
              "kind": "function",
              "name": "operator PropertiesID",
              "constexpr": true,
              "immutable": true,
              "type": "",
              "parameters": [],
              "hints": {
                "body": "return value;"
              },
              "doc": ""
            }
          }
        },
        "Properties": {
          "doc": "SDL properties ID\n\n@since This datatype is available since SDL 3.2.0.\n\n@cat resource",
          "name": "Properties",
          "kind": "struct",
          "type": "",
          "sourceName": "SDL_PropertiesID",
          "entries": {
            "m_resource": {
              "kind": "var",
              "type": "PropertiesID",
              "hints": {
                "body": "0"
              },
              "name": "m_resource",
              "doc": ""
            },
            "Properties": [
              {
                "kind": "function",
                "type": "",
                "constexpr": true,
                "parameters": [],
                "hints": {
                  "default": true,
                  "changeAccess": "public"
                },
                "name": "Properties",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "",
                "constexpr": true,
                "explicit": true,
                "parameters": [
                  {
                    "name": "resource",
                    "type": "const PropertiesID"
                  }
                ],
                "hints": {
                  "init": [
                    "m_resource(resource)"
                  ]
                },
                "name": "Properties",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "other",
                    "type": "const Properties &"
                  }
                ],
                "hints": {},
                "name": "Properties",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "name": "other",
                    "type": "Properties &&"
                  }
                ],
                "hints": {
                  "init": [
                    "m_resource(other.m_resource)"
                  ],
                  "body": "other.m_resource = 0;"
                },
                "name": "Properties",
                "doc": ""
              }
            ],
            "Create": {
              "doc": "Create a group of properties.\n\nAll properties are automatically destroyed when SDL_Quit() is called.\n\n@returns an ID for a new group of properties, or 0 on failure; call\n         GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Properties.Destroy",
              "name": "Create",
              "kind": "function",
              "type": "Properties",
              "parameters": [],
              "sourceName": "SDL_CreateProperties",
              "static": true,
              "hints": {
                "wrapSelf": true
              }
            },
            "~Properties": {
              "kind": "function",
              "type": "",
              "parameters": [],
              "hints": {
                "body": "SDL_DestroyProperties(m_resource);"
              },
              "name": "~Properties",
              "doc": ""
            },
            "operator=": {
              "kind": "function",
              "type": "Properties &",
              "parameters": [
                {
                  "name": "other",
                  "type": "Properties"
                }
              ],
              "hints": {
                "body": "std::swap(m_resource, other.m_resource);\nreturn *this;"
              },
              "name": "operator=",
              "doc": ""
            },
            "get": {
              "kind": "function",
              "type": "PropertiesID",
              "immutable": true,
              "constexpr": true,
              "parameters": [],
              "hints": {
                "body": "return m_resource;"
              },
              "name": "get",
              "doc": ""
            },
            "release": {
              "kind": "function",
              "type": "PropertiesID",
              "constexpr": true,
              "parameters": [],
              "hints": {
                "body": "auto r = m_resource;\nm_resource = 0;\nreturn r;"
              },
              "name": "release",
              "doc": ""
            },
            "operator PropertiesParam": {
              "kind": "function",
              "type": "",
              "immutable": true,
              "constexpr": true,
              "parameters": [],
              "hints": {
                "body": "return {m_resource};"
              },
              "name": "operator PropertiesParam",
              "doc": ""
            },
            "Destroy": {
              "doc": "Destroy a group of properties.\n\nAll properties are deleted and their cleanup functions will be called, if\nany.\n\n\n@threadsafety This function should not be called while these properties are\n              locked or other threads might be setting or getting values\n              from these properties.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Properties.Create",
              "name": "Destroy",
              "kind": "function",
              "type": "void",
              "parameters": [],
              "sourceName": "SDL_DestroyProperties",
              "hints": {
                "body": "SDL_DestroyProperties(m_resource);\nm_resource = 0;"
              }
            }
          },
          "hints": {
            "self": "m_resource",
            "super": "m_resource",
            "private": true
          }
        },
        "PropertyType": {
          "doc": "SDL property type\n\n@since This enum is available since SDL 3.2.0.",
          "name": "PropertyType",
          "kind": "alias",
          "sourceName": "SDL_PropertyType",
          "type": "SDL_PropertyType"
        },
        "PROPERTY_TYPE_INVALID": {
          "kind": "var",
          "name": "PROPERTY_TYPE_INVALID",
          "constexpr": true,
          "type": "PropertyType",
          "doc": "INVALID",
          "sourceName": "SDL_PROPERTY_TYPE_INVALID"
        },
        "PROPERTY_TYPE_POINTER": {
          "kind": "var",
          "name": "PROPERTY_TYPE_POINTER",
          "constexpr": true,
          "type": "PropertyType",
          "doc": "POINTER",
          "sourceName": "SDL_PROPERTY_TYPE_POINTER"
        },
        "PROPERTY_TYPE_STRING": {
          "kind": "var",
          "name": "PROPERTY_TYPE_STRING",
          "constexpr": true,
          "type": "PropertyType",
          "doc": "STRING",
          "sourceName": "SDL_PROPERTY_TYPE_STRING"
        },
        "PROPERTY_TYPE_NUMBER": {
          "kind": "var",
          "name": "PROPERTY_TYPE_NUMBER",
          "constexpr": true,
          "type": "PropertyType",
          "doc": "NUMBER",
          "sourceName": "SDL_PROPERTY_TYPE_NUMBER"
        },
        "PROPERTY_TYPE_FLOAT": {
          "kind": "var",
          "name": "PROPERTY_TYPE_FLOAT",
          "constexpr": true,
          "type": "PropertyType",
          "doc": "FLOAT",
          "sourceName": "SDL_PROPERTY_TYPE_FLOAT"
        },
        "PROPERTY_TYPE_BOOLEAN": {
          "kind": "var",
          "name": "PROPERTY_TYPE_BOOLEAN",
          "constexpr": true,
          "type": "PropertyType",
          "doc": "BOOLEAN",
          "sourceName": "SDL_PROPERTY_TYPE_BOOLEAN"
        },
        "GetGlobalProperties": {
          "doc": "Get the global SDL properties.\n\n@returns a valid property ID on success.\n@throws Error on failure.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetGlobalProperties",
          "kind": "function",
          "type": "PropertiesID",
          "parameters": [],
          "sourceName": "SDL_GetGlobalProperties",
          "hints": {
            "mayFail": true
          }
        },
        "CreateProperties": {
          "doc": "Create a group of properties.\n\nAll properties are automatically destroyed when SDL_Quit() is called.\n\n@returns an ID for a new group of properties, or 0 on failure; call\n         GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Properties.Destroy",
          "name": "CreateProperties",
          "kind": "function",
          "type": "Properties",
          "parameters": [],
          "sourceName": "SDL_CreateProperties",
          "hints": {
            "wrapSelf": true
          }
        },
        "CopyProperties": {
          "doc": "Copy a group of properties.\n\nCopy all the properties from one group of properties to another, with the\nexception of properties requiring cleanup (set using\nSetPointerPropertyWithCleanup()), which will not be copied. Any\nproperty that already exists on `dst` will be overwritten.\n\n@param src the properties to copy.\n@param dst the destination properties.\n@throws Error on failure.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "CopyProperties",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "src",
              "type": "PropertiesParam"
            },
            {
              "name": "dst",
              "type": "PropertiesParam"
            }
          ],
          "sourceName": "SDL_CopyProperties",
          "hints": {
            "mayFail": true
          }
        },
        "LockProperties": {
          "doc": "Lock a group of properties.\n\nObtain a multi-threaded lock for these properties. Other threads will wait\nwhile trying to lock these properties until they are unlocked. Properties\nmust be unlocked before they are destroyed.\n\nThe lock is automatically taken when setting individual properties, this\nfunction is only needed when you want to set several properties atomically\nor want to guarantee that properties being queried aren't freed in another\nthread.\n\n@param props the properties to lock.\n@throws Error on failure.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa UnlockProperties",
          "name": "LockProperties",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "props",
              "type": "PropertiesParam"
            }
          ],
          "sourceName": "SDL_LockProperties",
          "hints": {
            "mayFail": true
          }
        },
        "UnlockProperties": {
          "doc": "Unlock a group of properties.\n\n@param props the properties to unlock.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa LockProperties",
          "name": "UnlockProperties",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "props",
              "type": "PropertiesParam"
            }
          ],
          "sourceName": "SDL_UnlockProperties"
        },
        "CleanupPropertyCallback": {
          "doc": "A callback used to free resources when a property is deleted.\n\nThis should release any resources associated with `value` that are no\nlonger needed.\n\nThis callback is set per-property. Different properties in the same group\ncan have different cleanup callbacks.\n\nThis callback will be called _during_ SetPointerPropertyWithCleanup if\nthe function fails for any reason.\n\n@param userdata an app-defined pointer passed to the callback.\n@param value the pointer assigned to the property to clean up.\n\n@threadsafety This callback may fire without any locks held; if this is a\n              concern, the app should provide its own locking.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa SetPointerPropertyWithCleanup",
          "name": "CleanupPropertyCallback",
          "kind": "alias",
          "type": "SDL_CleanupPropertyCallback",
          "sourceName": "SDL_CleanupPropertyCallback"
        },
        "CleanupPropertyCB": {
          "kind": "alias",
          "name": "CleanupPropertyCB",
          "type": "std::function<void(void *)>",
          "doc": "A callback used to free resources when a property is deleted.\n\nThis should release any resources associated with `value` that are no\nlonger needed.\n\nThis callback is set per-property. Different properties in the same group\ncan have different cleanup callbacks.\n\nThis callback will be called _during_ SetPointerPropertyWithCleanup if\nthe function fails for any reason.\n\n@param userdata an app-defined pointer passed to the callback.\n@param value the pointer assigned to the property to clean up.\n\n@threadsafety This callback may fire without any locks held; if this is a\n              concern, the app should provide its own locking.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa SetPointerPropertyWithCleanup\n@sa CleanupPropertyCallback"
        },
        "SetPointerPropertyWithCleanup": [
          {
            "doc": "Set a pointer property in a group of properties with a cleanup function\nthat is called when the property is deleted.\n\nThe cleanup function is also called if setting the property fails for any\nreason.\n\nFor simply setting basic data types, like numbers, bools, or strings, use\nSetNumberProperty, SetBooleanProperty, or SetStringProperty\ninstead, as those functions will handle cleanup on your behalf. This\nfunction is only for more complex, custom data.\n\n@param props the properties to modify.\n@param name the name of the property to modify.\n@param value the new value of the property, or nullptr to delete the property.\n@param cleanup the function to call when this property is deleted, or nullptr\n               if no cleanup is necessary.\n@param userdata a pointer that is passed to the cleanup function.\n@throws Error on failure.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetPointerProperty\n@sa SetPointerProperty\n@sa CleanupPropertyCallback",
            "name": "SetPointerPropertyWithCleanup",
            "kind": "function",
            "type": "void",
            "parameters": [
              {
                "name": "props",
                "type": "PropertiesParam"
              },
              {
                "name": "name",
                "type": "StringParam"
              },
              {
                "name": "value",
                "type": "void *"
              },
              {
                "name": "cleanup",
                "type": "CleanupPropertyCallback"
              },
              {
                "name": "userdata",
                "type": "void *"
              }
            ],
            "sourceName": "SDL_SetPointerPropertyWithCleanup",
            "hints": {
              "mayFail": true
            }
          },
          {
            "kind": "function",
            "static": false,
            "type": "void",
            "after": "SDL_SetPointerPropertyWithCleanup",
            "parameters": [
              {
                "type": "PropertiesParam",
                "name": "props"
              },
              {
                "type": "StringParam",
                "name": "name"
              },
              {
                "type": "void *",
                "name": "value"
              },
              {
                "type": "CleanupPropertyCB",
                "name": "cleanup"
              }
            ],
            "name": "SetPointerPropertyWithCleanup",
            "doc": "Set a pointer property in a group of properties with a cleanup function\nthat is called when the property is deleted.\n\nThe cleanup function is also called if setting the property fails for any\nreason.\n\nFor simply setting basic data types, like numbers, bools, or strings, use\nSetNumberProperty, SetBooleanProperty, or SetStringProperty\ninstead, as those functions will handle cleanup on your behalf. This\nfunction is only for more complex, custom data.\n\n@param props the properties to modify.\n@param name the name of the property to modify.\n@param value the new value of the property, or nullptr to delete the property.\n@param cleanup the function to call when this property is deleted, or nullptr\n               if no cleanup is necessary.\n@param userdata a pointer that is passed to the cleanup function.\n@throws Error on failure.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetPointerProperty\n@sa SetPointerProperty\n@sa CleanupPropertyCallback"
          }
        ],
        "SetPointerProperty": {
          "doc": "Set a pointer property in a group of properties.\n\n@param props the properties to modify.\n@param name the name of the property to modify.\n@param value the new value of the property, or nullptr to delete the property.\n@throws Error on failure.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetPointerProperty\n@sa HasProperty\n@sa SetBooleanProperty\n@sa SetFloatProperty\n@sa SetNumberProperty\n@sa SetPointerPropertyWithCleanup\n@sa SetStringProperty",
          "name": "SetPointerProperty",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "props",
              "type": "PropertiesParam"
            },
            {
              "name": "name",
              "type": "StringParam"
            },
            {
              "name": "value",
              "type": "void *"
            }
          ],
          "sourceName": "SDL_SetPointerProperty",
          "hints": {
            "mayFail": true
          }
        },
        "SetStringProperty": {
          "doc": "Set a string property in a group of properties.\n\nThis function makes a copy of the string; the caller does not have to\npreserve the data after this call completes.\n\n@param props the properties to modify.\n@param name the name of the property to modify.\n@param value the new value of the property, or nullptr to delete the property.\n@throws Error on failure.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetStringProperty",
          "name": "SetStringProperty",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "props",
              "type": "PropertiesParam"
            },
            {
              "name": "name",
              "type": "StringParam"
            },
            {
              "name": "value",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_SetStringProperty",
          "hints": {
            "mayFail": true
          }
        },
        "SetNumberProperty": {
          "doc": "Set an integer property in a group of properties.\n\n@param props the properties to modify.\n@param name the name of the property to modify.\n@param value the new value of the property.\n@throws Error on failure.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetNumberProperty",
          "name": "SetNumberProperty",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "props",
              "type": "PropertiesParam"
            },
            {
              "name": "name",
              "type": "StringParam"
            },
            {
              "name": "value",
              "type": "Sint64"
            }
          ],
          "sourceName": "SDL_SetNumberProperty",
          "hints": {
            "mayFail": true
          }
        },
        "SetFloatProperty": {
          "doc": "Set a floating point property in a group of properties.\n\n@param props the properties to modify.\n@param name the name of the property to modify.\n@param value the new value of the property.\n@throws Error on failure.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetFloatProperty",
          "name": "SetFloatProperty",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "props",
              "type": "PropertiesParam"
            },
            {
              "name": "name",
              "type": "StringParam"
            },
            {
              "name": "value",
              "type": "float"
            }
          ],
          "sourceName": "SDL_SetFloatProperty",
          "hints": {
            "mayFail": true
          }
        },
        "SetBooleanProperty": {
          "doc": "Set a boolean property in a group of properties.\n\n@param props the properties to modify.\n@param name the name of the property to modify.\n@param value the new value of the property.\n@throws Error on failure.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetBooleanProperty",
          "name": "SetBooleanProperty",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "props",
              "type": "PropertiesParam"
            },
            {
              "name": "name",
              "type": "StringParam"
            },
            {
              "name": "value",
              "type": "bool"
            }
          ],
          "sourceName": "SDL_SetBooleanProperty",
          "hints": {
            "mayFail": true
          }
        },
        "HasProperty": {
          "doc": "Return whether a property exists in a group of properties.\n\n@param props the properties to query.\n@param name the name of the property to query.\n@returns true if the property exists, or false if it doesn't.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetPropertyType",
          "name": "HasProperty",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "props",
              "type": "PropertiesParam"
            },
            {
              "name": "name",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_HasProperty"
        },
        "GetPropertyType": {
          "doc": "Get the type of a property in a group of properties.\n\n@param props the properties to query.\n@param name the name of the property to query.\n@returns the type of the property, or PROPERTY_TYPE_INVALID if it is\n         not set.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa HasProperty",
          "name": "GetPropertyType",
          "kind": "function",
          "type": "PropertyType",
          "parameters": [
            {
              "name": "props",
              "type": "PropertiesParam"
            },
            {
              "name": "name",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_GetPropertyType"
        },
        "GetPointerProperty": {
          "doc": "Get a pointer property from a group of properties.\n\nBy convention, the names of properties that SDL exposes on objects will\nstart with \"SDL.\", and properties that SDL uses internally will start with\n\"SDL.internal.\". These should be considered read-only and should not be\nmodified by applications.\n\n@param props the properties to query.\n@param name the name of the property to query.\n@param default_value the default value of the property.\n@returns the value of the property, or `default_value` if it is not set or\n         not a pointer property.\n\n@threadsafety It is safe to call this function from any thread, although\n              the data returned is not protected and could potentially be\n              freed if you call SetPointerProperty() or\n              ClearProperty() on these properties from another thread.\n              If you need to avoid this, use LockProperties() and\n              UnlockProperties().\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetBooleanProperty\n@sa GetFloatProperty\n@sa GetNumberProperty\n@sa GetPropertyType\n@sa GetStringProperty\n@sa HasProperty\n@sa SetPointerProperty",
          "name": "GetPointerProperty",
          "kind": "function",
          "type": "void *",
          "parameters": [
            {
              "name": "props",
              "type": "PropertiesParam"
            },
            {
              "name": "name",
              "type": "StringParam"
            },
            {
              "name": "default_value",
              "type": "void *"
            }
          ],
          "sourceName": "SDL_GetPointerProperty"
        },
        "GetStringProperty": {
          "doc": "Get a string property from a group of properties.\n\n@param props the properties to query.\n@param name the name of the property to query.\n@param default_value the default value of the property.\n@returns the value of the property, or `default_value` if it is not set or\n         not a string property.\n\n@threadsafety It is safe to call this function from any thread, although\n              the data returned is not protected and could potentially be\n              freed if you call SetStringProperty() or\n              ClearProperty() on these properties from another thread.\n              If you need to avoid this, use LockProperties() and\n              UnlockProperties().\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetPropertyType\n@sa HasProperty\n@sa SetStringProperty",
          "name": "GetStringProperty",
          "kind": "function",
          "type": "const char *",
          "parameters": [
            {
              "name": "props",
              "type": "PropertiesParam"
            },
            {
              "name": "name",
              "type": "StringParam"
            },
            {
              "name": "default_value",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_GetStringProperty"
        },
        "GetNumberProperty": {
          "doc": "Get a number property from a group of properties.\n\nYou can use GetPropertyType() to query whether the property exists and\nis a number property.\n\n@param props the properties to query.\n@param name the name of the property to query.\n@param default_value the default value of the property.\n@returns the value of the property, or `default_value` if it is not set or\n         not a number property.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetPropertyType\n@sa HasProperty\n@sa SetNumberProperty",
          "name": "GetNumberProperty",
          "kind": "function",
          "type": "Sint64",
          "parameters": [
            {
              "name": "props",
              "type": "PropertiesParam"
            },
            {
              "name": "name",
              "type": "StringParam"
            },
            {
              "name": "default_value",
              "type": "Sint64"
            }
          ],
          "sourceName": "SDL_GetNumberProperty"
        },
        "GetFloatProperty": {
          "doc": "Get a floating point property from a group of properties.\n\nYou can use GetPropertyType() to query whether the property exists and\nis a floating point property.\n\n@param props the properties to query.\n@param name the name of the property to query.\n@param default_value the default value of the property.\n@returns the value of the property, or `default_value` if it is not set or\n         not a float property.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetPropertyType\n@sa HasProperty\n@sa SetFloatProperty",
          "name": "GetFloatProperty",
          "kind": "function",
          "type": "float",
          "parameters": [
            {
              "name": "props",
              "type": "PropertiesParam"
            },
            {
              "name": "name",
              "type": "StringParam"
            },
            {
              "name": "default_value",
              "type": "float"
            }
          ],
          "sourceName": "SDL_GetFloatProperty"
        },
        "GetBooleanProperty": {
          "doc": "Get a boolean property from a group of properties.\n\nYou can use GetPropertyType() to query whether the property exists and\nis a boolean property.\n\n@param props the properties to query.\n@param name the name of the property to query.\n@param default_value the default value of the property.\n@returns the value of the property, or `default_value` if it is not set or\n         not a boolean property.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetPropertyType\n@sa HasProperty\n@sa SetBooleanProperty",
          "name": "GetBooleanProperty",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "props",
              "type": "PropertiesParam"
            },
            {
              "name": "name",
              "type": "StringParam"
            },
            {
              "name": "default_value",
              "type": "bool"
            }
          ],
          "sourceName": "SDL_GetBooleanProperty"
        },
        "ClearProperty": {
          "doc": "Clear a property from a group of properties.\n\n@param props the properties to modify.\n@param name the name of the property to clear.\n@throws Error on failure.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "ClearProperty",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "props",
              "type": "PropertiesParam"
            },
            {
              "name": "name",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_ClearProperty",
          "hints": {
            "mayFail": true
          }
        },
        "EnumeratePropertiesCallback": {
          "doc": "A callback used to enumerate all the properties in a group of properties.\n\nThis callback is called from EnumerateProperties(), and is called once\nper property in the set.\n\n@param userdata an app-defined pointer passed to the callback.\n@param props the Properties that is being enumerated.\n@param name the next property name in the enumeration.\n\n@threadsafety EnumerateProperties holds a lock on `props` during this\n              callback.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa EnumerateProperties",
          "name": "EnumeratePropertiesCallback",
          "kind": "alias",
          "type": "SDL_EnumeratePropertiesCallback",
          "sourceName": "SDL_EnumeratePropertiesCallback"
        },
        "EnumeratePropertiesCB": {
          "kind": "alias",
          "name": "EnumeratePropertiesCB",
          "type": "std::function<void(PropertiesID props, const char *name)>",
          "doc": "A callback used to enumerate all the properties in a group of properties.\n\nThis callback is called from EnumerateProperties(), and is called once\nper property in the set.\n\n@param userdata an app-defined pointer passed to the callback.\n@param props the Properties that is being enumerated.\n@param name the next property name in the enumeration.\n\n@threadsafety EnumerateProperties holds a lock on `props` during this\n              callback.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa EnumerateProperties\n@sa EnumeratePropertiesCallback"
        },
        "EnumerateProperties": [
          {
            "doc": "Enumerate the properties contained in a group of properties.\n\nThe callback function is called for each property in the group of\nproperties. The properties are locked during enumeration.\n\n@param props the properties to query.\n@param callback the function to call for each property.\n@param userdata a pointer that is passed to `callback`.\n@throws Error on failure.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
            "name": "EnumerateProperties",
            "kind": "function",
            "type": "void",
            "parameters": [
              {
                "name": "props",
                "type": "PropertiesParam"
              },
              {
                "name": "callback",
                "type": "EnumeratePropertiesCallback"
              },
              {
                "name": "userdata",
                "type": "void *"
              }
            ],
            "sourceName": "SDL_EnumerateProperties",
            "hints": {
              "mayFail": true
            }
          },
          {
            "kind": "function",
            "type": "void",
            "after": "SDL_EnumerateProperties",
            "parameters": [
              {
                "type": "PropertiesParam",
                "name": "props"
              },
              {
                "type": "EnumeratePropertiesCB",
                "name": "callback"
              }
            ],
            "name": "EnumerateProperties",
            "doc": "Enumerate the properties contained in a group of properties.\n\nThe callback function is called for each property in the group of\nproperties. The properties are locked during enumeration.\n\n@param props the properties to query.\n@param callback the function to call for each property.\n@param userdata a pointer that is passed to `callback`.\n@throws Error on failure.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0."
          }
        ],
        "CountProperties": {
          "kind": "function",
          "type": "Uint64",
          "parameters": [
            {
              "type": "PropertiesParam",
              "name": "props"
            }
          ],
          "name": "CountProperties",
          "doc": ""
        },
        "DestroyProperties": {
          "doc": "Destroy a group of properties.\n\nAll properties are deleted and their cleanup functions will be called, if\nany.\n\n@param props the properties to destroy.\n\n@threadsafety This function should not be called while these properties are\n              locked or other threads might be setting or getting values\n              from these properties.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Properties.Create",
          "name": "DestroyProperties",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "props",
              "type": "PropertiesID"
            }
          ],
          "sourceName": "SDL_DestroyProperties"
        }
      },
      "includes": [
        "SDL3/SDL_properties.h"
      ],
      "localIncludes": [
        "SDL3pp_callbackWrapper.h",
        "SDL3pp_error.h",
        "SDL3pp_strings.h"
      ]
    },
    "SDL3pp_error.h": {
      "name": "SDL3pp_error.h",
      "doc": "@defgroup CategoryError Category Error\n\nSimple error message routines for SDL.\n\nMost apps will interface with these APIs in exactly one function: when\nalmost any SDL function call reports failure, you can get a human-readable\nstring of the problem from GetError().\n\nThese strings are maintained per-thread, and apps are welcome to set their\nown errors, which is popular when building libraries on top of SDL for\nother apps to consume. These strings are set by calling SetErrorUnformatted().\n\nA common usage pattern is to have a function that returns true for success\nand false for failure, and do this when something fails:\n\n```c\nif (something_went_wrong) {\n   return SetErrorUnformatted(\"The thing broke in this specific way: %d\", errcode);\n}\n```\n\nIt's also common to just return `false` in this case if the failing thing\nis known to call SetErrorUnformatted(), so errors simply propagate through.",
      "entries": {
        "SetErrorUnformatted": {
          "doc": "Set the SDL error message for the current thread.\n\nCalling this function will replace any previous error message that was set.\n\nThis function always returns false, since SDL frequently uses false to\nsignify a failing result, leading to this idiom:\n\n```c\nif (error_code) {\n    return SetErrorUnformatted(\"This operation has failed: %d\", error_code);\n}\n```\n\n@param fmt a printf()-style message format string.\n@param ... additional parameters matching % tokens in the `fmt` string, if\n           any.\n@returns false.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa ClearError\n@sa GetError\n@sa SDL_SetErrorV",
          "name": "SetErrorUnformatted",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "message",
              "type": "StringParam"
            }
          ],
          "sourceName": "SDL_SetError"
        },
        "OutOfMemory": {
          "doc": "Set an error indicating that memory allocation failed.\n\nThis function does not do any memory allocation.\n\n@returns false.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "OutOfMemory",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_OutOfMemory"
        },
        "GetError": {
          "doc": "Retrieve a message about the last error that occurred on the current\nthread.\n\nIt is possible for multiple errors to occur before calling GetError().\nOnly the last error is returned.\n\nThe message is only applicable when an SDL function has signaled an error.\nYou must check the return values of SDL function calls to determine when to\nappropriately call GetError(). You should *not* use the results of\nGetError() to decide if an error has occurred! Sometimes SDL will set\nan error string even when reporting success.\n\nSDL will *not* clear the error string for successful API calls. You *must*\ncheck return values for failure cases before you can assume the error\nstring applies.\n\nError strings are set per-thread, so an error set in a different thread\nwill not interfere with the current thread's operation.\n\nThe returned value is a thread-local string which will remain valid until\nthe current thread's error string is changed. The caller should make a copy\nif the value is needed after the next SDL API call.\n\n@returns a message with information about the specific error that occurred,\n         or an empty string if there hasn't been an error message set since\n         the last call to ClearError().\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa ClearError\n@sa SetErrorUnformatted",
          "name": "GetError",
          "kind": "function",
          "type": "const char *",
          "parameters": [],
          "sourceName": "SDL_GetError"
        },
        "ClearError": {
          "doc": "Clear any previous error message for this thread.\n\n@returns true.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetError\n@sa SetErrorUnformatted",
          "name": "ClearError",
          "kind": "function",
          "type": "bool",
          "parameters": [],
          "sourceName": "SDL_ClearError"
        },
        "SDL_Unsupported": {
          "doc": "A macro to standardize error reporting on unsupported operations.\n\nThis simply calls SetErrorUnformatted() with a standardized error string, for\nconvenience, consistency, and clarity.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_Unsupported",
          "kind": "def",
          "parameters": [],
          "value": "SDL_SetError(\"That operation is not supported\")",
          "sourceName": "SDL_Unsupported"
        },
        "SDL_InvalidParamError": {
          "doc": "A macro to standardize error reporting on unsupported operations.\n\nThis simply calls SetErrorUnformatted() with a standardized error string, for\nconvenience, consistency, and clarity.\n\nA common usage pattern inside SDL is this:\n\n```c\nbool MyFunction(const char *str) {\n    if (!str) {\n        return SDL_InvalidParamError(\"str\");  // returns false.\n    }\n    DoSomething(str);\n    return true;\n}\n```\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_InvalidParamError",
          "kind": "def",
          "parameters": [
            "param"
          ],
          "value": "SDL_SetError(\"Parameter '%s' is invalid\", (param))",
          "sourceName": "SDL_InvalidParamError"
        }
      },
      "includes": [
        "exception",
        "format",
        "SDL3/SDL_error.h"
      ],
      "localIncludes": [
        "SDL3pp_strings.h"
      ]
    },
    "SDL3pp_assert.h": {
      "name": "SDL3pp_assert.h",
      "doc": "@defgroup CategoryAssert Category Assert\n\nA helpful assertion macro!\n\nSDL assertions operate like your usual `assert` macro, but with some added\nfeatures:\n\n- It uses a trick with the `sizeof` operator, so disabled assertions\n  vaporize out of the compiled code, but variables only referenced in the\n  assertion won't trigger compiler warnings about being unused.\n- It is safe to use with a dangling-else: `if (x) SDL_assert(y); else\n  do_something();`\n- It works the same everywhere, instead of counting on various platforms'\n  compiler and C runtime to behave.\n- It provides multiple levels of assertion (SDL_assert, SDL_assert_release,\n  SDL_assert_paranoid) instead of a single all-or-nothing option.\n- It offers a variety of responses when an assertion fails (retry, trigger\n  the debugger, abort the program, ignore the failure once, ignore it for\n  the rest of the program's run).\n- It tries to show the user a dialog by default, if possible, but the app\n  can provide a callback to handle assertion failures however they like.\n- It lets failed assertions be retried. Perhaps you had a network failure\n  and just want to retry the test after plugging your network cable back\n  in? You can.\n- It lets the user ignore an assertion failure, if there's a harmless\n  problem that one can continue past.\n- It lets the user mark an assertion as ignored for the rest of the\n  program's run; if there's a harmless problem that keeps popping up.\n- It provides statistics and data on all failed assertions to the app.\n- It allows the default assertion handler to be controlled with environment\n  variables, in case an automated script needs to control it.\n- It can be used as an aid to Clang's static analysis; it will treat SDL\n  assertions as universally true (under the assumption that you are serious\n  about the asserted claims and that your debug builds will detect when\n  these claims were wrong). This can help the analyzer avoid false\n  positives.\n\nTo use it: compile a debug build and just sprinkle around tests to check\nyour code!",
      "entries": {
        "SDL_ASSERT_LEVEL": {
          "doc": "The level of assertion aggressiveness.\n\nThis value changes depending on compiler options and other preprocessor\ndefines.\n\nIt is currently one of the following values, but future SDL releases might\nadd more:\n\n- 0: All SDL assertion macros are disabled.\n- 1: Release settings: SDL_assert disabled, SDL_assert_release enabled.\n- 2: Debug settings: SDL_assert and SDL_assert_release enabled.\n- 3: Paranoid settings: All SDL assertion macros enabled, including\n  SDL_assert_paranoid.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_ASSERT_LEVEL",
          "kind": "def",
          "value": "SomeNumberBasedOnVariousFactors",
          "sourceName": "SDL_ASSERT_LEVEL"
        },
        "SDL_TriggerBreakpoint": {
          "doc": "Attempt to tell an attached debugger to pause.\n\nThis allows an app to programmatically halt (\"break\") the debugger as if it\nhad hit a breakpoint, allowing the developer to examine program state, etc.\n\nThis is a macro--not a function--so that the debugger breaks on the source\ncode line that used SDL_TriggerBreakpoint and not in some random guts of\nSDL. SDL_assert uses this macro for the same reason.\n\nIf the program is not running under a debugger, SDL_TriggerBreakpoint will\nlikely terminate the app, possibly without warning. If the current platform\nisn't supported, this macro is left undefined.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_TriggerBreakpoint",
          "kind": "def",
          "parameters": [],
          "value": "TriggerABreakpointInAPlatformSpecificManner",
          "sourceName": "SDL_TriggerBreakpoint"
        },
        "SDL_FUNCTION": {
          "doc": "A macro that reports the current function being compiled.\n\nIf SDL can't figure how the compiler reports this, it will use \"???\".\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_FUNCTION",
          "kind": "def",
          "value": "__FUNCTION__",
          "sourceName": "SDL_FUNCTION"
        },
        "SDL_FILE": {
          "doc": "A macro that reports the current file being compiled.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_FILE",
          "kind": "def",
          "value": "__FILE__",
          "sourceName": "SDL_FILE"
        },
        "SDL_LINE": {
          "doc": "A macro that reports the current line number of the file being compiled.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_LINE",
          "kind": "def",
          "value": "__LINE__",
          "sourceName": "SDL_LINE"
        },
        "SDL_NULL_WHILE_LOOP_CONDITION": {
          "doc": "A macro for wrapping code in `do {} while (0);` without compiler warnings.\n\nVisual Studio with really aggressive warnings enabled needs this to avoid\ncompiler complaints.\n\nthe `do {} while (0);` trick is useful for wrapping code in a macro that\nmay or may not be a single statement, to avoid various C language\naccidents.\n\nTo use:\n\n```c\ndo { SomethingOnce(); } while (SDL_nullptr_WHILE_LOOP_CONDITION (0));\n```\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_NULL_WHILE_LOOP_CONDITION",
          "kind": "def",
          "value": "(0)",
          "sourceName": "SDL_NULL_WHILE_LOOP_CONDITION"
        },
        "SDL_disabled_assert": {
          "doc": "The macro used when an assertion is disabled.\n\nThis isn't for direct use by apps, but this is the code that is inserted\nwhen an SDL_assert is disabled (perhaps in a release build).\n\nThe code does nothing, but wraps `condition` in a sizeof operator, which\ngenerates no code and has no side effects, but avoid compiler warnings\nabout unused variables.\n\n@param condition the condition to assert (but not actually run here).\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_disabled_assert",
          "kind": "def",
          "parameters": [
            "condition"
          ],
          "value": "    do { (void) sizeof ((condition)); } while (SDL_NULL_WHILE_LOOP_CONDITION)",
          "sourceName": "SDL_disabled_assert"
        },
        "AssertState": {
          "doc": "Possible outcomes from a triggered assertion.\n\nWhen an enabled assertion triggers, it may call the assertion handler\n(possibly one provided by the app via SetAssertionHandler), which will\nreturn one of these values, possibly after asking the user.\n\nThen SDL will respond based on this outcome (loop around to retry the\ncondition, try to break in a debugger, kill the program, or ignore the\nproblem).\n\n@since This enum is available since SDL 3.2.0.",
          "name": "AssertState",
          "kind": "alias",
          "sourceName": "SDL_AssertState",
          "type": "SDL_AssertState"
        },
        "ASSERTION_RETRY": {
          "kind": "var",
          "name": "ASSERTION_RETRY",
          "constexpr": true,
          "type": "AssertState",
          "doc": "Retry the assert immediately.",
          "sourceName": "SDL_ASSERTION_RETRY"
        },
        "ASSERTION_BREAK": {
          "kind": "var",
          "name": "ASSERTION_BREAK",
          "constexpr": true,
          "type": "AssertState",
          "doc": "Make the debugger trigger a breakpoint.",
          "sourceName": "SDL_ASSERTION_BREAK"
        },
        "ASSERTION_ABORT": {
          "kind": "var",
          "name": "ASSERTION_ABORT",
          "constexpr": true,
          "type": "AssertState",
          "doc": "Terminate the program.",
          "sourceName": "SDL_ASSERTION_ABORT"
        },
        "ASSERTION_IGNORE": {
          "kind": "var",
          "name": "ASSERTION_IGNORE",
          "constexpr": true,
          "type": "AssertState",
          "doc": "Ignore the assert.",
          "sourceName": "SDL_ASSERTION_IGNORE"
        },
        "ASSERTION_ALWAYS_IGNORE": {
          "kind": "var",
          "name": "ASSERTION_ALWAYS_IGNORE",
          "constexpr": true,
          "type": "AssertState",
          "doc": "Ignore the assert from now on.",
          "sourceName": "SDL_ASSERTION_ALWAYS_IGNORE"
        },
        "AssertData": {
          "doc": "Information about an assertion failure.\n\nThis structure is filled in with information about a triggered assertion,\nused by the assertion handler, then added to the assertion report. This is\nreturned as a linked list from GetAssertionReport().\n\n@since This struct is available since SDL 3.2.0.",
          "name": "AssertData",
          "kind": "alias",
          "sourceName": "SDL_AssertData",
          "type": "SDL_AssertData"
        },
        "ReportAssertion": {
          "doc": "Never call this directly.\n\nUse the SDL_assert macros instead.\n\n@param data assert data structure.\n@param func function name.\n@param file file name.\n@param line line number.\n@returns assert state.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "ReportAssertion",
          "kind": "function",
          "type": "AssertState",
          "parameters": [
            {
              "name": "data",
              "type": "AssertData *"
            },
            {
              "name": "func",
              "type": "StringParam"
            },
            {
              "name": "file",
              "type": "StringParam"
            },
            {
              "name": "line",
              "type": "int"
            }
          ],
          "sourceName": "SDL_ReportAssertion"
        },
        "SDL_AssertBreakpoint": {
          "doc": "The macro used when an assertion triggers a breakpoint.\n\nThis isn't for direct use by apps; use SDL_assert or SDL_TriggerBreakpoint\ninstead.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_AssertBreakpoint",
          "kind": "def",
          "parameters": [],
          "value": "SDL_TriggerBreakpoint()",
          "sourceName": "SDL_AssertBreakpoint"
        },
        "SDL_enabled_assert": {
          "doc": "The macro used when an assertion is enabled.\n\nThis isn't for direct use by apps, but this is the code that is inserted\nwhen an SDL_assert is enabled.\n\nThe `do {} while(0)` avoids dangling else problems:\n\n```c\nif (x) SDL_assert(y); else blah();\n```\n\n... without the do/while, the \"else\" could attach to this macro's \"if\". We\ntry to handle just the minimum we need here in a macro...the loop, the\nstatic vars, and break points. The heavy lifting is handled in\nReportAssertion().\n\n@param condition the condition to assert.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_enabled_assert",
          "kind": "def",
          "parameters": [
            "condition"
          ],
          "value": "[object Object]",
          "sourceName": "SDL_enabled_assert"
        },
        "SDL_assert": {
          "doc": "An assertion test that is normally performed only in debug builds.\n\nThis macro is enabled when the SDL_ASSERT_LEVEL is >= 2, otherwise it is\ndisabled. This is meant to only do these tests in debug builds, so they can\ntend to be more expensive, and they are meant to bring everything to a halt\nwhen they fail, with the programmer there to assess the problem.\n\nIn short: you can sprinkle these around liberally and assume they will\nevaporate out of the build when building for end-users.\n\nWhen assertions are disabled, this wraps `condition` in a `sizeof`\noperator, which means any function calls and side effects will not run, but\nthe compiler will not complain about any otherwise-unused variables that\nare only referenced in the assertion.\n\nOne can set the environment variable \"SDL_ASSERT\" to one of several strings\n(\"abort\", \"break\", \"retry\", \"ignore\", \"always_ignore\") to force a default\nbehavior, which may be desirable for automation purposes. If your platform\nrequires GUI interfaces to happen on the main thread but you're debugging\nan assertion in a background thread, it might be desirable to set this to\n\"break\" so that your debugger takes control as soon as assert is triggered,\ninstead of risking a bad UI interaction (deadlock, etc) in the application.\n\n@param condition boolean value to test.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_assert",
          "kind": "def",
          "parameters": [
            "condition"
          ],
          "value": "if (assertion_enabled && (condition)) { trigger_assertion; }",
          "sourceName": "SDL_assert"
        },
        "SDL_assert_release": {
          "doc": "An assertion test that is performed even in release builds.\n\nThis macro is enabled when the SDL_ASSERT_LEVEL is >= 1, otherwise it is\ndisabled. This is meant to be for tests that are cheap to make and\nextremely unlikely to fail; generally it is frowned upon to have an\nassertion failure in a release build, so these assertions generally need to\nbe of more than life-and-death importance if there's a chance they might\ntrigger. You should almost always consider handling these cases more\ngracefully than an assert allows.\n\nWhen assertions are disabled, this wraps `condition` in a `sizeof`\noperator, which means any function calls and side effects will not run, but\nthe compiler will not complain about any otherwise-unused variables that\nare only referenced in the assertion.\n\nOne can set the environment variable \"SDL_ASSERT\" to one of several strings\n(\"abort\", \"break\", \"retry\", \"ignore\", \"always_ignore\") to force a default\nbehavior, which may be desirable for automation purposes. If your platform\nrequires GUI interfaces to happen on the main thread but you're debugging\nan assertion in a background thread, it might be desirable to set this to\n\"break\" so that your debugger takes control as soon as assert is triggered,\ninstead of risking a bad UI interaction (deadlock, etc) in the application.\n*\n\n@param condition boolean value to test.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_assert_release",
          "kind": "def",
          "parameters": [
            "condition"
          ],
          "value": "SDL_disabled_assert(condition)",
          "sourceName": "SDL_assert_release"
        },
        "SDL_assert_paranoid": {
          "doc": "An assertion test that is performed only when built with paranoid settings.\n\nThis macro is enabled when the SDL_ASSERT_LEVEL is >= 3, otherwise it is\ndisabled. This is a higher level than both release and debug, so these\ntests are meant to be expensive and only run when specifically looking for\nextremely unexpected failure cases in a special build.\n\nWhen assertions are disabled, this wraps `condition` in a `sizeof`\noperator, which means any function calls and side effects will not run, but\nthe compiler will not complain about any otherwise-unused variables that\nare only referenced in the assertion.\n\nOne can set the environment variable \"SDL_ASSERT\" to one of several strings\n(\"abort\", \"break\", \"retry\", \"ignore\", \"always_ignore\") to force a default\nbehavior, which may be desirable for automation purposes. If your platform\nrequires GUI interfaces to happen on the main thread but you're debugging\nan assertion in a background thread, it might be desirable to set this to\n\"break\" so that your debugger takes control as soon as assert is triggered,\ninstead of risking a bad UI interaction (deadlock, etc) in the application.\n\n@param condition boolean value to test.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_assert_paranoid",
          "kind": "def",
          "parameters": [
            "condition"
          ],
          "value": "SDL_disabled_assert(condition)",
          "sourceName": "SDL_assert_paranoid"
        },
        "SDL_assert_always": {
          "doc": "An assertion test that is always performed.\n\nThis macro is always enabled no matter what SDL_ASSERT_LEVEL is set to. You\nalmost never want to use this, as it could trigger on an end-user's system,\ncrashing your program.\n\nOne can set the environment variable \"SDL_ASSERT\" to one of several strings\n(\"abort\", \"break\", \"retry\", \"ignore\", \"always_ignore\") to force a default\nbehavior, which may be desirable for automation purposes. If your platform\nrequires GUI interfaces to happen on the main thread but you're debugging\nan assertion in a background thread, it might be desirable to set this to\n\"break\" so that your debugger takes control as soon as assert is triggered,\ninstead of risking a bad UI interaction (deadlock, etc) in the application.\n\n@param condition boolean value to test.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_assert_always",
          "kind": "def",
          "parameters": [
            "condition"
          ],
          "value": "SDL_enabled_assert(condition)",
          "sourceName": "SDL_assert_always"
        },
        "AssertionHandler": {
          "doc": "A callback that fires when an SDL assertion fails.\n\n@param data a pointer to the AssertData structure corresponding to the\n            current assertion.\n@param userdata what was passed as `userdata` to SetAssertionHandler().\n@returns an AssertState value indicating how to handle the failure.\n\n@threadsafety This callback may be called from any thread that triggers an\n              assert at any time.\n\n@since This datatype is available since SDL 3.2.0.",
          "name": "AssertionHandler",
          "kind": "alias",
          "type": "SDL_AssertionHandler",
          "sourceName": "SDL_AssertionHandler"
        },
        "AssertionHandlerCB": {
          "kind": "alias",
          "name": "AssertionHandlerCB",
          "type": "std::function<SDL_AssertState(const SDL_AssertData *)>",
          "doc": "A callback that fires when an SDL assertion fails.\n\n@param data a pointer to the AssertData structure corresponding to the\n            current assertion.\n@param userdata what was passed as `userdata` to SetAssertionHandler().\n@returns an AssertState value indicating how to handle the failure.\n\n@threadsafety This callback may be called from any thread that triggers an\n              assert at any time.\n\n@since This datatype is available since SDL 3.2.0.\n@sa AssertionHandler"
        },
        "SetAssertionHandler": [
          {
            "doc": "Set an application-defined assertion handler.\n\nThis function allows an application to show its own assertion UI and/or\nforce the response to an assertion failure. If the application doesn't\nprovide this, SDL will try to do the right thing, popping up a\nsystem-specific GUI dialog, and probably minimizing any fullscreen windows.\n\nThis callback may fire from any thread, but it runs wrapped in a mutex, so\nit will only fire from one thread at a time.\n\nThis callback is NOT reset to SDL's internal handler upon SDL_Quit()!\n\n@param handler the AssertionHandler function to call when an assertion\n               fails or nullptr for the default handler.\n@param userdata a pointer that is passed to `handler`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetAssertionHandler",
            "name": "SetAssertionHandler",
            "kind": "function",
            "type": "void",
            "parameters": [
              {
                "name": "handler",
                "type": "AssertionHandler"
              },
              {
                "name": "userdata",
                "type": "void *"
              }
            ],
            "sourceName": "SDL_SetAssertionHandler"
          },
          {
            "kind": "function",
            "type": "void",
            "parameters": [
              {
                "type": "AssertionHandlerCB",
                "name": "handler"
              }
            ],
            "name": "SetAssertionHandler",
            "doc": "Set an application-defined assertion handler.\n\nThis function allows an application to show its own assertion UI and/or\nforce the response to an assertion failure. If the application doesn't\nprovide this, SDL will try to do the right thing, popping up a\nsystem-specific GUI dialog, and probably minimizing any fullscreen windows.\n\nThis callback may fire from any thread, but it runs wrapped in a mutex, so\nit will only fire from one thread at a time.\n\nThis callback is NOT reset to SDL's internal handler upon SDL_Quit()!\n\n@param handler the AssertionHandler function to call when an assertion\n               fails or nullptr for the default handler.\n@param userdata a pointer that is passed to `handler`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetAssertionHandler"
          }
        ],
        "GetDefaultAssertionHandler": {
          "doc": "Get the default assertion handler.\n\nThis returns the function pointer that is called by default when an\nassertion is triggered. This is an internal function provided by SDL, that\nis used for assertions when SetAssertionHandler() hasn't been used to\nprovide a different function.\n\n@returns the default AssertionHandler that is called when an assert\n         triggers.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetAssertionHandler",
          "name": "GetDefaultAssertionHandler",
          "kind": "function",
          "type": "AssertionHandler",
          "parameters": [],
          "sourceName": "SDL_GetDefaultAssertionHandler"
        },
        "GetAssertionHandler": [
          {
            "doc": "Get the current assertion handler.\n\nThis returns the function pointer that is called when an assertion is\ntriggered. This is either the value last passed to\nSetAssertionHandler(), or if no application-specified function is set,\nis equivalent to calling GetDefaultAssertionHandler().\n\nThe parameter `puserdata` is a pointer to a void*, which will store the\n\"userdata\" pointer that was passed to SetAssertionHandler(). This value\nwill always be nullptr for the default handler. If you don't care about this\ndata, it is safe to pass a nullptr pointer to this function to ignore it.\n\n@param puserdata pointer which is filled with the \"userdata\" pointer that\n                 was passed to SetAssertionHandler().\n@returns the AssertionHandler that is called when an assert triggers.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SetAssertionHandler",
            "name": "GetAssertionHandler",
            "kind": "function",
            "type": "AssertionHandler",
            "parameters": [
              {
                "name": "puserdata",
                "type": "void **"
              }
            ],
            "sourceName": "SDL_GetAssertionHandler"
          },
          {
            "kind": "function",
            "type": "AssertionHandlerCB",
            "parameters": [],
            "name": "GetAssertionHandler",
            "doc": "Get the current assertion handler.\n\nThis returns the function pointer that is called when an assertion is\ntriggered. This is either the value last passed to\nSetAssertionHandler(), or if no application-specified function is set,\nis equivalent to calling GetDefaultAssertionHandler().\n\nThe parameter `puserdata` is a pointer to a void*, which will store the\n\"userdata\" pointer that was passed to SetAssertionHandler(). This value\nwill always be nullptr for the default handler. If you don't care about this\ndata, it is safe to pass a nullptr pointer to this function to ignore it.\n\n@param puserdata pointer which is filled with the \"userdata\" pointer that\n                 was passed to SetAssertionHandler().\n@returns the AssertionHandler that is called when an assert triggers.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SetAssertionHandler"
          }
        ],
        "GetAssertionReport": {
          "doc": "Get a list of all assertion failures.\n\nThis function gets all assertions triggered since the last call to\nResetAssertionReport(), or the start of the program.\n\nThe proper way to examine this data looks something like this:\n\n```c\nconst AssertData *item = GetAssertionReport();\nwhile (item) {\n   printf(\"'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\@n\",\n          item->condition, item->function, item->filename,\n          item->linenum, item->trigger_count,\n          item->always_ignore ? \"yes\" : \"no\");\n   item = item->next;\n}\n```\n\n@returns a list of all failed assertions or nullptr if the list is empty. This\n         memory should not be modified or freed by the application. This\n         pointer remains valid until the next call to SDL_Quit() or\n         ResetAssertionReport().\n\n@threadsafety This function is not thread safe. Other threads calling\n              ResetAssertionReport() simultaneously, may render the\n              returned pointer invalid.\n\n@since This function is available since SDL 3.2.0.\n\n@sa ResetAssertionReport",
          "name": "GetAssertionReport",
          "kind": "function",
          "type": "const AssertData *",
          "parameters": [],
          "sourceName": "SDL_GetAssertionReport"
        },
        "ResetAssertionReport": {
          "doc": "Clear the list of all assertion failures.\n\nThis function will clear the list of all assertions triggered up to that\npoint. Immediately following this call, GetAssertionReport will return\nno items. In addition, any previously-triggered assertions will be reset to\na trigger_count of zero, and their always_ignore state will be false.\n\n@threadsafety This function is not thread safe. Other threads triggering an\n              assertion, or simultaneously calling this function may cause\n              memory leaks or crashes.\n\n@since This function is available since SDL 3.2.0.\n\n@sa GetAssertionReport",
          "name": "ResetAssertionReport",
          "kind": "function",
          "type": "void",
          "parameters": [],
          "sourceName": "SDL_ResetAssertionReport"
        }
      },
      "includes": [
        "SDL3/SDL_assert.h"
      ],
      "localIncludes": [
        "SDL3pp_callbackWrapper.h",
        "SDL3pp_strings.h"
      ]
    },
    "SDL3pp_pixels.h": {
      "name": "SDL3pp_pixels.h",
      "doc": "@defgroup CategoryPixels Category Pixels\n\nSDL offers facilities for pixel management.\n\nLargely these facilities deal with pixel _format_: what does this set of\nbits represent?\n\nIf you mostly want to think of a pixel as some combination of red, green,\nblue, and maybe alpha intensities, this is all pretty straightforward, and\nin many cases, is enough information to build a perfectly fine game.\n\nHowever, the actual definition of a pixel is more complex than that:\n\nPixels are a representation of a color in a particular color space.\n\nThe first characteristic of a color space is the color type. SDL\nunderstands two different color types, RGB and YCbCr, or in SDL also\nreferred to as YUV.\n\nRGB colors consist of red, green, and blue channels of color that are added\ntogether to represent the colors we see on the screen.\n\nhttps://en.wikipedia.org/wiki/RGB_color_model\n\nYCbCr colors represent colors as a Y luma brightness component and red and\nblue chroma color offsets. This color representation takes advantage of the\nfact that the human eye is more sensitive to brightness than the color in\nan image. The Cb and Cr components are often compressed and have lower\nresolution than the luma component.\n\nhttps://en.wikipedia.org/wiki/YCbCr\n\nWhen the color information in YCbCr is compressed, the Y pixels are left at\nfull resolution and each Cr and Cb pixel represents an average of the color\ninformation in a block of Y pixels. The chroma location determines where in\nthat block of pixels the color information is coming from.\n\nThe color range defines how much of the pixel to use when converting a\npixel into a color on the display. When the full color range is used, the\nentire numeric range of the pixel bits is significant. When narrow color\nrange is used, for historical reasons, the pixel uses only a portion of the\nnumeric range to represent colors.\n\nThe color primaries and white point are a definition of the colors in the\ncolor space relative to the standard XYZ color space.\n\nhttps://en.wikipedia.org/wiki/CIE_1931_color_space\n\nThe transfer characteristic, or opto-electrical transfer function (OETF),\nis the way a color is converted from mathematically linear space into a\nnon-linear output signals.\n\nhttps://en.wikipedia.org/wiki/Rec._709#Transfer_characteristics\n\nThe matrix coefficients are used to convert between YCbCr and RGB colors.",
      "entries": {
        "Palette-forward": {
          "name": "Palette",
          "kind": "forward",
          "doc": ""
        },
        "PaletteRaw": {
          "name": "PaletteRaw",
          "kind": "alias",
          "type": "SDL_Palette *",
          "doc": ""
        },
        "PaletteParam": {
          "name": "PaletteParam",
          "kind": "struct",
          "doc": "Safely wrap Palette for non owning parameters",
          "entries": {
            "value": {
              "kind": "var",
              "name": "value",
              "type": "PaletteRaw",
              "doc": ""
            },
            "PaletteParam": [
              {
                "kind": "function",
                "name": "PaletteParam",
                "constexpr": true,
                "type": "",
                "parameters": [
                  {
                    "type": "PaletteRaw",
                    "name": "value"
                  }
                ],
                "hints": {
                  "init": [
                    "value(value)"
                  ]
                },
                "doc": ""
              },
              {
                "kind": "function",
                "name": "PaletteParam",
                "constexpr": true,
                "type": "",
                "parameters": [
                  {
                    "type": "std::nullptr_t",
                    "name": "_"
                  }
                ],
                "hints": {
                  "init": [
                    "value(nullptr)"
                  ]
                },
                "doc": ""
              }
            ],
            "operator PaletteRaw": {
              "kind": "function",
              "name": "operator PaletteRaw",
              "constexpr": true,
              "immutable": true,
              "type": "",
              "parameters": [],
              "hints": {
                "body": "return value;"
              },
              "doc": ""
            }
          }
        },
        "PaletteConstParam": {
          "name": "PaletteConstParam",
          "kind": "struct",
          "doc": "Safely wrap Palette for non owning const parameters",
          "entries": {
            "value": {
              "kind": "var",
              "name": "value",
              "type": "const PaletteRaw",
              "doc": ""
            },
            "PaletteConstParam": [
              {
                "kind": "function",
                "name": "PaletteConstParam",
                "constexpr": true,
                "type": "",
                "parameters": [
                  {
                    "type": "const PaletteRaw",
                    "name": "value"
                  }
                ],
                "hints": {
                  "init": [
                    "value(value)"
                  ]
                },
                "doc": ""
              },
              {
                "kind": "function",
                "name": "PaletteConstParam",
                "constexpr": true,
                "type": "",
                "parameters": [
                  {
                    "type": "PaletteParam",
                    "name": "value"
                  }
                ],
                "hints": {
                  "init": [
                    "value(value.value)"
                  ]
                },
                "doc": ""
              },
              {
                "kind": "function",
                "name": "PaletteConstParam",
                "constexpr": true,
                "type": "",
                "parameters": [
                  {
                    "type": "std::nullptr_t",
                    "name": "_"
                  }
                ],
                "hints": {
                  "init": [
                    "value(nullptr)"
                  ]
                },
                "doc": ""
              }
            ],
            "operator const PaletteRaw": {
              "kind": "function",
              "name": "operator const PaletteRaw",
              "constexpr": true,
              "immutable": true,
              "type": "",
              "parameters": [],
              "hints": {
                "body": "return value;"
              },
              "doc": ""
            }
          }
        },
        "PixelFormatRaw": {
          "name": "PixelFormatRaw",
          "kind": "alias",
          "type": "SDL_PixelFormat",
          "doc": ""
        },
        "ColorRaw": {
          "name": "ColorRaw",
          "kind": "alias",
          "type": "SDL_Color",
          "doc": ""
        },
        "FColorRaw": {
          "name": "FColorRaw",
          "kind": "alias",
          "type": "SDL_FColor",
          "doc": ""
        },
        "Color-forward": {
          "kind": "forward",
          "name": "Color",
          "doc": ""
        },
        "PixelFormatDetails": {
          "doc": "Details about the format of a pixel.\n\n@since This struct is available since SDL 3.2.0.",
          "name": "PixelFormatDetails",
          "kind": "alias",
          "sourceName": "SDL_PixelFormatDetails",
          "type": "SDL_PixelFormatDetails",
          "after": "__begin"
        },
        "SDL_ALPHA_OPAQUE": {
          "doc": "A fully opaque 8-bit alpha value.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_ALPHA_TRANSPARENT",
          "name": "SDL_ALPHA_OPAQUE",
          "kind": "def",
          "value": "255",
          "sourceName": "SDL_ALPHA_OPAQUE"
        },
        "SDL_ALPHA_OPAQUE_FLOAT": {
          "doc": "A fully opaque floating point alpha value.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_ALPHA_TRANSPARENT_FLOAT",
          "name": "SDL_ALPHA_OPAQUE_FLOAT",
          "kind": "def",
          "value": "1.0f",
          "sourceName": "SDL_ALPHA_OPAQUE_FLOAT"
        },
        "SDL_ALPHA_TRANSPARENT": {
          "doc": "A fully transparent 8-bit alpha value.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_ALPHA_OPAQUE",
          "name": "SDL_ALPHA_TRANSPARENT",
          "kind": "def",
          "value": "0",
          "sourceName": "SDL_ALPHA_TRANSPARENT"
        },
        "SDL_ALPHA_TRANSPARENT_FLOAT": {
          "doc": "A fully transparent floating point alpha value.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_ALPHA_OPAQUE_FLOAT",
          "name": "SDL_ALPHA_TRANSPARENT_FLOAT",
          "kind": "def",
          "value": "0.0f",
          "sourceName": "SDL_ALPHA_TRANSPARENT_FLOAT"
        },
        "PixelType": {
          "doc": "Pixel type.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "PixelType",
          "kind": "alias",
          "sourceName": "SDL_PixelType",
          "type": "SDL_PixelType"
        },
        "PIXELTYPE_UNKNOWN": {
          "kind": "var",
          "name": "PIXELTYPE_UNKNOWN",
          "constexpr": true,
          "type": "PixelType",
          "doc": "UNKNOWN",
          "sourceName": "SDL_PIXELTYPE_UNKNOWN"
        },
        "PIXELTYPE_INDEX1": {
          "kind": "var",
          "name": "PIXELTYPE_INDEX1",
          "constexpr": true,
          "type": "PixelType",
          "doc": "INDEX1",
          "sourceName": "SDL_PIXELTYPE_INDEX1"
        },
        "PIXELTYPE_INDEX4": {
          "kind": "var",
          "name": "PIXELTYPE_INDEX4",
          "constexpr": true,
          "type": "PixelType",
          "doc": "INDEX4",
          "sourceName": "SDL_PIXELTYPE_INDEX4"
        },
        "PIXELTYPE_INDEX8": {
          "kind": "var",
          "name": "PIXELTYPE_INDEX8",
          "constexpr": true,
          "type": "PixelType",
          "doc": "INDEX8",
          "sourceName": "SDL_PIXELTYPE_INDEX8"
        },
        "PIXELTYPE_PACKED8": {
          "kind": "var",
          "name": "PIXELTYPE_PACKED8",
          "constexpr": true,
          "type": "PixelType",
          "doc": "PACKED8",
          "sourceName": "SDL_PIXELTYPE_PACKED8"
        },
        "PIXELTYPE_PACKED16": {
          "kind": "var",
          "name": "PIXELTYPE_PACKED16",
          "constexpr": true,
          "type": "PixelType",
          "doc": "PACKED16",
          "sourceName": "SDL_PIXELTYPE_PACKED16"
        },
        "PIXELTYPE_PACKED32": {
          "kind": "var",
          "name": "PIXELTYPE_PACKED32",
          "constexpr": true,
          "type": "PixelType",
          "doc": "PACKED32",
          "sourceName": "SDL_PIXELTYPE_PACKED32"
        },
        "PIXELTYPE_ARRAYU8": {
          "kind": "var",
          "name": "PIXELTYPE_ARRAYU8",
          "constexpr": true,
          "type": "PixelType",
          "doc": "ARRAYU8",
          "sourceName": "SDL_PIXELTYPE_ARRAYU8"
        },
        "PIXELTYPE_ARRAYU16": {
          "kind": "var",
          "name": "PIXELTYPE_ARRAYU16",
          "constexpr": true,
          "type": "PixelType",
          "doc": "ARRAYU16",
          "sourceName": "SDL_PIXELTYPE_ARRAYU16"
        },
        "PIXELTYPE_ARRAYU32": {
          "kind": "var",
          "name": "PIXELTYPE_ARRAYU32",
          "constexpr": true,
          "type": "PixelType",
          "doc": "ARRAYU32",
          "sourceName": "SDL_PIXELTYPE_ARRAYU32"
        },
        "PIXELTYPE_ARRAYF16": {
          "kind": "var",
          "name": "PIXELTYPE_ARRAYF16",
          "constexpr": true,
          "type": "PixelType",
          "doc": "ARRAYF16",
          "sourceName": "SDL_PIXELTYPE_ARRAYF16"
        },
        "PIXELTYPE_ARRAYF32": {
          "kind": "var",
          "name": "PIXELTYPE_ARRAYF32",
          "constexpr": true,
          "type": "PixelType",
          "doc": "ARRAYF32",
          "sourceName": "SDL_PIXELTYPE_ARRAYF32"
        },
        "PIXELTYPE_INDEX2": {
          "kind": "var",
          "name": "PIXELTYPE_INDEX2",
          "constexpr": true,
          "type": "PixelType",
          "doc": "INDEX2",
          "sourceName": "SDL_PIXELTYPE_INDEX2"
        },
        "BitmapOrder": {
          "doc": "Bitmap pixel order, high bit -> low bit.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "BitmapOrder",
          "kind": "alias",
          "sourceName": "SDL_BitmapOrder",
          "type": "SDL_BitmapOrder"
        },
        "BITMAPORDER_NONE": {
          "kind": "var",
          "name": "BITMAPORDER_NONE",
          "constexpr": true,
          "type": "BitmapOrder",
          "doc": "NONE",
          "sourceName": "SDL_BITMAPORDER_NONE"
        },
        "BITMAPORDER_4321": {
          "kind": "var",
          "name": "BITMAPORDER_4321",
          "constexpr": true,
          "type": "BitmapOrder",
          "doc": "4321",
          "sourceName": "SDL_BITMAPORDER_4321"
        },
        "BITMAPORDER_1234": {
          "kind": "var",
          "name": "BITMAPORDER_1234",
          "constexpr": true,
          "type": "BitmapOrder",
          "doc": "1234",
          "sourceName": "SDL_BITMAPORDER_1234"
        },
        "PackedOrder": {
          "doc": "Packed component order, high bit -> low bit.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "PackedOrder",
          "kind": "alias",
          "sourceName": "SDL_PackedOrder",
          "type": "SDL_PackedOrder"
        },
        "PACKEDORDER_NONE": {
          "kind": "var",
          "name": "PACKEDORDER_NONE",
          "constexpr": true,
          "type": "PackedOrder",
          "doc": "NONE",
          "sourceName": "SDL_PACKEDORDER_NONE"
        },
        "PACKEDORDER_XRGB": {
          "kind": "var",
          "name": "PACKEDORDER_XRGB",
          "constexpr": true,
          "type": "PackedOrder",
          "doc": "XRGB",
          "sourceName": "SDL_PACKEDORDER_XRGB"
        },
        "PACKEDORDER_RGBX": {
          "kind": "var",
          "name": "PACKEDORDER_RGBX",
          "constexpr": true,
          "type": "PackedOrder",
          "doc": "RGBX",
          "sourceName": "SDL_PACKEDORDER_RGBX"
        },
        "PACKEDORDER_ARGB": {
          "kind": "var",
          "name": "PACKEDORDER_ARGB",
          "constexpr": true,
          "type": "PackedOrder",
          "doc": "ARGB",
          "sourceName": "SDL_PACKEDORDER_ARGB"
        },
        "PACKEDORDER_RGBA": {
          "kind": "var",
          "name": "PACKEDORDER_RGBA",
          "constexpr": true,
          "type": "PackedOrder",
          "doc": "RGBA",
          "sourceName": "SDL_PACKEDORDER_RGBA"
        },
        "PACKEDORDER_XBGR": {
          "kind": "var",
          "name": "PACKEDORDER_XBGR",
          "constexpr": true,
          "type": "PackedOrder",
          "doc": "XBGR",
          "sourceName": "SDL_PACKEDORDER_XBGR"
        },
        "PACKEDORDER_BGRX": {
          "kind": "var",
          "name": "PACKEDORDER_BGRX",
          "constexpr": true,
          "type": "PackedOrder",
          "doc": "BGRX",
          "sourceName": "SDL_PACKEDORDER_BGRX"
        },
        "PACKEDORDER_ABGR": {
          "kind": "var",
          "name": "PACKEDORDER_ABGR",
          "constexpr": true,
          "type": "PackedOrder",
          "doc": "ABGR",
          "sourceName": "SDL_PACKEDORDER_ABGR"
        },
        "PACKEDORDER_BGRA": {
          "kind": "var",
          "name": "PACKEDORDER_BGRA",
          "constexpr": true,
          "type": "PackedOrder",
          "doc": "BGRA",
          "sourceName": "SDL_PACKEDORDER_BGRA"
        },
        "ArrayOrder": {
          "doc": "Array component order, low byte -> high byte.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "ArrayOrder",
          "kind": "alias",
          "sourceName": "SDL_ArrayOrder",
          "type": "SDL_ArrayOrder"
        },
        "ARRAYORDER_NONE": {
          "kind": "var",
          "name": "ARRAYORDER_NONE",
          "constexpr": true,
          "type": "ArrayOrder",
          "doc": "NONE",
          "sourceName": "SDL_ARRAYORDER_NONE"
        },
        "ARRAYORDER_RGB": {
          "kind": "var",
          "name": "ARRAYORDER_RGB",
          "constexpr": true,
          "type": "ArrayOrder",
          "doc": "RGB",
          "sourceName": "SDL_ARRAYORDER_RGB"
        },
        "ARRAYORDER_RGBA": {
          "kind": "var",
          "name": "ARRAYORDER_RGBA",
          "constexpr": true,
          "type": "ArrayOrder",
          "doc": "RGBA",
          "sourceName": "SDL_ARRAYORDER_RGBA"
        },
        "ARRAYORDER_ARGB": {
          "kind": "var",
          "name": "ARRAYORDER_ARGB",
          "constexpr": true,
          "type": "ArrayOrder",
          "doc": "ARGB",
          "sourceName": "SDL_ARRAYORDER_ARGB"
        },
        "ARRAYORDER_BGR": {
          "kind": "var",
          "name": "ARRAYORDER_BGR",
          "constexpr": true,
          "type": "ArrayOrder",
          "doc": "BGR",
          "sourceName": "SDL_ARRAYORDER_BGR"
        },
        "ARRAYORDER_BGRA": {
          "kind": "var",
          "name": "ARRAYORDER_BGRA",
          "constexpr": true,
          "type": "ArrayOrder",
          "doc": "BGRA",
          "sourceName": "SDL_ARRAYORDER_BGRA"
        },
        "ARRAYORDER_ABGR": {
          "kind": "var",
          "name": "ARRAYORDER_ABGR",
          "constexpr": true,
          "type": "ArrayOrder",
          "doc": "ABGR",
          "sourceName": "SDL_ARRAYORDER_ABGR"
        },
        "PackedLayout": {
          "doc": "Packed component layout.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "PackedLayout",
          "kind": "alias",
          "sourceName": "SDL_PackedLayout",
          "type": "SDL_PackedLayout"
        },
        "PACKEDLAYOUT_NONE": {
          "kind": "var",
          "name": "PACKEDLAYOUT_NONE",
          "constexpr": true,
          "type": "PackedLayout",
          "doc": "NONE",
          "sourceName": "SDL_PACKEDLAYOUT_NONE"
        },
        "PACKEDLAYOUT_332": {
          "kind": "var",
          "name": "PACKEDLAYOUT_332",
          "constexpr": true,
          "type": "PackedLayout",
          "doc": "332",
          "sourceName": "SDL_PACKEDLAYOUT_332"
        },
        "PACKEDLAYOUT_4444": {
          "kind": "var",
          "name": "PACKEDLAYOUT_4444",
          "constexpr": true,
          "type": "PackedLayout",
          "doc": "4444",
          "sourceName": "SDL_PACKEDLAYOUT_4444"
        },
        "PACKEDLAYOUT_1555": {
          "kind": "var",
          "name": "PACKEDLAYOUT_1555",
          "constexpr": true,
          "type": "PackedLayout",
          "doc": "1555",
          "sourceName": "SDL_PACKEDLAYOUT_1555"
        },
        "PACKEDLAYOUT_5551": {
          "kind": "var",
          "name": "PACKEDLAYOUT_5551",
          "constexpr": true,
          "type": "PackedLayout",
          "doc": "5551",
          "sourceName": "SDL_PACKEDLAYOUT_5551"
        },
        "PACKEDLAYOUT_565": {
          "kind": "var",
          "name": "PACKEDLAYOUT_565",
          "constexpr": true,
          "type": "PackedLayout",
          "doc": "565",
          "sourceName": "SDL_PACKEDLAYOUT_565"
        },
        "PACKEDLAYOUT_8888": {
          "kind": "var",
          "name": "PACKEDLAYOUT_8888",
          "constexpr": true,
          "type": "PackedLayout",
          "doc": "8888",
          "sourceName": "SDL_PACKEDLAYOUT_8888"
        },
        "PACKEDLAYOUT_2101010": {
          "kind": "var",
          "name": "PACKEDLAYOUT_2101010",
          "constexpr": true,
          "type": "PackedLayout",
          "doc": "2101010",
          "sourceName": "SDL_PACKEDLAYOUT_2101010"
        },
        "PACKEDLAYOUT_1010102": {
          "kind": "var",
          "name": "PACKEDLAYOUT_1010102",
          "constexpr": true,
          "type": "PackedLayout",
          "doc": "1010102",
          "sourceName": "SDL_PACKEDLAYOUT_1010102"
        },
        "SDL_DEFINE_PIXELFOURCC": {
          "doc": "A macro for defining custom FourCC pixel formats.\n\nFor example, defining PIXELFORMAT_YV12 looks like this:\n\n```c\nSDL_DEFINE_PIXELFOURCC('Y', 'V', '1', '2')\n```\n\n@param A the first character of the FourCC code.\n@param B the second character of the FourCC code.\n@param C the third character of the FourCC code.\n@param D the fourth character of the FourCC code.\n@returns a format value in the style of PixelFormat.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_DEFINE_PIXELFOURCC",
          "kind": "def",
          "parameters": [
            "A",
            "B",
            "C",
            "D"
          ],
          "value": "SDL_FOURCC(A, B, C, D)",
          "sourceName": "SDL_DEFINE_PIXELFOURCC"
        },
        "SDL_DEFINE_PIXELFORMAT": {
          "doc": "A macro for defining custom non-FourCC pixel formats.\n\nFor example, defining PIXELFORMAT_RGBA8888 looks like this:\n\n```c\nSDL_DEFINE_PIXELFORMAT(PIXELTYPE_PACKED32, PACKEDORDER_RGBA, PACKEDLAYOUT_8888, 32, 4)\n```\n\n@param type the type of the new format, probably a PixelType value.\n@param order the order of the new format, probably a BitmapOrder,\n             PackedOrder, or ArrayOrder value.\n@param layout the layout of the new format, probably an PackedLayout\n              value or zero.\n@param bits the number of bits per pixel of the new format.\n@param bytes the number of bytes per pixel of the new format.\n@returns a format value in the style of PixelFormat.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_DEFINE_PIXELFORMAT",
          "kind": "def",
          "parameters": [
            "type",
            "order",
            "layout",
            "bits",
            "bytes"
          ],
          "value": "    ((1 << 28) | ((type) << 24) | ((order) << 20) | ((layout) << 16) | \\\n     ((bits) << 8) | ((bytes) << 0))",
          "sourceName": "SDL_DEFINE_PIXELFORMAT"
        },
        "SDL_PIXELFLAG": {
          "doc": "A macro to retrieve the flags of an PixelFormat.\n\nThis macro is generally not needed directly by an app, which should use\nspecific tests, like SDL_ISPIXELFORMAT_FOURCC, instead.\n\n@param format an PixelFormat to check.\n@returns the flags of `format`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_PIXELFLAG",
          "kind": "def",
          "parameters": [
            "format"
          ],
          "value": "(((format) >> 28) & 0x0F)",
          "sourceName": "SDL_PIXELFLAG"
        },
        "SDL_PIXELTYPE": {
          "doc": "A macro to retrieve the type of an PixelFormat.\n\nThis is usually a value from the PixelType enumeration.\n\n@param format an PixelFormat to check.\n@returns the type of `format`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_PIXELTYPE",
          "kind": "def",
          "parameters": [
            "format"
          ],
          "value": "(((format) >> 24) & 0x0F)",
          "sourceName": "SDL_PIXELTYPE"
        },
        "SDL_PIXELORDER": {
          "doc": "A macro to retrieve the order of an PixelFormat.\n\nThis is usually a value from the BitmapOrder, PackedOrder, or\nArrayOrder enumerations, depending on the format type.\n\n@param format an PixelFormat to check.\n@returns the order of `format`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_PIXELORDER",
          "kind": "def",
          "parameters": [
            "format"
          ],
          "value": "(((format) >> 20) & 0x0F)",
          "sourceName": "SDL_PIXELORDER"
        },
        "SDL_PIXELLAYOUT": {
          "doc": "A macro to retrieve the layout of an PixelFormat.\n\nThis is usually a value from the PackedLayout enumeration, or zero if a\nlayout doesn't make sense for the format type.\n\n@param format an PixelFormat to check.\n@returns the layout of `format`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_PIXELLAYOUT",
          "kind": "def",
          "parameters": [
            "format"
          ],
          "value": "(((format) >> 16) & 0x0F)",
          "sourceName": "SDL_PIXELLAYOUT"
        },
        "SDL_BITSPERPIXEL": {
          "doc": "A macro to determine an PixelFormat's bits per pixel.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\nFourCC formats will report zero here, as it rarely makes sense to measure\nthem per-pixel.\n\n@param format an PixelFormat to check.\n@returns the bits-per-pixel of `format`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_BYTESPERPIXEL",
          "name": "SDL_BITSPERPIXEL",
          "kind": "def",
          "parameters": [
            "format"
          ],
          "value": "    (SDL_ISPIXELFORMAT_FOURCC(format) ? 0 : (((format) >> 8) & 0xFF))",
          "sourceName": "SDL_BITSPERPIXEL"
        },
        "SDL_BYTESPERPIXEL": {
          "doc": "A macro to determine an PixelFormat's bytes per pixel.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\nFourCC formats do their best here, but many of them don't have a meaningful\nmeasurement of bytes per pixel.\n\n@param format an PixelFormat to check.\n@returns the bytes-per-pixel of `format`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.\n\n@sa SDL_BITSPERPIXEL",
          "name": "SDL_BYTESPERPIXEL",
          "kind": "def",
          "parameters": [
            "format"
          ],
          "value": "    (SDL_ISPIXELFORMAT_FOURCC(format) ? \\\n        ((((format) == SDL_PIXELFORMAT_YUY2) || \\\n          ((format) == SDL_PIXELFORMAT_UYVY) || \\\n          ((format) == SDL_PIXELFORMAT_YVYU) || \\\n          ((format) == SDL_PIXELFORMAT_P010)) ? 2 : 1) : (((format) >> 0) & 0xFF))",
          "sourceName": "SDL_BYTESPERPIXEL"
        },
        "SDL_ISPIXELFORMAT_INDEXED": {
          "doc": "A macro to determine if an PixelFormat is an indexed format.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n@param format an PixelFormat to check.\n@returns true if the format is indexed, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISPIXELFORMAT_INDEXED",
          "kind": "def",
          "parameters": [
            "format"
          ],
          "value": "    (!SDL_ISPIXELFORMAT_FOURCC(format) && \\\n     ((SDL_PIXELTYPE(format) == SDL_PIXELTYPE_INDEX1) || \\\n      (SDL_PIXELTYPE(format) == SDL_PIXELTYPE_INDEX2) || \\\n      (SDL_PIXELTYPE(format) == SDL_PIXELTYPE_INDEX4) || \\\n      (SDL_PIXELTYPE(format) == SDL_PIXELTYPE_INDEX8)))",
          "sourceName": "SDL_ISPIXELFORMAT_INDEXED"
        },
        "SDL_ISPIXELFORMAT_PACKED": {
          "doc": "A macro to determine if an PixelFormat is a packed format.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n@param format an PixelFormat to check.\n@returns true if the format is packed, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISPIXELFORMAT_PACKED",
          "kind": "def",
          "parameters": [
            "format"
          ],
          "value": "    (!SDL_ISPIXELFORMAT_FOURCC(format) && \\\n     ((SDL_PIXELTYPE(format) == SDL_PIXELTYPE_PACKED8) || \\\n      (SDL_PIXELTYPE(format) == SDL_PIXELTYPE_PACKED16) || \\\n      (SDL_PIXELTYPE(format) == SDL_PIXELTYPE_PACKED32)))",
          "sourceName": "SDL_ISPIXELFORMAT_PACKED"
        },
        "SDL_ISPIXELFORMAT_ARRAY": {
          "doc": "A macro to determine if an PixelFormat is an array format.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n@param format an PixelFormat to check.\n@returns true if the format is an array, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISPIXELFORMAT_ARRAY",
          "kind": "def",
          "parameters": [
            "format"
          ],
          "value": "    (!SDL_ISPIXELFORMAT_FOURCC(format) && \\\n     ((SDL_PIXELTYPE(format) == SDL_PIXELTYPE_ARRAYU8) || \\\n      (SDL_PIXELTYPE(format) == SDL_PIXELTYPE_ARRAYU16) || \\\n      (SDL_PIXELTYPE(format) == SDL_PIXELTYPE_ARRAYU32) || \\\n      (SDL_PIXELTYPE(format) == SDL_PIXELTYPE_ARRAYF16) || \\\n      (SDL_PIXELTYPE(format) == SDL_PIXELTYPE_ARRAYF32)))",
          "sourceName": "SDL_ISPIXELFORMAT_ARRAY"
        },
        "SDL_ISPIXELFORMAT_10BIT": {
          "doc": "A macro to determine if an PixelFormat is a 10-bit format.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n@param format an PixelFormat to check.\n@returns true if the format is 10-bit, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISPIXELFORMAT_10BIT",
          "kind": "def",
          "parameters": [
            "format"
          ],
          "value": "      (!SDL_ISPIXELFORMAT_FOURCC(format) && \\\n       ((SDL_PIXELTYPE(format) == SDL_PIXELTYPE_PACKED32) && \\\n        (SDL_PIXELLAYOUT(format) == SDL_PACKEDLAYOUT_2101010)))",
          "sourceName": "SDL_ISPIXELFORMAT_10BIT"
        },
        "SDL_ISPIXELFORMAT_FLOAT": {
          "doc": "A macro to determine if an PixelFormat is a floating point format.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n@param format an PixelFormat to check.\n@returns true if the format is 10-bit, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISPIXELFORMAT_FLOAT",
          "kind": "def",
          "parameters": [
            "format"
          ],
          "value": "      (!SDL_ISPIXELFORMAT_FOURCC(format) && \\\n       ((SDL_PIXELTYPE(format) == SDL_PIXELTYPE_ARRAYF16) || \\\n        (SDL_PIXELTYPE(format) == SDL_PIXELTYPE_ARRAYF32)))",
          "sourceName": "SDL_ISPIXELFORMAT_FLOAT"
        },
        "SDL_ISPIXELFORMAT_ALPHA": {
          "doc": "A macro to determine if an PixelFormat has an alpha channel.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n@param format an PixelFormat to check.\n@returns true if the format has alpha, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISPIXELFORMAT_ALPHA",
          "kind": "def",
          "parameters": [
            "format"
          ],
          "value": "    ((SDL_ISPIXELFORMAT_PACKED(format) && \\\n      ((SDL_PIXELORDER(format) == SDL_PACKEDORDER_ARGB) || \\\n       (SDL_PIXELORDER(format) == SDL_PACKEDORDER_RGBA) || \\\n       (SDL_PIXELORDER(format) == SDL_PACKEDORDER_ABGR) || \\\n       (SDL_PIXELORDER(format) == SDL_PACKEDORDER_BGRA))) || \\\n     (SDL_ISPIXELFORMAT_ARRAY(format) && \\\n      ((SDL_PIXELORDER(format) == SDL_ARRAYORDER_ARGB) || \\\n       (SDL_PIXELORDER(format) == SDL_ARRAYORDER_RGBA) || \\\n       (SDL_PIXELORDER(format) == SDL_ARRAYORDER_ABGR) || \\\n       (SDL_PIXELORDER(format) == SDL_ARRAYORDER_BGRA))))",
          "sourceName": "SDL_ISPIXELFORMAT_ALPHA"
        },
        "SDL_ISPIXELFORMAT_FOURCC": {
          "doc": "A macro to determine if an PixelFormat is a \"FourCC\" format.\n\nThis covers custom and other unusual formats.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n@param format an PixelFormat to check.\n@returns true if the format has alpha, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISPIXELFORMAT_FOURCC",
          "kind": "def",
          "parameters": [
            "format"
          ],
          "value": "    /* The flag is set to 1 because 0x1? is not in the printable ASCII range */ \\\n    ((format) && (SDL_PIXELFLAG(format) != 1))",
          "sourceName": "SDL_ISPIXELFORMAT_FOURCC"
        },
        "PixelFormat": {
          "doc": "Pixel format.\n\nSDL's pixel formats have the following naming convention:\n\n- Names with a list of components and a single bit count, such as RGB24 and\n  ABGR32, define a platform-independent encoding into bytes in the order\n  specified. For example, in RGB24 data, each pixel is encoded in 3 bytes\n  (red, green, blue) in that order, and in ABGR32 data, each pixel is\n  encoded in 4 bytes (alpha, blue, green, red) in that order. Use these\n  names if the property of a format that is important to you is the order\n  of the bytes in memory or on disk.\n- Names with a bit count per component, such as ARGB8888 and XRGB1555, are\n  \"packed\" into an appropriately-sized integer in the platform's native\n  endianness. For example, ARGB8888 is a sequence of 32-bit integers; in\n  each integer, the most significant bits are alpha, and the least\n  significant bits are blue. On a little-endian CPU such as x86, the least\n  significant bits of each integer are arranged first in memory, but on a\n  big-endian CPU such as s390x, the most significant bits are arranged\n  first. Use these names if the property of a format that is important to\n  you is the meaning of each bit position within a native-endianness\n  integer.\n- In indexed formats such as INDEX4LSB, each pixel is represented by\n  encoding an index into the palette into the indicated number of bits,\n  with multiple pixels packed into each byte if appropriate. In LSB\n  formats, the first (leftmost) pixel is stored in the least-significant\n  bits of the byte; in MSB formats, it's stored in the most-significant\n  bits. INDEX8 does not need LSB/MSB variants, because each pixel exactly\n  fills one byte.\n\nThe 32-bit byte-array encodings such as RGBA32 are aliases for the\nappropriate 8888 encoding for the current platform. For example, RGBA32 is\nan alias for ABGR8888 on little-endian CPUs like x86, or an alias for\nRGBA8888 on big-endian CPUs.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "PixelFormat",
          "kind": "struct",
          "sourceName": "SDL_PixelFormat",
          "entries": {
            "m_format": {
              "kind": "var",
              "name": "m_format",
              "type": "SDL_PixelFormat",
              "doc": ""
            },
            "PixelFormat": {
              "kind": "function",
              "name": "PixelFormat",
              "type": "",
              "constexpr": true,
              "parameters": [
                {
                  "type": "SDL_PixelFormat",
                  "name": "format",
                  "default": "{}"
                }
              ],
              "doc": "Wraps PixelFormat.\n\n@param format the value to be wrapped",
              "hints": {
                "init": [
                  "m_format(format)"
                ]
              }
            },
            "operator==": [
              {
                "kind": "function",
                "name": "operator==",
                "type": "bool",
                "constexpr": true,
                "immutable": true,
                "parameters": [
                  {
                    "type": "const PixelFormat &",
                    "name": "other"
                  }
                ],
                "doc": "Default comparison operator",
                "hints": {
                  "default": true
                }
              },
              {
                "kind": "function",
                "name": "operator==",
                "type": "bool",
                "constexpr": true,
                "immutable": true,
                "parameters": [
                  {
                    "type": "SDL_PixelFormat",
                    "name": "format"
                  }
                ],
                "doc": "Compares with the underlying type",
                "hints": {
                  "body": "return operator==(PixelFormat(format));"
                }
              }
            ],
            "operator SDL_PixelFormat": {
              "kind": "function",
              "name": "operator SDL_PixelFormat",
              "type": "",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Unwraps to the underlying PixelFormat.\n\n@returns the underlying PixelFormat.",
              "hints": {
                "body": "return m_format;"
              }
            },
            "operator bool": {
              "kind": "function",
              "name": "operator bool",
              "type": "",
              "constexpr": true,
              "explicit": true,
              "immutable": true,
              "parameters": [],
              "doc": "Check if valid.\n\n@returns True if valid state, false otherwise.",
              "hints": {
                "body": "return m_format != 0;"
              }
            },
            "GetType": {
              "name": "GetType",
              "kind": "def",
              "doc": ""
            },
            "GetOrder": {
              "name": "GetOrder",
              "kind": "def",
              "doc": ""
            },
            "GetLayout": {
              "name": "GetLayout",
              "kind": "def",
              "doc": ""
            },
            "GetBitsPerPixel": {
              "name": "GetBitsPerPixel",
              "kind": "def",
              "doc": ""
            },
            "GetBytesPerPixel": {
              "name": "GetBytesPerPixel",
              "kind": "def",
              "doc": ""
            },
            "IsIndexed": {
              "name": "IsIndexed",
              "kind": "def",
              "doc": ""
            },
            "IsPacked": {
              "name": "IsPacked",
              "kind": "def",
              "doc": ""
            },
            "IsArray": {
              "name": "IsArray",
              "kind": "def",
              "doc": ""
            },
            "Is10Bit": {
              "name": "Is10Bit",
              "kind": "def",
              "doc": ""
            },
            "IsFloat": {
              "name": "IsFloat",
              "kind": "def",
              "doc": ""
            },
            "IsAlpha": {
              "name": "IsAlpha",
              "kind": "def",
              "doc": ""
            },
            "IsFourCC": {
              "name": "IsFourCC",
              "kind": "def",
              "doc": ""
            },
            "GetName": {
              "doc": "Get the human readable name of a pixel format.\n\n@returns the human readable name of the specified pixel format or\n         \"PIXELFORMAT_UNKNOWN\" if the format isn't recognized.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetName",
              "kind": "function",
              "type": "const char *",
              "parameters": [],
              "sourceName": "SDL_GetPixelFormatName",
              "immutable": true
            },
            "GetMasks": {
              "doc": "Convert one of the enumerated pixel formats to a bpp value and RGBA masks.\n\n@param bpp a bits per pixel value; usually 15, 16, or 32.\n@param Rmask a pointer filled in with the red mask for the format.\n@param Gmask a pointer filled in with the green mask for the format.\n@param Bmask a pointer filled in with the blue mask for the format.\n@param Amask a pointer filled in with the alpha mask for the format.\n@throws Error on failure.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PixelFormat.ForMasks",
              "name": "GetMasks",
              "kind": "function",
              "type": "void",
              "parameters": [
                {
                  "name": "bpp",
                  "type": "int *"
                },
                {
                  "name": "Rmask",
                  "type": "Uint32 *"
                },
                {
                  "name": "Gmask",
                  "type": "Uint32 *"
                },
                {
                  "name": "Bmask",
                  "type": "Uint32 *"
                },
                {
                  "name": "Amask",
                  "type": "Uint32 *"
                }
              ],
              "sourceName": "SDL_GetMasksForPixelFormat",
              "hints": {
                "mayFail": true
              },
              "immutable": true
            },
            "ForMasks": {
              "doc": "Convert a bpp value and RGBA masks to an enumerated pixel format.\n\nThis will return `PIXELFORMAT_UNKNOWN` if the conversion wasn't\npossible.\n\n@param bpp a bits per pixel value; usually 15, 16, or 32.\n@param Rmask the red mask for the format.\n@param Gmask the green mask for the format.\n@param Bmask the blue mask for the format.\n@param Amask the alpha mask for the format.\n@returns the PixelFormat value corresponding to the format masks, or\n         PIXELFORMAT_UNKNOWN if there isn't a match.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PixelFormat.GetMasks",
              "name": "ForMasks",
              "kind": "function",
              "type": "PixelFormat",
              "parameters": [
                {
                  "name": "bpp",
                  "type": "int"
                },
                {
                  "name": "Rmask",
                  "type": "Uint32"
                },
                {
                  "name": "Gmask",
                  "type": "Uint32"
                },
                {
                  "name": "Bmask",
                  "type": "Uint32"
                },
                {
                  "name": "Amask",
                  "type": "Uint32"
                }
              ],
              "sourceName": "SDL_GetPixelFormatForMasks",
              "static": true
            },
            "GetDetails": {
              "doc": "Create an PixelFormatDetails structure corresponding to a pixel format.\n\nReturned structure may come from a shared global cache (i.e. not newly\nallocated), and hence should not be modified, especially the palette. Weird\nerrors such as `Blit combination not supported` may occur.\n\n@returns a pointer to a PixelFormatDetails structure or nullptr on\n         failure; call GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetDetails",
              "kind": "function",
              "type": "const PixelFormatDetails *",
              "parameters": [],
              "sourceName": "SDL_GetPixelFormatDetails",
              "immutable": true
            },
            "Map": {
              "kind": "function",
              "type": "Uint32",
              "immutable": true,
              "proto": true,
              "parameters": [
                {
                  "type": "Color",
                  "name": "color"
                },
                {
                  "type": "PaletteConstParam",
                  "name": "palette"
                }
              ],
              "name": "Map",
              "doc": ""
            },
            "Get": {
              "kind": "function",
              "type": "Color",
              "immutable": true,
              "proto": true,
              "parameters": [
                {
                  "type": "Uint32",
                  "name": "pixel"
                },
                {
                  "type": "PaletteConstParam",
                  "name": "palette"
                }
              ],
              "name": "Get",
              "doc": ""
            }
          },
          "hints": {
            "self": "m_format"
          },
          "type": ""
        },
        "PIXELFORMAT_UNKNOWN": {
          "kind": "var",
          "name": "PIXELFORMAT_UNKNOWN",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "UNKNOWN",
          "sourceName": "SDL_PIXELFORMAT_UNKNOWN"
        },
        "PIXELFORMAT_INDEX1LSB": {
          "kind": "var",
          "name": "PIXELFORMAT_INDEX1LSB",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "INDEX1LSB",
          "sourceName": "SDL_PIXELFORMAT_INDEX1LSB"
        },
        "PIXELFORMAT_INDEX1MSB": {
          "kind": "var",
          "name": "PIXELFORMAT_INDEX1MSB",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "INDEX1MSB",
          "sourceName": "SDL_PIXELFORMAT_INDEX1MSB"
        },
        "PIXELFORMAT_INDEX2LSB": {
          "kind": "var",
          "name": "PIXELFORMAT_INDEX2LSB",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "INDEX2LSB",
          "sourceName": "SDL_PIXELFORMAT_INDEX2LSB"
        },
        "PIXELFORMAT_INDEX2MSB": {
          "kind": "var",
          "name": "PIXELFORMAT_INDEX2MSB",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "INDEX2MSB",
          "sourceName": "SDL_PIXELFORMAT_INDEX2MSB"
        },
        "PIXELFORMAT_INDEX4LSB": {
          "kind": "var",
          "name": "PIXELFORMAT_INDEX4LSB",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "INDEX4LSB",
          "sourceName": "SDL_PIXELFORMAT_INDEX4LSB"
        },
        "PIXELFORMAT_INDEX4MSB": {
          "kind": "var",
          "name": "PIXELFORMAT_INDEX4MSB",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "INDEX4MSB",
          "sourceName": "SDL_PIXELFORMAT_INDEX4MSB"
        },
        "PIXELFORMAT_INDEX8": {
          "kind": "var",
          "name": "PIXELFORMAT_INDEX8",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "INDEX8",
          "sourceName": "SDL_PIXELFORMAT_INDEX8"
        },
        "PIXELFORMAT_RGB332": {
          "kind": "var",
          "name": "PIXELFORMAT_RGB332",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "RGB332",
          "sourceName": "SDL_PIXELFORMAT_RGB332"
        },
        "PIXELFORMAT_XRGB4444": {
          "kind": "var",
          "name": "PIXELFORMAT_XRGB4444",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "XRGB4444",
          "sourceName": "SDL_PIXELFORMAT_XRGB4444"
        },
        "PIXELFORMAT_XBGR4444": {
          "kind": "var",
          "name": "PIXELFORMAT_XBGR4444",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "XBGR4444",
          "sourceName": "SDL_PIXELFORMAT_XBGR4444"
        },
        "PIXELFORMAT_XRGB1555": {
          "kind": "var",
          "name": "PIXELFORMAT_XRGB1555",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "XRGB1555",
          "sourceName": "SDL_PIXELFORMAT_XRGB1555"
        },
        "PIXELFORMAT_XBGR1555": {
          "kind": "var",
          "name": "PIXELFORMAT_XBGR1555",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "XBGR1555",
          "sourceName": "SDL_PIXELFORMAT_XBGR1555"
        },
        "PIXELFORMAT_ARGB4444": {
          "kind": "var",
          "name": "PIXELFORMAT_ARGB4444",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "ARGB4444",
          "sourceName": "SDL_PIXELFORMAT_ARGB4444"
        },
        "PIXELFORMAT_RGBA4444": {
          "kind": "var",
          "name": "PIXELFORMAT_RGBA4444",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "RGBA4444",
          "sourceName": "SDL_PIXELFORMAT_RGBA4444"
        },
        "PIXELFORMAT_ABGR4444": {
          "kind": "var",
          "name": "PIXELFORMAT_ABGR4444",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "ABGR4444",
          "sourceName": "SDL_PIXELFORMAT_ABGR4444"
        },
        "PIXELFORMAT_BGRA4444": {
          "kind": "var",
          "name": "PIXELFORMAT_BGRA4444",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "BGRA4444",
          "sourceName": "SDL_PIXELFORMAT_BGRA4444"
        },
        "PIXELFORMAT_ARGB1555": {
          "kind": "var",
          "name": "PIXELFORMAT_ARGB1555",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "ARGB1555",
          "sourceName": "SDL_PIXELFORMAT_ARGB1555"
        },
        "PIXELFORMAT_RGBA5551": {
          "kind": "var",
          "name": "PIXELFORMAT_RGBA5551",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "RGBA5551",
          "sourceName": "SDL_PIXELFORMAT_RGBA5551"
        },
        "PIXELFORMAT_ABGR1555": {
          "kind": "var",
          "name": "PIXELFORMAT_ABGR1555",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "ABGR1555",
          "sourceName": "SDL_PIXELFORMAT_ABGR1555"
        },
        "PIXELFORMAT_BGRA5551": {
          "kind": "var",
          "name": "PIXELFORMAT_BGRA5551",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "BGRA5551",
          "sourceName": "SDL_PIXELFORMAT_BGRA5551"
        },
        "PIXELFORMAT_RGB565": {
          "kind": "var",
          "name": "PIXELFORMAT_RGB565",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "RGB565",
          "sourceName": "SDL_PIXELFORMAT_RGB565"
        },
        "PIXELFORMAT_BGR565": {
          "kind": "var",
          "name": "PIXELFORMAT_BGR565",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "BGR565",
          "sourceName": "SDL_PIXELFORMAT_BGR565"
        },
        "PIXELFORMAT_RGB24": {
          "kind": "var",
          "name": "PIXELFORMAT_RGB24",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "RGB24",
          "sourceName": "SDL_PIXELFORMAT_RGB24"
        },
        "PIXELFORMAT_BGR24": {
          "kind": "var",
          "name": "PIXELFORMAT_BGR24",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "BGR24",
          "sourceName": "SDL_PIXELFORMAT_BGR24"
        },
        "PIXELFORMAT_XRGB8888": {
          "kind": "var",
          "name": "PIXELFORMAT_XRGB8888",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "XRGB8888",
          "sourceName": "SDL_PIXELFORMAT_XRGB8888"
        },
        "PIXELFORMAT_RGBX8888": {
          "kind": "var",
          "name": "PIXELFORMAT_RGBX8888",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "RGBX8888",
          "sourceName": "SDL_PIXELFORMAT_RGBX8888"
        },
        "PIXELFORMAT_XBGR8888": {
          "kind": "var",
          "name": "PIXELFORMAT_XBGR8888",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "XBGR8888",
          "sourceName": "SDL_PIXELFORMAT_XBGR8888"
        },
        "PIXELFORMAT_BGRX8888": {
          "kind": "var",
          "name": "PIXELFORMAT_BGRX8888",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "BGRX8888",
          "sourceName": "SDL_PIXELFORMAT_BGRX8888"
        },
        "PIXELFORMAT_ARGB8888": {
          "kind": "var",
          "name": "PIXELFORMAT_ARGB8888",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "ARGB8888",
          "sourceName": "SDL_PIXELFORMAT_ARGB8888"
        },
        "PIXELFORMAT_RGBA8888": {
          "kind": "var",
          "name": "PIXELFORMAT_RGBA8888",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "RGBA8888",
          "sourceName": "SDL_PIXELFORMAT_RGBA8888"
        },
        "PIXELFORMAT_ABGR8888": {
          "kind": "var",
          "name": "PIXELFORMAT_ABGR8888",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "ABGR8888",
          "sourceName": "SDL_PIXELFORMAT_ABGR8888"
        },
        "PIXELFORMAT_BGRA8888": {
          "kind": "var",
          "name": "PIXELFORMAT_BGRA8888",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "BGRA8888",
          "sourceName": "SDL_PIXELFORMAT_BGRA8888"
        },
        "PIXELFORMAT_XRGB2101010": {
          "kind": "var",
          "name": "PIXELFORMAT_XRGB2101010",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "XRGB2101010",
          "sourceName": "SDL_PIXELFORMAT_XRGB2101010"
        },
        "PIXELFORMAT_XBGR2101010": {
          "kind": "var",
          "name": "PIXELFORMAT_XBGR2101010",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "XBGR2101010",
          "sourceName": "SDL_PIXELFORMAT_XBGR2101010"
        },
        "PIXELFORMAT_ARGB2101010": {
          "kind": "var",
          "name": "PIXELFORMAT_ARGB2101010",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "ARGB2101010",
          "sourceName": "SDL_PIXELFORMAT_ARGB2101010"
        },
        "PIXELFORMAT_ABGR2101010": {
          "kind": "var",
          "name": "PIXELFORMAT_ABGR2101010",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "ABGR2101010",
          "sourceName": "SDL_PIXELFORMAT_ABGR2101010"
        },
        "PIXELFORMAT_RGB48": {
          "kind": "var",
          "name": "PIXELFORMAT_RGB48",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "RGB48",
          "sourceName": "SDL_PIXELFORMAT_RGB48"
        },
        "PIXELFORMAT_BGR48": {
          "kind": "var",
          "name": "PIXELFORMAT_BGR48",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "BGR48",
          "sourceName": "SDL_PIXELFORMAT_BGR48"
        },
        "PIXELFORMAT_RGBA64": {
          "kind": "var",
          "name": "PIXELFORMAT_RGBA64",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "RGBA64",
          "sourceName": "SDL_PIXELFORMAT_RGBA64"
        },
        "PIXELFORMAT_ARGB64": {
          "kind": "var",
          "name": "PIXELFORMAT_ARGB64",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "ARGB64",
          "sourceName": "SDL_PIXELFORMAT_ARGB64"
        },
        "PIXELFORMAT_BGRA64": {
          "kind": "var",
          "name": "PIXELFORMAT_BGRA64",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "BGRA64",
          "sourceName": "SDL_PIXELFORMAT_BGRA64"
        },
        "PIXELFORMAT_ABGR64": {
          "kind": "var",
          "name": "PIXELFORMAT_ABGR64",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "ABGR64",
          "sourceName": "SDL_PIXELFORMAT_ABGR64"
        },
        "PIXELFORMAT_RGB48_FLOAT": {
          "kind": "var",
          "name": "PIXELFORMAT_RGB48_FLOAT",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "RGB48_FLOAT",
          "sourceName": "SDL_PIXELFORMAT_RGB48_FLOAT"
        },
        "PIXELFORMAT_BGR48_FLOAT": {
          "kind": "var",
          "name": "PIXELFORMAT_BGR48_FLOAT",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "BGR48_FLOAT",
          "sourceName": "SDL_PIXELFORMAT_BGR48_FLOAT"
        },
        "PIXELFORMAT_RGBA64_FLOAT": {
          "kind": "var",
          "name": "PIXELFORMAT_RGBA64_FLOAT",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "RGBA64_FLOAT",
          "sourceName": "SDL_PIXELFORMAT_RGBA64_FLOAT"
        },
        "PIXELFORMAT_ARGB64_FLOAT": {
          "kind": "var",
          "name": "PIXELFORMAT_ARGB64_FLOAT",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "ARGB64_FLOAT",
          "sourceName": "SDL_PIXELFORMAT_ARGB64_FLOAT"
        },
        "PIXELFORMAT_BGRA64_FLOAT": {
          "kind": "var",
          "name": "PIXELFORMAT_BGRA64_FLOAT",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "BGRA64_FLOAT",
          "sourceName": "SDL_PIXELFORMAT_BGRA64_FLOAT"
        },
        "PIXELFORMAT_ABGR64_FLOAT": {
          "kind": "var",
          "name": "PIXELFORMAT_ABGR64_FLOAT",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "ABGR64_FLOAT",
          "sourceName": "SDL_PIXELFORMAT_ABGR64_FLOAT"
        },
        "PIXELFORMAT_RGB96_FLOAT": {
          "kind": "var",
          "name": "PIXELFORMAT_RGB96_FLOAT",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "RGB96_FLOAT",
          "sourceName": "SDL_PIXELFORMAT_RGB96_FLOAT"
        },
        "PIXELFORMAT_BGR96_FLOAT": {
          "kind": "var",
          "name": "PIXELFORMAT_BGR96_FLOAT",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "BGR96_FLOAT",
          "sourceName": "SDL_PIXELFORMAT_BGR96_FLOAT"
        },
        "PIXELFORMAT_RGBA128_FLOAT": {
          "kind": "var",
          "name": "PIXELFORMAT_RGBA128_FLOAT",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "RGBA128_FLOAT",
          "sourceName": "SDL_PIXELFORMAT_RGBA128_FLOAT"
        },
        "PIXELFORMAT_ARGB128_FLOAT": {
          "kind": "var",
          "name": "PIXELFORMAT_ARGB128_FLOAT",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "ARGB128_FLOAT",
          "sourceName": "SDL_PIXELFORMAT_ARGB128_FLOAT"
        },
        "PIXELFORMAT_BGRA128_FLOAT": {
          "kind": "var",
          "name": "PIXELFORMAT_BGRA128_FLOAT",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "BGRA128_FLOAT",
          "sourceName": "SDL_PIXELFORMAT_BGRA128_FLOAT"
        },
        "PIXELFORMAT_ABGR128_FLOAT": {
          "kind": "var",
          "name": "PIXELFORMAT_ABGR128_FLOAT",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "ABGR128_FLOAT",
          "sourceName": "SDL_PIXELFORMAT_ABGR128_FLOAT"
        },
        "PIXELFORMAT_YV12": {
          "kind": "var",
          "name": "PIXELFORMAT_YV12",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "Planar mode: Y + V + U (3 planes)",
          "sourceName": "SDL_PIXELFORMAT_YV12"
        },
        "PIXELFORMAT_IYUV": {
          "kind": "var",
          "name": "PIXELFORMAT_IYUV",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "Planar mode: Y + U + V (3 planes)",
          "sourceName": "SDL_PIXELFORMAT_IYUV"
        },
        "PIXELFORMAT_YUY2": {
          "kind": "var",
          "name": "PIXELFORMAT_YUY2",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "Packed mode: Y0+U0+Y1+V0 (1 plane)",
          "sourceName": "SDL_PIXELFORMAT_YUY2"
        },
        "PIXELFORMAT_UYVY": {
          "kind": "var",
          "name": "PIXELFORMAT_UYVY",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "Packed mode: U0+Y0+V0+Y1 (1 plane)",
          "sourceName": "SDL_PIXELFORMAT_UYVY"
        },
        "PIXELFORMAT_YVYU": {
          "kind": "var",
          "name": "PIXELFORMAT_YVYU",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "Packed mode: Y0+V0+Y1+U0 (1 plane)",
          "sourceName": "SDL_PIXELFORMAT_YVYU"
        },
        "PIXELFORMAT_NV12": {
          "kind": "var",
          "name": "PIXELFORMAT_NV12",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "Planar mode: Y + U/V interleaved (2 planes)",
          "sourceName": "SDL_PIXELFORMAT_NV12"
        },
        "PIXELFORMAT_NV21": {
          "kind": "var",
          "name": "PIXELFORMAT_NV21",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "Planar mode: Y + V/U interleaved (2 planes)",
          "sourceName": "SDL_PIXELFORMAT_NV21"
        },
        "PIXELFORMAT_P010": {
          "kind": "var",
          "name": "PIXELFORMAT_P010",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "Planar mode: Y + U/V interleaved (2 planes)",
          "sourceName": "SDL_PIXELFORMAT_P010"
        },
        "PIXELFORMAT_EXTERNAL_OES": {
          "kind": "var",
          "name": "PIXELFORMAT_EXTERNAL_OES",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "Android video texture format.",
          "sourceName": "SDL_PIXELFORMAT_EXTERNAL_OES"
        },
        "PIXELFORMAT_MJPG": {
          "kind": "var",
          "name": "PIXELFORMAT_MJPG",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "Motion JPEG.",
          "sourceName": "SDL_PIXELFORMAT_MJPG"
        },
        "PIXELFORMAT_RGBA32": {
          "kind": "var",
          "name": "PIXELFORMAT_RGBA32",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "RGBA32",
          "sourceName": "SDL_PIXELFORMAT_RGBA32"
        },
        "PIXELFORMAT_ARGB32": {
          "kind": "var",
          "name": "PIXELFORMAT_ARGB32",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "ARGB32",
          "sourceName": "SDL_PIXELFORMAT_ARGB32"
        },
        "PIXELFORMAT_BGRA32": {
          "kind": "var",
          "name": "PIXELFORMAT_BGRA32",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "BGRA32",
          "sourceName": "SDL_PIXELFORMAT_BGRA32"
        },
        "PIXELFORMAT_ABGR32": {
          "kind": "var",
          "name": "PIXELFORMAT_ABGR32",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "ABGR32",
          "sourceName": "SDL_PIXELFORMAT_ABGR32"
        },
        "PIXELFORMAT_RGBX32": {
          "kind": "var",
          "name": "PIXELFORMAT_RGBX32",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "RGBX32",
          "sourceName": "SDL_PIXELFORMAT_RGBX32"
        },
        "PIXELFORMAT_XRGB32": {
          "kind": "var",
          "name": "PIXELFORMAT_XRGB32",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "XRGB32",
          "sourceName": "SDL_PIXELFORMAT_XRGB32"
        },
        "PIXELFORMAT_BGRX32": {
          "kind": "var",
          "name": "PIXELFORMAT_BGRX32",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "BGRX32",
          "sourceName": "SDL_PIXELFORMAT_BGRX32"
        },
        "PIXELFORMAT_XBGR32": {
          "kind": "var",
          "name": "PIXELFORMAT_XBGR32",
          "constexpr": true,
          "type": "SDL_PixelFormat",
          "doc": "XBGR32",
          "sourceName": "SDL_PIXELFORMAT_XBGR32"
        },
        "ColorType": {
          "doc": "Colorspace color type.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "ColorType",
          "kind": "alias",
          "sourceName": "SDL_ColorType",
          "type": "SDL_ColorType"
        },
        "COLOR_TYPE_UNKNOWN": {
          "kind": "var",
          "name": "COLOR_TYPE_UNKNOWN",
          "constexpr": true,
          "type": "ColorType",
          "doc": "COLOR_TYPE_UNKNOWN",
          "sourceName": "SDL_COLOR_TYPE_UNKNOWN"
        },
        "COLOR_TYPE_RGB": {
          "kind": "var",
          "name": "COLOR_TYPE_RGB",
          "constexpr": true,
          "type": "ColorType",
          "doc": "COLOR_TYPE_RGB",
          "sourceName": "SDL_COLOR_TYPE_RGB"
        },
        "COLOR_TYPE_YCBCR": {
          "kind": "var",
          "name": "COLOR_TYPE_YCBCR",
          "constexpr": true,
          "type": "ColorType",
          "doc": "COLOR_TYPE_YCBCR",
          "sourceName": "SDL_COLOR_TYPE_YCBCR"
        },
        "ColorRange": {
          "doc": "Colorspace color range, as described by\nhttps://www.itu.int/rec/R-REC-BT.2100-2-201807-I/en\n\n@since This enum is available since SDL 3.2.0.",
          "name": "ColorRange",
          "kind": "alias",
          "sourceName": "SDL_ColorRange",
          "type": "SDL_ColorRange"
        },
        "COLOR_RANGE_UNKNOWN": {
          "kind": "var",
          "name": "COLOR_RANGE_UNKNOWN",
          "constexpr": true,
          "type": "ColorRange",
          "doc": "COLOR_RANGE_UNKNOWN",
          "sourceName": "SDL_COLOR_RANGE_UNKNOWN"
        },
        "COLOR_RANGE_LIMITED": {
          "kind": "var",
          "name": "COLOR_RANGE_LIMITED",
          "constexpr": true,
          "type": "ColorRange",
          "doc": "Narrow range, e.g.  16-235 for 8-bit RGB and luma, and 16-240 for 8-bit chroma",
          "sourceName": "SDL_COLOR_RANGE_LIMITED"
        },
        "COLOR_RANGE_FULL": {
          "kind": "var",
          "name": "COLOR_RANGE_FULL",
          "constexpr": true,
          "type": "ColorRange",
          "doc": "Full range, e.g.  0-255 for 8-bit RGB and luma, and 1-255 for 8-bit chroma",
          "sourceName": "SDL_COLOR_RANGE_FULL"
        },
        "ColorPrimaries": {
          "doc": "Colorspace color primaries, as described by\nhttps://www.itu.int/rec/T-REC-H.273-201612-S/en\n\n@since This enum is available since SDL 3.2.0.",
          "name": "ColorPrimaries",
          "kind": "alias",
          "sourceName": "SDL_ColorPrimaries",
          "type": "SDL_ColorPrimaries"
        },
        "COLOR_PRIMARIES_UNKNOWN": {
          "kind": "var",
          "name": "COLOR_PRIMARIES_UNKNOWN",
          "constexpr": true,
          "type": "ColorPrimaries",
          "doc": "COLOR_PRIMARIES_UNKNOWN",
          "sourceName": "SDL_COLOR_PRIMARIES_UNKNOWN"
        },
        "COLOR_PRIMARIES_BT709": {
          "kind": "var",
          "name": "COLOR_PRIMARIES_BT709",
          "constexpr": true,
          "type": "ColorPrimaries",
          "doc": "ITU-R BT.709-6.",
          "sourceName": "SDL_COLOR_PRIMARIES_BT709"
        },
        "COLOR_PRIMARIES_UNSPECIFIED": {
          "kind": "var",
          "name": "COLOR_PRIMARIES_UNSPECIFIED",
          "constexpr": true,
          "type": "ColorPrimaries",
          "doc": "COLOR_PRIMARIES_UNSPECIFIED",
          "sourceName": "SDL_COLOR_PRIMARIES_UNSPECIFIED"
        },
        "COLOR_PRIMARIES_BT470M": {
          "kind": "var",
          "name": "COLOR_PRIMARIES_BT470M",
          "constexpr": true,
          "type": "ColorPrimaries",
          "doc": "ITU-R BT.470-6 System M.",
          "sourceName": "SDL_COLOR_PRIMARIES_BT470M"
        },
        "COLOR_PRIMARIES_BT470BG": {
          "kind": "var",
          "name": "COLOR_PRIMARIES_BT470BG",
          "constexpr": true,
          "type": "ColorPrimaries",
          "doc": "ITU-R BT.470-6 System B, G / ITU-R BT.601-7 625.",
          "sourceName": "SDL_COLOR_PRIMARIES_BT470BG"
        },
        "COLOR_PRIMARIES_BT601": {
          "kind": "var",
          "name": "COLOR_PRIMARIES_BT601",
          "constexpr": true,
          "type": "ColorPrimaries",
          "doc": "ITU-R BT.601-7 525, SMPTE 170M.",
          "sourceName": "SDL_COLOR_PRIMARIES_BT601"
        },
        "COLOR_PRIMARIES_SMPTE240": {
          "kind": "var",
          "name": "COLOR_PRIMARIES_SMPTE240",
          "constexpr": true,
          "type": "ColorPrimaries",
          "doc": "SMPTE 240M, functionally the same as COLOR_PRIMARIES_BT601.",
          "sourceName": "SDL_COLOR_PRIMARIES_SMPTE240"
        },
        "COLOR_PRIMARIES_GENERIC_FILM": {
          "kind": "var",
          "name": "COLOR_PRIMARIES_GENERIC_FILM",
          "constexpr": true,
          "type": "ColorPrimaries",
          "doc": "Generic film (color filters using Illuminant C)",
          "sourceName": "SDL_COLOR_PRIMARIES_GENERIC_FILM"
        },
        "COLOR_PRIMARIES_BT2020": {
          "kind": "var",
          "name": "COLOR_PRIMARIES_BT2020",
          "constexpr": true,
          "type": "ColorPrimaries",
          "doc": "ITU-R BT.2020-2 / ITU-R BT.2100-0.",
          "sourceName": "SDL_COLOR_PRIMARIES_BT2020"
        },
        "COLOR_PRIMARIES_XYZ": {
          "kind": "var",
          "name": "COLOR_PRIMARIES_XYZ",
          "constexpr": true,
          "type": "ColorPrimaries",
          "doc": "SMPTE ST 428-1.",
          "sourceName": "SDL_COLOR_PRIMARIES_XYZ"
        },
        "COLOR_PRIMARIES_SMPTE431": {
          "kind": "var",
          "name": "COLOR_PRIMARIES_SMPTE431",
          "constexpr": true,
          "type": "ColorPrimaries",
          "doc": "SMPTE RP 431-2.",
          "sourceName": "SDL_COLOR_PRIMARIES_SMPTE431"
        },
        "COLOR_PRIMARIES_SMPTE432": {
          "kind": "var",
          "name": "COLOR_PRIMARIES_SMPTE432",
          "constexpr": true,
          "type": "ColorPrimaries",
          "doc": "SMPTE EG 432-1 / DCI P3.",
          "sourceName": "SDL_COLOR_PRIMARIES_SMPTE432"
        },
        "COLOR_PRIMARIES_EBU3213": {
          "kind": "var",
          "name": "COLOR_PRIMARIES_EBU3213",
          "constexpr": true,
          "type": "ColorPrimaries",
          "doc": "EBU Tech.  3213-E",
          "sourceName": "SDL_COLOR_PRIMARIES_EBU3213"
        },
        "COLOR_PRIMARIES_CUSTOM": {
          "kind": "var",
          "name": "COLOR_PRIMARIES_CUSTOM",
          "constexpr": true,
          "type": "ColorPrimaries",
          "doc": "COLOR_PRIMARIES_CUSTOM",
          "sourceName": "SDL_COLOR_PRIMARIES_CUSTOM"
        },
        "TransferCharacteristics": {
          "doc": "Colorspace transfer characteristics.\n\nThese are as described by https://www.itu.int/rec/T-REC-H.273-201612-S/en\n\n@since This enum is available since SDL 3.2.0.",
          "name": "TransferCharacteristics",
          "kind": "alias",
          "sourceName": "SDL_TransferCharacteristics",
          "type": "SDL_TransferCharacteristics"
        },
        "TRANSFER_CHARACTERISTICS_UNKNOWN": {
          "kind": "var",
          "name": "TRANSFER_CHARACTERISTICS_UNKNOWN",
          "constexpr": true,
          "type": "TransferCharacteristics",
          "doc": "TRANSFER_CHARACTERISTICS_UNKNOWN",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_UNKNOWN"
        },
        "TRANSFER_CHARACTERISTICS_BT709": {
          "kind": "var",
          "name": "TRANSFER_CHARACTERISTICS_BT709",
          "constexpr": true,
          "type": "TransferCharacteristics",
          "doc": "Rec.  ITU-R BT.709-6 / ITU-R BT1361",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_BT709"
        },
        "TRANSFER_CHARACTERISTICS_UNSPECIFIED": {
          "kind": "var",
          "name": "TRANSFER_CHARACTERISTICS_UNSPECIFIED",
          "constexpr": true,
          "type": "TransferCharacteristics",
          "doc": "TRANSFER_CHARACTERISTICS_UNSPECIFIED",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_UNSPECIFIED"
        },
        "TRANSFER_CHARACTERISTICS_GAMMA22": {
          "kind": "var",
          "name": "TRANSFER_CHARACTERISTICS_GAMMA22",
          "constexpr": true,
          "type": "TransferCharacteristics",
          "doc": "ITU-R BT.470-6 System M / ITU-R BT1700 625 PAL & SECAM.",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_GAMMA22"
        },
        "TRANSFER_CHARACTERISTICS_GAMMA28": {
          "kind": "var",
          "name": "TRANSFER_CHARACTERISTICS_GAMMA28",
          "constexpr": true,
          "type": "TransferCharacteristics",
          "doc": "ITU-R BT.470-6 System B, G.",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_GAMMA28"
        },
        "TRANSFER_CHARACTERISTICS_BT601": {
          "kind": "var",
          "name": "TRANSFER_CHARACTERISTICS_BT601",
          "constexpr": true,
          "type": "TransferCharacteristics",
          "doc": "SMPTE ST 170M / ITU-R BT.601-7 525 or 625.",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_BT601"
        },
        "TRANSFER_CHARACTERISTICS_SMPTE240": {
          "kind": "var",
          "name": "TRANSFER_CHARACTERISTICS_SMPTE240",
          "constexpr": true,
          "type": "TransferCharacteristics",
          "doc": "SMPTE ST 240M.",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_SMPTE240"
        },
        "TRANSFER_CHARACTERISTICS_LINEAR": {
          "kind": "var",
          "name": "TRANSFER_CHARACTERISTICS_LINEAR",
          "constexpr": true,
          "type": "TransferCharacteristics",
          "doc": "TRANSFER_CHARACTERISTICS_LINEAR",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_LINEAR"
        },
        "TRANSFER_CHARACTERISTICS_LOG100": {
          "kind": "var",
          "name": "TRANSFER_CHARACTERISTICS_LOG100",
          "constexpr": true,
          "type": "TransferCharacteristics",
          "doc": "TRANSFER_CHARACTERISTICS_LOG100",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_LOG100"
        },
        "TRANSFER_CHARACTERISTICS_LOG100_SQRT10": {
          "kind": "var",
          "name": "TRANSFER_CHARACTERISTICS_LOG100_SQRT10",
          "constexpr": true,
          "type": "TransferCharacteristics",
          "doc": "TRANSFER_CHARACTERISTICS_LOG100_SQRT10",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_LOG100_SQRT10"
        },
        "TRANSFER_CHARACTERISTICS_IEC61966": {
          "kind": "var",
          "name": "TRANSFER_CHARACTERISTICS_IEC61966",
          "constexpr": true,
          "type": "TransferCharacteristics",
          "doc": "IEC 61966-2-4.",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_IEC61966"
        },
        "TRANSFER_CHARACTERISTICS_BT1361": {
          "kind": "var",
          "name": "TRANSFER_CHARACTERISTICS_BT1361",
          "constexpr": true,
          "type": "TransferCharacteristics",
          "doc": "ITU-R BT1361 Extended Colour Gamut.",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_BT1361"
        },
        "TRANSFER_CHARACTERISTICS_SRGB": {
          "kind": "var",
          "name": "TRANSFER_CHARACTERISTICS_SRGB",
          "constexpr": true,
          "type": "TransferCharacteristics",
          "doc": "IEC 61966-2-1 (sRGB or sYCC)",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_SRGB"
        },
        "TRANSFER_CHARACTERISTICS_BT2020_10BIT": {
          "kind": "var",
          "name": "TRANSFER_CHARACTERISTICS_BT2020_10BIT",
          "constexpr": true,
          "type": "TransferCharacteristics",
          "doc": "ITU-R BT2020 for 10-bit system.",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_BT2020_10BIT"
        },
        "TRANSFER_CHARACTERISTICS_BT2020_12BIT": {
          "kind": "var",
          "name": "TRANSFER_CHARACTERISTICS_BT2020_12BIT",
          "constexpr": true,
          "type": "TransferCharacteristics",
          "doc": "ITU-R BT2020 for 12-bit system.",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_BT2020_12BIT"
        },
        "TRANSFER_CHARACTERISTICS_PQ": {
          "kind": "var",
          "name": "TRANSFER_CHARACTERISTICS_PQ",
          "constexpr": true,
          "type": "TransferCharacteristics",
          "doc": "SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems.",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_PQ"
        },
        "TRANSFER_CHARACTERISTICS_SMPTE428": {
          "kind": "var",
          "name": "TRANSFER_CHARACTERISTICS_SMPTE428",
          "constexpr": true,
          "type": "TransferCharacteristics",
          "doc": "SMPTE ST 428-1.",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_SMPTE428"
        },
        "TRANSFER_CHARACTERISTICS_HLG": {
          "kind": "var",
          "name": "TRANSFER_CHARACTERISTICS_HLG",
          "constexpr": true,
          "type": "TransferCharacteristics",
          "doc": "ARIB STD-B67, known as \"hybrid log-gamma\" (HLG)",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_HLG"
        },
        "TRANSFER_CHARACTERISTICS_CUSTOM": {
          "kind": "var",
          "name": "TRANSFER_CHARACTERISTICS_CUSTOM",
          "constexpr": true,
          "type": "TransferCharacteristics",
          "doc": "TRANSFER_CHARACTERISTICS_CUSTOM",
          "sourceName": "SDL_TRANSFER_CHARACTERISTICS_CUSTOM"
        },
        "MatrixCoefficients": {
          "doc": "Colorspace matrix coefficients.\n\nThese are as described by https://www.itu.int/rec/T-REC-H.273-201612-S/en\n\n@since This enum is available since SDL 3.2.0.",
          "name": "MatrixCoefficients",
          "kind": "alias",
          "sourceName": "SDL_MatrixCoefficients",
          "type": "SDL_MatrixCoefficients"
        },
        "MATRIX_COEFFICIENTS_IDENTITY": {
          "kind": "var",
          "name": "MATRIX_COEFFICIENTS_IDENTITY",
          "constexpr": true,
          "type": "MatrixCoefficients",
          "doc": "MATRIX_COEFFICIENTS_IDENTITY",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_IDENTITY"
        },
        "MATRIX_COEFFICIENTS_BT709": {
          "kind": "var",
          "name": "MATRIX_COEFFICIENTS_BT709",
          "constexpr": true,
          "type": "MatrixCoefficients",
          "doc": "ITU-R BT.709-6.",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_BT709"
        },
        "MATRIX_COEFFICIENTS_UNSPECIFIED": {
          "kind": "var",
          "name": "MATRIX_COEFFICIENTS_UNSPECIFIED",
          "constexpr": true,
          "type": "MatrixCoefficients",
          "doc": "MATRIX_COEFFICIENTS_UNSPECIFIED",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_UNSPECIFIED"
        },
        "MATRIX_COEFFICIENTS_FCC": {
          "kind": "var",
          "name": "MATRIX_COEFFICIENTS_FCC",
          "constexpr": true,
          "type": "MatrixCoefficients",
          "doc": "US FCC Title 47.",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_FCC"
        },
        "MATRIX_COEFFICIENTS_BT470BG": {
          "kind": "var",
          "name": "MATRIX_COEFFICIENTS_BT470BG",
          "constexpr": true,
          "type": "MatrixCoefficients",
          "doc": "ITU-R BT.470-6 System B, G / ITU-R BT.601-7 625, functionally the same as MATRIX_COEFFICIENTS_BT601.",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_BT470BG"
        },
        "MATRIX_COEFFICIENTS_BT601": {
          "kind": "var",
          "name": "MATRIX_COEFFICIENTS_BT601",
          "constexpr": true,
          "type": "MatrixCoefficients",
          "doc": "ITU-R BT.601-7 525.",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_BT601"
        },
        "MATRIX_COEFFICIENTS_SMPTE240": {
          "kind": "var",
          "name": "MATRIX_COEFFICIENTS_SMPTE240",
          "constexpr": true,
          "type": "MatrixCoefficients",
          "doc": "SMPTE 240M.",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_SMPTE240"
        },
        "MATRIX_COEFFICIENTS_YCGCO": {
          "kind": "var",
          "name": "MATRIX_COEFFICIENTS_YCGCO",
          "constexpr": true,
          "type": "MatrixCoefficients",
          "doc": "MATRIX_COEFFICIENTS_YCGCO",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_YCGCO"
        },
        "MATRIX_COEFFICIENTS_BT2020_NCL": {
          "kind": "var",
          "name": "MATRIX_COEFFICIENTS_BT2020_NCL",
          "constexpr": true,
          "type": "MatrixCoefficients",
          "doc": "ITU-R BT.2020-2 non-constant luminance.",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_BT2020_NCL"
        },
        "MATRIX_COEFFICIENTS_BT2020_CL": {
          "kind": "var",
          "name": "MATRIX_COEFFICIENTS_BT2020_CL",
          "constexpr": true,
          "type": "MatrixCoefficients",
          "doc": "ITU-R BT.2020-2 constant luminance.",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_BT2020_CL"
        },
        "MATRIX_COEFFICIENTS_SMPTE2085": {
          "kind": "var",
          "name": "MATRIX_COEFFICIENTS_SMPTE2085",
          "constexpr": true,
          "type": "MatrixCoefficients",
          "doc": "SMPTE ST 2085.",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_SMPTE2085"
        },
        "MATRIX_COEFFICIENTS_CHROMA_DERIVED_NCL": {
          "kind": "var",
          "name": "MATRIX_COEFFICIENTS_CHROMA_DERIVED_NCL",
          "constexpr": true,
          "type": "MatrixCoefficients",
          "doc": "MATRIX_COEFFICIENTS_CHROMA_DERIVED_NCL",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_CHROMA_DERIVED_NCL"
        },
        "MATRIX_COEFFICIENTS_CHROMA_DERIVED_CL": {
          "kind": "var",
          "name": "MATRIX_COEFFICIENTS_CHROMA_DERIVED_CL",
          "constexpr": true,
          "type": "MatrixCoefficients",
          "doc": "MATRIX_COEFFICIENTS_CHROMA_DERIVED_CL",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_CHROMA_DERIVED_CL"
        },
        "MATRIX_COEFFICIENTS_ICTCP": {
          "kind": "var",
          "name": "MATRIX_COEFFICIENTS_ICTCP",
          "constexpr": true,
          "type": "MatrixCoefficients",
          "doc": "ITU-R BT.2100-0 ICTCP.",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_ICTCP"
        },
        "MATRIX_COEFFICIENTS_CUSTOM": {
          "kind": "var",
          "name": "MATRIX_COEFFICIENTS_CUSTOM",
          "constexpr": true,
          "type": "MatrixCoefficients",
          "doc": "MATRIX_COEFFICIENTS_CUSTOM",
          "sourceName": "SDL_MATRIX_COEFFICIENTS_CUSTOM"
        },
        "ChromaLocation": {
          "doc": "Colorspace chroma sample location.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "ChromaLocation",
          "kind": "alias",
          "sourceName": "SDL_ChromaLocation",
          "type": "SDL_ChromaLocation"
        },
        "CHROMA_LOCATION_NONE": {
          "kind": "var",
          "name": "CHROMA_LOCATION_NONE",
          "constexpr": true,
          "type": "ChromaLocation",
          "doc": "RGB, no chroma sampling.",
          "sourceName": "SDL_CHROMA_LOCATION_NONE"
        },
        "CHROMA_LOCATION_LEFT": {
          "kind": "var",
          "name": "CHROMA_LOCATION_LEFT",
          "constexpr": true,
          "type": "ChromaLocation",
          "doc": "In MPEG-2, MPEG-4, and AVC, Cb and Cr are taken on midpoint of the left-edge of the 2x2 square.  In other words, they have the same horizontal location as the top-left pixel, but is shifted one-half pixel down vertically.",
          "sourceName": "SDL_CHROMA_LOCATION_LEFT"
        },
        "CHROMA_LOCATION_CENTER": {
          "kind": "var",
          "name": "CHROMA_LOCATION_CENTER",
          "constexpr": true,
          "type": "ChromaLocation",
          "doc": "In JPEG/JFIF, H.261, and MPEG-1, Cb and Cr are taken at the center of the 2x2 square.  In other words, they are offset one-half pixel to the right and one-half pixel down compared to the top-left pixel.",
          "sourceName": "SDL_CHROMA_LOCATION_CENTER"
        },
        "CHROMA_LOCATION_TOPLEFT": {
          "kind": "var",
          "name": "CHROMA_LOCATION_TOPLEFT",
          "constexpr": true,
          "type": "ChromaLocation",
          "doc": "In HEVC for BT.2020 and BT.2100 content (in particular on Blu-rays), Cb and Cr are sampled at the same location as the group's top-left Y pixel (\"co-sited\", \"co-located\").",
          "sourceName": "SDL_CHROMA_LOCATION_TOPLEFT"
        },
        "SDL_DEFINE_COLORSPACE": {
          "doc": "A macro for defining custom Colorspace formats.\n\nFor example, defining COLORSPACE_SRGB looks like this:\n\n```c\nSDL_DEFINE_COLORSPACE(COLOR_TYPE_RGB,\n                      COLOR_RANGE_FULL,\n                      COLOR_PRIMARIES_BT709,\n                      TRANSFER_CHARACTERISTICS_SRGB,\n                      MATRIX_COEFFICIENTS_IDENTITY,\n                      CHROMA_LOCATION_NONE)\n```\n\n@param type the type of the new format, probably an ColorType value.\n@param range the range of the new format, probably a ColorRange value.\n@param primaries the primaries of the new format, probably an\n                 ColorPrimaries value.\n@param transfer the transfer characteristics of the new format, probably an\n                TransferCharacteristics value.\n@param matrix the matrix coefficients of the new format, probably an\n              MatrixCoefficients value.\n@param chroma the chroma sample location of the new format, probably an\n              ChromaLocation value.\n@returns a format value in the style of Colorspace.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_DEFINE_COLORSPACE",
          "kind": "def",
          "parameters": [
            "type",
            "range",
            "primaries",
            "transfer",
            "matrix",
            "chroma"
          ],
          "value": "    (((Uint32)(type) << 28) | ((Uint32)(range) << 24) | ((Uint32)(chroma) << 20) | \\\n    ((Uint32)(primaries) << 10) | ((Uint32)(transfer) << 5) | ((Uint32)(matrix) << 0))",
          "sourceName": "SDL_DEFINE_COLORSPACE"
        },
        "SDL_COLORSPACETYPE": {
          "doc": "A macro to retrieve the type of an Colorspace.\n\n@param cspace an Colorspace to check.\n@returns the ColorType for `cspace`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_COLORSPACETYPE",
          "kind": "def",
          "parameters": [
            "cspace"
          ],
          "value": "(SDL_ColorType)(((cspace) >> 28) & 0x0F)",
          "sourceName": "SDL_COLORSPACETYPE"
        },
        "SDL_COLORSPACERANGE": {
          "doc": "A macro to retrieve the range of an Colorspace.\n\n@param cspace an Colorspace to check.\n@returns the ColorRange of `cspace`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_COLORSPACERANGE",
          "kind": "def",
          "parameters": [
            "cspace"
          ],
          "value": "(SDL_ColorRange)(((cspace) >> 24) & 0x0F)",
          "sourceName": "SDL_COLORSPACERANGE"
        },
        "SDL_COLORSPACECHROMA": {
          "doc": "A macro to retrieve the chroma sample location of an Colorspace.\n\n@param cspace an Colorspace to check.\n@returns the ChromaLocation of `cspace`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_COLORSPACECHROMA",
          "kind": "def",
          "parameters": [
            "cspace"
          ],
          "value": "(SDL_ChromaLocation)(((cspace) >> 20) & 0x0F)",
          "sourceName": "SDL_COLORSPACECHROMA"
        },
        "SDL_COLORSPACEPRIMARIES": {
          "doc": "A macro to retrieve the primaries of an Colorspace.\n\n@param cspace an Colorspace to check.\n@returns the ColorPrimaries of `cspace`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_COLORSPACEPRIMARIES",
          "kind": "def",
          "parameters": [
            "cspace"
          ],
          "value": "(SDL_ColorPrimaries)(((cspace) >> 10) & 0x1F)",
          "sourceName": "SDL_COLORSPACEPRIMARIES"
        },
        "SDL_COLORSPACETRANSFER": {
          "doc": "A macro to retrieve the transfer characteristics of an Colorspace.\n\n@param cspace an Colorspace to check.\n@returns the TransferCharacteristics of `cspace`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_COLORSPACETRANSFER",
          "kind": "def",
          "parameters": [
            "cspace"
          ],
          "value": "(SDL_TransferCharacteristics)(((cspace) >> 5) & 0x1F)",
          "sourceName": "SDL_COLORSPACETRANSFER"
        },
        "SDL_COLORSPACEMATRIX": {
          "doc": "A macro to retrieve the matrix coefficients of an Colorspace.\n\n@param cspace an Colorspace to check.\n@returns the MatrixCoefficients of `cspace`.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_COLORSPACEMATRIX",
          "kind": "def",
          "parameters": [
            "cspace"
          ],
          "value": "(SDL_MatrixCoefficients)((cspace) & 0x1F)",
          "sourceName": "SDL_COLORSPACEMATRIX"
        },
        "SDL_ISCOLORSPACE_MATRIX_BT601": {
          "doc": "A macro to determine if an Colorspace uses BT601 (or BT470BG) matrix\ncoefficients.\n\nNote that this macro double-evaluates its parameter, so do not use\nexpressions with side-effects here.\n\n@param cspace an Colorspace to check.\n@returns true if BT601 or BT470BG, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISCOLORSPACE_MATRIX_BT601",
          "kind": "def",
          "parameters": [
            "cspace"
          ],
          "value": "(SDL_COLORSPACEMATRIX(cspace) == SDL_MATRIX_COEFFICIENTS_BT601 || SDL_COLORSPACEMATRIX(cspace) == SDL_MATRIX_COEFFICIENTS_BT470BG)",
          "sourceName": "SDL_ISCOLORSPACE_MATRIX_BT601"
        },
        "SDL_ISCOLORSPACE_MATRIX_BT709": {
          "doc": "A macro to determine if an Colorspace uses BT709 matrix coefficients.\n\n@param cspace an Colorspace to check.\n@returns true if BT709, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISCOLORSPACE_MATRIX_BT709",
          "kind": "def",
          "parameters": [
            "cspace"
          ],
          "value": "(SDL_COLORSPACEMATRIX(cspace) == SDL_MATRIX_COEFFICIENTS_BT709)",
          "sourceName": "SDL_ISCOLORSPACE_MATRIX_BT709"
        },
        "SDL_ISCOLORSPACE_MATRIX_BT2020_NCL": {
          "doc": "A macro to determine if an Colorspace uses BT2020_NCL matrix\ncoefficients.\n\n@param cspace an Colorspace to check.\n@returns true if BT2020_NCL, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISCOLORSPACE_MATRIX_BT2020_NCL",
          "kind": "def",
          "parameters": [
            "cspace"
          ],
          "value": "(SDL_COLORSPACEMATRIX(cspace) == SDL_MATRIX_COEFFICIENTS_BT2020_NCL)",
          "sourceName": "SDL_ISCOLORSPACE_MATRIX_BT2020_NCL"
        },
        "SDL_ISCOLORSPACE_LIMITED_RANGE": {
          "doc": "A macro to determine if an Colorspace has a limited range.\n\n@param cspace an Colorspace to check.\n@returns true if limited range, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISCOLORSPACE_LIMITED_RANGE",
          "kind": "def",
          "parameters": [
            "cspace"
          ],
          "value": "(SDL_COLORSPACERANGE(cspace) != SDL_COLOR_RANGE_FULL)",
          "sourceName": "SDL_ISCOLORSPACE_LIMITED_RANGE"
        },
        "SDL_ISCOLORSPACE_FULL_RANGE": {
          "doc": "A macro to determine if an Colorspace has a full range.\n\n@param cspace an Colorspace to check.\n@returns true if full range, false otherwise.\n\n@threadsafety It is safe to call this macro from any thread.\n\n@since This macro is available since SDL 3.2.0.",
          "name": "SDL_ISCOLORSPACE_FULL_RANGE",
          "kind": "def",
          "parameters": [
            "cspace"
          ],
          "value": "(SDL_COLORSPACERANGE(cspace) == SDL_COLOR_RANGE_FULL)",
          "sourceName": "SDL_ISCOLORSPACE_FULL_RANGE"
        },
        "Colorspace": {
          "doc": "Colorspace definitions.\n\nSince similar colorspaces may vary in their details (matrix, transfer\nfunction, etc.), this is not an exhaustive list, but rather a\nrepresentative sample of the kinds of colorspaces supported in SDL.\n\n@since This enum is available since SDL 3.2.0.\n\n@sa ColorPrimaries\n@sa ColorRange\n@sa ColorType\n@sa MatrixCoefficients\n@sa TransferCharacteristics",
          "name": "Colorspace",
          "kind": "struct",
          "sourceName": "SDL_Colorspace",
          "entries": {
            "Colorspace": {
              "name": "Colorspace",
              "kind": "def",
              "doc": ""
            },
            "GetType": {
              "name": "GetType",
              "kind": "def",
              "doc": ""
            },
            "GetRange": {
              "name": "GetRange",
              "kind": "def",
              "doc": ""
            },
            "GetChroma": {
              "name": "GetChroma",
              "kind": "def",
              "doc": ""
            },
            "GetPrimaries": {
              "name": "GetPrimaries",
              "kind": "def",
              "doc": ""
            },
            "GetTransfer": {
              "name": "GetTransfer",
              "kind": "def",
              "doc": ""
            },
            "GetMatrix": {
              "name": "GetMatrix",
              "kind": "def",
              "doc": ""
            },
            "IsMatrixBT601": {
              "name": "IsMatrixBT601",
              "kind": "def",
              "doc": ""
            },
            "IsMatrixBT709": {
              "name": "IsMatrixBT709",
              "kind": "def",
              "doc": ""
            },
            "IsMatrixBT2020_NCL": {
              "name": "IsMatrixBT2020_NCL",
              "kind": "def",
              "doc": ""
            },
            "IsLimitedRange": {
              "name": "IsLimitedRange",
              "kind": "def",
              "doc": ""
            },
            "IsFullRange": {
              "name": "IsFullRange",
              "kind": "def",
              "doc": ""
            }
          }
        },
        "COLORSPACE_UNKNOWN": {
          "kind": "var",
          "name": "COLORSPACE_UNKNOWN",
          "constexpr": true,
          "type": "SDL_Colorspace",
          "doc": "UNKNOWN",
          "sourceName": "SDL_COLORSPACE_UNKNOWN"
        },
        "COLORSPACE_SRGB": {
          "kind": "var",
          "name": "COLORSPACE_SRGB",
          "constexpr": true,
          "type": "SDL_Colorspace",
          "doc": "Equivalent to DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709.",
          "sourceName": "SDL_COLORSPACE_SRGB"
        },
        "COLORSPACE_SRGB_LINEAR": {
          "kind": "var",
          "name": "COLORSPACE_SRGB_LINEAR",
          "constexpr": true,
          "type": "SDL_Colorspace",
          "doc": "[object Object]",
          "sourceName": "SDL_COLORSPACE_SRGB_LINEAR"
        },
        "COLORSPACE_HDR10": {
          "kind": "var",
          "name": "COLORSPACE_HDR10",
          "constexpr": true,
          "type": "SDL_Colorspace",
          "doc": "[object Object]",
          "sourceName": "SDL_COLORSPACE_HDR10"
        },
        "COLORSPACE_JPEG": {
          "kind": "var",
          "name": "COLORSPACE_JPEG",
          "constexpr": true,
          "type": "SDL_Colorspace",
          "doc": "Equivalent to DXGI_COLOR_SPACE_YCBCR_FULL_G22_NONE_P709_X601.",
          "sourceName": "SDL_COLORSPACE_JPEG"
        },
        "COLORSPACE_BT601_LIMITED": {
          "kind": "var",
          "name": "COLORSPACE_BT601_LIMITED",
          "constexpr": true,
          "type": "SDL_Colorspace",
          "doc": "Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601.",
          "sourceName": "SDL_COLORSPACE_BT601_LIMITED"
        },
        "COLORSPACE_BT601_FULL": {
          "kind": "var",
          "name": "COLORSPACE_BT601_FULL",
          "constexpr": true,
          "type": "SDL_Colorspace",
          "doc": "Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601.",
          "sourceName": "SDL_COLORSPACE_BT601_FULL"
        },
        "COLORSPACE_BT709_LIMITED": {
          "kind": "var",
          "name": "COLORSPACE_BT709_LIMITED",
          "constexpr": true,
          "type": "SDL_Colorspace",
          "doc": "Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709.",
          "sourceName": "SDL_COLORSPACE_BT709_LIMITED"
        },
        "COLORSPACE_BT709_FULL": {
          "kind": "var",
          "name": "COLORSPACE_BT709_FULL",
          "constexpr": true,
          "type": "SDL_Colorspace",
          "doc": "Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709.",
          "sourceName": "SDL_COLORSPACE_BT709_FULL"
        },
        "COLORSPACE_BT2020_LIMITED": {
          "kind": "var",
          "name": "COLORSPACE_BT2020_LIMITED",
          "constexpr": true,
          "type": "SDL_Colorspace",
          "doc": "Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P2020.",
          "sourceName": "SDL_COLORSPACE_BT2020_LIMITED"
        },
        "COLORSPACE_BT2020_FULL": {
          "kind": "var",
          "name": "COLORSPACE_BT2020_FULL",
          "constexpr": true,
          "type": "SDL_Colorspace",
          "doc": "Equivalent to DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P2020.",
          "sourceName": "SDL_COLORSPACE_BT2020_FULL"
        },
        "COLORSPACE_RGB_DEFAULT": {
          "kind": "var",
          "name": "COLORSPACE_RGB_DEFAULT",
          "constexpr": true,
          "type": "SDL_Colorspace",
          "doc": "The default colorspace for RGB surfaces if no colorspace is specified.",
          "sourceName": "SDL_COLORSPACE_RGB_DEFAULT"
        },
        "COLORSPACE_YUV_DEFAULT": {
          "kind": "var",
          "name": "COLORSPACE_YUV_DEFAULT",
          "constexpr": true,
          "type": "SDL_Colorspace",
          "doc": "The default colorspace for YUV surfaces if no colorspace is specified.",
          "sourceName": "SDL_COLORSPACE_YUV_DEFAULT"
        },
        "Color": {
          "doc": "A structure that represents a color as RGBA components.\n\nThe bits of this structure can be directly reinterpreted as an\ninteger-packed color which uses the PIXELFORMAT_RGBA32 format\n(PIXELFORMAT_ABGR8888 on little-endian systems and\nPIXELFORMAT_RGBA8888 on big-endian systems).\n\n@since This struct is available since SDL 3.2.0.",
          "name": "Color",
          "kind": "struct",
          "sourceName": "SDL_Color",
          "hints": {
            "self": "this",
            "super": "SDL_Color"
          },
          "type": "SDL_Color",
          "entries": {
            "Color": [
              {
                "kind": "function",
                "name": "Color",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "ColorRaw",
                    "name": "color",
                    "default": "{}"
                  }
                ],
                "doc": "Wraps Color.\n\n@param color the value to be wrapped",
                "hints": {
                  "init": [
                    "SDL_Color(color)"
                  ]
                }
              },
              {
                "kind": "function",
                "name": "Color",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "Uint8",
                    "name": "r"
                  },
                  {
                    "type": "Uint8",
                    "name": "g"
                  },
                  {
                    "type": "Uint8",
                    "name": "b"
                  },
                  {
                    "type": "Uint8",
                    "name": "a"
                  }
                ],
                "doc": "Constructs from its fields.\n\n@param r the value for r.\n@param g the value for g.\n@param b the value for b.\n@param a the value for a.",
                "hints": {
                  "init": [
                    "SDL_Color{r, g, b, a}"
                  ]
                }
              }
            ],
            "operator<=>": [
              {
                "kind": "function",
                "name": "operator<=>",
                "type": "auto",
                "constexpr": true,
                "immutable": true,
                "parameters": [
                  {
                    "type": "const Color &",
                    "name": "other"
                  }
                ],
                "doc": "Default comparison operator",
                "hints": {
                  "default": true
                }
              },
              {
                "kind": "function",
                "name": "operator<=>",
                "type": "auto",
                "constexpr": true,
                "immutable": true,
                "parameters": [
                  {
                    "type": "ColorRaw",
                    "name": "color"
                  }
                ],
                "doc": "Compares with the underlying type",
                "hints": {
                  "body": "return operator<=>(Color(color));"
                }
              }
            ],
            "GetR": {
              "kind": "function",
              "name": "GetR",
              "type": "Uint8",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the r.\n\n@returns current r value.",
              "hints": {
                "body": "return r;"
              }
            },
            "SetR": {
              "kind": "function",
              "name": "SetR",
              "type": "Color &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "Uint8",
                  "name": "newR"
                }
              ],
              "doc": "Set the r.\n\n@param newR the new r value.\n@returns Reference to self.",
              "hints": {
                "body": "r = newR;\nreturn *this;"
              }
            },
            "GetG": {
              "kind": "function",
              "name": "GetG",
              "type": "Uint8",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the g.\n\n@returns current g value.",
              "hints": {
                "body": "return g;"
              }
            },
            "SetG": {
              "kind": "function",
              "name": "SetG",
              "type": "Color &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "Uint8",
                  "name": "newG"
                }
              ],
              "doc": "Set the g.\n\n@param newG the new g value.\n@returns Reference to self.",
              "hints": {
                "body": "g = newG;\nreturn *this;"
              }
            },
            "GetB": {
              "kind": "function",
              "name": "GetB",
              "type": "Uint8",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the b.\n\n@returns current b value.",
              "hints": {
                "body": "return b;"
              }
            },
            "SetB": {
              "kind": "function",
              "name": "SetB",
              "type": "Color &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "Uint8",
                  "name": "newB"
                }
              ],
              "doc": "Set the b.\n\n@param newB the new b value.\n@returns Reference to self.",
              "hints": {
                "body": "b = newB;\nreturn *this;"
              }
            },
            "GetA": {
              "kind": "function",
              "name": "GetA",
              "type": "Uint8",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the a.\n\n@returns current a value.",
              "hints": {
                "body": "return a;"
              }
            },
            "SetA": {
              "kind": "function",
              "name": "SetA",
              "type": "Color &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "Uint8",
                  "name": "newA"
                }
              ],
              "doc": "Set the a.\n\n@param newA the new a value.\n@returns Reference to self.",
              "hints": {
                "body": "a = newA;\nreturn *this;"
              }
            }
          }
        },
        "FColor": {
          "doc": "The bits of this structure can be directly reinterpreted as a float-packed\ncolor which uses the PIXELFORMAT_RGBA128_FLOAT format\n\n@since This struct is available since SDL 3.2.0.",
          "name": "FColor",
          "kind": "struct",
          "sourceName": "SDL_FColor",
          "hints": {
            "self": "this",
            "super": "SDL_FColor"
          },
          "type": "SDL_FColor",
          "entries": {
            "FColor": [
              {
                "kind": "function",
                "name": "FColor",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "const FColorRaw &",
                    "name": "color",
                    "default": "{}"
                  }
                ],
                "doc": "Wraps FColor.\n\n@param color the value to be wrapped",
                "hints": {
                  "init": [
                    "SDL_FColor(color)"
                  ]
                }
              },
              {
                "kind": "function",
                "name": "FColor",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "float",
                    "name": "r"
                  },
                  {
                    "type": "float",
                    "name": "g"
                  },
                  {
                    "type": "float",
                    "name": "b"
                  },
                  {
                    "type": "float",
                    "name": "a"
                  }
                ],
                "doc": "Constructs from its fields.\n\n@param r the value for r.\n@param g the value for g.\n@param b the value for b.\n@param a the value for a.",
                "hints": {
                  "init": [
                    "SDL_FColor{r, g, b, a}"
                  ]
                }
              }
            ],
            "operator<=>": [
              {
                "kind": "function",
                "name": "operator<=>",
                "type": "auto",
                "constexpr": true,
                "immutable": true,
                "parameters": [
                  {
                    "type": "const FColor &",
                    "name": "other"
                  }
                ],
                "doc": "Default comparison operator",
                "hints": {
                  "default": true
                }
              },
              {
                "kind": "function",
                "name": "operator<=>",
                "type": "auto",
                "constexpr": true,
                "immutable": true,
                "parameters": [
                  {
                    "type": "const FColorRaw &",
                    "name": "color"
                  }
                ],
                "doc": "Compares with the underlying type",
                "hints": {
                  "body": "return operator<=>(FColor(color));"
                }
              }
            ],
            "GetR": {
              "kind": "function",
              "name": "GetR",
              "type": "float",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the r.\n\n@returns current r value.",
              "hints": {
                "body": "return r;"
              }
            },
            "SetR": {
              "kind": "function",
              "name": "SetR",
              "type": "FColor &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "float",
                  "name": "newR"
                }
              ],
              "doc": "Set the r.\n\n@param newR the new r value.\n@returns Reference to self.",
              "hints": {
                "body": "r = newR;\nreturn *this;"
              }
            },
            "GetG": {
              "kind": "function",
              "name": "GetG",
              "type": "float",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the g.\n\n@returns current g value.",
              "hints": {
                "body": "return g;"
              }
            },
            "SetG": {
              "kind": "function",
              "name": "SetG",
              "type": "FColor &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "float",
                  "name": "newG"
                }
              ],
              "doc": "Set the g.\n\n@param newG the new g value.\n@returns Reference to self.",
              "hints": {
                "body": "g = newG;\nreturn *this;"
              }
            },
            "GetB": {
              "kind": "function",
              "name": "GetB",
              "type": "float",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the b.\n\n@returns current b value.",
              "hints": {
                "body": "return b;"
              }
            },
            "SetB": {
              "kind": "function",
              "name": "SetB",
              "type": "FColor &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "float",
                  "name": "newB"
                }
              ],
              "doc": "Set the b.\n\n@param newB the new b value.\n@returns Reference to self.",
              "hints": {
                "body": "b = newB;\nreturn *this;"
              }
            },
            "GetA": {
              "kind": "function",
              "name": "GetA",
              "type": "float",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the a.\n\n@returns current a value.",
              "hints": {
                "body": "return a;"
              }
            },
            "SetA": {
              "kind": "function",
              "name": "SetA",
              "type": "FColor &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "float",
                  "name": "newA"
                }
              ],
              "doc": "Set the a.\n\n@param newA the new a value.\n@returns Reference to self.",
              "hints": {
                "body": "a = newA;\nreturn *this;"
              }
            }
          }
        },
        "Palette": {
          "doc": "A set of indexed colors representing a palette.\n\n@since This struct is available since SDL 3.2.0.\n\n@sa Palette.SetColors\n\n@cat resource",
          "name": "Palette",
          "kind": "struct",
          "sourceName": "SDL_Palette",
          "entries": {
            "m_resource": {
              "kind": "var",
              "type": "PaletteRaw",
              "hints": {
                "body": "nullptr"
              },
              "name": "m_resource",
              "doc": ""
            },
            "Palette": [
              {
                "kind": "function",
                "type": "",
                "constexpr": true,
                "parameters": [],
                "hints": {
                  "default": true,
                  "changeAccess": "public"
                },
                "name": "Palette",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "",
                "constexpr": true,
                "explicit": true,
                "parameters": [
                  {
                    "name": "resource",
                    "type": "const PaletteRaw"
                  }
                ],
                "hints": {
                  "init": [
                    "m_resource(resource)"
                  ]
                },
                "name": "Palette",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "other",
                    "type": "const Palette &"
                  }
                ],
                "hints": {
                  "init": [
                    "m_resource(other.m_resource)"
                  ],
                  "body": "++m_resource->refcount;"
                },
                "name": "Palette",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "name": "other",
                    "type": "Palette &&"
                  }
                ],
                "hints": {
                  "init": [
                    "m_resource(other.m_resource)"
                  ],
                  "body": "other.m_resource = nullptr;"
                },
                "name": "Palette",
                "doc": ""
              },
              {
                "doc": "Create a palette structure with the specified number of color entries.\n\nThe palette entries are initialized to white.\n\n@param ncolors represents the number of color entries in the color palette.\n@post a new Palette structure on success.\n@throws Error on failure.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Palette.Destroy\n@sa Palette.SetColors\n@sa SDL_SetSurfacePalette",
                "name": "Palette",
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "ncolors",
                    "type": "int"
                  }
                ],
                "sourceName": "SDL_CreatePalette",
                "hints": {
                  "mayFail": true
                }
              }
            ],
            "~Palette": {
              "kind": "function",
              "type": "",
              "parameters": [],
              "hints": {
                "body": "SDL_DestroyPalette(m_resource);"
              },
              "name": "~Palette",
              "doc": ""
            },
            "operator=": {
              "kind": "function",
              "type": "Palette &",
              "parameters": [
                {
                  "name": "other",
                  "type": "Palette"
                }
              ],
              "hints": {
                "body": "std::swap(m_resource, other.m_resource);\nreturn *this;"
              },
              "name": "operator=",
              "doc": ""
            },
            "get": {
              "kind": "function",
              "type": "PaletteRaw",
              "immutable": true,
              "constexpr": true,
              "parameters": [],
              "hints": {
                "body": "return m_resource;"
              },
              "name": "get",
              "doc": ""
            },
            "release": {
              "kind": "function",
              "type": "PaletteRaw",
              "constexpr": true,
              "parameters": [],
              "hints": {
                "body": "auto r = m_resource;\nm_resource = nullptr;\nreturn r;"
              },
              "name": "release",
              "doc": ""
            },
            "operator PaletteParam": {
              "kind": "function",
              "type": "",
              "immutable": true,
              "constexpr": true,
              "parameters": [],
              "hints": {
                "body": "return {m_resource};"
              },
              "name": "operator PaletteParam",
              "doc": ""
            },
            "GetSize": {
              "kind": "function",
              "type": "int",
              "immutable": true,
              "constexpr": true,
              "parameters": [],
              "name": "GetSize",
              "doc": ""
            },
            "operator[]": {
              "kind": "function",
              "type": "Color",
              "immutable": true,
              "constexpr": true,
              "parameters": [
                {
                  "type": "int",
                  "name": "index"
                }
              ],
              "name": "operator[]",
              "doc": ""
            },
            "SetColors": {
              "doc": "Set a range of colors in a palette.\n\n@param colors an array of Color structures to copy into the palette.\n@param firstcolor the index of the first palette entry to modify.\n@param ncolors the number of entries to modify.\n@throws Error on failure.\n\n@threadsafety It is safe to call this function from any thread, as long as\n              the palette is not modified or destroyed in another thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "SetColors",
              "kind": "function",
              "type": "void",
              "parameters": [
                {
                  "name": "colors",
                  "type": "SpanRef<const SDL_Color>"
                },
                {
                  "name": "firstcolor",
                  "type": "int",
                  "default": "0"
                }
              ],
              "sourceName": "SDL_SetPaletteColors",
              "hints": {
                "mayFail": true
              }
            },
            "Destroy": {
              "doc": "Free a palette created with Palette.Palette().\n\n\n@threadsafety It is safe to call this function from any thread, as long as\n              the palette is not modified or destroyed in another thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Palette.Palette",
              "name": "Destroy",
              "kind": "function",
              "type": "void",
              "parameters": [],
              "sourceName": "SDL_DestroyPalette",
              "hints": {
                "body": "SDL_DestroyPalette(m_resource);\nm_resource = nullptr;"
              }
            }
          },
          "hints": {
            "self": "m_resource",
            "super": "m_resource",
            "private": true
          }
        },
        "GetPixelFormatName": {
          "doc": "Get the human readable name of a pixel format.\n\n@param format the pixel format to query.\n@returns the human readable name of the specified pixel format or\n         \"PIXELFORMAT_UNKNOWN\" if the format isn't recognized.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetPixelFormatName",
          "kind": "function",
          "type": "const char *",
          "parameters": [
            {
              "name": "format",
              "type": "PixelFormat"
            }
          ],
          "sourceName": "SDL_GetPixelFormatName"
        },
        "GetMasksForPixelFormat": {
          "doc": "Convert one of the enumerated pixel formats to a bpp value and RGBA masks.\n\n@param format one of the PixelFormat values.\n@param bpp a bits per pixel value; usually 15, 16, or 32.\n@param Rmask a pointer filled in with the red mask for the format.\n@param Gmask a pointer filled in with the green mask for the format.\n@param Bmask a pointer filled in with the blue mask for the format.\n@param Amask a pointer filled in with the alpha mask for the format.\n@throws Error on failure.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PixelFormat.ForMasks",
          "name": "GetMasksForPixelFormat",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "format",
              "type": "PixelFormat"
            },
            {
              "name": "bpp",
              "type": "int *"
            },
            {
              "name": "Rmask",
              "type": "Uint32 *"
            },
            {
              "name": "Gmask",
              "type": "Uint32 *"
            },
            {
              "name": "Bmask",
              "type": "Uint32 *"
            },
            {
              "name": "Amask",
              "type": "Uint32 *"
            }
          ],
          "sourceName": "SDL_GetMasksForPixelFormat",
          "hints": {
            "mayFail": true
          }
        },
        "GetPixelFormatForMasks": {
          "doc": "Convert a bpp value and RGBA masks to an enumerated pixel format.\n\nThis will return `PIXELFORMAT_UNKNOWN` if the conversion wasn't\npossible.\n\n@param bpp a bits per pixel value; usually 15, 16, or 32.\n@param Rmask the red mask for the format.\n@param Gmask the green mask for the format.\n@param Bmask the blue mask for the format.\n@param Amask the alpha mask for the format.\n@returns the PixelFormat value corresponding to the format masks, or\n         PIXELFORMAT_UNKNOWN if there isn't a match.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PixelFormat.GetMasks",
          "name": "GetPixelFormatForMasks",
          "kind": "function",
          "type": "PixelFormat",
          "parameters": [
            {
              "name": "bpp",
              "type": "int"
            },
            {
              "name": "Rmask",
              "type": "Uint32"
            },
            {
              "name": "Gmask",
              "type": "Uint32"
            },
            {
              "name": "Bmask",
              "type": "Uint32"
            },
            {
              "name": "Amask",
              "type": "Uint32"
            }
          ],
          "sourceName": "SDL_GetPixelFormatForMasks"
        },
        "GetPixelFormatDetails": {
          "doc": "Create an PixelFormatDetails structure corresponding to a pixel format.\n\nReturned structure may come from a shared global cache (i.e. not newly\nallocated), and hence should not be modified, especially the palette. Weird\nerrors such as `Blit combination not supported` may occur.\n\n@param format one of the PixelFormat values.\n@returns a pointer to a PixelFormatDetails structure or nullptr on\n         failure; call GetError() for more information.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetPixelFormatDetails",
          "kind": "function",
          "type": "const PixelFormatDetails *",
          "parameters": [
            {
              "name": "format",
              "type": "PixelFormat"
            }
          ],
          "sourceName": "SDL_GetPixelFormatDetails"
        },
        "CreatePalette": {
          "doc": "Create a palette structure with the specified number of color entries.\n\nThe palette entries are initialized to white.\n\n@param ncolors represents the number of color entries in the color palette.\n@returns a new Palette structure on success.\n@throws Error on failure.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Palette.Destroy\n@sa Palette.SetColors\n@sa SDL_SetSurfacePalette",
          "name": "CreatePalette",
          "kind": "function",
          "type": "Palette",
          "parameters": [
            {
              "name": "ncolors",
              "type": "int"
            }
          ],
          "sourceName": "SDL_CreatePalette",
          "hints": {
            "mayFail": true,
            "wrapSelf": true
          }
        },
        "SetPaletteColors": {
          "doc": "Set a range of colors in a palette.\n\n@param palette the Palette structure to modify.\n@param colors an array of Color structures to copy into the palette.\n@param firstcolor the index of the first palette entry to modify.\n@param ncolors the number of entries to modify.\n@throws Error on failure.\n\n@threadsafety It is safe to call this function from any thread, as long as\n              the palette is not modified or destroyed in another thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "SetPaletteColors",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "palette",
              "type": "PaletteParam"
            },
            {
              "name": "colors",
              "type": "SpanRef<const SDL_Color>"
            },
            {
              "name": "firstcolor",
              "type": "int",
              "default": "0"
            }
          ],
          "sourceName": "SDL_SetPaletteColors",
          "hints": {
            "mayFail": true
          }
        },
        "DestroyPalette": {
          "doc": "Free a palette created with Palette.Palette().\n\n@param palette the Palette structure to be freed.\n\n@threadsafety It is safe to call this function from any thread, as long as\n              the palette is not modified or destroyed in another thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Palette.Palette",
          "name": "DestroyPalette",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "palette",
              "type": "PaletteRaw"
            }
          ],
          "sourceName": "SDL_DestroyPalette"
        },
        "MapRGB": {
          "doc": "Map an RGB triple to an opaque pixel value for a given pixel format.\n\nThis function maps the RGB color value to the specified pixel format and\nreturns the pixel value best approximating the given RGB color value for\nthe given pixel format.\n\nIf the format has a palette (8-bit) the index of the closest matching color\nin the palette will be returned.\n\nIf the specified pixel format has an alpha component it will be returned as\nall 1 bits (fully opaque).\n\nIf the pixel format bpp (color depth) is less than 32-bpp then the unused\nupper bits of the return value can safely be ignored (e.g., with a 16-bpp\nformat the return value can be assigned to a Uint16, and similarly a Uint8\nfor an 8-bpp format).\n\n@param format a pointer to PixelFormatDetails describing the pixel\n              format.\n@param palette an optional palette for indexed formats, may be nullptr.\n@param r the red component of the pixel in the range 0-255.\n@param g the green component of the pixel in the range 0-255.\n@param b the blue component of the pixel in the range 0-255.\n@returns a pixel value.\n\n@threadsafety It is safe to call this function from any thread, as long as\n              the palette is not modified.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PixelFormat.GetDetails\n@sa GetRGB\n@sa MapRGBA\n@sa SDL_MapSurfaceRGB",
          "name": "MapRGB",
          "kind": "function",
          "type": "Uint32",
          "parameters": [
            {
              "name": "format",
              "type": "const PixelFormatDetails *"
            },
            {
              "name": "palette",
              "type": "PaletteConstParam"
            },
            {
              "name": "r",
              "type": "Uint8"
            },
            {
              "name": "g",
              "type": "Uint8"
            },
            {
              "name": "b",
              "type": "Uint8"
            }
          ],
          "sourceName": "SDL_MapRGB"
        },
        "MapRGBA": {
          "doc": "Map an RGBA quadruple to a pixel value for a given pixel format.\n\nThis function maps the RGBA color value to the specified pixel format and\nreturns the pixel value best approximating the given RGBA color value for\nthe given pixel format.\n\nIf the specified pixel format has no alpha component the alpha value will\nbe ignored (as it will be in formats with a palette).\n\nIf the format has a palette (8-bit) the index of the closest matching color\nin the palette will be returned.\n\nIf the pixel format bpp (color depth) is less than 32-bpp then the unused\nupper bits of the return value can safely be ignored (e.g., with a 16-bpp\nformat the return value can be assigned to a Uint16, and similarly a Uint8\nfor an 8-bpp format).\n\n@param format a pointer to PixelFormatDetails describing the pixel\n              format.\n@param palette an optional palette for indexed formats, may be nullptr.\n@param r the red component of the pixel in the range 0-255.\n@param g the green component of the pixel in the range 0-255.\n@param b the blue component of the pixel in the range 0-255.\n@param a the alpha component of the pixel in the range 0-255.\n@returns a pixel value.\n\n@threadsafety It is safe to call this function from any thread, as long as\n              the palette is not modified.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PixelFormat.GetDetails\n@sa GetRGBA\n@sa MapRGB\n@sa SDL_MapSurfaceRGBA",
          "name": "MapRGBA",
          "kind": "function",
          "type": "Uint32",
          "parameters": [
            {
              "name": "format",
              "type": "const PixelFormatDetails *"
            },
            {
              "name": "palette",
              "type": "PaletteConstParam"
            },
            {
              "name": "r",
              "type": "Uint8"
            },
            {
              "name": "g",
              "type": "Uint8"
            },
            {
              "name": "b",
              "type": "Uint8"
            },
            {
              "name": "a",
              "type": "Uint8"
            }
          ],
          "sourceName": "SDL_MapRGBA"
        },
        "GetRGB": {
          "doc": "Get RGB values from a pixel in the specified format.\n\nThis function uses the entire 8-bit [0..255] range when converting color\ncomponents from pixel formats with less than 8-bits per RGB component\n(e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,\n0xff, 0xff] not [0xf8, 0xfc, 0xf8]).\n\n@param pixel a pixel value.\n@param format a pointer to PixelFormatDetails describing the pixel\n              format.\n@param palette an optional palette for indexed formats, may be nullptr.\n@param r a pointer filled in with the red component, may be nullptr.\n@param g a pointer filled in with the green component, may be nullptr.\n@param b a pointer filled in with the blue component, may be nullptr.\n\n@threadsafety It is safe to call this function from any thread, as long as\n              the palette is not modified.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PixelFormat.GetDetails\n@sa GetRGBA\n@sa MapRGB\n@sa MapRGBA",
          "name": "GetRGB",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "pixel",
              "type": "Uint32"
            },
            {
              "name": "format",
              "type": "const PixelFormatDetails *"
            },
            {
              "name": "palette",
              "type": "PaletteConstParam"
            },
            {
              "name": "r",
              "type": "Uint8 *"
            },
            {
              "name": "g",
              "type": "Uint8 *"
            },
            {
              "name": "b",
              "type": "Uint8 *"
            }
          ],
          "sourceName": "SDL_GetRGB"
        },
        "GetRGBA": {
          "doc": "Get RGBA values from a pixel in the specified format.\n\nThis function uses the entire 8-bit [0..255] range when converting color\ncomponents from pixel formats with less than 8-bits per RGB component\n(e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,\n0xff, 0xff] not [0xf8, 0xfc, 0xf8]).\n\nIf the surface has no alpha component, the alpha will be returned as 0xff\n(100% opaque).\n\n@param pixel a pixel value.\n@param format a pointer to PixelFormatDetails describing the pixel\n              format.\n@param palette an optional palette for indexed formats, may be nullptr.\n@param r a pointer filled in with the red component, may be nullptr.\n@param g a pointer filled in with the green component, may be nullptr.\n@param b a pointer filled in with the blue component, may be nullptr.\n@param a a pointer filled in with the alpha component, may be nullptr.\n\n@threadsafety It is safe to call this function from any thread, as long as\n              the palette is not modified.\n\n@since This function is available since SDL 3.2.0.\n\n@sa PixelFormat.GetDetails\n@sa GetRGB\n@sa MapRGB\n@sa MapRGBA",
          "name": "GetRGBA",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "pixel",
              "type": "Uint32"
            },
            {
              "name": "format",
              "type": "const PixelFormatDetails *"
            },
            {
              "name": "palette",
              "type": "PaletteConstParam"
            },
            {
              "name": "r",
              "type": "Uint8 *"
            },
            {
              "name": "g",
              "type": "Uint8 *"
            },
            {
              "name": "b",
              "type": "Uint8 *"
            },
            {
              "name": "a",
              "type": "Uint8 *"
            }
          ],
          "sourceName": "SDL_GetRGBA"
        }
      },
      "includes": [
        "SDL3/SDL_version.h",
        "SDL3/SDL_pixels.h"
      ],
      "localIncludes": [
        "SDL3pp_spanRef.h",
        "SDL3pp_error.h"
      ]
    },
    "SDL3pp_blendmode.h": {
      "name": "SDL3pp_blendmode.h",
      "doc": "@defgroup CategoryBlendmode Category Blendmode\n\nBlend modes decide how two colors will mix together. There are both\nstandard modes for basic needs and a means to create custom modes,\ndictating what sort of math to do on what color components.",
      "entries": {
        "BlendMode": {
          "doc": "A set of blend modes used in drawing operations.\n\nThese predefined blend modes are supported everywhere.\n\nAdditional values may be obtained from ComposeCustomBlendMode.\n\n@since This datatype is available since SDL 3.2.0.\n\n@sa ComposeCustomBlendMode",
          "name": "BlendMode",
          "kind": "alias",
          "type": "Uint32",
          "sourceName": "SDL_BlendMode"
        },
        "BLENDMODE_NONE": {
          "doc": "no blending: dstRGBA = srcRGBA",
          "name": "BLENDMODE_NONE",
          "kind": "var",
          "value": "0x00000000u",
          "sourceName": "SDL_BLENDMODE_NONE",
          "constexpr": true,
          "type": "BlendMode"
        },
        "BLENDMODE_BLEND": {
          "doc": "alpha blending: dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA)), dstA = srcA + (dstA * (1-srcA))",
          "name": "BLENDMODE_BLEND",
          "kind": "var",
          "value": "0x00000001u",
          "sourceName": "SDL_BLENDMODE_BLEND",
          "constexpr": true,
          "type": "BlendMode"
        },
        "BLENDMODE_BLEND_PREMULTIPLIED": {
          "doc": "pre-multiplied alpha blending: dstRGBA = srcRGBA + (dstRGBA * (1-srcA))",
          "name": "BLENDMODE_BLEND_PREMULTIPLIED",
          "kind": "var",
          "value": "0x00000010u",
          "sourceName": "SDL_BLENDMODE_BLEND_PREMULTIPLIED",
          "constexpr": true,
          "type": "BlendMode"
        },
        "BLENDMODE_ADD": {
          "doc": "additive blending: dstRGB = (srcRGB * srcA) + dstRGB, dstA = dstA",
          "name": "BLENDMODE_ADD",
          "kind": "var",
          "value": "0x00000002u",
          "sourceName": "SDL_BLENDMODE_ADD",
          "constexpr": true,
          "type": "BlendMode"
        },
        "BLENDMODE_ADD_PREMULTIPLIED": {
          "doc": "pre-multiplied additive blending: dstRGB = srcRGB + dstRGB, dstA = dstA",
          "name": "BLENDMODE_ADD_PREMULTIPLIED",
          "kind": "var",
          "value": "0x00000020u",
          "sourceName": "SDL_BLENDMODE_ADD_PREMULTIPLIED",
          "constexpr": true,
          "type": "BlendMode"
        },
        "BLENDMODE_MOD": {
          "doc": "color modulate: dstRGB = srcRGB * dstRGB, dstA = dstA",
          "name": "BLENDMODE_MOD",
          "kind": "var",
          "value": "0x00000004u",
          "sourceName": "SDL_BLENDMODE_MOD",
          "constexpr": true,
          "type": "BlendMode"
        },
        "BLENDMODE_MUL": {
          "doc": "color multiply: dstRGB = (srcRGB * dstRGB) + (dstRGB * (1-srcA)), dstA = dstA",
          "name": "BLENDMODE_MUL",
          "kind": "var",
          "value": "0x00000008u",
          "sourceName": "SDL_BLENDMODE_MUL",
          "constexpr": true,
          "type": "BlendMode"
        },
        "BLENDMODE_INVALID": {
          "doc": "INVALID",
          "name": "BLENDMODE_INVALID",
          "kind": "var",
          "value": "0x7FFFFFFFu",
          "sourceName": "SDL_BLENDMODE_INVALID",
          "constexpr": true,
          "type": "BlendMode"
        },
        "BlendOperation": {
          "doc": "The blend operation used when combining source and destination pixel\ncomponents.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "BlendOperation",
          "kind": "alias",
          "sourceName": "SDL_BlendOperation",
          "type": "SDL_BlendOperation"
        },
        "BLENDOPERATION_ADD": {
          "kind": "var",
          "name": "BLENDOPERATION_ADD",
          "constexpr": true,
          "type": "BlendOperation",
          "doc": "dst + src: supported by all renderers",
          "sourceName": "SDL_BLENDOPERATION_ADD"
        },
        "BLENDOPERATION_SUBTRACT": {
          "kind": "var",
          "name": "BLENDOPERATION_SUBTRACT",
          "constexpr": true,
          "type": "BlendOperation",
          "doc": "src - dst : supported by D3D, OpenGL, OpenGLES, and Vulkan",
          "sourceName": "SDL_BLENDOPERATION_SUBTRACT"
        },
        "BLENDOPERATION_REV_SUBTRACT": {
          "kind": "var",
          "name": "BLENDOPERATION_REV_SUBTRACT",
          "constexpr": true,
          "type": "BlendOperation",
          "doc": "dst - src : supported by D3D, OpenGL, OpenGLES, and Vulkan",
          "sourceName": "SDL_BLENDOPERATION_REV_SUBTRACT"
        },
        "BLENDOPERATION_MINIMUM": {
          "kind": "var",
          "name": "BLENDOPERATION_MINIMUM",
          "constexpr": true,
          "type": "BlendOperation",
          "doc": "min(dst, src) : supported by D3D, OpenGL, OpenGLES, and Vulkan",
          "sourceName": "SDL_BLENDOPERATION_MINIMUM"
        },
        "BLENDOPERATION_MAXIMUM": {
          "kind": "var",
          "name": "BLENDOPERATION_MAXIMUM",
          "constexpr": true,
          "type": "BlendOperation",
          "doc": "max(dst, src) : supported by D3D, OpenGL, OpenGLES, and Vulkan",
          "sourceName": "SDL_BLENDOPERATION_MAXIMUM"
        },
        "BlendFactor": {
          "doc": "The normalized factor used to multiply pixel components.\n\nThe blend factors are multiplied with the pixels from a drawing operation\n(src) and the pixels from the render target (dst) before the blend\noperation. The comma-separated factors listed above are always applied in\nthe component order red, green, blue, and alpha.\n\n@since This enum is available since SDL 3.2.0.",
          "name": "BlendFactor",
          "kind": "alias",
          "sourceName": "SDL_BlendFactor",
          "type": "SDL_BlendFactor"
        },
        "BLENDFACTOR_ZERO": {
          "kind": "var",
          "name": "BLENDFACTOR_ZERO",
          "constexpr": true,
          "type": "BlendFactor",
          "doc": "0, 0, 0, 0",
          "sourceName": "SDL_BLENDFACTOR_ZERO"
        },
        "BLENDFACTOR_ONE": {
          "kind": "var",
          "name": "BLENDFACTOR_ONE",
          "constexpr": true,
          "type": "BlendFactor",
          "doc": "1, 1, 1, 1",
          "sourceName": "SDL_BLENDFACTOR_ONE"
        },
        "BLENDFACTOR_SRC_COLOR": {
          "kind": "var",
          "name": "BLENDFACTOR_SRC_COLOR",
          "constexpr": true,
          "type": "BlendFactor",
          "doc": "srcR, srcG, srcB, srcA",
          "sourceName": "SDL_BLENDFACTOR_SRC_COLOR"
        },
        "BLENDFACTOR_ONE_MINUS_SRC_COLOR": {
          "kind": "var",
          "name": "BLENDFACTOR_ONE_MINUS_SRC_COLOR",
          "constexpr": true,
          "type": "BlendFactor",
          "doc": "1-srcR, 1-srcG, 1-srcB, 1-srcA",
          "sourceName": "SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR"
        },
        "BLENDFACTOR_SRC_ALPHA": {
          "kind": "var",
          "name": "BLENDFACTOR_SRC_ALPHA",
          "constexpr": true,
          "type": "BlendFactor",
          "doc": "srcA, srcA, srcA, srcA",
          "sourceName": "SDL_BLENDFACTOR_SRC_ALPHA"
        },
        "BLENDFACTOR_ONE_MINUS_SRC_ALPHA": {
          "kind": "var",
          "name": "BLENDFACTOR_ONE_MINUS_SRC_ALPHA",
          "constexpr": true,
          "type": "BlendFactor",
          "doc": "1-srcA, 1-srcA, 1-srcA, 1-srcA",
          "sourceName": "SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA"
        },
        "BLENDFACTOR_DST_COLOR": {
          "kind": "var",
          "name": "BLENDFACTOR_DST_COLOR",
          "constexpr": true,
          "type": "BlendFactor",
          "doc": "dstR, dstG, dstB, dstA",
          "sourceName": "SDL_BLENDFACTOR_DST_COLOR"
        },
        "BLENDFACTOR_ONE_MINUS_DST_COLOR": {
          "kind": "var",
          "name": "BLENDFACTOR_ONE_MINUS_DST_COLOR",
          "constexpr": true,
          "type": "BlendFactor",
          "doc": "1-dstR, 1-dstG, 1-dstB, 1-dstA",
          "sourceName": "SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR"
        },
        "BLENDFACTOR_DST_ALPHA": {
          "kind": "var",
          "name": "BLENDFACTOR_DST_ALPHA",
          "constexpr": true,
          "type": "BlendFactor",
          "doc": "dstA, dstA, dstA, dstA",
          "sourceName": "SDL_BLENDFACTOR_DST_ALPHA"
        },
        "BLENDFACTOR_ONE_MINUS_DST_ALPHA": {
          "kind": "var",
          "name": "BLENDFACTOR_ONE_MINUS_DST_ALPHA",
          "constexpr": true,
          "type": "BlendFactor",
          "doc": "1-dstA, 1-dstA, 1-dstA, 1-dstA",
          "sourceName": "SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA"
        },
        "ComposeCustomBlendMode": {
          "doc": "Compose a custom blend mode for renderers.\n\nThe functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept\nthe BlendMode returned by this function if the renderer supports it.\n\nA blend mode controls how the pixels from a drawing operation (source) get\ncombined with the pixels from the render target (destination). First, the\ncomponents of the source and destination pixels get multiplied with their\nblend factors. Then, the blend operation takes the two products and\ncalculates the result that will get stored in the render target.\n\nExpressed in pseudocode, it would look like this:\n\n```c\ndstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);\ndstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);\n```\n\nWhere the functions `colorOperation(src, dst)` and `alphaOperation(src,\ndst)` can return one of the following:\n\n- `src + dst`\n- `src - dst`\n- `dst - src`\n- `min(src, dst)`\n- `max(src, dst)`\n\nThe red, green, and blue components are always multiplied with the first,\nsecond, and third components of the BlendFactor, respectively. The\nfourth component is not used.\n\nThe alpha component is always multiplied with the fourth component of the\nBlendFactor. The other components are not used in the alpha\ncalculation.\n\nSupport for these blend modes varies for each renderer. To check if a\nspecific BlendMode is supported, create a renderer and pass it to\neither SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will\nreturn with an error if the blend mode is not supported.\n\nThis list describes the support of custom blend modes for each renderer.\nAll renderers support the four blend modes listed in the BlendMode\nenumeration.\n\n- **direct3d**: Supports all operations with all factors. However, some\n  factors produce unexpected results with `BLENDOPERATION_MINIMUM` and\n  `BLENDOPERATION_MAXIMUM`.\n- **direct3d11**: Same as Direct3D 9.\n- **opengl**: Supports the `BLENDOPERATION_ADD` operation with all\n  factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly here.\n- **opengles2**: Supports the `BLENDOPERATION_ADD`,\n  `BLENDOPERATION_SUBTRACT`, `BLENDOPERATION_REV_SUBTRACT`\n  operations with all factors.\n- **psp**: No custom blend mode support.\n- **software**: No custom blend mode support.\n\nSome renderers do not provide an alpha component for the default render\ntarget. The `BLENDFACTOR_DST_ALPHA` and\n`BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this\ncase.\n\n@param srcColorFactor the BlendFactor applied to the red, green, and\n                      blue components of the source pixels.\n@param dstColorFactor the BlendFactor applied to the red, green, and\n                      blue components of the destination pixels.\n@param colorOperation the BlendOperation used to combine the red,\n                      green, and blue components of the source and\n                      destination pixels.\n@param srcAlphaFactor the BlendFactor applied to the alpha component of\n                      the source pixels.\n@param dstAlphaFactor the BlendFactor applied to the alpha component of\n                      the destination pixels.\n@param alphaOperation the BlendOperation used to combine the alpha\n                      component of the source and destination pixels.\n@returns an BlendMode that represents the chosen factors and\n         operations.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa SDL_SetRenderDrawBlendMode\n@sa SDL_GetRenderDrawBlendMode\n@sa SDL_SetTextureBlendMode\n@sa SDL_GetTextureBlendMode",
          "name": "ComposeCustomBlendMode",
          "kind": "function",
          "type": "BlendMode",
          "parameters": [
            {
              "name": "srcColorFactor",
              "type": "BlendFactor"
            },
            {
              "name": "dstColorFactor",
              "type": "BlendFactor"
            },
            {
              "name": "colorOperation",
              "type": "BlendOperation"
            },
            {
              "name": "srcAlphaFactor",
              "type": "BlendFactor"
            },
            {
              "name": "dstAlphaFactor",
              "type": "BlendFactor"
            },
            {
              "name": "alphaOperation",
              "type": "BlendOperation"
            }
          ],
          "sourceName": "SDL_ComposeCustomBlendMode"
        }
      },
      "includes": [
        "SDL3/SDL_blendmode.h"
      ]
    },
    "SDL3pp_rect.h": {
      "name": "SDL3pp_rect.h",
      "doc": "@defgroup CategoryRect Category Rect\n\nSome helper functions for managing rectangles and 2D points, in both\ninteger and floating point versions.",
      "entries": {
        "PointRaw": {
          "name": "PointRaw",
          "kind": "alias",
          "type": "SDL_Point",
          "doc": ""
        },
        "FPointRaw": {
          "name": "FPointRaw",
          "kind": "alias",
          "type": "SDL_FPoint",
          "doc": ""
        },
        "RectRaw": {
          "name": "RectRaw",
          "kind": "alias",
          "type": "SDL_Rect",
          "doc": ""
        },
        "FRectRaw": {
          "name": "FRectRaw",
          "kind": "alias",
          "type": "SDL_FRect",
          "doc": ""
        },
        "FPoint-forward": {
          "kind": "forward",
          "name": "FPoint",
          "doc": ""
        },
        "Rect-forward": {
          "kind": "forward",
          "name": "Rect",
          "doc": ""
        },
        "FRect-forward": {
          "kind": "forward",
          "name": "FRect",
          "doc": ""
        },
        "Point": {
          "doc": "The structure that defines a point (using integers).\n\n@since This struct is available since SDL 3.2.0.\n\n@sa Rect.GetEnclosingPoints\n@sa Point.InRect",
          "name": "Point",
          "kind": "struct",
          "sourceName": "SDL_Point",
          "entries": {
            "Point": [
              {
                "kind": "function",
                "name": "Point",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "const PointRaw &",
                    "name": "p",
                    "default": "{}"
                  }
                ],
                "doc": "Wraps Point.\n\n@param p the value to be wrapped",
                "hints": {
                  "init": [
                    "SDL_Point(p)"
                  ]
                }
              },
              {
                "kind": "function",
                "name": "Point",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "int",
                    "name": "x"
                  },
                  {
                    "type": "int",
                    "name": "y"
                  }
                ],
                "doc": "Constructs from its fields.\n\n@param x the value for x.\n@param y the value for y.",
                "hints": {
                  "init": [
                    "SDL_Point{x, y}"
                  ]
                }
              },
              {
                "kind": "function",
                "type": "",
                "constexpr": true,
                "explicit": true,
                "parameters": [
                  {
                    "type": "const FPointRaw &",
                    "name": "p"
                  }
                ],
                "name": "Point",
                "doc": "Wraps Point.\n\n@param p the value to be wrapped"
              }
            ],
            "operator==": [
              {
                "kind": "function",
                "name": "operator==",
                "type": "bool",
                "constexpr": true,
                "immutable": true,
                "parameters": [
                  {
                    "type": "const PointRaw &",
                    "name": "other"
                  }
                ],
                "doc": "Compares with the underlying type",
                "hints": {
                  "body": "return x == other.x && y == other.y;"
                }
              },
              {
                "kind": "function",
                "name": "operator==",
                "type": "bool",
                "constexpr": true,
                "immutable": true,
                "parameters": [
                  {
                    "type": "const Point &",
                    "name": "other"
                  }
                ],
                "doc": "Compares with the underlying type",
                "hints": {
                  "body": "return *this == (const PointRaw &)(other);"
                }
              }
            ],
            "operator bool": {
              "kind": "function",
              "name": "operator bool",
              "type": "",
              "constexpr": true,
              "explicit": true,
              "immutable": true,
              "parameters": [],
              "doc": "Check if valid.\n\n@returns True if valid state, false otherwise.",
              "hints": {
                "body": "return *this != SDL_Point{};"
              }
            },
            "GetX": {
              "kind": "function",
              "name": "GetX",
              "type": "int",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the x.\n\n@returns current x value.",
              "hints": {
                "body": "return x;"
              }
            },
            "SetX": {
              "kind": "function",
              "name": "SetX",
              "type": "Point &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "int",
                  "name": "newX"
                }
              ],
              "doc": "Set the x.\n\n@param newX the new x value.\n@returns Reference to self.",
              "hints": {
                "body": "x = newX;\nreturn *this;"
              }
            },
            "GetY": {
              "kind": "function",
              "name": "GetY",
              "type": "int",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the y.\n\n@returns current y value.",
              "hints": {
                "body": "return y;"
              }
            },
            "SetY": {
              "kind": "function",
              "name": "SetY",
              "type": "Point &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "int",
                  "name": "newY"
                }
              ],
              "doc": "Set the y.\n\n@param newY the new y value.\n@returns Reference to self.",
              "hints": {
                "body": "y = newY;\nreturn *this;"
              }
            },
            "InRect": {
              "doc": "Determine whether a point resides inside a rectangle.\n\nA point is considered part of a rectangle if both `p` and `r` are not nullptr,\nand `p`'s x and y coordinates are >= to the rectangle's top left corner,\nand < the rectangle's x+w and y+h. So a 1x1 rectangle considers point (0,0)\nas \"inside\" and (0,1) as not.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param r the rectangle to test.\n@returns true if `p` is contained by `r`, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "InRect",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "r",
                  "type": "const RectRaw &"
                }
              ],
              "sourceName": "SDL_PointInRect",
              "constexpr": true,
              "immutable": true
            }
          },
          "hints": {
            "self": "this",
            "super": "SDL_Point"
          },
          "type": "SDL_Point"
        },
        "FPoint": {
          "doc": "The structure that defines a point (using floating point values).\n\n@since This struct is available since SDL 3.2.0.\n\n@sa FRect.GetEnclosingPoints\n@sa FPoint.InRect",
          "name": "FPoint",
          "kind": "struct",
          "sourceName": "SDL_FPoint",
          "entries": {
            "FPoint": [
              {
                "kind": "function",
                "name": "FPoint",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "const FPointRaw &",
                    "name": "p",
                    "default": "{}"
                  }
                ],
                "doc": "Wraps FPoint.\n\n@param p the value to be wrapped",
                "hints": {
                  "init": [
                    "SDL_FPoint(p)"
                  ]
                }
              },
              {
                "kind": "function",
                "name": "FPoint",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "float",
                    "name": "x"
                  },
                  {
                    "type": "float",
                    "name": "y"
                  }
                ],
                "doc": "Constructs from its fields.\n\n@param x the value for x.\n@param y the value for y.",
                "hints": {
                  "init": [
                    "SDL_FPoint{x, y}"
                  ]
                }
              }
            ],
            "operator==": [
              {
                "kind": "function",
                "name": "operator==",
                "type": "bool",
                "constexpr": true,
                "immutable": true,
                "parameters": [
                  {
                    "type": "const FPointRaw &",
                    "name": "other"
                  }
                ],
                "doc": "Compares with the underlying type",
                "hints": {
                  "body": "return x == other.x && y == other.y;"
                }
              },
              {
                "kind": "function",
                "name": "operator==",
                "type": "bool",
                "constexpr": true,
                "immutable": true,
                "parameters": [
                  {
                    "type": "const FPoint &",
                    "name": "other"
                  }
                ],
                "doc": "Compares with the underlying type",
                "hints": {
                  "body": "return *this == (const FPointRaw &)(other);"
                }
              }
            ],
            "operator bool": {
              "kind": "function",
              "name": "operator bool",
              "type": "",
              "constexpr": true,
              "explicit": true,
              "immutable": true,
              "parameters": [],
              "doc": "Check if valid.\n\n@returns True if valid state, false otherwise.",
              "hints": {
                "body": "return *this != SDL_FPoint{};"
              }
            },
            "GetX": {
              "kind": "function",
              "name": "GetX",
              "type": "float",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the x.\n\n@returns current x value.",
              "hints": {
                "body": "return x;"
              }
            },
            "SetX": {
              "kind": "function",
              "name": "SetX",
              "type": "FPoint &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "float",
                  "name": "newX"
                }
              ],
              "doc": "Set the x.\n\n@param newX the new x value.\n@returns Reference to self.",
              "hints": {
                "body": "x = newX;\nreturn *this;"
              }
            },
            "GetY": {
              "kind": "function",
              "name": "GetY",
              "type": "float",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the y.\n\n@returns current y value.",
              "hints": {
                "body": "return y;"
              }
            },
            "SetY": {
              "kind": "function",
              "name": "SetY",
              "type": "FPoint &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "float",
                  "name": "newY"
                }
              ],
              "doc": "Set the y.\n\n@param newY the new y value.\n@returns Reference to self.",
              "hints": {
                "body": "y = newY;\nreturn *this;"
              }
            },
            "InRect": {
              "doc": "Determine whether a point resides inside a floating point rectangle.\n\nA point is considered part of a rectangle if both `p` and `r` are not nullptr,\nand `p`'s x and y coordinates are >= to the rectangle's top left corner,\nand <= the rectangle's x+w and y+h. So a 1x1 rectangle considers point\n(0,0) and (0,1) as \"inside\" and (0,2) as not.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param r the rectangle to test.\n@returns true if `p` is contained by `r`, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "InRect",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "r",
                  "type": "const FRectRaw &"
                }
              ],
              "sourceName": "SDL_PointInRectFloat",
              "constexpr": true,
              "immutable": true
            }
          },
          "hints": {
            "self": "this",
            "super": "SDL_FPoint"
          },
          "type": "SDL_FPoint"
        },
        "Rect": {
          "doc": "A rectangle, with the origin at the upper left (using integers).\n\n@since This struct is available since SDL 3.2.0.\n\n@sa Rect.Empty\n@sa Rect.Equal\n@sa Rect.HasIntersection\n@sa Rect.GetIntersection\n@sa Rect.GetLineIntersection\n@sa Rect.GetUnion\n@sa Rect.GetEnclosingPoints",
          "name": "Rect",
          "kind": "struct",
          "sourceName": "SDL_Rect",
          "entries": {
            "Rect": [
              {
                "kind": "function",
                "name": "Rect",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "const RectRaw &",
                    "name": "r",
                    "default": "{}"
                  }
                ],
                "doc": "Wraps Rect.\n\n@param r the value to be wrapped",
                "hints": {
                  "init": [
                    "SDL_Rect(r)"
                  ]
                }
              },
              {
                "kind": "function",
                "name": "Rect",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "int",
                    "name": "x"
                  },
                  {
                    "type": "int",
                    "name": "y"
                  },
                  {
                    "type": "int",
                    "name": "w"
                  },
                  {
                    "type": "int",
                    "name": "h"
                  }
                ],
                "doc": "Constructs from its fields.\n\n@param x the value for x.\n@param y the value for y.\n@param w the value for w.\n@param h the value for h.",
                "hints": {
                  "init": [
                    "SDL_Rect{x, y, w, h}"
                  ]
                }
              },
              {
                "kind": "function",
                "type": "",
                "parameters": [
                  {
                    "name": "corner",
                    "type": "const PointRaw &"
                  },
                  {
                    "name": "size",
                    "type": "const PointRaw &"
                  }
                ],
                "name": "Rect",
                "doc": "Wraps Rect.\n\n@param r the value to be wrapped"
              }
            ],
            "operator==": [
              {
                "kind": "function",
                "name": "operator==",
                "type": "bool",
                "constexpr": true,
                "immutable": true,
                "parameters": [
                  {
                    "type": "const RectRaw &",
                    "name": "other"
                  }
                ],
                "doc": "Compares with the underlying type",
                "hints": {
                  "body": "return x == other.x && y == other.y && w == other.w && h == other.h;"
                }
              },
              {
                "kind": "function",
                "name": "operator==",
                "type": "bool",
                "constexpr": true,
                "immutable": true,
                "parameters": [
                  {
                    "type": "const Rect &",
                    "name": "other"
                  }
                ],
                "doc": "Compares with the underlying type",
                "hints": {
                  "body": "return *this == (const RectRaw &)(other);"
                }
              }
            ],
            "operator bool": {
              "doc": "@sa Empty()",
              "kind": "function",
              "immutable": true,
              "explicit": true,
              "constexpr": true,
              "parameters": [],
              "type": "",
              "name": "operator bool"
            },
            "GetX": {
              "kind": "function",
              "name": "GetX",
              "type": "int",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the x.\n\n@returns current x value.",
              "hints": {
                "body": "return x;"
              }
            },
            "SetX": {
              "kind": "function",
              "name": "SetX",
              "type": "Rect &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "int",
                  "name": "newX"
                }
              ],
              "doc": "Set the x.\n\n@param newX the new x value.\n@returns Reference to self.",
              "hints": {
                "body": "x = newX;\nreturn *this;"
              }
            },
            "GetY": {
              "kind": "function",
              "name": "GetY",
              "type": "int",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the y.\n\n@returns current y value.",
              "hints": {
                "body": "return y;"
              }
            },
            "SetY": {
              "kind": "function",
              "name": "SetY",
              "type": "Rect &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "int",
                  "name": "newY"
                }
              ],
              "doc": "Set the y.\n\n@param newY the new y value.\n@returns Reference to self.",
              "hints": {
                "body": "y = newY;\nreturn *this;"
              }
            },
            "GetW": {
              "kind": "function",
              "name": "GetW",
              "type": "int",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the w.\n\n@returns current w value.",
              "hints": {
                "body": "return w;"
              }
            },
            "SetW": {
              "kind": "function",
              "name": "SetW",
              "type": "Rect &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "int",
                  "name": "newW"
                }
              ],
              "doc": "Set the w.\n\n@param newW the new w value.\n@returns Reference to self.",
              "hints": {
                "body": "w = newW;\nreturn *this;"
              }
            },
            "GetH": {
              "kind": "function",
              "name": "GetH",
              "type": "int",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the h.\n\n@returns current h value.",
              "hints": {
                "body": "return h;"
              }
            },
            "SetH": {
              "kind": "function",
              "name": "SetH",
              "type": "Rect &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "int",
                  "name": "newH"
                }
              ],
              "doc": "Set the h.\n\n@param newH the new h value.\n@returns Reference to self.",
              "hints": {
                "body": "h = newH;\nreturn *this;"
              }
            },
            "GetEnclosingPoints": {
              "doc": "Calculate a minimal rectangle enclosing a set of points.\n\nIf `clip` is not nullptr then only points inside of the clipping rectangle are\nconsidered.\n\n@param points an array of Point structures representing points to be\n              enclosed.\n@param count the number of structures in the `points` array.\n@param clip an Rect used for clipping or nullptr to enclose all points.\n@param result an Rect structure filled in with the minimal enclosing\n              rectangle.\n@returns true if any points were enclosed or false if all the points were\n         outside of the clipping rectangle.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetEnclosingPoints",
              "kind": "function",
              "type": "Rect",
              "parameters": [
                {
                  "name": "points",
                  "type": "SpanRef<const SDL_Point>"
                },
                {
                  "name": "clip",
                  "type": "OptionalRef<const SDL_Rect>",
                  "default": "std::nullopt"
                }
              ],
              "sourceName": "SDL_GetRectEnclosingPoints",
              "static": true
            },
            "FromCenter": [
              {
                "kind": "function",
                "name": "FromCenter",
                "constexpr": true,
                "static": true,
                "type": "Rect",
                "parameters": [
                  {
                    "name": "cx",
                    "type": "int"
                  },
                  {
                    "name": "cy",
                    "type": "int"
                  },
                  {
                    "name": "w",
                    "type": "int"
                  },
                  {
                    "name": "h",
                    "type": "int"
                  }
                ],
                "doc": ""
              },
              {
                "kind": "function",
                "name": "FromCenter",
                "constexpr": true,
                "static": true,
                "type": "Rect",
                "parameters": [
                  {
                    "name": "center",
                    "type": "const Point &"
                  },
                  {
                    "name": "size",
                    "type": "const Point &"
                  }
                ],
                "doc": ""
              }
            ],
            "FromCorners": [
              {
                "kind": "function",
                "name": "FromCorners",
                "static": true,
                "constexpr": true,
                "type": "Rect",
                "parameters": [
                  {
                    "name": "x1",
                    "type": "int"
                  },
                  {
                    "name": "y1",
                    "type": "int"
                  },
                  {
                    "name": "x2",
                    "type": "int"
                  },
                  {
                    "name": "y2",
                    "type": "int"
                  }
                ],
                "doc": ""
              },
              {
                "kind": "function",
                "name": "FromCorners",
                "constexpr": true,
                "static": true,
                "type": "Rect",
                "parameters": [
                  {
                    "name": "p1",
                    "type": "const PointRaw &"
                  },
                  {
                    "name": "p2",
                    "type": "const PointRaw &"
                  }
                ],
                "doc": ""
              }
            ],
            "GetX2": {
              "kind": "function",
              "name": "GetX2",
              "doc": ""
            },
            "SetX2": {
              "kind": "function",
              "name": "SetX2",
              "doc": ""
            },
            "GetY2": {
              "kind": "function",
              "name": "GetY2",
              "doc": ""
            },
            "SetY2": {
              "kind": "function",
              "name": "SetY2",
              "doc": ""
            },
            "GetTopLeft": {
              "kind": "function",
              "name": "GetTopLeft",
              "doc": ""
            },
            "GetTopRight": {
              "kind": "function",
              "name": "GetTopRight",
              "doc": ""
            },
            "GetBottomLeft": {
              "kind": "function",
              "name": "GetBottomLeft",
              "doc": ""
            },
            "GetBottomRight": {
              "kind": "function",
              "name": "GetBottomRight",
              "doc": ""
            },
            "GetSize": {
              "kind": "function",
              "name": "GetSize",
              "doc": ""
            },
            "GetCentroid": {
              "kind": "function",
              "name": "GetCentroid",
              "doc": ""
            },
            "GetLineIntersection": [
              {
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "type": "PointRaw *",
                    "name": "p1"
                  },
                  {
                    "type": "PointRaw *",
                    "name": "p2"
                  }
                ],
                "name": "GetLineIntersection",
                "doc": ""
              },
              {
                "doc": "Calculate the intersection of a rectangle and line segment.\n\nThis function is used to clip a line segment to a rectangle. A line segment\ncontained entirely within the rectangle or that does not intersect will\nremain unchanged. A line segment that crosses the rectangle at either or\nboth ends will be clipped to the boundary of the rectangle and the new\ncoordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.\n\n@param X1 a pointer to the starting X-coordinate of the line.\n@param Y1 a pointer to the starting Y-coordinate of the line.\n@param X2 a pointer to the ending X-coordinate of the line.\n@param Y2 a pointer to the ending Y-coordinate of the line.\n@returns true if there is an intersection, false otherwise.\n\n@since This function is available since SDL 3.2.0.",
                "name": "GetLineIntersection",
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "X1",
                    "type": "int *"
                  },
                  {
                    "name": "Y1",
                    "type": "int *"
                  },
                  {
                    "name": "X2",
                    "type": "int *"
                  },
                  {
                    "name": "Y2",
                    "type": "int *"
                  }
                ],
                "sourceName": "SDL_GetRectAndLineIntersection",
                "immutable": true
              }
            ],
            "operator SDL_FRect": {
              "doc": "Convert an Rect to FRect\n\n@param rect a pointer to an Rect.\n@param frect a pointer filled in with the floating point representation of\n             `rect`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "operator SDL_FRect",
              "kind": "function",
              "type": "",
              "parameters": [],
              "sourceName": "SDL_RectToFRect",
              "static": false,
              "immutable": true,
              "constexpr": true
            },
            "operator FRect": {
              "doc": "@sa operator ToFRect()",
              "name": "operator FRect",
              "static": false,
              "immutable": true,
              "constexpr": true,
              "parameters": [],
              "type": ""
            },
            "Empty": {
              "doc": "Determine whether a rectangle has no area.\n\nA rectangle is considered \"empty\" for this function if `r` is nullptr, or if\n`r`'s width and/or height are <= 0.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@returns true if the rectangle is \"empty\", false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "Empty",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_RectEmpty",
              "constexpr": true,
              "immutable": true
            },
            "Equal": {
              "doc": "Determine whether two rectangles are equal.\n\nRectangles are considered equal if both are not nullptr and each of their x,\ny, width and height match.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param b the second rectangle to test.\n@returns true if the rectangles are equal, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "Equal",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "other",
                  "type": "const RectRaw &"
                }
              ],
              "sourceName": "SDL_RectsEqual",
              "immutable": true,
              "constexpr": true
            },
            "Contains": [
              {
                "kind": "function",
                "type": "bool",
                "constexpr": true,
                "immutable": true,
                "parameters": [
                  {
                    "name": "p",
                    "type": "const PointRaw &"
                  }
                ],
                "name": "Contains",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "bool",
                "constexpr": true,
                "immutable": true,
                "parameters": [
                  {
                    "name": "other",
                    "type": "const RectRaw &"
                  }
                ],
                "name": "Contains",
                "doc": ""
              }
            ],
            "HasIntersection": {
              "doc": "Determine whether two rectangles intersect.\n\nIf either pointer is nullptr the function will return false.\n\n@param B an Rect structure representing the second rectangle.\n@returns true if there is an intersection, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Rect.GetIntersection",
              "name": "HasIntersection",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "other",
                  "type": "const RectRaw &"
                }
              ],
              "sourceName": "SDL_HasRectIntersection",
              "constexpr": true,
              "immutable": true
            },
            "GetIntersection": {
              "doc": "Calculate the intersection of two rectangles.\n\nIf `result` is nullptr then this function will return false.\n\n@param B an Rect structure representing the second rectangle.\n@param result an Rect structure filled in with the intersection of\n              rectangles `A` and `B`.\n@returns true if there is an intersection, false otherwise.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Rect.HasIntersection",
              "name": "GetIntersection",
              "kind": "function",
              "type": "std::optional<Rect>",
              "parameters": [
                {
                  "name": "other",
                  "type": "const RectRaw &"
                }
              ],
              "sourceName": "SDL_GetRectIntersection",
              "constexpr": true,
              "immutable": true
            },
            "GetUnion": {
              "doc": "Calculate the union of two rectangles.\n\n@param B an Rect structure representing the second rectangle.\n@param result an Rect structure filled in with the union of rectangles\n              `A` and `B`.\n@throws Error on failure.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetUnion",
              "kind": "function",
              "type": "Rect",
              "parameters": [
                {
                  "name": "other",
                  "type": "const RectRaw &"
                }
              ],
              "sourceName": "SDL_GetRectUnion",
              "hints": {
                "mayFail": true
              },
              "immutable": true,
              "constexpr": true
            }
          },
          "hints": {
            "self": "this",
            "super": "SDL_Rect"
          },
          "type": "SDL_Rect"
        },
        "FRect": {
          "doc": "A rectangle, with the origin at the upper left (using floating point\nvalues).\n\n@since This struct is available since SDL 3.2.0.\n\n@sa FRect.Empty\n@sa FRect.Equal\n@sa FRect.EqualEpsilon\n@sa FRect.HasIntersection\n@sa FRect.GetIntersection\n@sa FRect.GetLineIntersection\n@sa FRect.GetUnion\n@sa FRect.GetEnclosingPoints\n@sa FPoint.InRect",
          "name": "FRect",
          "kind": "struct",
          "sourceName": "SDL_FRect",
          "entries": {
            "FRect": [
              {
                "kind": "function",
                "name": "FRect",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "const FRectRaw &",
                    "name": "r",
                    "default": "{}"
                  }
                ],
                "doc": "Wraps FRect.\n\n@param r the value to be wrapped",
                "hints": {
                  "init": [
                    "SDL_FRect(r)"
                  ]
                }
              },
              {
                "kind": "function",
                "name": "FRect",
                "type": "",
                "constexpr": true,
                "parameters": [
                  {
                    "type": "float",
                    "name": "x"
                  },
                  {
                    "type": "float",
                    "name": "y"
                  },
                  {
                    "type": "float",
                    "name": "w"
                  },
                  {
                    "type": "float",
                    "name": "h"
                  }
                ],
                "doc": "Constructs from its fields.\n\n@param x the value for x.\n@param y the value for y.\n@param w the value for w.\n@param h the value for h.",
                "hints": {
                  "init": [
                    "SDL_FRect{x, y, w, h}"
                  ]
                }
              },
              {
                "kind": "function",
                "constexpr": true,
                "type": "",
                "parameters": [
                  {
                    "name": "corner",
                    "type": "const FPointRaw &"
                  },
                  {
                    "name": "size",
                    "type": "const FPointRaw &"
                  }
                ],
                "name": "FRect",
                "doc": "Wraps FRect.\n\n@param r the value to be wrapped"
              }
            ],
            "operator==": [
              {
                "kind": "function",
                "name": "operator==",
                "type": "bool",
                "constexpr": true,
                "immutable": true,
                "parameters": [
                  {
                    "type": "const FRectRaw &",
                    "name": "other"
                  }
                ],
                "doc": "Compares with the underlying type",
                "hints": {
                  "body": "return x == other.x && y == other.y && w == other.w && h == other.h;"
                }
              },
              {
                "kind": "function",
                "name": "operator==",
                "type": "bool",
                "constexpr": true,
                "immutable": true,
                "parameters": [
                  {
                    "type": "const FRect &",
                    "name": "other"
                  }
                ],
                "doc": "Compares with the underlying type",
                "hints": {
                  "body": "return *this == (const FRectRaw &)(other);"
                }
              }
            ],
            "operator bool": {
              "doc": "@sa Empty()",
              "kind": "function",
              "immutable": true,
              "explicit": true,
              "constexpr": true,
              "parameters": [],
              "type": "",
              "name": "operator bool"
            },
            "GetX": {
              "kind": "function",
              "name": "GetX",
              "type": "float",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the x.\n\n@returns current x value.",
              "hints": {
                "body": "return x;"
              }
            },
            "SetX": {
              "kind": "function",
              "name": "SetX",
              "type": "FRect &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "float",
                  "name": "newX"
                }
              ],
              "doc": "Set the x.\n\n@param newX the new x value.\n@returns Reference to self.",
              "hints": {
                "body": "x = newX;\nreturn *this;"
              }
            },
            "GetY": {
              "kind": "function",
              "name": "GetY",
              "type": "float",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the y.\n\n@returns current y value.",
              "hints": {
                "body": "return y;"
              }
            },
            "SetY": {
              "kind": "function",
              "name": "SetY",
              "type": "FRect &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "float",
                  "name": "newY"
                }
              ],
              "doc": "Set the y.\n\n@param newY the new y value.\n@returns Reference to self.",
              "hints": {
                "body": "y = newY;\nreturn *this;"
              }
            },
            "GetW": {
              "kind": "function",
              "name": "GetW",
              "type": "float",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the w.\n\n@returns current w value.",
              "hints": {
                "body": "return w;"
              }
            },
            "SetW": {
              "kind": "function",
              "name": "SetW",
              "type": "FRect &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "float",
                  "name": "newW"
                }
              ],
              "doc": "Set the w.\n\n@param newW the new w value.\n@returns Reference to self.",
              "hints": {
                "body": "w = newW;\nreturn *this;"
              }
            },
            "GetH": {
              "kind": "function",
              "name": "GetH",
              "type": "float",
              "constexpr": true,
              "immutable": true,
              "parameters": [],
              "doc": "Get the h.\n\n@returns current h value.",
              "hints": {
                "body": "return h;"
              }
            },
            "SetH": {
              "kind": "function",
              "name": "SetH",
              "type": "FRect &",
              "constexpr": true,
              "parameters": [
                {
                  "type": "float",
                  "name": "newH"
                }
              ],
              "doc": "Set the h.\n\n@param newH the new h value.\n@returns Reference to self.",
              "hints": {
                "body": "h = newH;\nreturn *this;"
              }
            },
            "GetEnclosingPoints": {
              "doc": "Calculate a minimal rectangle enclosing a set of points with float\nprecision.\n\nIf `clip` is not nullptr then only points inside of the clipping rectangle are\nconsidered.\n\n@param points an array of FPoint structures representing points to be\n              enclosed.\n@param count the number of structures in the `points` array.\n@param clip an FRect used for clipping or nullptr to enclose all points.\n@param result an FRect structure filled in with the minimal enclosing\n              rectangle.\n@returns true if any points were enclosed or false if all the points were\n         outside of the clipping rectangle.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetEnclosingPoints",
              "kind": "function",
              "type": "FRect",
              "parameters": [
                {
                  "name": "points",
                  "type": "SpanRef<const SDL_FPoint>"
                },
                {
                  "name": "clip",
                  "type": "OptionalRef<const SDL_FRect>",
                  "default": "std::nullopt"
                }
              ],
              "sourceName": "SDL_GetRectEnclosingPointsFloat",
              "constexpr": true,
              "static": true
            },
            "FromCenter": [
              {
                "kind": "function",
                "name": "FromCenter",
                "type": "FRect",
                "constexpr": true,
                "static": true,
                "parameters": [
                  {
                    "name": "cx",
                    "type": "float"
                  },
                  {
                    "name": "cy",
                    "type": "float"
                  },
                  {
                    "name": "w",
                    "type": "float"
                  },
                  {
                    "name": "h",
                    "type": "float"
                  }
                ],
                "doc": ""
              },
              {
                "kind": "function",
                "name": "FromCenter",
                "type": "FRect",
                "static": true,
                "constexpr": true,
                "parameters": [
                  {
                    "name": "center",
                    "type": "const FPointRaw &"
                  },
                  {
                    "name": "size",
                    "type": "const FPointRaw &"
                  }
                ],
                "doc": ""
              }
            ],
            "FromCorners": [
              {
                "kind": "function",
                "name": "FromCorners",
                "type": "FRect",
                "constexpr": true,
                "static": true,
                "parameters": [
                  {
                    "name": "x1",
                    "type": "float"
                  },
                  {
                    "name": "y1",
                    "type": "float"
                  },
                  {
                    "name": "x2",
                    "type": "float"
                  },
                  {
                    "name": "y2",
                    "type": "float"
                  }
                ],
                "doc": ""
              },
              {
                "kind": "function",
                "name": "FromCorners",
                "static": true,
                "constexpr": true,
                "type": "FRect",
                "parameters": [
                  {
                    "name": "p1",
                    "type": "const FPointRaw &"
                  },
                  {
                    "name": "p2",
                    "type": "const FPointRaw &"
                  }
                ],
                "doc": ""
              }
            ],
            "GetX2": {
              "kind": "function",
              "name": "GetX2",
              "doc": ""
            },
            "SetX2": {
              "kind": "function",
              "name": "SetX2",
              "doc": ""
            },
            "GetY2": {
              "kind": "function",
              "name": "GetY2",
              "doc": ""
            },
            "SetY2": {
              "kind": "function",
              "name": "SetY2",
              "doc": ""
            },
            "GetTopLeft": {
              "kind": "function",
              "name": "GetTopLeft",
              "doc": ""
            },
            "GetTopRight": {
              "kind": "function",
              "name": "GetTopRight",
              "doc": ""
            },
            "GetBottomLeft": {
              "kind": "function",
              "name": "GetBottomLeft",
              "doc": ""
            },
            "GetBottomRight": {
              "kind": "function",
              "name": "GetBottomRight",
              "doc": ""
            },
            "GetSize": {
              "kind": "function",
              "name": "GetSize",
              "doc": ""
            },
            "GetCentroid": {
              "kind": "function",
              "name": "GetCentroid",
              "doc": ""
            },
            "GetLineIntersection": {
              "doc": "Calculate the intersection of a rectangle and line segment with float\nprecision.\n\nThis function is used to clip a line segment to a rectangle. A line segment\ncontained entirely within the rectangle or that does not intersect will\nremain unchanged. A line segment that crosses the rectangle at either or\nboth ends will be clipped to the boundary of the rectangle and the new\ncoordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.\n\n@param X1 a pointer to the starting X-coordinate of the line.\n@param Y1 a pointer to the starting Y-coordinate of the line.\n@param X2 a pointer to the ending X-coordinate of the line.\n@param Y2 a pointer to the ending Y-coordinate of the line.\n@returns true if there is an intersection, false otherwise.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetLineIntersection",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "X1",
                  "type": "float *"
                },
                {
                  "name": "Y1",
                  "type": "float *"
                },
                {
                  "name": "X2",
                  "type": "float *"
                },
                {
                  "name": "Y2",
                  "type": "float *"
                }
              ],
              "sourceName": "SDL_GetRectAndLineIntersectionFloat",
              "immutable": true
            },
            "Empty": {
              "doc": "Determine whether a floating point rectangle can contain any point.\n\nA rectangle is considered \"empty\" for this function if `r` is nullptr, or if\n`r`'s width and/or height are < 0.0f.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@returns true if the rectangle is \"empty\", false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
              "name": "Empty",
              "kind": "function",
              "type": "bool",
              "parameters": [],
              "sourceName": "SDL_RectEmptyFloat",
              "constexpr": true,
              "immutable": true
            },
            "EqualEpsilon": {
              "doc": "Determine whether two floating point rectangles are equal, within some\ngiven epsilon.\n\nRectangles are considered equal if both are not nullptr and each of their x,\ny, width and height are within `epsilon` of each other. If you don't know\nwhat value to use for `epsilon`, you should call the FRect.Equal\nfunction instead.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param b the second rectangle to test.\n@param epsilon the epsilon value for comparison.\n@returns true if the rectangles are equal, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa FRect.Equal",
              "name": "EqualEpsilon",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "other",
                  "type": "const FRectRaw &"
                },
                {
                  "name": "epsilon",
                  "type": "const float"
                }
              ],
              "sourceName": "SDL_RectsEqualEpsilon",
              "immutable": true,
              "constexpr": true
            },
            "Equal": {
              "doc": "Determine whether two floating point rectangles are equal, within a default\nepsilon.\n\nRectangles are considered equal if both are not nullptr and each of their x,\ny, width and height are within SDL_FLT_EPSILON of each other. This is often\na reasonable way to compare two floating point rectangles and deal with the\nslight precision variations in floating point calculations that tend to pop\nup.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param b the second rectangle to test.\n@returns true if the rectangles are equal, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa FRect.EqualEpsilon",
              "name": "Equal",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "other",
                  "type": "const FRectRaw &"
                }
              ],
              "sourceName": "SDL_RectsEqualFloat",
              "immutable": true,
              "constexpr": true
            },
            "Contains": [
              {
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "p",
                    "type": "const FPointRaw &"
                  }
                ],
                "constexpr": true,
                "immutable": true,
                "name": "Contains",
                "doc": ""
              },
              {
                "kind": "function",
                "type": "bool",
                "parameters": [
                  {
                    "name": "other",
                    "type": "const FRectRaw &"
                  }
                ],
                "constexpr": true,
                "immutable": true,
                "name": "Contains",
                "doc": ""
              }
            ],
            "HasIntersection": {
              "doc": "Determine whether two rectangles intersect with float precision.\n\nIf either pointer is nullptr the function will return false.\n\n@param B an FRect structure representing the second rectangle.\n@returns true if there is an intersection, false otherwise.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Rect.GetIntersection",
              "name": "HasIntersection",
              "kind": "function",
              "type": "bool",
              "parameters": [
                {
                  "name": "other",
                  "type": "const FRectRaw &"
                }
              ],
              "sourceName": "SDL_HasRectIntersectionFloat",
              "immutable": true,
              "constexpr": true
            },
            "GetIntersection": {
              "doc": "Calculate the intersection of two rectangles with float precision.\n\nIf `result` is nullptr then this function will return false.\n\n@param B an FRect structure representing the second rectangle.\n@param result an FRect structure filled in with the intersection of\n              rectangles `A` and `B`.\n@returns true if there is an intersection, false otherwise.\n\n@since This function is available since SDL 3.2.0.\n\n@sa FRect.HasIntersection",
              "name": "GetIntersection",
              "kind": "function",
              "type": "FRect",
              "parameters": [
                {
                  "name": "other",
                  "type": "const FRectRaw &"
                }
              ],
              "sourceName": "SDL_GetRectIntersectionFloat",
              "immutable": true,
              "constexpr": true
            },
            "GetUnion": {
              "doc": "Calculate the union of two rectangles with float precision.\n\n@param B an FRect structure representing the second rectangle.\n@param result an FRect structure filled in with the union of rectangles\n              `A` and `B`.\n@throws Error on failure.\n\n@since This function is available since SDL 3.2.0.",
              "name": "GetUnion",
              "kind": "function",
              "type": "FRect",
              "parameters": [
                {
                  "name": "other",
                  "type": "const FRectRaw &"
                }
              ],
              "sourceName": "SDL_GetRectUnionFloat",
              "hints": {
                "mayFail": true
              },
              "immutable": true,
              "constexpr": true
            }
          },
          "hints": {
            "self": "this",
            "super": "SDL_FRect"
          },
          "type": "SDL_FRect"
        },
        "RectToFRect": {
          "doc": "Convert an Rect to FRect\n\n@param rect a pointer to an Rect.\n@param frect a pointer filled in with the floating point representation of\n             `rect`.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "RectToFRect",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "rect",
              "type": "const RectRaw &"
            },
            {
              "name": "frect",
              "type": "FRectRaw *"
            }
          ],
          "sourceName": "SDL_RectToFRect"
        },
        "PointInRect": {
          "doc": "Determine whether a point resides inside a rectangle.\n\nA point is considered part of a rectangle if both `p` and `r` are not nullptr,\nand `p`'s x and y coordinates are >= to the rectangle's top left corner,\nand < the rectangle's x+w and y+h. So a 1x1 rectangle considers point (0,0)\nas \"inside\" and (0,1) as not.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param p the point to test.\n@param r the rectangle to test.\n@returns true if `p` is contained by `r`, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "PointInRect",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "p",
              "type": "const PointRaw &"
            },
            {
              "name": "r",
              "type": "const RectRaw &"
            }
          ],
          "sourceName": "SDL_PointInRect"
        },
        "RectEmpty": {
          "doc": "Determine whether a rectangle has no area.\n\nA rectangle is considered \"empty\" for this function if `r` is nullptr, or if\n`r`'s width and/or height are <= 0.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param r the rectangle to test.\n@returns true if the rectangle is \"empty\", false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "RectEmpty",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "r",
              "type": "const RectRaw &"
            }
          ],
          "sourceName": "SDL_RectEmpty"
        },
        "RectsEqual": {
          "doc": "Determine whether two rectangles are equal.\n\nRectangles are considered equal if both are not nullptr and each of their x,\ny, width and height match.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param a the first rectangle to test.\n@param b the second rectangle to test.\n@returns true if the rectangles are equal, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "RectsEqual",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "a",
              "type": "const RectRaw &"
            },
            {
              "name": "b",
              "type": "const RectRaw &"
            }
          ],
          "sourceName": "SDL_RectsEqual"
        },
        "HasRectIntersection": {
          "doc": "Determine whether two rectangles intersect.\n\nIf either pointer is nullptr the function will return false.\n\n@param A an Rect structure representing the first rectangle.\n@param B an Rect structure representing the second rectangle.\n@returns true if there is an intersection, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Rect.GetIntersection",
          "name": "HasRectIntersection",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "A",
              "type": "const RectRaw &"
            },
            {
              "name": "B",
              "type": "const RectRaw &"
            }
          ],
          "sourceName": "SDL_HasRectIntersection"
        },
        "GetRectIntersection": {
          "doc": "Calculate the intersection of two rectangles.\n\nIf `result` is nullptr then this function will return false.\n\n@param A an Rect structure representing the first rectangle.\n@param B an Rect structure representing the second rectangle.\n@param result an Rect structure filled in with the intersection of\n              rectangles `A` and `B`.\n@returns true if there is an intersection, false otherwise.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Rect.HasIntersection",
          "name": "GetRectIntersection",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "A",
              "type": "const RectRaw &"
            },
            {
              "name": "B",
              "type": "const RectRaw &"
            },
            {
              "name": "result",
              "type": "RectRaw *"
            }
          ],
          "sourceName": "SDL_GetRectIntersection"
        },
        "GetRectUnion": {
          "doc": "Calculate the union of two rectangles.\n\n@param A an Rect structure representing the first rectangle.\n@param B an Rect structure representing the second rectangle.\n@param result an Rect structure filled in with the union of rectangles\n              `A` and `B`.\n@throws Error on failure.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetRectUnion",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "A",
              "type": "const RectRaw &"
            },
            {
              "name": "B",
              "type": "const RectRaw &"
            },
            {
              "name": "result",
              "type": "RectRaw *"
            }
          ],
          "sourceName": "SDL_GetRectUnion",
          "hints": {
            "mayFail": true
          }
        },
        "GetRectEnclosingPoints": {
          "doc": "Calculate a minimal rectangle enclosing a set of points.\n\nIf `clip` is not nullptr then only points inside of the clipping rectangle are\nconsidered.\n\n@param points an array of Point structures representing points to be\n              enclosed.\n@param count the number of structures in the `points` array.\n@param clip an Rect used for clipping or nullptr to enclose all points.\n@param result an Rect structure filled in with the minimal enclosing\n              rectangle.\n@returns true if any points were enclosed or false if all the points were\n         outside of the clipping rectangle.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetRectEnclosingPoints",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "points",
              "type": "SpanRef<const SDL_Point>"
            },
            {
              "name": "clip",
              "type": "OptionalRef<const SDL_Rect>"
            },
            {
              "name": "result",
              "type": "RectRaw *"
            }
          ],
          "sourceName": "SDL_GetRectEnclosingPoints",
          "static": true
        },
        "GetRectAndLineIntersection": {
          "doc": "Calculate the intersection of a rectangle and line segment.\n\nThis function is used to clip a line segment to a rectangle. A line segment\ncontained entirely within the rectangle or that does not intersect will\nremain unchanged. A line segment that crosses the rectangle at either or\nboth ends will be clipped to the boundary of the rectangle and the new\ncoordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.\n\n@param rect an Rect structure representing the rectangle to intersect.\n@param X1 a pointer to the starting X-coordinate of the line.\n@param Y1 a pointer to the starting Y-coordinate of the line.\n@param X2 a pointer to the ending X-coordinate of the line.\n@param Y2 a pointer to the ending Y-coordinate of the line.\n@returns true if there is an intersection, false otherwise.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetRectAndLineIntersection",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "rect",
              "type": "const RectRaw &"
            },
            {
              "name": "X1",
              "type": "int *"
            },
            {
              "name": "Y1",
              "type": "int *"
            },
            {
              "name": "X2",
              "type": "int *"
            },
            {
              "name": "Y2",
              "type": "int *"
            }
          ],
          "sourceName": "SDL_GetRectAndLineIntersection"
        },
        "PointInRectFloat": {
          "doc": "Determine whether a point resides inside a floating point rectangle.\n\nA point is considered part of a rectangle if both `p` and `r` are not nullptr,\nand `p`'s x and y coordinates are >= to the rectangle's top left corner,\nand <= the rectangle's x+w and y+h. So a 1x1 rectangle considers point\n(0,0) and (0,1) as \"inside\" and (0,2) as not.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param p the point to test.\n@param r the rectangle to test.\n@returns true if `p` is contained by `r`, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "PointInRectFloat",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "p",
              "type": "const FPointRaw &"
            },
            {
              "name": "r",
              "type": "const FRectRaw &"
            }
          ],
          "sourceName": "SDL_PointInRectFloat"
        },
        "RectEmptyFloat": {
          "doc": "Determine whether a floating point rectangle can contain any point.\n\nA rectangle is considered \"empty\" for this function if `r` is nullptr, or if\n`r`'s width and/or height are < 0.0f.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param r the rectangle to test.\n@returns true if the rectangle is \"empty\", false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "RectEmptyFloat",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "r",
              "type": "const FRectRaw &"
            }
          ],
          "sourceName": "SDL_RectEmptyFloat"
        },
        "RectsEqualEpsilon": {
          "doc": "Determine whether two floating point rectangles are equal, within some\ngiven epsilon.\n\nRectangles are considered equal if both are not nullptr and each of their x,\ny, width and height are within `epsilon` of each other. If you don't know\nwhat value to use for `epsilon`, you should call the FRect.Equal\nfunction instead.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param a the first rectangle to test.\n@param b the second rectangle to test.\n@param epsilon the epsilon value for comparison.\n@returns true if the rectangles are equal, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa FRect.Equal",
          "name": "RectsEqualEpsilon",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "a",
              "type": "const FRectRaw &"
            },
            {
              "name": "b",
              "type": "const FRectRaw &"
            },
            {
              "name": "epsilon",
              "type": "float"
            }
          ],
          "sourceName": "SDL_RectsEqualEpsilon"
        },
        "RectsEqualFloat": {
          "doc": "Determine whether two floating point rectangles are equal, within a default\nepsilon.\n\nRectangles are considered equal if both are not nullptr and each of their x,\ny, width and height are within SDL_FLT_EPSILON of each other. This is often\na reasonable way to compare two floating point rectangles and deal with the\nslight precision variations in floating point calculations that tend to pop\nup.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param a the first rectangle to test.\n@param b the second rectangle to test.\n@returns true if the rectangles are equal, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.\n\n@sa FRect.EqualEpsilon",
          "name": "RectsEqualFloat",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "a",
              "type": "const FRectRaw &"
            },
            {
              "name": "b",
              "type": "const FRectRaw &"
            }
          ],
          "sourceName": "SDL_RectsEqualFloat"
        },
        "HasRectIntersectionFloat": {
          "doc": "Determine whether two rectangles intersect with float precision.\n\nIf either pointer is nullptr the function will return false.\n\n@param A an FRect structure representing the first rectangle.\n@param B an FRect structure representing the second rectangle.\n@returns true if there is an intersection, false otherwise.\n\n@since This function is available since SDL 3.2.0.\n\n@sa Rect.GetIntersection",
          "name": "HasRectIntersectionFloat",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "A",
              "type": "const FRectRaw &"
            },
            {
              "name": "B",
              "type": "const FRectRaw &"
            }
          ],
          "sourceName": "SDL_HasRectIntersectionFloat"
        },
        "GetRectIntersectionFloat": {
          "doc": "Calculate the intersection of two rectangles with float precision.\n\nIf `result` is nullptr then this function will return false.\n\n@param A an FRect structure representing the first rectangle.\n@param B an FRect structure representing the second rectangle.\n@param result an FRect structure filled in with the intersection of\n              rectangles `A` and `B`.\n@returns true if there is an intersection, false otherwise.\n\n@since This function is available since SDL 3.2.0.\n\n@sa FRect.HasIntersection",
          "name": "GetRectIntersectionFloat",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "A",
              "type": "const FRectRaw &"
            },
            {
              "name": "B",
              "type": "const FRectRaw &"
            },
            {
              "name": "result",
              "type": "FRectRaw *"
            }
          ],
          "sourceName": "SDL_GetRectIntersectionFloat"
        },
        "GetRectUnionFloat": {
          "doc": "Calculate the union of two rectangles with float precision.\n\n@param A an FRect structure representing the first rectangle.\n@param B an FRect structure representing the second rectangle.\n@param result an FRect structure filled in with the union of rectangles\n              `A` and `B`.\n@throws Error on failure.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetRectUnionFloat",
          "kind": "function",
          "type": "void",
          "parameters": [
            {
              "name": "A",
              "type": "const FRectRaw &"
            },
            {
              "name": "B",
              "type": "const FRectRaw &"
            },
            {
              "name": "result",
              "type": "FRectRaw *"
            }
          ],
          "sourceName": "SDL_GetRectUnionFloat",
          "hints": {
            "mayFail": true
          }
        },
        "GetRectEnclosingPointsFloat": {
          "doc": "Calculate a minimal rectangle enclosing a set of points with float\nprecision.\n\nIf `clip` is not nullptr then only points inside of the clipping rectangle are\nconsidered.\n\n@param points an array of FPoint structures representing points to be\n              enclosed.\n@param count the number of structures in the `points` array.\n@param clip an FRect used for clipping or nullptr to enclose all points.\n@param result an FRect structure filled in with the minimal enclosing\n              rectangle.\n@returns true if any points were enclosed or false if all the points were\n         outside of the clipping rectangle.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetRectEnclosingPointsFloat",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "points",
              "type": "SpanRef<const SDL_FPoint>"
            },
            {
              "name": "clip",
              "type": "OptionalRef<const SDL_FRect>"
            },
            {
              "name": "result",
              "type": "FRectRaw *"
            }
          ],
          "sourceName": "SDL_GetRectEnclosingPointsFloat",
          "static": true
        },
        "GetRectAndLineIntersectionFloat": {
          "doc": "Calculate the intersection of a rectangle and line segment with float\nprecision.\n\nThis function is used to clip a line segment to a rectangle. A line segment\ncontained entirely within the rectangle or that does not intersect will\nremain unchanged. A line segment that crosses the rectangle at either or\nboth ends will be clipped to the boundary of the rectangle and the new\ncoordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.\n\n@param rect an FRect structure representing the rectangle to intersect.\n@param X1 a pointer to the starting X-coordinate of the line.\n@param Y1 a pointer to the starting Y-coordinate of the line.\n@param X2 a pointer to the ending X-coordinate of the line.\n@param Y2 a pointer to the ending Y-coordinate of the line.\n@returns true if there is an intersection, false otherwise.\n\n@since This function is available since SDL 3.2.0.",
          "name": "GetRectAndLineIntersectionFloat",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "rect",
              "type": "const FRectRaw &"
            },
            {
              "name": "X1",
              "type": "float *"
            },
            {
              "name": "Y1",
              "type": "float *"
            },
            {
              "name": "X2",
              "type": "float *"
            },
            {
              "name": "Y2",
              "type": "float *"
            }
          ],
          "sourceName": "SDL_GetRectAndLineIntersectionFloat"
        }
      },
      "includes": [
        "SDL3/SDL_rect.h"
      ],
      "localIncludes": [
        "SDL3pp_error.h",
        "SDL3pp_optionalRef.h",
        "SDL3pp_spanRef.h"
      ]
    },
    "SDL3pp_bits.h": {
      "name": "SDL3pp_bits.h",
      "doc": "@defgroup CategoryBits Category Bits\n\nFunctions for fiddling with bits and bitmasks.",
      "entries": {
        "MostSignificantBitIndex32": {
          "doc": "Get the index of the most significant (set) bit in a 32-bit number.\n\nResult is undefined when called with 0. This operation can also be stated\nas \"count leading zeroes\" and \"log base 2\".\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param x the 32-bit value to examine.\n@returns the index of the most significant bit, or -1 if the value is 0.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "MostSignificantBitIndex32",
          "kind": "function",
          "type": "int",
          "parameters": [
            {
              "name": "x",
              "type": "Uint32"
            }
          ],
          "sourceName": "SDL_MostSignificantBitIndex32"
        },
        "HasExactlyOneBitSet32": {
          "doc": "Determine if a unsigned 32-bit value has exactly one bit set.\n\nIf there are no bits set (`x` is zero), or more than one bit set, this\nreturns false. If any one bit is exclusively set, this returns true.\n\nNote that this is a forced-inline function in a header, and not a public\nAPI function available in the SDL library (which is to say, the code is\nembedded in the calling program and the linker and dynamic loader will not\nbe able to find this function inside SDL itself).\n\n@param x the 32-bit value to examine.\n@returns true if exactly one bit is set in `x`, false otherwise.\n\n@threadsafety It is safe to call this function from any thread.\n\n@since This function is available since SDL 3.2.0.",
          "name": "HasExactlyOneBitSet32",
          "kind": "function",
          "type": "bool",
          "parameters": [
            {
              "name": "x",
              "type": "Uint32"
            }
          ],
          "sourceName": "SDL_HasExactlyOneBitSet32"
        }
      },
      "includes": [
        "SDL3/SDL_bits.h"
      ]
    }
  }
}
