// Amalgamated SDL3pp
#ifndef SDL3PP_H_
#define SDL3PP_H_

#include <atomic>
#include <chrono>
#include <concepts>
#include <exception>
#include <format>
#include <functional>
#include <map>
#include <memory>
#include <optional>
#include <ranges>
#include <span>
#include <string>
#include <string_view>
#include <variant>
#include <SDL3/SDL.h>

namespace SDL {

/**
 * @defgroup CategoryBits Bit Manipulation
 *
 * Functions for fiddling with bits and bitmasks.
 *
 * @{
 */

/**
 * Get the index of the most significant (set) bit in a 32-bit number.
 *
 * Result is undefined when called with 0. This operation can also be stated
 * as "count leading zeroes" and "log base 2".
 *
 * Note that this is a forced-inline function in a header, and not a public
 * API function available in the SDL library (which is to say, the code is
 * embedded in the calling program and the linker and dynamic loader will not
 * be able to find this function inside SDL itself).
 *
 * @param x the 32-bit value to examine.
 * @returns the index of the most significant bit, or -1 if the value is 0.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
constexpr int MostSignificantBitIndex32(Uint32 x)
{
  return SDL_MostSignificantBitIndex32(x);
}

/**
 * Determine if a unsigned 32-bit value has exactly one bit set.
 *
 * If there are no bits set (`x` is zero), or more than one bit set, this
 * returns false. If any one bit is exclusively set, this returns true.
 *
 * Note that this is a forced-inline function in a header, and not a public
 * API function available in the SDL library (which is to say, the code is
 * embedded in the calling program and the linker and dynamic loader will not
 * be able to find this function inside SDL itself).
 *
 * @param x the 32-bit value to examine.
 * @returns true if exactly one bit is set in `x`, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
constexpr bool HasExactlyOneBitSet32(Uint32 x)
{
  return SDL_HasExactlyOneBitSet32(x);
}

/// @}

/**
 * @defgroup CategoryBlendmode Blend modes
 *
 * Blend modes decide how two colors will mix together. There are both
 * standard modes for basic needs and a means to create custom modes,
 * dictating what sort of math to do on what color components.
 *
 * @{
 */

/**
 * @name BlendModes
 *
 * @{
 */

/**
 * A set of blend modes used in drawing operations.
 *
 * These predefined blend modes are supported everywhere.
 *
 * Additional values may be obtained from ComposeCustomBlendMode.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa ComposeCustomBlendMode
 */
using BlendMode = Uint32;

constexpr BlendMode BLENDMODE_NONE =
  SDL_BLENDMODE_NONE; ///< no blending: dstRGBA = srcRGBA

/**
 * alpha blending: dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA)), dstA = srcA +
 * (dstA * (1-srcA))
 */
constexpr BlendMode BLENDMODE_BLEND = SDL_BLENDMODE_BLEND;

/// pre-multiplied alpha blending: dstRGBA = srcRGBA + (dstRGBA * (1-srcA))
constexpr BlendMode BLENDMODE_BLEND_PREMULTIPLIED =
  SDL_BLENDMODE_BLEND_PREMULTIPLIED;

/// additive blending: dstRGB = (srcRGB * srcA) + dstRGB, dstA = dstA
constexpr BlendMode BLENDMODE_ADD = SDL_BLENDMODE_ADD;

/// pre-multiplied additive blending: dstRGB = srcRGB + dstRGB, dstA = dstA
constexpr BlendMode BLENDMODE_ADD_PREMULTIPLIED =
  SDL_BLENDMODE_ADD_PREMULTIPLIED;

/// color modulate: dstRGB = srcRGB * dstRGB, dstA = dstA
constexpr BlendMode BLENDMODE_MOD = SDL_BLENDMODE_MOD;

/**
 * color multiply: dstRGB = (srcRGB * dstRGB) + (dstRGB * (1-srcA)), dstA = dstA
 */
constexpr BlendMode BLENDMODE_MUL = SDL_BLENDMODE_MUL;

constexpr BlendMode BLENDMODE_INVALID = SDL_BLENDMODE_INVALID; ///< INVALID

///@}

/**
 * The blend operation used when combining source and destination pixel
 * components.
 *
 * @since This enum is available since SDL 3.2.0.
 */
using BlendOperation = SDL_BlendOperation;

constexpr BlendOperation BLENDOPERATION_ADD =
  SDL_BLENDOPERATION_ADD; ///< dst + src: supported by all renderers

/// src - dst : supported by D3D, OpenGL, OpenGLES, and Vulkan
constexpr BlendOperation BLENDOPERATION_SUBTRACT = SDL_BLENDOPERATION_SUBTRACT;

/// dst - src : supported by D3D, OpenGL, OpenGLES, and Vulkan
constexpr BlendOperation BLENDOPERATION_REV_SUBTRACT =
  SDL_BLENDOPERATION_REV_SUBTRACT;

/// min(dst, src) : supported by D3D, OpenGL, OpenGLES, and Vulkan
constexpr BlendOperation BLENDOPERATION_MINIMUM = SDL_BLENDOPERATION_MINIMUM;

/// max(dst, src) : supported by D3D, OpenGL, OpenGLES, and Vulkan
constexpr BlendOperation BLENDOPERATION_MAXIMUM = SDL_BLENDOPERATION_MAXIMUM;

/**
 * The normalized factor used to multiply pixel components.
 *
 * The blend factors are multiplied with the pixels from a drawing operation
 * (src) and the pixels from the render target (dst) before the blend
 * operation. The comma-separated factors listed above are always applied in
 * the component order red, green, blue, and alpha.
 *
 * @since This enum is available since SDL 3.2.0.
 */
using BlendFactor = SDL_BlendFactor;

constexpr BlendFactor BLENDFACTOR_ZERO = SDL_BLENDFACTOR_ZERO; ///< 0, 0, 0, 0

constexpr BlendFactor BLENDFACTOR_ONE = SDL_BLENDFACTOR_ONE; ///< 1, 1, 1, 1

constexpr BlendFactor BLENDFACTOR_SRC_COLOR =
  SDL_BLENDFACTOR_SRC_COLOR; ///< srcR, srcG, srcB, srcA

constexpr BlendFactor BLENDFACTOR_ONE_MINUS_SRC_COLOR =
  SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR; ///< 1-srcR, 1-srcG, 1-srcB, 1-srcA

constexpr BlendFactor BLENDFACTOR_SRC_ALPHA =
  SDL_BLENDFACTOR_SRC_ALPHA; ///< srcA, srcA, srcA, srcA

constexpr BlendFactor BLENDFACTOR_ONE_MINUS_SRC_ALPHA =
  SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA; ///< 1-srcA, 1-srcA, 1-srcA, 1-srcA

constexpr BlendFactor BLENDFACTOR_DST_COLOR =
  SDL_BLENDFACTOR_DST_COLOR; ///< dstR, dstG, dstB, dstA

constexpr BlendFactor BLENDFACTOR_ONE_MINUS_DST_COLOR =
  SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR; ///< 1-dstR, 1-dstG, 1-dstB, 1-dstA

constexpr BlendFactor BLENDFACTOR_DST_ALPHA =
  SDL_BLENDFACTOR_DST_ALPHA; ///< dstA, dstA, dstA, dstA

constexpr BlendFactor BLENDFACTOR_ONE_MINUS_DST_ALPHA =
  SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA; ///< 1-dstA, 1-dstA, 1-dstA, 1-dstA

/**
 * Compose a custom blend mode for renderers.
 *
 * The functions Renderer.SetDrawBlendMode and Texture.SetBlendMode accept
 * the BlendMode returned by this function if the renderer supports it.
 *
 * A blend mode controls how the pixels from a drawing operation (source) get
 * combined with the pixels from the render target (destination). First, the
 * components of the source and destination pixels get multiplied with their
 * blend factors. Then, the blend operation takes the two products and
 * calculates the result that will get stored in the render target.
 *
 * Expressed in pseudocode, it would look like this:
 *
 * ```c
 * dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);
 * dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);
 * ```
 *
 * Where the functions `colorOperation(src, dst)` and `alphaOperation(src,
 * dst)` can return one of the following:
 *
 * - `src + dst`
 * - `src - dst`
 * - `dst - src`
 * - `min(src, dst)`
 * - `max(src, dst)`
 *
 * The red, green, and blue components are always multiplied with the first,
 * second, and third components of the BlendFactor, respectively. The
 * fourth component is not used.
 *
 * The alpha component is always multiplied with the fourth component of the
 * BlendFactor. The other components are not used in the alpha
 * calculation.
 *
 * Support for these blend modes varies for each renderer. To check if a
 * specific BlendMode is supported, create a renderer and pass it to
 * either Renderer.SetDrawBlendMode or Texture.SetBlendMode. They will
 * return with an error if the blend mode is not supported.
 *
 * This list describes the support of custom blend modes for each renderer.
 * All renderers support the four blend modes listed in the BlendMode
 * enumeration.
 *
 * - **direct3d**: Supports all operations with all factors. However, some
 *   factors produce unexpected results with `BLENDOPERATION_MINIMUM` and
 *   `BLENDOPERATION_MAXIMUM`.
 * - **direct3d11**: Same as Direct3D 9.
 * - **opengl**: Supports the `BLENDOPERATION_ADD` operation with all
 *   factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly here.
 * - **opengles2**: Supports the `BLENDOPERATION_ADD`,
 *   `BLENDOPERATION_SUBTRACT`, `BLENDOPERATION_REV_SUBTRACT`
 *   operations with all factors.
 * - **psp**: No custom blend mode support.
 * - **software**: No custom blend mode support.
 *
 * Some renderers do not provide an alpha component for the default render
 * target. The `BLENDFACTOR_DST_ALPHA` and
 * `BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this
 * case.
 *
 * @param srcColorFactor the BlendFactor applied to the red, green, and
 *                       blue components of the source pixels.
 * @param dstColorFactor the BlendFactor applied to the red, green, and
 *                       blue components of the destination pixels.
 * @param colorOperation the BlendOperation used to combine the red,
 *                       green, and blue components of the source and
 *                       destination pixels.
 * @param srcAlphaFactor the BlendFactor applied to the alpha component of
 *                       the source pixels.
 * @param dstAlphaFactor the BlendFactor applied to the alpha component of
 *                       the destination pixels.
 * @param alphaOperation the BlendOperation used to combine the alpha
 *                       component of the source and destination pixels.
 * @returns an BlendMode that represents the chosen factors and
 *          operations.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.SetDrawBlendMode
 * @sa Renderer.GetDrawBlendMode
 * @sa Texture.SetBlendMode
 * @sa Texture.GetBlendMode
 */
inline BlendMode ComposeCustomBlendMode(BlendFactor srcColorFactor,
                                        BlendFactor dstColorFactor,
                                        BlendOperation colorOperation,
                                        BlendFactor srcAlphaFactor,
                                        BlendFactor dstAlphaFactor,
                                        BlendOperation alphaOperation)
{
  return SDL_ComposeCustomBlendMode(srcColorFactor,
                                    dstColorFactor,
                                    colorOperation,
                                    srcAlphaFactor,
                                    dstAlphaFactor,
                                    alphaOperation);
}

/// @}

/**
 * @defgroup CategoryCallbackWrapper Async callback helpers
 *
 * Async callback wrapper helper functions and types.
 *
 * @{
 */

/** A typesafe handle for callback */
class CallbackHandle
{
  void* id;

public:
  /// @private
  constexpr explicit CallbackHandle(void* id = nullptr)
    : id(id)
  {
  }
  /// Get Internal id
  constexpr void* get() const { return id; }

  /// True if has a valid id
  constexpr operator bool() const { return id != 0; }
};

/// Base class for callback wrappers
template<class Result, class... Args>
struct CallbackWrapperBase
{
  /// The wrapped std::function type
  using ValueType = std::function<Result(Args...)>;

  /// Return unwrapped value of handle.
  static const ValueType& Unwrap(void* handle)
  {
    return *static_cast<ValueType*>(handle);
  }

  /// Call
  static Result Call(void* handle, Args... args)
  {
    auto& f = Unwrap(handle);
    return f(args...);
  }

  /// Call with suffix handle.
  static Result CallSuffixed(Args... args, void* handle)
  {
    auto& f = Unwrap(handle);
    return f(args...);
  }
};

template<class F>
struct CallbackWrapper;

/**
 * @brief Wrapper [result callbacks](#result-callback).
 *
 * @tparam F the function type.
 *
 * For the simpler case, where no transformation is done on the parameters, you
 * can just pass CallOnce() or CallOnceSuffixed(). Otherwise use release().
 *
 * In all cases, use Wrap to change the callback into a void* pointer.
 */
template<class Result, class... Args>
struct CallbackWrapper<std::function<Result(Args...)>>
  : CallbackWrapperBase<Result, Args...>
{
  CallbackWrapper() = delete;

  /// The wrapped std::function type
  using ValueType = std::function<Result(Args...)>;

  /**
   * @brief Change the callback into a void* pointer.
   *
   * @param cb
   * @return void*
   */
  static ValueType* Wrap(ValueType&& cb)
  {
    return new ValueType(std::move(cb));
  }

  /// Call once and release.
  static Result CallOnce(void* handle, Args... args)
  {
    auto f = release(handle);
    return f(args...);
  }

  /// Call once and release with suffix handle.
  static Result CallOnceSuffixed(Args... args, void* handle)
  {
    auto f = release(handle);
    return f(args...);
  }

  /**
   * @brief Transfer ownership from the function and delete handle.
   *
   * @param handle the handle to be released.
   *
   * @return the callback ready to be invoked.
   */
  static ValueType release(void* handle)
  {
    if (handle == nullptr) return {};
    auto ptr = static_cast<ValueType*>(handle);
    ValueType value{std::move(*ptr)};
    delete ptr;
    return value;
  }

  /// Return unwrapped value of handle.
  static const ValueType release(CallbackHandle handle)
  {
    return release(handle.get());
  }
};

/**
 * @brief Wrapper key to value [result callbacks](#result-callback).
 *
 * @tparam KEY the key type.
 * @tparam VALUE the value type.
 * @tparam VARIANT the variant, if more than one listener type is associated.
 *
 */
template<class KEY, class VALUE, size_t VARIANT = 0>
struct KeyValueWrapper
{
  static_assert(sizeof(KEY) <= sizeof(void*));
  KeyValueWrapper() = delete;

  /// Key type
  using KeyType = KEY;

  /// Value type.
  using ValueType = VALUE;

  /**
   * @brief Change the value into a void* pointer held by key.
   *
   * @param key
   * @param value
   * @return void*
   */
  static ValueType* Wrap(KeyType key, ValueType&& value)
  {
    auto lockGuard = lock();
    return &Values().insert_or_assign(key, std::move(value)).first->second;
  }

  /// True if handle is stored.
  static bool contains(KeyType handle)
  {
    auto lockGuard = lock();
    return Values().contains(handle);
  }

  /// Return unwrapped value of handle.
  static const ValueType& at(KeyType handle)
  {
    auto lockGuard = lock();
    return Values().at(handle);
  }

  /// Return unwrapped value associated by key and remove association.
  static ValueType release(KeyType key)
  {
    auto lockGuard = lock();
    auto& values = Values();
    auto it = values.find(key);
    if (it == values.end()) return {};
    ValueType value{std::move(it->second)};
    values.erase(it);
    return value;
  }

  /**
   * Remove association.
   *
   * @param key the key associated.
   * @return true if the key was associated and was erased, false otherwise.
   */
  static bool erase(KeyType key)
  {
    auto lockGuard = lock();
    return Values().erase(key);
  }

private:
  static std::map<KeyType, ValueType>& Values()
  {
    static std::map<KeyType, ValueType> values;
    return values;
  }

  static std::lock_guard<std::mutex> lock()
  {
    static std::mutex uniqueMutex;
    return std::lock_guard{uniqueMutex};
  }
};

/// Store callbacks by key
template<class KEY, class VALUE, size_t VARIANT = 0>
struct KeyValueCallbackWrapper;

/// Store callbacks by key
template<class KEY, class Result, class... Args, size_t VARIANT>
struct KeyValueCallbackWrapper<KEY, std::function<Result(Args...)>, VARIANT>
  : CallbackWrapperBase<Result, Args...>
  , KeyValueWrapper<KEY, std::function<Result(Args...)>, VARIANT>
{
  KeyValueCallbackWrapper() = delete;

  /// Wrapped type.
  using ValueType = std::function<Result(Args...)>;
};

/**
 * @brief Stored Wrapper unique by type [result callbacks](#result-callback).
 *
 * @tparam VALUE the function type.
 */
template<class VALUE>
struct UniqueCallbackWrapper;

/**
 * @brief Stored Wrapper unique by type [result callbacks](#result-callback).
 */
template<class Result, class... Args>
struct UniqueCallbackWrapper<std::function<Result(Args...)>>
  : CallbackWrapperBase<Result, Args...>
{
  UniqueCallbackWrapper() = delete;

  /// Wrapped type.
  using ValueType = std::function<Result(Args...)>;

  /**
   * @brief Change the value into a void* pointer held uniquely by this type.
   *
   * @param value
   * @return void*
   */
  static ValueType* Wrap(ValueType&& value)
  {
    auto lockGuard = lock();
    auto& v = Value();
    v = std::move(value);
    return &v;
  }

  /// True if handle equals to wrapped value.
  static bool contains(void* handle)
  {
    auto lockGuard = lock();
    auto& v = Value();
    return bool(v) && &v == handle;
  }

  /// Return wrapped type, if handle is contained.
  static ValueType at(void* handle)
  {
    if (&get() == handle) {
      return CallbackWrapperBase<Result, Args...>::Unwrap(handle);
    }
    return {};
  }

  /// Return wrapped type, if handle is contained.
  static const ValueType& get()
  {
    auto lockGuard = lock();
    return Value();
  }

  /// Return wrapped type and erase it from store.
  static ValueType release()
  {
    auto lockGuard = lock();
    ValueType value{std::move(Value())};
    return value;
  }

  /// Return wrapped type and erase it from store.
  static ValueType release(void* handle)
  {
    SDL_assert_paranoid(&get() == handle);
    return release();
  }

  /// Erase value from store.
  static void erase()
  {
    auto lockGuard = lock();
    Value() = {};
  }

private:
  static ValueType& Value()
  {
    static ValueType value;
    return value;
  }

  static std::lock_guard<std::mutex> lock()
  {
    static std::mutex uniqueMutex;
    return std::lock_guard{uniqueMutex};
  }
};

/// @}

/**
 * @brief Optional-like shim for references
 *
 * This allows us explicitly annotate optional parameters that would otherwise
 * be references.
 *
 * @tparam T the underlying type
 *
 * @ingroup CategoriesCppSupport
 */
template<class T>
class OptionalRef
{
  T* ptr;

public:
  constexpr OptionalRef(std::nullopt_t = std::nullopt)
    : ptr(nullptr)
  {
  }

  constexpr OptionalRef(T& value)
    : ptr(&value)
  {
  }

  constexpr auto operator<=>(const OptionalRef&) const = default;

  constexpr bool has_value() const { return ptr != nullptr; }

  constexpr const T& value() const { return *ptr; }
  constexpr T& value() { return *ptr; }

  constexpr operator T*() const { return ptr; }

  constexpr bool operator==(std::nullopt_t) const { return ptr == nullptr; }

  constexpr T& operator*() { return *ptr; }
  constexpr const T& operator*() const { return *ptr; }
  constexpr T* operator->() { return ptr; }
  constexpr const T* operator->() const { return ptr; }
};

template<class T>
constexpr OptionalRef<T> fromNullable(T* ptr)
{
  if (ptr) return {*ptr};
  return std::nullopt;
}

/**
 * @defgroup CategoryOwnPtr Pointer wrapper to SDL::free()
 *
 * Wraps SDL generated pointers to automatically freeing them.
 * @{
 */

/// Calls SDL_free()
struct PtrDeleter
{
  void operator()(void* ptr) const;
};

/**
 * Handle to an owned SDL memory allocated pointer
 *
 * @cat resource
 *
 * @sa resource
 * @sa PtrBase
 * @sa RefPtr
 */
template<class T>
using OwnPtr = std::unique_ptr<T, PtrDeleter>;

/**
 * Base class for SDL memory allocated array wrap
 *
 * @tparam T the wrapped array type, without the []
 *
 * @cat resource
 */
template<class T>
class OwnArray
{
  OwnPtr<T> m_ptr;
  size_t m_size = 0;

public:
  constexpr OwnArray(std::nullptr_t = nullptr) {}

  constexpr explicit OwnArray(T* ptr, size_t size)
    : m_ptr(ptr)
    , m_size(size)
  {
  }

  constexpr explicit OwnArray(T* ptr)
    : m_ptr(ptr)
  {
    if (ptr) {
      auto endPtr = ptr;
      while (*endPtr) ++endPtr;
      m_size = endPtr - ptr;
    }
  }

  /// True if not empty
  constexpr explicit operator bool() const { return bool(m_ptr); }

  /// True if size() == 0
  constexpr bool empty() const { return !m_ptr; }

  /// Data
  constexpr T* data() { return m_ptr.get(); }

  /// Data
  constexpr const T* data() const { return m_ptr.get(); }

  /// Size
  constexpr size_t size() const { return m_size; }

  /**
   * Release control on object.
   *
   * You are responsible to call free() on the returned value, if its different
   * than nullptr.
   */
  T* release() { return m_ptr.release(); }

  /**
   * Reset object.
   *
   * You are responsible to call free() on the returned value, if its different
   * than nullptr.
   */
  void reset(T* newValue = nullptr)
  {
    m_ptr.reset(newValue);
    if (newValue) {
      auto endPtr = newValue;
      while (*endPtr) ++endPtr;
      m_size = endPtr - newValue;
    }
  }

  /**
   * Reset object.
   *
   * You are responsible to call free() on the returned value, if its different
   * than nullptr.
   */
  void reset(T* newValue, size_t size)
  {
    m_ptr.reset(newValue);
    m_size = size;
  }

  /// Access index
  constexpr T& operator[](size_t i) { return m_ptr.get()[i]; }

  /// Access index
  constexpr const T& operator[](size_t i) const { return m_ptr.get()[i]; }

  /**
   * @{
   *
   * Get iterator to first element
   */
  T* begin() { return data(); }
  const T* begin() const { return data(); }
  const T* cbegin() const { return begin(); }
  /// @}

  /**
   * @{
   *
   * Get iterator to one past end element
   */
  T* end() { return begin() + size(); }
  const T* end() const { return begin() + size(); }
  const T* cend() const { return begin() + size(); }
  /// @}

  /// Return first element.
  T& front() { return *data(); }

  /// Return last element
  T& back() { return begin()[size()]; }
};

/**
 * Handle to an owned SDL memory allocated array
 *
 * @tparam T the wrapped array type, without the []
 *
 * @cat resource
 *
 * @sa resource
 * @sa ArrayBase
 * @sa OwnArray
 * @sa RefPtr
 */
template<class T>
using RefArray = std::span<T>;

/// @}

template<class T, class BASE>
concept DerivedWrapper =
  std::derived_from<T, BASE> && sizeof(T) == sizeof(BASE);

/**
 * span-like for empty-derived structs
 *
 * This wraps around std::span that works for out derived-wrapper pattern
 * (eg, Rect, Color)
 *
 * @ingroup CategoriesCppSupport
 */
template<class T>
class SpanRef
{
  std::span<T> value;

public:
  constexpr SpanRef() = default;

  template<DerivedWrapper<T> U, size_t N>
  constexpr SpanRef(U (&other)[N])
    : value(static_cast<T*>(other), N)
  {
  }

  template<DerivedWrapper<T> U>
  constexpr SpanRef(const std::span<U>& other)
    : value(other.data(), other.size())
  {
  }

  template<std::contiguous_iterator It>
    requires DerivedWrapper<std::iter_value_t<It>, T>
  constexpr SpanRef(It first, size_t count)
    : value((T*)(&*first), count)
  {
  }

  template<std::contiguous_iterator It, std::sized_sentinel_for<It> End>
    requires DerivedWrapper<std::iter_value_t<It>, T>
  constexpr SpanRef(It first, End last)
    : value((T*)(&*first), size_t(last - first))
  {
  }
  template<std::ranges::contiguous_range R>
    requires DerivedWrapper<std::iter_value_t<std::ranges::iterator_t<R>>, T>
  constexpr SpanRef(R&& range)
    : SpanRef(std::begin(range), std::end(range))
  {
  }

  constexpr size_t size() const { return value.size(); }

  constexpr T* data() const { return value.data(); }
};

/**
 * @defgroup CategoryVersion Querying SDL Version
 *
 * Functionality to query the current SDL version, both as headers the app was
 * compiled against, and a library the app is linked to.
 *
 * @{
 */

#ifdef SDL3PP_DOC

/**
 * The current major version of SDL headers.
 *
 * If this were SDL version 3.2.1, this value would be 3.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_MAJOR_VERSION 3

/**
 * The current minor version of the SDL headers.
 *
 * If this were SDL version 3.2.1, this value would be 2.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_MINOR_VERSION 2

/**
 * The current micro (or patchlevel) version of the SDL headers.
 *
 * If this were SDL version 3.2.1, this value would be 1.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_MICRO_VERSION 23

/**
 * This macro turns the version numbers into a numeric value.
 *
 * (1,2,3) becomes 1002003.
 *
 * @param major the major version number.
 * @param minor the minorversion number.
 * @param patch the patch version number.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_VERSIONNUM(major, minor, patch)                                    \
  ((major) * 1000000 + (minor) * 1000 + (patch))

/**
 * This macro extracts the major version from a version number
 *
 * 1002003 becomes 1.
 *
 * @param version the version number.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_VERSIONNUM_MAJOR(version) ((version) / 1000000)

/**
 * This macro extracts the minor version from a version number
 *
 * 1002003 becomes 2.
 *
 * @param version the version number.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_VERSIONNUM_MINOR(version) (((version) / 1000) % 1000)

/**
 * This macro extracts the micro version from a version number
 *
 * 1002003 becomes 3.
 *
 * @param version the version number.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_VERSIONNUM_MICRO(version) ((version) % 1000)

/**
 * This is the version number macro for the current SDL version.
 *
 * @since This macro is available since SDL 3.2.0.
 *
 * @sa GetVersion
 */
#define SDL_VERSION                                                            \
  SDL_VERSIONNUM(SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_MICRO_VERSION)

/**
 * This macro will evaluate to true if compiled with SDL at least X.Y.Z.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_VERSION_ATLEAST(X, Y, Z) (SDL_VERSION >= SDL_VERSIONNUM(X, Y, Z))

#endif // SDL3PP_DOC

/**
 * Get the version of SDL that is linked against your program.
 *
 * If you are linking to SDL dynamically, then it is possible that the current
 * version will be different than the version you compiled against. This
 * function returns the current version, while SDL_VERSION is the version you
 * compiled with.
 *
 * This function may be called safely at any time, even before Init().
 *
 * @returns the version of the linked library.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetRevision
 */
inline int GetVersion() { return SDL_GetVersion(); }

/**
 * Get the code revision of SDL that is linked against your program.
 *
 * This value is the revision of the code you are linked with and may be
 * different from the code you are compiling with, which is found in the
 * constant SDL_REVISION.
 *
 * The revision is arbitrary string (a hash value) uniquely identifying the
 * exact revision of the SDL library in use, and is only useful in comparing
 * against other revisions. It is NOT an incrementing number.
 *
 * If SDL wasn't built from a git repository with the appropriate tools, this
 * will return an empty string.
 *
 * You shouldn't use this function for anything but logging it for debugging
 * purposes. The string is not intended to be reliable in any way.
 *
 * @returns an arbitrary string, uniquely identifying the exact revision of
 *          the SDL library in use.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetVersion
 */
inline const char* GetRevision() { return SDL_GetRevision(); }

/// @}

/**
 * @defgroup CategoryStrings Helpers to use C++ strings and byte arrays.
 *
 * It has StringParam to use on parameters and StringResult to have
 * a simple std::string-like interface for SDL allocated strings.
 * @{
 */

#ifndef SDL3PP_ENABLE_STRING_PARAM

#ifndef SDL3PP_DISABLE_STRING_PARAM
#define SDL3PP_ENABLE_STRING_PARAM
#endif // SDL3PP_DISABLE_STRING_PARAM

#endif // SDL3PP_ENABLE_STRING_PARAM

#ifdef SDL3PP_ENABLE_STRING_PARAM

/**
 * @brief Helpers to use C++ strings parameters
 *
 * This wraps std::string and std::string_view to the SDL's C interfaces.
 *
 * This should only be declared in [function
 * parameters](https://en.cppreference.com/w/cpp/language/expressions#Full-expressions),
 * using it otherwise is to ask for undefined behavior
 *
 * @ingroup CategoriesCppSupport
 */
class StringParam
{
  std::variant<const char*, std::string> data;

public:
  /// Default ctor
  constexpr StringParam(std::nullptr_t = nullptr)
    : data("")
  {
  }

  /**
   * Constructs from a C string.
   *
   * This assumes the parameter object lifetime is larger than this object,
   * which is always true on parameters, so it just stores the pointer, no copy
   * is done.
   *
   * @param str the string to store. This parameter must outlive this object.
   */
  constexpr StringParam(const char* str)
    : data(str ?: "")
  {
  }

  /**
   * Constructs from std::string reference.
   *
   * This assumes the parameter object lifetime is larger than this object,
   * which is always true on parameters, so it just stores the pointer to
   * internal string data, no copy is done.
   *
   * @param str the reference to a string. This parameter must outlive this
   *            object.
   */
  constexpr StringParam(const std::string& str)
    : StringParam(str.c_str())
  {
  }

  /**
   * Constructs from std::string object.
   *
   * This case we assume the ownership for the string and will properly call
   * destructor automatically.
   *
   * @param str the string to store
   */
  constexpr StringParam(std::string&& str)
    : data(std::move(str))
  {
  }

  /**
   * Constructs from std::string_view object
   *
   * String view are very usefull on C++, but they don't have the null
   * terminator expected by most string SDL APIs, so we always copy its content
   * to a stored std::string.
   *
   * @param str the string_view to store
   */
  StringParam(std::string_view str)
    : StringParam(std::string{str})
  {
  }

  StringParam(const StringParam&) = delete;
  StringParam& operator=(const StringParam&) = delete;

  /// Move ctor
  StringParam(StringParam&&) = default;

  /// Move assignment
  StringParam& operator=(StringParam&&) = default;

  /**
   * Converts to a null terminated C string.
   *
   * @return the C string representation. We guarantee it to be null terminated
   * unless the objects it was constructed from are corrupted.
   */
  constexpr const char* c_str() const
  {
    struct Visitor
    {
      const char* operator()(const char* a) const { return a; }
      const char* operator()(const std::string& s) const { return s.c_str(); }
    };
    return std::visit(Visitor{}, data);
  }

  /**
   * Converts to a null terminated C string.
   *
   * @return the C string representation. We guarantee it to be null terminated
   * unless the objects it was constructed from are corrupted.
   */
  constexpr operator const char*() const { return c_str(); }
};

#else // SDL3PP_ENABLE_STRING_PARAM

using StringParam = const char*;

#endif // SDL3PP_ENABLE_STRING_PARAM

/**
 * A simple std::string-like interface for SDL allocated strings.
 */
struct StringResult : OwnArray<char>
{

  /// Use parent ctors
  using OwnArray::OwnArray;

  /// Copy ctor
  StringResult(const StringResult& other)
    : StringResult(std::string_view(other))
  {
  }

  /// Move ctor
  constexpr StringResult(StringResult&& other)
    : OwnArray(other.release(), other.size())
  {
  }

  /// Constructs from string view
  StringResult(std::string_view other)
    : OwnArray(other.empty() ? nullptr
                             : SDL_strndup(other.data(), other.size()))
  {
  }

  /// Convert to StringParam
  constexpr operator StringParam() const { return std::string_view{*this}; }

  /// Convert to std::string_view
  constexpr operator std::string_view() const
  {
    return std::string_view{data(), size()};
  }

  /// Append string.
  StringResult& operator+=(std::string_view other)
  {
    if (empty()) {
      reset(StringResult(other).release());
    } else if (!other.empty()) {
      size_t lhsSz = size();
      size_t rhsSz = other.size();
      size_t finalSize = lhsSz + lhsSz + 1;
      auto newBuf = static_cast<char*>(SDL_realloc(data(), finalSize));
      newBuf += lhsSz;
      SDL_memcpy(newBuf, other.data(), rhsSz);
      newBuf += rhsSz;
      *newBuf = 0;
      reset(newBuf, finalSize - 1);
    }
    return *this;
  }

  /// Append char.
  StringResult& operator+=(char ch)
  {
    return (*this) += std::string_view{&ch, 1};
  }

  /// Append string.
  StringResult operator+(std::string_view other) const
  {
    StringResult t{*this};
    t += other;
    return t;
  }

  /// Append char.
  StringResult operator+(char ch) { return (*this) + std::string_view{&ch, 1}; }

  /// Convert to string.
  std::string str() const { return std::string{data(), size()}; }

  /// Convert to c-string.
  const char* c_str() const
  {
    if (empty()) return "";
    return data();
  }
};

/**
 * Source byte stream.
 *
 * Source byte stream, tipically used as source where bytes are copied from.
 */
struct SourceBytes
{
  const void* data;  ///< The data copied from
  size_t size_bytes; ///< The size in bytes

  /// Default ctor
  constexpr SourceBytes() = default;

  /// Disambiguate between multiple pointer types.
  constexpr SourceBytes(std::nullptr_t)
    : SourceBytes()
  {
  }

  /**
   * From span
   *
   * @param span the data.
   *
   */
  template<class T, size_t N>
  constexpr SourceBytes(std::span<T, N> span)
    : SourceBytes(span.data(), span.size_bytes())
  {
  }

  /**
   * From container-like
   *
   * @param data the data.
   */
  template<class T>
  constexpr SourceBytes(const T& data)
    : SourceBytes(std::span{data.data(), data.size()})
  {
  }
  /**
   * From array
   *
   * @param data the data.
   */
  template<class T, size_t N>
  constexpr SourceBytes(T (&data)[N])
    : SourceBytes(std::span<T, N>{static_cast<T*>(data), N})
  {
  }

  /**
   * From data + size in bytes.
   *
   * @param data the data.
   * @param size_bytes size in @b bytes!
   *
   */
  constexpr SourceBytes(const void* data, size_t size_bytes)
    : data(size_bytes > 0 ? data : nullptr)
    , size_bytes(data != nullptr ? size_bytes : 0)
  {
  }
};

/**
 * Target byte stream.
 *
 * Target byte stream, tipically used as target where bytes are copied to.
 */
struct TargetBytes
{
  void* data = nullptr;  ///< The address to have data copied to it
  size_t size_bytes = 0; ///< The size in bytes

  /// Default ctor
  constexpr TargetBytes() = default;

  /// Disambiguate between multiple pointer types.
  constexpr TargetBytes(std::nullptr_t)
    : TargetBytes()
  {
  }

  constexpr TargetBytes(const TargetBytes& other) = default;

  constexpr TargetBytes(TargetBytes&& other) = default;

  constexpr TargetBytes& operator=(const TargetBytes& other) = default;

  constexpr TargetBytes& operator=(TargetBytes&& other) = default;

  /// Just to have better error message
  template<class T, size_t N>
  constexpr TargetBytes(std::span<const T, N> span)
  {
    static_assert(false, "Non-const type is required");
  }

  /**
   * From span
   *
   * @param span the data.
   *
   */
  template<class T, size_t N>
  constexpr TargetBytes(std::span<T, N> span)
    : TargetBytes(span.data(), span.size_bytes())
  {
  }

  /**
   * From container-like
   *
   * @param data the data.
   */
  template<class T>
  constexpr TargetBytes(T& data)
    : TargetBytes(std::span{data.data(), data.size()})
  {
  }
  /**
   * From array
   *
   * @param data the data.
   */
  template<class T, size_t N>
  constexpr TargetBytes(T (&data)[N])
    : TargetBytes(std::span<T, N>{static_cast<T*>(data), N})
  {
  }

  /**
   * From data + size in bytes.
   *
   * @param data the data.
   * @param size_bytes size in @b bytes!
   *
   */
  constexpr TargetBytes(void* data, size_t size_bytes)
    : data(size_bytes > 0 ? data : nullptr)
    , size_bytes(data != nullptr ? size_bytes : 0)
  {
  }
};

/// @}

/**
 * @defgroup CategoryAssert Assertions
 *
 * A helpful assertion macro!
 *
 * SDL assertions operate like your usual `assert` macro, but with some added
 * features:
 *
 * - It uses a trick with the `sizeof` operator, so disabled assertions
 *   vaporize out of the compiled code, but variables only referenced in the
 *   assertion won't trigger compiler warnings about being unused.
 * - It is safe to use with a dangling-else: `if (x) SDL_assert(y); else
 *   do_something();`
 * - It works the same everywhere, instead of counting on various platforms'
 *   compiler and C runtime to behave.
 * - It provides multiple levels of assertion (SDL_assert, SDL_assert_release,
 *   SDL_assert_paranoid) instead of a single all-or-nothing option.
 * - It offers a variety of responses when an assertion fails (retry, trigger
 *   the debugger, abort the program, ignore the failure once, ignore it for
 *   the rest of the program's run).
 * - It tries to show the user a dialog by default, if possible, but the app
 *   can provide a callback to handle assertion failures however they like.
 * - It lets failed assertions be retried. Perhaps you had a network failure
 *   and just want to retry the test after plugging your network cable back
 *   in? You can.
 * - It lets the user ignore an assertion failure, if there's a harmless
 *   problem that one can continue past.
 * - It lets the user mark an assertion as ignored for the rest of the
 *   program's run; if there's a harmless problem that keeps popping up.
 * - It provides statistics and data on all failed assertions to the app.
 * - It allows the default assertion handler to be controlled with environment
 *   variables, in case an automated script needs to control it.
 * - It can be used as an aid to Clang's static analysis; it will treat SDL
 *   assertions as universally true (under the assumption that you are serious
 *   about the asserted claims and that your debug builds will detect when
 *   these claims were wrong). This can help the analyzer avoid false
 *   positives.
 *
 * To use it: compile a debug build and just sprinkle around tests to check
 * your code!
 *
 * @{
 */

#ifdef SDL3PP_DOC

/**
 * The level of assertion aggressiveness.
 *
 * This value changes depending on compiler options and other preprocessor
 * defines.
 *
 * It is currently one of the following values, but future SDL releases might
 * add more:
 *
 * - 0: All SDL assertion macros are disabled.
 * - 1: Release settings: SDL_assert disabled, SDL_assert_release enabled.
 * - 2: Debug settings: SDL_assert and SDL_assert_release enabled.
 * - 3: Paranoid settings: All SDL assertion macros enabled, including
 *   SDL_assert_paranoid.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_ASSERT_LEVEL SomeNumberBasedOnVariousFactors

/**
 * Attempt to tell an attached debugger to pause.
 *
 * This allows an app to programmatically halt ("break") the debugger as if it
 * had hit a breakpoint, allowing the developer to examine program state, etc.
 *
 * This is a macro--not a function--so that the debugger breaks on the source
 * code line that used SDL_TriggerBreakpoint and not in some random guts of
 * SDL. SDL_assert uses this macro for the same reason.
 *
 * If the program is not running under a debugger, SDL_TriggerBreakpoint will
 * likely terminate the app, possibly without warning. If the current platform
 * isn't supported, this macro is left undefined.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_TriggerBreakpoint() TriggerABreakpointInAPlatformSpecificManner

/**
 * A macro that reports the current function being compiled.
 *
 * If SDL can't figure how the compiler reports this, it will use "???".
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_FUNCTION __FUNCTION__

/**
 * A macro that reports the current file being compiled.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_FILE __FILE__

/**
 * A macro that reports the current line number of the file being compiled.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_LINE __LINE__

/**
 * A macro for wrapping code in `do {} while (0);` without compiler warnings.
 *
 * Visual Studio with really aggressive warnings enabled needs this to avoid
 * compiler complaints.
 *
 * the `do {} while (0);` trick is useful for wrapping code in a macro that
 * may or may not be a single statement, to avoid various C language
 * accidents.
 *
 * To use:
 *
 * ```c
 * do { SomethingOnce(); } while (SDL_NULL_WHILE_LOOP_CONDITION (0));
 * ```
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_NULL_WHILE_LOOP_CONDITION (0)

/**
 * The macro used when an assertion is disabled.
 *
 * This isn't for direct use by apps, but this is the code that is inserted
 * when an SDL_assert is disabled (perhaps in a release build).
 *
 * The code does nothing, but wraps `condition` in a sizeof operator, which
 * generates no code and has no side effects, but avoid compiler warnings
 * about unused variables.
 *
 * @param condition the condition to assert (but not actually run here).
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_disabled_assert(condition)                                         \
  do {                                                                         \
    (void)sizeof((condition));                                                 \
  } while (SDL_NULL_WHILE_LOOP_CONDITION)

#endif // SDL3PP_DOC

/**
 * Possible outcomes from a triggered assertion.
 *
 * When an enabled assertion triggers, it may call the assertion handler
 * (possibly one provided by the app via SetAssertionHandler), which will
 * return one of these values, possibly after asking the user.
 *
 * Then SDL will respond based on this outcome (loop around to retry the
 * condition, try to break in a debugger, kill the program, or ignore the
 * problem).
 *
 * @since This enum is available since SDL 3.2.0.
 */
using AssertState = SDL_AssertState;

constexpr AssertState ASSERTION_RETRY =
  SDL_ASSERTION_RETRY; ///< Retry the assert immediately.

constexpr AssertState ASSERTION_BREAK =
  SDL_ASSERTION_BREAK; ///< Make the debugger trigger a breakpoint.

constexpr AssertState ASSERTION_ABORT =
  SDL_ASSERTION_ABORT; ///< Terminate the program.

constexpr AssertState ASSERTION_IGNORE =
  SDL_ASSERTION_IGNORE; ///< Ignore the assert.

constexpr AssertState ASSERTION_ALWAYS_IGNORE =
  SDL_ASSERTION_ALWAYS_IGNORE; ///< Ignore the assert from now on.

/**
 * Information about an assertion failure.
 *
 * This structure is filled in with information about a triggered assertion,
 * used by the assertion handler, then added to the assertion report. This is
 * returned as a linked list from GetAssertionReport().
 *
 * @since This struct is available since SDL 3.2.0.
 */
using AssertData = SDL_AssertData;

/**
 * Never call this directly.
 *
 * Use the SDL_assert macros instead.
 *
 * @param data assert data structure.
 * @param func function name.
 * @param file file name.
 * @param line line number.
 * @returns assert state.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline AssertState ReportAssertion(AssertData* data,
                                   StringParam func,
                                   StringParam file,
                                   int line)
{
  return SDL_ReportAssertion(data, func, file, line);
}

#ifdef SDL3PP_DOC

/**
 * The macro used when an assertion triggers a breakpoint.
 *
 * This isn't for direct use by apps; use SDL_assert or SDL_TriggerBreakpoint
 * instead.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_AssertBreakpoint() SDL_TriggerBreakpoint()

/**
 * The macro used when an assertion is enabled.
 *
 * This isn't for direct use by apps, but this is the code that is inserted
 * when an SDL_assert is enabled.
 *
 * The `do {} while(0)` avoids dangling else problems:
 *
 * ```c
 * if (x) SDL_assert(y); else blah();
 * ```
 *
 * ... without the do/while, the "else" could attach to this macro's "if". We
 * try to handle just the minimum we need here in a macro...the loop, the
 * static vars, and break points. The heavy lifting is handled in
 * ReportAssertion().
 *
 * @param condition the condition to assert.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_enabled_assert(condition)                                          \
  do {                                                                         \
    while (!(condition)) {                                                     \
      static struct SDL_AssertData sdl_assert_data = {                         \
        0, 0, #condition, 0, 0, 0, 0};                                         \
      const SDL_AssertState sdl_assert_state = SDL_ReportAssertion(            \
        &sdl_assert_data, SDL_FUNCTION, SDL_FILE, SDL_LINE);                   \
      if (sdl_assert_state == SDL_ASSERTION_RETRY) {                           \
        continue; /* go again. */                                              \
      } else if (sdl_assert_state == SDL_ASSERTION_BREAK) {                    \
        SDL_AssertBreakpoint();                                                \
      }                                                                        \
      break; /* not retrying. */                                               \
    }                                                                          \
  } while (SDL_NULL_WHILE_LOOP_CONDITION)

/**
 * An assertion test that is normally performed only in debug builds.
 *
 * This macro is enabled when the SDL_ASSERT_LEVEL is >= 2, otherwise it is
 * disabled. This is meant to only do these tests in debug builds, so they can
 * tend to be more expensive, and they are meant to bring everything to a halt
 * when they fail, with the programmer there to assess the problem.
 *
 * In short: you can sprinkle these around liberally and assume they will
 * evaporate out of the build when building for end-users.
 *
 * When assertions are disabled, this wraps `condition` in a `sizeof`
 * operator, which means any function calls and side effects will not run, but
 * the compiler will not complain about any otherwise-unused variables that
 * are only referenced in the assertion.
 *
 * One can set the environment variable "SDL_ASSERT" to one of several strings
 * ("abort", "break", "retry", "ignore", "always_ignore") to force a default
 * behavior, which may be desirable for automation purposes. If your platform
 * requires GUI interfaces to happen on the main thread but you're debugging
 * an assertion in a background thread, it might be desirable to set this to
 * "break" so that your debugger takes control as soon as assert is triggered,
 * instead of risking a bad UI interaction (deadlock, etc) in the application.
 *
 * @param condition boolean value to test.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_assert(condition)                                                  \
  if (assertion_enabled && (condition)) { trigger_assertion; }

/**
 * An assertion test that is performed even in release builds.
 *
 * This macro is enabled when the SDL_ASSERT_LEVEL is >= 1, otherwise it is
 * disabled. This is meant to be for tests that are cheap to make and
 * extremely unlikely to fail; generally it is frowned upon to have an
 * assertion failure in a release build, so these assertions generally need to
 * be of more than life-and-death importance if there's a chance they might
 * trigger. You should almost always consider handling these cases more
 * gracefully than an assert allows.
 *
 * When assertions are disabled, this wraps `condition` in a `sizeof`
 * operator, which means any function calls and side effects will not run, but
 * the compiler will not complain about any otherwise-unused variables that
 * are only referenced in the assertion.
 *
 * One can set the environment variable "SDL_ASSERT" to one of several strings
 * ("abort", "break", "retry", "ignore", "always_ignore") to force a default
 * behavior, which may be desirable for automation purposes. If your platform
 * requires GUI interfaces to happen on the main thread but you're debugging
 * an assertion in a background thread, it might be desirable to set this to
 * "break" so that your debugger takes control as soon as assert is triggered,
 * instead of risking a bad UI interaction (deadlock, etc) in the application.
 * *
 *
 * @param condition boolean value to test.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_assert_release(condition) SDL_disabled_assert(condition)

/**
 * An assertion test that is performed only when built with paranoid settings.
 *
 * This macro is enabled when the SDL_ASSERT_LEVEL is >= 3, otherwise it is
 * disabled. This is a higher level than both release and debug, so these
 * tests are meant to be expensive and only run when specifically looking for
 * extremely unexpected failure cases in a special build.
 *
 * When assertions are disabled, this wraps `condition` in a `sizeof`
 * operator, which means any function calls and side effects will not run, but
 * the compiler will not complain about any otherwise-unused variables that
 * are only referenced in the assertion.
 *
 * One can set the environment variable "SDL_ASSERT" to one of several strings
 * ("abort", "break", "retry", "ignore", "always_ignore") to force a default
 * behavior, which may be desirable for automation purposes. If your platform
 * requires GUI interfaces to happen on the main thread but you're debugging
 * an assertion in a background thread, it might be desirable to set this to
 * "break" so that your debugger takes control as soon as assert is triggered,
 * instead of risking a bad UI interaction (deadlock, etc) in the application.
 *
 * @param condition boolean value to test.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_assert_paranoid(condition) SDL_disabled_assert(condition)

/**
 * An assertion test that is always performed.
 *
 * This macro is always enabled no matter what SDL_ASSERT_LEVEL is set to. You
 * almost never want to use this, as it could trigger on an end-user's system,
 * crashing your program.
 *
 * One can set the environment variable "SDL_ASSERT" to one of several strings
 * ("abort", "break", "retry", "ignore", "always_ignore") to force a default
 * behavior, which may be desirable for automation purposes. If your platform
 * requires GUI interfaces to happen on the main thread but you're debugging
 * an assertion in a background thread, it might be desirable to set this to
 * "break" so that your debugger takes control as soon as assert is triggered,
 * instead of risking a bad UI interaction (deadlock, etc) in the application.
 *
 * @param condition boolean value to test.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_assert_always(condition) SDL_enabled_assert(condition)

#endif // SDL3PP_DOC

/**
 * A @ref callback that fires when an SDL assertion fails.
 *
 * @param data a pointer to the AssertData structure corresponding to the
 *             current assertion.
 * @param userdata what was passed as `userdata` to SetAssertionHandler().
 * @returns an AssertState value indicating how to handle the failure.
 *
 * @threadsafety This callback may be called from any thread that triggers an
 *               assert at any time.
 *
 * @since This datatype is available since SDL 3.2.0.
 */
using AssertionHandler = SDL_AssertionHandler;

/**
 * A callback that fires when an SDL assertion fails.
 *
 * @param data a pointer to the AssertData structure corresponding to the
 *             current assertion.
 * @returns an AssertState value indicating how to handle the failure.
 *
 * @threadsafety This callback may be called from any thread that triggers an
 *               assert at any time.
 *
 * @since This datatype is available since SDL 3.2.0.
 * @sa AssertionHandler
 */
using AssertionHandlerCB =
  std::function<SDL_AssertState(const SDL_AssertData*)>;

/**
 * Set an application-defined assertion handler.
 *
 * This function allows an application to show its own assertion UI and/or
 * force the response to an assertion failure. If the application doesn't
 * provide this, SDL will try to do the right thing, popping up a
 * system-specific GUI dialog, and probably minimizing any fullscreen windows.
 *
 * This callback may fire from any thread, but it runs wrapped in a mutex, so
 * it will only fire from one thread at a time.
 *
 * This callback is NOT reset to SDL's internal handler upon Quit()!
 *
 * @param handler the AssertionHandler function to call when an assertion
 *                fails or nullptr for the default handler.
 * @param userdata a pointer that is passed to `handler`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetAssertionHandler
 */
inline void SetAssertionHandler(AssertionHandler handler, void* userdata)
{
  UniqueCallbackWrapper<AssertionHandlerCB>::erase();
  return SDL_SetAssertionHandler(handler, userdata);
}

/**
 * Set an application-defined assertion handler.
 *
 * This function allows an application to show its own assertion UI and/or
 * force the response to an assertion failure. If the application doesn't
 * provide this, SDL will try to do the right thing, popping up a
 * system-specific GUI dialog, and probably minimizing any fullscreen windows.
 *
 * This callback may fire from any thread, but it runs wrapped in a mutex, so
 * it will only fire from one thread at a time.
 *
 * This callback is NOT reset to SDL's internal handler upon Quit()!
 *
 * @param handler the SDL_AssertionHandler function to call when an assertion
 *                fails.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetAssertionHandler
 */
inline void SetAssertionHandler(AssertionHandlerCB handler)
{
  using Wrapper = UniqueCallbackWrapper<AssertionHandlerCB>;
  SetAssertionHandler(&Wrapper::CallSuffixed,
                      Wrapper::Wrap(std::move(handler)));
}
/**
 * Get the default assertion handler.
 *
 * This returns the function pointer that is called by default when an
 * assertion is triggered. This is an internal function provided by SDL, that
 * is used for assertions when SetAssertionHandler() hasn't been used to
 * provide a different function.
 *
 * @returns the default AssertionHandler that is called when an assert triggers.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetAssertionHandler
 */
inline AssertionHandler GetDefaultAssertionHandler()
{
  return SDL_GetDefaultAssertionHandler();
}

/**
 * Get the current assertion handler.
 *
 * This returns the function pointer that is called when an assertion is
 * triggered. This is either the value last passed to SetAssertionHandler(), or
 * if no application-specified function is set, is equivalent to calling
 * GetDefaultAssertionHandler().
 *
 * The parameter `puserdata` is a pointer to a void*, which will store the
 * "userdata" pointer that was passed to SetAssertionHandler(). This value
 * will always be nullptr for the default handler. If you don't care about this
 * data, it is safe to pass a nullptr pointer to this function to ignore it.
 *
 * @param puserdata pointer which is filled with the "userdata" pointer that
 *                  was passed to SetAssertionHandler().
 * @returns the AssertionHandler that is called when an assert triggers.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SetAssertionHandler
 */
inline AssertionHandler GetAssertionHandler(void** puserdata)
{
  return SDL_GetAssertionHandler(puserdata);
}

/**
 * Get the current assertion handler.
 *
 * This returns the function pointer that is called when an assertion is
 * triggered. This is either the value last passed to
 * SDL_SetAssertionHandler(), or if no application-specified function is set,
 * is equivalent to calling SDL_GetDefaultAssertionHandler().
 *
 * The parameter `puserdata` is a pointer to a void*, which will store the
 * "userdata" pointer that was passed to SDL_SetAssertionHandler(). This value
 * will always be nullptr for the default handler. If you don't care about this
 * data, it is safe to pass a nullptr pointer to this function to ignore it.
 *
 * @returns the AssertionHandlerCB that is called when an assert triggers.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SetAssertionHandler
 */
inline AssertionHandlerCB GetAssertionHandler()
{
  using Wrapper = UniqueCallbackWrapper<AssertionHandlerCB>;
  void* userdata = nullptr;
  auto cb = GetAssertionHandler(&userdata);
  if (Wrapper::contains(userdata)) return Wrapper::Unwrap(userdata);
  return [cb, userdata](const AssertData* data) { return cb(data, userdata); };
}

/**
 * Get a list of all assertion failures.
 *
 * This function gets all assertions triggered since the last call to
 * ResetAssertionReport(), or the start of the program.
 *
 * The proper way to examine this data looks something like this:
 *
 * ```cpp
 * const AssertData *item = GetAssertionReport();
 * while (item) {
 *    printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\@n",
 *           item->condition, item->function, item->filename,
 *           item->linenum, item->trigger_count,
 *           item->always_ignore ? "yes" : "no");
 *    item = item->next;
 * }
 * ```
 *
 * @returns a list of all failed assertions or nullptr if the list is empty.
 * This memory should not be modified or freed by the application. This pointer
 * remains valid until the next call to Quit() or ResetAssertionReport().
 *
 * @threadsafety This function is not thread safe. Other threads calling
 *               ResetAssertionReport() simultaneously, may render the
 *               returned pointer invalid.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa ResetAssertionReport
 */
inline const AssertData* GetAssertionReport()
{
  return SDL_GetAssertionReport();
}

/**
 * Clear the list of all assertion failures.
 *
 * This function will clear the list of all assertions triggered up to that
 * point. Immediately following this call, GetAssertionReport will return
 * no items. In addition, any previously-triggered assertions will be reset to
 * a trigger_count of zero, and their always_ignore state will be false.
 *
 * @threadsafety This function is not thread safe. Other threads triggering an
 *               assertion, or simultaneously calling this function may cause
 *               memory leaks or crashes.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetAssertionReport
 */
inline void ResetAssertionReport() { SDL_ResetAssertionReport(); }

/// @}

/**
 * @defgroup CategoryError Error Handling
 *
 * Simple error message routines for SDL.
 *
 * Most apps will interface with these APIs in exactly one function: when
 * almost any SDL function call reports failure, you can get a human-readable
 * string of the problem from GetError().
 *
 * These strings are maintained per-thread, and apps are welcome to set their
 * own errors, which is popular when building libraries on top of SDL for
 * other apps to consume. These strings are set by calling SetError().
 *
 * A common usage pattern is to have a function that returns true for success
 * and false for failure, and do this when something fails:
 *
 * ```cpp
 * if (something_went_wrong) {
 *    return SDL::SetError("The thing broke in this specific way: {}", errcode);
 * }
 * ```
 *
 * It's also common to just return `false` in this case if the failing thing
 * is known to call SetError(), so errors simply propagate through.
 *
 * @{
 */

/**
 * Set the SDL error message for the current thread.
 *
 * Calling this function will replace any previous error message that was set.
 *
 * This function always returns false, since SDL frequently uses false to
 * signify a failing result, leading to this idiom:
 *
 * ```c
 * if (error_code) {
 *     return SDL::SetError("This operation has failed: {}", error_code);
 * }
 * ```
 *
 * @param message the error message
 * @returns false.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa ClearError
 * @sa GetError
 * @sa SetError
 */
inline bool SetErrorUnformatted(StringParam message)
{
  return SDL_SetError("%s", static_cast<const char*>(message));
}

/**
 * Set the SDL error message for the current thread.
 *
 * Calling this function will replace any previous error message that was set.
 *
 * This function always returns false, since SDL frequently uses false to
 * signify a failing result, leading to this idiom:
 *
 * ```c
 * if (error_code) {
 *     return SetError("This operation has failed: {}", error_code);
 * }
 * ```
 *
 * @tparam ARGS the formatting parameters
 * @param fmt a
 * [std::format/fmt](https://en.cppreference.com/w/cpp/utility/format/spec)
 * style message format string
 * @param args additional parameters matching the `{}` tokens in the format
 * string, if any.
 * @returns false.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @cat formatted-string
 *
 * @sa formatted-string
 * @sa ClearError
 * @sa GetError
 * @sa SetError
 * @return false
 */
template<class... ARGS>
inline bool SetError(std::string_view fmt, ARGS... args)
{
  return SetError(
    std::vformat(fmt, std::make_format_args(std::forward<ARGS>(args)...)));
}

/**
 * Set an error indicating that memory allocation failed.
 *
 * This function does not do any memory allocation.
 *
 * @returns false.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline bool OutOfMemory() { return SDL_OutOfMemory(); }

/**
 * Retrieve a message about the last error that occurred on the current
 * thread.
 *
 * It is possible for multiple errors to occur before calling GetError().
 * Only the last error is returned.
 *
 * The message is only applicable when an SDL function has signaled an error.
 * You must check the return values of SDL function calls to determine when to
 * appropriately call GetError(). You should *not* use the results of
 * GetError() to decide if an error has occurred! Sometimes SDL will set
 * an error string even when reporting success.
 *
 * SDL will *not* clear the error string for successful API calls. You *must*
 * check return values for failure cases before you can assume the error
 * string applies.
 *
 * Error strings are set per-thread, so an error set in a different thread
 * will not interfere with the current thread's operation.
 *
 * The returned value is a thread-local string which will remain valid until
 * the current thread's error string is changed. The caller should make a copy
 * if the value is needed after the next SDL API call.
 *
 * @returns a message with information about the specific error that occurred,
 *          or an empty string if there hasn't been an error message set since
 *          the last call to ClearError().
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa ClearError
 * @sa SetErrorUnformatted
 */
inline const char* GetError() { return SDL_GetError(); }

/**
 * An exception that returns GetError()
 *
 */
class Error : public std::exception
{
  std::string m_message;

public:
  /// Default ctor.
  Error()
    : m_message(SDL_GetError())
  {
  }

  /// Default ctor.
  Error(std::string message)
    : m_message(std::move(message))
  {
  }

  /// Returns the explanatory string.
  constexpr const char* what() const noexcept { return m_message.c_str(); }

  /**
   * Returns the explanatory string.
   */
  constexpr const std::string& str() const noexcept { return m_message; }
};

/**
 * Check and throw if returned value from SDL is an error.
 *
 * This should be called only for things that may set SetError(). If the
 * parameter is false it will throw Error.
 *
 * @param result the result returned
 */
constexpr void CheckError(bool result)
{
  if (!result) throw Error();
}

/**
 * Check and throw if returned value from SDL is an error.
 *
 * This should be called only for things that may set SetError(). If the
 * parameter is false it will throw Error.
 *
 * @param result the result returned
 */
template<class T>
constexpr T CheckError(T result)
{
  if (!result) throw Error();
  return result;
}

/**
 * Check and throw if returned value from SDL is an error.
 *
 * This should be called only for things that may set SetError(). If the result
 * parameter is equals to invalidValue it will throw Error.
 *
 * @param result       the result returned
 * @param invalidValue the value that if equal to result indicates this is
 *                     invalid.
 */
template<class T>
constexpr T CheckError(T result, T invalidValue)
{
  if (result == invalidValue) throw Error();
  return result;
}

/**
 * Clear any previous error message for this thread.
 *
 * @returns true.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetError
 * @sa SetErrorUnformatted
 */
inline bool ClearError() { return SDL_ClearError(); }

#ifdef SDL3PP_DOC

/**
 * A macro to standardize error reporting on unsupported operations.
 *
 * This simply calls SetError() with a standardized error string, for
 * convenience, consistency, and clarity.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_Unsupported() SDL_SetError("That operation is not supported")

/**
 * A macro to standardize error reporting on unsupported operations.
 *
 * This simply calls SetError() with a standardized error string, for
 * convenience, consistency, and clarity.
 *
 * A common usage pattern inside SDL is this:
 *
 * ```c
 * bool MyFunction(const char *str) {
 *     if (!str) {
 *         return SDL_InvalidParamError("str");  // returns false.
 *     }
 *     DoSomething(str);
 *     return true;
 * }
 * ```
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_InvalidParamError(param)                                           \
  SDL_SetError("Parameter '%s' is invalid", (param))

#endif // SDL3PP_DOC

/// @}

/**
 * @defgroup CategoryHints Configuration Variables
 *
 * This file contains functions to set and get configuration hints, as well as
 * listing each of them alphabetically.
 *
 * The convention for naming hints is SDL_HINT_X, where "SDL_X" is the
 * environment variable that can be used to override the default.
 *
 * In general these hints are just that - they may or may not be supported or
 * applicable on any given platform, but they provide a way for an application
 * or user to give the library a hint as to how they would like the library to
 * work.
 *
 * @{
 */

#ifdef SDL3PP_DOC

/**
 * Specify the behavior of Alt+Tab while the keyboard is grabbed.
 *
 * By default, SDL emulates Alt+Tab functionality while the keyboard is
 * grabbed and your window is full-screen. This prevents the user from getting
 * stuck in your application if you've enabled keyboard grab.
 *
 * The variable can be set to the following values:
 *
 * - "0": SDL will not handle Alt+Tab. Your application is responsible for
 *   handling Alt+Tab while the keyboard is grabbed.
 * - "1": SDL will minimize your window when Alt+Tab is pressed (default)
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED "SDL_ALLOW_ALT_TAB_WHILE_GRABBED"

/**
 * A variable to control whether the SDL activity is allowed to be re-created.
 *
 * If this hint is true, the activity can be recreated on demand by the OS,
 * and Java static data and C++ static data remain with their current values.
 * If this hint is false, then SDL will call exit() when you return from your
 * main function and the application will be terminated and then started fresh
 * each time.
 *
 * The variable can be set to the following values:
 *
 * - "0": The application starts fresh at each launch. (default)
 * - "1": The application activity can be recreated by the OS.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_ANDROID_ALLOW_RECREATE_ACTIVITY                               \
  "SDL_ANDROID_ALLOW_RECREATE_ACTIVITY"

/**
 * A variable to control whether the event loop will block itself when the app
 * is paused.
 *
 * The variable can be set to the following values:
 *
 * - "0": Non blocking.
 * - "1": Blocking. (default)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_ANDROID_BLOCK_ON_PAUSE "SDL_ANDROID_BLOCK_ON_PAUSE"

/**
 * A variable to control whether low latency audio should be enabled.
 *
 * Some devices have poor quality output when this is enabled, but this is
 * usually an improvement in audio latency.
 *
 * The variable can be set to the following values:
 *
 * - "0": Low latency audio is not enabled.
 * - "1": Low latency audio is enabled. (default)
 *
 * This hint should be set before SDL audio is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_ANDROID_LOW_LATENCY_AUDIO "SDL_ANDROID_LOW_LATENCY_AUDIO"

/**
 * A variable to control whether we trap the Android back button to handle it
 * manually.
 *
 * This is necessary for the right mouse button to work on some Android
 * devices, or to be able to trap the back button for use in your code
 * reliably. If this hint is true, the back button will show up as an
 * EVENT_KEY_DOWN / EVENT_KEY_UP pair with a keycode of
 * SCANCODE_AC_BACK.
 *
 * The variable can be set to the following values:
 *
 * - "0": Back button will be handled as usual for system. (default)
 * - "1": Back button will be trapped, allowing you to handle the key press
 *   manually. (This will also let right mouse click work on systems where the
 *   right mouse button functions as back.)
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_ANDROID_TRAP_BACK_BUTTON "SDL_ANDROID_TRAP_BACK_BUTTON"

/**
 * A variable setting the app ID string.
 *
 * This string is used by desktop compositors to identify and group windows
 * together, as well as match applications with associated desktop settings
 * and icons.
 *
 * This will override prop::appMetaData.IDENTIFIER_STRING, if set by the
 * application.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_APP_ID "SDL_APP_ID"

/**
 * A variable setting the application name.
 *
 * This hint lets you specify the application name sent to the OS when
 * required. For example, this will often appear in volume control applets for
 * audio streams, and in lists of applications which are inhibiting the
 * screensaver. You should use a string that describes your program ("My Game
 * 2: The Revenge")
 *
 * This will override prop::appMetaData.NAME_STRING, if set by the
 * application.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_APP_NAME "SDL_APP_NAME"

/**
 * A variable controlling whether controllers used with the Apple TV generate
 * UI events.
 *
 * When UI events are generated by controller input, the app will be
 * backgrounded when the Apple TV remote's menu button is pressed, and when
 * the pause or B buttons on gamepads are pressed.
 *
 * More information about properly making use of controllers for the Apple TV
 * can be found here:
 * https://developer.apple.com/tvos/human-interface-guidelines/remote-and-controllers/
 *
 * The variable can be set to the following values:
 *
 * - "0": Controller input does not generate UI events. (default)
 * - "1": Controller input generates UI events.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS                                 \
  "SDL_APPLE_TV_CONTROLLER_UI_EVENTS"

/**
 * A variable controlling whether the Apple TV remote's joystick axes will
 * automatically match the rotation of the remote.
 *
 * The variable can be set to the following values:
 *
 * - "0": Remote orientation does not affect joystick axes. (default)
 * - "1": Joystick axes are based on the orientation of the remote.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION                                \
  "SDL_APPLE_TV_REMOTE_ALLOW_ROTATION"

/**
 * Specify the default ALSA audio device name.
 *
 * This variable is a specific audio device to open when the "default" audio
 * device is used.
 *
 * This hint will be ignored when opening the default playback device if
 * SDL_HINT_AUDIO_ALSA_DEFAULT_PLAYBACK_DEVICE is set, or when opening the
 * default recording device if SDL_HINT_AUDIO_ALSA_DEFAULT_RECORDING_DEVICE is
 * set.
 *
 * This hint should be set before an audio device is opened.
 *
 * @since This hint is available since SDL 3.2.0.
 *
 * @sa SDL_HINT_AUDIO_ALSA_DEFAULT_PLAYBACK_DEVICE
 * @sa SDL_HINT_AUDIO_ALSA_DEFAULT_RECORDING_DEVICE
 */
#define SDL_HINT_AUDIO_ALSA_DEFAULT_DEVICE "SDL_AUDIO_ALSA_DEFAULT_DEVICE"

/**
 * Specify the default ALSA audio playback device name.
 *
 * This variable is a specific audio device to open for playback, when the
 * "default" audio device is used.
 *
 * If this hint isn't set, SDL will check SDL_HINT_AUDIO_ALSA_DEFAULT_DEVICE
 * before choosing a reasonable default.
 *
 * This hint should be set before an audio device is opened.
 *
 * @since This hint is available since SDL 3.2.0.
 *
 * @sa SDL_HINT_AUDIO_ALSA_DEFAULT_RECORDING_DEVICE
 * @sa SDL_HINT_AUDIO_ALSA_DEFAULT_DEVICE
 */
#define SDL_HINT_AUDIO_ALSA_DEFAULT_PLAYBACK_DEVICE                            \
  "SDL_AUDIO_ALSA_DEFAULT_PLAYBACK_DEVICE"

/**
 * Specify the default ALSA audio recording device name.
 *
 * This variable is a specific audio device to open for recording, when the
 * "default" audio device is used.
 *
 * If this hint isn't set, SDL will check SDL_HINT_AUDIO_ALSA_DEFAULT_DEVICE
 * before choosing a reasonable default.
 *
 * This hint should be set before an audio device is opened.
 *
 * @since This hint is available since SDL 3.2.0.
 *
 * @sa SDL_HINT_AUDIO_ALSA_DEFAULT_PLAYBACK_DEVICE
 * @sa SDL_HINT_AUDIO_ALSA_DEFAULT_DEVICE
 */
#define SDL_HINT_AUDIO_ALSA_DEFAULT_RECORDING_DEVICE                           \
  "SDL_AUDIO_ALSA_DEFAULT_RECORDING_DEVICE"

/**
 * A variable controlling the audio category on iOS and macOS.
 *
 * The variable can be set to the following values:
 *
 * - "ambient": Use the AVAudioSessionCategoryAmbient audio category, will be
 *   muted by the phone mute switch (default)
 * - "playback": Use the AVAudioSessionCategoryPlayback category.
 *
 * For more information, see Apple's documentation:
 * https://developer.apple.com/library/content/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/AudioSessionCategoriesandModes/AudioSessionCategoriesandModes.html
 *
 * This hint should be set before an audio device is opened.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_AUDIO_CATEGORY "SDL_AUDIO_CATEGORY"

/**
 * A variable controlling the default audio channel count.
 *
 * If the application doesn't specify the audio channel count when opening the
 * device, this hint can be used to specify a default channel count that will
 * be used. This defaults to "1" for recording and "2" for playback devices.
 *
 * This hint should be set before an audio device is opened.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_AUDIO_CHANNELS "SDL_AUDIO_CHANNELS"

/**
 * Specify an application icon name for an audio device.
 *
 * Some audio backends (such as Pulseaudio and Pipewire) allow you to set an
 * XDG icon name for your application. Among other things, this icon might
 * show up in a system control panel that lets the user adjust the volume on
 * specific audio streams instead of using one giant master volume slider.
 * Note that this is unrelated to the icon used by the windowing system, which
 * may be set with Window.SetIcon (or via desktop file on Wayland).
 *
 * Setting this to "" or leaving it unset will have SDL use a reasonable
 * default, "applications-games", which is likely to be installed. See
 * https://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html
 * and
 * https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html
 * for the relevant XDG icon specs.
 *
 * This hint should be set before an audio device is opened.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_AUDIO_DEVICE_APP_ICON_NAME "SDL_AUDIO_DEVICE_APP_ICON_NAME"

/**
 * A variable controlling device buffer size.
 *
 * This hint is an integer > 0, that represents the size of the device's
 * buffer in sample frames (stereo audio data in 16-bit format is 4 bytes per
 * sample frame, for example).
 *
 * SDL3 generally decides this value on behalf of the app, but if for some
 * reason the app needs to dictate this (because they want either lower
 * latency or higher throughput AND ARE WILLING TO DEAL WITH what that might
 * require of the app), they can specify it.
 *
 * SDL will try to accommodate this value, but there is no promise you'll get
 * the buffer size requested. Many platforms won't honor this request at all,
 * or might adjust it.
 *
 * This hint should be set before an audio device is opened.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_AUDIO_DEVICE_SAMPLE_FRAMES "SDL_AUDIO_DEVICE_SAMPLE_FRAMES"

/**
 * Specify an audio stream name for an audio device.
 *
 * Some audio backends (such as PulseAudio) allow you to describe your audio
 * stream. Among other things, this description might show up in a system
 * control panel that lets the user adjust the volume on specific audio
 * streams instead of using one giant master volume slider.
 *
 * This hints lets you transmit that information to the OS. The contents of
 * this hint are used while opening an audio device. You should use a string
 * that describes your what your program is playing ("audio stream" is
 * probably sufficient in many cases, but this could be useful for something
 * like "team chat" if you have a headset playing VoIP audio separately).
 *
 * Setting this to "" or leaving it unset will have SDL use a reasonable
 * default: "audio stream" or something similar.
 *
 * Note that while this talks about audio streams, this is an OS-level
 * concept, so it applies to a physical audio device in this case, and not an
 * AudioStream, nor an SDL logical audio device.
 *
 * This hint should be set before an audio device is opened.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_AUDIO_DEVICE_STREAM_NAME "SDL_AUDIO_DEVICE_STREAM_NAME"

/**
 * Specify an application role for an audio device.
 *
 * Some audio backends (such as Pipewire) allow you to describe the role of
 * your audio stream. Among other things, this description might show up in a
 * system control panel or software for displaying and manipulating media
 * playback/recording graphs.
 *
 * This hints lets you transmit that information to the OS. The contents of
 * this hint are used while opening an audio device. You should use a string
 * that describes your what your program is playing (Game, Music, Movie,
 * etc...).
 *
 * Setting this to "" or leaving it unset will have SDL use a reasonable
 * default: "Game" or something similar.
 *
 * Note that while this talks about audio streams, this is an OS-level
 * concept, so it applies to a physical audio device in this case, and not an
 * AudioStream, nor an SDL logical audio device.
 *
 * This hint should be set before an audio device is opened.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_AUDIO_DEVICE_STREAM_ROLE "SDL_AUDIO_DEVICE_STREAM_ROLE"

/**
 * Specify the input file when recording audio using the disk audio driver.
 *
 * This defaults to "sdlaudio-in.raw"
 *
 * This hint should be set before an audio device is opened.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_AUDIO_DISK_INPUT_FILE "SDL_AUDIO_DISK_INPUT_FILE"

/**
 * Specify the output file when playing audio using the disk audio driver.
 *
 * This defaults to "sdlaudio.raw"
 *
 * This hint should be set before an audio device is opened.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_AUDIO_DISK_OUTPUT_FILE "SDL_AUDIO_DISK_OUTPUT_FILE"

/**
 * A variable controlling the audio rate when using the disk audio driver.
 *
 * The disk audio driver normally simulates real-time for the audio rate that
 * was specified, but you can use this variable to adjust this rate higher or
 * lower down to 0. The default value is "1.0".
 *
 * This hint should be set before an audio device is opened.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_AUDIO_DISK_TIMESCALE "SDL_AUDIO_DISK_TIMESCALE"

/**
 * A variable that specifies an audio backend to use.
 *
 * By default, SDL will try all available audio backends in a reasonable order
 * until it finds one that can work, but this hint allows the app or user to
 * force a specific driver, such as "pipewire" if, say, you are on PulseAudio
 * but want to try talking to the lower level instead.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_AUDIO_DRIVER "SDL_AUDIO_DRIVER"

/**
 * A variable controlling the audio rate when using the dummy audio driver.
 *
 * The dummy audio driver normally simulates real-time for the audio rate that
 * was specified, but you can use this variable to adjust this rate higher or
 * lower down to 0. The default value is "1.0".
 *
 * This hint should be set before an audio device is opened.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_AUDIO_DUMMY_TIMESCALE "SDL_AUDIO_DUMMY_TIMESCALE"

/**
 * A variable controlling the default audio format.
 *
 * If the application doesn't specify the audio format when opening the
 * device, this hint can be used to specify a default format that will be
 * used.
 *
 * The variable can be set to the following values:
 *
 * - "U8": Unsigned 8-bit audio
 * - "S8": Signed 8-bit audio
 * - "S16LE": Signed 16-bit little-endian audio
 * - "S16BE": Signed 16-bit big-endian audio
 * - "S16": Signed 16-bit native-endian audio (default)
 * - "S32LE": Signed 32-bit little-endian audio
 * - "S32BE": Signed 32-bit big-endian audio
 * - "S32": Signed 32-bit native-endian audio
 * - "F32LE": Floating point little-endian audio
 * - "F32BE": Floating point big-endian audio
 * - "F32": Floating point native-endian audio
 *
 * This hint should be set before an audio device is opened.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_AUDIO_FORMAT "SDL_AUDIO_FORMAT"

/**
 * A variable controlling the default audio frequency.
 *
 * If the application doesn't specify the audio frequency when opening the
 * device, this hint can be used to specify a default frequency that will be
 * used. This defaults to "44100".
 *
 * This hint should be set before an audio device is opened.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_AUDIO_FREQUENCY "SDL_AUDIO_FREQUENCY"

/**
 * A variable that causes SDL to not ignore audio "monitors".
 *
 * This is currently only used by the PulseAudio driver.
 *
 * By default, SDL ignores audio devices that aren't associated with physical
 * hardware. Changing this hint to "1" will expose anything SDL sees that
 * appears to be an audio source or sink. This will add "devices" to the list
 * that the user probably doesn't want or need, but it can be useful in
 * scenarios where you want to hook up SDL to some sort of virtual device,
 * etc.
 *
 * The variable can be set to the following values:
 *
 * - "0": Audio monitor devices will be ignored. (default)
 * - "1": Audio monitor devices will show up in the device list.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_AUDIO_INCLUDE_MONITORS "SDL_AUDIO_INCLUDE_MONITORS"

/**
 * A variable controlling whether SDL updates joystick state when getting
 * input events.
 *
 * The variable can be set to the following values:
 *
 * - "0": You'll call SDL_UpdateJoysticks() manually.
 * - "1": SDL will automatically call SDL_UpdateJoysticks(). (default)
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_AUTO_UPDATE_JOYSTICKS "SDL_AUTO_UPDATE_JOYSTICKS"

/**
 * A variable controlling whether SDL updates sensor state when getting input
 * events.
 *
 * The variable can be set to the following values:
 *
 * - "0": You'll call SDL_UpdateSensors() manually.
 * - "1": SDL will automatically call SDL_UpdateSensors(). (default)
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_AUTO_UPDATE_SENSORS "SDL_AUTO_UPDATE_SENSORS"

/**
 * Prevent SDL from using version 4 of the bitmap header when saving BMPs.
 *
 * The bitmap header version 4 is required for proper alpha channel support
 * and SDL will use it when required. Should this not be desired, this hint
 * can force the use of the 40 byte header version which is supported
 * everywhere.
 *
 * The variable can be set to the following values:
 *
 * - "0": Surfaces with a colorkey or an alpha channel are saved to a 32-bit
 *   BMP file with an alpha mask. SDL will use the bitmap header version 4 and
 *   set the alpha mask accordingly. (default)
 * - "1": Surfaces with a colorkey or an alpha channel are saved to a 32-bit
 *   BMP file without an alpha mask. The alpha channel data will be in the
 *   file, but applications are going to ignore it.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_BMP_SAVE_LEGACY_FORMAT "SDL_BMP_SAVE_LEGACY_FORMAT"

/**
 * A variable that decides what camera backend to use.
 *
 * By default, SDL will try all available camera backends in a reasonable
 * order until it finds one that can work, but this hint allows the app or
 * user to force a specific target, such as "directshow" if, say, you are on
 * Windows Media Foundations but want to try DirectShow instead.
 *
 * The default value is unset, in which case SDL will try to figure out the
 * best camera backend on your behalf. This hint needs to be set before
 * Init() is called to be useful.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_CAMERA_DRIVER "SDL_CAMERA_DRIVER"

/**
 * A variable that limits what CPU features are available.
 *
 * By default, SDL marks all features the current CPU supports as available.
 * This hint allows the enabled features to be limited to a subset.
 *
 * When the hint is unset, or empty, SDL will enable all detected CPU
 * features.
 *
 * The variable can be set to a comma separated list containing the following
 * items:
 *
 * - "all"
 * - "altivec"
 * - "sse"
 * - "sse2"
 * - "sse3"
 * - "sse41"
 * - "sse42"
 * - "avx"
 * - "avx2"
 * - "avx512f"
 * - "arm-simd"
 * - "neon"
 * - "lsx"
 * - "lasx"
 *
 * The items can be prefixed by '+'/'-' to add/remove features.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_CPU_FEATURE_MASK "SDL_CPU_FEATURE_MASK"

/**
 * A variable controlling whether DirectInput should be used for controllers.
 *
 * The variable can be set to the following values:
 *
 * - "0": Disable DirectInput detection.
 * - "1": Enable DirectInput detection. (default)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_DIRECTINPUT "SDL_JOYSTICK_DIRECTINPUT"

/**
 * A variable that specifies a dialog backend to use.
 *
 * By default, SDL will try all available dialog backends in a reasonable
 * order until it finds one that can work, but this hint allows the app or
 * user to force a specific target.
 *
 * If the specified target does not exist or is not available, the
 * dialog-related function calls will fail.
 *
 * This hint currently only applies to platforms using the generic "Unix"
 * dialog implementation, but may be extended to more platforms in the future.
 * Note that some Unix and Unix-like platforms have their own implementation,
 * such as macOS and Haiku.
 *
 * The variable can be set to the following values:
 *
 * - nullptr: Select automatically (default, all platforms)
 * - "portal": Use XDG Portals through DBus (Unix only)
 * - "zenity": Use the Zenity program (Unix only)
 *
 * More options may be added in the future.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_FILE_DIALOG_DRIVER "SDL_FILE_DIALOG_DRIVER"

/**
 * Override for Display.GetUsableBounds().
 *
 * If set, this hint will override the expected results for
 * Display.GetUsableBounds() for display index 0. Generally you don't want
 * to do this, but this allows an embedded system to request that some of the
 * screen be reserved for other uses when paired with a well-behaved
 * application.
 *
 * The contents of this hint must be 4 comma-separated integers, the first is
 * the bounds x, then y, width and height, in that order.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_DISPLAY_USABLE_BOUNDS "SDL_DISPLAY_USABLE_BOUNDS"

/**
 * Disable giving back control to the browser automatically when running with
 * asyncify.
 *
 * With -s ASYNCIFY, SDL calls emscripten_sleep during operations such as
 * refreshing the screen or polling events.
 *
 * This hint only applies to the emscripten platform.
 *
 * The variable can be set to the following values:
 *
 * - "0": Disable emscripten_sleep calls (if you give back browser control
 *   manually or use asyncify for other purposes).
 * - "1": Enable emscripten_sleep calls. (default)
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_EMSCRIPTEN_ASYNCIFY "SDL_EMSCRIPTEN_ASYNCIFY"

/**
 * Specify the CSS selector used for the "default" window/canvas.
 *
 * This hint only applies to the emscripten platform.
 *
 * The default value is "#canvas"
 *
 * This hint should be set before creating a window.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_EMSCRIPTEN_CANVAS_SELECTOR "SDL_EMSCRIPTEN_CANVAS_SELECTOR"

/**
 * Override the binding element for keyboard inputs for Emscripten builds.
 *
 * This hint only applies to the emscripten platform.
 *
 * The variable can be one of:
 *
 * - "#window": the javascript window object (default)
 * - "#document": the javascript document object
 * - "#screen": the javascript window.screen object
 * - "#canvas": the WebGL canvas element
 * - "#none": Don't bind anything at all
 * - any other string without a leading # sign applies to the element on the
 *   page with that ID.
 *
 * This hint should be set before creating a window.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT "SDL_EMSCRIPTEN_KEYBOARD_ELEMENT"

/**
 * A variable that controls whether the on-screen keyboard should be shown
 * when text input is active.
 *
 * The variable can be set to the following values:
 *
 * - "auto": The on-screen keyboard will be shown if there is no physical
 *   keyboard attached. (default)
 * - "0": Do not show the on-screen keyboard.
 * - "1": Show the on-screen keyboard, if available.
 *
 * This hint must be set before Window.StartTextInput() is called
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_ENABLE_SCREEN_KEYBOARD "SDL_ENABLE_SCREEN_KEYBOARD"

/**
 * A variable containing a list of evdev devices to use if udev is not
 * available.
 *
 * The list of devices is in the form:
 *
 * deviceclass:path[,deviceclass:path[,...]]
 *
 * where device class is an integer representing the SDL_UDEV_deviceclass and
 * path is the full path to the event device.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_EVDEV_DEVICES "SDL_EVDEV_DEVICES"

/**
 * A variable controlling verbosity of the logging of SDL events pushed onto
 * the internal queue.
 *
 * The variable can be set to the following values, from least to most
 * verbose:
 *
 * - "0": Don't log any events. (default)
 * - "1": Log most events (other than the really spammy ones).
 * - "2": Include mouse and finger motion events.
 *
 * This is generally meant to be used to debug SDL itself, but can be useful
 * for application developers that need better visibility into what is going
 * on in the event queue. Logged events are sent through Log(), which
 * means by default they appear on stdout on most platforms or maybe
 * OutputDebugString() on Windows, and can be funneled by the app with
 * SetLogOutputFunction(), etc.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_EVENT_LOGGING "SDL_EVENT_LOGGING"

/**
 * A variable controlling whether raising the window should be done more
 * forcefully.
 *
 * The variable can be set to the following values:
 *
 * - "0": Honor the OS policy for raising windows. (default)
 * - "1": Force the window to be raised, overriding any OS policy.
 *
 * At present, this is only an issue under MS Windows, which makes it nearly
 * impossible to programmatically move a window to the foreground, for
 * "security" reasons. See http://stackoverflow.com/a/34414846 for a
 * discussion.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_FORCE_RAISEWINDOW "SDL_FORCE_RAISEWINDOW"

/**
 * A variable controlling how 3D acceleration is used to accelerate the SDL
 * screen surface.
 *
 * SDL can try to accelerate the SDL screen surface by using streaming
 * textures with a 3D rendering engine. This variable controls whether and how
 * this is done.
 *
 * The variable can be set to the following values:
 *
 * - "0": Disable 3D acceleration
 * - "1": Enable 3D acceleration, using the default renderer. (default)
 * - "X": Enable 3D acceleration, using X where X is one of the valid
 *   rendering drivers. (e.g. "direct3d", "opengl", etc.)
 *
 * This hint should be set before calling Window.GetSurface()
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_FRAMEBUFFER_ACCELERATION "SDL_FRAMEBUFFER_ACCELERATION"

/**
 * A variable that lets you manually hint extra gamecontroller db entries.
 *
 * The variable should be newline delimited rows of gamecontroller config
 * data, see SDL_gamepad.h
 *
 * You can update mappings after SDL is initialized with
 * SDL_GetGamepadMappingForGUID() and SDL_AddGamepadMapping()
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_GAMECONTROLLERCONFIG "SDL_GAMECONTROLLERCONFIG"

/**
 * A variable that lets you provide a file with extra gamecontroller db
 * entries.
 *
 * The file should contain lines of gamecontroller config data, see
 * SDL_gamepad.h
 *
 * You can update mappings after SDL is initialized with
 * SDL_GetGamepadMappingForGUID() and SDL_AddGamepadMapping()
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_GAMECONTROLLERCONFIG_FILE "SDL_GAMECONTROLLERCONFIG_FILE"

/**
 * A variable that overrides the automatic controller type detection.
 *
 * The variable should be comma separated entries, in the form: VID/PID=type
 *
 * The VID and PID should be hexadecimal with exactly 4 digits, e.g. 0x00fd
 *
 * This hint affects what low level protocol is used with the HIDAPI driver.
 *
 * The variable can be set to the following values:
 *
 * - "Xbox360"
 * - "XboxOne"
 * - "PS3"
 * - "PS4"
 * - "PS5"
 * - "SwitchPro"
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_GAMECONTROLLERTYPE "SDL_GAMECONTROLLERTYPE"

/**
 * A variable containing a list of devices to skip when scanning for game
 * controllers.
 *
 * The format of the string is a comma separated list of USB VID/PID pairs in
 * hexadecimal form, e.g.
 *
 * 0xAAAA/0xBBBB,0xCCCC/0xDDDD
 *
 * The variable can also take the form of "@file", in which case the named
 * file will be loaded and interpreted as the value of the variable.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES                                 \
  "SDL_GAMECONTROLLER_IGNORE_DEVICES"

/**
 * If set, all devices will be skipped when scanning for game controllers
 * except for the ones listed in this variable.
 *
 * The format of the string is a comma separated list of USB VID/PID pairs in
 * hexadecimal form, e.g.
 *
 * 0xAAAA/0xBBBB,0xCCCC/0xDDDD
 *
 * The variable can also take the form of "@file", in which case the named
 * file will be loaded and interpreted as the value of the variable.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT                          \
  "SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT"

/**
 * A variable that controls whether the device's built-in accelerometer and
 * gyro should be used as sensors for gamepads.
 *
 * The variable can be set to the following values:
 *
 * - "0": Sensor fusion is disabled
 * - "1": Sensor fusion is enabled for all controllers that lack sensors
 *
 * Or the variable can be a comma separated list of USB VID/PID pairs in
 * hexadecimal form, e.g.
 *
 * 0xAAAA/0xBBBB,0xCCCC/0xDDDD
 *
 * The variable can also take the form of "@file", in which case the named
 * file will be loaded and interpreted as the value of the variable.
 *
 * This hint should be set before a gamepad is opened.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_GAMECONTROLLER_SENSOR_FUSION "SDL_GAMECONTROLLER_SENSOR_FUSION"

/**
 * This variable sets the default text of the TextInput window on GDK
 * platforms.
 *
 * This hint is available only if SDL_GDK_TEXTINPUT defined.
 *
 * This hint should be set before calling Window.StartTextInput()
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_GDK_TEXTINPUT_DEFAULT_TEXT "SDL_GDK_TEXTINPUT_DEFAULT_TEXT"

/**
 * This variable sets the description of the TextInput window on GDK
 * platforms.
 *
 * This hint is available only if SDL_GDK_TEXTINPUT defined.
 *
 * This hint should be set before calling Window.StartTextInput()
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_GDK_TEXTINPUT_DESCRIPTION "SDL_GDK_TEXTINPUT_DESCRIPTION"

/**
 * This variable sets the maximum input length of the TextInput window on GDK
 * platforms.
 *
 * The value must be a stringified integer, for example "10" to allow for up
 * to 10 characters of text input.
 *
 * This hint is available only if SDL_GDK_TEXTINPUT defined.
 *
 * This hint should be set before calling Window.StartTextInput()
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_GDK_TEXTINPUT_MAX_LENGTH "SDL_GDK_TEXTINPUT_MAX_LENGTH"

/**
 * This variable sets the input scope of the TextInput window on GDK
 * platforms.
 *
 * Set this hint to change the XGameUiTextEntryInputScope value that will be
 * passed to the window creation function. The value must be a stringified
 * integer, for example "0" for XGameUiTextEntryInputScope::Default.
 *
 * This hint is available only if SDL_GDK_TEXTINPUT defined.
 *
 * This hint should be set before calling Window.StartTextInput()
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_GDK_TEXTINPUT_SCOPE "SDL_GDK_TEXTINPUT_SCOPE"

/**
 * This variable sets the title of the TextInput window on GDK platforms.
 *
 * This hint is available only if SDL_GDK_TEXTINPUT defined.
 *
 * This hint should be set before calling Window.StartTextInput()
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_GDK_TEXTINPUT_TITLE "SDL_GDK_TEXTINPUT_TITLE"

/**
 * A variable to control whether HIDAPI uses libusb for device access.
 *
 * By default libusb will only be used for a few devices that require direct
 * USB access, and this can be controlled with
 * SDL_HINT_HIDAPI_LIBUSB_WHITELIST.
 *
 * The variable can be set to the following values:
 *
 * - "0": HIDAPI will not use libusb for device access.
 * - "1": HIDAPI will use libusb for device access if available. (default)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_HIDAPI_LIBUSB "SDL_HIDAPI_LIBUSB"

/**
 * A variable to control whether HIDAPI uses libusb only for whitelisted
 * devices.
 *
 * By default libusb will only be used for a few devices that require direct
 * USB access.
 *
 * The variable can be set to the following values:
 *
 * - "0": HIDAPI will use libusb for all device access.
 * - "1": HIDAPI will use libusb only for whitelisted devices. (default)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_HIDAPI_LIBUSB_WHITELIST "SDL_HIDAPI_LIBUSB_WHITELIST"

/**
 * A variable to control whether HIDAPI uses udev for device detection.
 *
 * The variable can be set to the following values:
 *
 * - "0": HIDAPI will poll for device changes.
 * - "1": HIDAPI will use udev for device detection. (default)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_HIDAPI_UDEV "SDL_HIDAPI_UDEV"

/**
 * A variable that specifies a GPU backend to use.
 *
 * By default, SDL will try all available GPU backends in a reasonable order
 * until it finds one that can work, but this hint allows the app or user to
 * force a specific target, such as "direct3d12" if, say, your hardware
 * supports Vulkan but you want to try using D3D12 instead.
 *
 * This hint should be set before any GPU functions are called.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_GPU_DRIVER "SDL_GPU_DRIVER"

/**
 * A variable to control whether SDL_hid_enumerate() enumerates all HID
 * devices or only controllers.
 *
 * The variable can be set to the following values:
 *
 * - "0": SDL_hid_enumerate() will enumerate all HID devices.
 * - "1": SDL_hid_enumerate() will only enumerate controllers. (default)
 *
 * By default SDL will only enumerate controllers, to reduce risk of hanging
 * or crashing on devices with bad drivers and avoiding macOS keyboard capture
 * permission prompts.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_HIDAPI_ENUMERATE_ONLY_CONTROLLERS                             \
  "SDL_HIDAPI_ENUMERATE_ONLY_CONTROLLERS"

/**
 * A variable containing a list of devices to ignore in SDL_hid_enumerate().
 *
 * The format of the string is a comma separated list of USB VID/PID pairs in
 * hexadecimal form, e.g.
 *
 * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
 *
 * For example, to ignore the Shanwan DS3 controller and any Valve controller,
 * you might use the string "0x2563/0x0523,0x28de/0x0000"
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_HIDAPI_IGNORE_DEVICES "SDL_HIDAPI_IGNORE_DEVICES"

/**
 * A variable describing what IME UI elements the application can display.
 *
 * By default IME UI is handled using native components by the OS where
 * possible, however this can interfere with or not be visible when exclusive
 * fullscreen mode is used.
 *
 * The variable can be set to a comma separated list containing the following
 * items:
 *
 * - "none" or "0": The application can't render any IME elements, and native
 *   UI should be used. (default)
 * - "composition": The application handles EVENT_TEXT_EDITING events and
 *   can render the composition text.
 * - "candidates": The application handles EVENT_TEXT_EDITING_CANDIDATES
 *   and can render the candidate list.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_IME_IMPLEMENTED_UI "SDL_IME_IMPLEMENTED_UI"

/**
 * A variable controlling whether the home indicator bar on iPhone X should be
 * hidden.
 *
 * The variable can be set to the following values:
 *
 * - "0": The indicator bar is not hidden. (default for windowed applications)
 * - "1": The indicator bar is hidden and is shown when the screen is touched
 *   (useful for movie playback applications).
 * - "2": The indicator bar is dim and the first swipe makes it visible and
 *   the second swipe performs the "home" action. (default for fullscreen
 *   applications)
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_IOS_HIDE_HOME_INDICATOR "SDL_IOS_HIDE_HOME_INDICATOR"

/**
 * A variable that lets you enable joystick (and gamecontroller) events even
 * when your app is in the background.
 *
 * The variable can be set to the following values:
 *
 * - "0": Disable joystick & gamecontroller input events when the application
 *   is in the background. (default)
 * - "1": Enable joystick & gamecontroller input events when the application
 *   is in the background.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS                              \
  "SDL_JOYSTICK_ALLOW_BACKGROUND_EVENTS"

/**
 * A variable containing a list of arcade stick style controllers.
 *
 * The format of the string is a comma separated list of USB VID/PID pairs in
 * hexadecimal form, e.g.
 *
 * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
 *
 * The variable can also take the form of "@file", in which case the named
 * file will be loaded and interpreted as the value of the variable.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_ARCADESTICK_DEVICES "SDL_JOYSTICK_ARCADESTICK_DEVICES"

/**
 * A variable containing a list of devices that are not arcade stick style
 * controllers.
 *
 * This will override SDL_HINT_JOYSTICK_ARCADESTICK_DEVICES and the built in
 * device list.
 *
 * The format of the string is a comma separated list of USB VID/PID pairs in
 * hexadecimal form, e.g.
 *
 * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
 *
 * The variable can also take the form of "@file", in which case the named
 * file will be loaded and interpreted as the value of the variable.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_ARCADESTICK_DEVICES_EXCLUDED                         \
  "SDL_JOYSTICK_ARCADESTICK_DEVICES_EXCLUDED"

/**
 * A variable containing a list of devices that should not be considered
 * joysticks.
 *
 * The format of the string is a comma separated list of USB VID/PID pairs in
 * hexadecimal form, e.g.
 *
 * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
 *
 * The variable can also take the form of "@file", in which case the named
 * file will be loaded and interpreted as the value of the variable.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_BLACKLIST_DEVICES "SDL_JOYSTICK_BLACKLIST_DEVICES"

/**
 * A variable containing a list of devices that should be considered
 * joysticks.
 *
 * This will override SDL_HINT_JOYSTICK_BLACKLIST_DEVICES and the built in
 * device list.
 *
 * The format of the string is a comma separated list of USB VID/PID pairs in
 * hexadecimal form, e.g.
 *
 * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
 *
 * The variable can also take the form of "@file", in which case the named
 * file will be loaded and interpreted as the value of the variable.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_BLACKLIST_DEVICES_EXCLUDED                           \
  "SDL_JOYSTICK_BLACKLIST_DEVICES_EXCLUDED"

/**
 * A variable containing a comma separated list of devices to open as
 * joysticks.
 *
 * This variable is currently only used by the Linux joystick driver.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_DEVICE "SDL_JOYSTICK_DEVICE"

/**
 * A variable controlling whether enhanced reports should be used for
 * controllers when using the HIDAPI driver.
 *
 * Enhanced reports allow rumble and effects on Bluetooth PlayStation
 * controllers and gyro on Nintendo Switch controllers, but break Windows
 * DirectInput for other applications that don't use SDL.
 *
 * Once enhanced reports are enabled, they can't be disabled on PlayStation
 * controllers without power cycling the controller.
 *
 * The variable can be set to the following values:
 *
 * - "0": enhanced reports are not enabled.
 * - "1": enhanced reports are enabled. (default)
 * - "auto": enhanced features are advertised to the application, but SDL
 *   doesn't change the controller report mode unless the application uses
 *   them.
 *
 * This hint can be enabled anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_ENHANCED_REPORTS "SDL_JOYSTICK_ENHANCED_REPORTS"

/**
 * A variable containing a list of flightstick style controllers.
 *
 * The format of the string is a comma separated list of USB VID/PID pairs in
 * hexadecimal form, e.g.
 *
 * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
 *
 * The variable can also take the form of file, in which case the named file
 * will be loaded and interpreted as the value of the variable.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_FLIGHTSTICK_DEVICES "SDL_JOYSTICK_FLIGHTSTICK_DEVICES"

/**
 * A variable containing a list of devices that are not flightstick style
 * controllers.
 *
 * This will override SDL_HINT_JOYSTICK_FLIGHTSTICK_DEVICES and the built in
 * device list.
 *
 * The format of the string is a comma separated list of USB VID/PID pairs in
 * hexadecimal form, e.g.
 *
 * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
 *
 * The variable can also take the form of "@file", in which case the named
 * file will be loaded and interpreted as the value of the variable.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_FLIGHTSTICK_DEVICES_EXCLUDED                         \
  "SDL_JOYSTICK_FLIGHTSTICK_DEVICES_EXCLUDED"

/**
 * A variable controlling whether GameInput should be used for controller
 * handling on Windows.
 *
 * The variable can be set to the following values:
 *
 * - "0": GameInput is not used.
 * - "1": GameInput is used.
 *
 * The default is "1" on GDK platforms, and "0" otherwise.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_GAMEINPUT "SDL_JOYSTICK_GAMEINPUT"

/**
 * A variable containing a list of devices known to have a GameCube form
 * factor.
 *
 * The format of the string is a comma separated list of USB VID/PID pairs in
 * hexadecimal form, e.g.
 *
 * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
 *
 * The variable can also take the form of "@file", in which case the named
 * file will be loaded and interpreted as the value of the variable.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_GAMECUBE_DEVICES "SDL_JOYSTICK_GAMECUBE_DEVICES"

/**
 * A variable containing a list of devices known not to have a GameCube form
 * factor.
 *
 * This will override SDL_HINT_JOYSTICK_GAMECUBE_DEVICES and the built in
 * device list.
 *
 * The format of the string is a comma separated list of USB VID/PID pairs in
 * hexadecimal form, e.g.
 *
 * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
 *
 * The variable can also take the form of "@file", in which case the named
 * file will be loaded and interpreted as the value of the variable.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_GAMECUBE_DEVICES_EXCLUDED                            \
  "SDL_JOYSTICK_GAMECUBE_DEVICES_EXCLUDED"

/**
 * A variable controlling whether the HIDAPI joystick drivers should be used.
 *
 * The variable can be set to the following values:
 *
 * - "0": HIDAPI drivers are not used.
 * - "1": HIDAPI drivers are used. (default)
 *
 * This variable is the default for all drivers, but can be overridden by the
 * hints for specific drivers below.
 *
 * This hint should be set before initializing joysticks and gamepads.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI "SDL_JOYSTICK_HIDAPI"

/**
 * A variable controlling whether Nintendo Switch Joy-Con controllers will be
 * combined into a single Pro-like controller when using the HIDAPI driver.
 *
 * The variable can be set to the following values:
 *
 * - "0": Left and right Joy-Con controllers will not be combined and each
 *   will be a mini-gamepad.
 * - "1": Left and right Joy-Con controllers will be combined into a single
 *   controller. (default)
 *
 * This hint should be set before initializing joysticks and gamepads.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_COMBINE_JOY_CONS                              \
  "SDL_JOYSTICK_HIDAPI_COMBINE_JOY_CONS"

/**
 * A variable controlling whether the HIDAPI driver for Nintendo GameCube
 * controllers should be used.
 *
 * The variable can be set to the following values:
 *
 * - "0": HIDAPI driver is not used.
 * - "1": HIDAPI driver is used.
 *
 * The default is the value of SDL_HINT_JOYSTICK_HIDAPI
 *
 * This hint should be set before initializing joysticks and gamepads.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE "SDL_JOYSTICK_HIDAPI_GAMECUBE"

/**
 * A variable controlling whether rumble is used to implement the GameCube
 * controller's 3 rumble modes, Stop(0), Rumble(1), and StopHard(2).
 *
 * This is useful for applications that need full compatibility for things
 * like ADSR envelopes. - Stop is implemented by setting low_frequency_rumble
 * to 0 and high_frequency_rumble >0 - Rumble is both at any arbitrary value -
 * StopHard is implemented by setting both low_frequency_rumble and
 * high_frequency_rumble to 0
 *
 * The variable can be set to the following values:
 *
 * - "0": Normal rumble behavior is behavior is used. (default)
 * - "1": Proper GameCube controller rumble behavior is used.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE_RUMBLE_BRAKE                         \
  "SDL_JOYSTICK_HIDAPI_GAMECUBE_RUMBLE_BRAKE"

/**
 * A variable controlling whether the HIDAPI driver for Nintendo Switch
 * Joy-Cons should be used.
 *
 * The variable can be set to the following values:
 *
 * - "0": HIDAPI driver is not used.
 * - "1": HIDAPI driver is used.
 *
 * The default is the value of SDL_HINT_JOYSTICK_HIDAPI.
 *
 * This hint should be set before initializing joysticks and gamepads.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_JOY_CONS "SDL_JOYSTICK_HIDAPI_JOY_CONS"

/**
 * A variable controlling whether the Home button LED should be turned on when
 * a Nintendo Switch Joy-Con controller is opened.
 *
 * The variable can be set to the following values:
 *
 * - "0": home button LED is turned off
 * - "1": home button LED is turned on
 *
 * By default the Home button LED state is not changed. This hint can also be
 * set to a floating point value between 0.0 and 1.0 which controls the
 * brightness of the Home button LED.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_JOYCON_HOME_LED                               \
  "SDL_JOYSTICK_HIDAPI_JOYCON_HOME_LED"

/**
 * A variable controlling whether the HIDAPI driver for Amazon Luna
 * controllers connected via Bluetooth should be used.
 *
 * The variable can be set to the following values:
 *
 * - "0": HIDAPI driver is not used.
 * - "1": HIDAPI driver is used.
 *
 * The default is the value of SDL_HINT_JOYSTICK_HIDAPI.
 *
 * This hint should be set before initializing joysticks and gamepads.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_LUNA "SDL_JOYSTICK_HIDAPI_LUNA"

/**
 * A variable controlling whether the HIDAPI driver for Nintendo Online
 * classic controllers should be used.
 *
 * The variable can be set to the following values:
 *
 * - "0": HIDAPI driver is not used.
 * - "1": HIDAPI driver is used.
 *
 * The default is the value of SDL_HINT_JOYSTICK_HIDAPI.
 *
 * This hint should be set before initializing joysticks and gamepads.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_NINTENDO_CLASSIC                              \
  "SDL_JOYSTICK_HIDAPI_NINTENDO_CLASSIC"

/**
 * A variable controlling whether the HIDAPI driver for PS3 controllers should
 * be used.
 *
 * The variable can be set to the following values:
 *
 * - "0": HIDAPI driver is not used.
 * - "1": HIDAPI driver is used.
 *
 * The default is the value of SDL_HINT_JOYSTICK_HIDAPI on macOS, and "0" on
 * other platforms.
 *
 * For official Sony driver (sixaxis.sys) use
 * SDL_HINT_JOYSTICK_HIDAPI_PS3_SIXAXIS_DRIVER. See
 * https://github.com/ViGEm/DsHidMini for an alternative driver on Windows.
 *
 * This hint should be set before initializing joysticks and gamepads.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_PS3 "SDL_JOYSTICK_HIDAPI_PS3"

/**
 * A variable controlling whether the Sony driver (sixaxis.sys) for PS3
 * controllers (Sixaxis/DualShock 3) should be used.
 *
 * The variable can be set to the following values:
 *
 * - "0": Sony driver (sixaxis.sys) is not used.
 * - "1": Sony driver (sixaxis.sys) is used.
 *
 * The default value is 0.
 *
 * This hint should be set before initializing joysticks and gamepads.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_PS3_SIXAXIS_DRIVER                            \
  "SDL_JOYSTICK_HIDAPI_PS3_SIXAXIS_DRIVER"

/**
 * A variable controlling whether the HIDAPI driver for PS4 controllers should
 * be used.
 *
 * The variable can be set to the following values:
 *
 * - "0": HIDAPI driver is not used.
 * - "1": HIDAPI driver is used.
 *
 * The default is the value of SDL_HINT_JOYSTICK_HIDAPI.
 *
 * This hint should be set before initializing joysticks and gamepads.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_PS4 "SDL_JOYSTICK_HIDAPI_PS4"

/**
 * A variable controlling the update rate of the PS4 controller over Bluetooth
 * when using the HIDAPI driver.
 *
 * This defaults to 4 ms, to match the behavior over USB, and to be more
 * friendly to other Bluetooth devices and older Bluetooth hardware on the
 * computer. It can be set to "1" (1000Hz), "2" (500Hz) and "4" (250Hz)
 *
 * This hint can be set anytime, but only takes effect when extended input
 * reports are enabled.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_PS4_REPORT_INTERVAL                           \
  "SDL_JOYSTICK_HIDAPI_PS4_REPORT_INTERVAL"

/**
 * A variable controlling whether the HIDAPI driver for PS5 controllers should
 * be used.
 *
 * The variable can be set to the following values:
 *
 * - "0": HIDAPI driver is not used.
 * - "1": HIDAPI driver is used.
 *
 * The default is the value of SDL_HINT_JOYSTICK_HIDAPI.
 *
 * This hint should be set before initializing joysticks and gamepads.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_PS5 "SDL_JOYSTICK_HIDAPI_PS5"

/**
 * A variable controlling whether the player LEDs should be lit to indicate
 * which player is associated with a PS5 controller.
 *
 * The variable can be set to the following values:
 *
 * - "0": player LEDs are not enabled.
 * - "1": player LEDs are enabled. (default)
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_PS5_PLAYER_LED                                \
  "SDL_JOYSTICK_HIDAPI_PS5_PLAYER_LED"

/**
 * A variable controlling whether the HIDAPI driver for NVIDIA SHIELD
 * controllers should be used.
 *
 * The variable can be set to the following values:
 *
 * - "0": HIDAPI driver is not used.
 * - "1": HIDAPI driver is used.
 *
 * The default is the value of SDL_HINT_JOYSTICK_HIDAPI.
 *
 * This hint should be set before initializing joysticks and gamepads.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_SHIELD "SDL_JOYSTICK_HIDAPI_SHIELD"

/**
 * A variable controlling whether the HIDAPI driver for Google Stadia
 * controllers should be used.
 *
 * The variable can be set to the following values:
 *
 * - "0": HIDAPI driver is not used.
 * - "1": HIDAPI driver is used.
 *
 * The default is the value of SDL_HINT_JOYSTICK_HIDAPI.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_STADIA "SDL_JOYSTICK_HIDAPI_STADIA"

/**
 * A variable controlling whether the HIDAPI driver for Bluetooth Steam
 * Controllers should be used.
 *
 * The variable can be set to the following values:
 *
 * - "0": HIDAPI driver is not used. (default)
 * - "1": HIDAPI driver is used for Steam Controllers, which requires
 *   Bluetooth access and may prompt the user for permission on iOS and
 *   Android.
 *
 * This hint should be set before initializing joysticks and gamepads.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_STEAM "SDL_JOYSTICK_HIDAPI_STEAM"

/**
 * A variable controlling whether the Steam button LED should be turned on
 * when a Steam controller is opened.
 *
 * The variable can be set to the following values:
 *
 * - "0": Steam button LED is turned off.
 * - "1": Steam button LED is turned on.
 *
 * By default the Steam button LED state is not changed. This hint can also be
 * set to a floating point value between 0.0 and 1.0 which controls the
 * brightness of the Steam button LED.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_STEAM_HOME_LED                                \
  "SDL_JOYSTICK_HIDAPI_STEAM_HOME_LED"

/**
 * A variable controlling whether the HIDAPI driver for the Steam Deck builtin
 * controller should be used.
 *
 * The variable can be set to the following values:
 *
 * - "0": HIDAPI driver is not used.
 * - "1": HIDAPI driver is used.
 *
 * The default is the value of SDL_HINT_JOYSTICK_HIDAPI.
 *
 * This hint should be set before initializing joysticks and gamepads.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_STEAMDECK "SDL_JOYSTICK_HIDAPI_STEAMDECK"

/**
 * A variable controlling whether the HIDAPI driver for HORI licensed Steam
 * controllers should be used.
 *
 * This variable can be set to the following values: "0" - HIDAPI driver is
 * not used "1" - HIDAPI driver is used
 *
 * The default is the value of SDL_HINT_JOYSTICK_HIDAPI
 */
#define SDL_HINT_JOYSTICK_HIDAPI_STEAM_HORI "SDL_JOYSTICK_HIDAPI_STEAM_HORI"

/**
 * A variable controlling whether the HIDAPI driver for Nintendo Switch
 * controllers should be used.
 *
 * The variable can be set to the following values:
 *
 * - "0": HIDAPI driver is not used.
 * - "1": HIDAPI driver is used.
 *
 * The default is the value of SDL_HINT_JOYSTICK_HIDAPI.
 *
 * This hint should be set before initializing joysticks and gamepads.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_SWITCH "SDL_JOYSTICK_HIDAPI_SWITCH"

/**
 * A variable controlling whether the Home button LED should be turned on when
 * a Nintendo Switch Pro controller is opened.
 *
 * The variable can be set to the following values:
 *
 * - "0": Home button LED is turned off.
 * - "1": Home button LED is turned on.
 *
 * By default the Home button LED state is not changed. This hint can also be
 * set to a floating point value between 0.0 and 1.0 which controls the
 * brightness of the Home button LED.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_SWITCH_HOME_LED                               \
  "SDL_JOYSTICK_HIDAPI_SWITCH_HOME_LED"

/**
 * A variable controlling whether the player LEDs should be lit to indicate
 * which player is associated with a Nintendo Switch controller.
 *
 * The variable can be set to the following values:
 *
 * - "0": Player LEDs are not enabled.
 * - "1": Player LEDs are enabled. (default)
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_SWITCH_PLAYER_LED                             \
  "SDL_JOYSTICK_HIDAPI_SWITCH_PLAYER_LED"

/**
 * A variable controlling whether Nintendo Switch Joy-Con controllers will be
 * in vertical mode when using the HIDAPI driver.
 *
 * The variable can be set to the following values:
 *
 * - "0": Left and right Joy-Con controllers will not be in vertical mode.
 *   (default)
 * - "1": Left and right Joy-Con controllers will be in vertical mode.
 *
 * This hint should be set before opening a Joy-Con controller.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_VERTICAL_JOY_CONS                             \
  "SDL_JOYSTICK_HIDAPI_VERTICAL_JOY_CONS"

/**
 * A variable controlling whether the HIDAPI driver for Nintendo Wii and Wii U
 * controllers should be used.
 *
 * The variable can be set to the following values:
 *
 * - "0": HIDAPI driver is not used.
 * - "1": HIDAPI driver is used.
 *
 * This driver doesn't work with the dolphinbar, so the default is false for
 * now.
 *
 * This hint should be set before initializing joysticks and gamepads.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_WII "SDL_JOYSTICK_HIDAPI_WII"

/**
 * A variable controlling whether the player LEDs should be lit to indicate
 * which player is associated with a Wii controller.
 *
 * The variable can be set to the following values:
 *
 * - "0": Player LEDs are not enabled.
 * - "1": Player LEDs are enabled. (default)
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_WII_PLAYER_LED                                \
  "SDL_JOYSTICK_HIDAPI_WII_PLAYER_LED"

/**
 * A variable controlling whether the HIDAPI driver for XBox controllers
 * should be used.
 *
 * The variable can be set to the following values:
 *
 * - "0": HIDAPI driver is not used.
 * - "1": HIDAPI driver is used.
 *
 * The default is "0" on Windows, otherwise the value of
 * SDL_HINT_JOYSTICK_HIDAPI
 *
 * This hint should be set before initializing joysticks and gamepads.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_XBOX "SDL_JOYSTICK_HIDAPI_XBOX"

/**
 * A variable controlling whether the HIDAPI driver for XBox 360 controllers
 * should be used.
 *
 * The variable can be set to the following values:
 *
 * - "0": HIDAPI driver is not used.
 * - "1": HIDAPI driver is used.
 *
 * The default is the value of SDL_HINT_JOYSTICK_HIDAPI_XBOX
 *
 * This hint should be set before initializing joysticks and gamepads.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_XBOX_360 "SDL_JOYSTICK_HIDAPI_XBOX_360"

/**
 * A variable controlling whether the player LEDs should be lit to indicate
 * which player is associated with an Xbox 360 controller.
 *
 * The variable can be set to the following values:
 *
 * - "0": Player LEDs are not enabled.
 * - "1": Player LEDs are enabled. (default)
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_XBOX_360_PLAYER_LED                           \
  "SDL_JOYSTICK_HIDAPI_XBOX_360_PLAYER_LED"

/**
 * A variable controlling whether the HIDAPI driver for XBox 360 wireless
 * controllers should be used.
 *
 * The variable can be set to the following values:
 *
 * - "0": HIDAPI driver is not used.
 * - "1": HIDAPI driver is used.
 *
 * The default is the value of SDL_HINT_JOYSTICK_HIDAPI_XBOX_360
 *
 * This hint should be set before initializing joysticks and gamepads.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_XBOX_360_WIRELESS                             \
  "SDL_JOYSTICK_HIDAPI_XBOX_360_WIRELESS"

/**
 * A variable controlling whether the HIDAPI driver for XBox One controllers
 * should be used.
 *
 * The variable can be set to the following values:
 *
 * - "0": HIDAPI driver is not used.
 * - "1": HIDAPI driver is used.
 *
 * The default is the value of SDL_HINT_JOYSTICK_HIDAPI_XBOX.
 *
 * This hint should be set before initializing joysticks and gamepads.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_XBOX_ONE "SDL_JOYSTICK_HIDAPI_XBOX_ONE"

/**
 * A variable controlling whether the Home button LED should be turned on when
 * an Xbox One controller is opened.
 *
 * The variable can be set to the following values:
 *
 * - "0": Home button LED is turned off.
 * - "1": Home button LED is turned on.
 *
 * By default the Home button LED state is not changed. This hint can also be
 * set to a floating point value between 0.0 and 1.0 which controls the
 * brightness of the Home button LED. The default brightness is 0.4.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_HIDAPI_XBOX_ONE_HOME_LED                             \
  "SDL_JOYSTICK_HIDAPI_XBOX_ONE_HOME_LED"

/**
 * A variable controlling whether IOKit should be used for controller
 * handling.
 *
 * The variable can be set to the following values:
 *
 * - "0": IOKit is not used.
 * - "1": IOKit is used. (default)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_IOKIT "SDL_JOYSTICK_IOKIT"

/**
 * A variable controlling whether to use the classic /dev/input/js* joystick
 * interface or the newer /dev/input/event* joystick interface on Linux.
 *
 * The variable can be set to the following values:
 *
 * - "0": Use /dev/input/event* (default)
 * - "1": Use /dev/input/js*
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_LINUX_CLASSIC "SDL_JOYSTICK_LINUX_CLASSIC"

/**
 * A variable controlling whether joysticks on Linux adhere to their
 * HID-defined deadzones or return unfiltered values.
 *
 * The variable can be set to the following values:
 *
 * - "0": Return unfiltered joystick axis values. (default)
 * - "1": Return axis values with deadzones taken into account.
 *
 * This hint should be set before a controller is opened.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_LINUX_DEADZONES "SDL_JOYSTICK_LINUX_DEADZONES"

/**
 * A variable controlling whether joysticks on Linux will always treat 'hat'
 * axis inputs (ABS_HAT0X - ABS_HAT3Y) as 8-way digital hats without checking
 * whether they may be analog.
 *
 * The variable can be set to the following values:
 *
 * - "0": Only map hat axis inputs to digital hat outputs if the input axes
 *   appear to actually be digital. (default)
 * - "1": Always handle the input axes numbered ABS_HAT0X to ABS_HAT3Y as
 *   digital hats.
 *
 * This hint should be set before a controller is opened.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_LINUX_DIGITAL_HATS "SDL_JOYSTICK_LINUX_DIGITAL_HATS"

/**
 * A variable controlling whether digital hats on Linux will apply deadzones
 * to their underlying input axes or use unfiltered values.
 *
 * The variable can be set to the following values:
 *
 * - "0": Return digital hat values based on unfiltered input axis values.
 * - "1": Return digital hat values with deadzones on the input axes taken
 *   into account. (default)
 *
 * This hint should be set before a controller is opened.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_LINUX_HAT_DEADZONES "SDL_JOYSTICK_LINUX_HAT_DEADZONES"

/**
 * A variable controlling whether GCController should be used for controller
 * handling.
 *
 * The variable can be set to the following values:
 *
 * - "0": GCController is not used.
 * - "1": GCController is used. (default)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_MFI "SDL_JOYSTICK_MFI"

/**
 * A variable controlling whether the RAWINPUT joystick drivers should be used
 * for better handling XInput-capable devices.
 *
 * The variable can be set to the following values:
 *
 * - "0": RAWINPUT drivers are not used. (default)
 * - "1": RAWINPUT drivers are used.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_RAWINPUT "SDL_JOYSTICK_RAWINPUT"

/**
 * A variable controlling whether the RAWINPUT driver should pull correlated
 * data from XInput.
 *
 * The variable can be set to the following values:
 *
 * - "0": RAWINPUT driver will only use data from raw input APIs.
 * - "1": RAWINPUT driver will also pull data from XInput and
 *   Windows.Gaming.Input, providing better trigger axes, guide button
 *   presses, and rumble support for Xbox controllers. (default)
 *
 * This hint should be set before a gamepad is opened.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_RAWINPUT_CORRELATE_XINPUT                            \
  "SDL_JOYSTICK_RAWINPUT_CORRELATE_XINPUT"

/**
 * A variable controlling whether the ROG Chakram mice should show up as
 * joysticks.
 *
 * The variable can be set to the following values:
 *
 * - "0": ROG Chakram mice do not show up as joysticks. (default)
 * - "1": ROG Chakram mice show up as joysticks.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_ROG_CHAKRAM "SDL_JOYSTICK_ROG_CHAKRAM"

/**
 * A variable controlling whether a separate thread should be used for
 * handling joystick detection and raw input messages on Windows.
 *
 * The variable can be set to the following values:
 *
 * - "0": A separate thread is not used.
 * - "1": A separate thread is used for handling raw input messages. (default)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_THREAD "SDL_JOYSTICK_THREAD"

/**
 * A variable containing a list of throttle style controllers.
 *
 * The format of the string is a comma separated list of USB VID/PID pairs in
 * hexadecimal form, e.g.
 *
 * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
 *
 * The variable can also take the form of "@file", in which case the named
 * file will be loaded and interpreted as the value of the variable.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_THROTTLE_DEVICES "SDL_JOYSTICK_THROTTLE_DEVICES"

/**
 * A variable containing a list of devices that are not throttle style
 * controllers.
 *
 * This will override SDL_HINT_JOYSTICK_THROTTLE_DEVICES and the built in
 * device list.
 *
 * The format of the string is a comma separated list of USB VID/PID pairs in
 * hexadecimal form, e.g.
 *
 * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
 *
 * The variable can also take the form of "@file", in which case the named
 * file will be loaded and interpreted as the value of the variable.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_THROTTLE_DEVICES_EXCLUDED                            \
  "SDL_JOYSTICK_THROTTLE_DEVICES_EXCLUDED"

/**
 * A variable controlling whether Windows.Gaming.Input should be used for
 * controller handling.
 *
 * The variable can be set to the following values:
 *
 * - "0": WGI is not used. (default)
 * - "1": WGI is used.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_WGI "SDL_JOYSTICK_WGI"

/**
 * A variable containing a list of wheel style controllers.
 *
 * The format of the string is a comma separated list of USB VID/PID pairs in
 * hexadecimal form, e.g.
 *
 * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
 *
 * The variable can also take the form of "@file", in which case the named
 * file will be loaded and interpreted as the value of the variable.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_WHEEL_DEVICES "SDL_JOYSTICK_WHEEL_DEVICES"

/**
 * A variable containing a list of devices that are not wheel style
 * controllers.
 *
 * This will override SDL_HINT_JOYSTICK_WHEEL_DEVICES and the built in device
 * list.
 *
 * The format of the string is a comma separated list of USB VID/PID pairs in
 * hexadecimal form, e.g.
 *
 * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
 *
 * The variable can also take the form of "@file", in which case the named
 * file will be loaded and interpreted as the value of the variable.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_WHEEL_DEVICES_EXCLUDED                               \
  "SDL_JOYSTICK_WHEEL_DEVICES_EXCLUDED"

/**
 * A variable containing a list of devices known to have all axes centered at
 * zero.
 *
 * The format of the string is a comma separated list of USB VID/PID pairs in
 * hexadecimal form, e.g.
 *
 * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
 *
 * The variable can also take the form of "@file", in which case the named
 * file will be loaded and interpreted as the value of the variable.
 *
 * This hint should be set before a controller is opened.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_JOYSTICK_ZERO_CENTERED_DEVICES                                \
  "SDL_JOYSTICK_ZERO_CENTERED_DEVICES"

#if SDL_VERSION_ATLEAST(3, 2, 5)

/**
 * A variable containing a list of devices and their desired number of haptic
 * (force feedback) enabled axis.
 *
 * The format of the string is a comma separated list of USB VID/PID pairs in
 * hexadecimal form plus the number of desired axes, e.g.
 *
 * `0xAAAA/0xBBBB/1,0xCCCC/0xDDDD/3`
 *
 * This hint supports a "wildcard" device that will set the number of haptic
 * axes on all initialized haptic devices which were not defined explicitly in
 * this hint.
 *
 * `0xFFFF/0xFFFF/1`
 *
 * This hint should be set before a controller is opened. The number of haptic
 * axes won't exceed the number of real axes found on the device.
 *
 * @since This hint is available since SDL 3.2.5.
 */
#define SDL_HINT_JOYSTICK_HAPTIC_AXES "SDL_JOYSTICK_HAPTIC_AXES"

#endif // SDL_VERSION_ATLEAST(3, 2, 5)

/**
 * A variable that controls keycode representation in keyboard events.
 *
 * This variable is a comma separated set of options for translating keycodes
 * in events:
 *
 * - "none": Keycode options are cleared, this overrides other options.
 * - "hide_numpad": The numpad keysyms will be translated into their
 *   non-numpad versions based on the current NumLock state. For example,
 *   SDLK_KP_4 would become SDLK_4 if KMOD_NUM is set in the event
 *   modifiers, and SDLK_LEFT if it is unset.
 * - "french_numbers": The number row on French keyboards is inverted, so
 *   pressing the 1 key would yield the keycode SDLK_1, or '1', instead of
 *   SDLK_AMPERSAND, or '&'
 * - "latin_letters": For keyboards using non-Latin letters, such as Russian
 *   or Thai, the letter keys generate keycodes as though it had an en_US
 *   layout. e.g. pressing the key associated with SCANCODE_A on a Russian
 *   keyboard would yield 'a' instead of a Cyrillic letter.
 *
 * The default value for this hint is "french_numbers,latin_letters"
 *
 * Some platforms like Emscripten only provide modified keycodes and the
 * options are not used.
 *
 * These options do not affect the return value of Keycode.Keycode() or
 * Keycode.GetScancode(), they just apply to the keycode included in key
 * events.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_KEYCODE_OPTIONS "SDL_KEYCODE_OPTIONS"

/**
 * A variable that controls what KMSDRM device to use.
 *
 * SDL might open something like "/dev/dri/cardNN" to access KMSDRM
 * functionality, where "NN" is a device index number. SDL makes a guess at
 * the best index to use (usually zero), but the app or user can set this hint
 * to a number between 0 and 99 to force selection.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_KMSDRM_DEVICE_INDEX "SDL_KMSDRM_DEVICE_INDEX"

/**
 * A variable that controls whether SDL requires DRM master access in order to
 * initialize the KMSDRM video backend.
 *
 * The DRM subsystem has a concept of a "DRM master" which is a DRM client
 * that has the ability to set planes, set cursor, etc. When SDL is DRM
 * master, it can draw to the screen using the SDL rendering APIs. Without DRM
 * master, SDL is still able to process input and query attributes of attached
 * displays, but it cannot change display state or draw to the screen
 * directly.
 *
 * In some cases, it can be useful to have the KMSDRM backend even if it
 * cannot be used for rendering. An app may want to use SDL for input
 * processing while using another rendering API (such as an MMAL overlay on
 * Raspberry Pi) or using its own code to render to DRM overlays that SDL
 * doesn't support.
 *
 * The variable can be set to the following values:
 *
 * - "0": SDL will allow usage of the KMSDRM backend without DRM master.
 * - "1": SDL Will require DRM master to use the KMSDRM backend. (default)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_KMSDRM_REQUIRE_DRM_MASTER "SDL_KMSDRM_REQUIRE_DRM_MASTER"

/**
 * A variable controlling the default SDL log levels.
 *
 * This variable is a comma separated set of category=level tokens that define
 * the default logging levels for SDL applications.
 *
 * The category can be a numeric category, one of "app", "error", "assert",
 * "system", "audio", "video", "render", "input", "test", or `*` for any
 * unspecified category.
 *
 * The level can be a numeric level, one of "verbose", "debug", "info",
 * "warn", "error", "critical", or "quiet" to disable that category.
 *
 * You can omit the category if you want to set the logging level for all
 * categories.
 *
 * If this hint isn't set, the default log levels are equivalent to:
 *
 * `app=info,assert=warn,test=verbose,*=error`
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_LOGGING "SDL_LOGGING"

/**
 * A variable controlling whether to force the application to become the
 * foreground process when launched on macOS.
 *
 * The variable can be set to the following values:
 *
 * - "0": The application is brought to the foreground when launched.
 *   (default)
 * - "1": The application may remain in the background when launched.
 *
 * This hint needs to be set before Init().
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_MAC_BACKGROUND_APP "SDL_MAC_BACKGROUND_APP"

/**
 * A variable that determines whether Ctrl+Click should generate a right-click
 * event on macOS.
 *
 * The variable can be set to the following values:
 *
 * - "0": Ctrl+Click does not generate a right mouse button click event.
 *   (default)
 * - "1": Ctrl+Click generated a right mouse button click event.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK                            \
  "SDL_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK"

/**
 * A variable controlling whether dispatching OpenGL context updates should
 * block the dispatching thread until the main thread finishes processing on
 * macOS.
 *
 * The variable can be set to the following values:
 *
 * - "0": Dispatching OpenGL context updates will block the dispatching thread
 *   until the main thread finishes processing. (default)
 * - "1": Dispatching OpenGL context updates will allow the dispatching thread
 *   to continue execution.
 *
 * Generally you want the default, but if you have OpenGL code in a background
 * thread on a Mac, and the main thread hangs because it's waiting for that
 * background thread, but that background thread is also hanging because it's
 * waiting for the main thread to do an update, this might fix your issue.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_MAC_OPENGL_ASYNC_DISPATCH "SDL_MAC_OPENGL_ASYNC_DISPATCH"

/**
 * A variable controlling whether the Option key on macOS should be remapped
 * to act as the Alt key.
 *
 * The variable can be set to the following values:
 *
 * - "none": The Option key is not remapped to Alt. (default)
 * - "only_left": Only the left Option key is remapped to Alt.
 * - "only_right": Only the right Option key is remapped to Alt.
 * - "both": Both Option keys are remapped to Alt.
 *
 * This will prevent the triggering of key compositions that rely on the
 * Option key, but will still send the Alt modifier for keyboard events. In
 * the case that both Alt and Option are pressed, the Option key will be
 * ignored. This is particularly useful for applications like terminal
 * emulators and graphical user interfaces (GUIs) that rely on Alt key
 * functionality for shortcuts or navigation. This does not apply to
 * Keycode.Keycode and only has an effect if IME is enabled.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_MAC_OPTION_AS_ALT "SDL_MAC_OPTION_AS_ALT"

/**
 * A variable controlling whether EVENT_MOUSE_WHEEL event values will have
 * momentum on macOS.
 *
 * The variable can be set to the following values:
 *
 * - "0": The mouse wheel events will have no momentum. (default)
 * - "1": The mouse wheel events will have momentum.
 *
 * This hint needs to be set before Init().
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_MAC_SCROLL_MOMENTUM "SDL_MAC_SCROLL_MOMENTUM"

/**
 * Request SDL_AppIterate() be called at a specific rate.
 *
 * If this is set to a number, it represents Hz, so "60" means try to iterate
 * 60 times per second. "0" means to iterate as fast as possible. Negative
 * values are illegal, but reserved, in case they are useful in a future
 * revision of SDL.
 *
 * There are other strings that have special meaning. If set to "waitevent",
 * SDL_AppIterate will not be called until new event(s) have arrived (and been
 * processed by SDL_AppEvent). This can be useful for apps that are completely
 * idle except in response to input.
 *
 * On some platforms, or if you are using SDL_main instead of SDL_AppIterate,
 * this hint is ignored. When the hint can be used, it is allowed to be
 * changed at any time.
 *
 * This defaults to 0, and specifying nullptr for the hint's value will restore
 * the default.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_MAIN_CALLBACK_RATE "SDL_MAIN_CALLBACK_RATE"

/**
 * A variable controlling whether the mouse is captured while mouse buttons
 * are pressed.
 *
 * The variable can be set to the following values:
 *
 * - "0": The mouse is not captured while mouse buttons are pressed.
 * - "1": The mouse is captured while mouse buttons are pressed.
 *
 * By default the mouse is captured while mouse buttons are pressed so if the
 * mouse is dragged outside the window, the application continues to receive
 * mouse events until the button is released.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_MOUSE_AUTO_CAPTURE "SDL_MOUSE_AUTO_CAPTURE"

/**
 * A variable setting the double click radius, in pixels.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_MOUSE_DOUBLE_CLICK_RADIUS "SDL_MOUSE_DOUBLE_CLICK_RADIUS"

/**
 * A variable setting the double click time, in milliseconds.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_MOUSE_DOUBLE_CLICK_TIME "SDL_MOUSE_DOUBLE_CLICK_TIME"

/**
 * A variable setting which system cursor to use as the default cursor.
 *
 * This should be an integer corresponding to the SystemCursor enum. The
 * default value is zero (SYSTEM_CURSOR_DEFAULT).
 *
 * This hint needs to be set before Init().
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_MOUSE_DEFAULT_SYSTEM_CURSOR "SDL_MOUSE_DEFAULT_SYSTEM_CURSOR"

/**
 * A variable controlling whether warping a hidden mouse cursor will activate
 * relative mouse mode.
 *
 * When this hint is set, the mouse cursor is hidden, and multiple warps to
 * the window center occur within a short time period, SDL will emulate mouse
 * warps using relative mouse mode. This can provide smoother and more
 * reliable mouse motion for some older games, which continuously calculate
 * the distance travelled by the mouse pointer and warp it back to the center
 * of the window, rather than using relative mouse motion.
 *
 * Note that relative mouse mode may have different mouse acceleration
 * behavior than pointer warps.
 *
 * If your application needs to repeatedly warp the hidden mouse cursor at a
 * high-frequency for other purposes, it should disable this hint.
 *
 * The variable can be set to the following values:
 *
 * - "0": Attempts to warp the mouse will always be made.
 * - "1": Some mouse warps will be emulated by forcing relative mouse mode.
 *   (default)
 *
 * If not set, this is automatically enabled unless an application uses
 * relative mouse mode directly.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_MOUSE_EMULATE_WARP_WITH_RELATIVE                              \
  "SDL_MOUSE_EMULATE_WARP_WITH_RELATIVE"

/**
 * Allow mouse click events when clicking to focus an SDL window.
 *
 * The variable can be set to the following values:
 *
 * - "0": Ignore mouse clicks that activate a window. (default)
 * - "1": Generate events for mouse clicks that activate a window.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH "SDL_MOUSE_FOCUS_CLICKTHROUGH"

/**
 * A variable setting the speed scale for mouse motion, in floating point,
 * when the mouse is not in relative mode.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_MOUSE_NORMAL_SPEED_SCALE "SDL_MOUSE_NORMAL_SPEED_SCALE"

/**
 * A variable controlling whether relative mouse mode constrains the mouse to
 * the center of the window.
 *
 * Constraining to the center of the window works better for FPS games and
 * when the application is running over RDP. Constraining to the whole window
 * works better for 2D games and increases the chance that the mouse will be
 * in the correct position when using high DPI mice.
 *
 * The variable can be set to the following values:
 *
 * - "0": Relative mouse mode constrains the mouse to the window.
 * - "1": Relative mouse mode constrains the mouse to the center of the
 *   window. (default)
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_MOUSE_RELATIVE_MODE_CENTER "SDL_MOUSE_RELATIVE_MODE_CENTER"

/**
 * A variable setting the scale for mouse motion, in floating point, when the
 * mouse is in relative mode.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE "SDL_MOUSE_RELATIVE_SPEED_SCALE"

/**
 * A variable controlling whether the system mouse acceleration curve is used
 * for relative mouse motion.
 *
 * The variable can be set to the following values:
 *
 * - "0": Relative mouse motion will be unscaled. (default)
 * - "1": Relative mouse motion will be scaled using the system mouse
 *   acceleration curve.
 *
 * If SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE is set, that will be applied after
 * system speed scale.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_MOUSE_RELATIVE_SYSTEM_SCALE "SDL_MOUSE_RELATIVE_SYSTEM_SCALE"

/**
 * A variable controlling whether a motion event should be generated for mouse
 * warping in relative mode.
 *
 * The variable can be set to the following values:
 *
 * - "0": Warping the mouse will not generate a motion event in relative mode
 * - "1": Warping the mouse will generate a motion event in relative mode
 *
 * By default warping the mouse will not generate motion events in relative
 * mode. This avoids the application having to filter out large relative
 * motion due to warping.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_MOUSE_RELATIVE_WARP_MOTION "SDL_MOUSE_RELATIVE_WARP_MOTION"

/**
 * A variable controlling whether the hardware cursor stays visible when
 * relative mode is active.
 *
 * This variable can be set to the following values:
 *
 * - "0": The cursor will be hidden while relative mode is active (default)
 * - "1": The cursor will remain visible while relative mode is active
 *
 * Note that for systems without raw hardware inputs, relative mode is
 * implemented using warping, so the hardware cursor will visibly warp between
 * frames if this is enabled on those systems.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_MOUSE_RELATIVE_CURSOR_VISIBLE                                 \
  "SDL_MOUSE_RELATIVE_CURSOR_VISIBLE"

/**
 * A variable controlling whether mouse events should generate synthetic touch
 * events.
 *
 * The variable can be set to the following values:
 *
 * - "0": Mouse events will not generate touch events. (default for desktop
 *   platforms)
 * - "1": Mouse events will generate touch events. (default for mobile
 *   platforms, such as Android and iOS)
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_MOUSE_TOUCH_EVENTS "SDL_MOUSE_TOUCH_EVENTS"

/**
 * A variable controlling whether the keyboard should be muted on the console.
 *
 * Normally the keyboard is muted while SDL applications are running so that
 * keyboard input doesn't show up as key strokes on the console. This hint
 * allows you to turn that off for debugging purposes.
 *
 * The variable can be set to the following values:
 *
 * - "0": Allow keystrokes to go through to the console.
 * - "1": Mute keyboard input so it doesn't show up on the console. (default)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_MUTE_CONSOLE_KEYBOARD "SDL_MUTE_CONSOLE_KEYBOARD"

/**
 * Tell SDL not to catch the SIGINT or SIGTERM signals on POSIX platforms.
 *
 * The variable can be set to the following values:
 *
 * - "0": SDL will install a SIGINT and SIGTERM handler, and when it catches a
 *   signal, convert it into an EVENT_QUIT event. (default)
 * - "1": SDL will not install a signal handler at all.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_NO_SIGNAL_HANDLERS "SDL_NO_SIGNAL_HANDLERS"

/**
 * Specify the OpenGL library to load.
 *
 * This hint should be set before creating an OpenGL window or creating an
 * OpenGL context. If this hint isn't set, SDL will choose a reasonable
 * default.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_OPENGL_LIBRARY "SDL_OPENGL_LIBRARY"

/**
 * Specify the EGL library to load.
 *
 * This hint should be set before creating an OpenGL window or creating an
 * OpenGL context. This hint is only considered if SDL is using EGL to manage
 * OpenGL contexts. If this hint isn't set, SDL will choose a reasonable
 * default.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_EGL_LIBRARY "SDL_EGL_LIBRARY"

/**
 * A variable controlling what driver to use for OpenGL ES contexts.
 *
 * On some platforms, currently Windows and X11, OpenGL drivers may support
 * creating contexts with an OpenGL ES profile. By default SDL uses these
 * profiles, when available, otherwise it attempts to load an OpenGL ES
 * library, e.g. that provided by the ANGLE project. This variable controls
 * whether SDL follows this default behaviour or will always load an OpenGL ES
 * library.
 *
 * Circumstances where this is useful include - Testing an app with a
 * particular OpenGL ES implementation, e.g ANGLE, or emulator, e.g. those
 * from ARM, Imagination or Qualcomm. - Resolving OpenGL ES function addresses
 * at link time by linking with the OpenGL ES library instead of querying them
 * at run time with GL_GetProcAddress().
 *
 * Caution: for an application to work with the default behaviour across
 * different OpenGL drivers it must query the OpenGL ES function addresses at
 * run time using GL_GetProcAddress().
 *
 * This variable is ignored on most platforms because OpenGL ES is native or
 * not supported.
 *
 * The variable can be set to the following values:
 *
 * - "0": Use ES profile of OpenGL, if available. (default)
 * - "1": Load OpenGL ES library using the default library names.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_OPENGL_ES_DRIVER "SDL_OPENGL_ES_DRIVER"

/**
 * Mechanism to specify openvr_api library location
 *
 * By default, when using the OpenVR driver, it will search for the API
 * library in the current folder. But, if you wish to use a system API you can
 * specify that by using this hint. This should be the full or relative path
 * to a .dll on Windows or .so on Linux.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_OPENVR_LIBRARY "SDL_OPENVR_LIBRARY"

/**
 * A variable controlling which orientations are allowed on iOS/Android.
 *
 * In some circumstances it is necessary to be able to explicitly control
 * which UI orientations are allowed.
 *
 * This variable is a space delimited list of the following values:
 *
 * - "LandscapeLeft"
 * - "LandscapeRight"
 * - "Portrait"
 * - "PortraitUpsideDown"
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_ORIENTATIONS "SDL_ORIENTATIONS"

/**
 * A variable controlling the use of a sentinel event when polling the event
 * queue.
 *
 * When polling for events, PumpEvents is used to gather new events from
 * devices. If a device keeps producing new events between calls to
 * PumpEvents, a poll loop will become stuck until the new events stop.
 * This is most noticeable when moving a high frequency mouse.
 *
 * The variable can be set to the following values:
 *
 * - "0": Disable poll sentinels.
 * - "1": Enable poll sentinels. (default)
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_POLL_SENTINEL "SDL_POLL_SENTINEL"

/**
 * Override for SDL_GetPreferredLocales().
 *
 * If set, this will be favored over anything the OS might report for the
 * user's preferred locales. Changing this hint at runtime will not generate a
 * EVENT_LOCALE_CHANGED event (but if you can change the hint, you can
 * push your own event, if you want).
 *
 * The format of this hint is a comma-separated list of language and locale,
 * combined with an underscore, as is a common format: "en_GB". Locale is
 * optional: "en". So you might have a list like this: "en_GB,jp,es_PT"
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_PREFERRED_LOCALES "SDL_PREFERRED_LOCALES"

/**
 * A variable that decides whether to send EVENT_QUIT when closing the
 * last window.
 *
 * The variable can be set to the following values:
 *
 * - "0": SDL will not send an EVENT_QUIT event when the last window is
 *   requesting to close. Note that in this case, there are still other
 *   legitimate reasons one might get an EVENT_QUIT event: choosing "Quit"
 *   from the macOS menu bar, sending a SIGINT (ctrl-c) on Unix, etc.
 * - "1": SDL will send a quit event when the last window is requesting to
 *   close. (default)
 *
 * If there is at least one active system tray icon, EVENT_QUIT will
 * instead be sent when both the last window will be closed and the last tray
 * icon will be destroyed.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_QUIT_ON_LAST_WINDOW_CLOSE "SDL_QUIT_ON_LAST_WINDOW_CLOSE"

/**
 * A variable controlling whether the Direct3D device is initialized for
 * thread-safe operations.
 *
 * The variable can be set to the following values:
 *
 * - "0": Thread-safety is not enabled. (default)
 * - "1": Thread-safety is enabled.
 *
 * This hint should be set before creating a renderer.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_RENDER_DIRECT3D_THREADSAFE "SDL_RENDER_DIRECT3D_THREADSAFE"

/**
 * A variable controlling whether to enable Direct3D 11+'s Debug Layer.
 *
 * This variable does not have any effect on the Direct3D 9 based renderer.
 *
 * The variable can be set to the following values:
 *
 * - "0": Disable Debug Layer use. (default)
 * - "1": Enable Debug Layer use.
 *
 * This hint should be set before creating a renderer.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_RENDER_DIRECT3D11_DEBUG "SDL_RENDER_DIRECT3D11_DEBUG"

/**
 * A variable controlling whether to enable Vulkan Validation Layers.
 *
 * This variable can be set to the following values:
 *
 * - "0": Disable Validation Layer use
 * - "1": Enable Validation Layer use
 *
 * By default, SDL does not use Vulkan Validation Layers.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_RENDER_VULKAN_DEBUG "SDL_RENDER_VULKAN_DEBUG"

/**
 * A variable controlling whether to create the GPU device in debug mode.
 *
 * This variable can be set to the following values:
 *
 * - "0": Disable debug mode use (default)
 * - "1": Enable debug mode use
 *
 * This hint should be set before creating a renderer.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_RENDER_GPU_DEBUG "SDL_RENDER_GPU_DEBUG"

/**
 * A variable controlling whether to prefer a low-power GPU on multi-GPU
 * systems.
 *
 * This variable can be set to the following values:
 *
 * - "0": Prefer high-performance GPU (default)
 * - "1": Prefer low-power GPU
 *
 * This hint should be set before creating a renderer.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_RENDER_GPU_LOW_POWER "SDL_RENDER_GPU_LOW_POWER"

/**
 * A variable specifying which render driver to use.
 *
 * If the application doesn't pick a specific renderer to use, this variable
 * specifies the name of the preferred renderer. If the preferred renderer
 * can't be initialized, creating a renderer will fail.
 *
 * This variable is case insensitive and can be set to the following values:
 *
 * - "direct3d"
 * - "direct3d11"
 * - "direct3d12"
 * - "opengl"
 * - "opengles2"
 * - "opengles"
 * - "metal"
 * - "vulkan"
 * - "gpu"
 * - "software"
 *
 * This hint accepts a comma-separated list of driver names, and each will be
 * tried in the order listed when creating a renderer until one succeeds or
 * all of them fail.
 *
 * The default varies by platform, but it's the first one in the list that is
 * available on the current platform.
 *
 * This hint should be set before creating a renderer.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_RENDER_DRIVER "SDL_RENDER_DRIVER"

/**
 * A variable controlling how the 2D render API renders lines.
 *
 * The variable can be set to the following values:
 *
 * - "0": Use the default line drawing method (Bresenham's line algorithm)
 * - "1": Use the driver point API using Bresenham's line algorithm (correct,
 *   draws many points)
 * - "2": Use the driver line API (occasionally misses line endpoints based on
 *   hardware driver quirks
 * - "3": Use the driver geometry API (correct, draws thicker diagonal lines)
 *
 * This hint should be set before creating a renderer.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_RENDER_LINE_METHOD "SDL_RENDER_LINE_METHOD"

/**
 * A variable controlling whether the Metal render driver select low power
 * device over default one.
 *
 * The variable can be set to the following values:
 *
 * - "0": Use the preferred OS device. (default)
 * - "1": Select a low power device.
 *
 * This hint should be set before creating a renderer.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_RENDER_METAL_PREFER_LOW_POWER_DEVICE                          \
  "SDL_RENDER_METAL_PREFER_LOW_POWER_DEVICE"

/**
 * A variable controlling whether updates to the SDL screen surface should be
 * synchronized with the vertical refresh, to avoid tearing.
 *
 * This hint overrides the application preference when creating a renderer.
 *
 * The variable can be set to the following values:
 *
 * - "0": Disable vsync. (default)
 * - "1": Enable vsync.
 *
 * This hint should be set before creating a renderer.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_RENDER_VSYNC "SDL_RENDER_VSYNC"

/**
 * A variable to control whether the return key on the soft keyboard should
 * hide the soft keyboard on Android and iOS.
 *
 * This hint sets the default value of prop::TextInput.MULTILINE_BOOLEAN.
 *
 * The variable can be set to the following values:
 *
 * - "0": The return key will be handled as a key event. (default)
 * - "1": The return key will hide the keyboard.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_RETURN_KEY_HIDES_IME "SDL_RETURN_KEY_HIDES_IME"

/**
 * A variable containing a list of ROG gamepad capable mice.
 *
 * The format of the string is a comma separated list of USB VID/PID pairs in
 * hexadecimal form, e.g.
 *
 * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
 *
 * The variable can also take the form of "@file", in which case the named
 * file will be loaded and interpreted as the value of the variable.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 *
 * @sa SDL_HINT_ROG_GAMEPAD_MICE_EXCLUDED
 */
#define SDL_HINT_ROG_GAMEPAD_MICE "SDL_ROG_GAMEPAD_MICE"

/**
 * A variable containing a list of devices that are not ROG gamepad capable
 * mice.
 *
 * This will override SDL_HINT_ROG_GAMEPAD_MICE and the built in device list.
 *
 * The format of the string is a comma separated list of USB VID/PID pairs in
 * hexadecimal form, e.g.
 *
 * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
 *
 * The variable can also take the form of "@file", in which case the named
 * file will be loaded and interpreted as the value of the variable.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_ROG_GAMEPAD_MICE_EXCLUDED "SDL_ROG_GAMEPAD_MICE_EXCLUDED"

/**
 * A variable controlling which Dispmanx layer to use on a Raspberry PI.
 *
 * Also known as Z-order. The variable can take a negative or positive value.
 * The default is 10000.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_RPI_VIDEO_LAYER "SDL_RPI_VIDEO_LAYER"

/**
 * Specify an "activity name" for screensaver inhibition.
 *
 * Some platforms, notably Linux desktops, list the applications which are
 * inhibiting the screensaver or other power-saving features.
 *
 * This hint lets you specify the "activity name" sent to the OS when
 * DisableScreenSaver() is used (or the screensaver is automatically
 * disabled). The contents of this hint are used when the screensaver is
 * disabled. You should use a string that describes what your program is doing
 * (and, therefore, why the screensaver is disabled). For example, "Playing a
 * game" or "Watching a video".
 *
 * Setting this to "" or leaving it unset will have SDL use a reasonable
 * default: "Playing a game" or something similar.
 *
 * This hint should be set before calling DisableScreenSaver()
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_SCREENSAVER_INHIBIT_ACTIVITY_NAME                             \
  "SDL_SCREENSAVER_INHIBIT_ACTIVITY_NAME"

/**
 * A variable controlling whether SDL calls dbus_shutdown() on quit.
 *
 * This is useful as a debug tool to validate memory leaks, but shouldn't ever
 * be set in production applications, as other libraries used by the
 * application might use dbus under the hood and this can cause crashes if
 * they continue after Quit().
 *
 * The variable can be set to the following values:
 *
 * - "0": SDL will not call dbus_shutdown() on quit. (default)
 * - "1": SDL will call dbus_shutdown() on quit.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_SHUTDOWN_DBUS_ON_QUIT "SDL_SHUTDOWN_DBUS_ON_QUIT"

/**
 * A variable that specifies a backend to use for title storage.
 *
 * By default, SDL will try all available storage backends in a reasonable
 * order until it finds one that can work, but this hint allows the app or
 * user to force a specific target, such as "pc" if, say, you are on Steam but
 * want to avoid SteamRemoteStorage for title data.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_STORAGE_TITLE_DRIVER "SDL_STORAGE_TITLE_DRIVER"

/**
 * A variable that specifies a backend to use for user storage.
 *
 * By default, SDL will try all available storage backends in a reasonable
 * order until it finds one that can work, but this hint allows the app or
 * user to force a specific target, such as "pc" if, say, you are on Steam but
 * want to avoid SteamRemoteStorage for user data.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_STORAGE_USER_DRIVER "SDL_STORAGE_USER_DRIVER"

/**
 * Specifies whether SDL_THREAD_PRIORITY_TIME_CRITICAL should be treated as
 * realtime.
 *
 * On some platforms, like Linux, a realtime priority thread may be subject to
 * restrictions that require special handling by the application. This hint
 * exists to let SDL know that the app is prepared to handle said
 * restrictions.
 *
 * On Linux, SDL will apply the following configuration to any thread that
 * becomes realtime:
 *
 * - The SCHED_RESET_ON_FORK bit will be set on the scheduling policy,
 * - An RLIMIT_RTTIME budget will be configured to the rtkit specified limit.
 * - Exceeding this limit will result in the kernel sending SIGKILL to the
 *   app, refer to the man pages for more information.
 *
 * The variable can be set to the following values:
 *
 * - "0": default platform specific behaviour
 * - "1": Force SDL_THREAD_PRIORITY_TIME_CRITICAL to a realtime scheduling
 *   policy
 *
 * This hint should be set before calling SDL_SetCurrentThreadPriority()
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_THREAD_FORCE_REALTIME_TIME_CRITICAL                           \
  "SDL_THREAD_FORCE_REALTIME_TIME_CRITICAL"

/**
 * A string specifying additional information to use with
 * SDL_SetCurrentThreadPriority.
 *
 * By default SDL_SetCurrentThreadPriority will make appropriate system
 * changes in order to apply a thread priority. For example on systems using
 * pthreads the scheduler policy is changed automatically to a policy that
 * works well with a given priority. Code which has specific requirements can
 * override SDL's default behavior with this hint.
 *
 * pthread hint values are "current", "other", "fifo" and "rr". Currently no
 * other platform hint values are defined but may be in the future.
 *
 * On Linux, the kernel may send SIGKILL to realtime tasks which exceed the
 * distro configured execution budget for rtkit. This budget can be queried
 * through RLIMIT_RTTIME after calling SDL_SetCurrentThreadPriority().
 *
 * This hint should be set before calling SDL_SetCurrentThreadPriority()
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_THREAD_PRIORITY_POLICY "SDL_THREAD_PRIORITY_POLICY"

/**
 * A variable that controls the timer resolution, in milliseconds.
 *
 * The higher resolution the timer, the more frequently the CPU services timer
 * interrupts, and the more precise delays are, but this takes up power and
 * CPU time. This hint is only used on Windows.
 *
 * See this blog post for more information:
 * http://randomascii.wordpress.com/2013/07/08/windows-timer-resolution-megawatts-wasted/
 *
 * The default value is "1".
 *
 * If this variable is set to "0", the system timer resolution is not set.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_TIMER_RESOLUTION "SDL_TIMER_RESOLUTION"

/**
 * A variable controlling whether touch events should generate synthetic mouse
 * events.
 *
 * The variable can be set to the following values:
 *
 * - "0": Touch events will not generate mouse events.
 * - "1": Touch events will generate mouse events. (default)
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_TOUCH_MOUSE_EVENTS "SDL_TOUCH_MOUSE_EVENTS"

/**
 * A variable controlling whether trackpads should be treated as touch
 * devices.
 *
 * On macOS (and possibly other platforms in the future), SDL will report
 * touches on a trackpad as mouse input, which is generally what users expect
 * from this device; however, these are often actually full multitouch-capable
 * touch devices, so it might be preferable to some apps to treat them as
 * such.
 *
 * The variable can be set to the following values:
 *
 * - "0": Trackpad will send mouse events. (default)
 * - "1": Trackpad will send touch events.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_TRACKPAD_IS_TOUCH_ONLY "SDL_TRACKPAD_IS_TOUCH_ONLY"

/**
 * A variable controlling whether the Android / tvOS remotes should be listed
 * as joystick devices, instead of sending keyboard events.
 *
 * The variable can be set to the following values:
 *
 * - "0": Remotes send enter/escape/arrow key events.
 * - "1": Remotes are available as 2 axis, 2 button joysticks. (default)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_TV_REMOTE_AS_JOYSTICK "SDL_TV_REMOTE_AS_JOYSTICK"

/**
 * A variable controlling whether the screensaver is enabled.
 *
 * The variable can be set to the following values:
 *
 * - "0": Disable screensaver. (default)
 * - "1": Enable screensaver.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_ALLOW_SCREENSAVER "SDL_VIDEO_ALLOW_SCREENSAVER"

/**
 * A comma separated list containing the names of the displays that SDL should
 * sort to the front of the display list.
 *
 * When this hint is set, displays with matching name strings will be
 * prioritized in the list of displays, as exposed by calling
 * Display.GetAll(), with the first listed becoming the primary display. The
 * naming convention can vary depending on the environment, but it is usually
 * a connector name (e.g. 'DP-1', 'DP-2', 'HDMI-A-1',etc...).
 *
 * On Wayland and X11 desktops, the connector names associated with displays
 * can typically be found by using the `xrandr` utility.
 *
 * This hint is currently supported on the following drivers:
 *
 * - KMSDRM (kmsdrm)
 * - Wayland (wayland)
 * - X11 (x11)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_DISPLAY_PRIORITY "SDL_VIDEO_DISPLAY_PRIORITY"

/**
 * Tell the video driver that we only want a double buffer.
 *
 * By default, most lowlevel 2D APIs will use a triple buffer scheme that
 * wastes no CPU time on waiting for vsync after issuing a flip, but
 * introduces a frame of latency. On the other hand, using a double buffer
 * scheme instead is recommended for cases where low latency is an important
 * factor because we save a whole frame of latency.
 *
 * We do so by waiting for vsync immediately after issuing a flip, usually
 * just after eglSwapBuffers call in the backend's *_SwapWindow function.
 *
 * This hint is currently supported on the following drivers:
 *
 * - Raspberry Pi (raspberrypi)
 * - Wayland (wayland)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_DOUBLE_BUFFER "SDL_VIDEO_DOUBLE_BUFFER"

/**
 * A variable that specifies a video backend to use.
 *
 * By default, SDL will try all available video backends in a reasonable order
 * until it finds one that can work, but this hint allows the app or user to
 * force a specific target, such as "x11" if, say, you are on Wayland but want
 * to try talking to the X server instead.
 *
 * This hint accepts a comma-separated list of driver names, and each will be
 * tried in the order listed during init, until one succeeds or all of them
 * fail.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_DRIVER "SDL_VIDEO_DRIVER"

/**
 * A variable controlling whether the dummy video driver saves output frames.
 *
 * - "0": Video frames are not saved to disk. (default)
 * - "1": Video frames are saved to files in the format "SDL_windowX-Y.bmp",
 *   where X is the window ID, and Y is the frame number.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_DUMMY_SAVE_FRAMES "SDL_VIDEO_DUMMY_SAVE_FRAMES"

/**
 * If eglGetPlatformDisplay fails, fall back to calling eglGetDisplay.
 *
 * The variable can be set to one of the following values:
 *
 * - "0": Do not fall back to eglGetDisplay.
 * - "1": Fall back to eglGetDisplay if eglGetPlatformDisplay fails. (default)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_EGL_ALLOW_GETDISPLAY_FALLBACK                           \
  "SDL_VIDEO_EGL_ALLOW_GETDISPLAY_FALLBACK"

/**
 * A variable controlling whether the OpenGL context should be created with
 * EGL.
 *
 * The variable can be set to the following values:
 *
 * - "0": Use platform-specific GL context creation API (GLX, WGL, CGL, etc).
 *   (default)
 * - "1": Use EGL
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_FORCE_EGL "SDL_VIDEO_FORCE_EGL"

/**
 * A variable that specifies the policy for fullscreen Spaces on macOS.
 *
 * The variable can be set to the following values:
 *
 * - "0": Disable Spaces support (FULLSCREEN_DESKTOP won't use them and
 *   WINDOW_RESIZABLE windows won't offer the "fullscreen" button on their
 *   titlebars).
 * - "1": Enable Spaces support (FULLSCREEN_DESKTOP will use them and
 *   WINDOW_RESIZABLE windows will offer the "fullscreen" button on their
 *   titlebars). (default)
 *
 * This hint should be set before creating a window.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES "SDL_VIDEO_MAC_FULLSCREEN_SPACES"

/**
 * A variable that specifies the menu visibility when a window is fullscreen
 * in Spaces on macOS.
 *
 * The variable can be set to the following values:
 *
 * - "0": The menu will be hidden when the window is in a fullscreen space,
 *   and not accessible by moving the mouse to the top of the screen.
 * - "1": The menu will be accessible when the window is in a fullscreen
 *   space.
 * - "auto": The menu will be hidden if fullscreen mode was toggled on
 *   programmatically via `Window.SetFullscreen()`, and accessible if
 *   fullscreen was entered via the "fullscreen" button on the window title
 *   bar. (default)
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_MAC_FULLSCREEN_MENU_VISIBILITY                          \
  "SDL_VIDEO_MAC_FULLSCREEN_MENU_VISIBILITY"

/**
 * A variable controlling whether fullscreen windows are minimized when they
 * lose focus.
 *
 * The variable can be set to the following values:
 *
 * - "0": Fullscreen windows will not be minimized when they lose focus.
 *   (default)
 * - "1": Fullscreen windows are minimized when they lose focus.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS "SDL_VIDEO_MINIMIZE_ON_FOCUS_LOSS"

/**
 * A variable controlling whether the offscreen video driver saves output
 * frames.
 *
 * This only saves frames that are generated using software rendering, not
 * accelerated OpenGL rendering.
 *
 * - "0": Video frames are not saved to disk. (default)
 * - "1": Video frames are saved to files in the format "SDL_windowX-Y.bmp",
 *   where X is the window ID, and Y is the frame number.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_OFFSCREEN_SAVE_FRAMES "SDL_VIDEO_OFFSCREEN_SAVE_FRAMES"

/**
 * A variable controlling whether all window operations will block until
 * complete.
 *
 * Window systems that run asynchronously may not have the results of window
 * operations that resize or move the window applied immediately upon the
 * return of the requesting function. Setting this hint will cause such
 * operations to block after every call until the pending operation has
 * completed. Setting this to '1' is the equivalent of calling
 * Window.Sync() after every function call.
 *
 * Be aware that amount of time spent blocking while waiting for window
 * operations to complete can be quite lengthy, as animations may have to
 * complete, which can take upwards of multiple seconds in some cases.
 *
 * The variable can be set to the following values:
 *
 * - "0": Window operations are non-blocking. (default)
 * - "1": Window operations will block until completed.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_SYNC_WINDOW_OPERATIONS "SDL_VIDEO_SYNC_WINDOW_OPERATIONS"

/**
 * A variable controlling whether the libdecor Wayland backend is allowed to
 * be used.
 *
 * libdecor is used over xdg-shell when xdg-decoration protocol is
 * unavailable.
 *
 * The variable can be set to the following values:
 *
 * - "0": libdecor use is disabled.
 * - "1": libdecor use is enabled. (default)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_WAYLAND_ALLOW_LIBDECOR "SDL_VIDEO_WAYLAND_ALLOW_LIBDECOR"

/**
 * A variable controlling whether video mode emulation is enabled under
 * Wayland.
 *
 * When this hint is set, a standard set of emulated CVT video modes will be
 * exposed for use by the application. If it is disabled, the only modes
 * exposed will be the logical desktop size and, in the case of a scaled
 * desktop, the native display resolution.
 *
 * The variable can be set to the following values:
 *
 * - "0": Video mode emulation is disabled.
 * - "1": Video mode emulation is enabled. (default)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_WAYLAND_MODE_EMULATION "SDL_VIDEO_WAYLAND_MODE_EMULATION"

/**
 * A variable controlling how modes with a non-native aspect ratio are
 * displayed under Wayland.
 *
 * When this hint is set, the requested scaling will be used when displaying
 * fullscreen video modes that don't match the display's native aspect ratio.
 * This is contingent on compositor viewport support.
 *
 * The variable can be set to the following values:
 *
 * - "aspect" - Video modes will be displayed scaled, in their proper aspect
 *   ratio, with black bars.
 * - "stretch" - Video modes will be scaled to fill the entire display.
 *   (default)
 * - "none" - Video modes will be displayed as 1:1 with no scaling.
 *
 * This hint should be set before creating a window.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_WAYLAND_MODE_SCALING "SDL_VIDEO_WAYLAND_MODE_SCALING"

/**
 * A variable controlling whether the libdecor Wayland backend is preferred
 * over native decorations.
 *
 * When this hint is set, libdecor will be used to provide window decorations,
 * even if xdg-decoration is available. (Note that, by default, libdecor will
 * use xdg-decoration itself if available).
 *
 * The variable can be set to the following values:
 *
 * - "0": libdecor is enabled only if server-side decorations are unavailable.
 *   (default)
 * - "1": libdecor is always enabled if available.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_WAYLAND_PREFER_LIBDECOR                                 \
  "SDL_VIDEO_WAYLAND_PREFER_LIBDECOR"

/**
 * A variable forcing non-DPI-aware Wayland windows to output at 1:1 scaling.
 *
 * This must be set before initializing the video subsystem.
 *
 * When this hint is set, Wayland windows that are not flagged as being
 * DPI-aware will be output with scaling designed to force 1:1 pixel mapping.
 *
 * This is intended to allow legacy applications to be displayed without
 * desktop scaling being applied, and has issues with certain display
 * configurations, as this forces the window to behave in a way that Wayland
 * desktops were not designed to accommodate:
 *
 * - Rounding errors can result with odd window sizes and/or desktop scales,
 *   which can cause the window contents to appear slightly blurry.
 * - Positioning the window may be imprecise due to unit conversions and
 *   rounding.
 * - The window may be unusably small on scaled desktops.
 * - The window may jump in size when moving between displays of different
 *   scale factors.
 * - Displays may appear to overlap when using a multi-monitor setup with
 *   scaling enabled.
 * - Possible loss of cursor precision due to the logical size of the window
 *   being reduced.
 *
 * New applications should be designed with proper DPI awareness handling
 * instead of enabling this.
 *
 * The variable can be set to the following values:
 *
 * - "0": Windows will be scaled normally.
 * - "1": Windows will be forced to scale to achieve 1:1 output.
 *
 * This hint should be set before creating a window.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_WAYLAND_SCALE_TO_DISPLAY                                \
  "SDL_VIDEO_WAYLAND_SCALE_TO_DISPLAY"

/**
 * A variable specifying which shader compiler to preload when using the
 * Chrome ANGLE binaries.
 *
 * SDL has EGL and OpenGL ES2 support on Windows via the ANGLE project. It can
 * use two different sets of binaries, those compiled by the user from source
 * or those provided by the Chrome browser. In the later case, these binaries
 * require that SDL loads a DLL providing the shader compiler.
 *
 * The variable can be set to the following values:
 *
 * - "d3dcompiler_46.dll" - best for Vista or later. (default)
 * - "d3dcompiler_43.dll" - for XP support.
 * - "none" - do not load any library, useful if you compiled ANGLE from
 *   source and included the compiler in your binaries.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_WIN_D3DCOMPILER "SDL_VIDEO_WIN_D3DCOMPILER"

#if SDL_VERSION_ATLEAST(3, 2, 10)

/**
 * A variable controlling whether SDL should call XSelectInput() to enable
 * input events on X11 windows wrapped by SDL windows.
 *
 * The variable can be set to the following values:
 *
 * - "0": Don't call XSelectInput(), assuming the native window code has done
 *   it already.
 * - "1": Call XSelectInput() to enable input events. (default)
 *
 * This hint should be set before creating a window.
 *
 * @since This hint is available since SDL 3.2.10.
 */
#define SDL_HINT_VIDEO_X11_EXTERNAL_WINDOW_INPUT                               \
  "SDL_VIDEO_X11_EXTERNAL_WINDOW_INPUT"

#endif // SDL_VERSION_ATLEAST(3, 2, 10)

/**
 * A variable controlling whether the X11 _NET_WM_BYPASS_COMPOSITOR hint
 * should be used.
 *
 * The variable can be set to the following values:
 *
 * - "0": Disable _NET_WM_BYPASS_COMPOSITOR.
 * - "1": Enable _NET_WM_BYPASS_COMPOSITOR. (default)
 *
 * This hint should be set before creating a window.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR                            \
  "SDL_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR"

/**
 * A variable controlling whether the X11 _NET_WM_PING protocol should be
 * supported.
 *
 * By default SDL will use _NET_WM_PING, but for applications that know they
 * will not always be able to respond to ping requests in a timely manner they
 * can turn it off to avoid the window manager thinking the app is hung.
 *
 * The variable can be set to the following values:
 *
 * - "0": Disable _NET_WM_PING.
 * - "1": Enable _NET_WM_PING. (default)
 *
 * This hint should be set before creating a window.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_X11_NET_WM_PING "SDL_VIDEO_X11_NET_WM_PING"

/**
 * A variable controlling whether SDL uses DirectColor visuals.
 *
 * The variable can be set to the following values:
 *
 * - "0": Disable DirectColor visuals.
 * - "1": Enable DirectColor visuals. (default)
 *
 * This hint should be set before initializing the video subsystem.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_X11_NODIRECTCOLOR "SDL_VIDEO_X11_NODIRECTCOLOR"

/**
 * A variable forcing the content scaling factor for X11 displays.
 *
 * The variable can be set to a floating point value in the range 1.0-10.0f
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_X11_SCALING_FACTOR "SDL_VIDEO_X11_SCALING_FACTOR"

/**
 * A variable forcing the visual ID used for X11 display modes.
 *
 * This hint should be set before initializing the video subsystem.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_X11_VISUALID "SDL_VIDEO_X11_VISUALID"

/**
 * A variable forcing the visual ID chosen for new X11 windows.
 *
 * This hint should be set before creating a window.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_X11_WINDOW_VISUALID "SDL_VIDEO_X11_WINDOW_VISUALID"

/**
 * A variable controlling whether the X11 XRandR extension should be used.
 *
 * The variable can be set to the following values:
 *
 * - "0": Disable XRandR.
 * - "1": Enable XRandR. (default)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VIDEO_X11_XRANDR "SDL_VIDEO_X11_XRANDR"

/**
 * A variable controlling whether touch should be enabled on the back panel of
 * the PlayStation Vita.
 *
 * The variable can be set to the following values:
 *
 * - "0": Disable touch on the back panel.
 * - "1": Enable touch on the back panel. (default)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VITA_ENABLE_BACK_TOUCH "SDL_VITA_ENABLE_BACK_TOUCH"

/**
 * A variable controlling whether touch should be enabled on the front panel
 * of the PlayStation Vita.
 *
 * The variable can be set to the following values:
 *
 * - "0": Disable touch on the front panel.
 * - "1": Enable touch on the front panel. (default)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VITA_ENABLE_FRONT_TOUCH "SDL_VITA_ENABLE_FRONT_TOUCH"

/**
 * A variable controlling the module path on the PlayStation Vita.
 *
 * This hint defaults to "app0:module"
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VITA_MODULE_PATH "SDL_VITA_MODULE_PATH"

/**
 * A variable controlling whether to perform PVR initialization on the
 * PlayStation Vita.
 *
 * - "0": Skip PVR initialization.
 * - "1": Perform the normal PVR initialization. (default)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VITA_PVR_INIT "SDL_VITA_PVR_INIT"

/**
 * A variable overriding the resolution reported on the PlayStation Vita.
 *
 * The variable can be set to the following values:
 *
 * - "544": 544p (default)
 * - "720": 725p for PSTV
 * - "1080": 1088i for PSTV
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VITA_RESOLUTION "SDL_VITA_RESOLUTION"

/**
 * A variable controlling whether OpenGL should be used instead of OpenGL ES
 * on the PlayStation Vita.
 *
 * The variable can be set to the following values:
 *
 * - "0": Use OpenGL ES. (default)
 * - "1": Use OpenGL.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VITA_PVR_OPENGL "SDL_VITA_PVR_OPENGL"

/**
 * A variable controlling which touchpad should generate synthetic mouse
 * events.
 *
 * The variable can be set to the following values:
 *
 * - "0": Only front touchpad should generate mouse events. (default)
 * - "1": Only back touchpad should generate mouse events.
 * - "2": Both touchpads should generate mouse events.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VITA_TOUCH_MOUSE_DEVICE "SDL_VITA_TOUCH_MOUSE_DEVICE"

/**
 * A variable overriding the display index used in SDL_Vulkan_CreateSurface()
 *
 * The display index starts at 0, which is the default.
 *
 * This hint should be set before calling SDL_Vulkan_CreateSurface()
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VULKAN_DISPLAY "SDL_VULKAN_DISPLAY"

/**
 * Specify the Vulkan library to load.
 *
 * This hint should be set before creating a Vulkan window or calling
 * SDL_Vulkan_LoadLibrary().
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_VULKAN_LIBRARY "SDL_VULKAN_LIBRARY"

/**
 * A variable controlling how the fact chunk affects the loading of a WAVE
 * file.
 *
 * The fact chunk stores information about the number of samples of a WAVE
 * file. The Standards Update from Microsoft notes that this value can be used
 * to 'determine the length of the data in seconds'. This is especially useful
 * for compressed formats (for which this is a mandatory chunk) if they
 * produce multiple sample frames per block and truncating the block is not
 * allowed. The fact chunk can exactly specify how many sample frames there
 * should be in this case.
 *
 * Unfortunately, most application seem to ignore the fact chunk and so SDL
 * ignores it by default as well.
 *
 * The variable can be set to the following values:
 *
 * - "truncate" - Use the number of samples to truncate the wave data if the
 *   fact chunk is present and valid.
 * - "strict" - Like "truncate", but raise an error if the fact chunk is
 *   invalid, not present for non-PCM formats, or if the data chunk doesn't
 *   have that many samples.
 * - "ignorezero" - Like "truncate", but ignore fact chunk if the number of
 *   samples is zero.
 * - "ignore" - Ignore fact chunk entirely. (default)
 *
 * This hint should be set before calling LoadWAV() or LoadWAV()
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_WAVE_FACT_CHUNK "SDL_WAVE_FACT_CHUNK"

/**
 * A variable controlling the maximum number of chunks in a WAVE file.
 *
 * This sets an upper bound on the number of chunks in a WAVE file to avoid
 * wasting time on malformed or corrupt WAVE files. This defaults to "10000".
 *
 * This hint should be set before calling LoadWAV() or LoadWAV()
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_WAVE_CHUNK_LIMIT "SDL_WAVE_CHUNK_LIMIT"

/**
 * A variable controlling how the size of the RIFF chunk affects the loading
 * of a WAVE file.
 *
 * The size of the RIFF chunk (which includes all the sub-chunks of the WAVE
 * file) is not always reliable. In case the size is wrong, it's possible to
 * just ignore it and step through the chunks until a fixed limit is reached.
 *
 * Note that files that have trailing data unrelated to the WAVE file or
 * corrupt files may slow down the loading process without a reliable
 * boundary. By default, SDL stops after 10000 chunks to prevent wasting time.
 * Use SDL_HINT_WAVE_CHUNK_LIMIT to adjust this value.
 *
 * The variable can be set to the following values:
 *
 * - "force" - Always use the RIFF chunk size as a boundary for the chunk
 *   search.
 * - "ignorezero" - Like "force", but a zero size searches up to 4 GiB.
 *   (default)
 * - "ignore" - Ignore the RIFF chunk size and always search up to 4 GiB.
 * - "maximum" - Search for chunks until the end of file. (not recommended)
 *
 * This hint should be set before calling LoadWAV() or LoadWAV()
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_WAVE_RIFF_CHUNK_SIZE "SDL_WAVE_RIFF_CHUNK_SIZE"

/**
 * A variable controlling how a truncated WAVE file is handled.
 *
 * A WAVE file is considered truncated if any of the chunks are incomplete or
 * the data chunk size is not a multiple of the block size. By default, SDL
 * decodes until the first incomplete block, as most applications seem to do.
 *
 * The variable can be set to the following values:
 *
 * - "verystrict" - Raise an error if the file is truncated.
 * - "strict" - Like "verystrict", but the size of the RIFF chunk is ignored.
 * - "dropframe" - Decode until the first incomplete sample frame.
 * - "dropblock" - Decode until the first incomplete block. (default)
 *
 * This hint should be set before calling LoadWAV() or LoadWAV()
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_WAVE_TRUNCATION "SDL_WAVE_TRUNCATION"

/**
 * A variable controlling whether the window is activated when the
 * Window.Raise function is called.
 *
 * The variable can be set to the following values:
 *
 * - "0": The window is not activated when the Window.Raise function is
 *   called.
 * - "1": The window is activated when the Window.Raise function is called.
 *   (default)
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_WINDOW_ACTIVATE_WHEN_RAISED "SDL_WINDOW_ACTIVATE_WHEN_RAISED"

/**
 * A variable controlling whether the window is activated when the
 * Window.Show function is called.
 *
 * The variable can be set to the following values:
 *
 * - "0": The window is not activated when the Window.Show function is
 *   called.
 * - "1": The window is activated when the Window.Show function is called.
 *   (default)
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_WINDOW_ACTIVATE_WHEN_SHOWN "SDL_WINDOW_ACTIVATE_WHEN_SHOWN"

/**
 * If set to "0" then never set the top-most flag on an SDL Window even if the
 * application requests it.
 *
 * This is a debugging aid for developers and not expected to be used by end
 * users.
 *
 * The variable can be set to the following values:
 *
 * - "0": don't allow topmost
 * - "1": allow topmost (default)
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_WINDOW_ALLOW_TOPMOST "SDL_WINDOW_ALLOW_TOPMOST"

/**
 * A variable controlling whether the window frame and title bar are
 * interactive when the cursor is hidden.
 *
 * The variable can be set to the following values:
 *
 * - "0": The window frame is not interactive when the cursor is hidden (no
 *   move, resize, etc).
 * - "1": The window frame is interactive when the cursor is hidden. (default)
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN                       \
  "SDL_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN"

/**
 * A variable controlling whether SDL generates window-close events for Alt+F4
 * on Windows.
 *
 * The variable can be set to the following values:
 *
 * - "0": SDL will only do normal key handling for Alt+F4.
 * - "1": SDL will generate a window-close event when it sees Alt+F4.
 *   (default)
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_WINDOWS_CLOSE_ON_ALT_F4 "SDL_WINDOWS_CLOSE_ON_ALT_F4"

/**
 * A variable controlling whether menus can be opened with their keyboard
 * shortcut (Alt+mnemonic).
 *
 * If the mnemonics are enabled, then menus can be opened by pressing the Alt
 * key and the corresponding mnemonic (for example, Alt+F opens the File
 * menu). However, in case an invalid mnemonic is pressed, Windows makes an
 * audible beep to convey that nothing happened. This is true even if the
 * window has no menu at all!
 *
 * Because most SDL applications don't have menus, and some want to use the
 * Alt key for other purposes, SDL disables mnemonics (and the beeping) by
 * default.
 *
 * Note: This also affects keyboard events: with mnemonics enabled, when a
 * menu is opened from the keyboard, you will not receive a KEYUP event for
 * the mnemonic key, and *might* not receive one for Alt.
 *
 * The variable can be set to the following values:
 *
 * - "0": Alt+mnemonic does nothing, no beeping. (default)
 * - "1": Alt+mnemonic opens menus, invalid mnemonics produce a beep.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_WINDOWS_ENABLE_MENU_MNEMONICS                                 \
  "SDL_WINDOWS_ENABLE_MENU_MNEMONICS"

/**
 * A variable controlling whether the windows message loop is processed by
 * SDL.
 *
 * The variable can be set to the following values:
 *
 * - "0": The window message loop is not run.
 * - "1": The window message loop is processed in PumpEvents(). (default)
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP "SDL_WINDOWS_ENABLE_MESSAGELOOP"

/**
 * A variable controlling whether GameInput is used for raw keyboard and mouse
 * on Windows.
 *
 * The variable can be set to the following values:
 *
 * - "0": GameInput is not used for raw keyboard and mouse events.
 * - "1": GameInput is used for raw keyboard and mouse events, if available.
 *   (default)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_WINDOWS_GAMEINPUT "SDL_WINDOWS_GAMEINPUT"

/**
 * A variable controlling whether raw keyboard events are used on Windows.
 *
 * The variable can be set to the following values:
 *
 * - "0": The Windows message loop is used for keyboard events. (default)
 * - "1": Low latency raw keyboard events are used.
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_WINDOWS_RAW_KEYBOARD "SDL_WINDOWS_RAW_KEYBOARD"

/**
 * A variable controlling whether SDL uses Kernel Semaphores on Windows.
 *
 * Kernel Semaphores are inter-process and require a context switch on every
 * interaction. On Windows 8 and newer, the WaitOnAddress API is available.
 * Using that and atomics to implement semaphores increases performance. SDL
 * will fall back to Kernel Objects on older OS versions or if forced to by
 * this hint.
 *
 * The variable can be set to the following values:
 *
 * - "0": Use Atomics and WaitOnAddress API when available, otherwise fall
 *   back to Kernel Objects. (default)
 * - "1": Force the use of Kernel Objects in all cases.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_WINDOWS_FORCE_SEMAPHORE_KERNEL                                \
  "SDL_WINDOWS_FORCE_SEMAPHORE_KERNEL"

/**
 * A variable to specify custom icon resource id from RC file on Windows
 * platform.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_WINDOWS_INTRESOURCE_ICON "SDL_WINDOWS_INTRESOURCE_ICON"

/**
 * A variable to specify custom icon resource id from RC file on Windows
 * platform.
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_WINDOWS_INTRESOURCE_ICON_SMALL                                \
  "SDL_WINDOWS_INTRESOURCE_ICON_SMALL"

/**
 * A variable controlling whether SDL uses the D3D9Ex API introduced in
 * Windows Vista, instead of normal D3D9.
 *
 * Direct3D 9Ex contains changes to state management that can eliminate device
 * loss errors during scenarios like Alt+Tab or UAC prompts. D3D9Ex may
 * require some changes to your application to cope with the new behavior, so
 * this is disabled by default.
 *
 * For more information on Direct3D 9Ex, see:
 *
 * -
 * https://docs.microsoft.com/en-us/windows/win32/direct3darticles/graphics-apis-in-windows-vista#direct3d-9ex
 * -
 * https://docs.microsoft.com/en-us/windows/win32/direct3darticles/direct3d-9ex-improvements
 *
 * The variable can be set to the following values:
 *
 * - "0": Use the original Direct3D 9 API. (default)
 * - "1": Use the Direct3D 9Ex API on Vista and later (and fall back if D3D9Ex
 *   is unavailable)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_WINDOWS_USE_D3D9EX "SDL_WINDOWS_USE_D3D9EX"

/**
 * A variable controlling whether SDL will clear the window contents when the
 * WM_ERASEBKGND message is received.
 *
 * The variable can be set to the following values:
 *
 * - "0"/"never": Never clear the window.
 * - "1"/"initial": Clear the window when the first WM_ERASEBKGND event fires.
 *   (default)
 * - "2"/"always": Clear the window on every WM_ERASEBKGND event.
 *
 * This hint should be set before creating a window.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_WINDOWS_ERASE_BACKGROUND_MODE                                 \
  "SDL_WINDOWS_ERASE_BACKGROUND_MODE"

/**
 * A variable controlling whether X11 windows are marked as override-redirect.
 *
 * If set, this _might_ increase framerate at the expense of the desktop not
 * working as expected. Override-redirect windows aren't noticed by the window
 * manager at all.
 *
 * You should probably only use this for fullscreen windows, and you probably
 * shouldn't even use it for that. But it's here if you want to try!
 *
 * The variable can be set to the following values:
 *
 * - "0": Do not mark the window as override-redirect. (default)
 * - "1": Mark the window as override-redirect.
 *
 * This hint should be set before creating a window.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_X11_FORCE_OVERRIDE_REDIRECT "SDL_X11_FORCE_OVERRIDE_REDIRECT"

/**
 * A variable specifying the type of an X11 window.
 *
 * During Window.Window, SDL uses the _NET_WM_WINDOW_TYPE X11 property to
 * report to the window manager the type of window it wants to create. This
 * might be set to various things if WINDOW_TOOLTIP or
 * WINDOW_POPUP_MENU, etc, were specified. For "normal" windows that
 * haven't set a specific type, this hint can be used to specify a custom
 * type. For example, a dock window might set this to
 * "_NET_WM_WINDOW_TYPE_DOCK".
 *
 * This hint should be set before creating a window.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_X11_WINDOW_TYPE "SDL_X11_WINDOW_TYPE"

/**
 * Specify the XCB library to load for the X11 driver.
 *
 * The default is platform-specific, often "libX11-xcb.so.1".
 *
 * This hint should be set before initializing the video subsystem.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_X11_XCB_LIBRARY "SDL_X11_XCB_LIBRARY"

/**
 * A variable controlling whether XInput should be used for controller
 * handling.
 *
 * The variable can be set to the following values:
 *
 * - "0": XInput is not enabled.
 * - "1": XInput is enabled. (default)
 *
 * This hint should be set before SDL is initialized.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_XINPUT_ENABLED "SDL_XINPUT_ENABLED"

/**
 * A variable controlling response to SDL_assert failures.
 *
 * The variable can be set to the following case-sensitive values:
 *
 * - "abort": Program terminates immediately.
 * - "break": Program triggers a debugger breakpoint.
 * - "retry": Program reruns the SDL_assert's test again.
 * - "ignore": Program continues on, ignoring this assertion failure this
 *   time.
 * - "always_ignore": Program continues on, ignoring this assertion failure
 *   for the rest of the run.
 *
 * Note that SetAssertionHandler offers a programmatic means to deal with
 * assertion failures through a callback, and this hint is largely intended to
 * be used via environment variables by end users and automated tools.
 *
 * This hint should be set before an assertion failure is triggered and can be
 * changed at any time.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_ASSERT "SDL_ASSERT"

/**
 * A variable controlling whether pen events should generate synthetic mouse
 * events.
 *
 * The variable can be set to the following values:
 *
 * - "0": Pen events will not generate mouse events.
 * - "1": Pen events will generate mouse events. (default)
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_PEN_MOUSE_EVENTS "SDL_PEN_MOUSE_EVENTS"

/**
 * A variable controlling whether pen events should generate synthetic touch
 * events.
 *
 * The variable can be set to the following values:
 *
 * - "0": Pen events will not generate touch events.
 * - "1": Pen events will generate touch events. (default)
 *
 * This hint can be set anytime.
 *
 * @since This hint is available since SDL 3.2.0.
 */
#define SDL_HINT_PEN_TOUCH_EVENTS "SDL_PEN_TOUCH_EVENTS"

#endif // SDL3PP_DOC

/**
 * An enumeration of hint priorities.
 *
 * @since This enum is available since SDL 3.2.0.
 */
using HintPriority = SDL_HintPriority;

constexpr HintPriority HINT_DEFAULT = SDL_HINT_DEFAULT; ///< DEFAULT

constexpr HintPriority HINT_NORMAL = SDL_HINT_NORMAL; ///< NORMAL

constexpr HintPriority HINT_OVERRIDE = SDL_HINT_OVERRIDE; ///< OVERRIDE

/**
 * Set a hint with a specific priority.
 *
 * The priority controls the behavior when setting a hint that already has a
 * value. Hints will replace existing hints of their priority and lower.
 * Environment variables are considered to have override priority.
 *
 * @param name the hint to set.
 * @param value the value of the hint variable.
 * @param priority the HintPriority level for the hint.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetHint
 * @sa ResetHint
 * @sa SetHint
 */
inline void SetHintWithPriority(StringParam name,
                                StringParam value,
                                HintPriority priority)
{
  CheckError(SDL_SetHintWithPriority(name, value, priority));
}

/**
 * Set a hint with normal priority.
 *
 * Hints will not be set if there is an existing override hint or environment
 * variable that takes precedence. You can use SetHintWithPriority() to
 * set the hint with override priority instead.
 *
 * @param name the hint to set.
 * @param value the value of the hint variable.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetHint
 * @sa ResetHint
 * @sa SetHintWithPriority
 */
inline void SetHint(StringParam name, StringParam value)
{
  CheckError(SDL_SetHint(name, value));
}

/**
 * Reset a hint to the default value.
 *
 * This will reset a hint to the value of the environment variable, or nullptr
 * if the environment isn't set. Callbacks will be called normally with this
 * change.
 *
 * @param name the hint to set.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SetHint
 * @sa ResetHints
 */
inline void ResetHint(StringParam name) { CheckError(SDL_ResetHint(name)); }

/**
 * Reset all hints to the default values.
 *
 * This will reset all hints to the value of the associated environment
 * variable, or nullptr if the environment isn't set. Callbacks will be called
 * normally with this change.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa ResetHint
 */
inline void ResetHints() { SDL_ResetHints(); }

/**
 * Get the value of a hint.
 *
 * @param name the hint to query.
 * @returns the string value of a hint or nullptr if the hint isn't set.
 *
 * @threadsafety It is safe to call this function from any thread, however the
 *               return value only remains valid until the hint is changed; if
 *               another thread might do so, the app should supply locks
 *               and/or make a copy of the string. Note that using a hint
 *               callback instead is always thread-safe, as SDL holds a lock
 *               on the thread subsystem during the callback.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SetHint
 * @sa SetHintWithPriority
 */
inline const char* GetHint(StringParam name) { return SDL_GetHint(name); }

/**
 * Get the boolean value of a hint variable.
 *
 * @param name the name of the hint to get the boolean value from.
 * @param default_value the value to return if the hint does not exist.
 * @returns the boolean value of a hint or the provided default value if the
 *          hint does not exist.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetHint
 * @sa SetHint
 */
inline bool GetHintBoolean(StringParam name, bool default_value)
{
  return SDL_GetHintBoolean(name, default_value);
}

/**
 * A callback used to send notifications of hint value changes.
 *
 * This is called an initial time during AddHintCallback with the hint's
 * current value, and then again each time the hint's value changes.
 *
 * @param userdata what was passed as `userdata` to AddHintCallback().
 * @param name what was passed as `name` to AddHintCallback().
 * @param oldValue the previous hint value.
 * @param newValue the new value hint is to be set to.
 *
 * @threadsafety This callback is fired from whatever thread is setting a new
 *               hint value. SDL holds a lock on the hint subsystem when
 *               calling this callback.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa AddHintCallback
 */
using HintCallback = SDL_HintCallback;

/**
 * A callback used to send notifications of hint value changes.
 *
 * This is called an initial time during AddHintCallback with the hint's
 * current value, and then again each time the hint's value changes.
 *
 * @param userdata what was passed as `userdata` to AddHintCallback().
 * @param name what was passed as `name` to AddHintCallback().
 * @param oldValue the previous hint value.
 * @param newValue the new value hint is to be set to.
 *
 * @threadsafety This callback is fired from whatever thread is setting a new
 *               hint value. SDL holds a lock on the hint subsystem when
 *               calling this callback.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa AddHintCallback
 * @sa HintCallback
 */
using HintCB = std::function<void(const char*, const char*, const char*)>;

/// Handle returned by AddHintCallback()
struct HintCallbackHandle : CallbackHandle
{
  using CallbackHandle::CallbackHandle;
};

/**
 * Add a function to watch a particular hint.
 *
 * The callback function is called _during_ this function, to provide it an
 * initial value, and again each time the hint's value changes.
 *
 * @param name the hint to watch.
 * @param callback An HintCallback function that will be called when the
 *                 hint value changes.
 * @param userdata a pointer to pass to the callback function.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa RemoveHintCallback
 */
inline void AddHintCallback(StringParam name,
                            HintCallback callback,
                            void* userdata)
{
  CheckError(SDL_AddHintCallback(name, callback, userdata));
}

/**
 * Add a function to watch a particular hint.
 *
 * The callback function is called _during_ this function, to provide it an
 * initial value, and again each time the hint's value changes.
 *
 * @param name the hint to watch.
 * @param callback An HintCallback function that will be called when the
 *                 hint value changes.
 * @returns a handle to be used on RemoveHintCallback()
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa RemoveHintCallback
 */
inline HintCallbackHandle AddHintCallback(StringParam name, HintCB callback)
{
  using Wrapper = CallbackWrapper<HintCB>;
  auto cb = Wrapper::Wrap(std::move(callback));
  if (!SDL_AddHintCallback(name, &Wrapper::Call, cb)) {
    Wrapper::release(cb);
    throw Error{};
  }
  return HintCallbackHandle{cb};
}

/**
 * Remove a function watching a particular hint.
 *
 * @param name the hint being watched.
 * @param callback an HintCallback function that will be called when the
 *                 hint value changes.
 * @param userdata a pointer being passed to the callback function.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AddHintCallback
 */
inline void RemoveHintCallback(StringParam name,
                               HintCallback callback,
                               void* userdata)
{
  SDL_RemoveHintCallback(name, callback, userdata);
}

/**
 * Remove a function watching a particular hint.
 *
 * @param name the hint being watched.
 * @param handle the handle for the HintCallback function to be removed
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AddHintCallback
 */
inline void RemoveHintCallback(StringParam name, HintCallbackHandle handle)
{
  CallbackWrapper<HintCB>::release(handle);
}

/// @}

/**
 * @defgroup CategoryLog Log Handling
 *
 * Simple log messages with priorities and categories. A message's
 * LogPriority signifies how important the message is. A message's
 * LogCategory signifies from what domain it belongs to. Every category
 * has a minimum priority specified: when a message belongs to that category,
 * it will only be sent out if it has that minimum priority or higher.
 *
 * SDL's own logs are sent below the default priority threshold, so they are
 * quiet by default.
 *
 * You can change the log verbosity programmatically using
 * LogCategory.SetLogPriority() or with SetHint(SDL_HINT_LOGGING, ...), or with
 * the "SDL_LOGGING" environment variable. This variable is a comma separated
 * set of category=level tokens that define the default logging levels for SDL
 * applications.
 *
 * The category can be a numeric category, one of "app", "error", "assert",
 * "system", "audio", "video", "render", "input", "test", or `*` for any
 * unspecified category.
 *
 * The level can be a numeric level, one of "trace", "verbose", "debug",
 * "info", "warn", "error", "critical", or "quiet" to disable that category.
 *
 * You can omit the category if you want to set the logging level for all
 * categories.
 *
 * If this hint isn't set, the default log levels are equivalent to:
 *
 * `app=info,assert=warn,test=verbose,*=error`
 *
 * Here's where the messages go on different platforms:
 *
 * - Windows: debug output stream
 * - Android: log output
 * - Others: standard error output (stderr)
 *
 * You don't need to have a newline (`@n`) on the end of messages, the
 * functions will do that for you. For consistent behavior cross-platform, you
 * shouldn't have any newlines in messages, such as to log multiple lines in
 * one call; unusual platform-specific behavior can be observed in such usage.
 * Do one log call per line instead, with no newlines in messages.
 *
 * Each log call is atomic, so you won't see log messages cut off one another
 * when logging from multiple threads.
 *
 * @{
 */

using LogCategoryRaw = SDL_LogCategory;

/**
 * @name LogPriorities
 *
 * The priorities assignable for a LogCategory.
 *
 * @{
 */

/**
 * The predefined log priorities
 *
 * @since This enum is available since SDL 3.2.0.
 */
using LogPriority = SDL_LogPriority;

constexpr LogPriority LOG_PRIORITY_INVALID =
  SDL_LOG_PRIORITY_INVALID; ///< INVALID

constexpr LogPriority LOG_PRIORITY_TRACE = SDL_LOG_PRIORITY_TRACE; ///< TRACE

constexpr LogPriority LOG_PRIORITY_VERBOSE =
  SDL_LOG_PRIORITY_VERBOSE; ///< VERBOSE

constexpr LogPriority LOG_PRIORITY_DEBUG = SDL_LOG_PRIORITY_DEBUG; ///< DEBUG

constexpr LogPriority LOG_PRIORITY_INFO = SDL_LOG_PRIORITY_INFO; ///< INFO

constexpr LogPriority LOG_PRIORITY_WARN = SDL_LOG_PRIORITY_WARN; ///< WARN

constexpr LogPriority LOG_PRIORITY_ERROR = SDL_LOG_PRIORITY_ERROR; ///< ERROR

constexpr LogPriority LOG_PRIORITY_CRITICAL =
  SDL_LOG_PRIORITY_CRITICAL; ///< CRITICAL

constexpr LogPriority LOG_PRIORITY_COUNT = SDL_LOG_PRIORITY_COUNT; ///< COUNT

/// @}

/**
 * @name LogCategories
 *
 * The logging categories. see LogCategory for more info
 *
 * @{
 */

/**
 * The predefined log categories
 *
 * By default the application and gpu categories are enabled at the INFO
 * level, the assert category is enabled at the WARN level, test is enabled at
 * the VERBOSE level and all other categories are enabled at the ERROR level.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @cat wrap-state
 *
 * @sa wrap-state
 */
class LogCategory
{
  LogCategoryRaw m_category;

public:
  /**
   * Wraps LogCategory.
   *
   * @param category the value to be wrapped
   */
  constexpr LogCategory(LogCategoryRaw category = SDL_LOG_CATEGORY_APPLICATION)
    : m_category(category)
  {
  }

  /**
   * Wraps LogCategory.
   *
   * @param category the value to be wrapped
   */
  constexpr explicit LogCategory(int category)
    : m_category(SDL_LogCategory(category))
  {
  }

  /// Default comparison operator
  constexpr auto operator<=>(const LogCategory& other) const = default;

  /// Compares with the underlying type
  constexpr auto operator<=>(LogCategoryRaw category) const
  {
    return operator<=>(LogCategory(category));
  }

  /**
   * Unwraps to the underlying LogCategory.
   *
   * @returns the underlying LogCategoryRaw.
   */
  constexpr operator LogCategoryRaw() const { return m_category; }

  /**
   * Check if valid.
   *
   * @returns True if valid state, false otherwise.
   */
  constexpr explicit operator bool() const { return m_category != 0; }

  /**
   * Set the priority of a particular log category.
   *
   * @param priority the LogPriority to assign.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa LogCategory.GetLogPriority
   * @sa ResetLogPriorities
   * @sa SetLogPriorities
   */
  void SetLogPriority(LogPriority priority) const;

  /**
   * Get the priority of a particular log category.
   *
   * @param category the category to query.
   * @returns the LogPriority for the requested category.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa LogCategory.SetLogPriority
   */
  LogPriority GetLogPriority() const;

  /**
   * Log an unformatted message with the specified priority.
   *
   * @param priority the priority of the message.
   * @param message string to output.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa SDL::Log()
   * @sa Log()
   * @sa LogCritical()
   * @sa LogDebug()
   * @sa LogError()
   * @sa LogInfo()
   * @sa LogTrace()
   * @sa LogVerbose()
   * @sa LogWarn()
   */
  void LogUnformatted(LogPriority priority, StringParam message) const
  {
    SDL_LogMessage(m_category, priority, "%s", (const char*)(message));
  }

  /**
   * Log a message with the specified priority.
   *
   * @param priority the priority of the message.
   * @param fmt a
   * [std::format/fmt](https://en.cppreference.com/w/cpp/utility/format/spec)
   * style message format string.
   * @param args additional parameters matching the `{}` tokens in the format
   * string, if any.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @cat formatted-string
   *
   * @sa LogCategory.LogCritical
   * @sa LogCategory.LogDebug
   * @sa LogCategory.LogError
   * @sa LogCategory.LogInfo
   * @sa LogUnformatted
   * @sa LogCategory.LogTrace
   * @sa LogCategory.LogVerbose
   * @sa LogCategory.LogWarn
   */
  template<class... ARGS>
  void LogMessage(LogPriority priority,
                  std::string_view fmt,
                  ARGS... args) const;

  /**
   * Log a message with LOG_PRIORITY_TRACE.
   *
   * @param fmt a
   * [std::format/fmt](https://en.cppreference.com/w/cpp/utility/format/spec)
   * style message format string.
   * @param args additional parameters matching the `{}` tokens in the format
   * string, if any.
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @cat formatted-string
   *
   * @sa LogCategory.LogCritical
   * @sa LogCategory.LogDebug
   * @sa LogCategory.LogError
   * @sa LogCategory.LogInfo
   * @sa LogCategory.LogMessage
   * @sa LogUnformatted
   * @sa LogCategory.LogTrace
   * @sa LogCategory.LogVerbose
   * @sa LogCategory.LogWarn
   */
  template<class... ARGS>
  void LogTrace(std::string_view fmt, ARGS&&... args) const;

  /**
   * Log a message with LOG_PRIORITY_VERBOSE.
   *
   * @param fmt a
   * [std::format/fmt](https://en.cppreference.com/w/cpp/utility/format/spec)
   * style message format string.
   * @param args additional parameters matching the `{}` tokens in the format
   * string, if any.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @cat formatted-string
   *
   * @sa LogCategory.LogCritical
   * @sa LogCategory.LogDebug
   * @sa LogCategory.LogError
   * @sa LogCategory.LogInfo
   * @sa LogCategory.LogMessage
   * @sa LogUnformatted
   * @sa LogCategory.LogWarn
   */
  template<class... ARGS>
  void LogVerbose(std::string_view fmt, ARGS&&... args) const;

  /**
   * Log a message with LOG_PRIORITY_DEBUG.
   *
   * @param fmt a
   * [std::format/fmt](https://en.cppreference.com/w/cpp/utility/format/spec)
   * style message format string.
   * @param args additional parameters matching the `{}` tokens in the format
   * string, if any.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @cat formatted-string
   *
   * @sa LogCategory.LogCritical
   * @sa LogCategory.LogError
   * @sa LogCategory.LogInfo
   * @sa LogCategory.LogMessage
   * @sa LogUnformatted
   * @sa LogCategory.LogTrace
   * @sa LogCategory.LogVerbose
   * @sa LogCategory.LogWarn
   */
  template<class... ARGS>
  void LogDebug(std::string_view fmt, ARGS&&... args) const;

  /**
   * Log a message with LOG_PRIORITY_INFO.
   *
   * @param fmt a
   * [std::format/fmt](https://en.cppreference.com/w/cpp/utility/format/spec)
   * style message format string.
   * @param args additional parameters matching the `{}` tokens in the format
   * string, if any.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @cat formatted-string
   *
   * @sa LogCategory.LogCritical
   * @sa LogCategory.LogDebug
   * @sa LogCategory.LogError
   * @sa LogCategory.LogMessage
   * @sa LogUnformatted
   * @sa LogCategory.LogTrace
   * @sa LogCategory.LogVerbose
   * @sa LogCategory.LogWarn
   */
  template<class... ARGS>
  void LogInfo(std::string_view fmt, ARGS&&... args) const;

  /**
   * Log a message with LOG_PRIORITY_WARN.
   *
   * @param fmt a
   * [std::format/fmt](https://en.cppreference.com/w/cpp/utility/format/spec)
   * style message format string.
   * @param args additional parameters matching the `{}` tokens in the format
   * string, if any.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @cat formatted-string
   *
   * @sa LogCategory.LogCritical
   * @sa LogCategory.LogDebug
   * @sa LogCategory.LogError
   * @sa LogCategory.LogInfo
   * @sa LogCategory.LogMessage
   * @sa LogUnformatted
   * @sa LogCategory.LogTrace
   * @sa LogCategory.LogVerbose
   */
  template<class... ARGS>
  void LogWarn(std::string_view fmt, ARGS&&... args) const;

  /**
   * Log a message with LOG_PRIORITY_ERROR.
   *
   * @param fmt a
   * [std::format/fmt](https://en.cppreference.com/w/cpp/utility/format/spec)
   * style message format string.
   * @param args additional parameters matching the `{}` tokens in the format
   * string, if any.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @cat formatted-string
   *
   * @sa LogCategory.LogCritical
   * @sa LogCategory.LogDebug
   * @sa LogCategory.LogInfo
   * @sa LogCategory.LogMessage
   * @sa LogUnformatted
   * @sa LogCategory.LogTrace
   * @sa LogCategory.LogVerbose
   * @sa LogCategory.LogWarn
   */
  template<class... ARGS>
  void LogError(std::string_view fmt, ARGS&&... args) const;

  /**
   * Log a message with LOG_PRIORITY_CRITICAL.
   *
   * @param fmt a
   * [std::format/fmt](https://en.cppreference.com/w/cpp/utility/format/spec)
   * style message format string.
   * @param args additional parameters matching the `{}` tokens in the format
   * string, if any.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @cat formatted-string
   *
   * @sa formatted-string
   * @sa LogCategory.LogDebug()
   * @sa LogCategory.LogError()
   * @sa LogCategory.LogInfo()
   * @sa LogUnformatted()
   * @sa LogCategory.LogUnformatted()
   * @sa LogCategory.LogTrace()
   * @sa LogCategory.LogVerbose()
   * @sa LogCategory.LogWarn
   */
  template<class... ARGS>
  void LogCritical(std::string_view fmt, ARGS&&... args) const;
};

constexpr LogCategory LOG_CATEGORY_APPLICATION =
  SDL_LOG_CATEGORY_APPLICATION; ///< APPLICATION

constexpr LogCategory LOG_CATEGORY_ERROR = SDL_LOG_CATEGORY_ERROR; ///< ERROR

constexpr LogCategory LOG_CATEGORY_ASSERT = SDL_LOG_CATEGORY_ASSERT; ///< ASSERT

constexpr LogCategory LOG_CATEGORY_SYSTEM = SDL_LOG_CATEGORY_SYSTEM; ///< SYSTEM

constexpr LogCategory LOG_CATEGORY_AUDIO = SDL_LOG_CATEGORY_AUDIO; ///< AUDIO

constexpr LogCategory LOG_CATEGORY_VIDEO = SDL_LOG_CATEGORY_VIDEO; ///< VIDEO

constexpr LogCategory LOG_CATEGORY_RENDER = SDL_LOG_CATEGORY_RENDER; ///< RENDER

constexpr LogCategory LOG_CATEGORY_INPUT = SDL_LOG_CATEGORY_INPUT; ///< INPUT

constexpr LogCategory LOG_CATEGORY_TEST = SDL_LOG_CATEGORY_TEST; ///< TEST

constexpr LogCategory LOG_CATEGORY_GPU = SDL_LOG_CATEGORY_GPU; ///< GPU

constexpr LogCategory LOG_CATEGORY_RESERVED2 =
  SDL_LOG_CATEGORY_RESERVED2; ///< RESERVED2

constexpr LogCategory LOG_CATEGORY_RESERVED3 =
  SDL_LOG_CATEGORY_RESERVED3; ///< RESERVED3

constexpr LogCategory LOG_CATEGORY_RESERVED4 =
  SDL_LOG_CATEGORY_RESERVED4; ///< RESERVED4

constexpr LogCategory LOG_CATEGORY_RESERVED5 =
  SDL_LOG_CATEGORY_RESERVED5; ///< RESERVED5

constexpr LogCategory LOG_CATEGORY_RESERVED6 =
  SDL_LOG_CATEGORY_RESERVED6; ///< RESERVED6

constexpr LogCategory LOG_CATEGORY_RESERVED7 =
  SDL_LOG_CATEGORY_RESERVED7; ///< RESERVED7

constexpr LogCategory LOG_CATEGORY_RESERVED8 =
  SDL_LOG_CATEGORY_RESERVED8; ///< RESERVED8

constexpr LogCategory LOG_CATEGORY_RESERVED9 =
  SDL_LOG_CATEGORY_RESERVED9; ///< RESERVED9

constexpr LogCategory LOG_CATEGORY_RESERVED10 =
  SDL_LOG_CATEGORY_RESERVED10; ///< RESERVED10

constexpr LogCategory LOG_CATEGORY_CUSTOM = SDL_LOG_CATEGORY_CUSTOM; ///< CUSTOM

/**
 * Set the priority of all log categories.
 *
 * @param priority the LogPriority to assign.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa ResetLogPriorities
 * @sa LogCategory.SetLogPriority
 */
inline void SetLogPriorities(LogPriority priority)
{
  SDL_SetLogPriorities(priority);
}

/**
 * Set the priority of a particular log category.
 *
 * @param category the category to assign a priority to.
 * @param priority the LogPriority to assign.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa LogCategory.GetLogPriority
 * @sa ResetLogPriorities
 * @sa SetLogPriorities
 */
inline void SetLogPriority(int category, LogPriority priority)
{
  SDL_SetLogPriority(category, priority);
}

inline void LogCategory::SetLogPriority(LogPriority priority) const
{
  SDL::SetLogPriority(m_category, priority);
}

/**
 * Get the priority of a particular log category.
 *
 * @param category the category to query.
 * @returns the LogPriority for the requested category.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa LogCategory.SetLogPriority
 */
inline LogPriority GetLogPriority(int category)
{
  return SDL_GetLogPriority(category);
}

inline LogPriority LogCategory::GetLogPriority() const
{
  return SDL::GetLogPriority(m_category);
}

/**
 * Reset all priorities to default.
 *
 * This is called by Quit().
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SetLogPriorities
 * @sa LogCategory.SetLogPriority
 */
inline void ResetLogPriorities() { SDL_ResetLogPriorities(); }

/**
 * Set the text prepended to log messages of a given priority.
 *
 * By default LOG_PRIORITY_INFO and below have no prefix, and
 * LOG_PRIORITY_WARN and higher have a prefix showing their priority, e.g.
 * "WARNING: ".
 *
 * @param priority the LogPriority to modify.
 * @param prefix the prefix to use for that log priority, or nullptr to use no
 *               prefix.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SetLogPriorities
 * @sa LogCategory.SetLogPriority
 */
inline void SetLogPriorityPrefix(LogPriority priority, StringParam prefix)
{
  CheckError(SDL_SetLogPriorityPrefix(priority, prefix));
}

/**
 * Log an unformatted message with LOG_CATEGORY_APPLICATION and
 * LOG_PRIORITY_INFO.
 *
 * @param category the category of the message.
 * @param priority the priority of the message.
 * @param message string to output.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Log
 * @sa LogCategory.LogCritical
 * @sa LogCategory.LogDebug
 * @sa LogCategory.LogError
 * @sa LogCategory.LogInfo
 * @sa LogCategory.LogMessage
 * @sa LogCategory.LogTrace
 * @sa LogCategory.LogVerbose
 * @sa LogCategory.LogWarn
 */
inline void LogUnformatted(LogCategory category,
                           LogPriority priority,
                           StringParam message)
{
  SDL_LogMessage(category, priority, "%s", static_cast<const char*>(message));
}

/**
 * Log an unformatted message with LOG_CATEGORY_APPLICATION and
 * LOG_PRIORITY_INFO.
 *
 * @param message string to output.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Log
 * @sa LogCategory.LogCritical
 * @sa LogCategory.LogDebug
 * @sa LogCategory.LogError
 * @sa LogCategory.LogInfo
 * @sa LogCategory.LogMessage
 * @sa LogCategory.LogTrace
 * @sa LogCategory.LogVerbose
 * @sa LogCategory.LogWarn
 */
inline void LogUnformatted(StringParam message)
{
  SDL_Log("%s", static_cast<const char*>(message));
}

/**
 * Log a message with LOG_CATEGORY_APPLICATION and LOG_PRIORITY_INFO.
 *
 * @param fmt a
 *            [std::format/fmt](https://en.cppreference.com/w/cpp/utility/format/spec)
 *            style message format string.
 * @param args additional parameters matching the `{}` tokens in the format
 *             string, if any.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @cat formatted-string
 *
 * @sa formatted-string
 * @sa LogUnformatted()
 * @sa LogCategory.LogCritical
 * @sa LogCategory.LogDebug
 * @sa LogCategory.LogError
 * @sa LogCategory.LogInfo
 * @sa LogCategory.LogMessage
 * @sa LogUnformatted
 * @sa LogCategory.LogTrace
 * @sa LogCategory.LogVerbose
 * @sa LogCategory.LogWarn
 */
template<class... ARGS>
inline void Log(std::string_view fmt, ARGS&&... args)
{
  LOG_CATEGORY_APPLICATION.LogInfo(fmt, std::forward<ARGS>(args)...);
}

/**
 * Log a message with the specified category and priority.
 *
 * @param category the category of the message.
 * @param priority the priority of the message.
 * @param fmt a printf() style message format string.
 * @param ... additional parameters matching % tokens in the **fmt** string,
 *            if any.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Log
 * @sa LogCategory.LogCritical
 * @sa LogCategory.LogDebug
 * @sa LogCategory.LogError
 * @sa LogCategory.LogInfo
 * @sa LogUnformatted
 * @sa LogCategory.LogTrace
 * @sa LogCategory.LogVerbose
 * @sa LogCategory.LogWarn
 */
template<class... ARGS>
inline void LogMessage(LogCategory category,
                       LogPriority priority,
                       std::string_view fmt,
                       ARGS... args)
{
  LogUnformatted(
    category, priority, std::vformat(fmt, std::make_format_args(args...)));
}

template<class... ARGS>
inline void LogCategory::LogMessage(LogPriority priority,
                                    std::string_view fmt,
                                    ARGS... args) const
{
  SDL::LogMessage(m_category, priority, fmt, args...);
}

/**
 * Log a message with LOG_PRIORITY_TRACE.
 *
 * @param category the category of the message.
 * @param fmt a printf() style message format string.
 * @param ... additional parameters matching % tokens in the **fmt** string,
 *            if any.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Log
 * @sa LogCategory.LogCritical
 * @sa LogCategory.LogDebug
 * @sa LogCategory.LogError
 * @sa LogCategory.LogInfo
 * @sa LogCategory.LogMessage
 * @sa LogUnformatted
 * @sa LogCategory.LogTrace
 * @sa LogCategory.LogVerbose
 * @sa LogCategory.LogWarn
 */
template<class... ARGS>
inline void LogTrace(LogCategory category, std::string_view fmt, ARGS&&... args)
{
  LogMessage(category, LOG_PRIORITY_TRACE, fmt, args...);
}

template<class... ARGS>
inline void LogCategory::LogTrace(std::string_view fmt, ARGS&&... args) const
{
  SDL::LogTrace(m_category, fmt, args...);
}

/**
 * Log a message with LOG_PRIORITY_VERBOSE.
 *
 * @param category the category of the message.
 * @param fmt a printf() style message format string.
 * @param ... additional parameters matching % tokens in the **fmt** string,
 *            if any.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Log
 * @sa LogCategory.LogCritical
 * @sa LogCategory.LogDebug
 * @sa LogCategory.LogError
 * @sa LogCategory.LogInfo
 * @sa LogCategory.LogMessage
 * @sa LogUnformatted
 * @sa LogCategory.LogWarn
 */
template<class... ARGS>
inline void LogVerbose(LogCategory category,
                       std::string_view fmt,
                       ARGS&&... args)
{
  LogMessage(category, LOG_PRIORITY_VERBOSE, fmt, args...);
}

template<class... ARGS>
inline void LogCategory::LogVerbose(std::string_view fmt, ARGS&&... args) const
{
  SDL::LogVerbose(m_category, fmt, args...);
}

/**
 * Log a message with LOG_PRIORITY_DEBUG.
 *
 * @param category the category of the message.
 * @param fmt a printf() style message format string.
 * @param ... additional parameters matching % tokens in the **fmt** string,
 *            if any.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Log
 * @sa LogCategory.LogCritical
 * @sa LogCategory.LogError
 * @sa LogCategory.LogInfo
 * @sa LogCategory.LogMessage
 * @sa LogUnformatted
 * @sa LogCategory.LogTrace
 * @sa LogCategory.LogVerbose
 * @sa LogCategory.LogWarn
 */
template<class... ARGS>
inline void LogDebug(LogCategory category, std::string_view fmt, ARGS&&... args)
{
  LogMessage(category, LOG_PRIORITY_DEBUG, fmt, args...);
}

template<class... ARGS>
inline void LogCategory::LogDebug(std::string_view fmt, ARGS&&... args) const
{
  SDL::LogDebug(m_category, fmt, args...);
}

/**
 * Log a message with LOG_PRIORITY_INFO.
 *
 * @param category the category of the message.
 * @param fmt a printf() style message format string.
 * @param ... additional parameters matching % tokens in the **fmt** string,
 *            if any.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Log
 * @sa LogCategory.LogCritical
 * @sa LogCategory.LogDebug
 * @sa LogCategory.LogError
 * @sa LogCategory.LogMessage
 * @sa LogUnformatted
 * @sa LogCategory.LogTrace
 * @sa LogCategory.LogVerbose
 * @sa LogCategory.LogWarn
 */
template<class... ARGS>
inline void LogInfo(LogCategory category, std::string_view fmt, ARGS&&... args)
{
  LogMessage(category, LOG_PRIORITY_INFO, fmt, args...);
}

template<class... ARGS>
inline void LogCategory::LogInfo(std::string_view fmt, ARGS&&... args) const
{
  SDL::LogInfo(m_category, fmt, args...);
}

/**
 * Log a message with LOG_PRIORITY_WARN.
 *
 * @param category the category of the message.
 * @param fmt a printf() style message format string.
 * @param ... additional parameters matching % tokens in the **fmt** string,
 *            if any.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Log
 * @sa LogCategory.LogCritical
 * @sa LogCategory.LogDebug
 * @sa LogCategory.LogError
 * @sa LogCategory.LogInfo
 * @sa LogCategory.LogMessage
 * @sa LogUnformatted
 * @sa LogCategory.LogTrace
 * @sa LogCategory.LogVerbose
 */
template<class... ARGS>
inline void LogWarn(LogCategory category, std::string_view fmt, ARGS&&... args)
{
  LogMessage(category, SDL_LOG_PRIORITY_WARN, fmt, args...);
}

template<class... ARGS>
inline void LogCategory::LogWarn(std::string_view fmt, ARGS&&... args) const
{
  SDL::LogWarn(m_category, fmt, args...);
}

/**
 * Log a message with LOG_PRIORITY_ERROR.
 *
 * @param category the category of the message.
 * @param fmt a printf() style message format string.
 * @param ... additional parameters matching % tokens in the **fmt** string,
 *            if any.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Log
 * @sa LogCategory.LogCritical
 * @sa LogCategory.LogDebug
 * @sa LogCategory.LogInfo
 * @sa LogCategory.LogMessage
 * @sa LogUnformatted
 * @sa LogCategory.LogTrace
 * @sa LogCategory.LogVerbose
 * @sa LogCategory.LogWarn
 */
template<class... ARGS>
inline void LogError(LogCategory category, std::string_view fmt, ARGS&&... args)
{
  LogMessage(category, SDL_LOG_PRIORITY_ERROR, fmt, args...);
}

template<class... ARGS>
inline void LogCategory::LogError(std::string_view fmt, ARGS&&... args) const
{
  SDL::LogError(m_category, fmt, args...);
}

/**
 * Log a message with LOG_PRIORITY_CRITICAL.
 *
 * @param category the category of the message.
 * @param fmt a printf() style message format string.
 * @param ... additional parameters matching % tokens in the **fmt** string,
 *            if any.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Log
 * @sa LogCategory.LogDebug
 * @sa LogCategory.LogError
 * @sa LogCategory.LogInfo
 * @sa LogCategory.LogMessage
 * @sa LogUnformatted
 * @sa LogCategory.LogTrace
 * @sa LogCategory.LogVerbose
 * @sa LogCategory.LogWarn
 */
template<class... ARGS>
inline void LogCritical(LogCategory category,
                        std::string_view fmt,
                        ARGS&&... args)
{
  LogMessage(category, SDL_LOG_PRIORITY_CRITICAL, fmt, args...);
}

template<class... ARGS>
inline void LogCategory::LogCritical(std::string_view fmt, ARGS&&... args) const
{
  SDL::LogCritical(m_category, fmt, args...);
}

/**
 * The prototype for the log output callback function.
 *
 * This function is called by SDL when there is new text to be logged. A mutex
 * is held so that this function is never called by more than one thread at
 * once.
 *
 * @param userdata what was passed as `userdata` to
 *                 SetLogOutputFunction().
 * @param category the category of the message.
 * @param priority the priority of the message.
 * @param message the message being output.
 *
 * @since This datatype is available since SDL 3.2.0.
 */
using LogOutputFunction = SDL_LogOutputFunction;

/**
 * The prototype for the log output callback function.
 *
 * This function is called by SDL when there is new text to be logged. A mutex
 * is held so that this function is never called by more than one thread at
 * once.
 *
 * @param category the category of the message.
 * @param priority the priority of the message.
 * @param message the message being output.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @cat listener-callback
 *
 * @sa LogOutputFunction
 */
using LogOutputCB = std::function<void(LogCategory, LogPriority, const char*)>;

/**
 * Get the default log output function.
 *
 * @returns the default log output callback.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SetLogOutputFunction
 * @sa GetLogOutputFunction
 */
inline LogOutputFunction GetDefaultLogOutputFunction()
{
  return SDL_GetDefaultLogOutputFunction();
}

/**
 * Get the current log output function.
 *
 * @param callback an LogOutputFunction filled in with the current log callback.
 * @param userdata a pointer filled in with the pointer that is passed to
 *                 `callback`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetDefaultLogOutputFunction
 * @sa SetLogOutputFunction
 */
inline void GetLogOutputFunction(LogOutputFunction* callback, void** userdata)
{
  SDL_GetLogOutputFunction(callback, userdata);
}

/**
 * Get the current log output function.
 *
 * @returns the LogOutputCB currently set
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @cat listener-callback
 *
 * @sa listener-callback
 * @sa GetDefaultLogOutputFunction
 * @sa SetLogOutputFunction
 */
inline LogOutputCB GetLogOutputFunction()
{
  using Wrapper = UniqueCallbackWrapper<LogOutputCB>;
  LogOutputFunction cb;
  void* userdata;
  GetLogOutputFunction(&cb, &userdata);
  if (userdata == nullptr) {
    return [cb](LogCategory c, LogPriority p, StringParam m) {
      cb(nullptr, c, p, m);
    };
  }
  if (auto cb = Wrapper::at(userdata)) return cb;
  return [cb, userdata](LogCategory c, LogPriority p, StringParam m) {
    cb(userdata, c, p, m);
  };
}

/**
 * Replace the default log output function with one of your own.
 *
 * @param callback an LogOutputFunction to call instead of the default.
 * @param userdata a pointer that is passed to `callback`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetDefaultLogOutputFunction
 * @sa GetLogOutputFunction
 * @sa ResetLogOutputFunction
 */
inline void SetLogOutputFunction(LogOutputFunction callback, void* userdata)
{
  UniqueCallbackWrapper<LogOutputCB>::erase();
  return SDL_SetLogOutputFunction(callback, userdata);
}

/**
 * Replace the default log output function with one of your own.
 *
 * @param callback an LogOutputFunction to call instead of the default.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @cat listener-callback
 *
 * @sa listener-callback
 * @sa GetDefaultLogOutputFunction
 * @sa GetLogOutputFunction
 * @sa ResetLogOutputFunction
 */
inline void SetLogOutputFunction(LogOutputCB callback)
{
  using Wrapper = UniqueCallbackWrapper<LogOutputCB>;
  SDL_SetLogOutputFunction(
    [](
      void* userdata, int category, LogPriority priority, const char* message) {
      return Wrapper::Call(userdata, LogCategory{category}, priority, message);
    },
    Wrapper::Wrap(std::move(callback)));
}

/**
 * Replace the current log output function with the default one
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetDefaultLogOutputFunction
 * @sa GetLogOutputFunction
 */
inline void ResetLogOutputFunction()
{
  return SetLogOutputFunction(GetDefaultLogOutputFunction(), nullptr);
}

/// @}

/**
 * @defgroup CategoryPixels Pixel Formats and Conversion Routines
 *
 * SDL offers facilities for pixel management.
 *
 * Largely these facilities deal with pixel _format_: what does this set of
 * bits represent?
 *
 * If you mostly want to think of a pixel as some combination of red, green,
 * blue, and maybe alpha intensities, this is all pretty straightforward, and
 * in many cases, is enough information to build a perfectly fine game.
 *
 * However, the actual definition of a pixel is more complex than that:
 *
 * Pixels are a representation of a color in a particular color space.
 *
 * The first characteristic of a color space is the color type. SDL
 * understands two different color types, RGB and YCbCr, or in SDL also
 * referred to as YUV.
 *
 * RGB colors consist of red, green, and blue channels of color that are added
 * together to represent the colors we see on the screen.
 *
 * https://en.wikipedia.org/wiki/RGB_color_model
 *
 * YCbCr colors represent colors as a Y luma brightness component and red and
 * blue chroma color offsets. This color representation takes advantage of the
 * fact that the human eye is more sensitive to brightness than the color in
 * an image. The Cb and Cr components are often compressed and have lower
 * resolution than the luma component.
 *
 * https://en.wikipedia.org/wiki/YCbCr
 *
 * When the color information in YCbCr is compressed, the Y pixels are left at
 * full resolution and each Cr and Cb pixel represents an average of the color
 * information in a block of Y pixels. The chroma location determines where in
 * that block of pixels the color information is coming from.
 *
 * The color range defines how much of the pixel to use when converting a
 * pixel into a color on the display. When the full color range is used, the
 * entire numeric range of the pixel bits is significant. When narrow color
 * range is used, for historical reasons, the pixel uses only a portion of the
 * numeric range to represent colors.
 *
 * The color primaries and white point are a definition of the colors in the
 * color space relative to the standard XYZ color space.
 *
 * https://en.wikipedia.org/wiki/CIE_1931_color_space
 *
 * The transfer characteristic, or opto-electrical transfer function (OETF),
 * is the way a color is converted from mathematically linear space into a
 * non-linear output signals.
 *
 * https://en.wikipedia.org/wiki/Rec._709#Transfer_characteristics
 *
 * The matrix coefficients are used to convert between YCbCr and RGB colors.
 *
 * @{
 */

using PixelFormatRaw = SDL_PixelFormat;

using ColorspaceRaw = SDL_Colorspace;

using ColorRaw = SDL_Color;

using FColorRaw = SDL_FColor;

// Forward decl
struct Palette;

using PaletteRaw = SDL_Palette*;

/// Safely wrap Palette for non owning parameters
struct PaletteParam
{
  PaletteRaw value; ///< parameter's PaletteRaw

  /// Constructs from PaletteRaw
  constexpr PaletteParam(PaletteRaw value)
    : value(value)
  {
  }

  /// Constructs null/invalid
  constexpr PaletteParam(std::nullptr_t _ = nullptr)
    : value(nullptr)
  {
  }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!value; }

  /// Comparison
  constexpr auto operator<=>(const PaletteParam& other) const = default;

  /// Converts to underlying PaletteRaw
  constexpr operator PaletteRaw() const { return value; }
};

/// Safely wrap Palette for non owning const parameters
struct PaletteConstParam
{
  const PaletteRaw value; ///< parameter's const PaletteRaw

  /// Constructs from const PaletteRaw
  constexpr PaletteConstParam(const PaletteRaw value)
    : value(value)
  {
  }

  /// Constructs from PaletteParam
  constexpr PaletteConstParam(PaletteParam value)
    : value(value.value)
  {
  }

  /// Constructs null/invalid
  constexpr PaletteConstParam(std::nullptr_t _ = nullptr)
    : value(nullptr)
  {
  }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!value; }

  /// Comparison
  constexpr auto operator<=>(const PaletteConstParam& other) const = default;

  /// Converts to underlying const PaletteRaw
  constexpr operator const PaletteRaw() const { return value; }
};

// Forward decl
struct Color;

/**
 * Details about the format of a pixel.
 *
 * @since This struct is available since SDL 3.2.0.
 */
using PixelFormatDetails = SDL_PixelFormatDetails;

/**
 * A fully opaque 8-bit alpha value.
 *
 * @since This macro is available since SDL 3.2.0.
 *
 * @sa ALPHA_TRANSPARENT
 */
constexpr Uint8 ALPHA_OPAQUE = SDL_ALPHA_OPAQUE;

/**
 * A fully opaque floating point alpha value.
 *
 * @since This macro is available since SDL 3.2.0.
 *
 * @sa ALPHA_TRANSPARENT_FLOAT
 */
constexpr float ALPHA_OPAQUE_FLOAT = SDL_ALPHA_OPAQUE_FLOAT;

/**
 * A fully transparent 8-bit alpha value.
 *
 * @since This macro is available since SDL 3.2.0.
 *
 * @sa ALPHA_OPAQUE
 */
constexpr Uint8 ALPHA_TRANSPARENT = SDL_ALPHA_TRANSPARENT;

/**
 * A fully transparent floating point alpha value.
 *
 * @since This macro is available since SDL 3.2.0.
 *
 * @sa ALPHA_OPAQUE_FLOAT
 */
constexpr float ALPHA_TRANSPARENT_FLOAT = SDL_ALPHA_TRANSPARENT_FLOAT;

/**
 * Pixel type.
 *
 * @name PixelTypes
 * @{
 */

/**
 * Pixel type.
 *
 * @since This enum is available since SDL 3.2.0.
 */
using PixelType = SDL_PixelType;

constexpr PixelType PIXELTYPE_UNKNOWN = SDL_PIXELTYPE_UNKNOWN; ///< UNKNOWN

constexpr PixelType PIXELTYPE_INDEX1 = SDL_PIXELTYPE_INDEX1; ///< INDEX1

constexpr PixelType PIXELTYPE_INDEX4 = SDL_PIXELTYPE_INDEX4; ///< INDEX4

constexpr PixelType PIXELTYPE_INDEX8 = SDL_PIXELTYPE_INDEX8; ///< INDEX8

constexpr PixelType PIXELTYPE_PACKED8 = SDL_PIXELTYPE_PACKED8; ///< PACKED8

constexpr PixelType PIXELTYPE_PACKED16 = SDL_PIXELTYPE_PACKED16; ///< PACKED16

constexpr PixelType PIXELTYPE_PACKED32 = SDL_PIXELTYPE_PACKED32; ///< PACKED32

constexpr PixelType PIXELTYPE_ARRAYU8 = SDL_PIXELTYPE_ARRAYU8; ///< ARRAYU8

constexpr PixelType PIXELTYPE_ARRAYU16 = SDL_PIXELTYPE_ARRAYU16; ///< ARRAYU16

constexpr PixelType PIXELTYPE_ARRAYU32 = SDL_PIXELTYPE_ARRAYU32; ///< ARRAYU32

constexpr PixelType PIXELTYPE_ARRAYF16 = SDL_PIXELTYPE_ARRAYF16; ///< ARRAYF16

constexpr PixelType PIXELTYPE_ARRAYF32 = SDL_PIXELTYPE_ARRAYF32; ///< ARRAYF32

constexpr PixelType PIXELTYPE_INDEX2 = SDL_PIXELTYPE_INDEX2; ///< INDEX2

/// @}

/**
 * @name BitmapOrders
 * @{
 */

/**
 * Bitmap pixel order, high bit -> low bit.
 *
 * @since This enum is available since SDL 3.2.0.
 */
using BitmapOrder = SDL_BitmapOrder;

constexpr BitmapOrder BITMAPORDER_NONE = SDL_BITMAPORDER_NONE; ///< NONE

constexpr BitmapOrder BITMAPORDER_4321 = SDL_BITMAPORDER_4321; ///< 4321

constexpr BitmapOrder BITMAPORDER_1234 = SDL_BITMAPORDER_1234; ///< 1234

/// @}

/**
 * @name PackedOrders
 * @{
 */

/**
 * Packed component order, high bit -> low bit.
 *
 * @since This enum is available since SDL 3.2.0.
 */
using PackedOrder = SDL_PackedOrder;

constexpr PackedOrder PACKEDORDER_NONE = SDL_PACKEDORDER_NONE; ///< NONE

constexpr PackedOrder PACKEDORDER_XRGB = SDL_PACKEDORDER_XRGB; ///< XRGB

constexpr PackedOrder PACKEDORDER_RGBX = SDL_PACKEDORDER_RGBX; ///< RGBX

constexpr PackedOrder PACKEDORDER_ARGB = SDL_PACKEDORDER_ARGB; ///< ARGB

constexpr PackedOrder PACKEDORDER_RGBA = SDL_PACKEDORDER_RGBA; ///< RGBA

constexpr PackedOrder PACKEDORDER_XBGR = SDL_PACKEDORDER_XBGR; ///< XBGR

constexpr PackedOrder PACKEDORDER_BGRX = SDL_PACKEDORDER_BGRX; ///< BGRX

constexpr PackedOrder PACKEDORDER_ABGR = SDL_PACKEDORDER_ABGR; ///< ABGR

constexpr PackedOrder PACKEDORDER_BGRA = SDL_PACKEDORDER_BGRA; ///< BGRA

/// @}

/**
 * @name ArrayOrders
 * @{
 */

/**
 * Array component order, low byte -> high byte.
 *
 * @since This enum is available since SDL 3.2.0.
 */
using ArrayOrder = SDL_ArrayOrder;

constexpr ArrayOrder ARRAYORDER_NONE = SDL_ARRAYORDER_NONE; ///< NONE

constexpr ArrayOrder ARRAYORDER_RGB = SDL_ARRAYORDER_RGB; ///< RGB

constexpr ArrayOrder ARRAYORDER_RGBA = SDL_ARRAYORDER_RGBA; ///< RGBA

constexpr ArrayOrder ARRAYORDER_ARGB = SDL_ARRAYORDER_ARGB; ///< ARGB

constexpr ArrayOrder ARRAYORDER_BGR = SDL_ARRAYORDER_BGR; ///< BGR

constexpr ArrayOrder ARRAYORDER_BGRA = SDL_ARRAYORDER_BGRA; ///< BGRA

constexpr ArrayOrder ARRAYORDER_ABGR = SDL_ARRAYORDER_ABGR; ///< ABGR

/// @}

/**
 * @name PackedLayouts
 * @{
 */

/**
 * Packed component layout.
 *
 * @since This enum is available since SDL 3.2.0.
 */
using PackedLayout = SDL_PackedLayout;

constexpr PackedLayout PACKEDLAYOUT_NONE = SDL_PACKEDLAYOUT_NONE; ///< NONE

constexpr PackedLayout PACKEDLAYOUT_332 = SDL_PACKEDLAYOUT_332; ///< 332

constexpr PackedLayout PACKEDLAYOUT_4444 = SDL_PACKEDLAYOUT_4444; ///< 4444

constexpr PackedLayout PACKEDLAYOUT_1555 = SDL_PACKEDLAYOUT_1555; ///< 1555

constexpr PackedLayout PACKEDLAYOUT_5551 = SDL_PACKEDLAYOUT_5551; ///< 5551

constexpr PackedLayout PACKEDLAYOUT_565 = SDL_PACKEDLAYOUT_565; ///< 565

constexpr PackedLayout PACKEDLAYOUT_8888 = SDL_PACKEDLAYOUT_8888; ///< 8888

constexpr PackedLayout PACKEDLAYOUT_2101010 =
  SDL_PACKEDLAYOUT_2101010; ///< 2101010

constexpr PackedLayout PACKEDLAYOUT_1010102 =
  SDL_PACKEDLAYOUT_1010102; ///< 1010102

/// @}

/**
 * A macro for defining custom FourCC pixel formats.
 *
 * For example, defining PIXELFORMAT_YV12 looks like this:
 *
 * ```cpp
 * DEFINE_PIXELFOURCC('Y', 'V', '1', '2')
 * ```
 *
 * @param A the first character of the FourCC code.
 * @param B the second character of the FourCC code.
 * @param C the third character of the FourCC code.
 * @param D the fourth character of the FourCC code.
 * @returns a format value in the style of PixelFormat.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr Uint32 DEFINE_PIXELFOURCC(Uint8 A, Uint8 B, Uint8 C, Uint8 D)
{
  return SDL_DEFINE_PIXELFOURCC(A, B, C, D);
}

/**
 * @name PixelFormats
 * @{
 */

/**
 * Pixel format.
 *
 * SDL's pixel formats have the following naming convention:
 *
 * - Names with a list of components and a single bit count, such as RGB24 and
 *   ABGR32, define a platform-independent encoding into bytes in the order
 *   specified. For example, in RGB24 data, each pixel is encoded in 3 bytes
 *   (red, green, blue) in that order, and in ABGR32 data, each pixel is
 *   encoded in 4 bytes (alpha, blue, green, red) in that order. Use these
 *   names if the property of a format that is important to you is the order
 *   of the bytes in memory or on disk.
 * - Names with a bit count per component, such as ARGB8888 and XRGB1555, are
 *   "packed" into an appropriately-sized integer in the platform's native
 *   endianness. For example, ARGB8888 is a sequence of 32-bit integers; in
 *   each integer, the most significant bits are alpha, and the least
 *   significant bits are blue. On a little-endian CPU such as x86, the least
 *   significant bits of each integer are arranged first in memory, but on a
 *   big-endian CPU such as s390x, the most significant bits are arranged
 *   first. Use these names if the property of a format that is important to
 *   you is the meaning of each bit position within a native-endianness
 *   integer.
 * - In indexed formats such as INDEX4LSB, each pixel is represented by
 *   encoding an index into the palette into the indicated number of bits,
 *   with multiple pixels packed into each byte if appropriate. In LSB
 *   formats, the first (leftmost) pixel is stored in the least-significant
 *   bits of the byte; in MSB formats, it's stored in the most-significant
 *   bits. INDEX8 does not need LSB/MSB variants, because each pixel exactly
 *   fills one byte.
 *
 * The 32-bit byte-array encodings such as RGBA32 are aliases for the
 * appropriate 8888 encoding for the current platform. For example, RGBA32 is
 * an alias for ABGR8888 on little-endian CPUs like x86, or an alias for
 * RGBA8888 on big-endian CPUs.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @cat wrap-state
 *
 * @sa wrap-state
 * @sa PixelFormats
 */
class PixelFormat
{
  PixelFormatRaw m_format;

public:
  /**
   * Wraps PixelFormat.
   *
   * @param format the value to be wrapped
   */
  constexpr PixelFormat(PixelFormatRaw format = {})
    : m_format(format)
  {
  }

  /**
   * Defining custom non-FourCC pixel formats.
   *
   * For example, defining PIXELFORMAT_RGBA8888 looks like this:
   *
   * ```cpp
   * PixelFormat format(PIXELTYPE_PACKED32, PACKEDORDER_RGBA,
   * PACKEDLAYOUT_8888, 32, 4)
   * ```
   *
   * @param type the type of the new format, probably a PixelType value.
   * @param order the order of the new format, probably a BitmapOrder,
   *              PackedOrder, or ArrayOrder value.
   * @param layout the layout of the new format, probably an PackedLayout
   *               value or zero.
   * @param bits the number of bits per pixel of the new format.
   * @param bytes the number of bytes per pixel of the new format.
   * @post a format value in the style of PixelFormat.
   *
   * @threadsafety It is safe to call this macro from any thread.
   *
   * @since This macro is available since SDL 3.2.0.
   */
  constexpr PixelFormat(PixelType type,
                        int order,
                        PackedLayout layout,
                        int bits,
                        int bytes)
    : m_format(PixelFormatRaw(
        SDL_DEFINE_PIXELFORMAT(type, order, layout, bits, bytes)))
  {
  }

  /// Default comparison operator
  constexpr bool operator==(const PixelFormat& other) const = default;

  /// Compares with the underlying type
  constexpr bool operator==(PixelFormatRaw format) const
  {
    return operator==(PixelFormat(format));
  }

  /**
   * Unwraps to the underlying PixelFormat.
   *
   * @returns the underlying PixelFormatRaw.
   */
  constexpr operator PixelFormatRaw() const { return m_format; }

  /**
   * Check if valid.
   *
   * @returns True if valid state, false otherwise.
   */
  constexpr explicit operator bool() const { return m_format != 0; }

  /**
   * Retrieve the flags of an PixelFormat.
   *
   * This function is generally not needed directly by an app, which should use
   * specific tests, like PixelFormat.IsFourCC, instead.
   *
   * @param format an PixelFormat to check.
   * @returns the flags of `format`.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr Uint8 GetFlags() const;

  /**
   * Retrieve the type.
   *
   * @returns the type as PixelType.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr PixelType GetType() const;

  /**
   * Retrieve the order.
   *
   * This is usually a value from the BitmapOrder, PackedOrder, or
   * ArrayOrder enumerations, depending on the format type.
   *
   * @returns the order.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr int GetOrder() const;

  /**
   * Retrieve the layout.
   *
   * This is usually a value from the PackedLayout enumeration, or zero if a
   * layout doesn't make sense for the format type.
   *
   * @returns the layout
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr PackedLayout GetLayout() const;

  /**
   * Determine this's bits per pixel.
   *
   * FourCC formats will report zero here, as it rarely makes sense to measure
   * them per-pixel.
   *
   * @returns the bits-per-pixel.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa GetBytesPerPixel
   */
  constexpr int GetBitsPerPixel() const;

  /**
   * Determine this's bytes per pixel.
   *
   * Note that this macro double-evaluates its parameter, so do not use
   * expressions with side-effects here.
   *
   * FourCC formats do their best here, but many of them don't have a meaningful
   * measurement of bytes per pixel.
   *
   * @return the bytes-per-pixel.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa GetBitsPerPixel
   */
  constexpr int GetBytesPerPixel() const;

  /**
   * Determine if this is an indexed format.
   *
   * @returns true if the format is indexed, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool IsIndexed() const;

  /**
   * Determine if this is a packed format.
   *
   * @returns true if the format is packed, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool IsPacked() const;

  /**
   * Determine if this is an array format.
   *
   * @returns true if the format is an array, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool IsArray() const;

  /**
   * Determine if this is a 10-bit format.
   *
   * @returns true if the format is 10-bit, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool Is10Bit() const;

  /**
   * Determine if this is a floating point format.
   *
   * @returns true if the format is 10-bit, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool IsFloat() const;

  /**
   * Determine if this has an alpha channel.
   *
   * @returns true if the format has alpha, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool IsAlpha() const;

  /**
   * Determine if this is a "FourCC" format.
   *
   * This covers custom and other unusual formats.
   *
   * @returns true if the format has alpha, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool IsFourCC() const;

  /**
   * Get the human readable name of a pixel format.
   *
   * @returns the human readable name of the specified pixel format or
   *          "PIXELFORMAT_UNKNOWN" if the format isn't recognized.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  const char* GetName() const;

  /**
   * Convert one of the enumerated pixel formats to a bpp value and RGBA masks.
   *
   * @param bpp a bits per pixel value; usually 15, 16, or 32.
   * @param Rmask a pointer filled in with the red mask for the format.
   * @param Gmask a pointer filled in with the green mask for the format.
   * @param Bmask a pointer filled in with the blue mask for the format.
   * @param Amask a pointer filled in with the alpha mask for the format.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa PixelFormat.ForMasks
   */
  void GetMasks(int* bpp,
                Uint32* Rmask,
                Uint32* Gmask,
                Uint32* Bmask,
                Uint32* Amask) const;

  /**
   * Convert a bpp value and RGBA masks to an enumerated pixel format.
   *
   * This will return `PIXELFORMAT_UNKNOWN` if the conversion wasn't
   * possible.
   *
   * @param bpp a bits per pixel value; usually 15, 16, or 32.
   * @param Rmask the red mask for the format.
   * @param Gmask the green mask for the format.
   * @param Bmask the blue mask for the format.
   * @param Amask the alpha mask for the format.
   * @returns the PixelFormat value corresponding to the format masks, or
   *          PIXELFORMAT_UNKNOWN if there isn't a match.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa PixelFormat.GetMasks
   */
  static PixelFormat ForMasks(int bpp,
                              Uint32 Rmask,
                              Uint32 Gmask,
                              Uint32 Bmask,
                              Uint32 Amask);

  /**
   * Create an PixelFormatDetails structure corresponding to a pixel format.
   *
   * Returned structure may come from a shared global cache (i.e. not newly
   * allocated), and hence should not be modified, especially the palette. Weird
   * errors such as `Blit combination not supported` may occur.
   *
   * @returns a pointer to a PixelFormatDetails structure or nullptr on
   *          failure; call GetError() for more information.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  const PixelFormatDetails* GetDetails() const;

  /**
   * Map an RGBA quadruple to a pixel value for a given pixel format.
   *
   * This function maps the RGBA color value to the specified pixel format and
   * returns the pixel value best approximating the given RGBA color value for
   * the given pixel format.
   *
   * If the specified pixel format has no alpha component the alpha value will
   * be ignored (as it will be in formats with a palette).
   *
   * If the format has a palette (8-bit) the index of the closest matching color
   * in the palette will be returned.
   *
   * If the pixel format bpp (color depth) is less than 32-bpp then the unused
   * upper bits of the return value can safely be ignored (e.g., with a 16-bpp
   * format the return value can be assigned to a Uint16, and similarly a Uint8
   * for an 8-bpp format).
   *
   * @param color the color components of the pixel in the range 0-255.
   * @param palette an optional palette for indexed formats, may be NULL.
   * @returns a pixel value.
   *
   * @threadsafety It is safe to call this function from any thread, as long as
   *               the palette is not modified.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa GetPixelFormatDetails()
   * @sa Get()
   * @sa MapRGBA()
   * @sa Surface.MapColor()
   */
  Uint32 Map(Color color, PaletteConstParam palette) const;

  /**
   * Get RGBA values from a pixel in the specified format.
   *
   * This function uses the entire 8-bit [0..255] range when converting color
   * components from pixel formats with less than 8-bits per RGB component
   * (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
   * 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).
   *
   * If the surface has no alpha component, the alpha will be returned as 0xff
   * (100% opaque).
   *
   * @param pixel a pixel value.
   * @param palette an optional palette for indexed formats, may be NULL.
   * @returns a color value.
   *
   * @threadsafety It is safe to call this function from any thread, as long as
   *               the palette is not modified.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa GetPixelFormatDetails()
   * @sa GetRGBA()
   * @sa Map()
   */
  Color Get(Uint32 pixel, PaletteConstParam palette) const;
};

constexpr PixelFormat PIXELFORMAT_UNKNOWN =
  SDL_PIXELFORMAT_UNKNOWN; ///< UNKNOWN

constexpr PixelFormat PIXELFORMAT_INDEX1LSB =
  SDL_PIXELFORMAT_INDEX1LSB; ///< INDEX1LSB

constexpr PixelFormat PIXELFORMAT_INDEX1MSB =
  SDL_PIXELFORMAT_INDEX1MSB; ///< INDEX1MSB

constexpr PixelFormat PIXELFORMAT_INDEX2LSB =
  SDL_PIXELFORMAT_INDEX2LSB; ///< INDEX2LSB

constexpr PixelFormat PIXELFORMAT_INDEX2MSB =
  SDL_PIXELFORMAT_INDEX2MSB; ///< INDEX2MSB

constexpr PixelFormat PIXELFORMAT_INDEX4LSB =
  SDL_PIXELFORMAT_INDEX4LSB; ///< INDEX4LSB

constexpr PixelFormat PIXELFORMAT_INDEX4MSB =
  SDL_PIXELFORMAT_INDEX4MSB; ///< INDEX4MSB

constexpr PixelFormat PIXELFORMAT_INDEX8 = SDL_PIXELFORMAT_INDEX8; ///< INDEX8

constexpr PixelFormat PIXELFORMAT_RGB332 = SDL_PIXELFORMAT_RGB332; ///< RGB332

constexpr PixelFormat PIXELFORMAT_XRGB4444 =
  SDL_PIXELFORMAT_XRGB4444; ///< XRGB4444

constexpr PixelFormat PIXELFORMAT_XBGR4444 =
  SDL_PIXELFORMAT_XBGR4444; ///< XBGR4444

constexpr PixelFormat PIXELFORMAT_XRGB1555 =
  SDL_PIXELFORMAT_XRGB1555; ///< XRGB1555

constexpr PixelFormat PIXELFORMAT_XBGR1555 =
  SDL_PIXELFORMAT_XBGR1555; ///< XBGR1555

constexpr PixelFormat PIXELFORMAT_ARGB4444 =
  SDL_PIXELFORMAT_ARGB4444; ///< ARGB4444

constexpr PixelFormat PIXELFORMAT_RGBA4444 =
  SDL_PIXELFORMAT_RGBA4444; ///< RGBA4444

constexpr PixelFormat PIXELFORMAT_ABGR4444 =
  SDL_PIXELFORMAT_ABGR4444; ///< ABGR4444

constexpr PixelFormat PIXELFORMAT_BGRA4444 =
  SDL_PIXELFORMAT_BGRA4444; ///< BGRA4444

constexpr PixelFormat PIXELFORMAT_ARGB1555 =
  SDL_PIXELFORMAT_ARGB1555; ///< ARGB1555

constexpr PixelFormat PIXELFORMAT_RGBA5551 =
  SDL_PIXELFORMAT_RGBA5551; ///< RGBA5551

constexpr PixelFormat PIXELFORMAT_ABGR1555 =
  SDL_PIXELFORMAT_ABGR1555; ///< ABGR1555

constexpr PixelFormat PIXELFORMAT_BGRA5551 =
  SDL_PIXELFORMAT_BGRA5551; ///< BGRA5551

constexpr PixelFormat PIXELFORMAT_RGB565 = SDL_PIXELFORMAT_RGB565; ///< RGB565

constexpr PixelFormat PIXELFORMAT_BGR565 = SDL_PIXELFORMAT_BGR565; ///< BGR565

constexpr PixelFormat PIXELFORMAT_RGB24 = SDL_PIXELFORMAT_RGB24; ///< RGB24

constexpr PixelFormat PIXELFORMAT_BGR24 = SDL_PIXELFORMAT_BGR24; ///< BGR24

constexpr PixelFormat PIXELFORMAT_XRGB8888 =
  SDL_PIXELFORMAT_XRGB8888; ///< XRGB8888

constexpr PixelFormat PIXELFORMAT_RGBX8888 =
  SDL_PIXELFORMAT_RGBX8888; ///< RGBX8888

constexpr PixelFormat PIXELFORMAT_XBGR8888 =
  SDL_PIXELFORMAT_XBGR8888; ///< XBGR8888

constexpr PixelFormat PIXELFORMAT_BGRX8888 =
  SDL_PIXELFORMAT_BGRX8888; ///< BGRX8888

constexpr PixelFormat PIXELFORMAT_ARGB8888 =
  SDL_PIXELFORMAT_ARGB8888; ///< ARGB8888

constexpr PixelFormat PIXELFORMAT_RGBA8888 =
  SDL_PIXELFORMAT_RGBA8888; ///< RGBA8888

constexpr PixelFormat PIXELFORMAT_ABGR8888 =
  SDL_PIXELFORMAT_ABGR8888; ///< ABGR8888

constexpr PixelFormat PIXELFORMAT_BGRA8888 =
  SDL_PIXELFORMAT_BGRA8888; ///< BGRA8888

constexpr PixelFormat PIXELFORMAT_XRGB2101010 =
  SDL_PIXELFORMAT_XRGB2101010; ///< XRGB2101010

constexpr PixelFormat PIXELFORMAT_XBGR2101010 =
  SDL_PIXELFORMAT_XBGR2101010; ///< XBGR2101010

constexpr PixelFormat PIXELFORMAT_ARGB2101010 =
  SDL_PIXELFORMAT_ARGB2101010; ///< ARGB2101010

constexpr PixelFormat PIXELFORMAT_ABGR2101010 =
  SDL_PIXELFORMAT_ABGR2101010; ///< ABGR2101010

constexpr PixelFormat PIXELFORMAT_RGB48 = SDL_PIXELFORMAT_RGB48; ///< RGB48

constexpr PixelFormat PIXELFORMAT_BGR48 = SDL_PIXELFORMAT_BGR48; ///< BGR48

constexpr PixelFormat PIXELFORMAT_RGBA64 = SDL_PIXELFORMAT_RGBA64; ///< RGBA64

constexpr PixelFormat PIXELFORMAT_ARGB64 = SDL_PIXELFORMAT_ARGB64; ///< ARGB64

constexpr PixelFormat PIXELFORMAT_BGRA64 = SDL_PIXELFORMAT_BGRA64; ///< BGRA64

constexpr PixelFormat PIXELFORMAT_ABGR64 = SDL_PIXELFORMAT_ABGR64; ///< ABGR64

constexpr PixelFormat PIXELFORMAT_RGB48_FLOAT =
  SDL_PIXELFORMAT_RGB48_FLOAT; ///< RGB48_FLOAT

constexpr PixelFormat PIXELFORMAT_BGR48_FLOAT =
  SDL_PIXELFORMAT_BGR48_FLOAT; ///< BGR48_FLOAT

constexpr PixelFormat PIXELFORMAT_RGBA64_FLOAT =
  SDL_PIXELFORMAT_RGBA64_FLOAT; ///< RGBA64_FLOAT

constexpr PixelFormat PIXELFORMAT_ARGB64_FLOAT =
  SDL_PIXELFORMAT_ARGB64_FLOAT; ///< ARGB64_FLOAT

constexpr PixelFormat PIXELFORMAT_BGRA64_FLOAT =
  SDL_PIXELFORMAT_BGRA64_FLOAT; ///< BGRA64_FLOAT

constexpr PixelFormat PIXELFORMAT_ABGR64_FLOAT =
  SDL_PIXELFORMAT_ABGR64_FLOAT; ///< ABGR64_FLOAT

constexpr PixelFormat PIXELFORMAT_RGB96_FLOAT =
  SDL_PIXELFORMAT_RGB96_FLOAT; ///< RGB96_FLOAT

constexpr PixelFormat PIXELFORMAT_BGR96_FLOAT =
  SDL_PIXELFORMAT_BGR96_FLOAT; ///< BGR96_FLOAT

constexpr PixelFormat PIXELFORMAT_RGBA128_FLOAT =
  SDL_PIXELFORMAT_RGBA128_FLOAT; ///< RGBA128_FLOAT

constexpr PixelFormat PIXELFORMAT_ARGB128_FLOAT =
  SDL_PIXELFORMAT_ARGB128_FLOAT; ///< ARGB128_FLOAT

constexpr PixelFormat PIXELFORMAT_BGRA128_FLOAT =
  SDL_PIXELFORMAT_BGRA128_FLOAT; ///< BGRA128_FLOAT

constexpr PixelFormat PIXELFORMAT_ABGR128_FLOAT =
  SDL_PIXELFORMAT_ABGR128_FLOAT; ///< ABGR128_FLOAT

constexpr PixelFormat PIXELFORMAT_YV12 =
  SDL_PIXELFORMAT_YV12; ///< Planar mode: Y + V + U (3 planes)

constexpr PixelFormat PIXELFORMAT_IYUV =
  SDL_PIXELFORMAT_IYUV; ///< Planar mode: Y + U + V (3 planes)

constexpr PixelFormat PIXELFORMAT_YUY2 =
  SDL_PIXELFORMAT_YUY2; ///< Packed mode: Y0+U0+Y1+V0 (1 plane)

constexpr PixelFormat PIXELFORMAT_UYVY =
  SDL_PIXELFORMAT_UYVY; ///< Packed mode: U0+Y0+V0+Y1 (1 plane)

constexpr PixelFormat PIXELFORMAT_YVYU =
  SDL_PIXELFORMAT_YVYU; ///< Packed mode: Y0+V0+Y1+U0 (1 plane)

constexpr PixelFormat PIXELFORMAT_NV12 =
  SDL_PIXELFORMAT_NV12; ///< Planar mode: Y + U/V interleaved (2 planes)

constexpr PixelFormat PIXELFORMAT_NV21 =
  SDL_PIXELFORMAT_NV21; ///< Planar mode: Y + V/U interleaved (2 planes)

constexpr PixelFormat PIXELFORMAT_P010 =
  SDL_PIXELFORMAT_P010; ///< Planar mode: Y + U/V interleaved (2 planes)

constexpr PixelFormat PIXELFORMAT_EXTERNAL_OES =
  SDL_PIXELFORMAT_EXTERNAL_OES; ///< Android video texture format.

#if SDL_VERSION_ATLEAST(3, 2, 10)

constexpr PixelFormat PIXELFORMAT_MJPG = SDL_PIXELFORMAT_MJPG; ///< Motion JPEG.

#endif // SDL_VERSION_ATLEAST(3, 2, 10)

constexpr PixelFormat PIXELFORMAT_RGBA32 = SDL_PIXELFORMAT_RGBA32; ///< RGBA32

constexpr PixelFormat PIXELFORMAT_ARGB32 = SDL_PIXELFORMAT_ARGB32; ///< ARGB32

constexpr PixelFormat PIXELFORMAT_BGRA32 = SDL_PIXELFORMAT_BGRA32; ///< BGRA32

constexpr PixelFormat PIXELFORMAT_ABGR32 = SDL_PIXELFORMAT_ABGR32; ///< ABGR32

constexpr PixelFormat PIXELFORMAT_RGBX32 = SDL_PIXELFORMAT_RGBX32; ///< RGBX32

constexpr PixelFormat PIXELFORMAT_XRGB32 = SDL_PIXELFORMAT_XRGB32; ///< XRGB32

constexpr PixelFormat PIXELFORMAT_BGRX32 = SDL_PIXELFORMAT_BGRX32; ///< BGRX32

constexpr PixelFormat PIXELFORMAT_XBGR32 = SDL_PIXELFORMAT_XBGR32; ///< XBGR32

/// @}

/**
 * A macro for defining custom non-FourCC pixel formats.
 *
 * For example, defining PIXELFORMAT_RGBA8888 looks like this:
 *
 * ```c
 * PixelFormat.PixelFormat(PIXELTYPE_PACKED32, PACKEDORDER_RGBA,
 * PACKEDLAYOUT_8888, 32, 4)
 * ```
 *
 * @param type the type of the new format, probably a PixelType value.
 * @param order the order of the new format, probably a BitmapOrder,
 *              PackedOrder, or ArrayOrder value.
 * @param layout the layout of the new format, probably an PackedLayout
 *               value or zero.
 * @param bits the number of bits per pixel of the new format.
 * @param bytes the number of bytes per pixel of the new format.
 * @returns a format value in the style of PixelFormat.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr PixelFormat DEFINE_PIXELFORMAT(PixelType type,
                                         int order,
                                         PackedLayout layout,
                                         int bits,
                                         int bytes)
{
  return PixelFormat(type, order, layout, bits, bytes);
}

/**
 * Retrieve the flags of an PixelFormat.
 *
 * This function is generally not needed directly by an app, which should use
 * specific tests, like PixelFormat.IsFourCC, instead.
 *
 * @param format an PixelFormat to check.
 * @returns the flags of `format`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
constexpr Uint8 PIXELFLAG(PixelFormatRaw format)
{
  return SDL_PIXELFLAG(format);
}

constexpr Uint8 PixelFormat::GetFlags() const
{
  return SDL::PIXELFLAG(m_format);
}

/**
 * A macro to retrieve the type of an PixelFormat.
 *
 * This is usually a value from the PixelType enumeration.
 *
 * @param format an PixelFormat to check.
 * @returns the type of `format`.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr PixelType PIXELTYPE(PixelFormatRaw format)
{
  return PixelType(SDL_PIXELTYPE(format));
}

constexpr PixelType PixelFormat::GetType() const
{
  return SDL::PIXELTYPE(m_format);
}

/**
 * A macro to retrieve the order of an PixelFormat.
 *
 * This is usually a value from the BitmapOrder, PackedOrder, or
 * ArrayOrder enumerations, depending on the format type.
 *
 * @param format an PixelFormat to check.
 * @returns the order of `format`.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr int PIXELORDER(PixelFormatRaw format)
{
  return SDL_PIXELORDER(format);
}

constexpr int PixelFormat::GetOrder() const
{
  return SDL::PIXELORDER(m_format);
}

/**
 * A macro to retrieve the layout of an PixelFormat.
 *
 * This is usually a value from the PackedLayout enumeration, or zero if a
 * layout doesn't make sense for the format type.
 *
 * @param format an PixelFormat to check.
 * @returns the layout of `format`.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr PackedLayout PIXELLAYOUT(PixelFormatRaw format)
{
  return PackedLayout(SDL_PIXELLAYOUT(format));
}

constexpr PackedLayout PixelFormat::GetLayout() const
{
  return SDL::PIXELLAYOUT(m_format);
}

/**
 * A macro to determine an PixelFormat's bits per pixel.
 *
 * Note that this macro double-evaluates its parameter, so do not use
 * expressions with side-effects here.
 *
 * FourCC formats will report zero here, as it rarely makes sense to measure
 * them per-pixel.
 *
 * @param format an PixelFormat to check.
 * @returns the bits-per-pixel of `format`.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 *
 * @sa PixelFormat.GetBytesPerPixel
 */
constexpr int BITSPERPIXEL(PixelFormatRaw format)
{
  return SDL_BITSPERPIXEL(format);
}

constexpr int PixelFormat::GetBitsPerPixel() const
{
  return SDL::BITSPERPIXEL(m_format);
}

/**
 * A macro to determine an PixelFormat's bytes per pixel.
 *
 * Note that this macro double-evaluates its parameter, so do not use
 * expressions with side-effects here.
 *
 * FourCC formats do their best here, but many of them don't have a meaningful
 * measurement of bytes per pixel.
 *
 * @param format an PixelFormat to check.
 * @returns the bytes-per-pixel of `format`.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 *
 * @sa PixelFormat.GetBitsPerPixel
 */
constexpr int BYTESPERPIXEL(PixelFormatRaw format)
{
  return SDL_BYTESPERPIXEL(format);
}

constexpr int PixelFormat::GetBytesPerPixel() const
{
  return SDL::BYTESPERPIXEL(m_format);
}

/**
 * A macro to determine if an PixelFormat is an indexed format.
 *
 * Note that this macro double-evaluates its parameter, so do not use
 * expressions with side-effects here.
 *
 * @param format an PixelFormat to check.
 * @returns true if the format is indexed, false otherwise.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr bool ISPIXELFORMAT_INDEXED(PixelFormatRaw format)
{
  return SDL_ISPIXELFORMAT_INDEXED(format);
}

constexpr bool PixelFormat::IsIndexed() const
{
  return SDL::ISPIXELFORMAT_INDEXED(m_format);
}

/**
 * A macro to determine if an PixelFormat is a packed format.
 *
 * Note that this macro double-evaluates its parameter, so do not use
 * expressions with side-effects here.
 *
 * @param format an PixelFormat to check.
 * @returns true if the format is packed, false otherwise.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr bool ISPIXELFORMAT_PACKED(PixelFormatRaw format)
{
  return SDL_ISPIXELFORMAT_PACKED(format);
}

constexpr bool PixelFormat::IsPacked() const
{
  return SDL::ISPIXELFORMAT_PACKED(m_format);
}

/**
 * A macro to determine if an PixelFormat is an array format.
 *
 * Note that this macro double-evaluates its parameter, so do not use
 * expressions with side-effects here.
 *
 * @param format an PixelFormat to check.
 * @returns true if the format is an array, false otherwise.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr bool ISPIXELFORMAT_ARRAY(PixelFormatRaw format)
{
  return SDL_ISPIXELFORMAT_ARRAY(format);
}

constexpr bool PixelFormat::IsArray() const
{
  return SDL::ISPIXELFORMAT_ARRAY(m_format);
}

/**
 * A macro to determine if an PixelFormat is a 10-bit format.
 *
 * Note that this macro double-evaluates its parameter, so do not use
 * expressions with side-effects here.
 *
 * @param format an PixelFormat to check.
 * @returns true if the format is 10-bit, false otherwise.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr bool ISPIXELFORMAT_10BIT(PixelFormatRaw format)
{
  return SDL_ISPIXELFORMAT_10BIT(format);
}

constexpr bool PixelFormat::Is10Bit() const
{
  return SDL::ISPIXELFORMAT_10BIT(m_format);
}

/**
 * A macro to determine if an PixelFormat is a floating point format.
 *
 * Note that this macro double-evaluates its parameter, so do not use
 * expressions with side-effects here.
 *
 * @param format an PixelFormat to check.
 * @returns true if the format is 10-bit, false otherwise.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr bool ISPIXELFORMAT_FLOAT(PixelFormatRaw format)
{
  return SDL_ISPIXELFORMAT_FLOAT(format);
}

constexpr bool PixelFormat::IsFloat() const
{
  return SDL::ISPIXELFORMAT_FLOAT(m_format);
}

/**
 * @name ColorTypes
 * @{
 */

/**
 * A macro to determine if an PixelFormat has an alpha channel.
 *
 * Note that this macro double-evaluates its parameter, so do not use
 * expressions with side-effects here.
 *
 * @param format an PixelFormat to check.
 * @returns true if the format has alpha, false otherwise.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr bool ISPIXELFORMAT_ALPHA(PixelFormatRaw format)
{
  return SDL_ISPIXELFORMAT_ALPHA(format);
}

constexpr bool PixelFormat::IsAlpha() const
{
  return SDL::ISPIXELFORMAT_ALPHA(m_format);
}

/**
 * A macro to determine if an PixelFormat is a "FourCC" format.
 *
 * This covers custom and other unusual formats.
 *
 * Note that this macro double-evaluates its parameter, so do not use
 * expressions with side-effects here.
 *
 * @param format an PixelFormat to check.
 * @returns true if the format has alpha, false otherwise.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr bool ISPIXELFORMAT_FOURCC(PixelFormatRaw format)
{
  return SDL_ISPIXELFORMAT_FOURCC(format);
}

constexpr bool PixelFormat::IsFourCC() const
{
  return SDL::ISPIXELFORMAT_FOURCC(m_format);
}

/**
 * Colorspace color type.
 *
 * @since This enum is available since SDL 3.2.0.
 */
using ColorType = SDL_ColorType;

constexpr ColorType COLOR_TYPE_UNKNOWN =
  SDL_COLOR_TYPE_UNKNOWN; ///< COLOR_TYPE_UNKNOWN

constexpr ColorType COLOR_TYPE_RGB = SDL_COLOR_TYPE_RGB; ///< COLOR_TYPE_RGB

constexpr ColorType COLOR_TYPE_YCBCR =
  SDL_COLOR_TYPE_YCBCR; ///< COLOR_TYPE_YCBCR

/// @}

/**
 * @name ColorRanges
 * @{
 */

/**
 * Colorspace color range, as described by
 * https://www.itu.int/rec/R-REC-BT.2100-2-201807-I/en
 *
 * @since This enum is available since SDL 3.2.0.
 */
using ColorRange = SDL_ColorRange;

constexpr ColorRange COLOR_RANGE_UNKNOWN =
  SDL_COLOR_RANGE_UNKNOWN; ///< COLOR_RANGE_UNKNOWN

/**
 * Narrow range, e.g. 16-235 for 8-bit RGB and luma, and 16-240 for 8-bit chroma
 */
constexpr ColorRange COLOR_RANGE_LIMITED = SDL_COLOR_RANGE_LIMITED;

/// Full range, e.g. 0-255 for 8-bit RGB and luma, and 1-255 for 8-bit chroma
constexpr ColorRange COLOR_RANGE_FULL = SDL_COLOR_RANGE_FULL;

/// @}

/**
 * @name ColorPrimaries
 * @{
 */

/**
 * Colorspace color primaries, as described by
 * https://www.itu.int/rec/T-REC-H.273-201612-S/en
 *
 * @since This enum is available since SDL 3.2.0.
 */
using ColorPrimaries = SDL_ColorPrimaries;

constexpr ColorPrimaries COLOR_PRIMARIES_UNKNOWN =
  SDL_COLOR_PRIMARIES_UNKNOWN; ///< COLOR_PRIMARIES_UNKNOWN

constexpr ColorPrimaries COLOR_PRIMARIES_BT709 =
  SDL_COLOR_PRIMARIES_BT709; ///< ITU-R BT.709-6.

constexpr ColorPrimaries COLOR_PRIMARIES_UNSPECIFIED =
  SDL_COLOR_PRIMARIES_UNSPECIFIED; ///< COLOR_PRIMARIES_UNSPECIFIED

constexpr ColorPrimaries COLOR_PRIMARIES_BT470M =
  SDL_COLOR_PRIMARIES_BT470M; ///< ITU-R BT.470-6 System M.

constexpr ColorPrimaries COLOR_PRIMARIES_BT470BG =
  SDL_COLOR_PRIMARIES_BT470BG; ///< ITU-R BT.470-6 System B, G / ITU-R BT.601-7
                               ///< 625.

constexpr ColorPrimaries COLOR_PRIMARIES_BT601 =
  SDL_COLOR_PRIMARIES_BT601; ///< ITU-R BT.601-7 525, SMPTE 170M.

/// SMPTE 240M, functionally the same as COLOR_PRIMARIES_BT601.
constexpr ColorPrimaries COLOR_PRIMARIES_SMPTE240 =
  SDL_COLOR_PRIMARIES_SMPTE240;

constexpr ColorPrimaries COLOR_PRIMARIES_GENERIC_FILM =
  SDL_COLOR_PRIMARIES_GENERIC_FILM; ///< Generic film (color filters using
                                    ///< Illuminant C)

constexpr ColorPrimaries COLOR_PRIMARIES_BT2020 =
  SDL_COLOR_PRIMARIES_BT2020; ///< ITU-R BT.2020-2 / ITU-R BT.2100-0.

constexpr ColorPrimaries COLOR_PRIMARIES_XYZ =
  SDL_COLOR_PRIMARIES_XYZ; ///< SMPTE ST 428-1.

constexpr ColorPrimaries COLOR_PRIMARIES_SMPTE431 =
  SDL_COLOR_PRIMARIES_SMPTE431; ///< SMPTE RP 431-2.

constexpr ColorPrimaries COLOR_PRIMARIES_SMPTE432 =
  SDL_COLOR_PRIMARIES_SMPTE432; ///< SMPTE EG 432-1 / DCI P3.

constexpr ColorPrimaries COLOR_PRIMARIES_EBU3213 =
  SDL_COLOR_PRIMARIES_EBU3213; ///< EBU Tech.  3213-E

constexpr ColorPrimaries COLOR_PRIMARIES_CUSTOM =
  SDL_COLOR_PRIMARIES_CUSTOM; ///< COLOR_PRIMARIES_CUSTOM

/// @}

/**
 * @name TransferCharacteristics
 * @{
 */

/**
 * Colorspace transfer characteristics.
 *
 * These are as described by https://www.itu.int/rec/T-REC-H.273-201612-S/en
 *
 * @since This enum is available since SDL 3.2.0.
 */
using TransferCharacteristics = SDL_TransferCharacteristics;

constexpr TransferCharacteristics TRANSFER_CHARACTERISTICS_UNKNOWN =
  SDL_TRANSFER_CHARACTERISTICS_UNKNOWN; ///< TRANSFER_CHARACTERISTICS_UNKNOWN

constexpr TransferCharacteristics TRANSFER_CHARACTERISTICS_BT709 =
  SDL_TRANSFER_CHARACTERISTICS_BT709; ///< Rec.  ITU-R BT.709-6 / ITU-R BT1361

constexpr TransferCharacteristics TRANSFER_CHARACTERISTICS_UNSPECIFIED =
  SDL_TRANSFER_CHARACTERISTICS_UNSPECIFIED; ///< TRANSFER_CHARACTERISTICS_UNSPECIFIED

/// ITU-R BT.470-6 System M / ITU-R BT1700 625 PAL & SECAM.
constexpr TransferCharacteristics TRANSFER_CHARACTERISTICS_GAMMA22 =
  SDL_TRANSFER_CHARACTERISTICS_GAMMA22;

constexpr TransferCharacteristics TRANSFER_CHARACTERISTICS_GAMMA28 =
  SDL_TRANSFER_CHARACTERISTICS_GAMMA28; ///< ITU-R BT.470-6 System B, G.

constexpr TransferCharacteristics TRANSFER_CHARACTERISTICS_BT601 =
  SDL_TRANSFER_CHARACTERISTICS_BT601; ///< SMPTE ST 170M / ITU-R BT.601-7 525 or
                                      ///< 625.

constexpr TransferCharacteristics TRANSFER_CHARACTERISTICS_SMPTE240 =
  SDL_TRANSFER_CHARACTERISTICS_SMPTE240; ///< SMPTE ST 240M.

constexpr TransferCharacteristics TRANSFER_CHARACTERISTICS_LINEAR =
  SDL_TRANSFER_CHARACTERISTICS_LINEAR; ///< TRANSFER_CHARACTERISTICS_LINEAR

constexpr TransferCharacteristics TRANSFER_CHARACTERISTICS_LOG100 =
  SDL_TRANSFER_CHARACTERISTICS_LOG100; ///< TRANSFER_CHARACTERISTICS_LOG100

constexpr TransferCharacteristics TRANSFER_CHARACTERISTICS_LOG100_SQRT10 =
  SDL_TRANSFER_CHARACTERISTICS_LOG100_SQRT10; ///< TRANSFER_CHARACTERISTICS_LOG100_SQRT10

constexpr TransferCharacteristics TRANSFER_CHARACTERISTICS_IEC61966 =
  SDL_TRANSFER_CHARACTERISTICS_IEC61966; ///< IEC 61966-2-4.

constexpr TransferCharacteristics TRANSFER_CHARACTERISTICS_BT1361 =
  SDL_TRANSFER_CHARACTERISTICS_BT1361; ///< ITU-R BT1361 Extended Colour Gamut.

constexpr TransferCharacteristics TRANSFER_CHARACTERISTICS_SRGB =
  SDL_TRANSFER_CHARACTERISTICS_SRGB; ///< IEC 61966-2-1 (sRGB or sYCC)

constexpr TransferCharacteristics TRANSFER_CHARACTERISTICS_BT2020_10BIT =
  SDL_TRANSFER_CHARACTERISTICS_BT2020_10BIT; ///< ITU-R BT2020 for 10-bit
                                             ///< system.

constexpr TransferCharacteristics TRANSFER_CHARACTERISTICS_BT2020_12BIT =
  SDL_TRANSFER_CHARACTERISTICS_BT2020_12BIT; ///< ITU-R BT2020 for 12-bit
                                             ///< system.

/// SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems.
constexpr TransferCharacteristics TRANSFER_CHARACTERISTICS_PQ =
  SDL_TRANSFER_CHARACTERISTICS_PQ;

constexpr TransferCharacteristics TRANSFER_CHARACTERISTICS_SMPTE428 =
  SDL_TRANSFER_CHARACTERISTICS_SMPTE428; ///< SMPTE ST 428-1.

constexpr TransferCharacteristics TRANSFER_CHARACTERISTICS_HLG =
  SDL_TRANSFER_CHARACTERISTICS_HLG; ///< ARIB STD-B67, known as "hybrid
                                    ///< log-gamma" (HLG)

constexpr TransferCharacteristics TRANSFER_CHARACTERISTICS_CUSTOM =
  SDL_TRANSFER_CHARACTERISTICS_CUSTOM; ///< TRANSFER_CHARACTERISTICS_CUSTOM

/// @}

/**
 * @name MatrixCoefficients
 * @{
 */

/**
 * Colorspace matrix coefficients.
 *
 * These are as described by https://www.itu.int/rec/T-REC-H.273-201612-S/en
 *
 * @since This enum is available since SDL 3.2.0.
 */
using MatrixCoefficients = SDL_MatrixCoefficients;

constexpr MatrixCoefficients MATRIX_COEFFICIENTS_IDENTITY =
  SDL_MATRIX_COEFFICIENTS_IDENTITY; ///< MATRIX_COEFFICIENTS_IDENTITY

constexpr MatrixCoefficients MATRIX_COEFFICIENTS_BT709 =
  SDL_MATRIX_COEFFICIENTS_BT709; ///< ITU-R BT.709-6.

constexpr MatrixCoefficients MATRIX_COEFFICIENTS_UNSPECIFIED =
  SDL_MATRIX_COEFFICIENTS_UNSPECIFIED; ///< MATRIX_COEFFICIENTS_UNSPECIFIED

constexpr MatrixCoefficients MATRIX_COEFFICIENTS_FCC =
  SDL_MATRIX_COEFFICIENTS_FCC; ///< US FCC Title 47.

/**
 * ITU-R BT.470-6 System B, G / ITU-R BT.601-7 625, functionally the same as
 * MATRIX_COEFFICIENTS_BT601.
 */
constexpr MatrixCoefficients MATRIX_COEFFICIENTS_BT470BG =
  SDL_MATRIX_COEFFICIENTS_BT470BG;

constexpr MatrixCoefficients MATRIX_COEFFICIENTS_BT601 =
  SDL_MATRIX_COEFFICIENTS_BT601; ///< ITU-R BT.601-7 525.

constexpr MatrixCoefficients MATRIX_COEFFICIENTS_SMPTE240 =
  SDL_MATRIX_COEFFICIENTS_SMPTE240; ///< SMPTE 240M.

constexpr MatrixCoefficients MATRIX_COEFFICIENTS_YCGCO =
  SDL_MATRIX_COEFFICIENTS_YCGCO; ///< MATRIX_COEFFICIENTS_YCGCO

constexpr MatrixCoefficients MATRIX_COEFFICIENTS_BT2020_NCL =
  SDL_MATRIX_COEFFICIENTS_BT2020_NCL; ///< ITU-R BT.2020-2 non-constant
                                      ///< luminance.

constexpr MatrixCoefficients MATRIX_COEFFICIENTS_BT2020_CL =
  SDL_MATRIX_COEFFICIENTS_BT2020_CL; ///< ITU-R BT.2020-2 constant luminance.

constexpr MatrixCoefficients MATRIX_COEFFICIENTS_SMPTE2085 =
  SDL_MATRIX_COEFFICIENTS_SMPTE2085; ///< SMPTE ST 2085.

constexpr MatrixCoefficients MATRIX_COEFFICIENTS_CHROMA_DERIVED_NCL =
  SDL_MATRIX_COEFFICIENTS_CHROMA_DERIVED_NCL; ///< MATRIX_COEFFICIENTS_CHROMA_DERIVED_NCL

constexpr MatrixCoefficients MATRIX_COEFFICIENTS_CHROMA_DERIVED_CL =
  SDL_MATRIX_COEFFICIENTS_CHROMA_DERIVED_CL; ///< MATRIX_COEFFICIENTS_CHROMA_DERIVED_CL

constexpr MatrixCoefficients MATRIX_COEFFICIENTS_ICTCP =
  SDL_MATRIX_COEFFICIENTS_ICTCP; ///< ITU-R BT.2100-0 ICTCP.

constexpr MatrixCoefficients MATRIX_COEFFICIENTS_CUSTOM =
  SDL_MATRIX_COEFFICIENTS_CUSTOM; ///< MATRIX_COEFFICIENTS_CUSTOM

/// @}

/**
 * @name ChromaLocations
 * @{
 */

/**
 * Colorspace chroma sample location.
 *
 * @since This enum is available since SDL 3.2.0.
 */
using ChromaLocation = SDL_ChromaLocation;

constexpr ChromaLocation CHROMA_LOCATION_NONE =
  SDL_CHROMA_LOCATION_NONE; ///< RGB, no chroma sampling.

/**
 * In MPEG-2, MPEG-4, and AVC, Cb and Cr are taken on midpoint of the left-edge
 * of the 2x2 square. In other words, they have the same horizontal location as
 * the top-left pixel, but is shifted one-half pixel down vertically.
 */
constexpr ChromaLocation CHROMA_LOCATION_LEFT = SDL_CHROMA_LOCATION_LEFT;

/**
 * In JPEG/JFIF, H.261, and MPEG-1, Cb and Cr are taken at the center of the 2x2
 * square. In other words, they are offset one-half pixel to the right and
 * one-half pixel down compared to the top-left pixel.
 */
constexpr ChromaLocation CHROMA_LOCATION_CENTER = SDL_CHROMA_LOCATION_CENTER;

/**
 * In HEVC for BT.2020 and BT.2100 content (in particular on Blu-rays), Cb and
 * Cr are sampled at the same location as the group's top-left Y pixel
 * ("co-sited", "co-located").
 */
constexpr ChromaLocation CHROMA_LOCATION_TOPLEFT = SDL_CHROMA_LOCATION_TOPLEFT;

/// @}

/**
 * @name Colorspaces
 * @{
 */

/**
 * Colorspace definitions.
 *
 * Since similar colorspaces may vary in their details (matrix, transfer
 * function, etc.), this is not an exhaustive list, but rather a
 * representative sample of the kinds of colorspaces supported in SDL.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @cat wrap-state
 *
 * @sa Colorspaces
 * @sa ColorPrimaries
 * @sa ColorRange
 * @sa ColorType
 * @sa MatrixCoefficients
 * @sa TransferCharacteristics
 */
class Colorspace
{
  ColorspaceRaw m_cspace;

public:
  /**
   * Wraps Colorspace.
   *
   * @param cspace the value to be wrapped
   */
  constexpr Colorspace(ColorspaceRaw cspace = {})
    : m_cspace(cspace)
  {
  }

  /**
   * Define custom Colorspace formats.
   *
   * For example, defining COLORSPACE_SRGB looks like this:
   *
   * ```cpp
   * Colorspace colorspace(COLOR_TYPE_RGB,
   *                       COLOR_RANGE_FULL,
   *                       COLOR_PRIMARIES_BT709,
   *                       TRANSFER_CHARACTERISTICS_SRGB,
   *                       MATRIX_COEFFICIENTS_IDENTITY,
   *                       CHROMA_LOCATION_NONE)
   * ```
   *
   * @param type the type of the new format, probably an ColorType value.
   * @param range the range of the new format, probably a ColorRange value.
   * @param primaries the primaries of the new format, probably an
   *                  ColorPrimaries value.
   * @param transfer the transfer characteristics of the new format, probably an
   *                 TransferCharacteristics value.
   * @param matrix the matrix coefficients of the new format, probably an
   *               MatrixCoefficients value.
   * @param chroma the chroma sample location of the new format, probably an
   *               ChromaLocation value.
   * @post a format value in the style of Colorspace.
   *
   * @threadsafety It is safe to call this macro from any thread.
   *
   * @since This macro is available since SDL 3.2.0.
   */
  constexpr Colorspace(ColorType type,
                       ColorRange range,
                       ColorPrimaries primaries,
                       TransferCharacteristics transfer,
                       MatrixCoefficients matrix,
                       ChromaLocation chroma)
    : m_cspace(ColorspaceRaw(SDL_DEFINE_COLORSPACE(type,
                                                   range,
                                                   primaries,
                                                   transfer,
                                                   matrix,
                                                   chroma)))
  {
  }

  /// Default comparison operator
  constexpr bool operator==(const Colorspace& other) const = default;

  /// Compares with the underlying type
  constexpr bool operator==(ColorspaceRaw cspace) const
  {
    return operator==(Colorspace(cspace));
  }

  /**
   * Unwraps to the underlying Colorspace.
   *
   * @returns the underlying ColorspaceRaw.
   */
  constexpr operator ColorspaceRaw() const { return m_cspace; }

  /**
   * Check if valid.
   *
   * @returns True if valid state, false otherwise.
   */
  constexpr explicit operator bool() const { return m_cspace != 0; }

  /**
   * Retrieve the type of a Colorspace.
   *
   * @returns the ColorType for `cspace`.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr ColorType GetType() const;

  /**
   * Retrieve the range of a Colorspace.
   *
   * @returns the ColorRange of `cspace`.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr ColorRange GetRange() const;

  /**
   * Retrieve the chroma sample location of an Colorspace.
   *
   * @returns the ChromaLocation of `cspace`.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr ChromaLocation GetChroma() const;

  /**
   * Retrieve the primaries of an Colorspace.
   *
   * @returns the ColorPrimaries of `cspace`.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr ColorPrimaries GetPrimaries() const;

  /**
   * Retrieve the transfer characteristics of an Colorspace.
   *
   * @returns the TransferCharacteristics of `cspace`.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr TransferCharacteristics GetTransfer() const;

  /**
   * Retrieve the matrix coefficients of an Colorspace.
   *
   * @returns the MatrixCoefficients of `cspace`.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr MatrixCoefficients GetMatrix() const;

  /**
   * Determine if a Colorspace uses BT601 (or BT470BG) matrix coefficients.
   *
   * @returns true if BT601 or BT470BG, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool IsMatrixBT601() const;

  /**
   * Determine if an Colorspace uses BT709 matrix coefficients.
   *
   * @returns true if BT709, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool IsMatrixBT709() const;

  /**
   * Determine if an Colorspace uses BT2020_NCL matrix coefficients.
   *
   * @returns true if BT2020_NCL, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool IsMatrixBT2020_NCL() const;

  /**
   * A function to determine if an Colorspace has a limited range.
   *
   * @returns true if limited range, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool IsLimitedRange() const;

  /**
   * A function to determine if an Colorspace has a full range.
   *
   * @returns true if full range, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool IsFullRange() const;
};

constexpr Colorspace COLORSPACE_UNKNOWN = SDL_COLORSPACE_UNKNOWN; ///< UNKNOWN

/// Equivalent to DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709.
constexpr Colorspace COLORSPACE_SRGB = SDL_COLORSPACE_SRGB;

constexpr Colorspace COLORSPACE_SRGB_LINEAR =
  SDL_COLORSPACE_SRGB_LINEAR; ///< [object Object]

constexpr Colorspace COLORSPACE_HDR10 =
  SDL_COLORSPACE_HDR10; ///< [object Object]

/// Equivalent to DXGI_COLOR_SPACE_YCBCR_FULL_G22_NONE_P709_X601.
constexpr Colorspace COLORSPACE_JPEG = SDL_COLORSPACE_JPEG;

/// Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601.
constexpr Colorspace COLORSPACE_BT601_LIMITED = SDL_COLORSPACE_BT601_LIMITED;

/// Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601.
constexpr Colorspace COLORSPACE_BT601_FULL = SDL_COLORSPACE_BT601_FULL;

/// Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709.
constexpr Colorspace COLORSPACE_BT709_LIMITED = SDL_COLORSPACE_BT709_LIMITED;

/// Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709.
constexpr Colorspace COLORSPACE_BT709_FULL = SDL_COLORSPACE_BT709_FULL;

/// Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P2020.
constexpr Colorspace COLORSPACE_BT2020_LIMITED = SDL_COLORSPACE_BT2020_LIMITED;

/// Equivalent to DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P2020.
constexpr Colorspace COLORSPACE_BT2020_FULL = SDL_COLORSPACE_BT2020_FULL;

/// The default colorspace for RGB surfaces if no colorspace is specified.
constexpr Colorspace COLORSPACE_RGB_DEFAULT = SDL_COLORSPACE_RGB_DEFAULT;

/// The default colorspace for YUV surfaces if no colorspace is specified.
constexpr Colorspace COLORSPACE_YUV_DEFAULT = SDL_COLORSPACE_YUV_DEFAULT;

/// @}

/**
 * A macro for defining custom Colorspace formats.
 *
 * For example, defining COLORSPACE_SRGB looks like this:
 *
 * ```c
 * Colorspace.Colorspace(COLOR_TYPE_RGB,
 *                       COLOR_RANGE_FULL,
 *                       COLOR_PRIMARIES_BT709,
 *                       TRANSFER_CHARACTERISTICS_SRGB,
 *                       MATRIX_COEFFICIENTS_IDENTITY,
 *                       CHROMA_LOCATION_NONE)
 * ```
 *
 * @param type the type of the new format, probably an ColorType value.
 * @param range the range of the new format, probably a ColorRange value.
 * @param primaries the primaries of the new format, probably an
 *                  ColorPrimaries value.
 * @param transfer the transfer characteristics of the new format, probably an
 *                 TransferCharacteristics value.
 * @param matrix the matrix coefficients of the new format, probably an
 *               MatrixCoefficients value.
 * @param chroma the chroma sample location of the new format, probably an
 *               ChromaLocation value.
 * @returns a format value in the style of Colorspace.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr Colorspace DEFINE_COLORSPACE(ColorType type,
                                       ColorRange range,
                                       ColorPrimaries primaries,
                                       TransferCharacteristics transfer,
                                       MatrixCoefficients matrix,
                                       ChromaLocation chroma)
{
  return Colorspace(type, range, primaries, transfer, matrix, chroma);
}

/**
 * A macro to retrieve the type of an Colorspace.
 *
 * @param cspace an Colorspace to check.
 * @returns the ColorType for `cspace`.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr ColorType COLORSPACETYPE(ColorspaceRaw cspace)
{
  return SDL_COLORSPACETYPE(cspace);
}

constexpr ColorType Colorspace::GetType() const
{
  return SDL::COLORSPACETYPE(m_cspace);
}

/**
 * A macro to retrieve the range of an Colorspace.
 *
 * @param cspace an Colorspace to check.
 * @returns the ColorRange of `cspace`.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr ColorRange COLORSPACERANGE(ColorspaceRaw cspace)
{
  return SDL_COLORSPACERANGE(cspace);
}

constexpr ColorRange Colorspace::GetRange() const
{
  return SDL::COLORSPACERANGE(m_cspace);
}

/**
 * A macro to retrieve the chroma sample location of an Colorspace.
 *
 * @param cspace an Colorspace to check.
 * @returns the ChromaLocation of `cspace`.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr ChromaLocation COLORSPACECHROMA(ColorspaceRaw cspace)
{
  return SDL_COLORSPACECHROMA(cspace);
}

constexpr ChromaLocation Colorspace::GetChroma() const
{
  return SDL::COLORSPACECHROMA(m_cspace);
}

/**
 * A macro to retrieve the primaries of an Colorspace.
 *
 * @param cspace an Colorspace to check.
 * @returns the ColorPrimaries of `cspace`.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr ColorPrimaries COLORSPACEPRIMARIES(ColorspaceRaw cspace)
{
  return SDL_COLORSPACEPRIMARIES(cspace);
}

constexpr ColorPrimaries Colorspace::GetPrimaries() const
{
  return SDL::COLORSPACEPRIMARIES(m_cspace);
}

/**
 * A macro to retrieve the transfer characteristics of an Colorspace.
 *
 * @param cspace an Colorspace to check.
 * @returns the TransferCharacteristics of `cspace`.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr TransferCharacteristics COLORSPACETRANSFER(ColorspaceRaw cspace)
{
  return SDL_COLORSPACETRANSFER(cspace);
}

constexpr TransferCharacteristics Colorspace::GetTransfer() const
{
  return SDL::COLORSPACETRANSFER(m_cspace);
}

/**
 * A macro to retrieve the matrix coefficients of an Colorspace.
 *
 * @param cspace an Colorspace to check.
 * @returns the MatrixCoefficients of `cspace`.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr MatrixCoefficients COLORSPACEMATRIX(ColorspaceRaw cspace)
{
  return SDL_COLORSPACEMATRIX(cspace);
}

constexpr MatrixCoefficients Colorspace::GetMatrix() const
{
  return SDL::COLORSPACEMATRIX(m_cspace);
}

/**
 * A macro to determine if an Colorspace uses BT601 (or BT470BG) matrix
 * coefficients.
 *
 * Note that this macro double-evaluates its parameter, so do not use
 * expressions with side-effects here.
 *
 * @param cspace an Colorspace to check.
 * @returns true if BT601 or BT470BG, false otherwise.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr bool ISCOLORSPACE_MATRIX_BT601(ColorspaceRaw cspace)
{
  return SDL_ISCOLORSPACE_MATRIX_BT601(cspace);
}

constexpr bool Colorspace::IsMatrixBT601() const
{
  return SDL::ISCOLORSPACE_MATRIX_BT601(m_cspace);
}

/**
 * A macro to determine if an Colorspace uses BT709 matrix coefficients.
 *
 * @param cspace an Colorspace to check.
 * @returns true if BT709, false otherwise.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr bool ISCOLORSPACE_MATRIX_BT709(ColorspaceRaw cspace)
{
  return SDL_ISCOLORSPACE_MATRIX_BT709(cspace);
}

constexpr bool Colorspace::IsMatrixBT709() const
{
  return SDL::ISCOLORSPACE_MATRIX_BT709(m_cspace);
}

/**
 * A macro to determine if an Colorspace uses BT2020_NCL matrix
 * coefficients.
 *
 * @param cspace an Colorspace to check.
 * @returns true if BT2020_NCL, false otherwise.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr bool ISCOLORSPACE_MATRIX_BT2020_NCL(ColorspaceRaw cspace)
{
  return SDL_ISCOLORSPACE_MATRIX_BT2020_NCL(cspace);
}

constexpr bool Colorspace::IsMatrixBT2020_NCL() const
{
  return SDL::ISCOLORSPACE_MATRIX_BT2020_NCL(m_cspace);
}

/**
 * A macro to determine if an Colorspace has a limited range.
 *
 * @param cspace an Colorspace to check.
 * @returns true if limited range, false otherwise.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr bool ISCOLORSPACE_LIMITED_RANGE(ColorspaceRaw cspace)
{
  return SDL_ISCOLORSPACE_LIMITED_RANGE(cspace);
}

constexpr bool Colorspace::IsLimitedRange() const
{
  return SDL::ISCOLORSPACE_LIMITED_RANGE(m_cspace);
}

/**
 * A macro to determine if an Colorspace has a full range.
 *
 * @param cspace an Colorspace to check.
 * @returns true if full range, false otherwise.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr bool ISCOLORSPACE_FULL_RANGE(ColorspaceRaw cspace)
{
  return SDL_ISCOLORSPACE_FULL_RANGE(cspace);
}

constexpr bool Colorspace::IsFullRange() const
{
  return SDL::ISCOLORSPACE_FULL_RANGE(m_cspace);
}

/**
 * A structure that represents a color as RGBA components.
 *
 * The bits of this structure can be directly reinterpreted as an
 * integer-packed color which uses the PIXELFORMAT_RGBA32 format
 * (PIXELFORMAT_ABGR8888 on little-endian systems and
 * PIXELFORMAT_RGBA8888 on big-endian systems).
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @cat wrap-extending-struct
 * @sa FColor
 */
struct Color : ColorRaw
{
  /**
   * Wraps Color.
   *
   * @param color the value to be wrapped
   */
  constexpr Color(ColorRaw color = {})
    : ColorRaw(color)
  {
  }

  /**
   * Constructs from its fields.
   *
   * @param r the value for channel r.
   * @param g the value for channel g.
   * @param b the value for channel b.
   * @param a the value for channel a.
   */
  constexpr Color(Uint8 r, Uint8 g, Uint8 b, Uint8 a = 255)
    : ColorRaw{r, g, b, a}
  {
  }

  /// Default comparison operator
  constexpr auto operator<=>(const Color& other) const
  {
    auto c = r <=> other.r;
    if (c != std::strong_ordering::equal) return c;
    c = g <=> other.g;
    if (c != std::strong_ordering::equal) return c;
    c = b <=> other.b;
    if (c != std::strong_ordering::equal) return c;
    return a <=> other.a;
  }

  /// Compares with the underlying type
  constexpr auto operator<=>(ColorRaw color) const
  {
    return operator<=>(Color(color));
  }

  /**
   * Get the red component from the color.
   *
   * @returns The red component from the color.
   */
  constexpr Uint8 GetR() const { return r; }

  /**
   * Set the red component from the color.
   *
   * @param newR New red component value.
   * @returns Reference to self.
   */
  constexpr Color& SetR(Uint8 newR)
  {
    r = newR;
    return *this;
  }

  /**
   * Get the green component from the color.
   *
   * @returns The green component from the color.
   *
   */
  constexpr Uint8 GetG() const { return g; }

  /**
   * Set the green component from the color.
   *
   * @param newG New green component value.
   * @returns Reference to self.
   */
  constexpr Color& SetG(Uint8 newG)
  {
    g = newG;
    return *this;
  }

  /**
   * Get the blue component from the color.
   *
   * @returns The blue component from the color.
   *
   */
  constexpr Uint8 GetB() const { return b; }

  /**
   * Set the blue component from the color.
   *
   * @param newB New blue component value.
   * @returns Reference to self.
   */
  constexpr Color& SetB(Uint8 newB)
  {
    b = newB;
    return *this;
  }

  /**
   * Get the alpha component from the color.
   *
   * @returns The alpha component from the color.
   *
   */
  constexpr Uint8 GetA() const { return a; }

  /**
   * Set the alpha component from the color.
   *
   * @param newA New alpha component value.
   * @returns Reference to self.
   */
  constexpr Color& SetA(Uint8 newA)
  {
    a = newA;
    return *this;
  }

  /**
   * Map an RGBA quadruple to a pixel value for a given pixel format.
   *
   * This function maps the RGBA color value to the specified pixel format and
   * returns the pixel value best approximating the given RGBA color value for
   * the given pixel format.
   *
   * If the specified pixel format has no alpha component the alpha value will
   * be ignored (as it will be in formats with a palette).
   *
   * If the format has a palette (8-bit) the index of the closest matching color
   * in the palette will be returned.
   *
   * If the pixel format bpp (color depth) is less than 32-bpp then the unused
   * upper bits of the return value can safely be ignored (e.g., with a 16-bpp
   * format the return value can be assigned to a Uint16, and similarly a Uint8
   * for an 8-bpp format).
   *
   * @param format a pointer to PixelFormatDetails describing the pixel
   *               format.
   * @param palette an optional palette for indexed formats, may be NULL.
   * @returns a pixel value.
   *
   * @threadsafety It is safe to call this function from any thread, as long as
   *               the palette is not modified.
   */
  Uint32 Map(const PixelFormatDetails& format, PaletteConstParam palette) const;

  /**
   * Get RGBA values from a pixel in the specified format.
   *
   * This function uses the entire 8-bit [0..255] range when converting color
   * components from pixel formats with less than 8-bits per RGB component
   * (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
   * 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).
   *
   * If the surface has no alpha component, the alpha will be returned as 0xff
   * (100% opaque).
   *
   * @param pixel a pixel value.
   * @param format a pointer to SDL_PixelFormatDetails describing the pixel
   *               format.
   * @param palette an optional palette for indexed formats, may be NULL.
   * @returns a color value.
   *
   * @threadsafety It is safe to call this function from any thread, as long as
   *               the palette is not modified.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa PixelFormat.GetDetails()
   * @sa GetRGBA()
   * @sa Map()
   */
  static Color Get(Uint32 pixel,
                   const PixelFormatDetails& format,
                   PaletteConstParam palette);
};

/**
 * The bits of this structure can be directly reinterpreted as a float-packed
 * color which uses the PIXELFORMAT_RGBA128_FLOAT format
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @cat wrap-extending-struct
 *
 * @sa Color
 */
struct FColor : FColorRaw
{
  /**
   * Wraps FColor.
   *
   * @param color the value to be wrapped
   */
  constexpr FColor(const FColorRaw& color = {})
    : FColorRaw(color)
  {
  }

  /**
   * Constructs from its fields.
   *
   * @param r the value for r.
   * @param g the value for g.
   * @param b the value for b.
   * @param a the value for a.
   */
  constexpr FColor(float r, float g, float b, float a = 1)
    : FColorRaw{r, g, b, a}
  {
  }

  /// Default comparison operator
  constexpr auto operator<=>(const FColor& other) const
  {
    auto c = r <=> other.r;
    if (c != std::partial_ordering::equivalent) return c;
    c = g <=> other.g;
    if (c != std::partial_ordering::equivalent) return c;
    c = b <=> other.b;
    if (c != std::partial_ordering::equivalent) return c;
    return a <=> other.a;
  }

  /// Compares with the underlying type
  constexpr auto operator<=>(const FColorRaw& color) const
  {
    return operator<=>(FColor(color));
  }

  /**
   * Get the red component from the color.
   *
   * @returns The red component from the color.
   */
  constexpr float GetR() const { return r; }

  /**
   * Set the red component from the color.
   *
   * @param newR New red component value.
   * @returns Reference to self.
   */
  constexpr FColor& SetR(float newR)
  {
    r = newR;
    return *this;
  }

  /**
   * Get the green component from the color.
   *
   * @returns The green component from the color.
   *
   */
  constexpr float GetG() const { return g; }

  /**
   * Set the green component from the color.
   *
   * @param newG New green component value.
   * @returns Reference to self.
   */
  constexpr FColor& SetG(float newG)
  {
    g = newG;
    return *this;
  }

  /**
   * Get the blue component from the color.
   *
   * @returns The blue component from the color.
   *
   */
  constexpr float GetB() const { return b; }

  /**
   * Set the blue component from the color.
   *
   * @param newB New blue component value.
   * @returns Reference to self.
   */
  constexpr FColor& SetB(float newB)
  {
    b = newB;
    return *this;
  }

  /**
   * Get the alpha component from the color.
   *
   * @returns The alpha component from the color.
   *
   */
  constexpr float GetA() const { return a; }

  /**
   * Set the alpha component from the color.
   *
   * @param newA New alpha component value.
   * @returns Reference to self.
   */
  constexpr FColor& SetA(float newA)
  {
    a = newA;
    return *this;
  }
};

/**
 * A set of indexed colors representing a palette.
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @sa Palette.SetColors
 *
 * @cat resource
 */
class Palette
{
  PaletteRaw m_resource = nullptr;

public:
  /// Default ctor
  constexpr Palette() = default;

  /**
   * Constructs from PaletteParam.
   *
   * @param resource a PaletteRaw to be wrapped.
   *
   * This assumes the ownership, call release() if you need to take back.
   */
  constexpr explicit Palette(const PaletteRaw resource)
    : m_resource(resource)
  {
  }

  /// Copy constructor
  constexpr Palette(const Palette& other) { ++m_resource->refcount; }

  /// Move constructor
  constexpr Palette(Palette&& other)
    : Palette(other.release())
  {
  }

  /**
   * Create a palette structure with the specified number of color entries.
   *
   * The palette entries are initialized to white.
   *
   * @param ncolors represents the number of color entries in the color palette.
   * @post a new Palette structure on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Palette.Destroy
   * @sa Palette.SetColors
   * @sa Surface.SetPalette
   */
  Palette(int ncolors)
    : m_resource(CheckError(SDL_CreatePalette(ncolors)))
  {
  }

  /**
   * Safely borrows the from PaletteParam.
   *
   * @param resource a PaletteRaw or Palette.
   *
   * This does not takes ownership!
   */
  static constexpr Palette Borrow(PaletteParam resource)
  {
    ++resource.value->refcount;
    return Palette(resource.value);
  }

  /// Destructor
  ~Palette() { SDL_DestroyPalette(m_resource); }

  /// Assignment operator.
  Palette& operator=(Palette other)
  {
    std::swap(m_resource, other.m_resource);
    return *this;
  }

  /// Retrieves underlying PaletteRaw.
  constexpr PaletteRaw get() const { return m_resource; }

  /// Retrieves underlying PaletteRaw and clear this.
  constexpr PaletteRaw release()
  {
    auto r = m_resource;
    m_resource = nullptr;
    return r;
  }

  /// Comparison
  constexpr auto operator<=>(const Palette& other) const = default;

  /// Comparison
  constexpr bool operator==(std::nullptr_t _) const { return !m_resource; }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!m_resource; }

  /// Converts to PaletteParam
  constexpr operator PaletteParam() const { return {m_resource}; }

  /**
   * Free a palette created with Palette.Palette().
   *
   *
   * @threadsafety It is safe to call this function from any thread, as long as
   *               the palette is not modified or destroyed in another thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Palette.Palette
   */
  void Destroy();

  constexpr int GetSize() const { return m_resource->ncolors; }

  constexpr Color operator[](int index) const
  {
    return m_resource->colors[index];
  }

  /**
   * Set a range of colors in a palette.
   *
   * @param colors an array of Color structures to copy into the palette.
   * @param firstcolor the index of the first palette entry to modify.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread, as long as
   *               the palette is not modified or destroyed in another thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Palette.Palette
   */
  void SetColors(SpanRef<const ColorRaw> colors, int firstcolor = 0);
};

/**
 * Get the human readable name of a pixel format.
 *
 * @param format the pixel format to query.
 * @returns the human readable name of the specified pixel format or
 *          "PIXELFORMAT_UNKNOWN" if the format isn't recognized.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline const char* GetPixelFormatName(PixelFormatRaw format)
{
  return SDL_GetPixelFormatName(format);
}

inline const char* PixelFormat::GetName() const
{
  return SDL::GetPixelFormatName(m_format);
}

/**
 * Convert one of the enumerated pixel formats to a bpp value and RGBA masks.
 *
 * @param format one of the PixelFormat values.
 * @param bpp a bits per pixel value; usually 15, 16, or 32.
 * @param Rmask a pointer filled in with the red mask for the format.
 * @param Gmask a pointer filled in with the green mask for the format.
 * @param Bmask a pointer filled in with the blue mask for the format.
 * @param Amask a pointer filled in with the alpha mask for the format.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa PixelFormat.ForMasks
 */
inline void GetMasksForPixelFormat(PixelFormatRaw format,
                                   int* bpp,
                                   Uint32* Rmask,
                                   Uint32* Gmask,
                                   Uint32* Bmask,
                                   Uint32* Amask)
{
  CheckError(
    SDL_GetMasksForPixelFormat(format, bpp, Rmask, Gmask, Bmask, Amask));
}

inline void PixelFormat::GetMasks(int* bpp,
                                  Uint32* Rmask,
                                  Uint32* Gmask,
                                  Uint32* Bmask,
                                  Uint32* Amask) const
{
  SDL::GetMasksForPixelFormat(m_format, bpp, Rmask, Gmask, Bmask, Amask);
}

/**
 * Convert a bpp value and RGBA masks to an enumerated pixel format.
 *
 * This will return `PIXELFORMAT_UNKNOWN` if the conversion wasn't
 * possible.
 *
 * @param bpp a bits per pixel value; usually 15, 16, or 32.
 * @param Rmask the red mask for the format.
 * @param Gmask the green mask for the format.
 * @param Bmask the blue mask for the format.
 * @param Amask the alpha mask for the format.
 * @returns the PixelFormat value corresponding to the format masks, or
 *          PIXELFORMAT_UNKNOWN if there isn't a match.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa PixelFormat.GetMasks
 */
inline PixelFormat GetPixelFormatForMasks(int bpp,
                                          Uint32 Rmask,
                                          Uint32 Gmask,
                                          Uint32 Bmask,
                                          Uint32 Amask)
{
  return SDL_GetPixelFormatForMasks(bpp, Rmask, Gmask, Bmask, Amask);
}

inline PixelFormat PixelFormat::ForMasks(int bpp,
                                         Uint32 Rmask,
                                         Uint32 Gmask,
                                         Uint32 Bmask,
                                         Uint32 Amask)
{
  return SDL::GetPixelFormatForMasks(bpp, Rmask, Gmask, Bmask, Amask);
}

/**
 * Create an PixelFormatDetails structure corresponding to a pixel format.
 *
 * Returned structure may come from a shared global cache (i.e. not newly
 * allocated), and hence should not be modified, especially the palette. Weird
 * errors such as `Blit combination not supported` may occur.
 *
 * @param format one of the PixelFormat values.
 * @returns a pointer to a PixelFormatDetails structure or nullptr on
 *          failure; call GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline const PixelFormatDetails* GetPixelFormatDetails(PixelFormatRaw format)
{
  return SDL_GetPixelFormatDetails(format);
}

inline const PixelFormatDetails* PixelFormat::GetDetails() const
{
  return SDL::GetPixelFormatDetails(m_format);
}

/**
 * Create a palette structure with the specified number of color entries.
 *
 * The palette entries are initialized to white.
 *
 * @param ncolors represents the number of color entries in the color palette.
 * @returns a new Palette structure on success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Palette.Destroy
 * @sa Palette.SetColors
 * @sa Surface.SetPalette
 */
inline Palette CreatePalette(int ncolors) { return Palette(ncolors); }

/**
 * Set a range of colors in a palette.
 *
 * @param palette the Palette structure to modify.
 * @param colors an array of Color structures to copy into the palette.
 * @param firstcolor the index of the first palette entry to modify.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread, as long as
 *               the palette is not modified or destroyed in another thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void SetPaletteColors(PaletteParam palette,
                             SpanRef<const ColorRaw> colors,
                             int firstcolor = 0)
{
  CheckError(
    SDL_SetPaletteColors(palette, colors.data(), firstcolor, colors.size()));
}

inline void Palette::SetColors(SpanRef<const ColorRaw> colors, int firstcolor)
{
  SDL::SetPaletteColors(m_resource, colors, firstcolor);
}

/**
 * Free a palette created with Palette.Palette().
 *
 * @param palette the Palette structure to be freed.
 *
 * @threadsafety It is safe to call this function from any thread, as long as
 *               the palette is not modified or destroyed in another thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Palette.Palette
 */
inline void DestroyPalette(PaletteRaw palette) { SDL_DestroyPalette(palette); }

inline void Palette::Destroy()
{
  SDL_DestroyPalette(m_resource);
  m_resource = nullptr;
}

/**
 * Map an RGB triple to an opaque pixel value for a given pixel format.
 *
 * This function maps the RGB color value to the specified pixel format and
 * returns the pixel value best approximating the given RGB color value for
 * the given pixel format.
 *
 * If the format has a palette (8-bit) the index of the closest matching color
 * in the palette will be returned.
 *
 * If the specified pixel format has an alpha component it will be returned as
 * all 1 bits (fully opaque).
 *
 * If the pixel format bpp (color depth) is less than 32-bpp then the unused
 * upper bits of the return value can safely be ignored (e.g., with a 16-bpp
 * format the return value can be assigned to a Uint16, and similarly a Uint8
 * for an 8-bpp format).
 *
 * @param format a pointer to PixelFormatDetails describing the pixel
 *               format.
 * @param palette an optional palette for indexed formats, may be nullptr.
 * @param r the red component of the pixel in the range 0-255.
 * @param g the green component of the pixel in the range 0-255.
 * @param b the blue component of the pixel in the range 0-255.
 * @returns a pixel value.
 *
 * @threadsafety It is safe to call this function from any thread, as long as
 *               the palette is not modified.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa PixelFormat.GetDetails
 * @sa GetRGB
 * @sa MapRGBA
 * @sa Surface.MapRGB
 */
inline Uint32 MapRGB(const PixelFormatDetails* format,
                     PaletteConstParam palette,
                     Uint8 r,
                     Uint8 g,
                     Uint8 b)
{
  return SDL_MapRGB(format, palette, r, g, b);
}

/**
 * Map an RGBA quadruple to a pixel value for a given pixel format.
 *
 * This function maps the RGBA color value to the specified pixel format and
 * returns the pixel value best approximating the given RGBA color value for
 * the given pixel format.
 *
 * If the specified pixel format has no alpha component the alpha value will
 * be ignored (as it will be in formats with a palette).
 *
 * If the format has a palette (8-bit) the index of the closest matching color
 * in the palette will be returned.
 *
 * If the pixel format bpp (color depth) is less than 32-bpp then the unused
 * upper bits of the return value can safely be ignored (e.g., with a 16-bpp
 * format the return value can be assigned to a Uint16, and similarly a Uint8
 * for an 8-bpp format).
 *
 * @param format a pointer to PixelFormatDetails describing the pixel
 *               format.
 * @param palette an optional palette for indexed formats, may be nullptr.
 * @param r the red component of the pixel in the range 0-255.
 * @param g the green component of the pixel in the range 0-255.
 * @param b the blue component of the pixel in the range 0-255.
 * @param a the alpha component of the pixel in the range 0-255.
 * @returns a pixel value.
 *
 * @threadsafety It is safe to call this function from any thread, as long as
 *               the palette is not modified.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa PixelFormat.GetDetails
 * @sa GetRGBA
 * @sa MapRGB
 * @sa Surface.MapRGBA
 */
inline Uint32 MapRGBA(const PixelFormatDetails* format,
                      PaletteConstParam palette,
                      ColorRaw c)
{
  return SDL_MapRGBA(format, palette, c.r, c.g, c.b, c.a);
}

/**
 * Get RGB values from a pixel in the specified format.
 *
 * This function uses the entire 8-bit [0..255] range when converting color
 * components from pixel formats with less than 8-bits per RGB component
 * (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
 * 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).
 *
 * @param pixel a pixel value.
 * @param format a pointer to PixelFormatDetails describing the pixel
 *               format.
 * @param palette an optional palette for indexed formats, may be nullptr.
 * @param r a pointer filled in with the red component, may be nullptr.
 * @param g a pointer filled in with the green component, may be nullptr.
 * @param b a pointer filled in with the blue component, may be nullptr.
 *
 * @threadsafety It is safe to call this function from any thread, as long as
 *               the palette is not modified.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa PixelFormat.GetDetails
 * @sa GetRGBA
 * @sa MapRGB
 * @sa MapRGBA
 */
inline void GetRGB(Uint32 pixel,
                   const PixelFormatDetails* format,
                   PaletteConstParam palette,
                   Uint8* r,
                   Uint8* g,
                   Uint8* b)
{
  SDL_GetRGB(pixel, format, palette, r, g, b);
}

/**
 * Get RGBA values from a pixel in the specified format.
 *
 * This function uses the entire 8-bit [0..255] range when converting color
 * components from pixel formats with less than 8-bits per RGB component
 * (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
 * 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).
 *
 * If the surface has no alpha component, the alpha will be returned as 0xff
 * (100% opaque).
 *
 * @param pixel a pixel value.
 * @param format a pointer to PixelFormatDetails describing the pixel
 *               format.
 * @param palette an optional palette for indexed formats, may be nullptr.
 * @param r a pointer filled in with the red component, may be nullptr.
 * @param g a pointer filled in with the green component, may be nullptr.
 * @param b a pointer filled in with the blue component, may be nullptr.
 * @param a a pointer filled in with the alpha component, may be nullptr.
 *
 * @threadsafety It is safe to call this function from any thread, as long as
 *               the palette is not modified.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa PixelFormat.GetDetails
 * @sa GetRGB
 * @sa MapRGB
 * @sa MapRGBA
 */
inline void GetRGBA(Uint32 pixel,
                    const PixelFormatDetails* format,
                    PaletteConstParam palette,
                    Uint8* r,
                    Uint8* g,
                    Uint8* b,
                    Uint8* a)
{
  SDL_GetRGBA(pixel, format, palette, r, g, b, a);
}

/// @}

inline Uint32 Color::Map(const PixelFormatDetails& format,
                         PaletteConstParam palette = nullptr) const
{
  return MapRGBA(&format, palette, {r, g, b, a});
}

inline Color Color::Get(Uint32 pixel,
                        const PixelFormatDetails& format,
                        PaletteConstParam palette = nullptr)
{
  Color c;
  GetRGBA(pixel, &format, palette, &c.r, &c.g, &c.b, &c.a);
  return c;
}

inline Uint32 PixelFormat::Map(Color color,
                               PaletteConstParam palette = nullptr) const
{
  return color.Map(*GetDetails(), palette);
}

inline Color PixelFormat::Get(Uint32 pixel,
                              PaletteConstParam palette = nullptr) const
{
  return Color::Get(pixel, *GetDetails(), palette);
}

/**
 * @defgroup CategoryProperties Object Properties
 *
 * A property is a variable that can be created and retrieved by name at
 * runtime.
 *
 * All properties are part of a property group (Properties). A property group
 * can be created with the Properties.Create function and destroyed with the
 * Properties.Destroy function, but the Properties destructor probably will do
 * what you want to, automatically.
 *
 * Properties can be added to and retrieved from a property group through the
 * following functions:
 *
 * - Properties.SetPointerProperty and Properties.GetPointerProperty operate on
 * `void*` pointer types.
 * - Properties.SetStringProperty and Properties.GetStringProperty operate on
 * string types.
 * - Properties.SetNumberProperty and Properties.GetNumberProperty operate on
 * signed 64-bit integer types.
 * - Properties.SetFloatProperty and Properties.GetFloatProperty operate on
 * floating point types.
 * - Properties.SetBooleanProperty and Properties.GetBooleanProperty operate on
 * boolean types.
 *
 * Properties can be removed from a group by using Properties.ClearProperty.
 *
 * @{
 */

// Forward decl
struct Properties;

using PropertiesID = SDL_PropertiesID;

// Forward decl
struct PropertiesRef;

/// Safely wrap Properties for non owning parameters
struct PropertiesParam
{
  PropertiesID value; ///< parameter's PropertiesID

  /// Constructs from PropertiesID
  constexpr PropertiesParam(PropertiesID value)
    : value(value)
  {
  }

  /// Constructs null/invalid
  constexpr PropertiesParam(std::nullptr_t _ = nullptr)
    : value(0)
  {
  }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!value; }

  /// Comparison
  constexpr auto operator<=>(const PropertiesParam& other) const = default;

  /// Converts to underlying PropertiesID
  constexpr operator PropertiesID() const { return value; }
};

/**
 * SDL property type
 *
 * @since This enum is available since SDL 3.2.0.
 */
using PropertyType = SDL_PropertyType;

constexpr PropertyType PROPERTY_TYPE_INVALID =
  SDL_PROPERTY_TYPE_INVALID; ///< INVALID

constexpr PropertyType PROPERTY_TYPE_POINTER =
  SDL_PROPERTY_TYPE_POINTER; ///< POINTER

constexpr PropertyType PROPERTY_TYPE_STRING =
  SDL_PROPERTY_TYPE_STRING; ///< STRING

constexpr PropertyType PROPERTY_TYPE_NUMBER =
  SDL_PROPERTY_TYPE_NUMBER; ///< NUMBER

constexpr PropertyType PROPERTY_TYPE_FLOAT = SDL_PROPERTY_TYPE_FLOAT; ///< FLOAT

constexpr PropertyType PROPERTY_TYPE_BOOLEAN =
  SDL_PROPERTY_TYPE_BOOLEAN; ///< BOOLEAN

/**
 * A callback used to enumerate all the properties in a group of properties.
 *
 * This callback is called from Properties.Enumerate(), and is called once
 * per property in the set.
 *
 * @param userdata an app-defined pointer passed to the callback.
 * @param props the Properties that is being enumerated.
 * @param name the next property name in the enumeration.
 *
 * @threadsafety Properties.Enumerate holds a lock on `props` during this
 *               callback.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa Properties.Enumerate
 */
using EnumeratePropertiesCallback = SDL_EnumeratePropertiesCallback;

/**
 * A callback used to enumerate all the properties in a group of properties.
 *
 * This callback is called from Properties.Enumerate(), and is called once
 * per property in the set.
 *
 * @param props the Properties that is being enumerated.
 * @param name the next property name in the enumeration.
 *
 * @threadsafety Properties.Enumerate holds a lock on `props` during this
 *               callback.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa Properties.Enumerate
 */
using EnumeratePropertiesCB =
  std::function<void(PropertiesID props, const char* name)>;

/**
 * SDL properties ID
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @cat resource
 *
 * @sa Properties.Create
 */
class Properties
{
  PropertiesID m_resource = 0;

public:
  /// Default ctor
  constexpr Properties() = default;

  /**
   * Constructs from PropertiesParam.
   *
   * @param resource a PropertiesID to be wrapped.
   *
   * This assumes the ownership, call release() if you need to take back.
   */
  constexpr explicit Properties(const PropertiesID resource)
    : m_resource(resource)
  {
  }

  /// Copy constructor
  constexpr Properties(const Properties& other) = delete;

  /// Move constructor
  constexpr Properties(Properties&& other)
    : Properties(other.release())
  {
  }

  constexpr Properties(const PropertiesRef& other) = delete;

  constexpr Properties(PropertiesRef&& other) = delete;

  /**
   * Create a group of properties.
   *
   * All properties are automatically destroyed when Quit() is called.
   *
   * @returns a valid ID for a new group of properties on success;
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Properties.Destroy
   */
  static Properties Create();

  /// Destructor
  ~Properties() { SDL_DestroyProperties(m_resource); }

  /// Assignment operator.
  Properties& operator=(Properties other)
  {
    std::swap(m_resource, other.m_resource);
    return *this;
  }

  /// Retrieves underlying PropertiesID.
  constexpr PropertiesID get() const { return m_resource; }

  /// Retrieves underlying PropertiesID and clear this.
  constexpr PropertiesID release()
  {
    auto r = m_resource;
    m_resource = 0;
    return r;
  }

  /// Comparison
  constexpr auto operator<=>(const Properties& other) const = default;

  /// Comparison
  constexpr bool operator==(std::nullptr_t _) const { return !m_resource; }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!m_resource; }

  /// Converts to PropertiesParam
  constexpr operator PropertiesParam() const { return {m_resource}; }

  /**
   * Destroy a group of properties.
   *
   * All properties are deleted and their cleanup functions will be called, if
   * any.
   *
   * @threadsafety This function should not be called while these properties are
   *               locked or other threads might be setting or getting values
   *               from these properties.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Properties.Create
   */
  void Destroy();

  /**
   * Lock a group of properties.
   *
   * Obtain a multi-threaded lock for these properties. Other threads will wait
   * while trying to lock these properties until they are unlocked. Properties
   * must be unlocked before they are destroyed.
   *
   * The lock is automatically taken when setting individual properties, this
   * function is only needed when you want to set several properties atomically
   * or want to guarantee that properties being queried aren't freed in another
   * thread.
   *
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Properties.Unlock
   */
  void Lock();

  /**
   * Unlock a group of properties.
   *
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Properties.Lock
   */
  void Unlock();

  /**
   * Set a pointer property in a group of properties.
   *
   * @param name the name of the property to modify.
   * @param value the new value of the property, or nullptr to delete the
   * property.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Properties.GetPointerProperty
   * @sa Properties.HasProperty
   * @sa Properties.SetBooleanProperty
   * @sa Properties.SetFloatProperty
   * @sa Properties.SetNumberProperty
   * @sa SetPointerPropertyWithCleanup
   * @sa Properties.SetStringProperty
   */
  void SetPointerProperty(StringParam name, void* value);

  /**
   * Set a string property in a group of properties.
   *
   * This function makes a copy of the string; the caller does not have to
   * preserve the data after this call completes.
   *
   * @param name the name of the property to modify.
   * @param value the new value of the property, or nullptr to delete the
   * property.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Properties.GetStringProperty
   */
  void SetStringProperty(StringParam name, StringParam value);

  /**
   * Set an integer property in a group of properties.
   *
   * @param name the name of the property to modify.
   * @param value the new value of the property.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Properties.GetNumberProperty
   */
  void SetNumberProperty(StringParam name, Sint64 value);

  /**
   * Set a floating point property in a group of properties.
   *
   * @param name the name of the property to modify.
   * @param value the new value of the property.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Properties.GetFloatProperty
   */
  void SetFloatProperty(StringParam name, float value);

  /**
   * Set a boolean property in a group of properties.
   *
   * @param name the name of the property to modify.
   * @param value the new value of the property.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Properties.GetBooleanProperty
   */
  void SetBooleanProperty(StringParam name, bool value);

  /**
   * Return whether a property exists in a group of properties.
   *
   * @param name the name of the property to query.
   * @returns true if the property exists, or false if it doesn't.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Properties.GetPropertyType
   */
  bool HasProperty(StringParam name) const;

  /**
   * Get the type of a property in a group of properties.
   *
   * @param name the name of the property to query.
   * @returns the type of the property, or PROPERTY_TYPE_INVALID if it is
   *          not set.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Properties.HasProperty
   */
  PropertyType GetPropertyType(StringParam name) const;

  /**
   * Get a pointer property from a group of properties.
   *
   * By convention, the names of properties that SDL exposes on objects will
   * start with "SDL.", and properties that SDL uses internally will start with
   * "SDL.internal.". These should be considered read-only and should not be
   * modified by applications.
   *
   * @param name the name of the property to query.
   * @param default_value the default value of the property.
   * @returns the value of the property, or `default_value` if it is not set or
   *          not a pointer property.
   *
   * @threadsafety It is safe to call this function from any thread, although
   *               the data returned is not protected and could potentially be
   *               freed if you call Properties.SetPointerProperty() or
   *               Properties.ClearProperty() on these properties from another
   * thread. If you need to avoid this, use Properties.Lock() and
   *               Properties.Unlock().
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Properties.GetBooleanProperty
   * @sa Properties.GetFloatProperty
   * @sa Properties.GetNumberProperty
   * @sa Properties.GetPropertyType
   * @sa Properties.GetStringProperty
   * @sa Properties.HasProperty
   * @sa Properties.SetPointerProperty
   */
  void* GetPointerProperty(StringParam name, void* default_value) const;

  /**
   * Get a string property from a group of properties.
   *
   * @param name the name of the property to query.
   * @param default_value the default value of the property.
   * @returns the value of the property, or `default_value` if it is not set or
   *          not a string property.
   *
   * @threadsafety It is safe to call this function from any thread, although
   *               the data returned is not protected and could potentially be
   *               freed if you call Properties.SetStringProperty() or
   *               Properties.ClearProperty() on these properties from another
   * thread. If you need to avoid this, use Properties.Lock() and
   *               Properties.Unlock().
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Properties.GetPropertyType
   * @sa Properties.HasProperty
   * @sa Properties.SetStringProperty
   */
  const char* GetStringProperty(StringParam name,
                                StringParam default_value) const;

  /**
   * Get a number property from a group of properties.
   *
   * You can use Properties.GetPropertyType() to query whether the property
   * exists and is a number property.
   *
   * @param name the name of the property to query.
   * @param default_value the default value of the property.
   * @returns the value of the property, or `default_value` if it is not set or
   *          not a number property.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Properties.GetPropertyType
   * @sa Properties.HasProperty
   * @sa Properties.SetNumberProperty
   */
  Sint64 GetNumberProperty(StringParam name, Sint64 default_value) const;

  /**
   * Get a floating point property from a group of properties.
   *
   * You can use Properties.GetPropertyType() to query whether the property
   * exists and is a floating point property.
   *
   * @param name the name of the property to query.
   * @param default_value the default value of the property.
   * @returns the value of the property, or `default_value` if it is not set or
   *          not a float property.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Properties.GetPropertyType
   * @sa Properties.HasProperty
   * @sa Properties.SetFloatProperty
   */
  float GetFloatProperty(StringParam name, float default_value) const;

  /**
   * Get a boolean property from a group of properties.
   *
   * You can use Properties.GetPropertyType() to query whether the property
   * exists and is a boolean property.
   *
   * @param name the name of the property to query.
   * @param default_value the default value of the property.
   * @returns the value of the property, or `default_value` if it is not set or
   *          not a boolean property.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Properties.GetPropertyType
   * @sa Properties.HasProperty
   * @sa Properties.SetBooleanProperty
   */
  bool GetBooleanProperty(StringParam name, bool default_value) const;

  /**
   * Clear a property from a group of properties.
   *
   * @param name the name of the property to clear.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void ClearProperty(StringParam name) const;

  template<std::output_iterator<const char*> IT>
  void Enumerate(IT outputIter) const
  {
    static_assert(false, "Not implemented");
  }

  void Enumerate(EnumeratePropertiesCB callback) const;

  /**
   * Enumerate the properties contained in a group of properties.
   *
   * The callback function is called for each property in the group of
   * properties. The properties are locked during enumeration.
   *
   * @param callback the function to call for each property.
   * @param userdata a pointer that is passed to `callback`.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void Enumerate(EnumeratePropertiesCallback callback, void* userdata) const;

  Uint64 GetCount() const;
};

/// Semi-safe reference for Properties.
struct PropertiesRef : Properties
{
  /**
   * Constructs from PropertiesParam.
   *
   * @param resource a PropertiesID or Properties.
   *
   * This does not takes ownership!
   */
  PropertiesRef(PropertiesParam resource)
    : Properties(resource.value)
  {
  }

  /// Copy constructor.
  PropertiesRef(const PropertiesRef& other)
    : Properties(other.get())
  {
  }

  /// Destructor
  ~PropertiesRef() { release(); }
};

/**
 * Get the global SDL properties.
 *
 * @returns a valid property ID on success.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline PropertiesRef GetGlobalProperties()
{
  return {CheckError(SDL_GetGlobalProperties())};
}

/**
 * Create a group of properties.
 *
 * All properties are automatically destroyed when Quit() is called.
 *
 * @returns a valid ID for a new group of properties on success;
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Properties.Destroy
 */
inline Properties CreateProperties()
{
  return Properties(CheckError(SDL_CreateProperties()));
}

inline Properties Properties::Create() { return SDL::CreateProperties(); }

/**
 * Copy a group of properties.
 *
 * Copy all the properties from one group of properties to another, with the
 * exception of properties requiring cleanup (set using
 * SetPointerPropertyWithCleanup()), which will not be copied. Any
 * property that already exists on `dst` will be overwritten.
 *
 * @param src the properties to copy.
 * @param dst the destination properties.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void CopyProperties(PropertiesParam src, PropertiesParam dst)
{
  CheckError(SDL_CopyProperties(src, dst));
}

/**
 * Lock a group of properties.
 *
 * Obtain a multi-threaded lock for these properties. Other threads will wait
 * while trying to lock these properties until they are unlocked. Properties
 * must be unlocked before they are destroyed.
 *
 * The lock is automatically taken when setting individual properties, this
 * function is only needed when you want to set several properties atomically
 * or want to guarantee that properties being queried aren't freed in another
 * thread.
 *
 * @param props the properties to lock.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Properties.Unlock
 */
inline void LockProperties(PropertiesParam props)
{
  CheckError(SDL_LockProperties(props));
}

inline void Properties::Lock() { SDL::LockProperties(m_resource); }

/**
 * Unlock a group of properties.
 *
 * @param props the properties to unlock.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Properties.Lock
 */
inline void UnlockProperties(PropertiesParam props)
{
  SDL_UnlockProperties(props);
}

inline void Properties::Unlock() { SDL::UnlockProperties(m_resource); }

/**
 * A callback used to free resources when a property is deleted.
 *
 * This should release any resources associated with `value` that are no
 * longer needed.
 *
 * This callback is set per-property. Different properties in the same group
 * can have different cleanup callbacks.
 *
 * This callback will be called _during_ SetPointerPropertyWithCleanup if
 * the function fails for any reason.
 *
 * @param userdata an app-defined pointer passed to the callback.
 * @param value the pointer assigned to the property to clean up.
 *
 * @threadsafety This callback may fire without any locks held; if this is a
 *               concern, the app should provide its own locking.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa SetPointerPropertyWithCleanup
 */
using CleanupPropertyCallback = SDL_CleanupPropertyCallback;

/**
 * A callback used to free resources when a property is deleted.
 *
 * This should release any resources associated with `value` that are no
 * longer needed.
 *
 * This callback is set per-property. Different properties in the same group
 * can have different cleanup callbacks.
 *
 * This callback will be called _during_ SetPointerPropertyWithCleanup if
 * the function fails for any reason.
 *
 * @param value the pointer assigned to the property to clean up.
 *
 * @threadsafety This callback may fire without any locks held; if this is a
 *               concern, the app should provide its own locking.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa SetPointerPropertyWithCleanup
 * @sa CleanupPropertyCallback
 */
using CleanupPropertyCB = std::function<void(void*)>;

/**
 * Set a pointer property in a group of properties with a cleanup function
 * that is called when the property is deleted.
 *
 * The cleanup function is also called if setting the property fails for any
 * reason.
 *
 * For simply setting basic data types, like numbers, bools, or strings, use
 * Properties.SetNumberProperty, Properties.SetBooleanProperty, or
 * Properties.SetStringProperty instead, as those functions will handle cleanup
 * on your behalf. This function is only for more complex, custom data.
 *
 * @param props the properties to modify.
 * @param name the name of the property to modify.
 * @param value the new value of the property, or nullptr to delete the
 * property.
 * @param cleanup the function to call when this property is deleted, or nullptr
 *                if no cleanup is necessary.
 * @param userdata a pointer that is passed to the cleanup function.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Properties.GetPointerProperty
 * @sa Properties.SetPointerProperty
 * @sa CleanupPropertyCallback
 */
inline void SetPointerPropertyWithCleanup(PropertiesParam props,
                                          StringParam name,
                                          void* value,
                                          CleanupPropertyCallback cleanup,
                                          void* userdata)
{
  CheckError(
    SDL_SetPointerPropertyWithCleanup(props, name, value, cleanup, userdata));
}

/**
 * Set a pointer property in a group of properties with a cleanup function
 * that is called when the property is deleted.
 *
 * The cleanup function is also called if setting the property fails for any
 * reason.
 *
 * For simply setting basic data types, like numbers, bools, or strings, use
 * Properties.SetNumberProperty, Properties.SetBooleanProperty, or
 * Properties.SetStringProperty instead, as those functions will handle cleanup
 * on your behalf. This function is only for more complex, custom data.
 *
 * @param props the properties to modify.
 * @param name the name of the property to modify.
 * @param value the new value of the property, or nullptr to delete the
 * property.
 * @param cleanup the function to call when this property is deleted, or nullptr
 *                if no cleanup is necessary.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Properties.GetPointerProperty
 * @sa Properties.SetPointerProperty
 * @sa CleanupPropertyCallback
 */
inline void SetPointerPropertyWithCleanup(PropertiesParam props,
                                          StringParam name,
                                          void* value,
                                          CleanupPropertyCB cleanup)
{
  using Wrapper = CallbackWrapper<CleanupPropertyCB>;
  SDL_SetPointerPropertyWithCleanup(props,
                                    std::move(name),
                                    value,
                                    &Wrapper::CallOnce,
                                    Wrapper::Wrap(std::move(cleanup)));
}

/**
 * Set a pointer property in a group of properties.
 *
 * @param props the properties to modify.
 * @param name the name of the property to modify.
 * @param value the new value of the property, or nullptr to delete the
 * property.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Properties.GetPointerProperty
 * @sa Properties.HasProperty
 * @sa Properties.SetBooleanProperty
 * @sa Properties.SetFloatProperty
 * @sa Properties.SetNumberProperty
 * @sa SetPointerPropertyWithCleanup
 * @sa Properties.SetStringProperty
 */
inline void SetPointerProperty(PropertiesParam props,
                               StringParam name,
                               void* value)
{
  CheckError(SDL_SetPointerProperty(props, name, value));
}

inline void Properties::SetPointerProperty(StringParam name, void* value)
{
  SDL::SetPointerProperty(m_resource, std::move(name), value);
}

/**
 * Set a string property in a group of properties.
 *
 * This function makes a copy of the string; the caller does not have to
 * preserve the data after this call completes.
 *
 * @param props the properties to modify.
 * @param name the name of the property to modify.
 * @param value the new value of the property, or nullptr to delete the
 * property.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Properties.GetStringProperty
 */
inline void SetStringProperty(PropertiesParam props,
                              StringParam name,
                              StringParam value)
{
  CheckError(SDL_SetStringProperty(props, name, value));
}

inline void Properties::SetStringProperty(StringParam name, StringParam value)
{
  SDL::SetStringProperty(m_resource, std::move(name), std::move(value));
}

/**
 * Set an integer property in a group of properties.
 *
 * @param props the properties to modify.
 * @param name the name of the property to modify.
 * @param value the new value of the property.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Properties.GetNumberProperty
 */
inline void SetNumberProperty(PropertiesParam props,
                              StringParam name,
                              Sint64 value)
{
  CheckError(SDL_SetNumberProperty(props, name, value));
}

inline void Properties::SetNumberProperty(StringParam name, Sint64 value)
{
  SDL::SetNumberProperty(m_resource, std::move(name), value);
}

/**
 * Set a floating point property in a group of properties.
 *
 * @param props the properties to modify.
 * @param name the name of the property to modify.
 * @param value the new value of the property.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Properties.GetFloatProperty
 */
inline void SetFloatProperty(PropertiesParam props,
                             StringParam name,
                             float value)
{
  CheckError(SDL_SetFloatProperty(props, name, value));
}

inline void Properties::SetFloatProperty(StringParam name, float value)
{
  SDL::SetFloatProperty(m_resource, std::move(name), value);
}

/**
 * Set a boolean property in a group of properties.
 *
 * @param props the properties to modify.
 * @param name the name of the property to modify.
 * @param value the new value of the property.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Properties.GetBooleanProperty
 */
inline void SetBooleanProperty(PropertiesParam props,
                               StringParam name,
                               bool value)
{
  CheckError(SDL_SetBooleanProperty(props, name, value));
}

inline void Properties::SetBooleanProperty(StringParam name, bool value)
{
  SDL::SetBooleanProperty(m_resource, std::move(name), value);
}

/**
 * Return whether a property exists in a group of properties.
 *
 * @param props the properties to query.
 * @param name the name of the property to query.
 * @returns true if the property exists, or false if it doesn't.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Properties.GetPropertyType
 */
inline bool HasProperty(PropertiesParam props, StringParam name)
{
  return SDL_HasProperty(props, name);
}

inline bool Properties::HasProperty(StringParam name) const
{
  return SDL::HasProperty(m_resource, std::move(name));
}

/**
 * Get the type of a property in a group of properties.
 *
 * @param props the properties to query.
 * @param name the name of the property to query.
 * @returns the type of the property, or PROPERTY_TYPE_INVALID if it is
 *          not set.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Properties.HasProperty
 */
inline PropertyType GetPropertyType(PropertiesParam props, StringParam name)
{
  return SDL_GetPropertyType(props, name);
}

inline PropertyType Properties::GetPropertyType(StringParam name) const
{
  return SDL::GetPropertyType(m_resource, std::move(name));
}

/**
 * Get a pointer property from a group of properties.
 *
 * By convention, the names of properties that SDL exposes on objects will
 * start with "SDL.", and properties that SDL uses internally will start with
 * "SDL.internal.". These should be considered read-only and should not be
 * modified by applications.
 *
 * @param props the properties to query.
 * @param name the name of the property to query.
 * @param default_value the default value of the property.
 * @returns the value of the property, or `default_value` if it is not set or
 *          not a pointer property.
 *
 * @threadsafety It is safe to call this function from any thread, although
 *               the data returned is not protected and could potentially be
 *               freed if you call Properties.SetPointerProperty() or
 *               Properties.ClearProperty() on these properties from another
 * thread. If you need to avoid this, use Properties.Lock() and
 *               Properties.Unlock().
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Properties.GetBooleanProperty
 * @sa Properties.GetFloatProperty
 * @sa Properties.GetNumberProperty
 * @sa Properties.GetPropertyType
 * @sa Properties.GetStringProperty
 * @sa Properties.HasProperty
 * @sa Properties.SetPointerProperty
 */
inline void* GetPointerProperty(PropertiesParam props,
                                StringParam name,
                                void* default_value)
{
  return SDL_GetPointerProperty(props, name, default_value);
}

inline void* Properties::GetPointerProperty(StringParam name,
                                            void* default_value) const
{
  return SDL::GetPointerProperty(m_resource, std::move(name), default_value);
}

/**
 * Get a string property from a group of properties.
 *
 * @param props the properties to query.
 * @param name the name of the property to query.
 * @param default_value the default value of the property.
 * @returns the value of the property, or `default_value` if it is not set or
 *          not a string property.
 *
 * @threadsafety It is safe to call this function from any thread, although
 *               the data returned is not protected and could potentially be
 *               freed if you call Properties.SetStringProperty() or
 *               Properties.ClearProperty() on these properties from another
 * thread. If you need to avoid this, use Properties.Lock() and
 *               Properties.Unlock().
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Properties.GetPropertyType
 * @sa Properties.HasProperty
 * @sa Properties.SetStringProperty
 */
inline const char* GetStringProperty(PropertiesParam props,
                                     StringParam name,
                                     StringParam default_value)
{
  return SDL_GetStringProperty(props, name, default_value);
}

inline const char* Properties::GetStringProperty(
  StringParam name,
  StringParam default_value) const
{
  return SDL::GetStringProperty(
    m_resource, std::move(name), std::move(default_value));
}

/**
 * Get a number property from a group of properties.
 *
 * You can use Properties.GetPropertyType() to query whether the property exists
 * and is a number property.
 *
 * @param props the properties to query.
 * @param name the name of the property to query.
 * @param default_value the default value of the property.
 * @returns the value of the property, or `default_value` if it is not set or
 *          not a number property.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Properties.GetPropertyType
 * @sa Properties.HasProperty
 * @sa Properties.SetNumberProperty
 */
inline Sint64 GetNumberProperty(PropertiesParam props,
                                StringParam name,
                                Sint64 default_value)
{
  return SDL_GetNumberProperty(props, name, default_value);
}

inline Sint64 Properties::GetNumberProperty(StringParam name,
                                            Sint64 default_value) const
{
  return SDL::GetNumberProperty(m_resource, std::move(name), default_value);
}

/**
 * Get a floating point property from a group of properties.
 *
 * You can use Properties.GetPropertyType() to query whether the property exists
 * and is a floating point property.
 *
 * @param props the properties to query.
 * @param name the name of the property to query.
 * @param default_value the default value of the property.
 * @returns the value of the property, or `default_value` if it is not set or
 *          not a float property.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Properties.GetPropertyType
 * @sa Properties.HasProperty
 * @sa Properties.SetFloatProperty
 */
inline float GetFloatProperty(PropertiesParam props,
                              StringParam name,
                              float default_value)
{
  return SDL_GetFloatProperty(props, name, default_value);
}

inline float Properties::GetFloatProperty(StringParam name,
                                          float default_value) const
{
  return SDL::GetFloatProperty(m_resource, std::move(name), default_value);
}

/**
 * Get a boolean property from a group of properties.
 *
 * You can use Properties.GetPropertyType() to query whether the property exists
 * and is a boolean property.
 *
 * @param props the properties to query.
 * @param name the name of the property to query.
 * @param default_value the default value of the property.
 * @returns the value of the property, or `default_value` if it is not set or
 *          not a boolean property.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Properties.GetPropertyType
 * @sa Properties.HasProperty
 * @sa Properties.SetBooleanProperty
 */
inline bool GetBooleanProperty(PropertiesParam props,
                               StringParam name,
                               bool default_value)
{
  return SDL_GetBooleanProperty(props, name, default_value);
}

inline bool Properties::GetBooleanProperty(StringParam name,
                                           bool default_value) const
{
  return SDL::GetBooleanProperty(m_resource, std::move(name), default_value);
}

/**
 * Clear a property from a group of properties.
 *
 * @param props the properties to modify.
 * @param name the name of the property to clear.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void ClearProperty(PropertiesParam props, StringParam name)
{
  CheckError(SDL_ClearProperty(props, name));
}

inline void Properties::ClearProperty(StringParam name) const
{
  SDL::ClearProperty(m_resource, std::move(name));
}

/**
 * Enumerate the properties contained in a group of properties.
 *
 * The callback function is called for each property in the group of
 * properties. The properties are locked during enumeration.
 *
 * @param props the properties to query.
 * @param callback the function to call for each property.
 * @param userdata a pointer that is passed to `callback`.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void EnumerateProperties(PropertiesParam props,
                                EnumeratePropertiesCallback callback,
                                void* userdata)
{
  CheckError(SDL_EnumerateProperties(props, callback, userdata));
}

/**
 * Enumerate the properties contained in a group of properties.
 *
 * The callback function is called for each property in the group of
 * properties. The properties are locked during enumeration.
 *
 * @param props the properties to query.
 * @param callback the function to call for each property.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void EnumerateProperties(PropertiesParam props,
                                EnumeratePropertiesCB callback)
{
  return EnumerateProperties(
    props,
    [](void* userdata, PropertiesID props, const char* name) {
      auto& f = *static_cast<EnumeratePropertiesCB*>(userdata);
      f(props, name);
    },
    &callback);
}

/**
 * Returns the number of properties this has
 *
 * This uses Enumerate() internally, so might not be so fast
 */
inline void Properties::Enumerate(EnumeratePropertiesCallback callback,
                                  void* userdata) const
{
  SDL::EnumerateProperties(m_resource, callback, userdata);
}

inline Uint64 CountProperties(PropertiesParam props)
{
  Uint64 count = 0;
  EnumerateProperties(props, [&](auto, const char*) { count++; });
  return count;
}

inline Uint64 Properties::GetCount() const
{
  return CountProperties(m_resource);
}

/**
 * Destroy a group of properties.
 *
 * All properties are deleted and their cleanup functions will be called, if
 * any.
 *
 * @param props the properties to destroy.
 *
 * @threadsafety This function should not be called while these properties are
 *               locked or other threads might be setting or getting values
 *               from these properties.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Properties.Create
 */
inline void DestroyProperties(PropertiesID props)
{
  SDL_DestroyProperties(props);
}

inline void Properties::Destroy()
{
  SDL_DestroyProperties(m_resource);
  m_resource = 0;
}

/// @}

/**
 * @defgroup CategoryStdinc Standard Library Functionality
 *
 * SDL provides its own implementation of some of the most important C runtime
 * functions.
 *
 * Using these functions allows an app to have access to common C
 * functionality without depending on a specific C runtime (or a C runtime at
 * all). More importantly, the SDL implementations work identically across
 * platforms, so apps can avoid surprises like snprintf() behaving differently
 * between Windows and Linux builds, or itoa() only existing on some
 * platforms.
 *
 * For many of the most common functions, like memcpy, SDL might just call
 * through to the usual C runtime behind the scenes, if it makes sense to do
 * so (if it's faster and always available/reliable on a given platform),
 * reducing library size and offering the most optimized option.
 *
 * SDL also offers other C-runtime-adjacent functionality in this header that
 * either isn't, strictly speaking, part of any C runtime standards, like
 * crc32() and SDL_reinterpret_cast, etc. It also offers a few better
 * options, like strlcpy(), which functions as a safer form of strcpy().
 *
 * @{
 */

// Forward decl
struct Environment;

using EnvironmentRaw = SDL_Environment*;

// Forward decl
struct EnvironmentRef;

/// Safely wrap Environment for non owning parameters
struct EnvironmentParam
{
  EnvironmentRaw value; ///< parameter's EnvironmentRaw

  /// Constructs from EnvironmentRaw
  constexpr EnvironmentParam(EnvironmentRaw value)
    : value(value)
  {
  }

  /// Constructs null/invalid
  constexpr EnvironmentParam(std::nullptr_t _ = nullptr)
    : value(nullptr)
  {
  }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!value; }

  /// Comparison
  constexpr auto operator<=>(const EnvironmentParam& other) const = default;

  /// Converts to underlying EnvironmentRaw
  constexpr operator EnvironmentRaw() const { return value; }
};

// Forward decl
struct IConv;

using IConvRaw = SDL_iconv_t;

// Forward decl
struct IConvRef;

/// Safely wrap IConv for non owning parameters
struct IConvParam
{
  IConvRaw value; ///< parameter's IConvRaw

  /// Constructs from IConvRaw
  constexpr IConvParam(IConvRaw value)
    : value(value)
  {
  }

  /// Constructs null/invalid
  constexpr IConvParam(std::nullptr_t _ = nullptr)
    : value(nullptr)
  {
  }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!value; }

  /// Comparison
  constexpr auto operator<=>(const IConvParam& other) const = default;

  constexpr operator IConvRaw() const { return value; }
};

#ifdef SDL3PP_DOC

/**
 * Don't let SDL use "long long" C types.
 *
 * SDL will define this if it believes the compiler doesn't understand the
 * "long long" syntax for C datatypes. This can happen on older compilers.
 *
 * If _your_ compiler doesn't support "long long" but SDL doesn't know it, it
 * is safe to define this yourself to build against the SDL headers.
 *
 * If this is defined, it will remove access to some C runtime support
 * functions, like SDL_ulltoa and SDL_strtoll that refer to this datatype
 * explicitly. The rest of SDL will still be available.
 *
 * SDL's own source code cannot be built with a compiler that has this
 * defined, for various technical reasons.
 */
#define SDL_NOLONGLONG 1

/**
 * The largest value that a `size_t` can hold for the target platform.
 *
 * `size_t` is generally the same size as a pointer in modern times, but this
 * can get weird on very old and very esoteric machines. For example, on a
 * 16-bit Intel 286, you might have a 32-bit "far" pointer (16-bit segment
 * plus 16-bit offset), but `size_t` is 16 bits, because it can only deal with
 * the offset into an individual segment.
 *
 * In modern times, it's generally expected to cover an entire linear address
 * space. But be careful!
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_SIZE_MAX SIZE_MAX

#endif // SDL3PP_DOC

/**
 * The number of elements in a static array.
 *
 * This will compile but return incorrect results for a pointer to an array;
 * it has to be an array the compiler knows the size of.
 *
 * @since This function is available since SDL 3.2.0.
 */
template<class T, std::size_t N>
constexpr std::size_t arraysize(const T (&array)[N])
{
  return SDL_arraysize(array);
}

#ifdef SDL3PP_DOC

/**
 * Macro useful for building other macros with strings in them.
 *
 * For example:
 *
 * ```c
 * #define LOG_ERROR(X) OutputDebugString(SDL_STRINGIFY_ARG(__FUNCTION__) ": " X
 * "@n")`
 * ```
 *
 * @param arg the text to turn into a string literal.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_STRINGIFY_ARG(arg) #arg

#endif // SDL3PP_DOC

/**
 * Define a four character code as a Uint32.
 *
 * @param a the first ASCII character.
 * @param b the second ASCII character.
 * @param c the third ASCII character.
 * @param d the fourth ASCII character.
 * @returns the four characters converted into a Uint32, one character
 *          per-byte.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
constexpr Uint32 FourCC(Uint8 a, Uint8 b, Uint8 c, Uint8 d)
{
  return SDL_FOURCC(a, b, c, d);
}

#ifdef SDL3PP_DOC

/**
 * Append the 64 bit integer suffix to a signed integer literal.
 *
 * This helps compilers that might believe a integer literal larger than
 * 0xFFFFFFFF is overflowing a 32-bit value. Use `SDL_SINT64_C(0xFFFFFFFF1)`
 * instead of `0xFFFFFFFF1` by itself.
 *
 * @since This macro is available since SDL 3.2.0.
 *
 * @sa SDL_UINT64_C
 */
#define SDL_SINT64_C(c) c##LL /* or whatever the current compiler uses. */

/**
 * Append the 64 bit integer suffix to an unsigned integer literal.
 *
 * This helps compilers that might believe a integer literal larger than
 * 0xFFFFFFFF is overflowing a 32-bit value. Use `SDL_UINT64_C(0xFFFFFFFF1)`
 * instead of `0xFFFFFFFF1` by itself.
 *
 * @since This macro is available since SDL 3.2.0.
 *
 * @sa SDL_SINT64_C
 */
#define SDL_UINT64_C(c) c##ULL /* or whatever the current compiler uses. */

/**
 * A signed 8-bit integer type.
 *
 * @since This macro is available since SDL 3.2.0.
 */
using Sint8 = Sint8;

#endif // SDL3PP_DOC

constexpr Sint8 MAX_SINT8 = SDL_MAX_SINT8;

constexpr Sint8 MIN_SINT8 = SDL_MIN_SINT8;

#ifdef SDL3PP_DOC

/**
 * An unsigned 8-bit integer type.
 *
 * @since This macro is available since SDL 3.2.0.
 */
using Uint8 = Uint8;

#endif // SDL3PP_DOC

constexpr Uint8 MAX_UINT8 = SDL_MAX_UINT8;

constexpr Uint8 MIN_UINT8 = SDL_MIN_UINT8;

#ifdef SDL3PP_DOC

/**
 * A signed 16-bit integer type.
 *
 * @since This macro is available since SDL 3.2.0.
 */
using Sint16 = Sint16;

#endif // SDL3PP_DOC

constexpr Sint16 MAX_SINT16 = SDL_MAX_SINT16;

constexpr Sint16 MIN_SINT16 = SDL_MIN_SINT16;

#ifdef SDL3PP_DOC

/**
 * An unsigned 16-bit integer type.
 *
 * @since This macro is available since SDL 3.2.0.
 */
using Uint16 = Uint16;

#endif // SDL3PP_DOC

constexpr Uint16 MAX_UINT16 = SDL_MAX_UINT16;

constexpr Uint16 MIN_UINT16 = SDL_MIN_UINT16;

#ifdef SDL3PP_DOC

/**
 * A signed 32-bit integer type.
 *
 * @since This macro is available since SDL 3.2.0.
 */
using Sint32 = Sint32;

#endif // SDL3PP_DOC

constexpr Sint32 MAX_SINT32 = SDL_MAX_SINT32;

constexpr Sint32 MIN_SINT32 = SDL_MIN_SINT32;

#ifdef SDL3PP_DOC

/**
 * An unsigned 32-bit integer type.
 *
 * @since This macro is available since SDL 3.2.0.
 */
using Uint32 = Uint32;

#endif // SDL3PP_DOC

constexpr Uint32 MAX_UINT32 = SDL_MAX_UINT32;

constexpr Uint8 MIN_UINT32 = SDL_MIN_UINT32;

#ifdef SDL3PP_DOC

/**
 * A signed 64-bit integer type.
 *
 * @since This macro is available since SDL 3.2.0.
 *
 * @sa SDL_SINT64_C
 */
using Sint64 = Sint64;

#endif // SDL3PP_DOC

constexpr Sint64 MAX_SINT64 = SDL_MAX_SINT64;

constexpr Sint64 MIN_SINT64 = SDL_MIN_SINT64;

#ifdef SDL3PP_DOC

/**
 * An unsigned 64-bit integer type.
 *
 * @since This macro is available since SDL 3.2.0.
 *
 * @sa SDL_UINT64_C
 */
using Uint64 = Uint64;

#endif // SDL3PP_DOC

constexpr Uint64 MAX_UINT64 = SDL_MAX_UINT64;

constexpr Uint8 MIN_UINT64 = SDL_MIN_UINT64;

/// Duration in seconds (float).
using Seconds = std::chrono::duration<float>;

/// Duration in Nanoseconds (Uint64).
using Nanoseconds = std::chrono::nanoseconds;

/// Converts a time duration to seconds (float).
constexpr float ToSeconds(Seconds duration) { return duration.count(); }

/// Converts a float to seconds representation.
constexpr Seconds FromSeconds(float duration) { return Seconds(duration); }

/// Converts a time duration to nanoseconds (Sint64);
constexpr Sint64 ToNS(std::chrono::nanoseconds duration)
{
  return duration.count();
}

/// Converts a Sint64 to nanoseconds representation.
constexpr Nanoseconds FromNS(Sint64 duration) { return Nanoseconds{duration}; }

/**
 * SDL times are signed, 64-bit integers representing nanoseconds since the
 * Unix epoch (Jan 1, 1970).
 *
 * They can be converted between POSIX time_t values with Time.ToPosix()
 * and Time.FromPosix(), and between Windows FILETIME values with
 * Time.ToWindows() and Time.FromWindows().
 *
 * @since This type is available since SDL 3.2.0.
 *
 * @sa MAX_SINT64
 * @sa MIN_SINT64
 */
class Time
{
  std::chrono::nanoseconds m_value;

public:
  constexpr Time() = default;

  /// Constructs from a nanoseconds period.
  constexpr Time(std::chrono::nanoseconds time)
    : m_value(time)
  {
  }

  /// Constructs from SDL_Time
  constexpr explicit Time(SDL_Time time)
    : m_value(FromNS(time))
  {
  }

  /// True if not zero
  constexpr explicit operator bool() const
  {
    return m_value != std::chrono::nanoseconds{};
  }

  /// Converts to nanoseconds period
  constexpr operator std::chrono::nanoseconds() const { return m_value; }

  /**
   * Gets the current value of the system realtime clock in nanoseconds since
   * Jan 1, 1970 in Universal Coordinated Time (UTC).
   *
   * @throws Error on failure.
   *
   * @since This function is available since SDL 3.2.0.
   */
  static Time Current();

  /// Create from a nanoseconds Sint64.
  static constexpr Time FromNS(Sint64 time)
  {
    return Time{std::chrono::nanoseconds{time}};
  }

  /// Converts to nanoseconds Sint64
  constexpr Sint64 ToNS() const { return m_value.count(); }

  /**
   * Convert seconds to nanoseconds.
   *
   * This only converts whole numbers, not fractional seconds.
   *
   * @param S the number of seconds to convert.
   * @returns S, expressed in nanoseconds.
   *
   * @threadsafety It is safe to call this macro from any thread.
   *
   * @since This macro is available since SDL 3.2.0.
   */
  static constexpr Time FromPosix(Sint64 time);

  /**
   * Convert nanoseconds to seconds.
   *
   * This performs a division, so the results can be dramatically different if
   * `NS` is an integer or floating point value.
   *
   * @param NS the number of nanoseconds to convert.
   * @returns NS, expressed in seconds.
   *
   * @threadsafety It is safe to call this macro from any thread.
   *
   * @since This macro is available since SDL 3.2.0.
   */
  constexpr Sint64 ToPosix() const;

  /**
   * Converts a Windows FILETIME (100-nanosecond intervals since January 1,
   * 1601) to an SDL time.
   *
   * This function takes the two 32-bit values of the FILETIME structure as
   * parameters.
   *
   * @param dwLowDateTime the low portion of the Windows FILETIME value.
   * @param dwHighDateTime the high portion of the Windows FILETIME value.
   * @returns the converted SDL time.
   *
   * @since This function is available since SDL 3.2.0.
   */
  static Time FromWindows(Uint32 dwLowDateTime, Uint32 dwHighDateTime);

  /**
   * Converts an SDL time into a Windows FILETIME (100-nanosecond intervals
   * since January 1, 1601).
   *
   * This function fills in the two 32-bit values of the FILETIME structure.
   *
   * @param dwLowDateTime a pointer filled in with the low portion of the
   *                      Windows FILETIME value.
   * @param dwHighDateTime a pointer filled in with the high portion of the
   *                       Windows FILETIME value.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void ToWindows(Uint32* dwLowDateTime, Uint32* dwHighDateTime) const;

  /// Converts a time to seconds (float) since epoch.
  constexpr float ToSeconds() const { return Seconds(m_value).count(); }

  /// Converts a time to seconds (float) since epoch.
  static constexpr Time FromSeconds(float interval)
  {
    return std::chrono::duration_cast<std::chrono::nanoseconds>(
      Seconds(interval));
  }

  /// Increment time
  constexpr Time& operator+=(std::chrono::nanoseconds interval)
  {
    m_value += interval;
    return *this;
  }

  /// Decrement
  constexpr Time& operator-=(std::chrono::nanoseconds interval)
  {
    m_value -= interval;
    return *this;
  }
};

constexpr Time MAX_TIME = Time::FromNS(SDL_MAX_TIME);

constexpr Time MIN_TIME = Time::FromNS(SDL_MIN_TIME);

#ifdef SDL3PP_DOC

/**
 * Epsilon constant, used for comparing floating-point numbers.
 *
 * Equals by default to platform-defined `FLT_EPSILON`, or
 * `1.1920928955078125e-07F` if that's not available.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_FLT_EPSILON 1.1920928955078125e-07F /* 0x0.000002p0 */

/**
 * A macro to initialize an SDL interface.
 *
 * This macro will initialize an SDL interface structure and should be called
 * before you fill out the fields with your implementation.
 *
 * You can use it like this:
 *
 * ```cpp
 * IOStreamInterface iface;
 *
 * SDL_INIT_INTERFACE(&iface);
 *
 * // Fill in the interface function pointers with your implementation
 * iface.seek = ...
 *
 * stream = IOStream.Open(&iface, nullptr);
 * ```
 *
 * If you are using designated initializers, you can use the size of the
 * interface as the version, e.g.
 *
 * ```cpp
 * IOStreamInterface iface = {
 *     .version = sizeof(iface),
 *     .seek = ...
 * };
 * stream = IOStream.Open(&iface, nullptr);
 * ```
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 *
 * @sa IOStreamInterface
 * @sa StorageInterface
 * @sa SDL_VirtualJoystickDesc
 */
#define SDL_INIT_INTERFACE(iface)                                              \
  do {                                                                         \
    SDL_zerop(iface);                                                          \
    (iface)->version = sizeof(*(iface));                                       \
  } while (0)

#endif // SDL3PP_DOC

/**
 * Allocate uninitialized memory.
 *
 * The allocated memory returned by this function must be freed with
 * free().
 *
 * If `size` is 0, it will be set to 1.
 *
 * If the allocation is successful, the returned pointer is guaranteed to be
 * aligned to either the *fundamental alignment* (`alignof(max_align_t)` in
 * C11 and later) or `2 * sizeof(void *)`, whichever is smaller. Use
 * aligned_alloc() if you need to allocate memory aligned to an alignment
 * greater than this guarantee.
 *
 * @param size the size to allocate.
 * @returns a pointer to the allocated memory, or nullptr if allocation failed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa free
 * @sa calloc
 * @sa realloc
 * @sa aligned_alloc
 */
inline void* malloc(size_t size) { return SDL_malloc(size); }

/**
 * Allocate a zero-initialized array.
 *
 * The memory returned by this function must be freed with free().
 *
 * If either of `nmemb` or `size` is 0, they will both be set to 1.
 *
 * If the allocation is successful, the returned pointer is guaranteed to be
 * aligned to either the *fundamental alignment* (`alignof(max_align_t)` in
 * C11 and later) or `2 * sizeof(void *)`, whichever is smaller.
 *
 * @param nmemb the number of elements in the array.
 * @param size the size of each element of the array.
 * @returns a pointer to the allocated array, or nullptr if allocation failed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa free
 * @sa malloc
 * @sa realloc
 */
inline void* calloc(size_t nmemb, size_t size)
{
  return SDL_calloc(nmemb, size);
}

/**
 * Change the size of allocated memory.
 *
 * The memory returned by this function must be freed with free().
 *
 * If `size` is 0, it will be set to 1. Note that this is unlike some other C
 * runtime `realloc` implementations, which may treat `realloc(mem, 0)` the
 * same way as `free(mem)`.
 *
 * If `mem` is nullptr, the behavior of this function is equivalent to
 * malloc(). Otherwise, the function can have one of three possible
 * outcomes:
 *
 * - If it returns the same pointer as `mem`, it means that `mem` was resized
 *   in place without freeing.
 * - If it returns a different non-nullptr pointer, it means that `mem` was
 * freed and cannot be dereferenced anymore.
 * - If it returns nullptr (indicating failure), then `mem` will remain valid
 * and must still be freed with free().
 *
 * If the allocation is successfully resized, the returned pointer is
 * guaranteed to be aligned to either the *fundamental alignment*
 * (`alignof(max_align_t)` in C11 and later) or `2 * sizeof(void *)`,
 * whichever is smaller.
 *
 * @param mem a pointer to allocated memory to reallocate, or nullptr.
 * @param size the new size of the memory.
 * @returns a pointer to the newly allocated memory, or nullptr if allocation
 *          failed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa free
 * @sa malloc
 * @sa calloc
 */
inline void* realloc(void* mem, size_t size) { return SDL_realloc(mem, size); }

/**
 * Free allocated memory.
 *
 * The pointer is no longer valid after this call and cannot be dereferenced
 * anymore.
 *
 * If `mem` is nullptr, this function does nothing.
 *
 * @param mem a pointer to allocated memory, or nullptr.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa malloc
 * @sa calloc
 * @sa realloc
 */
inline void free(void* mem) { SDL_free(mem); }

/**
 * A callback used to implement malloc().
 *
 * SDL will always ensure that the passed `size` is greater than 0.
 *
 * @param size the size to allocate.
 * @returns a pointer to the allocated memory, or nullptr if allocation failed.
 *
 * @threadsafety It should be safe to call this callback from any thread.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa malloc
 * @sa GetOriginalMemoryFunctions
 * @sa GetMemoryFunctions
 * @sa SetMemoryFunctions
 */
using malloc_func = SDL_malloc_func;

/**
 * A callback used to implement calloc().
 *
 * SDL will always ensure that the passed `nmemb` and `size` are both greater
 * than 0.
 *
 * @param nmemb the number of elements in the array.
 * @param size the size of each element of the array.
 * @returns a pointer to the allocated array, or nullptr if allocation failed.
 *
 * @threadsafety It should be safe to call this callback from any thread.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa calloc
 * @sa GetOriginalMemoryFunctions
 * @sa GetMemoryFunctions
 * @sa SetMemoryFunctions
 */
using calloc_func = SDL_calloc_func;

/**
 * A callback used to implement realloc().
 *
 * SDL will always ensure that the passed `size` is greater than 0.
 *
 * @param mem a pointer to allocated memory to reallocate, or nullptr.
 * @param size the new size of the memory.
 * @returns a pointer to the newly allocated memory, or nullptr if allocation
 *          failed.
 *
 * @threadsafety It should be safe to call this callback from any thread.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa realloc
 * @sa GetOriginalMemoryFunctions
 * @sa GetMemoryFunctions
 * @sa SetMemoryFunctions
 */
using realloc_func = SDL_realloc_func;

/**
 * A callback used to implement free().
 *
 * SDL will always ensure that the passed `mem` is a non-nullptr pointer.
 *
 * @param mem a pointer to allocated memory.
 *
 * @threadsafety It should be safe to call this callback from any thread.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa free
 * @sa GetOriginalMemoryFunctions
 * @sa GetMemoryFunctions
 * @sa SetMemoryFunctions
 */
using free_func = SDL_free_func;

/**
 * Get the original set of SDL memory functions.
 *
 * This is what malloc and friends will use by default, if there has been
 * no call to SetMemoryFunctions. This is not necessarily using the C
 * runtime's `malloc` functions behind the scenes! Different platforms and
 * build configurations might do any number of unexpected things.
 *
 * @param malloc_func filled with malloc function.
 * @param calloc_func filled with calloc function.
 * @param realloc_func filled with realloc function.
 * @param free_func filled with free function.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void GetOriginalMemoryFunctions(malloc_func* malloc_func,
                                       calloc_func* calloc_func,
                                       realloc_func* realloc_func,
                                       free_func* free_func)
{
  SDL_GetOriginalMemoryFunctions(
    malloc_func, calloc_func, realloc_func, free_func);
}

/**
 * Get the current set of SDL memory functions.
 *
 * @param malloc_func filled with malloc function.
 * @param calloc_func filled with calloc function.
 * @param realloc_func filled with realloc function.
 * @param free_func filled with free function.
 *
 * @threadsafety This does not hold a lock, so do not call this in the
 *               unlikely event of a background thread calling
 *               SetMemoryFunctions simultaneously.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SetMemoryFunctions
 * @sa GetOriginalMemoryFunctions
 */
inline void GetMemoryFunctions(malloc_func* malloc_func,
                               calloc_func* calloc_func,
                               realloc_func* realloc_func,
                               free_func* free_func)
{
  SDL_GetMemoryFunctions(malloc_func, calloc_func, realloc_func, free_func);
}

/**
 * Replace SDL's memory allocation functions with a custom set.
 *
 * It is not safe to call this function once any allocations have been made,
 * as future calls to free will use the new allocator, even if they came
 * from an malloc made with the old one!
 *
 * If used, usually this needs to be the first call made into the SDL library,
 * if not the very first thing done at program startup time.
 *
 * @param malloc_func custom malloc function.
 * @param calloc_func custom calloc function.
 * @param realloc_func custom realloc function.
 * @param free_func custom free function.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread, but one
 *               should not replace the memory functions once any allocations
 *               are made!
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetMemoryFunctions
 * @sa GetOriginalMemoryFunctions
 */
inline void SetMemoryFunctions(malloc_func malloc_func,
                               calloc_func calloc_func,
                               realloc_func realloc_func,
                               free_func free_func)
{
  CheckError(
    SDL_SetMemoryFunctions(malloc_func, calloc_func, realloc_func, free_func));
}

/**
 * Allocate memory aligned to a specific alignment.
 *
 * The memory returned by this function must be freed with aligned_free(),
 * _not_ free().
 *
 * If `alignment` is less than the size of `void *`, it will be increased to
 * match that.
 *
 * The returned memory address will be a multiple of the alignment value, and
 * the size of the memory allocated will be a multiple of the alignment value.
 *
 * @param alignment the alignment of the memory.
 * @param size the size to allocate.
 * @returns a pointer to the aligned memory, or nullptr if allocation failed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa aligned_free
 */
inline void* aligned_alloc(size_t alignment, size_t size)
{
  return SDL_aligned_alloc(alignment, size);
}

/**
 * Free memory allocated by aligned_alloc().
 *
 * The pointer is no longer valid after this call and cannot be dereferenced
 * anymore.
 *
 * If `mem` is nullptr, this function does nothing.
 *
 * @param mem a pointer previously returned by aligned_alloc(), or nullptr.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa aligned_alloc
 */
inline void aligned_free(void* mem) { SDL_aligned_free(mem); }

/**
 * Get the number of outstanding (unfreed) allocations.
 *
 * @returns the number of allocations or -1 if allocation counting is
 *          disabled.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int GetNumAllocations() { return SDL_GetNumAllocations(); }

/**
 * A thread-safe set of environment variables
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @cat resource
 *
 * @sa GetEnvironment
 * @sa Environment.Environment
 * @sa Environment.GetVariable
 * @sa Environment.GetVariables
 * @sa Environment.SetVariable
 * @sa Environment.UnsetVariable
 * @sa Environment.Destroy
 */
class Environment
{
  EnvironmentRaw m_resource = nullptr;

public:
  /// Default ctor
  constexpr Environment() = default;

  /**
   * Constructs from EnvironmentParam.
   *
   * @param resource a EnvironmentRaw to be wrapped.
   *
   * This assumes the ownership, call release() if you need to take back.
   */
  constexpr explicit Environment(const EnvironmentRaw resource)
    : m_resource(resource)
  {
  }

  /// Copy constructor
  constexpr Environment(const Environment& other) = delete;

  /// Move constructor
  constexpr Environment(Environment&& other)
    : Environment(other.release())
  {
  }

  constexpr Environment(const EnvironmentRef& other) = delete;

  constexpr Environment(EnvironmentRef&& other) = delete;

  /**
   * Create a set of environment variables
   *
   * @param populated true to initialize it from the C runtime environment,
   *                  false to create an empty environment.
   * @post a pointer to the new environment or nullptr on failure; call
   *          GetError() for more information.
   *
   * @threadsafety If `populated` is false, it is safe to call this function
   *               from any thread, otherwise it is safe if no other threads are
   *               calling setenv() or unsetenv()
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Environment.GetVariable
   * @sa Environment.GetVariables
   * @sa Environment.SetVariable
   * @sa Environment.UnsetVariable
   * @sa Environment.Destroy
   */
  Environment(bool populated)
    : m_resource(SDL_CreateEnvironment(populated))
  {
  }

  /// Destructor
  ~Environment() { SDL_DestroyEnvironment(m_resource); }

  /// Assignment operator.
  Environment& operator=(Environment other)
  {
    std::swap(m_resource, other.m_resource);
    return *this;
  }

  /// Retrieves underlying EnvironmentRaw.
  constexpr EnvironmentRaw get() const { return m_resource; }

  /// Retrieves underlying EnvironmentRaw and clear this.
  constexpr EnvironmentRaw release()
  {
    auto r = m_resource;
    m_resource = nullptr;
    return r;
  }

  /// Comparison
  constexpr auto operator<=>(const Environment& other) const = default;

  /// Comparison
  constexpr bool operator==(std::nullptr_t _) const { return !m_resource; }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!m_resource; }

  /// Converts to EnvironmentParam
  constexpr operator EnvironmentParam() const { return {m_resource}; }

  /**
   * Destroy a set of environment variables.
   *
   *
   * @threadsafety It is safe to call this function from any thread, as long as
   *               the environment is no longer in use.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Environment.Environment
   */
  void Destroy();

  /**
   * Get the value of a variable in the environment.
   *
   * @param name the name of the variable to get.
   * @returns a pointer to the value of the variable or nullptr if it can't be
   *          found.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa GetEnvironment
   * @sa Environment.Environment
   * @sa Environment.GetVariables
   * @sa Environment.SetVariable
   * @sa Environment.UnsetVariable
   */
  const char* GetVariable(StringParam name);

  /**
   * Get all variables in the environment.
   *
   * @returns a nullptr terminated array of pointers to environment variables in
   *          the form "variable=value" on success. This is wrapped to be
   *          auto-deleted, use FreeWrapper.release() if you want to manage
   *          manually.
   * @throws Error on failure
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa GetEnvironment
   * @sa Environment.Environment
   * @sa Environment.GetVariables
   * @sa Environment.SetVariable
   * @sa Environment.UnsetVariable
   */
  OwnArray<char*> GetVariables();

  /**
   * Get the Variables count.
   *
   * @return the number of existing environment variables
   *
   * This might be slow.
   */
  Uint64 GetVariableCount()
  {
    Uint64 count = 0;
    for (auto& var : GetVariables()) count += 1;
    return count;
  }

  /**
   * Set the value of a variable in the environment.
   *
   * @param name the name of the variable to set.
   * @param value the value of the variable to set.
   * @param overwrite true to overwrite the variable if it exists, false to
   *                  return success without setting the variable if it already
   *                  exists.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa GetEnvironment
   * @sa Environment.Environment
   * @sa Environment.GetVariable
   * @sa Environment.GetVariables
   * @sa Environment.UnsetVariable
   */
  void SetVariable(StringParam name, StringParam value, bool overwrite);

  /**
   * Clear a variable from the environment.
   *
   * @param name the name of the variable to unset.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa GetEnvironment
   * @sa Environment.Environment
   * @sa Environment.GetVariable
   * @sa Environment.GetVariables
   * @sa Environment.SetVariable
   * @sa Environment.UnsetVariable
   */
  void UnsetVariable(StringParam name);
};

/// Semi-safe reference for Environment.
struct EnvironmentRef : Environment
{
  /**
   * Constructs from EnvironmentParam.
   *
   * @param resource a EnvironmentRaw or Environment.
   *
   * This does not takes ownership!
   */
  EnvironmentRef(EnvironmentParam resource)
    : Environment(resource.value)
  {
  }

  /// Copy constructor.
  EnvironmentRef(const EnvironmentRef& other)
    : Environment(other.get())
  {
  }

  /// Destructor
  ~EnvironmentRef() { release(); }
};

/**
 * Get the process environment.
 *
 * This is initialized at application start and is not affected by setenv()
 * and unsetenv() calls after that point. Use Environment.SetVariable() and
 * Environment.UnsetVariable() if you want to modify this environment, or
 * setenv_unsafe() or unsetenv_unsafe() if you want changes to persist
 * in the C runtime environment after Quit().
 *
 * @returns a pointer to the environment for the process or nullptr on failure;
 *          call GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Environment.GetVariable
 * @sa Environment.GetVariables
 * @sa Environment.SetVariable
 * @sa Environment.UnsetVariable
 */
inline EnvironmentRaw GetEnvironment() { return SDL_GetEnvironment(); }

/**
 * Create a set of environment variables
 *
 * @param populated true to initialize it from the C runtime environment,
 *                  false to create an empty environment.
 * @returns a pointer to the new environment or nullptr on failure; call
 *          GetError() for more information.
 *
 * @threadsafety If `populated` is false, it is safe to call this function
 *               from any thread, otherwise it is safe if no other threads are
 *               calling setenv() or unsetenv()
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Environment.GetVariable
 * @sa Environment.GetVariables
 * @sa Environment.SetVariable
 * @sa Environment.UnsetVariable
 * @sa Environment.Destroy
 */
inline Environment CreateEnvironment(bool populated)
{
  return Environment(populated);
}

/**
 * Get the value of a variable in the environment.
 *
 * @param env the environment to query.
 * @param name the name of the variable to get.
 * @returns a pointer to the value of the variable or nullptr if it can't be
 *          found.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetEnvironment
 * @sa Environment.Environment
 * @sa Environment.GetVariables
 * @sa Environment.SetVariable
 * @sa Environment.UnsetVariable
 */
inline const char* GetEnvironmentVariable(EnvironmentParam env,
                                          StringParam name)
{
  return SDL_GetEnvironmentVariable(env, name);
}

inline const char* Environment::GetVariable(StringParam name)
{
  return SDL::GetEnvironmentVariable(m_resource, std::move(name));
}

/**
 * Get all variables in the environment.
 *
 * @param env the environment to query.
 * @returns a nullptr terminated array of pointers to environment variables in
 *          the form "variable=value" or nullptr on failure; call GetError()
 *          for more information. This is a single allocation that should be
 *          freed with free() when it is no longer needed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetEnvironment
 * @sa Environment.Environment
 * @sa Environment.GetVariables
 * @sa Environment.SetVariable
 * @sa Environment.UnsetVariable
 */
inline OwnArray<char*> GetEnvironmentVariables(EnvironmentParam env)
{
  return OwnArray<char*>{CheckError(SDL_GetEnvironmentVariables(env))};
}

inline OwnArray<char*> Environment::GetVariables()
{
  return SDL::GetEnvironmentVariables(m_resource);
}

/**
 * Set the value of a variable in the environment.
 *
 * @param env the environment to modify.
 * @param name the name of the variable to set.
 * @param value the value of the variable to set.
 * @param overwrite true to overwrite the variable if it exists, false to
 *                  return success without setting the variable if it already
 *                  exists.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetEnvironment
 * @sa Environment.Environment
 * @sa Environment.GetVariable
 * @sa Environment.GetVariables
 * @sa Environment.UnsetVariable
 */
inline void SetEnvironmentVariable(EnvironmentParam env,
                                   StringParam name,
                                   StringParam value,
                                   bool overwrite)
{
  CheckError(SDL_SetEnvironmentVariable(env, name, value, overwrite));
}

inline void Environment::SetVariable(StringParam name,
                                     StringParam value,
                                     bool overwrite)
{
  SDL::SetEnvironmentVariable(
    m_resource, std::move(name), std::move(value), overwrite);
}

/**
 * Clear a variable from the environment.
 *
 * @param env the environment to modify.
 * @param name the name of the variable to unset.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetEnvironment
 * @sa Environment.Environment
 * @sa Environment.GetVariable
 * @sa Environment.GetVariables
 * @sa Environment.SetVariable
 * @sa Environment.UnsetVariable
 */
inline void UnsetEnvironmentVariable(EnvironmentParam env, StringParam name)
{
  CheckError(SDL_UnsetEnvironmentVariable(env, name));
}

inline void Environment::UnsetVariable(StringParam name)
{
  SDL::UnsetEnvironmentVariable(m_resource, std::move(name));
}

/**
 * Destroy a set of environment variables.
 *
 * @param env the environment to destroy.
 *
 * @threadsafety It is safe to call this function from any thread, as long as
 *               the environment is no longer in use.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Environment.Environment
 */
inline void DestroyEnvironment(EnvironmentRaw env)
{
  SDL_DestroyEnvironment(env);
}

inline void Environment::Destroy()
{
  SDL_DestroyEnvironment(m_resource);
  m_resource = nullptr;
}

/**
 * Get the value of a variable in the environment.
 *
 * This function uses SDL's cached copy of the environment and is thread-safe.
 *
 * @param name the name of the variable to get.
 * @returns a pointer to the value of the variable or nullptr if it can't be
 *          found.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline const char* getenv(StringParam name) { return SDL_getenv(name); }

/**
 * Get the value of a variable in the environment.
 *
 * This function bypasses SDL's cached copy of the environment and is not
 * thread-safe.
 *
 * @param name the name of the variable to get.
 * @returns a pointer to the value of the variable or nullptr if it can't be
 *          found.
 *
 * @threadsafety This function is not thread safe, consider using getenv()
 *               instead.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa getenv
 */
inline const char* getenv_unsafe(StringParam name)
{
  return SDL_getenv_unsafe(name);
}

/**
 * Set the value of a variable in the environment.
 *
 * @param name the name of the variable to set.
 * @param value the value of the variable to set.
 * @param overwrite 1 to overwrite the variable if it exists, 0 to return
 *                  success without setting the variable if it already exists.
 * @returns 0 on success, -1 on error.
 *
 * @threadsafety This function is not thread safe, consider using
 *               Environment.SetVariable() instead.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Environment.SetVariable
 */
inline int setenv_unsafe(StringParam name, StringParam value, int overwrite)
{
  return SDL_setenv_unsafe(name, value, overwrite);
}

/**
 * Clear a variable from the environment.
 *
 * @param name the name of the variable to unset.
 * @returns 0 on success, -1 on error.
 *
 * @threadsafety This function is not thread safe, consider using
 *               Environment.UnsetVariable() instead.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Environment.UnsetVariable
 */
inline int unsetenv_unsafe(StringParam name)
{
  return SDL_unsetenv_unsafe(name);
}

/**
 * A callback used with SDL sorting and binary search functions.
 *
 * @param a a pointer to the first element being compared.
 * @param b a pointer to the second element being compared.
 * @returns -1 if `a` should be sorted before `b`, 1 if `b` should be sorted
 *          before `a`, 0 if they are equal. If two elements are equal, their
 *          order in the sorted array is undefined.
 *
 * @since This callback is available since SDL 3.2.0.
 *
 * @sa bsearch
 * @sa qsort
 */
using CompareCallback = SDL_CompareCallback;

/**
 * Sort an array.
 *
 * For example:
 *
 * ```c
 * typedef struct {
 *     int key;
 *     const char *string;
 * } data;
 *
 * int SDLCALL compare(const void *a, const void *b)
 * {
 *     const data *A = (const data *)a;
 *     const data *B = (const data *)b;
 *
 *     if (A->n < B->n) {
 *         return -1;
 *     } else if (B->n < A->n) {
 *         return 1;
 *     } else {
 *         return 0;
 *     }
 * }
 *
 * data values[] = {
 *     { 3, "third" }, { 1, "first" }, { 2, "second" }
 * };
 *
 * qsort(values, arraysize(values), sizeof(values[0]), compare);
 * ```
 *
 * @param base a pointer to the start of the array.
 * @param nmemb the number of elements in the array.
 * @param size the size of the elements in the array.
 * @param compare a function used to compare elements in the array.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa bsearch
 * @sa qsort_r
 */
inline void qsort(void* base,
                  size_t nmemb,
                  size_t size,
                  CompareCallback compare)
{
  SDL_qsort(base, nmemb, size, compare);
}

/**
 * Perform a binary search on a previously sorted array.
 *
 * For example:
 *
 * ```c
 * typedef struct {
 *     int key;
 *     const char *string;
 * } data;
 *
 * int SDLCALL compare(const void *a, const void *b)
 * {
 *     const data *A = (const data *)a;
 *     const data *B = (const data *)b;
 *
 *     if (A->n < B->n) {
 *         return -1;
 *     } else if (B->n < A->n) {
 *         return 1;
 *     } else {
 *         return 0;
 *     }
 * }
 *
 * data values[] = {
 *     { 1, "first" }, { 2, "second" }, { 3, "third" }
 * };
 * data key = { 2, nullptr };
 *
 * data *result = bsearch(&key, values, arraysize(values), sizeof(values[0]),
 * compare);
 * ```
 *
 * @param key a pointer to a key equal to the element being searched for.
 * @param base a pointer to the start of the array.
 * @param nmemb the number of elements in the array.
 * @param size the size of the elements in the array.
 * @param compare a function used to compare elements in the array.
 * @returns a pointer to the matching element in the array, or nullptr if not
 *          found.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa bsearch_r
 * @sa qsort
 */
inline void* bsearch(const void* key,
                     const void* base,
                     size_t nmemb,
                     size_t size,
                     CompareCallback compare)
{
  return SDL_bsearch(key, base, nmemb, size, compare);
}

/**
 * A callback used with SDL sorting and binary search functions.
 *
 * @param userdata the `userdata` pointer passed to the sort function.
 * @param a a pointer to the first element being compared.
 * @param b a pointer to the second element being compared.
 * @returns -1 if `a` should be sorted before `b`, 1 if `b` should be sorted
 *          before `a`, 0 if they are equal. If two elements are equal, their
 *          order in the sorted array is undefined.
 *
 * @since This callback is available since SDL 3.2.0.
 *
 * @sa qsort_r
 * @sa bsearch_r
 */
using CompareCallback_r = SDL_CompareCallback_r;

/**
 * A callback used with SDL sorting and binary search functions.
 *
 * @param a a pointer to the first element being compared.
 * @param b a pointer to the second element being compared.
 * @returns -1 if `a` should be sorted before `b`, 1 if `b` should be sorted
 *          before `a`, 0 if they are equal. If two elements are equal, their
 *          order in the sorted array is undefined.
 *
 * @since This callback is available since SDL 3.2.0.
 *
 * @sa qsort_r
 * @sa bsearch_r
 * @sa CompareCallback_r
 */
using CompareCB = std::function<int(const void*, const void*)>;

/**
 * Sort an array, passing a userdata pointer to the compare function.
 *
 * For example:
 *
 * ```c
 * typedef enum {
 *     sort_increasing,
 *     sort_decreasing,
 * } sort_method;
 *
 * typedef struct {
 *     int key;
 *     const char *string;
 * } data;
 *
 * int SDLCALL compare(const void *userdata, const void *a, const void *b)
 * {
 *     sort_method method = (sort_method)(uintptr_t)userdata;
 *     const data *A = (const data *)a;
 *     const data *B = (const data *)b;
 *
 *     if (A->key < B->key) {
 *         return (method == sort_increasing) ? -1 : 1;
 *     } else if (B->key < A->key) {
 *         return (method == sort_increasing) ? 1 : -1;
 *     } else {
 *         return 0;
 *     }
 * }
 *
 * data values[] = {
 *     { 3, "third" }, { 1, "first" }, { 2, "second" }
 * };
 *
 * qsort_r(values, arraysize(values), sizeof(values[0]), compare, (const void
 * *)(uintptr_t)sort_increasing);
 * ```
 *
 * @param base a pointer to the start of the array.
 * @param nmemb the number of elements in the array.
 * @param size the size of the elements in the array.
 * @param compare a function used to compare elements in the array.
 * @param userdata a pointer to pass to the compare function.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa bsearch_r
 * @sa qsort
 */
inline void qsort_r(void* base,
                    size_t nmemb,
                    size_t size,
                    CompareCallback_r compare,
                    void* userdata)
{
  SDL_qsort_r(base, nmemb, size, compare, userdata);
}

/**
 * Sort an array, passing a userdata pointer to the compare function.
 *
 * For example:
 *
 * ```c
 * typedef enum {
 *     sort_increasing,
 *     sort_decreasing,
 * } sort_method;
 *
 * typedef struct {
 *     int key;
 *     const char *string;
 * } data;
 *
 * int SDLCALL compare(const void *userdata, const void *a, const void *b)
 * {
 *     sort_method method = (sort_method)(uintptr_t)userdata;
 *     const data *A = (const data *)a;
 *     const data *B = (const data *)b;
 *
 *     if (A->key < B->key) {
 *         return (method == sort_increasing) ? -1 : 1;
 *     } else if (B->key < A->key) {
 *         return (method == sort_increasing) ? 1 : -1;
 *     } else {
 *         return 0;
 *     }
 * }
 *
 * data values[] = {
 *     { 3, "third" }, { 1, "first" }, { 2, "second" }
 * };
 *
 * qsort_r(values, arraysize(values), sizeof(values[0]), compare, (const void
 * *)(uintptr_t)sort_increasing);
 * ```
 *
 * @param base a pointer to the start of the array.
 * @param nmemb the number of elements in the array.
 * @param size the size of the elements in the array.
 * @param compare a function used to compare elements in the array.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa bsearch_r
 * @sa qsort
 */
inline void qsort_r(void* base, size_t nmemb, size_t size, CompareCB compare)
{
  return qsort_r(
    base,
    nmemb,
    size,
    [](void* userdata, const void* a, const void* b) {
      auto& cb = *static_cast<CompareCB*>(userdata);
      return cb(a, b);
    },
    &compare);
}

/**
 * Perform a binary search on a previously sorted array, passing a userdata
 * pointer to the compare function.
 *
 * For example:
 *
 * ```c
 * typedef enum {
 *     sort_increasing,
 *     sort_decreasing,
 * } sort_method;
 *
 * typedef struct {
 *     int key;
 *     const char *string;
 * } data;
 *
 * int SDLCALL compare(const void *userdata, const void *a, const void *b)
 * {
 *     sort_method method = (sort_method)(uintptr_t)userdata;
 *     const data *A = (const data *)a;
 *     const data *B = (const data *)b;
 *
 *     if (A->key < B->key) {
 *         return (method == sort_increasing) ? -1 : 1;
 *     } else if (B->key < A->key) {
 *         return (method == sort_increasing) ? 1 : -1;
 *     } else {
 *         return 0;
 *     }
 * }
 *
 * data values[] = {
 *     { 1, "first" }, { 2, "second" }, { 3, "third" }
 * };
 * data key = { 2, nullptr };
 *
 * data *result = bsearch_r(&key, values, arraysize(values), sizeof(values[0]),
 * compare, (const void *)(uintptr_t)sort_increasing);
 * ```
 *
 * @param key a pointer to a key equal to the element being searched for.
 * @param base a pointer to the start of the array.
 * @param nmemb the number of elements in the array.
 * @param size the size of the elements in the array.
 * @param compare a function used to compare elements in the array.
 * @param userdata a pointer to pass to the compare function.
 * @returns a pointer to the matching element in the array, or nullptr if not
 *          found.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa bsearch
 * @sa qsort_r
 */
inline void* bsearch_r(const void* key,
                       const void* base,
                       size_t nmemb,
                       size_t size,
                       CompareCallback_r compare,
                       void* userdata)
{
  return SDL_bsearch_r(key, base, nmemb, size, compare, userdata);
}

/**
 * Perform a binary search on a previously sorted array, passing a userdata
 * pointer to the compare function.
 *
 * For example:
 *
 * ```c
 * typedef enum {
 *     sort_increasing,
 *     sort_decreasing,
 * } sort_method;
 *
 * typedef struct {
 *     int key;
 *     const char *string;
 * } data;
 *
 * int SDLCALL compare(const void *userdata, const void *a, const void *b)
 * {
 *     sort_method method = (sort_method)(uintptr_t)userdata;
 *     const data *A = (const data *)a;
 *     const data *B = (const data *)b;
 *
 *     if (A->key < B->key) {
 *         return (method == sort_increasing) ? -1 : 1;
 *     } else if (B->key < A->key) {
 *         return (method == sort_increasing) ? 1 : -1;
 *     } else {
 *         return 0;
 *     }
 * }
 *
 * data values[] = {
 *     { 1, "first" }, { 2, "second" }, { 3, "third" }
 * };
 * data key = { 2, nullptr };
 *
 * data *result = bsearch_r(&key, values, arraysize(values), sizeof(values[0]),
 * compare, (const void *)(uintptr_t)sort_increasing);
 * ```
 *
 * @param key a pointer to a key equal to the element being searched for.
 * @param base a pointer to the start of the array.
 * @param nmemb the number of elements in the array.
 * @param size the size of the elements in the array.
 * @param compare a function used to compare elements in the array.
 * @returns a pointer to the matching element in the array, or nullptr if not
 *          found.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa bsearch
 * @sa qsort_r
 */
inline void* bsearch_r(const void* key,
                       const void* base,
                       size_t nmemb,
                       size_t size,
                       CompareCB compare)
{
  return bsearch_r(
    key,
    base,
    nmemb,
    size,
    [](void* userdata, const void* a, const void* b) {
      auto& cb = *static_cast<CompareCB*>(userdata);
      return cb(a, b);
    },
    &compare);
}

/**
 * Compute the absolute value of `x`.
 *
 * @param x an integer value.
 * @returns the absolute value of x.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int abs(int x) { return SDL_abs(x); }

/**
 * Compute the absolute value of `x`
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `0 <= y <= INF`
 *
 * This function operates on double-precision floating point values, use
 * abs for single-precision floats.
 *
 * @param x floating point value to use as the magnitude.
 * @returns the absolute value of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa abs
 */
inline double abs(double x) { return SDL_fabs(x); }

/**
 * Compute the absolute value of `x`
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `0 <= y <= INF`
 *
 * This function operates on single-precision floating point values, use
 * abs for double-precision floats.
 *
 * @param x floating point value to use as the magnitude.
 * @returns the absolute value of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa abs
 */
inline float abs(float x) { return SDL_fabsf(x); }

/**
 * Return the lesser of two values.
 *
 * This is a helper macro that might be more clear than writing out the
 * comparisons directly, and works with any type that can be compared with the
 * `<` operator. However, it double-evaluates both its parameters, so do not
 * use expressions with side-effects here.
 *
 * @param x the first value to compare.
 * @param y the second value to compare.
 * @returns the lesser of `x` and `y`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
template<class T, class U>
constexpr T min(T x, U y)
{
  return SDL_min(x, y);
}

/**
 * Return the greater of two values.
 *
 * This is a helper function that might be more clear than writing out the
 * comparisons directly, and works with any type that can be compared with the
 * `>` operator. However, it double-evaluates both its parameters, so do not
 * use expressions with side-effects here.
 *
 * @param x the first value to compare.
 * @param y the second value to compare.
 * @returns the lesser of `x` and `y`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
template<class T, class U>
constexpr T max(T x, U y)
{
  return SDL_max(x, y);
}

/**
 * Return a value clamped to a range.
 *
 * If `x` is outside the range a values between `a` and `b`, the returned
 * value will be `a` or `b` as appropriate. Otherwise, `x` is returned.
 *
 * This function will produce incorrect results if `b` is less than `a`.
 *
 * This is a helper function that might be more clear than writing out the
 * comparisons directly, and works with any type that can be compared with the
 * `<` and `>` operators. However, it double-evaluates all its parameters, so
 * do not use expressions with side-effects here.
 *
 * @param x the value to compare.
 * @param a the low end value.
 * @param b the high end value.
 * @returns x, clamped between a and b.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
template<class T, class U, class V>
constexpr T clamp(T x, U a, V b)
{
  return SDL_clamp(x, a, b);
}

/**
 * Query if a character is alphabetic (a letter).
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * for English 'a-z' and 'A-Z' as true.
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int isalpha(int x) { return SDL_isalpha(x); }

/**
 * Query if a character is alphabetic (a letter) or a number.
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * for English 'a-z', 'A-Z', and '0-9' as true.
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int isalnum(int x) { return SDL_isalnum(x); }

/**
 * Report if a character is blank (a space or tab).
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * 0x20 (space) or 0x9 (tab) as true.
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int isblank(int x) { return SDL_isblank(x); }

/**
 * Report if a character is a control character.
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * 0 through 0x1F, and 0x7F, as true.
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int iscntrl(int x) { return SDL_iscntrl(x); }

/**
 * Report if a character is a numeric digit.
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * '0' (0x30) through '9' (0x39), as true.
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int isdigit(int x) { return SDL_isdigit(x); }

/**
 * Report if a character is a hexadecimal digit.
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * 'A' through 'F', 'a' through 'f', and '0' through '9', as true.
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int isxdigit(int x) { return SDL_isxdigit(x); }

/**
 * Report if a character is a punctuation mark.
 *
 * **WARNING**: Regardless of system locale, this is equivalent to
 * `((isgraph(x)) && (!isalnum(x)))`.
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa isgraph
 * @sa isalnum
 */
inline int ispunct(int x) { return SDL_ispunct(x); }

/**
 * Report if a character is whitespace.
 *
 * **WARNING**: Regardless of system locale, this will only treat the
 * following ASCII values as true:
 *
 * - space (0x20)
 * - tab (0x09)
 * - newline (0x0A)
 * - vertical tab (0x0B)
 * - form feed (0x0C)
 * - return (0x0D)
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int isspace(int x) { return SDL_isspace(x); }

/**
 * Report if a character is upper case.
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * 'A' through 'Z' as true.
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int isupper(int x) { return SDL_isupper(x); }

/**
 * Report if a character is lower case.
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * 'a' through 'z' as true.
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int islower(int x) { return SDL_islower(x); }

/**
 * Report if a character is "printable".
 *
 * Be advised that "printable" has a definition that goes back to text
 * terminals from the dawn of computing, making this a sort of special case
 * function that is not suitable for Unicode (or most any) text management.
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * ' ' (0x20) through '~' (0x7E) as true.
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int isprint(int x) { return SDL_isprint(x); }

/**
 * Report if a character is any "printable" except space.
 *
 * Be advised that "printable" has a definition that goes back to text
 * terminals from the dawn of computing, making this a sort of special case
 * function that is not suitable for Unicode (or most any) text management.
 *
 * **WARNING**: Regardless of system locale, this is equivalent to
 * `(isprint(x)) && ((x) != ' ')`.
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa isprint
 */
inline int isgraph(int x) { return SDL_isgraph(x); }

/**
 * Convert low-ASCII English letters to uppercase.
 *
 * **WARNING**: Regardless of system locale, this will only convert ASCII
 * values 'a' through 'z' to uppercase.
 *
 * This function returns the uppercase equivalent of `x`. If a character
 * cannot be converted, or is already uppercase, this function returns `x`.
 *
 * @param x character value to check.
 * @returns capitalized version of x, or x if no conversion available.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int toupper(int x) { return SDL_toupper(x); }

/**
 * Convert low-ASCII English letters to lowercase.
 *
 * **WARNING**: Regardless of system locale, this will only convert ASCII
 * values 'A' through 'Z' to lowercase.
 *
 * This function returns the lowercase equivalent of `x`. If a character
 * cannot be converted, or is already lowercase, this function returns `x`.
 *
 * @param x character value to check.
 * @returns lowercase version of x, or x if no conversion available.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int tolower(int x) { return SDL_tolower(x); }

/**
 * Calculate a CRC-16 value.
 *
 * https://en.wikipedia.org/wiki/Cyclic_redundancy_check
 *
 * This function can be called multiple times, to stream data to be
 * checksummed in blocks. Each call must provide the previous CRC-16 return
 * value to be updated with the next block. The first call to this function
 * for a set of blocks should pass in a zero CRC value.
 *
 * @param crc the current checksum for this data set, or 0 for a new data set.
 * @param data a new block of data to add to the checksum.
 * @param len the size, in bytes, of the new block of data.
 * @returns a CRC-16 checksum value of all blocks in the data set.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Uint16 crc16(Uint16 crc, const void* data, size_t len)
{
  return SDL_crc16(crc, data, len);
}

/**
 * Calculate a CRC-32 value.
 *
 * https://en.wikipedia.org/wiki/Cyclic_redundancy_check
 *
 * This function can be called multiple times, to stream data to be
 * checksummed in blocks. Each call must provide the previous CRC-32 return
 * value to be updated with the next block. The first call to this function
 * for a set of blocks should pass in a zero CRC value.
 *
 * @param crc the current checksum for this data set, or 0 for a new data set.
 * @param data a new block of data to add to the checksum.
 * @param len the size, in bytes, of the new block of data.
 * @returns a CRC-32 checksum value of all blocks in the data set.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Uint32 crc32(Uint32 crc, const void* data, size_t len)
{
  return SDL_crc32(crc, data, len);
}

/**
 * Calculate a 32-bit MurmurHash3 value for a block of data.
 *
 * https://en.wikipedia.org/wiki/MurmurHash
 *
 * A seed may be specified, which changes the final results consistently, but
 * this does not work like crc16 and crc32: you can't feed a previous
 * result from this function back into itself as the next seed value to
 * calculate a hash in chunks; it won't produce the same hash as it would if
 * the same data was provided in a single call.
 *
 * If you aren't sure what to provide for a seed, zero is fine. Murmur3 is not
 * cryptographically secure, so it shouldn't be used for hashing top-secret
 * data.
 *
 * @param data the data to be hashed.
 * @param len the size of data, in bytes.
 * @param seed a value that alters the final hash value.
 * @returns a Murmur3 32-bit hash value.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Uint32 murmur3_32(const void* data, size_t len, Uint32 seed)
{
  return SDL_murmur3_32(data, len, seed);
}

/**
 * Copy non-overlapping memory.
 *
 * The memory regions must not overlap. If they do, use memmove() instead.
 *
 * @param dst The destination memory region. Must not be nullptr, and must not
 *            overlap with `src`.
 * @param src The source memory region. Must not be nullptr, and must not
 * overlap with `dst`.
 * @param len The length in bytes of both `dst` and `src`.
 * @returns `dst`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa memmove
 */
inline void* memcpy(void* dst, const void* src, size_t len)
{
#ifdef SDL_SLOW_MEMCPY
  return SDL_memcpy(dst, src, len);
#else
  return ::memcpy(dst, src, len);
#endif // SDL_SLOW_MEMCPY
}

#ifdef SDL3PP_DOC

/**
 * A macro to copy memory between objects, with basic type checking.
 *
 * memcpy and memmove do not care where you copy memory to and from,
 * which can lead to bugs. This macro aims to avoid most of those bugs by
 * making sure that the source and destination are both pointers to objects
 * that are the same size. It does not check that the objects are the same
 * _type_, just that the copy will not overflow either object.
 *
 * The size check happens at compile time, and the compiler will throw an
 * error if the objects are different sizes.
 *
 * Generally this is intended to copy a single object, not an array.
 *
 * This macro looks like it double-evaluates its parameters, but the extras
 * them are in `sizeof` sections, which generate no code nor side-effects.
 *
 * @param dst a pointer to the destination object. Must not be nullptr.
 * @param src a pointer to the source object. Must not be nullptr.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
#define SDL_copyp(dst, src)                                                    \
  {                                                                            \
    SDL_COMPILE_TIME_ASSERT(SDL_copyp, sizeof(*(dst)) == sizeof(*(src)));      \
  }                                                                            \
  SDL_memcpy((dst), (src), sizeof(*(src)))

#endif // SDL3PP_DOC

/**
 * Copy memory ranges that might overlap.
 *
 * It is okay for the memory regions to overlap. If you are confident that the
 * regions never overlap, using memcpy() may improve performance.
 *
 * @param dst The destination memory region. Must not be nullptr.
 * @param src The source memory region. Must not be nullptr.
 * @param len The length in bytes of both `dst` and `src`.
 * @returns `dst`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa memcpy
 */
inline void* memmove(void* dst, const void* src, size_t len)
{
#ifdef SDL_SLOW_MEMMOVE
  return SDL_memmove(dst, src, len);
#else
  return ::memmove(dst, src, len);
#endif // SDL_SLOW_MEMMOVE
}

/**
 * Initialize all bytes of buffer of memory to a specific value.
 *
 * This function will set `len` bytes, pointed to by `dst`, to the value
 * specified in `c`.
 *
 * Despite `c` being an `int` instead of a `char`, this only operates on
 * bytes; `c` must be a value between 0 and 255, inclusive.
 *
 * @param dst the destination memory region. Must not be nullptr.
 * @param c the byte value to set.
 * @param len the length, in bytes, to set in `dst`.
 * @returns `dst`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void* memset(void* dst, int c, size_t len)
{
#ifdef SDL_SLOW_MEMSET
  return SDL_memset(dst, c, len);
#else
  return ::memset(dst, c, len);
#endif // SDL_SLOW_MEMSET
}

/**
 * Initialize all 32-bit words of buffer of memory to a specific value.
 *
 * This function will set a buffer of `dwords` Uint32 values, pointed to by
 * `dst`, to the value specified in `val`.
 *
 * Unlike memset, this sets 32-bit values, not bytes, so it's not limited
 * to a range of 0-255.
 *
 * @param dst the destination memory region. Must not be nullptr.
 * @param val the Uint32 value to set.
 * @param dwords the number of Uint32 values to set in `dst`.
 * @returns `dst`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void* memset4(void* dst, Uint32 val, size_t dwords)
{
  return SDL_memset4(dst, val, dwords);
}

/**
 * Clear an object's memory to zero.
 *
 * This is wrapper over memset that handles calculating the object size,
 * so there's no chance of copy/paste errors, and the code is cleaner.
 *
 * This requires an object, not a pointer to an object, nor an array.
 *
 * @param x the object to clear.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 *
 * @sa zerop
 * @sa zeroa
 */
template<class T>
inline void zero(T& x)
{
  SDL_zero(x);
}

/**
 * Clear an object's memory to zero, using a pointer.
 *
 * This is wrapper over memset that handles calculating the object size,
 * so there's no chance of copy/paste errors, and the code is cleaner.
 *
 * This requires a pointer to an object, not an object itself, nor an array.
 *
 * @param x a pointer to the object to clear.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 *
 * @sa zero
 * @sa zeroa
 */
template<class T>
inline void zerop(T* x)
{
  SDL_zerop(x);
}

/**
 * Clear an array's memory to zero.
 *
 * This is wrapper over memset that handles calculating the array size, so
 * there's no chance of copy/paste errors, and the code is cleaner.
 *
 * This requires an array, not an object, nor a pointer to an object.
 *
 * @param x an array to clear.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa zero
 * @sa zeroa
 */
template<class T, std::size_t N>
inline void zeroa(T (&x)[N])
{
  SDL_zeroa(x);
}

/**
 * Compare two buffers of memory.
 *
 * @param s1 the first buffer to compare. nullptr is not permitted!
 * @param s2 the second buffer to compare. nullptr is not permitted!
 * @param len the number of bytes to compare between the buffers.
 * @returns less than zero if s1 is "less than" s2, greater than zero if s1 is
 *          "greater than" s2, and zero if the buffers match exactly for `len`
 *          bytes.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int memcmp(const void* s1, const void* s2, size_t len)
{
  return SDL_memcmp(s1, s2, len);
}

/**
 * This works exactly like wcslen() but doesn't require access to a C runtime.
 *
 * Counts the number of wchar_t values in `wstr`, excluding the null
 * terminator.
 *
 * Like strlen only counts bytes and not codepoints in a UTF-8 string,
 * this counts wchar_t values in a string, even if the string's encoding is of
 * variable width, like UTF-16.
 *
 * Also be aware that wchar_t is different sizes on different platforms (4
 * bytes on Linux, 2 on Windows, etc).
 *
 * @param wstr The null-terminated wide string to read. Must not be nullptr.
 * @returns the length (in wchar_t values, excluding the null terminator) of
 *          `wstr`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa wcsnlen
 * @sa utf8strlen
 * @sa utf8strnlen
 */
inline size_t wcslen(const wchar_t* wstr) { return SDL_wcslen(wstr); }

/**
 * This works exactly like wcsnlen() but doesn't require access to a C
 * runtime.
 *
 * Counts up to a maximum of `maxlen` wchar_t values in `wstr`, excluding the
 * null terminator.
 *
 * Like strnlen only counts bytes and not codepoints in a UTF-8 string,
 * this counts wchar_t values in a string, even if the string's encoding is of
 * variable width, like UTF-16.
 *
 * Also be aware that wchar_t is different sizes on different platforms (4
 * bytes on Linux, 2 on Windows, etc).
 *
 * Also, `maxlen` is a count of wide characters, not bytes!
 *
 * @param wstr The null-terminated wide string to read. Must not be nullptr.
 * @param maxlen The maximum amount of wide characters to count.
 * @returns the length (in wide characters, excluding the null terminator) of
 *          `wstr` but never more than `maxlen`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa wcslen
 * @sa utf8strlen
 * @sa utf8strnlen
 */
inline size_t wcsnlen(const wchar_t* wstr, size_t maxlen)
{
  return SDL_wcsnlen(wstr, maxlen);
}

/**
 * Copy a wide string.
 *
 * This function copies `maxlen` - 1 wide characters from `src` to `dst`, then
 * appends a null terminator.
 *
 * `src` and `dst` must not overlap.
 *
 * If `maxlen` is 0, no wide characters are copied and no null terminator is
 * written.
 *
 * @param dst The destination buffer. Must not be nullptr, and must not overlap
 *            with `src`.
 * @param src The null-terminated wide string to copy. Must not be nullptr, and
 *            must not overlap with `dst`.
 * @param maxlen The length (in wide characters) of the destination buffer.
 * @returns the length (in wide characters, excluding the null terminator) of
 *          `src`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa wcslcat
 */
inline size_t wcslcpy(wchar_t* dst, const wchar_t* src, size_t maxlen)
{
  return SDL_wcslcpy(dst, src, maxlen);
}

/**
 * Concatenate wide strings.
 *
 * This function appends up to `maxlen` - wcslen(dst) - 1 wide characters
 * from `src` to the end of the wide string in `dst`, then appends a null
 * terminator.
 *
 * `src` and `dst` must not overlap.
 *
 * If `maxlen` - wcslen(dst) - 1 is less than or equal to 0, then `dst` is
 * unmodified.
 *
 * @param dst The destination buffer already containing the first
 *            null-terminated wide string. Must not be nullptr and must not
 *            overlap with `src`.
 * @param src The second null-terminated wide string. Must not be nullptr, and
 *            must not overlap with `dst`.
 * @param maxlen The length (in wide characters) of the destination buffer.
 * @returns the length (in wide characters, excluding the null terminator) of
 *          the string in `dst` plus the length of `src`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa wcslcpy
 */
inline size_t wcslcat(wchar_t* dst, const wchar_t* src, size_t maxlen)
{
  return SDL_wcslcat(dst, src, maxlen);
}

/**
 * Allocate a copy of a wide string.
 *
 * This allocates enough space for a null-terminated copy of `wstr`, using
 * malloc, and then makes a copy of the string into this space.
 *
 * The returned string is owned by the caller, and should be passed to
 * free when no longer needed.
 *
 * @param wstr the string to copy.
 * @returns a pointer to the newly-allocated wide string.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline wchar_t* wcsdup(const wchar_t* wstr) { return SDL_wcsdup(wstr); }

/**
 * Search a wide string for the first instance of a specific substring.
 *
 * The search ends once it finds the requested substring, or a null terminator
 * byte to end the string.
 *
 * Note that this looks for strings of _wide characters_, not _codepoints_, so
 * it's legal to search for malformed and incomplete UTF-16 sequences.
 *
 * @param haystack the wide string to search. Must not be nullptr.
 * @param needle the wide string to search for. Must not be nullptr.
 * @returns a pointer to the first instance of `needle` in the string, or
 * nullptr if not found.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline wchar_t* wcsstr(const wchar_t* haystack, const wchar_t* needle)
{
  return SDL_wcsstr(haystack, needle);
}

/**
 * Search a wide string, up to n wide chars, for the first instance of a
 * specific substring.
 *
 * The search ends once it finds the requested substring, or a null terminator
 * value to end the string, or `maxlen` wide character have been examined. It
 * is possible to use this function on a wide string without a null
 * terminator.
 *
 * Note that this looks for strings of _wide characters_, not _codepoints_, so
 * it's legal to search for malformed and incomplete UTF-16 sequences.
 *
 * @param haystack the wide string to search. Must not be nullptr.
 * @param needle the wide string to search for. Must not be nullptr.
 * @param maxlen the maximum number of wide characters to search in
 *               `haystack`.
 * @returns a pointer to the first instance of `needle` in the string, or
 * nullptr if not found.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline wchar_t* wcsnstr(const wchar_t* haystack,
                        const wchar_t* needle,
                        size_t maxlen)
{
  return SDL_wcsnstr(haystack, needle, maxlen);
}

/**
 * Compare two null-terminated wide strings.
 *
 * This only compares wchar_t values until it hits a null-terminating
 * character; it does not care if the string is well-formed UTF-16 (or UTF-32,
 * depending on your platform's wchar_t size), or uses valid Unicode values.
 *
 * @param str1 the first string to compare. nullptr is not permitted!
 * @param str2 the second string to compare. nullptr is not permitted!
 * @returns less than zero if str1 is "less than" str2, greater than zero if
 *          str1 is "greater than" str2, and zero if the strings match
 *          exactly.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int wcscmp(const wchar_t* str1, const wchar_t* str2)
{
  return SDL_wcscmp(str1, str2);
}

/**
 * Compare two wide strings up to a number of wchar_t values.
 *
 * This only compares wchar_t values; it does not care if the string is
 * well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),
 * or uses valid Unicode values.
 *
 * Note that while this function is intended to be used with UTF-16 (or
 * UTF-32, depending on your platform's definition of wchar_t), it is
 * comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies
 * a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16
 * sequence, it will only compare a portion of the final character.
 *
 * `maxlen` specifies a maximum number of wchar_t to compare; if the strings
 * match to this number of wide chars (or both have matched to a
 * null-terminator character before this count), they will be considered
 * equal.
 *
 * @param str1 the first string to compare. nullptr is not permitted!
 * @param str2 the second string to compare. nullptr is not permitted!
 * @param maxlen the maximum number of wchar_t to compare.
 * @returns less than zero if str1 is "less than" str2, greater than zero if
 *          str1 is "greater than" str2, and zero if the strings match
 *          exactly.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int wcsncmp(const wchar_t* str1, const wchar_t* str2, size_t maxlen)
{
  return SDL_wcsncmp(str1, str2, maxlen);
}

/**
 * Compare two null-terminated wide strings, case-insensitively.
 *
 * This will work with Unicode strings, using a technique called
 * "case-folding" to handle the vast majority of case-sensitive human
 * languages regardless of system locale. It can deal with expanding values: a
 * German Eszett character can compare against two ASCII 's' chars and be
 * considered a match, for example. A notable exception: it does not handle
 * the Turkish 'i' character; human language is complicated!
 *
 * Depending on your platform, "wchar_t" might be 2 bytes, and expected to be
 * UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this
 * handles Unicode, it expects the string to be well-formed and not a
 * null-terminated string of arbitrary bytes. Characters that are not valid
 * UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT
 * CHARACTER), which is to say two strings of random bits may turn out to
 * match if they convert to the same amount of replacement characters.
 *
 * @param str1 the first string to compare. nullptr is not permitted!
 * @param str2 the second string to compare. nullptr is not permitted!
 * @returns less than zero if str1 is "less than" str2, greater than zero if
 *          str1 is "greater than" str2, and zero if the strings match
 *          exactly.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int wcscasecmp(const wchar_t* str1, const wchar_t* str2)
{
  return SDL_wcscasecmp(str1, str2);
}

/**
 * Compare two wide strings, case-insensitively, up to a number of wchar_t.
 *
 * This will work with Unicode strings, using a technique called
 * "case-folding" to handle the vast majority of case-sensitive human
 * languages regardless of system locale. It can deal with expanding values: a
 * German Eszett character can compare against two ASCII 's' chars and be
 * considered a match, for example. A notable exception: it does not handle
 * the Turkish 'i' character; human language is complicated!
 *
 * Depending on your platform, "wchar_t" might be 2 bytes, and expected to be
 * UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this
 * handles Unicode, it expects the string to be well-formed and not a
 * null-terminated string of arbitrary bytes. Characters that are not valid
 * UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT
 * CHARACTER), which is to say two strings of random bits may turn out to
 * match if they convert to the same amount of replacement characters.
 *
 * Note that while this function might deal with variable-sized characters,
 * `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a
 * multi-byte UTF-16 sequence, it may convert a portion of the final character
 * to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not
 * to overflow a buffer.
 *
 * `maxlen` specifies a maximum number of wchar_t values to compare; if the
 * strings match to this number of wchar_t (or both have matched to a
 * null-terminator character before this number of bytes), they will be
 * considered equal.
 *
 * @param str1 the first string to compare. nullptr is not permitted!
 * @param str2 the second string to compare. nullptr is not permitted!
 * @param maxlen the maximum number of wchar_t values to compare.
 * @returns less than zero if str1 is "less than" str2, greater than zero if
 *          str1 is "greater than" str2, and zero if the strings match
 *          exactly.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int wcsncasecmp(const wchar_t* str1, const wchar_t* str2, size_t maxlen)
{
  return SDL_wcsncasecmp(str1, str2, maxlen);
}

/**
 * Parse a `long` from a wide string.
 *
 * If `str` starts with whitespace, then those whitespace characters are
 * skipped before attempting to parse the number.
 *
 * If the parsed number does not fit inside a `long`, the result is clamped to
 * the minimum and maximum representable `long` values.
 *
 * @param str The null-terminated wide string to read. Must not be nullptr.
 * @param endp If not nullptr, the address of the first invalid wide character
 *             (i.e. the next character after the parsed number) will be
 *             written to this pointer.
 * @param base The base of the integer to read. Supported values are 0 and 2
 *             to 36 inclusive. If 0, the base will be inferred from the
 *             number's prefix (0x for hexadecimal, 0 for octal, decimal
 *             otherwise).
 * @returns the parsed `long`, or 0 if no number could be parsed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa strtol
 */
inline long wcstol(const wchar_t* str, wchar_t** endp, int base)
{
  return SDL_wcstol(str, endp, base);
}

/**
 * This works exactly like strlen() but doesn't require access to a C runtime.
 *
 * Counts the bytes in `str`, excluding the null terminator.
 *
 * If you need the length of a UTF-8 string, consider using utf8strlen().
 *
 * @param str The null-terminated string to read. Must not be nullptr.
 * @returns the length (in bytes, excluding the null terminator) of `src`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa strnlen
 * @sa utf8strlen
 * @sa utf8strnlen
 */
inline size_t strlen(StringParam str) { return SDL_strlen(str); }

/**
 * This works exactly like strnlen() but doesn't require access to a C
 * runtime.
 *
 * Counts up to a maximum of `maxlen` bytes in `str`, excluding the null
 * terminator.
 *
 * If you need the length of a UTF-8 string, consider using utf8strnlen().
 *
 * @param str The null-terminated string to read. Must not be nullptr.
 * @param maxlen The maximum amount of bytes to count.
 * @returns the length (in bytes, excluding the null terminator) of `src` but
 *          never more than `maxlen`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa strlen
 * @sa utf8strlen
 * @sa utf8strnlen
 */
inline size_t strnlen(StringParam str, size_t maxlen)
{
  return SDL_strnlen(str, maxlen);
}

/**
 * Copy a string.
 *
 * This function copies up to `maxlen` - 1 characters from `src` to `dst`,
 * then appends a null terminator.
 *
 * If `maxlen` is 0, no characters are copied and no null terminator is
 * written.
 *
 * If you want to copy an UTF-8 string but need to ensure that multi-byte
 * sequences are not truncated, consider using utf8strlcpy().
 *
 * @param dst The destination buffer. Must not be nullptr, and must not overlap
 *            with `src`.
 * @param src The null-terminated string to copy. Must not be nullptr, and must
 *            not overlap with `dst`.
 * @param maxlen The length (in characters) of the destination buffer.
 * @returns the length (in characters, excluding the null terminator) of
 *          `src`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa strlcat
 * @sa utf8strlcpy
 */
inline size_t strlcpy(char* dst, StringParam src, size_t maxlen)
{
  return SDL_strlcpy(dst, src, maxlen);
}

/**
 * Copy an UTF-8 string.
 *
 * This function copies up to `dst_bytes` - 1 bytes from `src` to `dst` while
 * also ensuring that the string written to `dst` does not end in a truncated
 * multi-byte sequence. Finally, it appends a null terminator.
 *
 * `src` and `dst` must not overlap.
 *
 * Note that unlike strlcpy(), this function returns the number of bytes
 * written, not the length of `src`.
 *
 * @param dst The destination buffer. Must not be nullptr, and must not overlap
 *            with `src`.
 * @param src The null-terminated UTF-8 string to copy. Must not be nullptr, and
 *            must not overlap with `dst`.
 * @param dst_bytes The length (in bytes) of the destination buffer. Must not
 *                  be 0.
 * @returns the number of bytes written, excluding the null terminator.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa strlcpy
 */
inline size_t utf8strlcpy(char* dst, StringParam src, size_t dst_bytes)
{
  return SDL_utf8strlcpy(dst, src, dst_bytes);
}

/**
 * Concatenate strings.
 *
 * This function appends up to `maxlen` - strlen(dst) - 1 characters from
 * `src` to the end of the string in `dst`, then appends a null terminator.
 *
 * `src` and `dst` must not overlap.
 *
 * If `maxlen` - strlen(dst) - 1 is less than or equal to 0, then `dst` is
 * unmodified.
 *
 * @param dst The destination buffer already containing the first
 *            null-terminated string. Must not be nullptr and must not overlap
 *            with `src`.
 * @param src The second null-terminated string. Must not be nullptr, and must
 *            not overlap with `dst`.
 * @param maxlen The length (in characters) of the destination buffer.
 * @returns the length (in characters, excluding the null terminator) of the
 *          string in `dst` plus the length of `src`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa strlcpy
 */
inline size_t strlcat(char* dst, StringParam src, size_t maxlen)
{
  return SDL_strlcat(dst, src, maxlen);
}

/**
 * Allocate a copy of a string.
 *
 * This allocates enough space for a null-terminated copy of `str`, using
 * malloc, and then makes a copy of the string into this space.
 *
 * The returned string is owned by the caller, and should be passed to
 * free when no longer needed.
 *
 * @param str the string to copy.
 * @returns a pointer to the newly-allocated string.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline char* strdup(StringParam str) { return SDL_strdup(str); }

/**
 * Allocate a copy of a string, up to n characters.
 *
 * This allocates enough space for a null-terminated copy of `str`, up to
 * `maxlen` bytes, using malloc, and then makes a copy of the string into
 * this space.
 *
 * If the string is longer than `maxlen` bytes, the returned string will be
 * `maxlen` bytes long, plus a null-terminator character that isn't included
 * in the count.
 *
 * The returned string is owned by the caller, and should be passed to
 * free when no longer needed.
 *
 * @param str the string to copy.
 * @param maxlen the maximum length of the copied string, not counting the
 *               null-terminator character.
 * @returns a pointer to the newly-allocated string.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline char* strndup(StringParam str, size_t maxlen)
{
  return SDL_strndup(str, maxlen);
}

/**
 * Reverse a string's contents.
 *
 * This reverses a null-terminated string in-place. Only the content of the
 * string is reversed; the null-terminator character remains at the end of the
 * reversed string.
 *
 * **WARNING**: This function reverses the _bytes_ of the string, not the
 * codepoints. If `str` is a UTF-8 string with Unicode codepoints > 127, this
 * will ruin the string data. You should only use this function on strings
 * that are completely comprised of low ASCII characters.
 *
 * @param str the string to reverse.
 * @returns `str`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline char* strrev(char* str) { return SDL_strrev(str); }

/**
 * Convert a string to uppercase.
 *
 * **WARNING**: Regardless of system locale, this will only convert ASCII
 * values 'A' through 'Z' to uppercase.
 *
 * This function operates on a null-terminated string of bytes--even if it is
 * malformed UTF-8!--and converts ASCII characters 'a' through 'z' to their
 * uppercase equivalents in-place, returning the original `str` pointer.
 *
 * @param str the string to convert in-place. Can not be nullptr.
 * @returns the `str` pointer passed into this function.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa strlwr
 */
inline char* strupr(char* str) { return SDL_strupr(str); }

/**
 * Convert a string to lowercase.
 *
 * **WARNING**: Regardless of system locale, this will only convert ASCII
 * values 'A' through 'Z' to lowercase.
 *
 * This function operates on a null-terminated string of bytes--even if it is
 * malformed UTF-8!--and converts ASCII characters 'A' through 'Z' to their
 * lowercase equivalents in-place, returning the original `str` pointer.
 *
 * @param str the string to convert in-place. Can not be nullptr.
 * @returns the `str` pointer passed into this function.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa strupr
 */
inline char* strlwr(char* str) { return SDL_strlwr(str); }

/**
 * Search a string for the first instance of a specific byte.
 *
 * The search ends once it finds the requested byte value, or a null
 * terminator byte to end the string.
 *
 * Note that this looks for _bytes_, not _characters_, so you cannot match
 * against a Unicode codepoint > 255, regardless of character encoding.
 *
 * @param str the string to search. Must not be nullptr.
 * @param c the byte value to search for.
 * @returns a pointer to the first instance of `c` in the string, or nullptr if
 *          not found.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline char* strchr(StringParam str, int c) { return SDL_strchr(str, c); }

/**
 * Search a string for the last instance of a specific byte.
 *
 * The search must go until it finds a null terminator byte to end the string.
 *
 * Note that this looks for _bytes_, not _characters_, so you cannot match
 * against a Unicode codepoint > 255, regardless of character encoding.
 *
 * @param str the string to search. Must not be nullptr.
 * @param c the byte value to search for.
 * @returns a pointer to the last instance of `c` in the string, or nullptr if
 *          not found.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline char* strrchr(StringParam str, int c) { return SDL_strrchr(str, c); }

/**
 * Search a string for the first instance of a specific substring.
 *
 * The search ends once it finds the requested substring, or a null terminator
 * byte to end the string.
 *
 * Note that this looks for strings of _bytes_, not _characters_, so it's
 * legal to search for malformed and incomplete UTF-8 sequences.
 *
 * @param haystack the string to search. Must not be nullptr.
 * @param needle the string to search for. Must not be nullptr.
 * @returns a pointer to the first instance of `needle` in the string, or
 * nullptr if not found.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline char* strstr(StringParam haystack, StringParam needle)
{
  return SDL_strstr(haystack, needle);
}

/**
 * Search a string, up to n bytes, for the first instance of a specific
 * substring.
 *
 * The search ends once it finds the requested substring, or a null terminator
 * byte to end the string, or `maxlen` bytes have been examined. It is
 * possible to use this function on a string without a null terminator.
 *
 * Note that this looks for strings of _bytes_, not _characters_, so it's
 * legal to search for malformed and incomplete UTF-8 sequences.
 *
 * @param haystack the string to search. Must not be nullptr.
 * @param needle the string to search for. Must not be nullptr.
 * @param maxlen the maximum number of bytes to search in `haystack`.
 * @returns a pointer to the first instance of `needle` in the string, or
 * nullptr if not found.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline char* strnstr(StringParam haystack, StringParam needle, size_t maxlen)
{
  return SDL_strnstr(haystack, needle, maxlen);
}

/**
 * Search a UTF-8 string for the first instance of a specific substring,
 * case-insensitively.
 *
 * This will work with Unicode strings, using a technique called
 * "case-folding" to handle the vast majority of case-sensitive human
 * languages regardless of system locale. It can deal with expanding values: a
 * German Eszett character can compare against two ASCII 's' chars and be
 * considered a match, for example. A notable exception: it does not handle
 * the Turkish 'i' character; human language is complicated!
 *
 * Since this handles Unicode, it expects the strings to be well-formed UTF-8
 * and not a null-terminated string of arbitrary bytes. Bytes that are not
 * valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT
 * CHARACTER), which is to say two strings of random bits may turn out to
 * match if they convert to the same amount of replacement characters.
 *
 * @param haystack the string to search. Must not be nullptr.
 * @param needle the string to search for. Must not be nullptr.
 * @returns a pointer to the first instance of `needle` in the string, or
 * nullptr if not found.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline char* strcasestr(StringParam haystack, StringParam needle)
{
  return SDL_strcasestr(haystack, needle);
}

/**
 * This works exactly like strtok_r() but doesn't require access to a C
 * runtime.
 *
 * Break a string up into a series of tokens.
 *
 * To start tokenizing a new string, `str` should be the non-nullptr address of
 * the string to start tokenizing. Future calls to get the next token from the
 * same string should specify a nullptr.
 *
 * Note that this function will overwrite pieces of `str` with null chars to
 * split it into tokens. This function cannot be used with const/read-only
 * strings!
 *
 * `saveptr` just needs to point to a `char *` that can be overwritten; SDL
 * will use this to save tokenizing state between calls. It is initialized if
 * `str` is non-nullptr, and used to resume tokenizing when `str` is nullptr.
 *
 * @param str the string to tokenize, or nullptr to continue tokenizing.
 * @param delim the delimiter string that separates tokens.
 * @param saveptr pointer to a char *, used for ongoing state.
 * @returns A pointer to the next token, or nullptr if no tokens remain.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline char* strtok_r(char* str, StringParam delim, char** saveptr)
{
  return SDL_strtok_r(str, delim, saveptr);
}

/**
 * Count the number of codepoints in a UTF-8 string.
 *
 * Counts the _codepoints_, not _bytes_, in `str`, excluding the null
 * terminator.
 *
 * If you need to count the bytes in a string instead, consider using
 * strlen().
 *
 * Since this handles Unicode, it expects the strings to be well-formed UTF-8
 * and not a null-terminated string of arbitrary bytes. Bytes that are not
 * valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT
 * CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the
 * count by several replacement characters.
 *
 * @param str The null-terminated UTF-8 string to read. Must not be nullptr.
 * @returns The length (in codepoints, excluding the null terminator) of
 *          `src`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa utf8strnlen
 * @sa strlen
 */
inline size_t utf8strlen(StringParam str) { return SDL_utf8strlen(str); }

/**
 * Count the number of codepoints in a UTF-8 string, up to n bytes.
 *
 * Counts the _codepoints_, not _bytes_, in `str`, excluding the null
 * terminator.
 *
 * If you need to count the bytes in a string instead, consider using
 * strnlen().
 *
 * The counting stops at `bytes` bytes (not codepoints!). This seems
 * counterintuitive, but makes it easy to express the total size of the
 * string's buffer.
 *
 * Since this handles Unicode, it expects the strings to be well-formed UTF-8
 * and not a null-terminated string of arbitrary bytes. Bytes that are not
 * valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT
 * CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the
 * count by several replacement characters.
 *
 * @param str The null-terminated UTF-8 string to read. Must not be nullptr.
 * @param bytes The maximum amount of bytes to count.
 * @returns The length (in codepoints, excluding the null terminator) of `src`
 *          but never more than `maxlen`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa utf8strlen
 * @sa strnlen
 */
inline size_t utf8strnlen(StringParam str, size_t bytes)
{
  return SDL_utf8strnlen(str, bytes);
}

/**
 * Convert an integer into a string.
 *
 * This requires a radix to specified for string format. Specifying 10
 * produces a decimal number, 16 hexadecimal, etc. Must be in the range of 2
 * to 36.
 *
 * Note that this function will overflow a buffer if `str` is not large enough
 * to hold the output! It may be safer to use snprintf to clamp output, or
 * asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate
 * much more space than you expect to use (and don't forget possible negative
 * signs, null terminator bytes, etc).
 *
 * @param value the integer to convert.
 * @param str the buffer to write the string into.
 * @param radix the radix to use for string generation.
 * @returns `str`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa uitoa
 * @sa ltoa
 * @sa SDL_lltoa
 */
inline char* itoa(int value, char* str, int radix)
{
  return SDL_itoa(value, str, radix);
}

/**
 * Convert an unsigned integer into a string.
 *
 * This requires a radix to specified for string format. Specifying 10
 * produces a decimal number, 16 hexadecimal, etc. Must be in the range of 2
 * to 36.
 *
 * Note that this function will overflow a buffer if `str` is not large enough
 * to hold the output! It may be safer to use snprintf to clamp output, or
 * asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate
 * much more space than you expect to use (and don't forget null terminator
 * bytes, etc).
 *
 * @param value the unsigned integer to convert.
 * @param str the buffer to write the string into.
 * @param radix the radix to use for string generation.
 * @returns `str`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa itoa
 * @sa ultoa
 * @sa SDL_ulltoa
 */
inline char* uitoa(unsigned int value, char* str, int radix)
{
  return SDL_uitoa(value, str, radix);
}

/**
 * Convert a long integer into a string.
 *
 * This requires a radix to specified for string format. Specifying 10
 * produces a decimal number, 16 hexadecimal, etc. Must be in the range of 2
 * to 36.
 *
 * Note that this function will overflow a buffer if `str` is not large enough
 * to hold the output! It may be safer to use snprintf to clamp output, or
 * asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate
 * much more space than you expect to use (and don't forget possible negative
 * signs, null terminator bytes, etc).
 *
 * @param value the long integer to convert.
 * @param str the buffer to write the string into.
 * @param radix the radix to use for string generation.
 * @returns `str`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa ultoa
 * @sa itoa
 * @sa SDL_lltoa
 */
inline char* ltoa(long value, char* str, int radix)
{
  return SDL_ltoa(value, str, radix);
}

/**
 * Convert an unsigned long integer into a string.
 *
 * This requires a radix to specified for string format. Specifying 10
 * produces a decimal number, 16 hexadecimal, etc. Must be in the range of 2
 * to 36.
 *
 * Note that this function will overflow a buffer if `str` is not large enough
 * to hold the output! It may be safer to use snprintf to clamp output, or
 * asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate
 * much more space than you expect to use (and don't forget null terminator
 * bytes, etc).
 *
 * @param value the unsigned long integer to convert.
 * @param str the buffer to write the string into.
 * @param radix the radix to use for string generation.
 * @returns `str`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa ltoa
 * @sa uitoa
 * @sa SDL_ulltoa
 */
inline char* ultoa(unsigned long value, char* str, int radix)
{
  return SDL_ultoa(value, str, radix);
}

/**
 * Parse an `int` from a string.
 *
 * The result of calling `atoi(str)` is equivalent to
 * `(int)strtol(str, nullptr, 10)`.
 *
 * @param str The null-terminated string to read. Must not be nullptr.
 * @returns the parsed `int`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa atof
 * @sa strtol
 * @sa strtoul
 * @sa SDL_strtoll
 * @sa SDL_strtoull
 * @sa strtod
 * @sa itoa
 */
inline int atoi(StringParam str) { return SDL_atoi(str); }

/**
 * Parse a `double` from a string.
 *
 * The result of calling `atof(str)` is equivalent to `strtod(str,
 * nullptr)`.
 *
 * @param str The null-terminated string to read. Must not be nullptr.
 * @returns the parsed `double`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa atoi
 * @sa strtol
 * @sa strtoul
 * @sa SDL_strtoll
 * @sa SDL_strtoull
 * @sa strtod
 */
inline double atof(StringParam str) { return SDL_atof(str); }

/**
 * Parse a `long` from a string.
 *
 * If `str` starts with whitespace, then those whitespace characters are
 * skipped before attempting to parse the number.
 *
 * If the parsed number does not fit inside a `long`, the result is clamped to
 * the minimum and maximum representable `long` values.
 *
 * @param str The null-terminated string to read. Must not be nullptr.
 * @param endp If not nullptr, the address of the first invalid character (i.e.
 *             the next character after the parsed number) will be written to
 *             this pointer.
 * @param base The base of the integer to read. Supported values are 0 and 2
 *             to 36 inclusive. If 0, the base will be inferred from the
 *             number's prefix (0x for hexadecimal, 0 for octal, decimal
 *             otherwise).
 * @returns the parsed `long`, or 0 if no number could be parsed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa atoi
 * @sa atof
 * @sa strtoul
 * @sa SDL_strtoll
 * @sa SDL_strtoull
 * @sa strtod
 * @sa ltoa
 * @sa wcstol
 */
inline long strtol(StringParam str, char** endp, int base)
{
  return SDL_strtol(str, endp, base);
}

/**
 * Parse an `unsigned long` from a string.
 *
 * If `str` starts with whitespace, then those whitespace characters are
 * skipped before attempting to parse the number.
 *
 * If the parsed number does not fit inside an `unsigned long`, the result is
 * clamped to the maximum representable `unsigned long` value.
 *
 * @param str The null-terminated string to read. Must not be nullptr.
 * @param endp If not nullptr, the address of the first invalid character (i.e.
 *             the next character after the parsed number) will be written to
 *             this pointer.
 * @param base The base of the integer to read. Supported values are 0 and 2
 *             to 36 inclusive. If 0, the base will be inferred from the
 *             number's prefix (0x for hexadecimal, 0 for octal, decimal
 *             otherwise).
 * @returns the parsed `unsigned long`, or 0 if no number could be parsed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa atoi
 * @sa atof
 * @sa strtol
 * @sa SDL_strtoll
 * @sa SDL_strtoull
 * @sa strtod
 * @sa ultoa
 */
inline unsigned long strtoul(StringParam str, char** endp, int base)
{
  return SDL_strtoul(str, endp, base);
}

/**
 * Parse a `double` from a string.
 *
 * This function makes fewer guarantees than the C runtime `strtod`:
 *
 * - Only decimal notation is guaranteed to be supported. The handling of
 *   scientific and hexadecimal notation is unspecified.
 * - Whether or not INF and NAN can be parsed is unspecified.
 * - The precision of the result is unspecified.
 *
 * @param str the null-terminated string to read. Must not be nullptr.
 * @param endp if not nullptr, the address of the first invalid character (i.e.
 *             the next character after the parsed number) will be written to
 *             this pointer.
 * @returns the parsed `double`, or 0 if no number could be parsed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa atoi
 * @sa atof
 * @sa strtol
 * @sa SDL_strtoll
 * @sa strtoul
 * @sa SDL_strtoull
 */
inline double strtod(StringParam str, char** endp)
{
  return SDL_strtod(str, endp);
}

/**
 * Compare two null-terminated UTF-8 strings.
 *
 * Due to the nature of UTF-8 encoding, this will work with Unicode strings,
 * since effectively this function just compares bytes until it hits a
 * null-terminating character. Also due to the nature of UTF-8, this can be
 * used with qsort() to put strings in (roughly) alphabetical order.
 *
 * @param str1 the first string to compare. nullptr is not permitted!
 * @param str2 the second string to compare. nullptr is not permitted!
 * @returns less than zero if str1 is "less than" str2, greater than zero if
 *          str1 is "greater than" str2, and zero if the strings match
 *          exactly.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int strcmp(StringParam str1, StringParam str2)
{
  return SDL_strcmp(str1, str2);
}

/**
 * Compare two UTF-8 strings up to a number of bytes.
 *
 * Due to the nature of UTF-8 encoding, this will work with Unicode strings,
 * since effectively this function just compares bytes until it hits a
 * null-terminating character. Also due to the nature of UTF-8, this can be
 * used with qsort() to put strings in (roughly) alphabetical order.
 *
 * Note that while this function is intended to be used with UTF-8, it is
 * doing a bytewise comparison, and `maxlen` specifies a _byte_ limit! If the
 * limit lands in the middle of a multi-byte UTF-8 sequence, it will only
 * compare a portion of the final character.
 *
 * `maxlen` specifies a maximum number of bytes to compare; if the strings
 * match to this number of bytes (or both have matched to a null-terminator
 * character before this number of bytes), they will be considered equal.
 *
 * @param str1 the first string to compare. nullptr is not permitted!
 * @param str2 the second string to compare. nullptr is not permitted!
 * @param maxlen the maximum number of _bytes_ to compare.
 * @returns less than zero if str1 is "less than" str2, greater than zero if
 *          str1 is "greater than" str2, and zero if the strings match
 *          exactly.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int strncmp(StringParam str1, StringParam str2, size_t maxlen)
{
  return SDL_strncmp(str1, str2, maxlen);
}

/**
 * Compare two null-terminated UTF-8 strings, case-insensitively.
 *
 * This will work with Unicode strings, using a technique called
 * "case-folding" to handle the vast majority of case-sensitive human
 * languages regardless of system locale. It can deal with expanding values: a
 * German Eszett character can compare against two ASCII 's' chars and be
 * considered a match, for example. A notable exception: it does not handle
 * the Turkish 'i' character; human language is complicated!
 *
 * Since this handles Unicode, it expects the string to be well-formed UTF-8
 * and not a null-terminated string of arbitrary bytes. Bytes that are not
 * valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT
 * CHARACTER), which is to say two strings of random bits may turn out to
 * match if they convert to the same amount of replacement characters.
 *
 * @param str1 the first string to compare. nullptr is not permitted!
 * @param str2 the second string to compare. nullptr is not permitted!
 * @returns less than zero if str1 is "less than" str2, greater than zero if
 *          str1 is "greater than" str2, and zero if the strings match
 *          exactly.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int strcasecmp(StringParam str1, StringParam str2)
{
  return SDL_strcasecmp(str1, str2);
}

/**
 * Compare two UTF-8 strings, case-insensitively, up to a number of bytes.
 *
 * This will work with Unicode strings, using a technique called
 * "case-folding" to handle the vast majority of case-sensitive human
 * languages regardless of system locale. It can deal with expanding values: a
 * German Eszett character can compare against two ASCII 's' chars and be
 * considered a match, for example. A notable exception: it does not handle
 * the Turkish 'i' character; human language is complicated!
 *
 * Since this handles Unicode, it expects the string to be well-formed UTF-8
 * and not a null-terminated string of arbitrary bytes. Bytes that are not
 * valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT
 * CHARACTER), which is to say two strings of random bits may turn out to
 * match if they convert to the same amount of replacement characters.
 *
 * Note that while this function is intended to be used with UTF-8, `maxlen`
 * specifies a _byte_ limit! If the limit lands in the middle of a multi-byte
 * UTF-8 sequence, it may convert a portion of the final character to one or
 * more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not to overflow
 * a buffer.
 *
 * `maxlen` specifies a maximum number of bytes to compare; if the strings
 * match to this number of bytes (or both have matched to a null-terminator
 * character before this number of bytes), they will be considered equal.
 *
 * @param str1 the first string to compare. nullptr is not permitted!
 * @param str2 the second string to compare. nullptr is not permitted!
 * @param maxlen the maximum number of bytes to compare.
 * @returns less than zero if str1 is "less than" str2, greater than zero if
 *          str1 is "greater than" str2, and zero if the strings match
 *          exactly.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int strncasecmp(StringParam str1, StringParam str2, size_t maxlen)
{
  return SDL_strncasecmp(str1, str2, maxlen);
}

/**
 * Searches a string for the first occurrence of any character contained in a
 * breakset, and returns a pointer from the string to that character.
 *
 * @param str The null-terminated string to be searched. Must not be nullptr,
 * and must not overlap with `breakset`.
 * @param breakset A null-terminated string containing the list of characters
 *                 to look for. Must not be nullptr, and must not overlap with
 *                 `str`.
 * @returns A pointer to the location, in str, of the first occurrence of a
 *          character present in the breakset, or nullptr if none is found.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline char* strpbrk(StringParam str, StringParam breakset)
{
  return SDL_strpbrk(str, breakset);
}

/**
 * The Unicode REPLACEMENT CHARACTER codepoint.
 *
 * StepUTF8() and StepBackUTF8() report this codepoint when they
 * encounter a UTF-8 string with encoding errors.
 *
 * This tends to render as something like a question mark in most places.
 *
 * @since This macro is available since SDL 3.2.0.
 *
 * @sa StepBackUTF8
 * @sa StepUTF8
 */
constexpr Uint32 INVALID_UNICODE_CODEPOINT = SDL_INVALID_UNICODE_CODEPOINT;

/**
 * Decode a UTF-8 string, one Unicode codepoint at a time.
 *
 * This will return the first Unicode codepoint in the UTF-8 encoded string in
 * `*pstr`, and then advance `*pstr` past any consumed bytes before returning.
 *
 * It will not access more than `*pslen` bytes from the string. `*pslen` will
 * be adjusted, as well, subtracting the number of bytes consumed.
 *
 * `pslen` is allowed to be nullptr, in which case the string _must_ be
 * nullptr-terminated, as the function will blindly read until it sees the
 * nullptr char.
 *
 * if `*pslen` is zero, it assumes the end of string is reached and returns a
 * zero codepoint regardless of the contents of the string buffer.
 *
 * If the resulting codepoint is zero (a nullptr terminator), or `*pslen` is
 * zero, it will not advance `*pstr` or `*pslen` at all.
 *
 * Generally this function is called in a loop until it returns zero,
 * adjusting its parameters each iteration.
 *
 * If an invalid UTF-8 sequence is encountered, this function returns
 * INVALID_UNICODE_CODEPOINT and advances the string/length by one byte
 * (which is to say, a multibyte sequence might produce several
 * INVALID_UNICODE_CODEPOINT returns before it syncs to the next valid
 * UTF-8 sequence).
 *
 * Several things can generate invalid UTF-8 sequences, including overlong
 * encodings, the use of UTF-16 surrogate values, and truncated data. Please
 * refer to
 * [RFC3629](https://www.ietf.org/rfc/rfc3629.txt)
 * for details.
 *
 * @param pstr a pointer to a UTF-8 string pointer to be read and adjusted.
 * @param pslen a pointer to the number of bytes in the string, to be read and
 *              adjusted. nullptr is allowed.
 * @returns the first Unicode codepoint in the string.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Uint32 StepUTF8(const char** pstr, size_t* pslen)
{
  return SDL_StepUTF8(pstr, pslen);
}

/**
 * Decode a UTF-8 string in reverse, one Unicode codepoint at a time.
 *
 * This will go to the start of the previous Unicode codepoint in the string,
 * move `*pstr` to that location and return that codepoint.
 *
 * If `*pstr` is already at the start of the string), it will not advance
 * `*pstr` at all.
 *
 * Generally this function is called in a loop until it returns zero,
 * adjusting its parameter each iteration.
 *
 * If an invalid UTF-8 sequence is encountered, this function returns
 * INVALID_UNICODE_CODEPOINT.
 *
 * Several things can generate invalid UTF-8 sequences, including overlong
 * encodings, the use of UTF-16 surrogate values, and truncated data. Please
 * refer to
 * [RFC3629](https://www.ietf.org/rfc/rfc3629.txt)
 * for details.
 *
 * @param start a pointer to the beginning of the UTF-8 string.
 * @param pstr a pointer to a UTF-8 string pointer to be read and adjusted.
 * @returns the previous Unicode codepoint in the string.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Uint32 StepBackUTF8(StringParam start, const char** pstr)
{
  return SDL_StepBackUTF8(start, pstr);
}

/**
 * Convert a single Unicode codepoint to UTF-8.
 *
 * The buffer pointed to by `dst` must be at least 4 bytes long, as this
 * function may generate between 1 and 4 bytes of output.
 *
 * This function returns the first byte _after_ the newly-written UTF-8
 * sequence, which is useful for encoding multiple codepoints in a loop, or
 * knowing where to write a nullptr-terminator character to end the string (in
 * either case, plan to have a buffer of _more_ than 4 bytes!).
 *
 * If `codepoint` is an invalid value (outside the Unicode range, or a UTF-16
 * surrogate value, etc), this will use U+FFFD (REPLACEMENT CHARACTER) for the
 * codepoint instead, and not set an error.
 *
 * If `dst` is nullptr, this returns nullptr immediately without writing to the
 * pointer and without setting an error.
 *
 * @param codepoint a Unicode codepoint to convert to UTF-8.
 * @param dst the location to write the encoded UTF-8. Must point to at least
 *            4 bytes!
 * @returns the first byte past the newly-written UTF-8 sequence.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline char* UCS4ToUTF8(Uint32 codepoint, char* dst)
{
  return SDL_UCS4ToUTF8(codepoint, dst);
}

/**
 * This works exactly like sscanf() but doesn't require access to a C runtime.
 *
 * Scan a string, matching a format string, converting each '%' item and
 * storing it to pointers provided through variable arguments.
 *
 * @param text the string to scan. Must not be nullptr.
 * @param fmt a printf-style format string. Must not be nullptr.
 * @param ... a list of pointers to values to be filled in with scanned items.
 * @returns the number of items that matched the format string.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int sscanf(StringParam text,
                  SDL_SCANF_FORMAT_STRING const char* fmt,
                  ...)
{
  int rc;
  va_list ap;
  va_start(ap, fmt);
  rc = SDL_vsscanf(text, fmt, ap);
  va_end(ap);
  return rc;
}

/**
 * This works exactly like vsscanf() but doesn't require access to a C
 * runtime.
 *
 * Functions identically to sscanf(), except it takes a `va_list` instead
 * of using `...` variable arguments.
 *
 * @param text the string to scan. Must not be nullptr.
 * @param fmt a printf-style format string. Must not be nullptr.
 * @param ap a `va_list` of pointers to values to be filled in with scanned
 *           items.
 * @returns the number of items that matched the format string.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int vsscanf(StringParam text,
                   SDL_SCANF_FORMAT_STRING const char* fmt,
                   va_list ap)
{
  return SDL_vsscanf(text, fmt, ap);
}

/**
 * This works exactly like snprintf() but doesn't require access to a C
 * runtime.
 *
 * Format a string of up to `maxlen`-1 bytes, converting each '%' item with
 * values provided through variable arguments.
 *
 * While some C runtimes differ on how to deal with too-large strings, this
 * function null-terminates the output, by treating the null-terminator as
 * part of the `maxlen` count. Note that if `maxlen` is zero, however, no
 * bytes will be written at all.
 *
 * This function returns the number of _bytes_ (not _characters_) that should
 * be written, excluding the null-terminator character. If this returns a
 * number >= `maxlen`, it means the output string was truncated. A negative
 * return value means an error occurred.
 *
 * Referencing the output string's pointer with a format item is undefined
 * behavior.
 *
 * @param text the buffer to write the string into. Must not be nullptr.
 * @param maxlen the maximum bytes to write, including the null-terminator.
 * @param fmt a printf-style format string. Must not be nullptr.
 * @param ... a list of values to be used with the format string.
 * @returns the number of bytes that should be written, not counting the
 *          null-terminator char, or a negative value on error.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int snprintf(char* text,
                    size_t maxlen,
                    SDL_PRINTF_FORMAT_STRING const char* fmt,
                    ...)
{
  va_list ap;
  int result;

  va_start(ap, fmt);
  result = SDL_vsnprintf(text, maxlen, fmt, ap);
  va_end(ap);

  return result;
}

/**
 * This works exactly like swprintf() but doesn't require access to a C
 * runtime.
 *
 * Format a wide string of up to `maxlen`-1 wchar_t values, converting each
 * '%' item with values provided through variable arguments.
 *
 * While some C runtimes differ on how to deal with too-large strings, this
 * function null-terminates the output, by treating the null-terminator as
 * part of the `maxlen` count. Note that if `maxlen` is zero, however, no wide
 * characters will be written at all.
 *
 * This function returns the number of _wide characters_ (not _codepoints_)
 * that should be written, excluding the null-terminator character. If this
 * returns a number >= `maxlen`, it means the output string was truncated. A
 * negative return value means an error occurred.
 *
 * Referencing the output string's pointer with a format item is undefined
 * behavior.
 *
 * @param text the buffer to write the wide string into. Must not be nullptr.
 * @param maxlen the maximum wchar_t values to write, including the
 *               null-terminator.
 * @param fmt a printf-style format string. Must not be nullptr.
 * @param ... a list of values to be used with the format string.
 * @returns the number of wide characters that should be written, not counting
 *          the null-terminator char, or a negative value on error.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int swprintf(wchar_t* text,
                    size_t maxlen,
                    SDL_PRINTF_FORMAT_STRING const wchar_t* fmt,
                    ...)
{
  va_list ap;
  int result;

  va_start(ap, fmt);
  result = SDL_vswprintf(text, maxlen, fmt, ap);
  va_end(ap);

  return result;
}

/**
 * This works exactly like vsnprintf() but doesn't require access to a C
 * runtime.
 *
 * Functions identically to snprintf(), except it takes a `va_list`
 * instead of using `...` variable arguments.
 *
 * @param text the buffer to write the string into. Must not be nullptr.
 * @param maxlen the maximum bytes to write, including the null-terminator.
 * @param fmt a printf-style format string. Must not be nullptr.
 * @param ap a `va_list` values to be used with the format string.
 * @returns the number of bytes that should be written, not counting the
 *          null-terminator char, or a negative value on error.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int vsnprintf(char* text,
                     size_t maxlen,
                     SDL_PRINTF_FORMAT_STRING const char* fmt,
                     va_list ap)
{
  return SDL_vsnprintf(text, maxlen, fmt, ap);
}

/**
 * This works exactly like vswprintf() but doesn't require access to a C
 * runtime.
 *
 * Functions identically to swprintf(), except it takes a `va_list`
 * instead of using `...` variable arguments.
 *
 * @param text the buffer to write the string into. Must not be nullptr.
 * @param maxlen the maximum wide characters to write, including the
 *               null-terminator.
 * @param fmt a printf-style format wide string. Must not be nullptr.
 * @param ap a `va_list` values to be used with the format string.
 * @returns the number of wide characters that should be written, not counting
 *          the null-terminator char, or a negative value on error.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int vswprintf(wchar_t* text,
                     size_t maxlen,
                     SDL_PRINTF_FORMAT_STRING const wchar_t* fmt,
                     va_list ap)
{
  return SDL_vswprintf(text, maxlen, fmt, ap);
}

/**
 * This works exactly like asprintf() but doesn't require access to a C
 * runtime.
 *
 * Functions identically to snprintf(), except it allocates a buffer large
 * enough to hold the output string on behalf of the caller.
 *
 * On success, this function returns the number of bytes (not characters)
 * comprising the output string, not counting the null-terminator character,
 * and sets `*strp` to the newly-allocated string.
 *
 * On error, this function returns a negative number, and the value of `*strp`
 * is undefined.
 *
 * The returned string is owned by the caller, and should be passed to
 * free when no longer needed.
 *
 * @param strp on output, is set to the new string. Must not be nullptr.
 * @param fmt a printf-style format string. Must not be nullptr.
 * @param ... a list of values to be used with the format string.
 * @returns the number of bytes in the newly-allocated string, not counting
 *          the null-terminator char, or a negative value on error.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int asprintf(char** strp, SDL_PRINTF_FORMAT_STRING const char* fmt, ...)
{
  va_list ap;
  int result;

  va_start(ap, fmt);
  result = SDL_vasprintf(strp, fmt, ap);
  va_end(ap);

  return result;
}

/**
 * This works exactly like vasprintf() but doesn't require access to a C
 * runtime.
 *
 * Functions identically to asprintf(), except it takes a `va_list`
 * instead of using `...` variable arguments.
 *
 * @param strp on output, is set to the new string. Must not be nullptr.
 * @param fmt a printf-style format string. Must not be nullptr.
 * @param ap a `va_list` values to be used with the format string.
 * @returns the number of bytes in the newly-allocated string, not counting
 *          the null-terminator char, or a negative value on error.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int vasprintf(char** strp,
                     SDL_PRINTF_FORMAT_STRING const char* fmt,
                     va_list ap)
{
  return SDL_vasprintf(strp, fmt, ap);
}

/**
 * Seeds the pseudo-random number generator.
 *
 * Reusing the seed number will cause rand() to repeat the same stream of
 * 'random' numbers.
 *
 * @param seed the value to use as a random number seed, or 0 to use
 *             GetPerformanceCounter().
 *
 * @threadsafety This should be called on the same thread that calls
 *               rand()
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa rand
 * @sa rand_bits
 * @sa randf
 */
inline void srand(Uint64 seed) { SDL_srand(seed); }

/**
 * Generate a pseudo-random number less than n for positive n
 *
 * The method used is faster and of better quality than `rand() % n`. Odds are
 * roughly 99.9% even for n = 1 million. Evenness is better for smaller n, and
 * much worse as n gets bigger.
 *
 * Example: to simulate a d6 use `rand(6) + 1` The +1 converts 0..5 to
 * 1..6
 *
 * If you want to generate a pseudo-random number in the full range of Sint32,
 * you should use: (Sint32)rand_bits()
 *
 * If you want reproducible output, be sure to initialize with srand()
 * first.
 *
 * There are no guarantees as to the quality of the random sequence produced,
 * and this should not be used for security (cryptography, passwords) or where
 * money is on the line (loot-boxes, casinos). There are many random number
 * libraries available with different characteristics and you should pick one
 * of those to meet any serious needs.
 *
 * @param n the number of possible outcomes. n must be positive.
 * @returns a random value in the range of [0 .. n-1].
 *
 * @threadsafety All calls should be made from a single thread
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa srand
 * @sa randf
 */
inline Sint32 rand(Sint32 n) { return SDL_rand(n); }

/**
 * Generate a uniform pseudo-random floating point number less than 1.0
 *
 * If you want reproducible output, be sure to initialize with srand()
 * first.
 *
 * There are no guarantees as to the quality of the random sequence produced,
 * and this should not be used for security (cryptography, passwords) or where
 * money is on the line (loot-boxes, casinos). There are many random number
 * libraries available with different characteristics and you should pick one
 * of those to meet any serious needs.
 *
 * @returns a random value in the range of [0.0, 1.0).
 *
 * @threadsafety All calls should be made from a single thread
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa srand
 * @sa rand
 */
inline float randf() { return SDL_randf(); }

/**
 * Generate 32 pseudo-random bits.
 *
 * You likely want to use rand() to get a pseudo-random number instead.
 *
 * There are no guarantees as to the quality of the random sequence produced,
 * and this should not be used for security (cryptography, passwords) or where
 * money is on the line (loot-boxes, casinos). There are many random number
 * libraries available with different characteristics and you should pick one
 * of those to meet any serious needs.
 *
 * @returns a random value in the range of [0-MAX_UINT32].
 *
 * @threadsafety All calls should be made from a single thread
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa rand
 * @sa randf
 * @sa srand
 */
inline Uint32 rand_bits() { return SDL_rand_bits(); }

/**
 * A independent pseudo random state
 *
 * This can be instantiated in any thread and as long as it is not shared with
 * another thread all members are safe to call.
 *
 * @cat wrap-state
 *
 * @sa wrap-state
 */
class Random
{
  Uint64 m_state;

public:
  constexpr Random()
    : m_state(0)
  {
  }

  /**
   * Init state with the given value
   */
  constexpr explicit Random(Uint64 state)
    : m_state(state)
  {
  }

  /// Convert to the underlying type
  constexpr operator Uint64() { return m_state; }

  /**
   * Generate a pseudo-random number less than n for positive n
   *
   * The method used is faster and of better quality than `rand() % n`. Odds are
   * roughly 99.9% even for n = 1 million. Evenness is better for smaller n, and
   * much worse as n gets bigger.
   *
   * Example: to simulate a d6 use `state.rand(6) + 1` The +1 converts
   * 0..5 to 1..6
   *
   * If you want to generate a pseudo-random number in the full range of Sint32,
   * you should use: (Sint32)state.rand_bits()
   *
   * There are no guarantees as to the quality of the random sequence produced,
   * and this should not be used for security (cryptography, passwords) or where
   * money is on the line (loot-boxes, casinos). There are many random number
   * libraries available with different characteristics and you should pick one
   * of those to meet any serious needs.
   *
   * @param n the number of possible outcomes. n must be positive.
   * @returns a random value in the range of [0 .. n-1].
   *
   * @threadsafety This function is thread-safe, as long as this object
   *               isn't shared between threads.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa rand
   * @sa Random.rand_bits
   * @sa Random.randf
   */
  Sint32 rand(Sint32 n) { return SDL_rand_r(&m_state, n); }

  /**
   * Generate a uniform pseudo-random floating point number less than 1.0
   *
   * If you want reproducible output, be sure to initialize with srand()
   * first.
   *
   * There are no guarantees as to the quality of the random sequence produced,
   * and this should not be used for security (cryptography, passwords) or where
   * money is on the line (loot-boxes, casinos). There are many random number
   * libraries available with different characteristics and you should pick one
   * of those to meet any serious needs.
   *
   * @returns a random value in the range of [0.0, 1.0).
   *
   * @threadsafety This function is thread-safe, as long as this object
   *               isn't shared between threads.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Random.rand_bits
   * @sa Random.rand
   * @sa randf
   */
  float randf() { return SDL_randf_r(&m_state); }

  /**
   * Generate 32 pseudo-random bits.
   *
   * You likely want to use Random.rand() to get a pseudo-random number instead.
   *
   * There are no guarantees as to the quality of the random sequence produced,
   * and this should not be used for security (cryptography, passwords) or where
   * money is on the line (loot-boxes, casinos). There are many random number
   * libraries available with different characteristics and you should pick one
   * of those to meet any serious needs.
   *
   * @returns a random value in the range of [0-MAX_UINT32].
   *
   * @threadsafety This function is thread-safe, as long as this object
   *               isn't shared between threads.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Random.rand
   * @sa Random.randf
   */
  Uint32 rand_bits() { return SDL_rand_bits_r(&m_state); }
};

/**
 * Generate a pseudo-random number less than n for positive n
 *
 * The method used is faster and of better quality than `rand() % n`. Odds are
 * roughly 99.9% even for n = 1 million. Evenness is better for smaller n, and
 * much worse as n gets bigger.
 *
 * Example: to simulate a d6 use `Random.rand(state, 6) + 1` The +1 converts
 * 0..5 to 1..6
 *
 * If you want to generate a pseudo-random number in the full range of Sint32,
 * you should use: (Sint32)Random.rand_bits(state)
 *
 * There are no guarantees as to the quality of the random sequence produced,
 * and this should not be used for security (cryptography, passwords) or where
 * money is on the line (loot-boxes, casinos). There are many random number
 * libraries available with different characteristics and you should pick one
 * of those to meet any serious needs.
 *
 * @param state a pointer to the current random number state, this may not be
 *              nullptr.
 * @param n the number of possible outcomes. n must be positive.
 * @returns a random value in the range of [0 .. n-1].
 *
 * @threadsafety This function is thread-safe, as long as the state pointer
 *               isn't shared between threads.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa rand
 * @sa Random.rand_bits
 * @sa Random.randf
 */
inline Sint32 rand_r(Uint64* state, Sint32 n) { return SDL_rand_r(state, n); }

/**
 * Generate a uniform pseudo-random floating point number less than 1.0
 *
 * If you want reproducible output, be sure to initialize with srand()
 * first.
 *
 * There are no guarantees as to the quality of the random sequence produced,
 * and this should not be used for security (cryptography, passwords) or where
 * money is on the line (loot-boxes, casinos). There are many random number
 * libraries available with different characteristics and you should pick one
 * of those to meet any serious needs.
 *
 * @param state a pointer to the current random number state, this may not be
 *              nullptr.
 * @returns a random value in the range of [0.0, 1.0).
 *
 * @threadsafety This function is thread-safe, as long as the state pointer
 *               isn't shared between threads.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Random.rand_bits
 * @sa Random.rand
 * @sa randf
 */
inline float randf_r(Uint64* state) { return SDL_randf_r(state); }

/**
 * Generate 32 pseudo-random bits.
 *
 * You likely want to use Random.rand() to get a psuedo-random number instead.
 *
 * There are no guarantees as to the quality of the random sequence produced,
 * and this should not be used for security (cryptography, passwords) or where
 * money is on the line (loot-boxes, casinos). There are many random number
 * libraries available with different characteristics and you should pick one
 * of those to meet any serious needs.
 *
 * @param state a pointer to the current random number state, this may not be
 *              nullptr.
 * @returns a random value in the range of [0-MAX_UINT32].
 *
 * @threadsafety This function is thread-safe, as long as the state pointer
 *               isn't shared between threads.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Random.rand
 * @sa Random.randf
 */
inline Uint32 rand_bits_r(Uint64* state) { return SDL_rand_bits_r(state); }

/**
 * The value of Pi, as a double-precision floating point literal.
 *
 * @since This macro is available since SDL 3.2.0.
 *
 * @sa PI_F
 */
constexpr double PI_D = SDL_PI_D;

/**
 * The value of Pi, as a single-precision floating point literal.
 *
 * @since This macro is available since SDL 3.2.0.
 *
 * @sa PI_D
 */
constexpr float PI_F = SDL_PI_F;

/**
 * Compute the arc cosine of `x`.
 *
 * The definition of `y = acos(x)` is `x = cos(y)`.
 *
 * Domain: `-1 <= x <= 1`
 *
 * Range: `0 <= y <= Pi`
 *
 * This function operates on double-precision floating point values, use
 * acos for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value.
 * @returns arc cosine of `x`, in radians.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa acos
 * @sa asin
 * @sa cos
 */
inline double acos(double x) { return SDL_acos(x); }

/**
 * Compute the arc cosine of `x`.
 *
 * The definition of `y = acos(x)` is `x = cos(y)`.
 *
 * Domain: `-1 <= x <= 1`
 *
 * Range: `0 <= y <= Pi`
 *
 * This function operates on single-precision floating point values, use
 * acos for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value.
 * @returns arc cosine of `x`, in radians.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa acos
 * @sa asin
 * @sa cos
 */
inline float acos(float x) { return SDL_acosf(x); }

/**
 * Compute the arc sine of `x`.
 *
 * The definition of `y = asin(x)` is `x = sin(y)`.
 *
 * Domain: `-1 <= x <= 1`
 *
 * Range: `-Pi/2 <= y <= Pi/2`
 *
 * This function operates on double-precision floating point values, use
 * asin for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value.
 * @returns arc sine of `x`, in radians.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa asin
 * @sa acos
 * @sa sin
 */
inline double asin(double x) { return SDL_asin(x); }

/**
 * Compute the arc sine of `x`.
 *
 * The definition of `y = asin(x)` is `x = sin(y)`.
 *
 * Domain: `-1 <= x <= 1`
 *
 * Range: `-Pi/2 <= y <= Pi/2`
 *
 * This function operates on single-precision floating point values, use
 * asin for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value.
 * @returns arc sine of `x`, in radians.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa asin
 * @sa acos
 * @sa sin
 */
inline float asin(float x) { return SDL_asinf(x); }

/**
 * Compute the arc tangent of `x`.
 *
 * The definition of `y = atan(x)` is `x = tan(y)`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-Pi/2 <= y <= Pi/2`
 *
 * This function operates on double-precision floating point values, use
 * atan for single-precision floats.
 *
 * To calculate the arc tangent of y / x, use atan2.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value.
 * @returns arc tangent of of `x` in radians, or 0 if `x = 0`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa atan
 * @sa atan2
 * @sa tan
 */
inline double atan(double x) { return SDL_atan(x); }

/**
 * Compute the arc tangent of `x`.
 *
 * The definition of `y = atan(x)` is `x = tan(y)`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-Pi/2 <= y <= Pi/2`
 *
 * This function operates on single-precision floating point values, use
 * atan for dboule-precision floats.
 *
 * To calculate the arc tangent of y / x, use atan2.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value.
 * @returns arc tangent of of `x` in radians, or 0 if `x = 0`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa atan
 * @sa atan2
 * @sa tan
 */
inline float atan(float x) { return SDL_atanf(x); }

/**
 * Compute the arc tangent of `y / x`, using the signs of x and y to adjust
 * the result's quadrant.
 *
 * The definition of `z = atan2(x, y)` is `y = x tan(z)`, where the quadrant
 * of z is determined based on the signs of x and y.
 *
 * Domain: `-INF <= x <= INF`, `-INF <= y <= INF`
 *
 * Range: `-Pi <= y <= Pi`
 *
 * This function operates on double-precision floating point values, use
 * atan2 for single-precision floats.
 *
 * To calculate the arc tangent of a single value, use atan.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param y floating point value of the numerator (y coordinate).
 * @param x floating point value of the denominator (x coordinate).
 * @returns arc tangent of of `y / x` in radians, or, if `x = 0`, either
 *          `-Pi/2`, `0`, or `Pi/2`, depending on the value of `y`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa atan
 * @sa tan
 */
inline double atan2(double y, double x) { return SDL_atan2(y, x); }

/**
 * Compute the arc tangent of `y / x`, using the signs of x and y to adjust
 * the result's quadrant.
 *
 * The definition of `z = atan2(x, y)` is `y = x tan(z)`, where the quadrant
 * of z is determined based on the signs of x and y.
 *
 * Domain: `-INF <= x <= INF`, `-INF <= y <= INF`
 *
 * Range: `-Pi <= y <= Pi`
 *
 * This function operates on single-precision floating point values, use
 * atan2 for double-precision floats.
 *
 * To calculate the arc tangent of a single value, use atan.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param y floating point value of the numerator (y coordinate).
 * @param x floating point value of the denominator (x coordinate).
 * @returns arc tangent of of `y / x` in radians, or, if `x = 0`, either
 *          `-Pi/2`, `0`, or `Pi/2`, depending on the value of `y`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa atan2
 * @sa atan
 * @sa tan
 */
inline float atan2(float y, float x) { return SDL_atan2f(y, x); }

/**
 * Compute the ceiling of `x`.
 *
 * The ceiling of `x` is the smallest integer `y` such that `y > x`, i.e `x`
 * rounded up to the nearest integer.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on double-precision floating point values, use
 * ceil for single-precision floats.
 *
 * @param x floating point value.
 * @returns the ceiling of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa ceil
 * @sa floor
 * @sa trunc
 * @sa round
 * @sa lround
 */
inline double ceil(double x) { return SDL_ceil(x); }

/**
 * Compute the ceiling of `x`.
 *
 * The ceiling of `x` is the smallest integer `y` such that `y > x`, i.e `x`
 * rounded up to the nearest integer.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on single-precision floating point values, use
 * ceil for double-precision floats.
 *
 * @param x floating point value.
 * @returns the ceiling of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa ceil
 * @sa floor
 * @sa trunc
 * @sa round
 * @sa lround
 */
inline float ceil(float x) { return SDL_ceilf(x); }

/**
 * Copy the sign of one floating-point value to another.
 *
 * The definition of copysign is that ``copysign(x, y) = abs(x) * sign(y)``.
 *
 * Domain: `-INF <= x <= INF`, ``-INF <= y <= f``
 *
 * Range: `-INF <= z <= INF`
 *
 * This function operates on double-precision floating point values, use
 * copysign for single-precision floats.
 *
 * @param x floating point value to use as the magnitude.
 * @param y floating point value to use as the sign.
 * @returns the floating point value with the sign of y and the magnitude of
 *          x.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa copysign
 * @sa abs
 */
inline double copysign(double x, double y) { return SDL_copysign(x, y); }

/**
 * Copy the sign of one floating-point value to another.
 *
 * The definition of copysign is that ``copysign(x, y) = abs(x) * sign(y)``.
 *
 * Domain: `-INF <= x <= INF`, ``-INF <= y <= f``
 *
 * Range: `-INF <= z <= INF`
 *
 * This function operates on single-precision floating point values, use
 * copysign for double-precision floats.
 *
 * @param x floating point value to use as the magnitude.
 * @param y floating point value to use as the sign.
 * @returns the floating point value with the sign of y and the magnitude of
 *          x.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa copysign
 * @sa abs
 */
inline float copysign(float x, float y) { return SDL_copysignf(x, y); }

/**
 * Compute the cosine of `x`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-1 <= y <= 1`
 *
 * This function operates on double-precision floating point values, use
 * cos for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value, in radians.
 * @returns cosine of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa cos
 * @sa acos
 * @sa sin
 */
inline double cos(double x) { return SDL_cos(x); }

/**
 * Compute the cosine of `x`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-1 <= y <= 1`
 *
 * This function operates on single-precision floating point values, use
 * cos for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value, in radians.
 * @returns cosine of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa cos
 * @sa acos
 * @sa sin
 */
inline float cos(float x) { return SDL_cosf(x); }

/**
 * Compute the exponential of `x`.
 *
 * The definition of `y = exp(x)` is `y = e^x`, where `e` is the base of the
 * natural logarithm. The inverse is the natural logarithm, log.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `0 <= y <= INF`
 *
 * The output will overflow if `exp(x)` is too large to be represented.
 *
 * This function operates on double-precision floating point values, use
 * exp for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value.
 * @returns value of `e^x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa exp
 * @sa log
 */
inline double exp(double x) { return SDL_exp(x); }

/**
 * Compute the exponential of `x`.
 *
 * The definition of `y = exp(x)` is `y = e^x`, where `e` is the base of the
 * natural logarithm. The inverse is the natural logarithm, log.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `0 <= y <= INF`
 *
 * The output will overflow if `exp(x)` is too large to be represented.
 *
 * This function operates on single-precision floating point values, use
 * exp for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value.
 * @returns value of `e^x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa exp
 * @sa log
 */
inline float exp(float x) { return SDL_expf(x); }

/**
 * Compute the floor of `x`.
 *
 * The floor of `x` is the largest integer `y` such that `y > x`, i.e `x`
 * rounded down to the nearest integer.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on double-precision floating point values, use
 * floor for single-precision floats.
 *
 * @param x floating point value.
 * @returns the floor of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa floor
 * @sa ceil
 * @sa trunc
 * @sa round
 * @sa lround
 */
inline double floor(double x) { return SDL_floor(x); }

/**
 * Compute the floor of `x`.
 *
 * The floor of `x` is the largest integer `y` such that `y > x`, i.e `x`
 * rounded down to the nearest integer.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on single-precision floating point values, use
 * floor for double-precision floats.
 *
 * @param x floating point value.
 * @returns the floor of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa floor
 * @sa ceil
 * @sa trunc
 * @sa round
 * @sa lround
 */
inline float floor(float x) { return SDL_floorf(x); }

/**
 * Truncate `x` to an integer.
 *
 * Rounds `x` to the next closest integer to 0. This is equivalent to removing
 * the fractional part of `x`, leaving only the integer part.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on double-precision floating point values, use
 * trunc for single-precision floats.
 *
 * @param x floating point value.
 * @returns `x` truncated to an integer.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa trunc
 * @sa fmod
 * @sa ceil
 * @sa floor
 * @sa round
 * @sa lround
 */
inline double trunc(double x) { return SDL_trunc(x); }

/**
 * Truncate `x` to an integer.
 *
 * Rounds `x` to the next closest integer to 0. This is equivalent to removing
 * the fractional part of `x`, leaving only the integer part.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on single-precision floating point values, use
 * trunc for double-precision floats.
 *
 * @param x floating point value.
 * @returns `x` truncated to an integer.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa trunc
 * @sa fmod
 * @sa ceil
 * @sa floor
 * @sa round
 * @sa lround
 */
inline float trunc(float x) { return SDL_truncf(x); }

/**
 * Return the floating-point remainder of `x / y`
 *
 * Divides `x` by `y`, and returns the remainder.
 *
 * Domain: `-INF <= x <= INF`, `-INF <= y <= INF`, `y != 0`
 *
 * Range: `-y <= z <= y`
 *
 * This function operates on double-precision floating point values, use
 * fmod for single-precision floats.
 *
 * @param x the numerator.
 * @param y the denominator. Must not be 0.
 * @returns the remainder of `x / y`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa fmod
 * @sa modf
 * @sa trunc
 * @sa ceil
 * @sa floor
 * @sa round
 * @sa lround
 */
inline double fmod(double x, double y) { return SDL_fmod(x, y); }

/**
 * Return the floating-point remainder of `x / y`
 *
 * Divides `x` by `y`, and returns the remainder.
 *
 * Domain: `-INF <= x <= INF`, `-INF <= y <= INF`, `y != 0`
 *
 * Range: `-y <= z <= y`
 *
 * This function operates on single-precision floating point values, use
 * fmod for double-precision floats.
 *
 * @param x the numerator.
 * @param y the denominator. Must not be 0.
 * @returns the remainder of `x / y`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa fmod
 * @sa trunc
 * @sa modf
 * @sa ceil
 * @sa floor
 * @sa round
 * @sa lround
 */
inline float fmod(float x, float y) { return SDL_fmodf(x, y); }

/**
 * Return whether the value is infinity.
 *
 * @param x double-precision floating point value.
 * @returns non-zero if the value is infinity, 0 otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa isinf
 */
inline int isinf(double x) { return SDL_isinf(x); }

/**
 * Return whether the value is infinity.
 *
 * @param x floating point value.
 * @returns non-zero if the value is infinity, 0 otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa isinf
 */
inline int isinf(float x) { return SDL_isinff(x); }

/**
 * Return whether the value is NaN.
 *
 * @param x double-precision floating point value.
 * @returns non-zero if the value is NaN, 0 otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa isnan
 */
inline int isnan(double x) { return SDL_isnan(x); }

/**
 * Return whether the value is NaN.
 *
 * @param x floating point value.
 * @returns non-zero if the value is NaN, 0 otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa isnan
 */
inline int isnan(float x) { return SDL_isnanf(x); }

/**
 * Compute the natural logarithm of `x`.
 *
 * Domain: `0 < x <= INF`
 *
 * Range: `-INF <= y <= INF`
 *
 * It is an error for `x` to be less than or equal to 0.
 *
 * This function operates on double-precision floating point values, use
 * log for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value. Must be greater than 0.
 * @returns the natural logarithm of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa log
 * @sa log10
 * @sa exp
 */
inline double log(double x) { return SDL_log(x); }

/**
 * Compute the natural logarithm of `x`.
 *
 * Domain: `0 < x <= INF`
 *
 * Range: `-INF <= y <= INF`
 *
 * It is an error for `x` to be less than or equal to 0.
 *
 * This function operates on single-precision floating point values, use
 * log for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value. Must be greater than 0.
 * @returns the natural logarithm of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa log
 * @sa exp
 */
inline float log(float x) { return SDL_logf(x); }

/**
 * Compute the base-10 logarithm of `x`.
 *
 * Domain: `0 < x <= INF`
 *
 * Range: `-INF <= y <= INF`
 *
 * It is an error for `x` to be less than or equal to 0.
 *
 * This function operates on double-precision floating point values, use
 * log10 for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value. Must be greater than 0.
 * @returns the logarithm of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa log10
 * @sa log
 * @sa pow
 */
inline double log10(double x) { return SDL_log10(x); }

/**
 * Compute the base-10 logarithm of `x`.
 *
 * Domain: `0 < x <= INF`
 *
 * Range: `-INF <= y <= INF`
 *
 * It is an error for `x` to be less than or equal to 0.
 *
 * This function operates on single-precision floating point values, use
 * log10 for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value. Must be greater than 0.
 * @returns the logarithm of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa log10
 * @sa log
 * @sa pow
 */
inline float log10(float x) { return SDL_log10f(x); }

/**
 * Split `x` into integer and fractional parts
 *
 * This function operates on double-precision floating point values, use
 * modf for single-precision floats.
 *
 * @param x floating point value.
 * @param y output pointer to store the integer part of `x`.
 * @returns the fractional part of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa modf
 * @sa trunc
 * @sa fmod
 */
inline double modf(double x, double* y) { return SDL_modf(x, y); }

/**
 * Split `x` into integer and fractional parts
 *
 * This function operates on single-precision floating point values, use
 * modf for double-precision floats.
 *
 * @param x floating point value.
 * @param y output pointer to store the integer part of `x`.
 * @returns the fractional part of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa modf
 * @sa trunc
 * @sa fmod
 */
inline float modf(float x, float* y) { return SDL_modff(x, y); }

/**
 * Raise `x` to the power `y`
 *
 * Domain: `-INF <= x <= INF`, `-INF <= y <= INF`
 *
 * Range: `-INF <= z <= INF`
 *
 * If `y` is the base of the natural logarithm (e), consider using exp
 * instead.
 *
 * This function operates on double-precision floating point values, use
 * pow for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x the base.
 * @param y the exponent.
 * @returns `x` raised to the power `y`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa pow
 * @sa exp
 * @sa log
 */
inline double pow(double x, double y) { return SDL_pow(x, y); }

/**
 * Raise `x` to the power `y`
 *
 * Domain: `-INF <= x <= INF`, `-INF <= y <= INF`
 *
 * Range: `-INF <= z <= INF`
 *
 * If `y` is the base of the natural logarithm (e), consider using exp
 * instead.
 *
 * This function operates on single-precision floating point values, use
 * pow for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x the base.
 * @param y the exponent.
 * @returns `x` raised to the power `y`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa pow
 * @sa exp
 * @sa log
 */
inline float pow(float x, float y) { return SDL_powf(x, y); }

/**
 * Round `x` to the nearest integer.
 *
 * Rounds `x` to the nearest integer. Values halfway between integers will be
 * rounded away from zero.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on double-precision floating point values, use
 * round for single-precision floats. To get the result as an integer
 * type, use lround.
 *
 * @param x floating point value.
 * @returns the nearest integer to `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa round
 * @sa lround
 * @sa floor
 * @sa ceil
 * @sa trunc
 */
inline double round(double x) { return SDL_round(x); }

/**
 * Round `x` to the nearest integer.
 *
 * Rounds `x` to the nearest integer. Values halfway between integers will be
 * rounded away from zero.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on single-precision floating point values, use
 * round for double-precision floats. To get the result as an integer
 * type, use lround.
 *
 * @param x floating point value.
 * @returns the nearest integer to `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa round
 * @sa lround
 * @sa floor
 * @sa ceil
 * @sa trunc
 */
inline float round(float x) { return SDL_roundf(x); }

/**
 * Round `x` to the nearest integer representable as a long
 *
 * Rounds `x` to the nearest integer. Values halfway between integers will be
 * rounded away from zero.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `MIN_LONG <= y <= MAX_LONG`
 *
 * This function operates on double-precision floating point values, use
 * lround for single-precision floats. To get the result as a
 * floating-point type, use round.
 *
 * @param x floating point value.
 * @returns the nearest integer to `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa lround
 * @sa round
 * @sa floor
 * @sa ceil
 * @sa trunc
 */
inline long lround(double x) { return SDL_lround(x); }

/**
 * Round `x` to the nearest integer representable as a long
 *
 * Rounds `x` to the nearest integer. Values halfway between integers will be
 * rounded away from zero.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `MIN_LONG <= y <= MAX_LONG`
 *
 * This function operates on single-precision floating point values, use
 * lround for double-precision floats. To get the result as a
 * floating-point type, use round.
 *
 * @param x floating point value.
 * @returns the nearest integer to `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa lround
 * @sa round
 * @sa floor
 * @sa ceil
 * @sa trunc
 */
inline long lround(float x) { return SDL_lroundf(x); }

/**
 * Scale `x` by an integer power of two.
 *
 * Multiplies `x` by the `n`th power of the floating point radix (always 2).
 *
 * Domain: `-INF <= x <= INF`, `n` integer
 *
 * Range: `-INF <= y <= INF`
 *
 * This function operates on double-precision floating point values, use
 * scalbn for single-precision floats.
 *
 * @param x floating point value to be scaled.
 * @param n integer exponent.
 * @returns `x * 2^n`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa scalbn
 * @sa pow
 */
inline double scalbn(double x, int n) { return SDL_scalbn(x, n); }

/**
 * Scale `x` by an integer power of two.
 *
 * Multiplies `x` by the `n`th power of the floating point radix (always 2).
 *
 * Domain: `-INF <= x <= INF`, `n` integer
 *
 * Range: `-INF <= y <= INF`
 *
 * This function operates on single-precision floating point values, use
 * scalbn for double-precision floats.
 *
 * @param x floating point value to be scaled.
 * @param n integer exponent.
 * @returns `x * 2^n`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa scalbn
 * @sa pow
 */
inline float scalbn(float x, int n) { return SDL_scalbnf(x, n); }

/**
 * Compute the sine of `x`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-1 <= y <= 1`
 *
 * This function operates on double-precision floating point values, use
 * sin for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value, in radians.
 * @returns sine of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa sin
 * @sa asin
 * @sa cos
 */
inline double sin(double x) { return SDL_sin(x); }

/**
 * Compute the sine of `x`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-1 <= y <= 1`
 *
 * This function operates on single-precision floating point values, use
 * sin for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value, in radians.
 * @returns sine of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa sin
 * @sa asin
 * @sa cos
 */
inline float sin(float x) { return SDL_sinf(x); }

/**
 * Compute the square root of `x`.
 *
 * Domain: `0 <= x <= INF`
 *
 * Range: `0 <= y <= INF`
 *
 * This function operates on double-precision floating point values, use
 * sqrt for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value. Must be greater than or equal to 0.
 * @returns square root of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa sqrt
 */
inline double sqrt(double x) { return SDL_sqrt(x); }

/**
 * Compute the square root of `x`.
 *
 * Domain: `0 <= x <= INF`
 *
 * Range: `0 <= y <= INF`
 *
 * This function operates on single-precision floating point values, use
 * sqrt for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value. Must be greater than or equal to 0.
 * @returns square root of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa sqrt
 */
inline float sqrt(float x) { return SDL_sqrtf(x); }

/**
 * Compute the tangent of `x`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`
 *
 * This function operates on double-precision floating point values, use
 * tan for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value, in radians.
 * @returns tangent of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa tan
 * @sa sin
 * @sa cos
 * @sa atan
 * @sa atan2
 */
inline double tan(double x) { return SDL_tan(x); }

/**
 * Compute the tangent of `x`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`
 *
 * This function operates on single-precision floating point values, use
 * tan for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value, in radians.
 * @returns tangent of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa tan
 * @sa sin
 * @sa cos
 * @sa atan
 * @sa atan2
 */
inline float tan(float x) { return SDL_tanf(x); }

/**
 * An opaque handle representing string encoding conversion state.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @cat resource
 *
 * @sa IConv.open
 * @sa IConv
 */
class IConv
{
  IConvRaw m_resource = nullptr;

public:
  /// Default ctor
  constexpr IConv() = default;

  /**
   * Constructs from IConvParam.
   *
   * @param resource a IConvRaw to be wrapped.
   *
   * This assumes the ownership, call release() if you need to take back.
   */
  constexpr explicit IConv(const IConvRaw resource)
    : m_resource(resource)
  {
  }

  /// Copy constructor
  constexpr IConv(const IConv& other) = delete;

  /// Move constructor
  constexpr IConv(IConv&& other)
    : IConv(other.release())
  {
  }

  constexpr IConv(const IConvRef& other) = delete;

  constexpr IConv(IConvRef&& other) = delete;

  /**
   * This function allocates a context for the specified character set
   * conversion.
   *
   * @param tocode The target character encoding, must not be nullptr.
   * @param fromcode The source character encoding, must not be nullptr.
   * @returns a handle that must be freed with IConv.close, or
   *          SDL_ICONV_ERROR on failure.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa IConv.iconv
   * @sa IConv.close
   * @sa iconv_string
   */
  IConv(StringParam tocode, StringParam fromcode)
    : m_resource(SDL_iconv_open(tocode, fromcode))
  {
  }

  /// Destructor
  ~IConv() { SDL_iconv_close(m_resource); }

  /// Assignment operator.
  IConv& operator=(IConv other)
  {
    std::swap(m_resource, other.m_resource);
    return *this;
  }

  /// Retrieves underlying IConvRaw.
  constexpr IConvRaw get() const { return m_resource; }

  /// Retrieves underlying IConvRaw and clear this.
  constexpr IConvRaw release()
  {
    auto r = m_resource;
    m_resource = nullptr;
    return r;
  }

  /// Comparison
  constexpr auto operator<=>(const IConv& other) const = default;

  /// Comparison
  constexpr bool operator==(std::nullptr_t _) const { return !m_resource; }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!m_resource; }

  /// Converts to IConvParam
  constexpr operator IConvParam() const { return {m_resource}; }

  /**
   * This function frees a context used for character set conversion.
   *
   * @param cd The character set conversion handle.
   * @returns 0 on success, or -1 on failure.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa IConv.iconv
   * @sa IConv.open
   * @sa iconv_string
   */
  int close();

  /**
   * This function converts text between encodings, reading from and writing to
   * a buffer.
   *
   * It returns the number of successful conversions on success. On error,
   * SDL_ICONV_E2BIG is returned when the output buffer is too small, or
   * SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,
   * or SDL_ICONV_EINVAL is returned when an incomplete input sequence is
   * encountered.
   *
   * On exit:
   *
   * - inbuf will point to the beginning of the next multibyte sequence. On
   *   error, this is the location of the problematic input sequence. On
   *   success, this is the end of the input sequence.
   * - inbytesleft will be set to the number of bytes left to convert, which
   *   will be 0 on success.
   * - outbuf will point to the location where to store the next output byte.
   * - outbytesleft will be set to the number of bytes left in the output
   *   buffer.
   *
   * @param inbuf Address of variable that points to the first character of the
   *              input sequence.
   * @param inbytesleft The number of bytes in the input buffer.
   * @param outbuf Address of variable that points to the output buffer.
   * @param outbytesleft The number of bytes in the output buffer.
   * @returns the number of conversions on success.
   * @throws Error on failure.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa IConv.open
   * @sa IConv.close
   * @sa iconv_string
   */
  size_t iconv(const char** inbuf,
               size_t* inbytesleft,
               char** outbuf,
               size_t* outbytesleft);
};

/// Semi-safe reference for IConv.
struct IConvRef : IConv
{
  /**
   * Constructs from IConvParam.
   *
   * @param resource a IConvRaw or IConv.
   *
   * This does not takes ownership!
   */
  IConvRef(IConvParam resource)
    : IConv(resource.value)
  {
  }

  /// Copy constructor.
  IConvRef(const IConvRef& other)
    : IConv(other.get())
  {
  }

  /// Destructor
  ~IConvRef() { release(); }
};

/**
 * This function allocates a context for the specified character set
 * conversion.
 *
 * @param tocode The target character encoding, must not be nullptr.
 * @param fromcode The source character encoding, must not be nullptr.
 * @returns a handle that must be freed with IConv.close, or
 *          SDL_ICONV_ERROR on failure.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa IConv.iconv
 * @sa IConv.close
 * @sa iconv_string
 */
inline IConv iconv_open(StringParam tocode, StringParam fromcode)
{
  return IConv(SDL_iconv_open(tocode, fromcode));
}

/**
 * This function frees a context used for character set conversion.
 *
 * @param cd The character set conversion handle.
 * @returns 0 on success.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa IConv.iconv
 * @sa IConv.open
 * @sa iconv_string
 */
inline int iconv_close(IConvRaw cd) { return CheckError(SDL_iconv_close(cd)); }

inline int IConv::close()
{
  auto r = SDL_iconv_close(m_resource);
  m_resource = nullptr;
  return r;
}

/**
 * This function converts text between encodings, reading from and writing to
 * a buffer.
 *
 * It returns the number of successful conversions on success. On error,
 * SDL_ICONV_E2BIG is returned when the output buffer is too small, or
 * SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,
 * or SDL_ICONV_EINVAL is returned when an incomplete input sequence is
 * encountered.
 *
 * On exit:
 *
 * - inbuf will point to the beginning of the next multibyte sequence. On
 *   error, this is the location of the problematic input sequence. On
 *   success, this is the end of the input sequence.
 * - inbytesleft will be set to the number of bytes left to convert, which
 *   will be 0 on success.
 * - outbuf will point to the location where to store the next output byte.
 * - outbytesleft will be set to the number of bytes left in the output
 *   buffer.
 *
 * @param cd The character set conversion context, created in
 *           IConv.open().
 * @param inbuf Address of variable that points to the first character of the
 *              input sequence.
 * @param inbytesleft The number of bytes in the input buffer.
 * @param outbuf Address of variable that points to the output buffer.
 * @param outbytesleft The number of bytes in the output buffer.
 * @returns the number of conversions on success.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa IConv.open
 * @sa IConv.close
 * @sa iconv_string
 */
inline size_t iconv(IConvRaw cd,
                    const char** inbuf,
                    size_t* inbytesleft,
                    char** outbuf,
                    size_t* outbytesleft)
{
  return CheckError(SDL_iconv(cd, inbuf, inbytesleft, outbuf, outbytesleft));
}

inline size_t IConv::iconv(const char** inbuf,
                           size_t* inbytesleft,
                           char** outbuf,
                           size_t* outbytesleft)
{
  return SDL::iconv(m_resource, inbuf, inbytesleft, outbuf, outbytesleft);
}

#ifdef SDL3PP_DOC

/// Generic error. Check GetError()?
#define SDL_ICONV_ERROR (size_t)-1

/// Output buffer was too small.
#define SDL_ICONV_E2BIG (size_t)-2

/// Invalid input sequence was encountered.
#define SDL_ICONV_EILSEQ (size_t)-3

/// Incomplete input sequence was encountered.
#define SDL_ICONV_EINVAL (size_t)-4

#endif // SDL3PP_DOC

/**
 * Helper function to convert a string's encoding in one call.
 *
 * This function converts a buffer or string between encodings in one pass.
 *
 * The string does not need to be nullptr-terminated; this function operates on
 * the number of bytes specified in `inbytesleft` whether there is a nullptr
 * character anywhere in the buffer.
 *
 * @param tocode the character encoding of the output string. Examples are
 *               "UTF-8", "UCS-4", etc.
 * @param fromcode the character encoding of data in `inbuf`.
 * @param inbuf the string to convert to a different encoding.
 * @param inbytesleft the size of the input string _in bytes_.
 * @returns a new string, converted to the new encoding, or nullptr on error.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa IConv.open
 * @sa IConv.close
 * @sa IConv.iconv
 */
inline OwnPtr<char> iconv_string(StringParam tocode,
                                 StringParam fromcode,
                                 StringParam inbuf,
                                 size_t inbytesleft)
{
  return OwnPtr<char>{SDL_iconv_string(tocode, fromcode, inbuf, inbytesleft)};
}

#ifdef SDL3PP_DOC

/**
 * Convert a UTF-8 string to the current locale's character encoding.
 *
 * This is a helper macro that might be more clear than calling
 * iconv_string directly. However, it double-evaluates its parameter, so
 * do not use an expression with side-effects here.
 *
 * @param S the string to convert.
 * @returns a new string, converted to the new encoding, or nullptr on error.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_iconv_utf8_locale(S)                                               \
  SDL_iconv_string("", "UTF-8", S, SDL_strlen(S) + 1)

/**
 * Convert a UTF-8 string to UCS-2.
 *
 * This is a helper macro that might be more clear than calling
 * iconv_string directly. However, it double-evaluates its parameter, so
 * do not use an expression with side-effects here.
 *
 * @param S the string to convert.
 * @returns a new string, converted to the new encoding, or nullptr on error.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_iconv_utf8_ucs2(S)                                                 \
  (Uint16*)SDL_iconv_string("UCS-2", "UTF-8", S, SDL_strlen(S) + 1)

/**
 * Convert a UTF-8 string to UCS-4.
 *
 * This is a helper macro that might be more clear than calling
 * iconv_string directly. However, it double-evaluates its parameter, so
 * do not use an expression with side-effects here.
 *
 * @param S the string to convert.
 * @returns a new string, converted to the new encoding, or nullptr on error.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_iconv_utf8_ucs4(S)                                                 \
  (Uint32*)SDL_iconv_string("UCS-4", "UTF-8", S, SDL_strlen(S) + 1)

/**
 * Convert a wchar_t string to UTF-8.
 *
 * This is a helper macro that might be more clear than calling
 * iconv_string directly. However, it double-evaluates its parameter, so
 * do not use an expression with side-effects here.
 *
 * @param S the string to convert.
 * @returns a new string, converted to the new encoding, or nullptr on error.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_iconv_wchar_utf8(S)                                                \
  SDL_iconv_string(                                                            \
    "UTF-8", "WCHAR_T", (char*)S, (SDL_wcslen(S) + 1) * sizeof(wchar_t))

#endif // SDL3PP_DOC

/**
 * Multiply two integers, checking for overflow.
 *
 * If `a * b` would overflow, return false.
 *
 * Otherwise store `a * b` via ret and return true.
 *
 * @param a the multiplicand.
 * @param b the multiplier.
 * @param ret on non-overflow output, stores the multiplication result, may
 *            not be nullptr.
 * @returns false on overflow, true if result is multiplied without overflow.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline bool size_mul_check_overflow(size_t a, size_t b, size_t* ret)
{
  return SDL_size_mul_check_overflow(a, b, ret);
}

/**
 * Add two integers, checking for overflow.
 *
 * If `a + b` would overflow, return false.
 *
 * Otherwise store `a + b` via ret and return true.
 *
 * @param a the first addend.
 * @param b the second addend.
 * @param ret on non-overflow output, stores the addition result, may not be
 *            nullptr.
 * @returns false on overflow, true if result is added without overflow.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline bool size_add_check_overflow(size_t a, size_t b, size_t* ret)
{
  return SDL_size_add_check_overflow(a, b, ret);
}

/**
 * A generic function pointer.
 *
 * In theory, generic function pointers should use this, instead of `void *`,
 * since some platforms could treat code addresses differently than data
 * addresses. Although in current times no popular platforms make this
 * distinction, it is more correct and portable to use the correct type for a
 * generic pointer.
 *
 * If for some reason you need to force this typedef to be an actual `void *`,
 * perhaps to work around a compiler or existing code, you can define
 * `SDL_FUNCTION_POINTER_IS_VOID_POINTER` before including any SDL headers.
 *
 * @since This datatype is available since SDL 3.2.0.
 */
using FunctionPointer = SDL_FunctionPointer;

/// @}

inline void PtrDeleter::operator()(void* ptr) const { SDL_free(ptr); }

/**
 * @defgroup CategoryClipboard Clipboard Handling
 *
 * SDL provides access to the system clipboard, both for reading information
 * from other processes and publishing information of its own.
 *
 * This is not just text! SDL apps can access and publish data by mimetype.
 *
 * ## Basic use (text)
 *
 * Obtaining and publishing simple text to the system clipboard is as easy as
 * calling GetClipboardText() and SetClipboardText(), respectively.
 * These deal with C strings in UTF-8 encoding. Data transmission and encoding
 * conversion is completely managed by SDL.
 *
 * ## Clipboard callbacks (data other than text)
 *
 * Things get more complicated when the clipboard contains something other
 * than text. Not only can the system clipboard contain data of any type, in
 * some cases it can contain the same data in different formats! For example,
 * an image painting app might let the user copy a graphic to the clipboard,
 * and offers it in .BMP, .JPG, or .PNG format for other apps to consume.
 *
 * Obtaining clipboard data ("pasting") like this is a matter of calling
 * GetClipboardData() and telling it the mimetype of the data you want.
 * But how does one know if that format is available? HasClipboardData()
 * can report if a specific mimetype is offered, and
 * GetClipboardMimeTypes() can provide the entire list of mimetypes
 * available, so the app can decide what to do with the data and what formats
 * it can support.
 *
 * Setting the clipboard ("copying") to arbitrary data is done with
 * SetClipboardData. The app does not provide the data in this call, but
 * rather the mimetypes it is willing to provide and a callback function.
 * During the callback, the app will generate the data. This allows massive
 * data sets to be provided to the clipboard, without any data being copied
 * before it is explicitly requested. More specifically, it allows an app to
 * offer data in multiple formats without providing a copy of all of them
 * upfront. If the app has an image that it could provide in PNG or JPG
 * format, it doesn't have to encode it to either of those unless and until
 * something tries to paste it.
 *
 * ## Primary Selection
 *
 * The X11 and Wayland video targets have a concept of the "primary selection"
 * in addition to the usual clipboard. This is generally highlighted (but not
 * explicitly copied) text from various apps. SDL offers APIs for this through
 * GetPrimarySelectionText() and SetPrimarySelectionText(). SDL offers
 * these APIs on platforms without this concept, too, but only so far that it
 * will keep a copy of a string that the app sets for later retrieval; the
 * operating system will not ever attempt to change the string externally if
 * it doesn't support a primary selection.
 *
 * @{
 */

/**
 * Put UTF-8 text into the clipboard.
 *
 * @param text the text to store in the clipboard.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetClipboardText
 * @sa HasClipboardText
 */
inline void SetClipboardText(StringParam text)
{
  CheckError(SDL_SetClipboardText(text));
}

/**
 * Get UTF-8 text from the clipboard.
 *
 * This function returns an empty string if there is not enough memory left
 * for a copy of the clipboard's content.
 *
 * @returns the clipboard text on success.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa HasClipboardText
 * @sa SetClipboardText
 */
inline StringResult GetClipboardText()
{
  return StringResult{CheckError(SDL_GetClipboardText())};
}

/**
 * Query whether the clipboard exists and contains a non-empty text string.
 *
 * @returns true if the clipboard has text, or false if it does not.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetClipboardText
 * @sa SetClipboardText
 */
inline bool HasClipboardText() { return SDL_HasClipboardText(); }

/**
 * Put UTF-8 text into the primary selection.
 *
 * @param text the text to store in the primary selection.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetPrimarySelectionText
 * @sa HasPrimarySelectionText
 */
inline void SetPrimarySelectionText(StringParam text)
{
  CheckError(SDL_SetPrimarySelectionText(text));
}

/**
 * Get UTF-8 text from the primary selection.
 *
 * This function returns an empty string if there is not enough memory left
 * for a copy of the primary selection's content.
 *
 * @returns the primary selection text on success.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa HasPrimarySelectionText
 * @sa SetPrimarySelectionText
 */
inline StringResult GetPrimarySelectionText()
{
  return StringResult{CheckError(SDL_GetPrimarySelectionText())};
}

/**
 * Query whether the primary selection exists and contains a non-empty text
 * string.
 *
 * @returns true if the primary selection has text, or false if it does not.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetPrimarySelectionText
 * @sa SetPrimarySelectionText
 */
inline bool HasPrimarySelectionText() { return SDL_HasPrimarySelectionText(); }

/**
 * Callback function that will be called when data for the specified mime-type
 * is requested by the OS.
 *
 * The callback function is called with nullptr as the mime_type when the
 * clipboard is cleared or new data is set. The clipboard is automatically
 * cleared in Quit().
 *
 * @param userdata a pointer to the provided user data.
 * @param mime_type the requested mime-type.
 * @param size a pointer filled in with the length of the returned data.
 * @returns a pointer to the data for the provided mime-type. Returning nullptr
 *          or setting the length to 0 will cause no data to be sent to the
 *          "receiver". It is up to the receiver to handle this. Essentially
 *          returning no data is more or less undefined behavior and may cause
 *          breakage in receiving applications.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SetClipboardData
 */
using ClipboardDataCallback = SDL_ClipboardDataCallback;

/**
 * Callback function that will be called when data for the specified mime-type
 * is requested by the OS.
 *
 * The callback function is called with nullptr as the mime_type when the
 * clipboard is cleared or new data is set. The clipboard is automatically
 * cleared in Quit().
 *
 * @param mime_type the requested mime-type.
 * @param size a pointer filled in with the length of the returned data.
 * @returns a pointer to the data for the provided mime-type. Returning nullptr
 *          or setting length to 0 will cause no data to be sent to the
 *          "receiver". It is up to the receiver to handle this. Essentially
 *          returning no data is more or less undefined behavior and may cause
 *          breakage in receiving applications.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SetClipboardData
 * @sa ClipboardDataCallback
 */
using ClipboardDataCB = std::function<SourceBytes(const char* mime_type)>;

/**
 * Callback function that will be called when the clipboard is cleared, or when
 * new data is set.
 *
 * @param userdata a pointer to the provided user data.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SetClipboardData
 */
using ClipboardCleanupCallback = SDL_ClipboardCleanupCallback;

/**
 * Callback function that will be called when the clipboard is cleared, or when
 * new data is set.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SetClipboardData
 * @sa ClipboardCleanupCallback
 */
using ClipboardCleanupCB = std::function<void()>;

/**
 * Offer clipboard data to the OS.
 *
 * Tell the operating system that the application is offering clipboard data
 * for each of the provided mime-types. Once another application requests the
 * data the callback function will be called, allowing it to generate and
 * respond with the data for the requested mime-type.
 *
 * The size of text data does not include any terminator, and the text does
 * not need to be null-terminated (e.g., you can directly copy a portion of a
 * document).
 *
 * @param callback a function pointer to the function that provides the
 *                 clipboard data.
 * @param cleanup a function pointer to the function that cleans up the
 *                clipboard data.
 * @param userdata an opaque pointer that will be forwarded to the callbacks.
 * @param mime_types a list of mime-types that are being offered. SDL copies the
 * given list.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa ClearClipboardData
 * @sa GetClipboardData
 * @sa HasClipboardData
 */
inline void SetClipboardData(ClipboardDataCallback callback,
                             ClipboardCleanupCallback cleanup,
                             void* userdata,
                             std::span<const char*> mime_types)
{
  CheckError(SDL_SetClipboardData(
    callback, cleanup, userdata, mime_types.data(), mime_types.size()));
}

/**
 * Offer clipboard data to the OS.
 *
 * Tell the operating system that the application is offering clipboard data
 * for each of the provided mime-types. Once another application requests the
 * data the callback function will be called, allowing it to generate and
 * respond with the data for the requested mime-type.
 *
 * The size of text data does not include any terminator, and the text does
 * not need to be null-terminated (e.g., you can directly copy a portion of a
 * document).
 *
 * @param callback a function pointer to the function that provides the
 *                 clipboard data.
 * @param cleanup a function pointer to the function that cleans up the
 *                clipboard data.
 * @param mime_types a list of mime-types that are being offered. SDL copies the
 * given list.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa ClearClipboardData
 * @sa GetClipboardData
 * @sa HasClipboardData
 */
inline void SetClipboardData(ClipboardDataCB callback,
                             ClipboardCleanupCB cleanup,
                             std::span<const char*> mime_types)
{
  static ClipboardDataCB s_callback;
  static ClipboardCleanupCB s_cleanup;
  CheckError(SDL_ClearClipboardData());
  s_callback = callback;
  s_cleanup = cleanup;
  SetClipboardData(
    [](void*, const char* mime_type, size_t* size) -> const void* {
      auto source = s_callback(mime_type);
      *size = source.size_bytes;
      return source.data;
    },
    [](void*) {
      if (s_cleanup) s_cleanup();
    },
    nullptr,
    mime_types);
}

/**
 * Clear the clipboard data.
 *
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SetClipboardData
 */
inline void ClearClipboardData() { CheckError(SDL_ClearClipboardData()); }

/**
 * Get the data from the clipboard for a given mime type.
 *
 * The size of text data does not include the terminator, but the text is
 * guaranteed to be null-terminated.
 *
 * @param mime_type the mime type to read from the clipboard.
 * @returns the retrieved data buffer or nullptr on failure; call GetError()
 *          for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa HasClipboardData
 * @sa SetClipboardData
 */
inline StringResult GetClipboardData(StringParam mime_type)
{
  size_t count = 0;
  auto data = SDL_GetClipboardData(mime_type, &count);
  if (!data) return {};
  return StringResult{static_cast<char*>(data), count};
}

/**
 * Get the data from the clipboard for a given mime type.
 *
 * The size of text data does not include the terminator, but the text is
 * guaranteed to be null-terminated.
 *
 * @param mime_type the mime type to read from the clipboard.
 * @returns the retrieved data buffer or nullptr on failure; call GetError()
 *          for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa HasClipboardData
 * @sa SetClipboardData
 */
template<class T>
inline OwnArray<T> GetClipboardDataAs(StringParam mime_type)
{
  size_t count = 0;
  auto data = SDL_GetClipboardData(mime_type, &count);
  if (!data) return {};
  return OwnArray<T>{static_cast<T*>(data), count / sizeof(T)};
}

/**
 * Query whether there is data in the clipboard for the provided mime type.
 *
 * @param mime_type the mime type to check for data.
 * @returns true if data exists in the clipboard for the provided mime type,
 *          false if it does not.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SetClipboardData
 * @sa GetClipboardData
 */
inline bool HasClipboardData(StringParam mime_type)
{
  return SDL_HasClipboardData(mime_type);
}

/**
 * Retrieve the list of mime types available in the clipboard.
 *
 * @returns a null terminated array of strings with mime types, or empty on
 *          failure; call GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SetClipboardData
 */
inline OwnArray<char*> GetClipboardMimeTypes()
{
  size_t count = 0;
  auto data = SDL_GetClipboardMimeTypes(&count);
  if (!data) return {};
  return OwnArray<char*>{data, count};
}

/// @}

/**
 * @defgroup CategoryFilesystem Filesystem Access
 *
 * SDL offers an API for examining and manipulating the system's filesystem.
 * This covers most things one would need to do with directories, except for
 * actual file I/O (which is covered by [CategoryIOStream](CategoryIOStream)
 * and [CategoryAsyncIO](CategoryAsyncIO) instead).
 *
 * There are functions to answer necessary path questions:
 *
 * - Where is my app's data? GetBasePath().
 * - Where can I safely write files? GetPrefPath().
 * - Where are paths like Downloads, Desktop, Music? GetUserFolder().
 * - What is this thing at this location? GetPathInfo().
 * - What items live in this folder? EnumerateDirectory().
 * - What items live in this folder by wildcard? GlobDirectory().
 * - What is my current working directory? GetCurrentDirectory().
 *
 * SDL also offers functions to manipulate the directory tree: renaming,
 * removing, copying files.
 *
 * @{
 */

using PathInfoRaw = SDL_PathInfo;

/**
 * Convenience representation of a path under SDL
 *
 */
struct Path : StringResult
{
  /// Use parent ctors
  using StringResult::StringResult;

  /// Append
  Path& operator+=(std::string_view other)
  {
    StringResult::operator+=(other);
    return *this;
  }

  /// Append
  Path& operator+=(char ch)
  {
    StringResult::operator+=(ch);
    return *this;
  }

  /// Append
  Path operator+(std::string_view other) const
  {
    Path result(*this);
    result += other;
    return result;
  }

  /// Append
  Path operator+(char ch) const
  {
    Path result(*this);
    result += ch;
    return result;
  }

  /// Append path component.
  Path& operator/=(std::string_view other)
  {
    if (!empty() && back() != '/' && back() != '\\') this->operator+=('/');
    return this->operator+=(other);
  }

  /// Append path component.
  Path operator/(std::string_view other) const
  {
    Path result(*this);
    result /= other;
    return result;
  }
};

/**
 * Get the directory where the application was run from.
 *
 * SDL caches the result of this call internally, but the first call to this
 * function is not necessarily fast, so plan accordingly.
 *
 * **macOS and iOS Specific Functionality**: If the application is in a ".app"
 * bundle, this function returns the Resource directory (e.g.
 * MyApp.app/Contents/Resources/). This behaviour can be overridden by adding
 * a property to the Info.plist file. Adding a string key with the name
 * SDL_FILESYSTEM_BASE_DIR_TYPE with a supported value will change the
 * behaviour.
 *
 * Supported values for the SDL_FILESYSTEM_BASE_DIR_TYPE property (Given an
 * application in /Applications/SDLApp/MyApp.app):
 *
 * - `resource`: bundle resource directory (the default). For example:
 *   `/Applications/SDLApp/MyApp.app/Contents/Resources`
 * - `bundle`: the Bundle directory. For example:
 *   `/Applications/SDLApp/MyApp.app/`
 * - `parent`: the containing directory of the bundle. For example:
 *   `/Applications/SDLApp/`
 *
 * **Nintendo 3DS Specific Functionality**: This function returns "romfs"
 * directory of the application as it is uncommon to store resources outside
 * the executable. As such it is not a writable directory.
 *
 * The returned path is guaranteed to end with a path separator ('\\' on
 * Windows, '/' on most other platforms).
 *
 * @returns an absolute path in UTF-8 encoding to the application data
 *          directory. nullptr will be returned on error or when the platform
 *          doesn't implement this functionality, call GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetPrefPath
 */
inline const char* GetBasePath() { return SDL_GetBasePath(); }

/**
 * Get the user-and-app-specific path where files can be written.
 *
 * Get the "pref dir". This is meant to be where users can write personal
 * files (preferences and save games, etc) that are specific to your
 * application. This directory is unique per user, per application.
 *
 * This function will decide the appropriate location in the native
 * filesystem, create the directory if necessary, and return a string of the
 * absolute path to the directory in UTF-8 encoding.
 *
 * On Windows, the string might look like:
 *
 * `C:\@Users\@bob\@AppData\@Roaming\@My Company\@My Program Name\\`
 *
 * On Linux, the string might look like:
 *
 * `/home/bob/.local/share/My Program Name/`
 *
 * On macOS, the string might look like:
 *
 * `/Users/bob/Library/Application Support/My Program Name/`
 *
 * You should assume the path returned by this function is the only safe place
 * to write files (and that GetBasePath(), while it might be writable, or
 * even the parent of the returned path, isn't where you should be writing
 * things).
 *
 * Both the org and app strings may become part of a directory name, so please
 * follow these rules:
 *
 * - Try to use the same org string (_including case-sensitivity_) for all
 *   your applications that use this function.
 * - Always use a unique app string for each one, and make sure it never
 *   changes for an app once you've decided on it.
 * - Unicode characters are legal, as long as they are UTF-8 encoded, but...
 * - ...only use letters, numbers, and spaces. Avoid punctuation like "Game
 *   Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.
 *
 * The returned path is guaranteed to end with a path separator ('\\' on
 * Windows, '/' on most other platforms).
 *
 * @param org the name of your organization.
 * @param app the name of your application.
 * @returns a UTF-8 string of the user directory in platform-dependent
 *          notation. nullptr if there's a problem (creating directory failed,
 *          etc.). This should be freed with free() when it is no longer
 *          needed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetBasePath
 */
inline Path GetPrefPath(StringParam org, StringParam app)
{
  return Path{SDL_GetPrefPath(org, app)};
}

/**
 * The type of the OS-provided default folder for a specific purpose.
 *
 * Note that the Trash folder isn't included here, because trashing files
 * usually involves extra OS-specific functionality to remember the file's
 * original location.
 *
 * The folders supported per platform are:
 *
 *             | Windows | macOS/iOS | tvOS | Unix (XDG) | Haiku | Emscripten
 * ----------- | ------- | --------- | ---- | ---------- | ----- | ----------
 * HOME        | X       | X         |      | X          | X     | X
 * DESKTOP     | X       | X         |      | X          | X     |
 * DOCUMENTS   | X       | X         |      | X          |       |
 * DOWNLOADS   | Vista+  | X         |      | X          |       |
 * MUSIC       | X       | X         |      | X          |       |
 * PICTURES    | X       | X         |      | X          |       |
 * PUBLICSHARE |         | X         |      | X          |       |
 * SAVEDGAMES  | Vista+  |           |      |            |       |
 * SCREENSHOTS | Vista+  |           |      |            |       |
 * TEMPLATES   | X       | X         |      | X          |       |
 * VIDEOS      | X       | X*        |      | X          |       |
 *
 * Note that on macOS/iOS, the Videos folder is called "Movies".
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa GetUserFolder
 */
using Folder = SDL_Folder;

/**
 * The folder which contains all of the current user's data, preferences, and
 * documents.  It usually contains most of the other folders. If a requested
 * folder does not exist, the home folder can be considered a safe fallback to
 * store a user's documents.
 */
constexpr Folder FOLDER_HOME = SDL_FOLDER_HOME;

/**
 * The folder of files that are displayed on the desktop.  Note that the
 * existence of a desktop folder does not guarantee that the system does show
 * icons on its desktop; certain GNU/Linux distros with a graphical environment
 * may not have desktop icons.
 */
constexpr Folder FOLDER_DESKTOP = SDL_FOLDER_DESKTOP;

/**
 * User document files, possibly application-specific.  This is a good place to
 * save a user's projects.
 */
constexpr Folder FOLDER_DOCUMENTS = SDL_FOLDER_DOCUMENTS;

/// Standard folder for user files downloaded from the internet.
constexpr Folder FOLDER_DOWNLOADS = SDL_FOLDER_DOWNLOADS;

/**
 * Music files that can be played using a standard music player (mp3, ogg...).
 */
constexpr Folder FOLDER_MUSIC = SDL_FOLDER_MUSIC;

/// Image files that can be displayed using a standard viewer (png, jpg...).
constexpr Folder FOLDER_PICTURES = SDL_FOLDER_PICTURES;

/// Files that are meant to be shared with other users on the same computer.
constexpr Folder FOLDER_PUBLICSHARE = SDL_FOLDER_PUBLICSHARE;

constexpr Folder FOLDER_SAVEDGAMES =
  SDL_FOLDER_SAVEDGAMES; ///< Save files for games.

constexpr Folder FOLDER_SCREENSHOTS =
  SDL_FOLDER_SCREENSHOTS; ///< Application screenshots.

/**
 * Template files to be used when the user requests the desktop environment to
 * create a new file in a certain folder, such as "New Text File.txt".  Any file
 * in the Templates folder can be used as a starting point for a new file.
 */
constexpr Folder FOLDER_TEMPLATES = SDL_FOLDER_TEMPLATES;

/**
 * Video files that can be played using a standard video player (mp4, webm...).
 */
constexpr Folder FOLDER_VIDEOS = SDL_FOLDER_VIDEOS;

/// Total number of types in this enum, not a folder type by itself.
constexpr Folder FOLDER_COUNT = SDL_FOLDER_COUNT;

/**
 * Finds the most suitable user folder for a specific purpose.
 *
 * Many OSes provide certain standard folders for certain purposes, such as
 * storing pictures, music or videos for a certain user. This function gives
 * the path for many of those special locations.
 *
 * This function is specifically for _user_ folders, which are meant for the
 * user to access and manage. For application-specific folders, meant to hold
 * data for the application to manage, see GetBasePath() and
 * GetPrefPath().
 *
 * The returned path is guaranteed to end with a path separator ('\\' on
 * Windows, '/' on most other platforms).
 *
 * If nullptr is returned, the error may be obtained with GetError().
 *
 * @param folder the type of folder to find.
 * @returns either a null-terminated C string containing the full path to the
 *          folder, or nullptr if an error happened.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline const char* GetUserFolder(Folder folder)
{
  return SDL_GetUserFolder(folder);
}

/**
 * Types of filesystem entries.
 *
 * Note that there may be other sorts of items on a filesystem: devices,
 * symlinks, named pipes, etc. They are currently reported as
 * PATHTYPE_OTHER.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa PathInfo
 */
using PathType = SDL_PathType;

constexpr PathType PATHTYPE_NONE = SDL_PATHTYPE_NONE; ///< path does not exist

constexpr PathType PATHTYPE_FILE = SDL_PATHTYPE_FILE; ///< a normal file

constexpr PathType PATHTYPE_DIRECTORY = SDL_PATHTYPE_DIRECTORY; ///< a directory

/**
 * something completely different like a device node (not a symlink, those are
 * always followed)
 */
constexpr PathType PATHTYPE_OTHER = SDL_PATHTYPE_OTHER;

/**
 * Information about a path on the filesystem.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa GetPathInfo
 * @sa Storage.GetPathInfo
 */
struct PathInfo : PathInfoRaw
{
  /**
   * Wraps PathInfo.
   *
   * @param pathInfo the value to be wrapped
   */
  constexpr PathInfo(const PathInfoRaw& pathInfo = {})
    : PathInfoRaw(pathInfo)
  {
  }

  /**
   * Compare with nullptr.
   *
   * @returns True if invalid state, false otherwise.
   */
  constexpr bool operator==(std::nullptr_t _) const { return !bool(*this); }

  /**
   * Check if valid.
   *
   * @returns True if valid state, false otherwise.
   */
  constexpr explicit operator bool() const { return type != PATHTYPE_NONE; }
};

/**
 * Flags for path matching.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa GlobDirectory
 * @sa Storage.GlobDirectory
 */
using GlobFlags = Uint32;

constexpr GlobFlags GLOB_CASEINSENSITIVE =
  SDL_GLOB_CASEINSENSITIVE; ///< CASEINSENSITIVE

/**
 * Create a directory, and any missing parent directories.
 *
 * This reports success if `path` already exists as a directory.
 *
 * If parent directories are missing, it will also create them. Note that if
 * this fails, it will not remove any parent directories it already made.
 *
 * @param path the path of the directory to create.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void CreateDirectory(StringParam path)
{
  CheckError(SDL_CreateDirectory(path));
}

/**
 * Possible results from an enumeration callback.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa EnumerateDirectoryCallback
 */
using EnumerationResult = SDL_EnumerationResult;

constexpr EnumerationResult ENUM_CONTINUE =
  SDL_ENUM_CONTINUE; ///< Value that requests that enumeration continue.

/// Value that requests that enumeration stop, successfully.
constexpr EnumerationResult ENUM_SUCCESS = SDL_ENUM_SUCCESS;

/// Value that requests that enumeration stop, as a failure.
constexpr EnumerationResult ENUM_FAILURE = SDL_ENUM_FAILURE;

/**
 * Callback for directory enumeration.
 *
 * Enumeration of directory entries will continue until either all entries
 * have been provided to the callback, or the callback has requested a stop
 * through its return value.
 *
 * Returning ENUM_CONTINUE will let enumeration proceed, calling the
 * callback with further entries. ENUM_SUCCESS and ENUM_FAILURE will
 * terminate the enumeration early, and dictate the return value of the
 * enumeration function itself.
 *
 * `dirname` is guaranteed to end with a path separator ('\\' on Windows, '/'
 * on most other platforms).
 *
 * @param userdata an app-controlled pointer that is passed to the callback.
 * @param dirname the directory that is being enumerated.
 * @param fname the next entry in the enumeration.
 * @returns how the enumeration should proceed.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa EnumerateDirectory
 */
using EnumerateDirectoryCallback = SDL_EnumerateDirectoryCallback;

/**
 * Callback for directory enumeration.
 *
 * Enumeration of directory entries will continue until either all entries
 * have been provided to the callback, or the callback has requested a stop
 * through its return value.
 *
 * Returning ENUM_CONTINUE will let enumeration proceed, calling the
 * callback with further entries. ENUM_SUCCESS and ENUM_FAILURE will
 * terminate the enumeration early, and dictate the return value of the
 * enumeration function itself.
 *
 * `dirname` is guaranteed to end with a path separator ('\\' on Windows, '/'
 * on most other platforms).
 *
 * @param dirname the directory that is being enumerated.
 * @param fname the next entry in the enumeration.
 * @returns how the enumeration should proceed.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa EnumerateDirectory
 * @sa EnumerateDirectoryCallback
 */
using EnumerateDirectoryCB =
  std::function<EnumerationResult(const char* dirname, const char* fname)>;

/**
 * Enumerate a directory through a callback function.
 *
 * This function provides every directory entry through an app-provided
 * callback, called once for each directory entry, until all results have been
 * provided or the callback returns either ENUM_SUCCESS or
 * ENUM_FAILURE.
 *
 * This will return false if there was a system problem in general, or if a
 * callback returns ENUM_FAILURE. A successful return means a callback
 * returned ENUM_SUCCESS to halt enumeration, or all directory entries
 * were enumerated.
 *
 * @param path the path of the directory to enumerate.
 * @param callback a function that is called for each entry in the directory.
 * @param userdata a pointer that is passed to `callback`.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void EnumerateDirectory(StringParam path,
                               EnumerateDirectoryCallback callback,
                               void* userdata)
{
  CheckError(SDL_EnumerateDirectory(path, callback, userdata));
}

/**
 * Enumerate a directory through a callback function.
 *
 * This function provides every directory entry through an app-provided
 * callback, called once for each directory entry, until all results have been
 * provided or the callback returns either ENUM_SUCCESS or
 * ENUM_FAILURE.
 *
 * This will return false if there was a system problem in general, or if a
 * callback returns ENUM_FAILURE. A successful return means a callback
 * returned ENUM_SUCCESS to halt enumeration, or all directory entries
 * were enumerated.
 *
 * @param path the path of the directory to enumerate.
 * @param callback a function that is called for each entry in the directory.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void EnumerateDirectory(StringParam path, EnumerateDirectoryCB callback)
{
  return EnumerateDirectory(
    std::move(path),
    [](void* userdata, const char* dirname, const char* fname) {
      auto& cb = *static_cast<EnumerateDirectoryCB*>(userdata);
      return cb(dirname, fname);
    },
    &callback);
}

/**
 * Enumerate a directory.
 *
 * @param path the path of the directory to enumerate.
 * @returns all the directory contents.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline std::vector<Path> EnumerateDirectory(StringParam path)
{
  std::vector<Path> r;
  EnumerateDirectory(std::move(path), [&](const char*, const char* fname) {
    r.emplace_back(fname);
    return ENUM_CONTINUE;
  });
  return r;
}

/**
 * Remove a file or an empty directory.
 *
 * Directories that are not empty will fail; this function will not recursively
 * delete directory trees.
 *
 * @param path the path to remove from the filesystem.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void RemovePath(StringParam path) { CheckError(SDL_RemovePath(path)); }

/**
 * Rename a file or directory.
 *
 * If the file at `newpath` already exists, it will replaced.
 *
 * Note that this will not copy files across filesystems/drives/volumes, as
 * that is a much more complicated (and possibly time-consuming) operation.
 *
 * Which is to say, if this function fails, CopyFile() to a temporary file
 * in the same directory as `newpath`, then RenamePath() from the
 * temporary file to `newpath` and RemovePath() on `oldpath` might work
 * for files. Renaming a non-empty directory across filesystems is
 * dramatically more complex, however.
 *
 * @param oldpath the old path.
 * @param newpath the new path.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void RenamePath(StringParam oldpath, StringParam newpath)
{
  CheckError(SDL_RenamePath(oldpath, newpath));
}

/**
 * Copy a file.
 *
 * If the file at `newpath` already exists, it will be overwritten with the
 * contents of the file at `oldpath`.
 *
 * This function will block until the copy is complete, which might be a
 * significant time for large files on slow disks. On some platforms, the copy
 * can be handed off to the OS itself, but on others SDL might just open both
 * paths, and read from one and write to the other.
 *
 * Note that this is not an atomic operation! If something tries to read from
 * `newpath` while the copy is in progress, it will see an incomplete copy of
 * the data, and if the calling thread terminates (or the power goes out)
 * during the copy, `newpath`'s previous contents will be gone, replaced with
 * an incomplete copy of the data. To avoid this risk, it is recommended that
 * the app copy to a temporary file in the same directory as `newpath`, and if
 * the copy is successful, use RenamePath() to replace `newpath` with the
 * temporary file. This will ensure that reads of `newpath` will either see a
 * complete copy of the data, or it will see the pre-copy state of `newpath`.
 *
 * This function attempts to synchronize the newly-copied data to disk before
 * returning, if the platform allows it, so that the renaming trick will not
 * have a problem in a system crash or power failure, where the file could be
 * renamed but the contents never made it from the system file cache to the
 * physical disk.
 *
 * If the copy fails for any reason, the state of `newpath` is undefined. It
 * might be half a copy, it might be the untouched data of what was already
 * there, or it might be a zero-byte file, etc.
 *
 * @param oldpath the old path.
 * @param newpath the new path.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void CopyFile(StringParam oldpath, StringParam newpath)
{
  CheckError(SDL_CopyFile(oldpath, newpath));
}

/**
 * Get information about a filesystem path.
 *
 * @param path the path to query.
 * @returns the information about the path on success.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline PathInfo GetPathInfo(StringParam path)
{
  PathInfo info;
  CheckError(SDL_GetPathInfo(path, &info));
  return info;
}

/**
 * Enumerate a directory tree, filtered by pattern, and return a list.
 *
 * Files are filtered out if they don't match the string in `pattern`, which
 * may contain wildcard characters '\*' (match everything) and '?' (match one
 * character). If pattern is nullptr, no filtering is done and all results are
 * returned. Subdirectories are permitted, and are specified with a path
 * separator of '/'. Wildcard characters '\*' and '?' never match a path
 * separator.
 *
 * `flags` may be set to GLOB_CASEINSENSITIVE to make the pattern matching
 * case-insensitive.
 *
 * The returned array is always nullptr-terminated, for your iterating
 * convenience, but if `count` is non-nullptr, on return it will contain the
 * number of items in the array, not counting the nullptr terminator.
 *
 * @param path the path of the directory to enumerate.
 * @param pattern the pattern that files in the directory must match. Can be
 *                nullptr.
 * @param flags `SDL_GLOB_*` bitflags that affect this search.
 * @returns an array of strings on success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline OwnArray<char*> GlobDirectory(StringParam path,
                                     StringParam pattern,
                                     GlobFlags flags = 0)
{
  int count;
  auto data = CheckError(SDL_GlobDirectory(path, pattern, flags, &count));
  return OwnArray<char*>{data, size_t(count)};
}

/**
 * Get what the system believes is the "current working directory."
 *
 * For systems without a concept of a current working directory, this will
 * still attempt to provide something reasonable.
 *
 * SDL does not provide a means to _change_ the current working directory; for
 * platforms without this concept, this would cause surprises with file access
 * outside of SDL.
 *
 * The returned path is guaranteed to end with a path separator ('\\' on
 * Windows, '/' on most other platforms).
 *
 * @returns a UTF-8 string of the current working directory in
 *          platform-dependent notation. nullptr if there's a problem. This
 *          should be freed with free() when it is no longer needed.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Path GetCurrentDirectory() { return Path{SDL_GetCurrentDirectory()}; }

/// @}

/**
 * @defgroup CategoryInit Initialization and Shutdown
 *
 * All SDL programs need to initialize the library before starting to work
 * with it.
 *
 * Almost everything can simply call Init() near startup, with a handful
 * of flags to specify subsystems to touch. These are here to make sure SDL
 * does not even attempt to touch low-level pieces of the operating system
 * that you don't intend to use. For example, you might be using SDL for video
 * and input but chose an external library for audio, and in this case you
 * would just need to leave off the `INIT_AUDIO` flag to make sure that
 * external library has complete control.
 *
 * Most apps, when terminating, should call Quit(). This will clean up
 * (nearly) everything that SDL might have allocated, and crucially, it'll
 * make sure that the display's resolution is back to what the user expects if
 * you had previously changed it for your game.
 *
 * SDL3 apps are strongly encouraged to call SetAppMetadata() at startup
 * to fill in details about the program. This is completely optional, but it
 * helps in small ways (we can provide an About dialog box for the macOS menu,
 * we can name the app in the system's audio mixer, etc). Those that want to
 * provide a _lot_ of information should look at the more-detailed
 * SetAppMetadataProperty().
 *
 * @{
 */

/**
 * @defgroup InitFlags Initialization flags
 *
 * @{
 */

/**
 * Initialization flags for Init and/or InitSubSystem
 *
 * These are the flags which may be passed to Init(). You should specify
 * the subsystems which you will be using in your application.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa Init
 * @sa Quit
 * @sa InitSubSystem
 * @sa QuitSubSystem
 * @sa WasInit
 */
using InitFlags = Uint32;

constexpr InitFlags INIT_AUDIO =
  SDL_INIT_AUDIO; ///< `INIT_AUDIO` implies `INIT_EVENTS`

/**
 * `INIT_VIDEO` implies `INIT_EVENTS`, should be initialized on the main thread
 */
constexpr InitFlags INIT_VIDEO = SDL_INIT_VIDEO;

constexpr InitFlags INIT_JOYSTICK =
  SDL_INIT_JOYSTICK; ///< `INIT_JOYSTICK` implies `INIT_EVENTS`

constexpr InitFlags INIT_HAPTIC = SDL_INIT_HAPTIC; ///< HAPTIC

constexpr InitFlags INIT_GAMEPAD =
  SDL_INIT_GAMEPAD; ///< `INIT_GAMEPAD` implies `INIT_JOYSTICK`

constexpr InitFlags INIT_EVENTS = SDL_INIT_EVENTS; ///< EVENTS

constexpr InitFlags INIT_SENSOR =
  SDL_INIT_SENSOR; ///< `INIT_SENSOR` implies `INIT_EVENTS`

constexpr InitFlags INIT_CAMERA =
  SDL_INIT_CAMERA; ///< `INIT_CAMERA` implies `INIT_EVENTS`

/// @}

/**
 * @name AppResult
 * App result for Main callback
 * @{
 */

/**
 * Return values for optional main callbacks.
 *
 * Returning APP_SUCCESS or APP_FAILURE from SDL_AppInit,
 * SDL_AppEvent, or SDL_AppIterate will terminate the program and report
 * success/failure to the operating system. What that means is
 * platform-dependent. On Unix, for example, on success, the process error
 * code will be zero, and on failure it will be 1. This interface doesn't
 * allow you to return specific exit codes, just whether there was an error
 * generally or not.
 *
 * Returning APP_CONTINUE from these functions will let the app continue
 * to run.
 *
 * See
 * [Main callbacks in
 * SDL3](https://wiki.libsdl.org/SDL3/README/main-functions#main-callbacks-in-sdl3)
 * for complete details.
 *
 * @since This enum is available since SDL 3.2.0.
 */
using AppResult = SDL_AppResult;

/// Value that requests that the app continue from the main callbacks.
constexpr AppResult APP_CONTINUE = SDL_APP_CONTINUE;

/// Value that requests termination with success from the main callbacks.
constexpr AppResult APP_SUCCESS = SDL_APP_SUCCESS;

/// Value that requests termination with error from the main callbacks.
constexpr AppResult APP_FAILURE = SDL_APP_FAILURE;

/// @}

/**
 * @name Callbacks for EnterAppMainCallbacks()
 *
 * @{
 */

/**
 * Function pointer typedef for SDL_AppInit.
 *
 * These are used by EnterAppMainCallbacks. This mechanism operates behind
 * the scenes for apps using the optional main callbacks. Apps that want to
 * use this should just implement SDL_AppInit directly.
 *
 * @param appstate a place where the app can optionally store a pointer for
 *                 future use.
 * @param argc the standard ANSI C main's argc; number of elements in `argv`.
 * @param argv the standard ANSI C main's argv; array of command line
 *             arguments.
 * @returns APP_FAILURE to terminate with an error, APP_SUCCESS to
 *          terminate with success, APP_CONTINUE to continue.
 *
 * @since This datatype is available since SDL 3.2.0.
 */
using AppInit_func = SDL_AppInit_func;

/**
 * Function pointer typedef for SDL_AppIterate.
 *
 * These are used by EnterAppMainCallbacks. This mechanism operates behind
 * the scenes for apps using the optional main callbacks. Apps that want to
 * use this should just implement SDL_AppIterate directly.
 *
 * @param appstate an optional pointer, provided by the app in SDL_AppInit.
 * @returns APP_FAILURE to terminate with an error, APP_SUCCESS to
 *          terminate with success, APP_CONTINUE to continue.
 *
 * @since This datatype is available since SDL 3.2.0.
 */
using AppIterate_func = SDL_AppIterate_func;

/**
 * Function pointer typedef for SDL_AppEvent.
 *
 * These are used by EnterAppMainCallbacks. This mechanism operates behind
 * the scenes for apps using the optional main callbacks. Apps that want to
 * use this should just implement SDL_AppEvent directly.
 *
 * @param appstate an optional pointer, provided by the app in SDL_AppInit.
 * @param event the new event for the app to examine.
 * @returns APP_FAILURE to terminate with an error, APP_SUCCESS to
 *          terminate with success, APP_CONTINUE to continue.
 *
 * @since This datatype is available since SDL 3.2.0.
 */
using AppEvent_func = SDL_AppEvent_func;

/**
 * Function pointer typedef for SDL_AppQuit.
 *
 * These are used by EnterAppMainCallbacks. This mechanism operates behind
 * the scenes for apps using the optional main callbacks. Apps that want to
 * use this should just implement SDL_AppEvent directly.
 *
 * @param appstate an optional pointer, provided by the app in SDL_AppInit.
 * @param result the result code that terminated the app (success or failure).
 *
 * @since This datatype is available since SDL 3.2.0.
 */
using AppQuit_func = SDL_AppQuit_func;

/// @}

/**
 * Initialize the SDL library.
 *
 * Init() simply forwards to calling InitSubSystem(). Therefore, the
 * two may be used interchangeably. Though for readability of your code
 * InitSubSystem() might be preferred.
 *
 * The file I/O (for example: IOStream.FromFile) and threading
 * (SDL_CreateThread) subsystems are initialized by default. Message boxes
 * (SDL_ShowSimpleMessageBox) also attempt to work without initializing the
 * video subsystem, in hopes of being useful in showing an error dialog when
 * Init fails. You must specifically initialize other subsystems if you
 * use them in your application.
 *
 * Logging (such as Log) works without initialization, too.
 *
 * `flags` may be any of the following OR'd together:
 *
 * - `INIT_AUDIO`: audio subsystem; automatically initializes the events
 *   subsystem
 * - `INIT_VIDEO`: video subsystem; automatically initializes the events
 *   subsystem, should be initialized on the main thread.
 * - `INIT_JOYSTICK`: joystick subsystem; automatically initializes the
 *   events subsystem
 * - `INIT_HAPTIC`: haptic (force feedback) subsystem
 * - `INIT_GAMEPAD`: gamepad subsystem; automatically initializes the
 *   joystick subsystem
 * - `INIT_EVENTS`: events subsystem
 * - `INIT_SENSOR`: sensor subsystem; automatically initializes the events
 *   subsystem
 * - `INIT_CAMERA`: camera subsystem; automatically initializes the events
 *   subsystem
 *
 * Subsystem initialization is ref-counted, you must call QuitSubSystem()
 * for each InitSubSystem() to correctly shutdown a subsystem manually (or
 * call Quit() to force shutdown). If a subsystem is already loaded then
 * this call will increase the ref-count and return.
 *
 * Consider reporting some basic metadata about your application before
 * calling Init, using either SetAppMetadata() or
 * SetAppMetadataProperty().
 *
 * @param flags subsystem initialization flags.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SetAppMetadata
 * @sa SetAppMetadataProperty
 * @sa InitSubSystem
 * @sa Quit
 * @sa SetMainReady
 * @sa WasInit
 */
inline void Init(InitFlags flags) { CheckError(SDL_Init(flags)); }

/**
 * Compatibility function to initialize the SDL library.
 *
 * This function and Init() are interchangeable.
 *
 * @param flags any of the flags used by Init(); see Init for details.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Init
 * @sa Quit
 * @sa QuitSubSystem
 */
inline void InitSubSystem(InitFlags flags)
{
  CheckError(SDL_InitSubSystem(flags));
}

/**
 * Shut down specific SDL subsystems.
 *
 * You still need to call Quit() even if you close all open subsystems
 * with QuitSubSystem().
 *
 * @param flags any of the flags used by Init(); see Init for details.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa InitSubSystem
 * @sa Quit
 */
inline void QuitSubSystem(InitFlags flags) { SDL_QuitSubSystem(flags); }

/**
 * Get a mask of the specified subsystems which are currently initialized.
 *
 * @param flags any of the flags used by Init(); see Init for details.
 * @returns a mask of all initialized subsystems if `flags` is 0, otherwise it
 *          returns the initialization status of the specified subsystems.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Init
 * @sa InitSubSystem
 */
inline InitFlags WasInit(InitFlags flags) { return SDL_WasInit(flags); }

/**
 * Clean up all initialized subsystems.
 *
 * You should call this function even if you have already shutdown each
 * initialized subsystem with QuitSubSystem(). It is safe to call this
 * function even in the case of errors in initialization.
 *
 * You can use this function with atexit() to ensure that it is run when your
 * application is shutdown, but it is not wise to do this from a library or
 * other dynamically loaded code.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Init
 * @sa QuitSubSystem
 */
inline void Quit() { SDL_Quit(); }

/**
 * Return whether this is the main thread.
 *
 * On Apple platforms, the main thread is the thread that runs your program's
 * main() entry point. On other platforms, the main thread is the one that
 * calls Init(INIT_VIDEO), which should usually be the one that runs
 * your program's main() entry point. If you are using the main callbacks,
 * SDL_AppInit(), SDL_AppIterate(), and SDL_AppQuit() are all called on the
 * main thread.
 *
 * @returns true if this thread is the main thread, or false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa RunOnMainThread
 */
inline bool IsMainThread() { return SDL_IsMainThread(); }

/**
 * @name Callbacks for RunOnMainThread()
 * @{
 */

/**
 * Callback run on the main thread.
 *
 * @param userdata an app-controlled pointer that is passed to the callback.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa RunOnMainThread
 */
using MainThreadCallback = SDL_MainThreadCallback;

/**
 * Callback run on the main thread.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa RunOnMainThread
 * @sa MainThreadCallback
 *
 * @cat result-callback
 *
 */
using MainThreadCB = std::function<void()>;

/// @}

/**
 * Call a function on the main thread during event processing.
 *
 * If this is called on the main thread, the callback is executed immediately.
 * If this is called on another thread, this callback is queued for execution
 * on the main thread during event processing.
 *
 * Be careful of deadlocks when using this functionality. You should not have
 * the main thread wait for the current thread while this function is being
 * called with `wait_complete` true.
 *
 * @param callback the callback to call on the main thread.
 * @param userdata a pointer that is passed to `callback`.
 * @param wait_complete true to wait for the callback to complete, false to
 *                      return immediately.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa IsMainThread
 */
inline void RunOnMainThread(MainThreadCallback callback,
                            void* userdata,
                            bool wait_complete)
{
  CheckError(SDL_RunOnMainThread(callback, userdata, wait_complete));
}

/**
 * Call a function on the main thread during event processing.
 *
 * If this is called on the main thread, the callback is executed immediately.
 * If this is called on another thread, this callback is queued for execution
 * on the main thread during event processing.
 *
 * Be careful of deadlocks when using this functionality. You should not have
 * the main thread wait for the current thread while this function is being
 * called with `wait_complete` true.
 *
 * @param callback the callback to call on the main thread.
 * @param wait_complete true to wait for the callback to complete, false to
 *                      return immediately.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa IsMainThread
 * @sa result-callback
 *
 * @cat result-callback
 */
inline void RunOnMainThread(MainThreadCB callback, bool wait_complete)
{
  using Wrapper = CallbackWrapper<MainThreadCB>;
  void* wrapped = Wrapper::Wrap(std::move(callback));
  RunOnMainThread(&Wrapper::CallOnce, wrapped, wait_complete);
}

/**
 * Specify basic metadata about your app.
 *
 * You can optionally provide metadata about your app to SDL. This is not
 * required, but strongly encouraged.
 *
 * There are several locations where SDL can make use of metadata (an "About"
 * box in the macOS menu bar, the name of the app can be shown on some audio
 * mixers, etc). Any piece of metadata can be left as nullptr, if a specific
 * detail doesn't make sense for the app.
 *
 * This function should be called as early as possible, before Init.
 * Multiple calls to this function are allowed, but various state might not
 * change once it has been set up with a previous call to this function.
 *
 * Passing a nullptr removes any previous metadata.
 *
 * This is a simplified interface for the most important information. You can
 * supply significantly more detailed metadata with
 * SetAppMetadataProperty().
 *
 * @param appname The name of the application ("My Game 2: Bad Guy's
 *                Revenge!").
 * @param appversion The version of the application ("1.0.0beta5" or a git
 *                   hash, or whatever makes sense).
 * @param appidentifier A unique string in reverse-domain format that
 *                      identifies this app ("com.example.mygame2").
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SetAppMetadataProperty
 */
inline void SetAppMetadata(StringParam appname,
                           StringParam appversion,
                           StringParam appidentifier)
{
  CheckError(SDL_SetAppMetadata(appname, appversion, appidentifier));
}

/**
 * Specify metadata about your app through a set of properties.
 *
 * You can optionally provide metadata about your app to SDL. This is not
 * required, but strongly encouraged.
 *
 * There are several locations where SDL can make use of metadata (an "About"
 * box in the macOS menu bar, the name of the app can be shown on some audio
 * mixers, etc). Any piece of metadata can be left out, if a specific detail
 * doesn't make sense for the app.
 *
 * This function should be called as early as possible, before Init.
 * Multiple calls to this function are allowed, but various state might not
 * change once it has been set up with a previous call to this function.
 *
 * Once set, this metadata can be read using GetAppMetadataProperty().
 *
 * These are the supported properties:
 *
 * - `prop::appMetaData.NAME_STRING`: The human-readable name of the
 *   application, like "My Game 2: Bad Guy's Revenge!". This will show up
 *   anywhere the OS shows the name of the application separately from window
 *   titles, such as volume control applets, etc. This defaults to "SDL
 *   Application".
 * - `prop::appMetaData.VERSION_STRING`: The version of the app that is
 *   running; there are no rules on format, so "1.0.3beta2" and "April 22nd,
 *   2024" and a git hash are all valid options. This has no default.
 * - `prop::appMetaData.IDENTIFIER_STRING`: A unique string that
 *   identifies this app. This must be in reverse-domain format, like
 *   "com.example.mygame2". This string is used by desktop compositors to
 *   identify and group windows together, as well as match applications with
 *   associated desktop settings and icons. If you plan to package your
 *   application in a container such as Flatpak, the app ID should match the
 *   name of your Flatpak container as well. This has no default.
 * - `prop::appMetaData.CREATOR_STRING`: The human-readable name of the
 *   creator/developer/maker of this app, like "MojoWorkshop, LLC"
 * - `prop::appMetaData.COPYRIGHT_STRING`: The human-readable copyright
 *   notice, like "Copyright (c) 2024 MojoWorkshop, LLC" or whatnot. Keep this
 *   to one line, don't paste a copy of a whole software license in here. This
 *   has no default.
 * - `prop::appMetaData.URL_STRING`: A URL to the app on the web. Maybe a
 *   product page, or a storefront, or even a GitHub repository, for user's
 *   further information This has no default.
 * - `prop::appMetaData.TYPE_STRING`: The type of application this is.
 *   Currently this string can be "game" for a video game, "mediaplayer" for a
 *   media player, or generically "application" if nothing else applies.
 *   Future versions of SDL might add new types. This defaults to
 *   "application".
 *
 * @param name the name of the metadata property to set.
 * @param value the value of the property, or nullptr to remove that property.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetAppMetadataProperty
 * @sa SetAppMetadata
 */
inline void SetAppMetadataProperty(StringParam name, StringParam value)
{
  CheckError(SDL_SetAppMetadataProperty(name, value));
}

namespace prop::appMetaData {

constexpr auto NAME_STRING = SDL_PROP_APP_METADATA_NAME_STRING;

constexpr auto VERSION_STRING = SDL_PROP_APP_METADATA_VERSION_STRING;

constexpr auto IDENTIFIER_STRING = SDL_PROP_APP_METADATA_IDENTIFIER_STRING;

constexpr auto CREATOR_STRING = SDL_PROP_APP_METADATA_CREATOR_STRING;

constexpr auto COPYRIGHT_STRING = SDL_PROP_APP_METADATA_COPYRIGHT_STRING;

constexpr auto URL_STRING = SDL_PROP_APP_METADATA_URL_STRING;

constexpr auto TYPE_STRING = SDL_PROP_APP_METADATA_TYPE_STRING;

} // namespace prop::appMetaData

/**
 * Get metadata about your app.
 *
 * This returns metadata previously set using SetAppMetadata() or
 * SetAppMetadataProperty(). See SetAppMetadataProperty() for the list
 * of available properties and their meanings.
 *
 * @param name the name of the metadata property to get.
 * @returns the current value of the metadata property, or the default if it
 *          is not set, nullptr for properties with no default.
 *
 * @threadsafety It is safe to call this function from any thread, although
 *               the string returned is not protected and could potentially be
 *               freed if you call SetAppMetadataProperty() to set that
 *               property from another thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SetAppMetadata
 * @sa SetAppMetadataProperty
 */
inline const char* GetAppMetadataProperty(StringParam name)
{
  return SDL_GetAppMetadataProperty(name);
}

#ifndef SDL3PP_APPCLASS_LOG_PRIORITY
/**
 * The default log priority for app class.
 */
#define SDL3PP_APPCLASS_LOG_PRIORITY LOG_PRIORITY_CRITICAL
#endif // SDL3PP_APPCLASS_LOG_PRIORITY

/**
 * Represents application parameters
 */
using AppArgs = std::span<char const* const>;

/**
 * @{
 *
 * Allocate and initialize state with new.
 *
 * If possible, pass the args to constructor, otherwise expects a default ctor;
 *
 * @tparam T the state class
 * @param state the state to initialize
 * @param args the program arguments
 * @return the app status
 */
template<class T>
inline AppResult DefaultCreateClass(T** state, AppArgs args)
{
  static_assert(std::is_default_constructible_v<T>);
  *state = new T{};
  return APP_CONTINUE;
}

template<class T>
  requires std::convertible_to<AppArgs, T>
inline AppResult DefaultCreateClass(T** state, AppArgs args)
{
  *state = new T{args};
  return APP_CONTINUE;
}
/// @}

/// @private
template<class T>
concept HasInitFunction = requires(T** state) {
  { T::Init(state, AppArgs{}) } -> std::convertible_to<AppResult>;
};

/**
 * @{
 *
 * Init state with arguments.
 *
 * This will call T::Init() if available, otherwise it delegates to
 * DefaultCreateClass().
 *
 * @tparam T the state class
 * @param state the state to initialize
 * @param args the program arguments
 * @return the app status
 */
template<class T>
inline AppResult InitClass(T** state, AppArgs args)
{
  try {
    return DefaultCreateClass(state, args);
  } catch (std::exception& e) {
    LOG_CATEGORY_APPLICATION.LogUnformatted(SDL3PP_APPCLASS_LOG_PRIORITY,
                                            e.what());
  } catch (...) {
  }
  return APP_FAILURE;
}

template<HasInitFunction T>
inline AppResult InitClass(T** state, AppArgs args)
{
  *state = nullptr;
  try {
    AppResult result = T::Init(state, args);
    if (*state == nullptr && result != APP_FAILURE) return APP_SUCCESS;
    return result;
  } catch (std::exception& e) {
    LOG_CATEGORY_APPLICATION.LogUnformatted(SDL3PP_APPCLASS_LOG_PRIORITY,
                                            e.what());
  } catch (...) {
  }
  return APP_FAILURE;
}
/// @}

/// @private
template<class T>
concept HasIterateFunction = requires(T* state) { state->Iterate(); };

/**
 * Iterate the state
 *
 * @tparam T the state class
 * @param state the state
 * @return the app status
 */
template<HasIterateFunction T>
inline AppResult IterateClass(T* state)
{
  try {
    return state->Iterate();
  } catch (std::exception& e) {
    LOG_CATEGORY_APPLICATION.LogUnformatted(SDL3PP_APPCLASS_LOG_PRIORITY,
                                            e.what());
  } catch (...) {
  }
  return APP_FAILURE;
}

/// @private
template<class T>
concept HasEventFunction =
  requires(T* state, const SDL_Event& event) { state->Event(event); };

/**
 * Default handle by finishing if QUIT is requested
 *
 * @tparam T the state class
 * @param state the state
 * @param event the event
 * @return APP_SUCCESS if event is QUIT_EVENT, APP_CONTINUE otherwise,
 */
template<class T>
inline AppResult DefaultEventClass(T* state, const SDL_Event& event)
{
  if (event.type == SDL_EVENT_QUIT) return APP_SUCCESS;
  return APP_CONTINUE;
}

/**
 * @{
 * Iterate the state
 *
 * @tparam T the state class
 * @param state the state
 * @param event the event to handle
 * @return the app status
 */
template<class T>
inline AppResult EventClass(T* state, const SDL_Event& event)
{
  try {
    return DefaultEventClass(state, event);
  } catch (std::exception& e) {
    LOG_CATEGORY_APPLICATION.LogUnformatted(SDL3PP_APPCLASS_LOG_PRIORITY,
                                            e.what());
  } catch (...) {
  }
  return APP_FAILURE;
}

template<HasEventFunction T>
inline AppResult EventClass(T* state, const SDL_Event& event)
{
  try {
    return state->Event(event);
  } catch (std::exception& e) {
    LOG_CATEGORY_APPLICATION.LogUnformatted(SDL3PP_APPCLASS_LOG_PRIORITY,
                                            e.what());
  } catch (...) {
  }
  return APP_FAILURE;
}

/// @}

/**
 * Destroy state with delete;
 *
 * @tparam T
 * @param state
 */
template<class T>
inline void DefaultClassDestroy(T* state)
{
  delete state;
}

/// @private
template<class T>
concept HasQuitFunction =
  requires(T* state, AppResult result) { T::Quit(state, result); };

/**
 * @{
 * Destroy state with given result
 *
 * This is responsible to destroy and deallocate the state. It tries to call
 * T::Quit() if available and delegates to it the duty of deleting. Otherwise it
 * calls delete directly.
 *
 * @tparam T the state class.
 * @param state the state to destroy.
 * @param result the app result.
 */
template<class T>
inline void QuitClass(T* state, AppResult result)
{
  DefaultClassDestroy(state);
}

template<HasQuitFunction T>
inline void QuitClass(T* state, AppResult result)
{
  T::Quit(state, result);
}
/// @}

/// @}

/**
 * @defgroup CategoryIOStream I/O Streams
 *
 * SDL provides an abstract interface for reading and writing data streams. It
 * offers implementations for files, memory, etc, and the app can provide
 * their own implementations, too.
 *
 * IOStream is not related to the standard C++ iostream class, other than
 * both are abstract interfaces to read/write data.
 *
 * @{
 */

// Forward decl
struct IOStream;

using IOStreamRaw = SDL_IOStream*;

// Forward decl
struct IOStreamRef;

/// Safely wrap IOStream for non owning parameters
struct IOStreamParam
{
  IOStreamRaw value; ///< parameter's IOStreamRaw

  /// Constructs from IOStreamRaw
  constexpr IOStreamParam(IOStreamRaw value)
    : value(value)
  {
  }

  /// Constructs null/invalid
  constexpr IOStreamParam(std::nullptr_t _ = nullptr)
    : value(nullptr)
  {
  }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!value; }

  /// Comparison
  constexpr auto operator<=>(const IOStreamParam& other) const = default;

  /// Converts to underlying IOStreamRaw
  constexpr operator IOStreamRaw() const { return value; }
};

/**
 * IOStream status, set by a read or write operation.
 *
 * @since This enum is available since SDL 3.2.0.
 */
using IOStatus = SDL_IOStatus;

constexpr IOStatus IO_STATUS_READY =
  SDL_IO_STATUS_READY; ///< Everything is ready (no errors and not EOF).

constexpr IOStatus IO_STATUS_ERROR =
  SDL_IO_STATUS_ERROR; ///< Read or write I/O error.

constexpr IOStatus IO_STATUS_EOF = SDL_IO_STATUS_EOF; ///< End of file.

constexpr IOStatus IO_STATUS_NOT_READY =
  SDL_IO_STATUS_NOT_READY; ///< Non blocking I/O, not ready.

constexpr IOStatus IO_STATUS_READONLY =
  SDL_IO_STATUS_READONLY; ///< Tried to write a read-only buffer.

constexpr IOStatus IO_STATUS_WRITEONLY =
  SDL_IO_STATUS_WRITEONLY; ///< Tried to read a write-only buffer.

/**
 * Possible `whence` values for IOStream seeking.
 *
 * These map to the same "whence" concept that `fseek` or `lseek` use in the
 * standard C runtime.
 *
 * @since This enum is available since SDL 3.2.0.
 */
using IOWhence = SDL_IOWhence;

constexpr IOWhence IO_SEEK_SET =
  SDL_IO_SEEK_SET; ///< Seek from the beginning of data.

constexpr IOWhence IO_SEEK_CUR =
  SDL_IO_SEEK_CUR; ///< Seek relative to current read point.

constexpr IOWhence IO_SEEK_END =
  SDL_IO_SEEK_END; ///< Seek relative to the end of data.

/**
 * The function pointers that drive an IOStream.
 *
 * Applications can provide this struct to IOStream.Open() to create their own
 * implementation of IOStream. This is not necessarily required, as SDL
 * already offers several common types of I/O streams, via functions like
 * IOStream.FromFile() and IOStream.FromMem().
 *
 * This structure should be initialized using SDL_INIT_INTERFACE()
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @sa SDL_INIT_INTERFACE
 */
using IOStreamInterface = SDL_IOStreamInterface;

/**
 * The read/write operation structure.
 *
 * This operates as an opaque handle. There are several APIs to create various
 * types of I/O streams, or an app can supply an IOStreamInterface to
 * IOStream.Open() to provide their own stream implementation behind this
 * struct's abstract interface.
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @cat resource
 */
class IOStream
{
  IOStreamRaw m_resource = nullptr;

public:
  /// Default ctor
  constexpr IOStream() = default;

  /**
   * Constructs from IOStreamParam.
   *
   * @param resource a IOStreamRaw to be wrapped.
   *
   * This assumes the ownership, call release() if you need to take back.
   */
  constexpr explicit IOStream(const IOStreamRaw resource)
    : m_resource(resource)
  {
  }

  /// Copy constructor
  constexpr IOStream(const IOStream& other) = delete;

  /// Move constructor
  constexpr IOStream(IOStream&& other)
    : IOStream(other.release())
  {
  }

  constexpr IOStream(const IOStreamRef& other) = delete;

  constexpr IOStream(IOStreamRef&& other) = delete;

  /**
   * Use this function to create a new IOStream structure for reading from
   * and/or writing to a named file.
   *
   * The `mode` string is treated roughly the same as in a call to the C
   * library's fopen(), even if SDL doesn't happen to use fopen() behind the
   * scenes.
   *
   * Available `mode` strings:
   *
   * - "r": Open a file for reading. The file must exist.
   * - "w": Create an empty file for writing. If a file with the same name
   *   already exists its content is erased and the file is treated as a new
   *   empty file.
   * - "a": Append to a file. Writing operations append data at the end of the
   *   file. The file is created if it does not exist.
   * - "r+": Open a file for update both reading and writing. The file must
   *   exist.
   * - "w+": Create an empty file for both reading and writing. If a file with
   *   the same name already exists its content is erased and the file is
   *   treated as a new empty file.
   * - "a+": Open a file for reading and appending. All writing operations are
   *   performed at the end of the file, protecting the previous content to be
   *   overwritten. You can reposition (fseek, rewind) the internal pointer to
   *   anywhere in the file for reading, but writing operations will move it
   *   back to the end of file. The file is created if it does not exist.
   *
   * **NOTE**: In order to open a file as a binary file, a "b" character has to
   * be included in the `mode` string. This additional "b" character can either
   * be appended at the end of the string (thus making the following compound
   * modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the
   * letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").
   * Additional characters may follow the sequence, although they should have no
   * effect. For example, "t" is sometimes appended to make explicit the file is
   * a text file.
   *
   * This function supports Unicode filenames, but they must be encoded in UTF-8
   * format, regardless of the underlying operating system.
   *
   * In Android, IOStream.FromFile() can be used to open content:// URIs. As a
   * fallback, IOStream.FromFile() will transparently open a matching filename
   * in the app's `assets`.
   *
   * Closing the IOStream will close SDL's internal file handle.
   *
   * The following properties may be set at creation time by SDL:
   *
   * - `prop::IOStream.WINDOWS_HANDLE_POINTER`: a pointer, that can be cast
   *   to a win32 `HANDLE`, that this IOStream is using to access the
   *   filesystem. If the program isn't running on Windows, or SDL used some
   *   other method to access the filesystem, this property will not be set.
   * - `prop::IOStream.STDIO_FILE_POINTER`: a pointer, that can be cast to a
   *   stdio `FILE *`, that this IOStream is using to access the filesystem.
   *   If SDL used some other method to access the filesystem, this property
   *   will not be set. PLEASE NOTE that if SDL is using a different C runtime
   *   than your app, trying to use this pointer will almost certainly result in
   *   a crash! This is mostly a problem on Windows; make sure you build SDL and
   *   your app with the same compiler and settings to avoid it.
   * - `prop::IOStream.FILE_DESCRIPTOR_NUMBER`: a file descriptor that this
   *   IOStream is using to access the filesystem.
   * - `prop::IOStream.ANDROID_AASSET_POINTER`: a pointer, that can be cast
   *   to an Android NDK `AAsset *`, that this IOStream is using to access
   *   the filesystem. If SDL used some other method to access the filesystem,
   *   this property will not be set.
   *
   * @param file a UTF-8 string representing the filename to open.
   * @param mode an ASCII string representing the mode to be used for opening
   *             the file.
   * @returns a pointer to the IOStream structure that is created or nullptr on
   *          failure; call GetError() for more information.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa IOStream.Close
   * @sa IOStream.Flush
   * @sa IOStream.Read
   * @sa IOStream.Seek
   * @sa IOStream.Tell
   * @sa IOStream.Write
   */
  static IOStream FromFile(StringParam file, StringParam mode);

  /**
   * Use this function to prepare a read-write memory buffer for use with
   * IOStream.
   *
   * This function sets up an IOStream struct based on a memory area of a
   * certain size, for both read and write access.
   *
   * This memory buffer is not copied by the IOStream; the pointer you
   * provide must remain valid until you close the stream. Closing the stream
   * will not free the original buffer.
   *
   * If you need to make sure the IOStream never writes to the memory
   * buffer, you should use IOStream.FromConstMem() with a read-only buffer of
   * memory instead.
   *
   * The following properties will be set at creation time by SDL:
   *
   * - `prop::IOStream.MEMORY_POINTER`: this will be the `mem` parameter that
   *   was passed to this function.
   * - `prop::IOStream.MEMORY_SIZE_NUMBER`: this will be the `size` parameter
   *   that was passed to this function.
   *
   * @param mem a buffer to feed an IOStream stream.
   * @returns a valid IOStream on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa IOStream.FromConstMem
   * @sa IOStream.Close
   * @sa IOStream.Flush
   * @sa IOStream.Read
   * @sa IOStream.Seek
   * @sa IOStream.Tell
   * @sa IOStream.Write
   */
  static IOStream FromMem(TargetBytes mem);

  /**
   * Use this function to prepare a read-only memory buffer for use with
   * IOStream.
   *
   * This function sets up an IOStream struct based on a memory area of a
   * certain size. It assumes the memory area is not writable.
   *
   * Attempting to write to this IOStream stream will report an error
   * without writing to the memory buffer.
   *
   * This memory buffer is not copied by the IOStream; the pointer you
   * provide must remain valid until you close the stream. Closing the stream
   * will not free the original buffer.
   *
   * If you need to write to a memory buffer, you should use IOStream.FromMem()
   * with a writable buffer of memory instead.
   *
   * The following properties will be set at creation time by SDL:
   *
   * - `prop::IOStream.MEMORY_POINTER`: this will be the `mem` parameter that
   *   was passed to this function.
   * - `prop::IOStream.MEMORY_SIZE_NUMBER`: this will be the `size` parameter
   *   that was passed to this function.
   *
   * @param mem a read-only buffer to feed an IOStreamRef stream.
   * @returns a valid IOStream on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa IOStream.FromMem
   * @sa IOStream.Close
   * @sa IOStream.Read
   * @sa IOStream.Seek
   * @sa IOStream.Tell
   */
  static IOStream FromConstMem(SourceBytes mem);

  /**
   * Use this function to create an IOStream that is backed by dynamically
   * allocated memory.
   *
   * This supports the following properties to provide access to the memory and
   * control over allocations:
   *
   * - `prop::IOStream.DYNAMIC_MEMORY_POINTER`: a pointer to the internal
   *   memory of the stream. This can be set to nullptr to transfer ownership of
   *   the memory to the application, which should free the memory with
   *   free(). If this is done, the next operation on the stream must be
   *   IOStream.Close().
   * - `prop::IOStream.DYNAMIC_CHUNKSIZE_NUMBER`: memory will be allocated in
   *   multiples of this size, defaulting to 1024.
   *
   * @returns a valid IOStream on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa IOStream.Close
   * @sa IOStream.Read
   * @sa IOStream.Seek
   * @sa IOStream.Tell
   * @sa IOStream.Write
   */
  static IOStream FromDynamicMem();

  /**
   * Create a custom IOStream.
   *
   * Applications do not need to use this function unless they are providing
   * their own IOStream implementation. If you just need an IOStream to
   * read/write a common data source, you should use the built-in
   * implementations in SDL, like IOStream.FromFile() or IOStream.FromMem(),
   * etc.
   *
   * This function makes a copy of `iface` and the caller does not need to keep
   * it around after this call.
   *
   * @param iface the interface that implements this IOStream, initialized
   *              using SDL_INIT_INTERFACE().
   * @param userdata the pointer that will be passed to the interface functions.
   * @returns a valid stream on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa IOStream.Close
   * @sa SDL_INIT_INTERFACE
   * @sa IOStream.FromConstMem
   * @sa IOStream.FromFile
   * @sa IOStream.FromMem
   */
  static IOStream Open(const IOStreamInterface* iface, void* userdata);

  /// Destructor
  ~IOStream() { SDL_CloseIO(m_resource); }

  /// Assignment operator.
  IOStream& operator=(IOStream other)
  {
    std::swap(m_resource, other.m_resource);
    return *this;
  }

  /// Retrieves underlying IOStreamRaw.
  constexpr IOStreamRaw get() const { return m_resource; }

  /// Retrieves underlying IOStreamRaw and clear this.
  constexpr IOStreamRaw release()
  {
    auto r = m_resource;
    m_resource = nullptr;
    return r;
  }

  /// Comparison
  constexpr auto operator<=>(const IOStream& other) const = default;

  /// Comparison
  constexpr bool operator==(std::nullptr_t _) const { return !m_resource; }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!m_resource; }

  /// Converts to IOStreamParam
  constexpr operator IOStreamParam() const { return {m_resource}; }

  /**
   * Close and free an allocated IOStream structure.
   *
   * IOStream.Close() closes and cleans up the IOStream stream. It releases any
   * resources used by the stream and frees the IOStream itself. This
   * returns true on success, or false if the stream failed to flush to its
   * output (e.g. to disk).
   *
   * Note that if this fails to flush the stream for any reason, this function
   * reports an error, but the IOStream is still invalid once this function
   * returns.
   *
   * This call flushes any buffered writes to the operating system, but there
   * are no guarantees that those writes have gone to physical media; they might
   * be in the OS's file cache, waiting to go to disk later. If it's absolutely
   * crucial that writes go to disk immediately, so they are definitely stored
   * even if the power fails before the file cache would have caught up, one
   * should call IOStream.Flush() before closing. Note that flushing takes time
   * and makes the system and your app operate less efficiently, so do so
   * sparingly.
   *
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa IOStream.Open
   */
  void Close();

  /**
   * Get the properties associated with an IOStream.
   *
   * @returns a valid property ID on success.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  PropertiesRef GetProperties() const;

  /**
   * Query the stream status of an IOStream.
   *
   * This information can be useful to decide if a short read or write was due
   * to an error, an EOF, or a non-blocking operation that isn't yet ready to
   * complete.
   *
   * An IOStream's status is only expected to change after a IOStream.Read or
   * IOStream.Write call; don't expect it to change if you just call this query
   * function in a tight loop.
   *
   * @returns an IOStatus enum with the current state.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  IOStatus GetStatus() const;

  /**
   * Use this function to get the size of the data stream in an IOStream.
   *
   * @returns the size of the data stream in the IOStream on success.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  Sint64 GetSize() const;

  /**
   * Seek within an IOStream data stream.
   *
   * This function seeks to byte `offset`, relative to `whence`.
   *
   * `whence` may be any of the following values:
   *
   * - `IO_SEEK_SET`: seek from the beginning of data
   * - `IO_SEEK_CUR`: seek relative to current read point
   * - `IO_SEEK_END`: seek relative to the end of data
   *
   * If this stream can not seek, it will return -1.
   *
   * @param offset an offset in bytes, relative to `whence` location; can be
   *               negative.
   * @param whence any of `IO_SEEK_SET`, `IO_SEEK_CUR`,
   *               `IO_SEEK_END`.
   * @returns the final offset in the data stream after the seek or -1 on
   *          failure; call GetError() for more information.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa IOStream.Tell
   */
  Sint64 Seek(Sint64 offset, IOWhence whence);

  /**
   * Determine the current read/write offset in an IOStream data stream.
   *
   * IOStream.Tell is actually a wrapper function that calls the IOStream's
   * `seek` method, with an offset of 0 bytes from `IO_SEEK_CUR`, to
   * simplify application development.
   *
   * @returns the current offset in the stream, or -1 if the information can not
   *          be determined.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa IOStream.Seek
   */
  Sint64 Tell() const;

  /**
   * Read from a data source.
   *
   * This function reads up `size` bytes from the data source to the area
   * pointed at by `ptr`. This function may read less bytes than requested.
   *
   * This function will return zero when the data stream is completely read, and
   * IOStreamRef.GetStatus() will return IO_STATUS_EOF. If zero is returned and
   * the stream is not at EOF, IOStreamRef.GetStatus() will return a different
   * error value and GetError() will offer a human-readable message.
   *
   * @param size the number of bytes to read from the data source.
   * @returns the bytes, or empty string on end of file or other failure;
   *          call GetError() for more information.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa IOStream.Write
   * @sa IOStream.GetStatus
   */
  std::string Read(size_t size = -1)
  {
    Sint64 pos = Tell();
    auto curSize = SDL_GetIOSize(get());
    if ((curSize < 0 || pos < 0)) {
      if (size == size_t(-1)) return {};
    } else if (curSize - pos <= 0) {
      return {};
    } else if (curSize - pos < size) {
      size = curSize - pos;
    }
    std::string result(size, 0);
    auto actualSize = Read(result);
    if (actualSize < size) result.resize(actualSize);
    return result;
  }

  /**
   * Read from a data source.
   *
   * This function reads up `size` bytes from the data source to the area
   * pointed at by `ptr`. This function may read less bytes than requested.
   *
   * This function will return zero when the data stream is completely read, and
   * IOStream.GetStatus() will return IO_STATUS_EOF. If zero is returned and
   * the stream is not at EOF, IOStream.GetStatus() will return a different
   * error value and GetError() will offer a human-readable message.
   *
   * @param ptr a pointer to a buffer to read data into.
   * @param size the number of bytes to read from the data source.
   * @returns the number of bytes read, or 0 on end of file or other failure;
   *          call GetError() for more information.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa IOStream.Write
   * @sa IOStream.GetStatus
   */
  size_t Read(TargetBytes buf);

  /**
   * Write to an IOStream data stream.
   *
   * This function writes exactly `size` bytes from the area pointed at by `ptr`
   * to the stream. If this fails for any reason, it'll return less than `size`
   * to demonstrate how far the write progressed. On success, it returns `size`.
   *
   * On error, this function still attempts to write as much as possible, so it
   * might return a positive value less than the requested write size.
   *
   * The caller can use IOStream.GetStatus() to determine if the problem is
   * recoverable, such as a non-blocking write that can simply be retried later,
   * or a fatal error.
   *
   * @param buf the bytes to write to
   * @returns the number of bytes written, which will be less than `size` on
   *          failure; call GetError() for more information.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa IOStream.printf
   * @sa IOStream.Read
   * @sa IOStream.Seek
   * @sa IOStream.Flush
   * @sa IOStream.GetStatus
   */
  size_t Write(SourceBytes buf);

  /**
   * Prints formatted string.
   *
   * @param fmt a std::format like format string
   * @param args... the arguments to be formatted
   * @cat formatted-string
   */
  size_t print(std::string_view fmt, auto... args)
  {
    return Write(std::vformat(fmt, std::make_format_args(args...)));
  }

  /**
   * Prints formatted string.
   *
   * @param fmt a std::format like format string
   * @param args... the arguments to be formatted
   * @cat formatted-string
   */
  size_t println(std::string_view fmt, auto... args)
  {
    std::string result =
      std::vformat(fmt, std::make_format_args(args...)) + "\n";
    return Write(result);
  }

  /**
   * Print to an IOStream data stream.
   *
   * @warning this is not typesafe! Prefer using print() and println()
   *
   * This function does formatted printing to the stream.
   *
   * @param fmt a printf() style format string.
   * @param ... additional parameters matching % tokens in the `fmt` string, if
   *            any.
   * @returns the number of bytes written or 0 on failure; call GetError()
   *          for more information.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa IOStream.vprintf
   * @sa IOStream.Write
   */
  size_t printf(SDL_PRINTF_FORMAT_STRING const char* fmt, ...)
  {
    va_list ap;
    size_t result;

    va_start(ap, fmt);
    result = vprintf(fmt, ap);
    va_end(ap);

    return result;
  }

  /**
   * Print to an IOStream data stream.
   *
   * @warning this is not typesafe! Prefer using print() and println()
   *
   * This function does formatted printing to the stream.
   *
   * @param fmt a printf() style format string.
   * @param ap a variable argument list.
   * @returns the number of bytes written or 0 on failure; call GetError()
   *          for more information.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa IOStream.printf
   * @sa IOStream.Write
   */
  size_t vprintf(SDL_PRINTF_FORMAT_STRING const char* fmt, va_list ap);

  /**
   * Flush any buffered data in the stream.
   *
   * This function makes sure that any buffered data is written to the stream.
   * Normally this isn't necessary but if the stream is a pipe or socket it
   * guarantees that any pending data is sent.
   *
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa IOStream.Open
   * @sa IOStream.Write
   */
  void Flush();

  /**
   * Load all the data from an SDL data stream.
   *
   * The data is allocated with a zero byte at the end (null terminated) for
   * convenience. This extra byte is not included in the value reported on
   * the returned string.
   *
   * @returns the data in bytes
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa LoadFile
   * @sa IOStream.SaveFile
   */
  StringResult LoadFile();

  /**
   * Load all the data from an SDL data stream.
   *
   * The data is allocated with a zero byte at the end (null terminated) for
   * convenience. This extra byte is not included in the value reported on
   * the returned string.
   *
   * @returns the data in bytes
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa LoadFile
   * @sa IOStream.SaveFile
   */
  template<class T>
  OwnArray<T> LoadFileAs()
  {
    size_t datasize = 0;
    auto data = static_cast<T*>(SDL_LoadFile_IO(get(), &datasize, false));
    return OwnArray<T>{CheckError(data), datasize / sizeof(T)};
  }

  /**
   * Save all the data into an SDL data stream.
   *
   * @param data the data to be written. If datasize is 0, may be nullptr or a
   *             invalid pointer.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa SaveFile
   * @sa IOStream.LoadFile
   */
  void SaveFile(SourceBytes data);

  /**
   * Use this function to read a byte from an IOStream.
   *
   * This function will return false when the data stream is completely read,
   * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
   * and the stream is not at EOF, IOStream.GetStatus() will return a different
   * error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  Uint8 ReadU8();

  /**
   * Use this function to read a signed byte from an IOStream.
   *
   * This function will return false when the data stream is completely read,
   * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
   * and the stream is not at EOF, IOStream.GetStatus() will return a different
   * error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  Sint8 ReadS8();

  /**
   * Use this function to read 16 bits of little-endian data from an
   * IOStream and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
   * and the stream is not at EOF, IOStream.GetStatus() will return a different
   * error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  Uint16 ReadU16LE();

  /**
   * Use this function to read 16 bits of little-endian data from an
   * IOStream and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
   * and the stream is not at EOF, IOStream.GetStatus() will return a different
   * error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  Sint16 ReadS16LE();

  /**
   * Use this function to read 16 bits of big-endian data from an IOStream
   * and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
   * and the stream is not at EOF, IOStream.GetStatus() will return a different
   * error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  Uint16 ReadU16BE();

  /**
   * Use this function to read 16 bits of big-endian data from an IOStream
   * and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
   * and the stream is not at EOF, IOStream.GetStatus() will return a different
   * error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  Sint16 ReadS16BE();

  /**
   * Use this function to read 32 bits of little-endian data from an
   * IOStream and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
   * and the stream is not at EOF, IOStream.GetStatus() will return a different
   * error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  Uint32 ReadU32LE();

  /**
   * Use this function to read 32 bits of little-endian data from an
   * IOStream and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
   * and the stream is not at EOF, IOStream.GetStatus() will return a different
   * error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  Sint32 ReadS32LE();

  /**
   * Use this function to read 32 bits of big-endian data from an IOStream
   * and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
   * and the stream is not at EOF, IOStream.GetStatus() will return a different
   * error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  Uint32 ReadU32BE();

  /**
   * Use this function to read 32 bits of big-endian data from an IOStream
   * and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
   * and the stream is not at EOF, IOStream.GetStatus() will return a different
   * error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  Sint32 ReadS32BE();

  /**
   * Use this function to read 64 bits of little-endian data from an
   * IOStream and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
   * and the stream is not at EOF, IOStream.GetStatus() will return a different
   * error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  Uint64 ReadU64LE();

  /**
   * Use this function to read 64 bits of little-endian data from an
   * IOStream and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
   * and the stream is not at EOF, IOStream.GetStatus() will return a different
   * error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  Sint64 ReadS64LE();

  /**
   * Use this function to read 64 bits of big-endian data from an IOStream
   * and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
   * and the stream is not at EOF, IOStream.GetStatus() will return a different
   * error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  Uint64 ReadU64BE();

  /**
   * Use this function to read 64 bits of big-endian data from an IOStream
   * and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
   * and the stream is not at EOF, IOStream.GetStatus() will return a different
   * error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  Sint64 ReadS64BE();

  /**
   * Use this function to read a byte from an IOStreamRef.
   *
   * This function will return false when the data stream is completely read,
   * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
   * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
   * a different error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success, std::nullopt on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  std::optional<Uint8> TryReadU8()
  {
    if (Uint8 value; SDL_ReadU8(get(), &value)) return value;
    return {};
  }

  /**
   * Use this function to read a byte from an IOStreamRef.
   *
   * This function will return false when the data stream is completely read,
   * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
   * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
   * a different error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success, std::nullopt on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  std::optional<Sint8> TryReadS8()
  {
    if (Sint8 value; SDL_ReadS8(get(), &value)) return value;
    return {};
  }

  /**
   * Use this function to read 16 bits of little-endian data from an
   * IOStreamRef and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
   * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
   * a different error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success, std::nullopt on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  std::optional<Uint16> TryReadU16LE()
  {
    if (Uint16 value; SDL_ReadU16LE(get(), &value)) return value;
    return {};
  }

  /**
   * Use this function to read 16 bits of little-endian data from an
   * IOStreamRef and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
   * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
   * a different error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success, std::nullopt on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  std::optional<Sint16> TryReadS16LE()
  {
    if (Sint16 value; SDL_ReadS16LE(get(), &value)) return value;
    return {};
  }

  /**
   * Use this function to read 16 bits of big-endian data from an IOStreamRef
   * and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
   * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
   * a different error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success, std::nullopt on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  std::optional<Uint16> TryReadU16BE()
  {
    if (Uint16 value; SDL_ReadU16BE(get(), &value)) return value;
    return {};
  }

  /**
   * Use this function to read 16 bits of big-endian data from an IOStreamRef
   * and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
   * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
   * a different error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success, std::nullopt on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  std::optional<Sint16> TryReadS16BE()
  {
    if (Sint16 value; SDL_ReadS16BE(get(), &value)) return value;
    return {};
  }

  /**
   * Use this function to read 32 bits of little-endian data from an
   * IOStreamRef and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
   * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
   * a different error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success, std::nullopt on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  std::optional<Uint32> TryReadU32LE()
  {
    if (Uint32 value; SDL_ReadU32LE(get(), &value)) return value;
    return {};
  }

  /**
   * Use this function to read 32 bits of little-endian data from an
   * IOStreamRef and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
   * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
   * a different error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success, std::nullopt on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  std::optional<Sint32> TryReadS32LE()
  {
    if (Sint32 value; SDL_ReadS32LE(get(), &value)) return value;
    return {};
  }

  /**
   * Use this function to read 32 bits of big-endian data from an IOStreamRef
   * and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
   * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
   * a different error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success, std::nullopt on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  std::optional<Uint32> TryReadU32BE()
  {
    if (Uint32 value; SDL_ReadU32BE(get(), &value)) return value;
    return {};
  }

  /**
   * Use this function to read 32 bits of big-endian data from an IOStreamRef
   * and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
   * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
   * a different error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success, std::nullopt on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  std::optional<Sint32> TryReadS32BE()
  {
    if (Sint32 value; SDL_ReadS32BE(get(), &value)) return value;
    return {};
  }

  /**
   * Use this function to read 64 bits of little-endian data from an
   * IOStreamRef and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
   * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
   * a different error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success, std::nullopt on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  std::optional<Uint64> TryReadU64LE()
  {
    if (Uint64 value; SDL_ReadU64LE(get(), &value)) return value;
    return {};
  }

  /**
   * Use this function to read 64 bits of little-endian data from an
   * IOStreamRef and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
   * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
   * a different error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success, std::nullopt on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  std::optional<Sint64> TryReadS64LE()
  {
    if (Sint64 value; SDL_ReadS64LE(get(), &value)) return value;
    return {};
  }

  /**
   * Use this function to read 64 bits of big-endian data from an IOStreamRef
   * and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
   * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
   * a different error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success, std::nullopt on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  std::optional<Uint64> TryReadU64BE()
  {
    if (Uint64 value; SDL_ReadU64BE(get(), &value)) return value;
    return {};
  }

  /**
   * Use this function to read 64 bits of big-endian data from an IOStreamRef
   * and return in native format.
   *
   * SDL byteswaps the data only if necessary, so the data returned will be in
   * the native byte order.
   *
   * This function will return false when the data stream is completely read,
   * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
   * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
   * a different error value and GetError() will offer a human-readable message.
   *
   * @returns the data read on success, std::nullopt on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  std::optional<Sint64> TryReadS64BE()
  {
    if (Sint64 value; SDL_ReadS64BE(get(), &value)) return value;
    return {};
  }

  /**
   * Use this function to write a byte to an IOStream.
   *
   * @param value the byte value to write.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void WriteU8(Uint8 value);

  /**
   * Use this function to write a signed byte to an IOStream.
   *
   * @param value the byte value to write.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void WriteS8(Sint8 value);

  /**
   * Use this function to write 16 bits in native format to an IOStream as
   * little-endian data.
   *
   * SDL byteswaps the data only if necessary, so the application always
   * specifies native format, and the data written will be in little-endian
   * format.
   *
   * @param value the data to be written, in native format.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void WriteU16LE(Uint16 value);

  /**
   * Use this function to write 16 bits in native format to an IOStream as
   * little-endian data.
   *
   * SDL byteswaps the data only if necessary, so the application always
   * specifies native format, and the data written will be in little-endian
   * format.
   *
   * @param value the data to be written, in native format.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void WriteS16LE(Sint16 value);

  /**
   * Use this function to write 16 bits in native format to an IOStream as
   * big-endian data.
   *
   * SDL byteswaps the data only if necessary, so the application always
   * specifies native format, and the data written will be in big-endian format.
   *
   * @param value the data to be written, in native format.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void WriteU16BE(Uint16 value);

  /**
   * Use this function to write 16 bits in native format to an IOStream as
   * big-endian data.
   *
   * SDL byteswaps the data only if necessary, so the application always
   * specifies native format, and the data written will be in big-endian format.
   *
   * @param value the data to be written, in native format.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void WriteS16BE(Sint16 value);

  /**
   * Use this function to write 32 bits in native format to an IOStream as
   * little-endian data.
   *
   * SDL byteswaps the data only if necessary, so the application always
   * specifies native format, and the data written will be in little-endian
   * format.
   *
   * @param value the data to be written, in native format.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void WriteU32LE(Uint32 value);

  /**
   * Use this function to write 32 bits in native format to an IOStream as
   * little-endian data.
   *
   * SDL byteswaps the data only if necessary, so the application always
   * specifies native format, and the data written will be in little-endian
   * format.
   *
   * @param value the data to be written, in native format.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void WriteS32LE(Sint32 value);

  /**
   * Use this function to write 32 bits in native format to an IOStream as
   * big-endian data.
   *
   * SDL byteswaps the data only if necessary, so the application always
   * specifies native format, and the data written will be in big-endian format.
   *
   * @param value the data to be written, in native format.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void WriteU32BE(Uint32 value);

  /**
   * Use this function to write 32 bits in native format to an IOStream as
   * big-endian data.
   *
   * SDL byteswaps the data only if necessary, so the application always
   * specifies native format, and the data written will be in big-endian format.
   *
   * @param value the data to be written, in native format.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void WriteS32BE(Sint32 value);

  /**
   * Use this function to write 64 bits in native format to an IOStream as
   * little-endian data.
   *
   * SDL byteswaps the data only if necessary, so the application always
   * specifies native format, and the data written will be in little-endian
   * format.
   *
   * @param value the data to be written, in native format.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void WriteU64LE(Uint64 value);

  /**
   * Use this function to write 64 bits in native format to an IOStream as
   * little-endian data.
   *
   * SDL byteswaps the data only if necessary, so the application always
   * specifies native format, and the data written will be in little-endian
   * format.
   *
   * @param value the data to be written, in native format.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void WriteS64LE(Sint64 value);

  /**
   * Use this function to write 64 bits in native format to an IOStream as
   * big-endian data.
   *
   * SDL byteswaps the data only if necessary, so the application always
   * specifies native format, and the data written will be in big-endian format.
   *
   * @param value the data to be written, in native format.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void WriteU64BE(Uint64 value);

  /**
   * Use this function to write 64 bits in native format to an IOStream as
   * big-endian data.
   *
   * SDL byteswaps the data only if necessary, so the application always
   * specifies native format, and the data written will be in big-endian format.
   *
   * @param value the data to be written, in native format.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void WriteS64BE(Sint64 value);
};

/// Semi-safe reference for IOStream.
struct IOStreamRef : IOStream
{
  /**
   * Constructs from IOStreamParam.
   *
   * @param resource a IOStreamRaw or IOStream.
   *
   * This does not takes ownership!
   */
  IOStreamRef(IOStreamParam resource)
    : IOStream(resource.value)
  {
  }

  /// Copy constructor.
  IOStreamRef(const IOStreamRef& other)
    : IOStream(other.get())
  {
  }

  /// Destructor
  ~IOStreamRef() { release(); }
};

/**
 * Use this function to create a new IOStream structure for reading from
 * and/or writing to a named file.
 *
 * The `mode` string is treated roughly the same as in a call to the C
 * library's fopen(), even if SDL doesn't happen to use fopen() behind the
 * scenes.
 *
 * Available `mode` strings:
 *
 * - "r": Open a file for reading. The file must exist.
 * - "w": Create an empty file for writing. If a file with the same name
 *   already exists its content is erased and the file is treated as a new
 *   empty file.
 * - "a": Append to a file. Writing operations append data at the end of the
 *   file. The file is created if it does not exist.
 * - "r+": Open a file for update both reading and writing. The file must
 *   exist.
 * - "w+": Create an empty file for both reading and writing. If a file with
 *   the same name already exists its content is erased and the file is
 *   treated as a new empty file.
 * - "a+": Open a file for reading and appending. All writing operations are
 *   performed at the end of the file, protecting the previous content to be
 *   overwritten. You can reposition (fseek, rewind) the internal pointer to
 *   anywhere in the file for reading, but writing operations will move it
 *   back to the end of file. The file is created if it does not exist.
 *
 * **NOTE**: In order to open a file as a binary file, a "b" character has to
 * be included in the `mode` string. This additional "b" character can either
 * be appended at the end of the string (thus making the following compound
 * modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the
 * letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").
 * Additional characters may follow the sequence, although they should have no
 * effect. For example, "t" is sometimes appended to make explicit the file is
 * a text file.
 *
 * This function supports Unicode filenames, but they must be encoded in UTF-8
 * format, regardless of the underlying operating system.
 *
 * In Android, IOStream.FromFile() can be used to open content:// URIs. As a
 * fallback, IOStream.FromFile() will transparently open a matching filename in
 * the app's `assets`.
 *
 * Closing the IOStream will close SDL's internal file handle.
 *
 * The following properties may be set at creation time by SDL:
 *
 * - `prop::IOStream.WINDOWS_HANDLE_POINTER`: a pointer, that can be cast
 *   to a win32 `HANDLE`, that this IOStream is using to access the
 *   filesystem. If the program isn't running on Windows, or SDL used some
 *   other method to access the filesystem, this property will not be set.
 * - `prop::IOStream.STDIO_FILE_POINTER`: a pointer, that can be cast to a
 *   stdio `FILE *`, that this IOStream is using to access the filesystem.
 *   If SDL used some other method to access the filesystem, this property
 *   will not be set. PLEASE NOTE that if SDL is using a different C runtime
 *   than your app, trying to use this pointer will almost certainly result in
 *   a crash! This is mostly a problem on Windows; make sure you build SDL and
 *   your app with the same compiler and settings to avoid it.
 * - `prop::IOStream.FILE_DESCRIPTOR_NUMBER`: a file descriptor that this
 *   IOStream is using to access the filesystem.
 * - `prop::IOStream.ANDROID_AASSET_POINTER`: a pointer, that can be cast
 *   to an Android NDK `AAsset *`, that this IOStream is using to access
 *   the filesystem. If SDL used some other method to access the filesystem,
 *   this property will not be set.
 *
 * @param file a UTF-8 string representing the filename to open.
 * @param mode an ASCII string representing the mode to be used for opening
 *             the file.
 * @returns a pointer to the IOStream structure that is created or nullptr on
 *          failure; call GetError() for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa IOStream.Close
 * @sa IOStream.Flush
 * @sa IOStream.Read
 * @sa IOStream.Seek
 * @sa IOStream.Tell
 * @sa IOStream.Write
 */
inline IOStream IOFromFile(StringParam file, StringParam mode)
{
  return IOStream(SDL_IOFromFile(file, mode));
}

inline IOStream IOStream::FromFile(StringParam file, StringParam mode)
{
  return SDL::IOFromFile(std::move(file), std::move(mode));
}

namespace prop::IOStream {

constexpr auto WINDOWS_HANDLE_POINTER =
  SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER;

constexpr auto STDIO_FILE_POINTER = SDL_PROP_IOSTREAM_STDIO_FILE_POINTER;

constexpr auto FILE_DESCRIPTOR_NUMBER =
  SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER;

constexpr auto ANDROID_AASSET_POINTER =
  SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER;

constexpr auto MEMORY_POINTER = SDL_PROP_IOSTREAM_MEMORY_POINTER;

constexpr auto MEMORY_SIZE_NUMBER = SDL_PROP_IOSTREAM_MEMORY_SIZE_NUMBER;

constexpr auto DYNAMIC_MEMORY_POINTER =
  SDL_PROP_IOSTREAM_DYNAMIC_MEMORY_POINTER;

constexpr auto DYNAMIC_CHUNKSIZE_NUMBER =
  SDL_PROP_IOSTREAM_DYNAMIC_CHUNKSIZE_NUMBER;

} // namespace prop::IOStream

/**
 * Use this function to prepare a read-write memory buffer for use with
 * IOStream.
 *
 * This function sets up an IOStream struct based on a memory area of a
 * certain size, for both read and write access.
 *
 * This memory buffer is not copied by the IOStream; the pointer you
 * provide must remain valid until you close the stream. Closing the stream
 * will not free the original buffer.
 *
 * If you need to make sure the IOStream never writes to the memory
 * buffer, you should use IOStream.FromConstMem() with a read-only buffer of
 * memory instead.
 *
 * The following properties will be set at creation time by SDL:
 *
 * - `prop::IOStream.MEMORY_POINTER`: this will be the `mem` parameter that
 *   was passed to this function.
 * - `prop::IOStream.MEMORY_SIZE_NUMBER`: this will be the `size` parameter
 *   that was passed to this function.
 *
 * @param mem a pointer to a buffer to feed an IOStream stream.
 * @param size the buffer size, in bytes.
 * @returns a pointer to a new IOStream structure or nullptr on failure; call
 *          GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa IOStream.FromConstMem
 * @sa IOStream.Close
 * @sa IOStream.Flush
 * @sa IOStream.Read
 * @sa IOStream.Seek
 * @sa IOStream.Tell
 * @sa IOStream.Write
 */
inline IOStream IOFromMem(void* mem, size_t size)
{
  return IOStream(SDL_IOFromMem(mem, size));
}

inline IOStream IOStream::FromMem(TargetBytes mem)
{
  return SDL::IOFromMem(mem.data, mem.size_bytes);
}

/**
 * Use this function to prepare a read-only memory buffer for use with
 * IOStream.
 *
 * This function sets up an IOStream struct based on a memory area of a
 * certain size. It assumes the memory area is not writable.
 *
 * Attempting to write to this IOStream stream will report an error
 * without writing to the memory buffer.
 *
 * This memory buffer is not copied by the IOStream; the pointer you
 * provide must remain valid until you close the stream. Closing the stream
 * will not free the original buffer.
 *
 * If you need to write to a memory buffer, you should use IOStream.FromMem()
 * with a writable buffer of memory instead.
 *
 * The following properties will be set at creation time by SDL:
 *
 * - `prop::IOStream.MEMORY_POINTER`: this will be the `mem` parameter that
 *   was passed to this function.
 * - `prop::IOStream.MEMORY_SIZE_NUMBER`: this will be the `size` parameter
 *   that was passed to this function.
 *
 * @param mem a pointer to a read-only buffer to feed an IOStream stream.
 * @param size the buffer size, in bytes.
 * @returns a pointer to a new IOStream structure or nullptr on failure; call
 *          GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa IOStream.FromMem
 * @sa IOStream.Close
 * @sa IOStream.Read
 * @sa IOStream.Seek
 * @sa IOStream.Tell
 */
inline IOStream IOFromConstMem(const void* mem, size_t size)
{
  return IOStream(SDL_IOFromConstMem(mem, size));
}

inline IOStream IOStream::FromConstMem(SourceBytes mem)
{
  return SDL::IOFromConstMem(mem.data, mem.size_bytes);
}

/**
 * Use this function to create an IOStream that is backed by dynamically
 * allocated memory.
 *
 * This supports the following properties to provide access to the memory and
 * control over allocations:
 *
 * - `prop::IOStream.DYNAMIC_MEMORY_POINTER`: a pointer to the internal
 *   memory of the stream. This can be set to nullptr to transfer ownership of
 *   the memory to the application, which should free the memory with
 *   free(). If this is done, the next operation on the stream must be
 *   IOStream.Close().
 * - `prop::IOStream.DYNAMIC_CHUNKSIZE_NUMBER`: memory will be allocated in
 *   multiples of this size, defaulting to 1024.
 *
 * @returns a pointer to a new IOStream structure or nullptr on failure; call
 *          GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa IOStream.Close
 * @sa IOStream.Read
 * @sa IOStream.Seek
 * @sa IOStream.Tell
 * @sa IOStream.Write
 */
inline IOStream IOFromDynamicMem() { return IOStream(SDL_IOFromDynamicMem()); }

inline IOStream IOStream::FromDynamicMem() { return SDL::IOFromDynamicMem(); }

/**
 * Create a custom IOStream.
 *
 * Applications do not need to use this function unless they are providing
 * their own IOStream implementation. If you just need an IOStream to
 * read/write a common data source, you should use the built-in
 * implementations in SDL, like IOStream.FromFile() or IOStream.FromMem(), etc.
 *
 * This function makes a copy of `iface` and the caller does not need to keep
 * it around after this call.
 *
 * @param iface the interface that implements this IOStream, initialized
 *              using SDL_INIT_INTERFACE().
 * @param userdata the pointer that will be passed to the interface functions.
 * @returns a pointer to the allocated memory on success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa IOStream.Close
 * @sa SDL_INIT_INTERFACE
 * @sa IOStream.FromConstMem
 * @sa IOStream.FromFile
 * @sa IOStream.FromMem
 */
inline IOStream OpenIO(const IOStreamInterface* iface, void* userdata)
{
  return IOStream(CheckError(SDL_OpenIO(iface, userdata)));
}

inline IOStream IOStream::Open(const IOStreamInterface* iface, void* userdata)
{
  return SDL::OpenIO(iface, userdata);
}

/**
 * Close and free an allocated IOStream structure.
 *
 * IOStream.Close() closes and cleans up the IOStream stream. It releases any
 * resources used by the stream and frees the IOStream itself. This
 * returns true on success, or false if the stream failed to flush to its
 * output (e.g. to disk).
 *
 * Note that if this fails to flush the stream for any reason, this function
 * reports an error, but the IOStream is still invalid once this function
 * returns.
 *
 * This call flushes any buffered writes to the operating system, but there
 * are no guarantees that those writes have gone to physical media; they might
 * be in the OS's file cache, waiting to go to disk later. If it's absolutely
 * crucial that writes go to disk immediately, so they are definitely stored
 * even if the power fails before the file cache would have caught up, one
 * should call IOStream.Flush() before closing. Note that flushing takes time
 * and makes the system and your app operate less efficiently, so do so
 * sparingly.
 *
 * @param context IOStream structure to close.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa IOStream.Open
 */
inline void CloseIO(IOStreamRaw context) { CheckError(SDL_CloseIO(context)); }

inline void IOStream::Close()
{
  CheckError(SDL_CloseIO(m_resource));
  m_resource = nullptr;
}

/**
 * Get the properties associated with an IOStream.
 *
 * @param context a pointer to an IOStream structure.
 * @returns a valid property ID on success.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline PropertiesRef GetIOProperties(IOStreamParam context)
{
  return {CheckError(SDL_GetIOProperties(context))};
}

inline PropertiesRef IOStream::GetProperties() const
{
  return SDL::GetIOProperties(m_resource);
}

/**
 * Query the stream status of an IOStream.
 *
 * This information can be useful to decide if a short read or write was due
 * to an error, an EOF, or a non-blocking operation that isn't yet ready to
 * complete.
 *
 * An IOStream's status is only expected to change after a IOStream.Read or
 * IOStream.Write call; don't expect it to change if you just call this query
 * function in a tight loop.
 *
 * @param context the IOStream to query.
 * @returns an IOStatus enum with the current state.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline IOStatus GetIOStatus(IOStreamParam context)
{
  return SDL_GetIOStatus(context);
}

inline IOStatus IOStream::GetStatus() const
{
  return SDL::GetIOStatus(m_resource);
}

/**
 * Use this function to get the size of the data stream in an IOStream.
 *
 * @param context the IOStream to get the size of the data stream from.
 * @returns the size of the data stream in the IOStream on success.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Sint64 GetIOSize(IOStreamParam context)
{
  return CheckError(SDL_GetIOSize(context));
}

inline Sint64 IOStream::GetSize() const { return SDL::GetIOSize(m_resource); }

/**
 * Seek within an IOStream data stream.
 *
 * This function seeks to byte `offset`, relative to `whence`.
 *
 * `whence` may be any of the following values:
 *
 * - `IO_SEEK_SET`: seek from the beginning of data
 * - `IO_SEEK_CUR`: seek relative to current read point
 * - `IO_SEEK_END`: seek relative to the end of data
 *
 * If this stream can not seek, it will return -1.
 *
 * @param context a pointer to an IOStream structure.
 * @param offset an offset in bytes, relative to `whence` location; can be
 *               negative.
 * @param whence any of `IO_SEEK_SET`, `IO_SEEK_CUR`,
 *               `IO_SEEK_END`.
 * @returns the final offset in the data stream after the seek or -1 on
 *          failure; call GetError() for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa IOStream.Tell
 */
inline Sint64 SeekIO(IOStreamParam context, Sint64 offset, IOWhence whence)
{
  return SDL_SeekIO(context, offset, whence);
}

inline Sint64 IOStream::Seek(Sint64 offset, IOWhence whence)
{
  return SDL::SeekIO(m_resource, offset, whence);
}

/**
 * Determine the current read/write offset in an IOStream data stream.
 *
 * IOStream.Tell is actually a wrapper function that calls the IOStream's
 * `seek` method, with an offset of 0 bytes from `IO_SEEK_CUR`, to
 * simplify application development.
 *
 * @param context an IOStream data stream object from which to get the
 *                current offset.
 * @returns the current offset in the stream, or -1 if the information can not
 *          be determined.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa IOStream.Seek
 */
inline Sint64 TellIO(IOStreamParam context) { return SDL_TellIO(context); }

inline Sint64 IOStream::Tell() const { return SDL::TellIO(m_resource); }

/**
 * Read from a data source.
 *
 * This function reads up `size` bytes from the data source to the area
 * pointed at by `ptr`. This function may read less bytes than requested.
 *
 * This function will return zero when the data stream is completely read, and
 * IOStream.GetStatus() will return IO_STATUS_EOF. If zero is returned and
 * the stream is not at EOF, IOStream.GetStatus() will return a different error
 * value and GetError() will offer a human-readable message.
 *
 * @param context a pointer to an IOStream structure.
 * @param ptr a pointer to a buffer to read data into.
 * @param size the number of bytes to read from the data source.
 * @returns the number of bytes read, or 0 on end of file or other failure;
 *          call GetError() for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa IOStream.Write
 * @sa IOStream.GetStatus
 */
inline size_t ReadIO(IOStreamParam context, TargetBytes buf)
{
  return SDL_ReadIO(context, buf.data, buf.size_bytes);
}

inline size_t IOStream::Read(TargetBytes buf)
{
  return SDL::ReadIO(m_resource, std::move(buf));
}

/**
 * Write to an IOStream data stream.
 *
 * This function writes exactly `size` bytes from the area pointed at by `ptr`
 * to the stream. If this fails for any reason, it'll return less than `size`
 * to demonstrate how far the write progressed. On success, it returns `size`.
 *
 * On error, this function still attempts to write as much as possible, so it
 * might return a positive value less than the requested write size.
 *
 * The caller can use IOStream.GetStatus() to determine if the problem is
 * recoverable, such as a non-blocking write that can simply be retried later,
 * or a fatal error.
 *
 * @param context a pointer to an IOStream structure.
 * @param ptr a pointer to a buffer containing data to write.
 * @param size the number of bytes to write.
 * @returns the number of bytes written, which will be less than `size` on
 *          failure; call GetError() for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa IOStream.printf
 * @sa IOStream.Read
 * @sa IOStream.Seek
 * @sa IOStream.Flush
 * @sa IOStream.GetStatus
 */
inline size_t WriteIO(IOStreamParam context, SourceBytes buf)
{
  return SDL_WriteIO(context, buf.data, buf.size_bytes);
}

inline size_t IOStream::Write(SourceBytes buf)
{
  return SDL::WriteIO(m_resource, buf);
}

/**
 * Print to an IOStream data stream.
 *
 * @warning this is not typesafe! Prefer using print() and println()
 *
 * This function does formatted printing to the stream.
 *
 * @param context a pointer to an IOStream structure.
 * @param fmt a printf() style format string.
 * @param ... additional parameters matching % tokens in the `fmt` string, if
 *            any.
 * @returns the number of bytes written or 0 on failure; call GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa IOStream.vprintf
 * @sa IOStream.Write
 */
inline size_t IOprintf(IOStreamParam context,
                       SDL_PRINTF_FORMAT_STRING const char* fmt,
                       ...)
{
  va_list ap;
  size_t result;

  va_start(ap, fmt);
  result = SDL_IOvprintf(context, fmt, ap);
  va_end(ap);

  return result;
}

/**
 * Print to an IOStream data stream.
 *
 * This function does formatted printing to the stream.
 *
 * @param context a pointer to an IOStream structure.
 * @param fmt a printf() style format string.
 * @param ap a variable argument list.
 * @returns the number of bytes written or 0 on failure; call GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa IOStream.printf
 * @sa IOStream.Write
 */
inline size_t IOvprintf(IOStreamParam context,
                        SDL_PRINTF_FORMAT_STRING const char* fmt,
                        va_list ap)
{
  return SDL_IOvprintf(context, fmt, ap);
}

inline size_t IOStream::vprintf(SDL_PRINTF_FORMAT_STRING const char* fmt,
                                va_list ap)
{
  return SDL::IOvprintf(m_resource, fmt, ap);
}

/**
 * Flush any buffered data in the stream.
 *
 * This function makes sure that any buffered data is written to the stream.
 * Normally this isn't necessary but if the stream is a pipe or socket it
 * guarantees that any pending data is sent.
 *
 * @param context IOStream structure to flush.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa IOStream.Open
 * @sa IOStream.Write
 */
inline void FlushIO(IOStreamParam context) { CheckError(SDL_FlushIO(context)); }

inline void IOStream::Flush() { SDL::FlushIO(m_resource); }

/**
 * Load all the data from an SDL data stream.
 *
 * The data is allocated with a zero byte at the end (null terminated) for
 * convenience. This extra byte is not included in the value reported on
 * the returned string.
 *
 * The data should be freed with free().
 *
 * @param src the IOStream to read all available data from.
 * @param closeio if true, calls IOStream.Close() on `src` before returning,
 * even in the case of an error.
 * @returns the data or nullptr on failure; call GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa LoadFile
 * @sa IOStream.SaveFile
 */
inline StringResult LoadFile(IOStreamParam src, bool closeio = true)
{
  size_t datasize = 0;
  auto data = static_cast<char*>(SDL_LoadFile_IO(src, &datasize, closeio));
  return StringResult{CheckError(data), datasize};
}

/**
 * Load all the data from a file path.
 *
 * The data is allocated with a zero byte at the end (null terminated) for
 * convenience. This extra byte is not included in the value reported on
 * the returned string.
 *
 * @param file the path to read all available data from.
 * @returns the data.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa IOStream.LoadFile
 * @sa SaveFile
 */
inline StringResult LoadFile(StringParam file)
{
  size_t datasize = 0;
  auto data = static_cast<char*>(SDL_LoadFile(file, &datasize));
  return StringResult{CheckError(data), datasize};
}

inline StringResult IOStream::LoadFile()
{
  return SDL::LoadFile(m_resource, false);
}

/**
 * Load all the data from a file path.
 *
 * The data is allocated with a zero byte at the end (null terminated) for
 * convenience. This extra byte is not included in the value reported on
 * the returned string.
 *
 * @param file the path to read all available data from.
 * @returns the data.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa IOStream.LoadFile
 * @sa SaveFile
 */
template<class T>
inline OwnArray<T> LoadFileAs(StringParam file)
{
  size_t datasize = 0;
  auto data = static_cast<T*>(SDL_LoadFile(file, &datasize));
  return OwnArray<T>{CheckError(data), datasize / sizeof(T)};
}

/**
 * Save all the data into an SDL data stream.
 *
 * @param src the IOStream to write all data to.
 * @param data the data to be written.
 * @param closeio if true, calls IOStream.Close() on `src` before returning,
 * even in the case of an error.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SaveFile
 * @sa IOStream.LoadFile
 */
inline void SaveFile(IOStreamParam src, SourceBytes data, bool closeio = true)
{
  CheckError(SDL_SaveFile_IO(src, data.data, data.size_bytes, closeio));
}

/**
 * Save all the data into a file path.
 *
 * @param file the path to write all available data into.
 * @param data the data to be written.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa IOStream.SaveFile
 * @sa LoadFile
 */
inline void SaveFile(StringParam file, SourceBytes data)
{
  CheckError(SDL_SaveFile(file, data.data, data.size_bytes));
}

inline void IOStream::SaveFile(SourceBytes data)
{
  SDL::SaveFile(m_resource, data, false);
}

/**
 * Use this function to read a byte from an IOStream.
 *
 * This function will return false when the data stream is completely read,
 * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, IOStream.GetStatus() will return a different
 * error value and GetError() will offer a human-readable message.
 *
 * @param src the IOStream to read from.
 * @param value a pointer filled in with the data read.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Uint8 ReadU8(IOStreamParam src)
{
  Uint8 value;
  CheckError(SDL_ReadU8(src, &value));
  return value;
}

/**
 * Use this function to read a signed byte from an IOStream.
 *
 * This function will return false when the data stream is completely read,
 * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, IOStream.GetStatus() will return a different
 * error value and GetError() will offer a human-readable message.
 *
 * @param src the IOStream to read from.
 * @param value a pointer filled in with the data read.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Sint8 ReadS8(IOStreamParam src)
{
  Sint8 value;
  CheckError(SDL_ReadS8(src, &value));
  return value;
}

/**
 * Use this function to read 16 bits of little-endian data from an
 * IOStream and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, IOStream.GetStatus() will return a different
 * error value and GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Uint16 ReadU16LE(IOStreamParam src)
{
  Uint16 value;
  CheckError(SDL_ReadU16LE(src, &value));
  return value;
}

inline Uint16 IOStream::ReadU16LE() { return SDL::ReadU16LE(m_resource); }

/**
 * Use this function to read 16 bits of little-endian data from an
 * IOStream and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, IOStream.GetStatus() will return a different
 * error value and GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Sint16 ReadS16LE(IOStreamParam src)
{
  Sint16 value;
  CheckError(SDL_ReadS16LE(src, &value));
  return value;
}

inline Sint16 IOStream::ReadS16LE() { return SDL::ReadS16LE(m_resource); }

/**
 * Use this function to read 16 bits of big-endian data from an IOStream
 * and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, IOStream.GetStatus() will return a different
 * error value and GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Uint16 ReadU16BE(IOStreamParam src)
{
  Uint16 value;
  CheckError(SDL_ReadU16BE(src, &value));
  return value;
}

inline Uint16 IOStream::ReadU16BE() { return SDL::ReadU16BE(m_resource); }

/**
 * Use this function to read 16 bits of big-endian data from an IOStream
 * and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, IOStream.GetStatus() will return a different
 * error value and GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Sint16 ReadS16BE(IOStreamParam src)
{
  Sint16 value;
  CheckError(SDL_ReadS16BE(src, &value));
  return value;
}

inline Sint16 IOStream::ReadS16BE() { return SDL::ReadS16BE(m_resource); }

/**
 * Use this function to read 32 bits of little-endian data from an
 * IOStream and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, IOStream.GetStatus() will return a different
 * error value and GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Uint32 ReadU32LE(IOStreamParam src)
{
  Uint32 value;
  CheckError(SDL_ReadU32LE(src, &value));
  return value;
}

inline Uint32 IOStream::ReadU32LE() { return SDL::ReadU32LE(m_resource); }

/**
 * Use this function to read 32 bits of little-endian data from an
 * IOStream and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, IOStream.GetStatus() will return a different
 * error value and GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Sint32 ReadS32LE(IOStreamParam src)
{
  Sint32 value;
  CheckError(SDL_ReadS32LE(src, &value));
  return value;
}

inline Sint32 IOStream::ReadS32LE() { return SDL::ReadS32LE(m_resource); }

/**
 * Use this function to read 32 bits of big-endian data from an IOStream
 * and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, IOStream.GetStatus() will return a different
 * error value and GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Uint32 ReadU32BE(IOStreamParam src)
{
  Uint32 value;
  CheckError(SDL_ReadU32BE(src, &value));
  return value;
}

inline Uint32 IOStream::ReadU32BE() { return SDL::ReadU32BE(m_resource); }

/**
 * Use this function to read 32 bits of big-endian data from an IOStream
 * and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, IOStream.GetStatus() will return a different
 * error value and GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Sint32 ReadS32BE(IOStreamParam src)
{
  Sint32 value;
  CheckError(SDL_ReadS32BE(src, &value));
  return value;
}

inline Sint32 IOStream::ReadS32BE() { return SDL::ReadS32BE(m_resource); }

/**
 * Use this function to read 64 bits of little-endian data from an
 * IOStream and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, IOStream.GetStatus() will return a different
 * error value and GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Uint64 ReadU64LE(IOStreamParam src)
{
  Uint64 value;
  CheckError(SDL_ReadU64LE(src, &value));
  return value;
}

inline Uint64 IOStream::ReadU64LE() { return SDL::ReadU64LE(m_resource); }

/**
 * Use this function to read 64 bits of little-endian data from an
 * IOStream and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, IOStream.GetStatus() will return a different
 * error value and GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Sint64 ReadS64LE(IOStreamParam src)
{
  Sint64 value;
  CheckError(SDL_ReadS64LE(src, &value));
  return value;
}

inline Sint64 IOStream::ReadS64LE() { return SDL::ReadS64LE(m_resource); }

/**
 * Use this function to read 64 bits of big-endian data from an IOStream
 * and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, IOStream.GetStatus() will return a different
 * error value and GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Uint64 ReadU64BE(IOStreamParam src)
{
  Uint64 value;
  CheckError(SDL_ReadU64BE(src, &value));
  return value;
}

inline Uint64 IOStream::ReadU64BE() { return SDL::ReadU64BE(m_resource); }

/**
 * Use this function to read 64 bits of big-endian data from an IOStream
 * and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and IOStream.GetStatus() will return IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, IOStream.GetStatus() will return a different
 * error value and GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Sint64 ReadS64BE(IOStreamParam src)
{
  Sint64 value;
  CheckError(SDL_ReadS64BE(src, &value));
  return value;
}

inline Sint64 IOStream::ReadS64BE() { return SDL::ReadS64BE(m_resource); }

/**
 * Use this function to write a byte to an IOStream.
 *
 * @param dst the IOStream to write to.
 * @param value the byte value to write.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void WriteU8(IOStreamParam dst, Uint8 value)
{
  CheckError(SDL_WriteU8(dst, value));
}

inline void IOStream::WriteU8(Uint8 value) { SDL::WriteU8(m_resource, value); }

/**
 * Use this function to write a signed byte to an IOStream.
 *
 * @param dst the IOStream to write to.
 * @param value the byte value to write.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void WriteS8(IOStreamParam dst, Sint8 value)
{
  CheckError(SDL_WriteS8(dst, value));
}

inline void IOStream::WriteS8(Sint8 value) { SDL::WriteS8(m_resource, value); }

/**
 * Use this function to write 16 bits in native format to an IOStream as
 * little-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in little-endian
 * format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void WriteU16LE(IOStreamParam dst, Uint16 value)
{
  CheckError(SDL_WriteU16LE(dst, value));
}

inline void IOStream::WriteU16LE(Uint16 value)
{
  SDL::WriteU16LE(m_resource, value);
}

/**
 * Use this function to write 16 bits in native format to an IOStream as
 * little-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in little-endian
 * format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void WriteS16LE(IOStreamParam dst, Sint16 value)
{
  CheckError(SDL_WriteS16LE(dst, value));
}

inline void IOStream::WriteS16LE(Sint16 value)
{
  SDL::WriteS16LE(m_resource, value);
}

/**
 * Use this function to write 16 bits in native format to an IOStream as
 * big-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in big-endian format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void WriteU16BE(IOStreamParam dst, Uint16 value)
{
  CheckError(SDL_WriteU16BE(dst, value));
}

inline void IOStream::WriteU16BE(Uint16 value)
{
  SDL::WriteU16BE(m_resource, value);
}

/**
 * Use this function to write 16 bits in native format to an IOStream as
 * big-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in big-endian format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void WriteS16BE(IOStreamParam dst, Sint16 value)
{
  CheckError(SDL_WriteS16BE(dst, value));
}

inline void IOStream::WriteS16BE(Sint16 value)
{
  SDL::WriteS16BE(m_resource, value);
}

/**
 * Use this function to write 32 bits in native format to an IOStream as
 * little-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in little-endian
 * format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void WriteU32LE(IOStreamParam dst, Uint32 value)
{
  CheckError(SDL_WriteU32LE(dst, value));
}

inline void IOStream::WriteU32LE(Uint32 value)
{
  SDL::WriteU32LE(m_resource, value);
}

/**
 * Use this function to write 32 bits in native format to an IOStream as
 * little-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in little-endian
 * format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void WriteS32LE(IOStreamParam dst, Sint32 value)
{
  CheckError(SDL_WriteS32LE(dst, value));
}

inline void IOStream::WriteS32LE(Sint32 value)
{
  SDL::WriteS32LE(m_resource, value);
}

/**
 * Use this function to write 32 bits in native format to an IOStream as
 * big-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in big-endian format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void WriteU32BE(IOStreamParam dst, Uint32 value)
{
  CheckError(SDL_WriteU32BE(dst, value));
}

inline void IOStream::WriteU32BE(Uint32 value)
{
  SDL::WriteU32BE(m_resource, value);
}

/**
 * Use this function to write 32 bits in native format to an IOStream as
 * big-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in big-endian format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void WriteS32BE(IOStreamParam dst, Sint32 value)
{
  CheckError(SDL_WriteS32BE(dst, value));
}

inline void IOStream::WriteS32BE(Sint32 value)
{
  SDL::WriteS32BE(m_resource, value);
}

/**
 * Use this function to write 64 bits in native format to an IOStream as
 * little-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in little-endian
 * format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void WriteU64LE(IOStreamParam dst, Uint64 value)
{
  CheckError(SDL_WriteU64LE(dst, value));
}

inline void IOStream::WriteU64LE(Uint64 value)
{
  SDL::WriteU64LE(m_resource, value);
}

/**
 * Use this function to write 64 bits in native format to an IOStream as
 * little-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in little-endian
 * format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void WriteS64LE(IOStreamParam dst, Sint64 value)
{
  CheckError(SDL_WriteS64LE(dst, value));
}

inline void IOStream::WriteS64LE(Sint64 value)
{
  SDL::WriteS64LE(m_resource, value);
}

/**
 * Use this function to write 64 bits in native format to an IOStream as
 * big-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in big-endian format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void WriteU64BE(IOStreamParam dst, Uint64 value)
{
  CheckError(SDL_WriteU64BE(dst, value));
}

inline void IOStream::WriteU64BE(Uint64 value)
{
  SDL::WriteU64BE(m_resource, value);
}

/**
 * Use this function to write 64 bits in native format to an IOStream as
 * big-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in big-endian format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void WriteS64BE(IOStreamParam dst, Sint64 value)
{
  CheckError(SDL_WriteS64BE(dst, value));
}

inline void IOStream::WriteS64BE(Sint64 value)
{
  SDL::WriteS64BE(m_resource, value);
}

/// @}

/**
 * @defgroup CategoryRect Rectangle Functions
 *
 * Some helper functions for managing rectangles and 2D points, in both
 * integer and floating point versions.
 *
 * @{
 */

using PointRaw = SDL_Point;

using FPointRaw = SDL_FPoint;

using RectRaw = SDL_Rect;

using FRectRaw = SDL_FRect;

// Forward decl
struct FPoint;

// Forward decl
struct Rect;

// Forward decl
struct FRect;

/**
 * The structure that defines a point (using integers).
 *
 * Inspired by
 * https://github.com/libSDL2pp/libSDL2pp/blob/master/SDL2pp/Point.hh
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @cat wrap-extending-struct
 *
 * @sa Rect.GetEnclosingPoints
 * @sa Point.InRect
 */
struct Point : PointRaw
{
  /**
   * Wraps Point.
   *
   * @param p the value to be wrapped
   */
  constexpr Point(const PointRaw& p = {})
    : PointRaw(p)
  {
  }

  /**
   * Constructs from its fields.
   *
   * @param x the value for x.
   * @param y the value for y.
   */
  constexpr Point(int x, int y)
    : PointRaw{x, y}
  {
  }

  /**
   * Wraps Point.
   *
   * @param p the value to be wrapped
   */
  constexpr explicit Point(const FPointRaw& p)
    : SDL_Point{int(p.x), int(p.y)}
  {
  }

  /// Compares with the underlying type
  constexpr bool operator==(const PointRaw& other) const
  {
    return x == other.x && y == other.y;
  }

  /// Compares with the underlying type
  constexpr bool operator==(const Point& other) const
  {
    return *this == (const PointRaw&)(other);
  }

  /**
   * Check if valid.
   *
   * @returns True if valid state, false otherwise.
   */
  constexpr explicit operator bool() const { return *this != PointRaw{}; }

  /**
   * Get x coordinate
   *
   * @returns x coordinate
   */
  constexpr int GetX() const { return x; }

  /**
   * Set the x coordinate.
   *
   * @param newX the new x coordinate.
   * @returns Reference to self.
   */
  constexpr Point& SetX(int newX)
  {
    x = newX;
    return *this;
  }

  /**
   * Get y coordinate
   *
   * @returns y coordinate
   */
  constexpr int GetY() const { return y; }

  /**
   * Set the y coordinate.
   *
   * @param newY the new y coordinate.
   * @returns Reference to self.
   */
  constexpr Point& SetY(int newY)
  {
    y = newY;
    return *this;
  }

  /**
   * Determine whether a point resides inside a rectangle.
   *
   * A point is considered part of a rectangle if both `p` and `r` are not
   * nullptr, and `p`'s x and y coordinates are >= to the rectangle's top left
   * corner, and < the rectangle's x+w and y+h. So a 1x1 rectangle considers
   * point (0,0) as "inside" and (0,1) as not.
   *
   * Note that this is a forced-inline function in a header, and not a public
   * API function available in the SDL library (which is to say, the code is
   * embedded in the calling program and the linker and dynamic loader will not
   * be able to find this function inside SDL itself).
   *
   * @param r the rectangle to test.
   * @returns true if this is contained by `r`, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool InRect(const RectRaw& r) const;

  /**
   * Get point's memberwise negation
   *
   * @returns New Point representing memberwise negation
   *
   */
  constexpr Point operator-() const { return Point(-x, -y); }

  /**
   * Get point's memberwise addition with another point
   *
   * @param[in] other Point to add
   *
   * @returns New Point representing memberwise addition with another point
   *
   */
  constexpr Point operator+(const Point& other) const
  {
    return Point(x + other.x, y + other.y);
  }

  /**
   * Get point's memberwise subtraction with another point
   *
   * @param[in] other Point to subtract
   *
   * @returns New Point representing memberwise subtraction of another point
   *
   */
  constexpr Point operator-(const Point& other) const
  {
    return Point(x - other.x, y - other.y);
  }

  /**
   * Get point's memberwise division by an integer
   *
   * @param[in] value Divisor
   *
   * @returns New Point representing memberwise division of
   *          point by an integer
   *
   */
  constexpr Point operator/(int value) const
  {
    return Point(x / value, y / value);
  }

  /**
   * Get point's memberwise division by an integer
   *
   * @param[in] value Divisor
   *
   * @returns New Point representing memberwise division of
   *          point by an integer
   *
   */
  constexpr FPoint operator/(float value) const;

  /**
   * Get point's memberwise division by another point
   *
   * @param[in] other Divisor
   *
   * @returns New Point representing memberwise division of
   *          point by another point
   *
   */
  constexpr Point operator/(const Point& other) const
  {
    return Point(x / other.x, y / other.y);
  }

  /**
   * Get point's memberwise remainder from division
   *        by an integer
   *
   * @param[in] value Divisor
   *
   * @returns New Point representing memberwise remainder
   *          from division by an integer
   *
   */
  constexpr Point operator%(int value) const
  {
    return Point(x % value, y % value);
  }

  /**
   * Get point's memberwise remainder from division
   *        by another point
   *
   * @param[in] other Divisor
   *
   * @returns New Point representing memberwise remainder
   *          from division by another point
   *
   */
  constexpr Point operator%(const Point& other) const
  {
    return Point(x % other.x, y % other.y);
  }

  /**
   * Get point's memberwise multiplication by an
   *        integer
   *
   * @param[in] value Multiplier
   *
   * @returns New Point representing memberwise multiplication
   *          of point by an integer
   *
   */
  constexpr Point operator*(int value) const
  {
    return Point(x * value, y * value);
  }

  /**
   * Get point's memberwise multiplication by an
   *        integer
   *
   * @param[in] value Multiplier
   *
   * @returns New Point representing memberwise multiplication
   *          of point by an integer
   *
   */
  constexpr FPoint operator*(float value) const;

  /**
   * Get point's memberwise multiplication by another
   *        point
   *
   * @param[in] other Multiplier
   *
   * @returns New Point representing memberwise multiplication
   *          of point by another point
   *
   */
  constexpr Point operator*(const Point& other) const
  {
    return Point(x * other.x, y * other.y);
  }

  /**
   * Memberwise add another point
   *
   * @param[in] other Point to add to the current one
   *
   * @returns Reference to self
   *
   */
  constexpr Point& operator+=(const Point& other)
  {
    x += other.x;
    y += other.y;
    return *this;
  }

  /**
   * Memberwise subtract another point
   *
   * @param[in] other Point to subtract from the current one
   *
   * @returns Reference to self
   *
   */
  constexpr Point& operator-=(const Point& other)
  {
    x -= other.x;
    y -= other.y;
    return *this;
  }

  /**
   * Memberwise divide by an integer
   *
   * @param[in] value Divisor
   *
   * @returns Reference to self
   *
   */
  constexpr Point& operator/=(int value)
  {
    x /= value;
    y /= value;
    return *this;
  }

  /**
   * Memberwise divide by another point
   *
   * @param[in] other Divisor
   *
   * @returns Reference to self
   *
   */
  constexpr Point& operator/=(const Point& other)
  {
    x /= other.x;
    y /= other.y;
    return *this;
  }

  /**
   * Memberwise remainder from division by an integer
   *
   * @param[in] value Divisor
   *
   * @returns Reference to self
   *
   */
  constexpr Point& operator%=(int value)
  {
    x %= value;
    y %= value;
    return *this;
  }

  /**
   * Memberwise remainder from division by another
   *        point
   *
   * @param[in] other Divisor
   *
   * @returns Reference to self
   *
   */
  constexpr Point& operator%=(const Point& other)
  {
    x %= other.x;
    y %= other.y;
    return *this;
  }

  /**
   * Memberwise multiply by an integer
   *
   * @param[in] value Multiplier
   *
   * @returns Reference to self
   *
   */
  constexpr Point& operator*=(int value)
  {
    x *= value;
    y *= value;
    return *this;
  }

  /**
   * Memberwise multiply by another point
   *
   * @param[in] other Multiplier
   *
   * @returns Reference to self
   *
   */
  constexpr Point& operator*=(const Point& other)
  {
    x *= other.x;
    y *= other.y;
    return *this;
  }

  /**
   * Get a point with coordinates modified so it fits
   *        into a given rect
   *
   * @param[in] rect Rectangle to clamp with
   *
   * @returns Clamped point
   *
   */
  constexpr Point GetClamped(const Rect& rect) const;

  /**
   * Clamp point coordinates to make it fit into a
   *        given rect
   *
   * @param[in] rect Rectangle to clamp with
   *
   * @returns Reference to self
   *
   */
  constexpr Point& Clamp(const Rect& rect);

  /**
   * Get a point wrapped within a specified rect
   *
   * @param[in] rect Rectangle to wrap with
   *
   * @returns Wrapped point
   *
   */
  constexpr Point GetWrapped(const Rect& rect) const;

  /**
   * Wrap point coordinates within a specified rect
   *
   * @param[in] rect Rectangle to wrap with
   *
   * @returns Reference to self
   *
   */
  constexpr Point& Wrap(const Rect& rect);

  /**
   * Converts to FPoint
   *
   * @return FPoint
   */
  constexpr operator FPoint() const;
};

/**
 * The structure that defines a point (using floating point values).
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @cat wrap-extending-struct
 *
 * @sa FRect.GetEnclosingPoints
 * @sa FPoint.InRect
 */
struct FPoint : FPointRaw
{
  /**
   * Wraps FPoint.
   *
   * @param p the value to be wrapped
   */
  constexpr FPoint(const FPointRaw& p = {})
    : FPointRaw(p)
  {
  }

  /**
   * Constructs from its fields.
   *
   * @param x the value for x.
   * @param y the value for y.
   */
  constexpr FPoint(float x, float y)
    : FPointRaw{x, y}
  {
  }

  /// Compares with the underlying type
  constexpr bool operator==(const FPointRaw& other) const
  {
    return x == other.x && y == other.y;
  }

  /// Compares with the underlying type
  constexpr bool operator==(const FPoint& other) const
  {
    return *this == (const FPointRaw&)(other);
  }

  /**
   * Check if valid.
   *
   * @returns True if valid state, false otherwise.
   */
  constexpr explicit operator bool() const { return *this != FPointRaw{}; }

  /**
   * Get the x coordinate.
   *
   * @returns current x value.
   */
  constexpr float GetX() const { return x; }

  /**
   * Set the x coordinate.
   *
   * @param newX the new x coordinate.
   * @returns Reference to self.
   */
  constexpr FPoint& SetX(float newX)
  {
    x = newX;
    return *this;
  }

  /**
   * Get the y coordinate.
   *
   * @returns current y coordinate.
   */
  constexpr float GetY() const { return y; }

  /**
   * Set the y coordinate.
   *
   * @param newY the new y coordinate.
   * @returns Reference to self.
   */
  constexpr FPoint& SetY(float newY)
  {
    y = newY;
    return *this;
  }

  /**
   * Determine whether a point resides inside a floating point rectangle.
   *
   * A point is considered part of a rectangle if both `p` and `r` are not
   * nullptr, and `p`'s x and y coordinates are >= to the rectangle's top left
   * corner, and <= the rectangle's x+w and y+h. So a 1x1 rectangle considers
   * point (0,0) and (0,1) as "inside" and (0,2) as not.
   *
   * Note that this is a forced-inline function in a header, and not a public
   * API function available in the SDL library (which is to say, the code is
   * embedded in the calling program and the linker and dynamic loader will not
   * be able to find this function inside SDL itself).
   *
   * @param r the rectangle to test.
   * @returns true if this is contained by `r`, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool InRect(const FRectRaw& r) const;

  /**
   * Get point's memberwise negation
   *
   * @returns New Point representing memberwise negation
   *
   */
  constexpr FPoint operator-() const { return FPoint(-x, -y); }

  /**
   * Get point's memberwise addition with another point
   *
   * @param[in] other Point to add
   *
   * @returns New Point representing memberwise addition with another point
   *
   */
  constexpr FPoint operator+(const FPoint& other) const
  {
    return FPoint(x + other.x, y + other.y);
  }

  /**
   * Get point's memberwise subtraction with another point
   *
   * @param[in] other Point to subtract
   *
   * @returns New Point representing memberwise subtraction of another point
   *
   */
  constexpr FPoint operator-(const FPoint& other) const
  {
    return FPoint(x - other.x, y - other.y);
  }

  /**
   * Get point's memberwise division by an float
   *
   * @param[in] value Divisor
   *
   * @returns New Point representing memberwise division of
   *          point by an float
   *
   */
  constexpr FPoint operator/(float value) const
  {
    return FPoint(x / value, y / value);
  }

  /**
   * Get point's memberwise division by another point
   *
   * @param[in] other Divisor
   *
   * @returns New Point representing memberwise division of
   *          point by another point
   *
   */
  constexpr FPoint operator/(const FPoint& other) const
  {
    return FPoint(x / other.x, y / other.y);
  }

  /**
   * Get point's memberwise multiplication by an
   *        float
   *
   * @param[in] value Multiplier
   *
   * @returns New Point representing memberwise multiplication
   *          of point by an float
   *
   */
  constexpr FPoint operator*(float value) const
  {
    return FPoint(x * value, y * value);
  }

  /**
   * Get point's memberwise multiplication by another
   *        point
   *
   * @param[in] other Multiplier
   *
   * @returns New Point representing memberwise multiplication
   *          of point by another point
   *
   */
  constexpr FPoint operator*(const FPoint& other) const
  {
    return FPoint(x * other.x, y * other.y);
  }

  /**
   * Memberwise add another point
   *
   * @param[in] other Point to add to the current one
   *
   * @returns Reference to self
   *
   */
  constexpr FPoint& operator+=(const FPoint& other)
  {
    x += other.x;
    y += other.y;
    return *this;
  }

  /**
   * Memberwise subtract another point
   *
   * @param[in] other Point to subtract from the current one
   *
   * @returns Reference to self
   *
   */
  constexpr FPoint& operator-=(const FPoint& other)
  {
    x -= other.x;
    y -= other.y;
    return *this;
  }

  /**
   * Memberwise divide by an float
   *
   * @param[in] value Divisor
   *
   * @returns Reference to self
   *
   */
  constexpr FPoint& operator/=(float value)
  {
    x /= value;
    y /= value;
    return *this;
  }

  /**
   * Memberwise divide by another point
   *
   * @param[in] other Divisor
   *
   * @returns Reference to self
   *
   */
  constexpr FPoint& operator/=(const FPoint& other)
  {
    x /= other.x;
    y /= other.y;
    return *this;
  }

  /**
   * Memberwise multiply by an float
   *
   * @param[in] value Multiplier
   *
   * @returns Reference to self
   *
   */
  constexpr FPoint& operator*=(float value)
  {
    x *= value;
    y *= value;
    return *this;
  }

  /**
   * Memberwise multiply by another point
   *
   * @param[in] other Multiplier
   *
   * @returns Reference to self
   *
   */
  constexpr FPoint& operator*=(const FPoint& other)
  {
    x *= other.x;
    y *= other.y;
    return *this;
  }

  /**
   * Get a point with coordinates modified so it fits
   *        into a given rect
   *
   * @param[in] rect Rectangle to clamp with
   *
   * @returns Clamped point
   *
   */
  constexpr FPoint GetClamped(const FRect& rect) const;

  /**
   * Clamp point coordinates to make it fit into a
   *        given rect
   *
   * @param[in] rect Rectangle to clamp with
   *
   * @returns Reference to self
   *
   */
  constexpr FPoint& Clamp(const FRect& rect);

  /**
   * Get a point wrapped within a specified rect
   *
   * @param[in] rect Rectangle to wrap with
   *
   * @returns Wrapped point
   *
   */
  constexpr FPoint GetWrapped(const FRect& rect) const;

  /**
   * Wrap point coordinates within a specified rect
   *
   * @param[in] rect Rectangle to wrap with
   *
   * @returns Reference to self
   *
   */
  constexpr FPoint& Wrap(const FRect& rect);
};

/**
 * A rectangle, with the origin at the upper left (using integers).
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @cat wrap-extending-struct
 *
 * @sa Rect.Empty
 * @sa Rect.Equal
 * @sa Rect.HasIntersection
 * @sa Rect.GetIntersection
 * @sa Rect.GetLineIntersection
 * @sa Rect.GetUnion
 * @sa Rect.GetEnclosingPoints
 */
struct Rect : RectRaw
{
  /**
   * Wraps Rect.
   *
   * @param r the value to be wrapped
   */
  constexpr Rect(const RectRaw& r = {})
    : RectRaw(r)
  {
  }

  /**
   * Constructs from its fields.
   *
   * @param x the left x.
   * @param y the top y.
   * @param w the width.
   * @param h the height.
   */
  constexpr Rect(int x, int y, int w, int h)
    : RectRaw{x, y, w, h}
  {
  }

  /**
   * Construct from offset and size
   *
   * @param corner the top-left corner
   * @param size the size
   */
  constexpr Rect(const PointRaw& corner, const PointRaw& size)
    : Rect{corner.x, corner.y, size.x, size.y}
  {
  }

  /// Compares with the underlying type
  constexpr bool operator==(const RectRaw& other) const { return Equal(other); }

  /// Compares with the underlying type
  constexpr bool operator==(const Rect& other) const
  {
    return *this == (const RectRaw&)(other);
  }

  /// @sa Empty()
  constexpr explicit operator bool() const { return !Empty(); }

  /**
   * Get left x coordinate.
   *
   * @returns coordinate of the left x
   */
  constexpr int GetX() const { return x; }

  /**
   * Set the left x coordinate.
   *
   * @param newX the new left x.
   * @returns Reference to self.
   */
  constexpr Rect& SetX(int newX)
  {
    x = newX;
    return *this;
  }

  /**
   * Get top y coordinate.
   *
   * @returns coordinate of the top y.
   */
  constexpr int GetY() const { return y; }

  /**
   * Set the top y coordinate.
   *
   * @param newY the new top y.
   * @returns Reference to self.
   */
  constexpr Rect& SetY(int newY)
  {
    y = newY;
    return *this;
  }

  /**
   * Get width of the rect
   *
   * @returns Width of the rect
   */
  constexpr int GetW() const { return w; }

  /**
   * Set the width of the rect.
   *
   * @param newW the new width.
   * @returns Reference to self.
   */
  constexpr Rect& SetW(int newW)
  {
    w = newW;
    return *this;
  }

  /**
   * Get height of the rect
   *
   * @returns Height of the rect
   */
  constexpr int GetH() const { return h; }

  /**
   * Set the height of the rect.
   *
   * @param newH the new height.
   * @returns Reference to self.
   */
  constexpr Rect& SetH(int newH)
  {
    h = newH;
    return *this;
  }

  /**
   * Calculate a minimal rectangle enclosing a set of points.
   *
   * If `clip` is not nullptr then only points inside of the clipping rectangle
   * are considered.
   *
   * @param points a span of SDL_Point structures representing points to be
   *               enclosed.
   * @param clip an SDL_Rect used for clipping or std::nullopt to enclose all
   *             points.
   * @returns a SDL_Rect structure filled in with the minimal enclosing
   *          rectangle or an empty rect if all the points were outside of the
   *          clipping rectangle.
   *
   * @since This function is available since SDL 3.2.0.
   */
  static Rect GetEnclosingPoints(
    SpanRef<const PointRaw> points,
    OptionalRef<const RectRaw> clip = std::nullopt);

  /**
   * Construct the rect from given center coordinates, width and height
   *
   * @param[in] cx X coordinate of the rectangle center
   * @param[in] cy Y coordinate of the rectangle center
   * @param[in] w Width of the rectangle
   * @param[in] h Height of the rectangle
   *
   */
  static constexpr Rect FromCenter(int cx, int cy, int w, int h)
  {
    return Rect(cx - w / 2, cy - h / 2, w, h);
  }

  /**
   * Construct the rect from given center coordinates and size
   *
   * @param[in] center Coordinates of the rectangle center
   * @param[in] size Dimensions of the rectangle
   *
   */
  static constexpr Rect FromCenter(Point center, Point size)
  {
    return Rect(center - size / 2, size);
  }

  /**
   * Construct the rect from given corners coordinates
   *
   * @param[in] x1 X coordinate of the top left rectangle corner
   * @param[in] y1 Y coordinate of the top left rectangle corner
   * @param[in] x2 X coordinate of the bottom right rectangle corner
   * @param[in] y2 Y coordinate of the bottom right rectangle corner
   *
   */
  static constexpr Rect FromCorners(int x1, int y1, int x2, int y2)
  {
    return Rect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);
  }

  /**
   * Construct the rect from given centers coordinates
   *
   * @param[in] p1 Coordinates of the top left rectangle corner
   * @param[in] p2 Coordinates of the bottom right rectangle corner
   *
   */
  static constexpr Rect FromCorners(Point p1, Point p2)
  {
    return Rect(p1, p2 - p1 + Point(1, 1));
  }

  /**
   * Get X coordinate of the rect second corner
   *
   * @returns X coordinate of the rect second corner
   *
   */
  constexpr int GetX2() const { return x + w - 1; }

  /**
   * Set X coordinate of the rect second corner
   *
   * @param[in] x2 New X coordinate value
   *
   * This modifies rectangle width internally
   *
   * @returns Reference to self
   *
   */
  constexpr Rect& SetX2(int x2)
  {
    w = x2 - x + 1;
    return *this;
  }

  /**
   * Get Y coordinate of the rect second corner
   *
   * @returns Y coordinate of the rect second corner
   *
   */
  constexpr int GetY2() const { return y + h - 1; }

  /**
   * Set Y coordinate of the rect second corner
   *
   * @param[in] y2 New Y coordinate value
   *
   * This modifies rectangle height internally
   *
   * @returns Reference to self
   *
   */
  constexpr Rect& SetY2(int y2)
  {
    h = y2 - y + 1;
    return *this;
  }

  /**
   * Get top left corner of the rect
   *
   * @returns Top left corner of the rect
   *
   */
  constexpr Point GetTopLeft() const { return Point(x, y); }

  /**
   * Get top right corner of the rect
   *
   * @returns Top right corner of the rect
   *
   */
  constexpr Point GetTopRight() const { return Point(GetX2(), y); }

  /**
   * Get bottom left corner of the rect
   *
   * @returns bottom left corner of the rect
   *
   */
  constexpr Point GetBottomLeft() const { return Point(x, GetY2()); }

  /**
   * Get bottom right corner of the rect
   *
   * @returns Bottom right corner of the rect
   *
   */
  constexpr Point GetBottomRight() const { return Point(GetX2(), GetY2()); }

  /**
   * Get size of the rect
   *
   * @returns Size of the rect
   *
   */
  constexpr Point GetSize() const { return Point(w, h); }

  /**
   * Get centroid of the rect
   *
   * @returns Centroid of the rect
   *
   */
  constexpr Point GetCentroid() const { return Point(x + w / 2, y + h / 2); }

  /**
   * Calculate the intersection of a rectangle and line segment
   *
   * @param[in,out] p1 Starting coordinates of the line
   * @param[in,out] p2 Ending coordinates of the line
   *
   * @returns True if there is an intersection, false otherwise
   *
   * This function is used to clip a line segment to a
   * rectangle. A line segment contained entirely within the
   * rectangle or that does not intersect will remain unchanged.
   * A line segment that crosses the rectangle at either or both
   * ends will be clipped to the boundary of the rectangle and
   * the new coordinates saved in p1 and/or p2 as necessary.
   *
   */
  bool GetLineIntersection(PointRaw* p1, PointRaw* p2) const
  {
    return GetLineIntersection(p1 ? &p1->x : nullptr,
                               p1 ? &p1->y : nullptr,
                               p2 ? &p2->x : nullptr,
                               p2 ? &p2->y : nullptr);
  }

  /**
   * Calculate the intersection of a rectangle and line segment.
   *
   * This function is used to clip a line segment to a rectangle. A line segment
   * contained entirely within the rectangle or that does not intersect will
   * remain unchanged. A line segment that crosses the rectangle at either or
   * both ends will be clipped to the boundary of the rectangle and the new
   * coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.
   *
   * @param X1 a pointer to the starting X-coordinate of the line.
   * @param Y1 a pointer to the starting Y-coordinate of the line.
   * @param X2 a pointer to the ending X-coordinate of the line.
   * @param Y2 a pointer to the ending Y-coordinate of the line.
   * @returns true if there is an intersection, false otherwise.
   *
   * @since This function is available since SDL 3.2.0.
   */
  bool GetLineIntersection(int* X1, int* Y1, int* X2, int* Y2) const;

  /**
   * Convert an SDL_Rect to SDL_FRect
   *
   * @return A FRect filled in with the floating point representation of
   *              `rect`.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr operator SDL_FRect() const;

  ///@sa operator ToFRect()
  constexpr operator FRect() const;

  /**
   * Determine whether a rectangle has no area.
   *
   * A rectangle is considered "empty" for this function if `r` is nullptr, or
   * if `r`'s width and/or height are <= 0.
   *
   * Note that this is a forced-inline function in a header, and not a public
   * API function available in the SDL library (which is to say, the code is
   * embedded in the calling program and the linker and dynamic loader will not
   * be able to find this function inside SDL itself).
   *
   * @returns true if the rectangle is "empty", false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool Empty() const;

  /**
   * Determine whether two rectangles are equal.
   *
   * Rectangles are considered equal if both are not nullptr and each of their
   * x, y, width and height match.
   *
   * Note that this is a forced-inline function in a header, and not a public
   * API function available in the SDL library (which is to say, the code is
   * embedded in the calling program and the linker and dynamic loader will not
   * be able to find this function inside SDL itself).
   *
   * @param other the second rectangle to test.
   * @returns true if the rectangles are equal, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool Equal(const RectRaw& other) const;

  /**
   * Check whether the rect contains given point
   *
   * @param p Point to check
   *
   * @returns True if the point is contained in the rect
   *
   */
  constexpr bool Contains(const PointRaw& p) const
  {
    return SDL_PointInRect(&p, this);
  }

  /**
   * Check whether the rect contains given point
   *
   * @param other Point to check
   *
   * @returns True if the point is contained in the rect
   *
   */
  constexpr bool Contains(const RectRaw& other) const
  {
    return GetUnion(other) == *this;
  }

  /**
   * Determine whether two rectangles intersect.
   *
   * @param other an SDL_Rect structure representing the second rectangle.
   * @returns true if there is an intersection, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Rect.GetIntersection
   */
  constexpr bool HasIntersection(const RectRaw& other) const;

  /**
   * Calculate the intersection of two rectangles.
   *
   * If `result` is nullptr then this function will return false.
   *
   * @param other an SDL_Rect structure representing the second rectangle.
   * @returns an SDL_Rect structure filled in with the intersection of
   *               if there is intersection, std::nullopt otherwise.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Rect.HasIntersection
   */
  constexpr std::optional<Rect> GetIntersection(const RectRaw& other) const;

  /**
   * Calculate the union of two rectangles.
   *
   * @param other an SDL_Rect structure representing the second rectangle.
   * @returns Rect representing union of two rectangles
   * @throws Error on failure.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr Rect GetUnion(const RectRaw& other) const;

  /**
   * Get a rect extended by specified amount of pixels
   *
   * @param[in] amount Number of pixels to extend by
   *
   * @returns Extended rect
   *
   */
  constexpr Rect GetExtension(unsigned int amount) const
  {
    Rect r = *this;
    r.Extend(amount);
    return r;
  }

  /**
   * Get a rect extended by specified amount of pixels
   *
   * @param[in] hAmount Number of pixels to extend by
   *                    in horizontal direction
   * @param[in] vAmount Number of pixels to extend by
   *                    in vertical direction
   *
   * @returns Extended rect
   *
   */
  constexpr Rect GetExtension(unsigned int hAmount, unsigned int vAmount) const
  {
    Rect r = *this;
    r.Extend(hAmount, vAmount);
    return r;
  }

  /**
   * Extend a rect by specified amount of pixels
   *
   * @param[in] amount Number of pixels to extend by
   *
   * @returns Reference to self
   *
   */
  constexpr Rect& Extend(unsigned int amount) { return Extend(amount, amount); }

  /**
   * Extend a rect by specified amount of pixels
   *
   * @param[in] hAmount Number of pixels to extend by
   *                    in horizontal direction
   * @param[in] vAmount Number of pixels to extend by
   *                    in vertical direction
   *
   * @returns Reference to self
   *
   */
  constexpr Rect& Extend(unsigned int hAmount, unsigned int vAmount)
  {
    x -= hAmount;
    y -= vAmount;
    w += hAmount * 2;
    h += vAmount * 2;
    return *this;
  }

  /**
   * Get rectangle moved by a given offset
   *
   * @param[in] offset Point specifying an offset
   *
   * @returns Moved rectangle
   *
   */
  constexpr Rect operator+(const Point& offset) const
  {
    return Rect(x + offset.x, y + offset.y, w, h);
  }

  /**
   * Get rectangle moved by an opposite of given offset
   *
   * @param[in] offset Point specifying an offset
   *
   * @returns Moved rectangle
   *
   */
  constexpr Rect operator-(const Point& offset) const
  {
    return Rect(x - offset.x, y - offset.y, w, h);
  }

  /**
   * Move by then given offset
   *
   * @param[in] offset Point specifying an offset
   *
   * @returns Reference to self
   *
   */
  constexpr Rect& operator+=(const Point& offset)
  {
    x += offset.x;
    y += offset.y;
    return *this;
  }

  /**
   * Move by an opposite of the given offset
   *
   * @param[in] offset Point specifying an offset
   *
   * @returns Reference to self
   *
   */
  constexpr Rect& operator-=(const Point& offset)
  {
    x -= offset.x;
    y -= offset.y;
    return *this;
  }
};

/**
 * A rectangle, with the origin at the upper left (using floating point
 * values).
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @cat wrap-extending-struct
 *
 * @sa FRect.Empty
 * @sa FRect.Equal
 * @sa FRect.EqualEpsilon
 * @sa FRect.HasIntersection
 * @sa FRect.GetIntersection
 * @sa FRect.GetLineIntersection
 * @sa FRect.GetUnion
 * @sa FRect.GetEnclosingPoints
 * @sa FPoint.InRect
 */
struct FRect : FRectRaw
{
  /**
   * Wraps FRect.
   *
   * @param r the value to be wrapped
   */
  constexpr FRect(const FRectRaw& r = {})
    : FRectRaw(r)
  {
  }

  /**
   * Constructs from its fields.
   *
   * @param x the left x.
   * @param y the top y.
   * @param w the width.
   * @param h the height.
   */
  constexpr FRect(float x, float y, float w, float h)
    : FRectRaw{x, y, w, h}
  {
  }

  /**
   * Constructs from top-left corner plus size
   */
  constexpr FRect(FPoint corner, FPoint size)
    : FRect{corner.x, corner.y, size.x, size.y}
  {
  }

  /// Compares with the underlying type
  constexpr bool operator==(const FRectRaw& other) const
  {
    return Equal(other);
  }

  /// Compares with the underlying type
  constexpr bool operator==(const FRect& other) const
  {
    return *this == (const FRectRaw&)(other);
  }

  /// @sa Empty()
  constexpr operator bool() const { return !Empty(); }

  /**
   * Get left x coordinate.
   *
   * @returns coordinate of the left x
   */
  constexpr float GetX() const { return x; }

  /**
   * Set the left x coordinate.
   *
   * @param newX the new left x.
   * @returns Reference to self.
   */
  constexpr FRect& SetX(float newX)
  {
    x = newX;
    return *this;
  }

  /**
   * Get top y coordinate.
   *
   * @returns coordinate of the top y.
   */
  constexpr float GetY() const { return y; }

  /**
   * Set the top y coordinate.
   *
   * @param newY the new top y.
   * @returns Reference to self.
   */
  constexpr FRect& SetY(float newY)
  {
    y = newY;
    return *this;
  }

  /**
   * Get width of the rect
   *
   * @returns Width of the rect
   */
  constexpr float GetW() const { return w; }

  /**
   * Set the width of the rect.
   *
   * @param newW the new width.
   * @returns Reference to self.
   */
  constexpr FRect& SetW(float newW)
  {
    w = newW;
    return *this;
  }

  /**
   * Get height of the rect
   *
   * @returns Height of the rect
   */
  constexpr float GetH() const { return h; }

  /**
   * Set the height of the rect.
   *
   * @param newH the new height.
   * @returns Reference to self.
   */
  constexpr FRect& SetH(float newH)
  {
    h = newH;
    return *this;
  }

  /**
   * Calculate a minimal rectangle enclosing a set of points with float
   * precision.
   *
   * If `clip` is not nullptr then only points inside of the clipping rectangle
   * are considered.
   *
   * @param points a span of SDL_Point structures representing points to be
   *               enclosed.
   * @param clip an SDL_Rect used for clipping or std::nullopt to enclose all
   *             points.
   * @returns a FRect structure filled in with the minimal enclosing
   *          rectangle or an empty FRect if all the points were outside of
   *          the clipping rectangle.
   *
   * @since This function is available since SDL 3.2.0.
   */
  static constexpr FRect GetEnclosingPoints(
    SpanRef<const FPointRaw> points,
    OptionalRef<const FRectRaw> clip = std::nullopt);

  /**
   * Construct the rect from given center coordinates, width and height
   *
   * @param[in] cx X coordinate of the rectangle center
   * @param[in] cy Y coordinate of the rectangle center
   * @param[in] w Width of the rectangle
   * @param[in] h Height of the rectangle
   *
   */
  static constexpr FRect FromCenter(float cx, float cy, float w, float h)
  {
    return FRect(cx - w / 2, cy - h / 2, w, h);
  }

  /**
   * Construct the rect from given center coordinates and size
   *
   * @param[in] center Coordinates of the rectangle center
   * @param[in] size Dimensions of the rectangle
   *
   */
  static constexpr FRect FromCenter(FPoint center, FPoint size)
  {
    return FRect(center - size / 2, size);
  }

  /**
   * Construct the rect from given corners coordinates
   *
   * @param[in] x1 X coordinate of the top left rectangle corner
   * @param[in] y1 Y coordinate of the top left rectangle corner
   * @param[in] x2 X coordinate of the bottom right rectangle corner
   * @param[in] y2 Y coordinate of the bottom right rectangle corner
   *
   */
  static constexpr FRect FromCorners(float x1, float y1, float x2, float y2)
  {
    return FRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);
  }

  /**
   * Construct the rect from given centers coordinates
   *
   * @param[in] p1 Coordinates of the top left rectangle corner
   * @param[in] p2 Coordinates of the bottom right rectangle corner
   *
   */
  static constexpr FRect FromCorners(FPoint p1, FPoint p2)
  {
    return FRect(p1, p2 - p1 + FPoint(1, 1));
  }

  /**
   * Get X coordinate of the rect second corner
   *
   * @returns X coordinate of the rect second corner
   *
   */
  constexpr float GetX2() const { return x + w - 1; }

  /**
   * Set X coordinate of the rect second corner
   *
   * @param[in] x2 New X coordinate value
   *
   * This modifies rectangle width internally
   *
   * @returns Reference to self
   *
   */
  constexpr FRect& SetX2(float x2)
  {
    w = x2 - x + 1;
    return *this;
  }

  /**
   * Get Y coordinate of the rect second corner
   *
   * @returns Y coordinate of the rect second corner
   *
   */
  constexpr float GetY2() const { return y + h - 1; }

  /**
   * Set Y coordinate of the rect second corner
   *
   * @param[in] y2 New Y coordinate value
   *
   * This modifies rectangle height internally
   *
   * @returns Reference to self
   *
   */
  constexpr FRect& SetY2(float y2)
  {
    h = y2 - y + 1;
    return *this;
  }

  /**
   * Get top left corner of the rect
   *
   * @returns Top left corner of the rect
   *
   */
  constexpr FPoint GetTopLeft() const { return FPoint(x, y); }

  /**
   * Get top right corner of the rect
   *
   * @returns Top right corner of the rect
   *
   */
  constexpr FPoint GetTopRight() const { return FPoint(GetX2(), y); }

  /**
   * Get bottom left corner of the rect
   *
   * @returns bottom left corner of the rect
   *
   */
  constexpr FPoint GetBottomLeft() const { return FPoint(x, GetY2()); }

  /**
   * Get bottom right corner of the rect
   *
   * @returns Bottom right corner of the rect
   *
   */
  constexpr FPoint GetBottomRight() const { return FPoint(GetX2(), GetY2()); }

  /**
   * Get size of the rect
   *
   * @returns Size of the rect
   *
   */
  constexpr FPoint GetSize() const { return FPoint(w, h); }

  /**
   * Get centroid of the rect
   *
   * @returns Centroid of the rect
   *
   */
  constexpr FPoint GetCentroid() const { return FPoint(x + w / 2, y + h / 2); }

  /**
   * Calculate the intersection of a rectangle and line segment with float
   * precision.
   *
   * This function is used to clip a line segment to a rectangle. A line segment
   * contained entirely within the rectangle or that does not intersect will
   * remain unchanged. A line segment that crosses the rectangle at either or
   * both ends will be clipped to the boundary of the rectangle and the new
   * coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.
   *
   * @param X1 a pointer to the starting X-coordinate of the line.
   * @param Y1 a pointer to the starting Y-coordinate of the line.
   * @param X2 a pointer to the ending X-coordinate of the line.
   * @param Y2 a pointer to the ending Y-coordinate of the line.
   * @returns true if there is an intersection, false otherwise.
   *
   * @since This function is available since SDL 3.2.0.
   */
  bool GetLineIntersection(float* X1, float* Y1, float* X2, float* Y2) const;

  /**
   * Calculate the intersection of a rectangle and line segment
   *
   * @param[in,out] p1 Starting coordinates of the line
   * @param[in,out] p2 Ending coordinates of the line
   *
   * @returns True if there is an intersection, false otherwise
   *
   * This function is used to clip a line segment to a
   * rectangle. A line segment contained entirely within the
   * rectangle or that does not intersect will remain unchanged.
   * A line segment that crosses the rectangle at either or both
   * ends will be clipped to the boundary of the rectangle and
   * the new coordinates saved in p1 and/or p2 as necessary.
   *
   */
  bool GetLineIntersection(FPoint* p1, FPoint* p2) const
  {
    return GetLineIntersection(p1 ? &p1->x : nullptr,
                               p1 ? &p1->y : nullptr,
                               p2 ? &p2->x : nullptr,
                               p2 ? &p2->y : nullptr);
  }

  /**
   * Determine whether a rectangle has no area.
   *
   * A rectangle is considered "empty" for this function if `r` is NULL, or if
   * `r`'s width and/or height are <= 0.
   *
   * Note that this is a forced-inline function in a header, and not a public
   * API function available in the SDL library (which is to say, the code is
   * embedded in the calling program and the linker and dynamic loader will not
   * be able to find this function inside SDL itself).
   *
   * @returns true if the rectangle is "empty", false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool Empty() const;

  /**
   * Determine whether two floating point rectangles are equal, within some
   * given epsilon.
   *
   * Rectangles are considered equal if both are not nullptr and each of their
   * x, y, width and height are within `epsilon` of each other. If you don't
   * know what value to use for `epsilon`, you should call the FRect.Equal
   * function instead.
   *
   * Note that this is a forced-inline function in a header, and not a public
   * API function available in the SDL library (which is to say, the code is
   * embedded in the calling program and the linker and dynamic loader will not
   * be able to find this function inside SDL itself).
   *
   * @param other the second rectangle to test.
   * @param epsilon the epsilon value for comparison.
   * @returns true if the rectangles are equal, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa FRect.Equal
   */
  constexpr bool EqualEpsilon(const FRectRaw& other, const float epsilon) const;

  /**
   * Determine whether two rectangles are equal.
   *
   * Rectangles are considered equal if both are not nullptr and each of their
   * x, y, width and height are within SDL_FLT_EPSILON of each other. This is
   * often a reasonable way to compare two floating point rectangles and deal
   * with the slight precision variations in floating point calculations that
   * tend to pop up.
   *
   * Note that this is a forced-inline function in a header, and not a public
   * API function available in the SDL library (which is to say, the code is
   * embedded in the calling program and the linker and dynamic loader will not
   * be able to find this function inside SDL itself).
   *
   * @param other the second rectangle to test.
   * @returns true if the rectangles are equal, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa FRect.EqualEpsilon
   */
  constexpr bool Equal(const FRectRaw& other) const;

  /**
   * Check whether the rect contains given point
   *
   * @param p Point to check
   *
   * @returns True if the point is contained in the rect
   *
   */
  constexpr bool Contains(const FPointRaw& p) const
  {
    return SDL_PointInRectFloat(&p, this);
  }

  /**
   * Check whether the rect contains given point
   *
   * @param other Point to check
   *
   * @returns True if the point is contained in the rect
   *
   */
  constexpr bool Contains(const FRectRaw& other) const
  {
    return GetUnion(other) == *this;
  }

  /**
   * Determine whether two rectangles intersect.
   *
   * @param other an SDL_Rect structure representing the second rectangle.
   * @returns true if there is an intersection, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Rect.GetIntersection
   */
  constexpr bool HasIntersection(const FRectRaw& other) const;

  /**
   * Calculate the intersection of two rectangles with float precision.
   *
   * If `result` is nullptr then this function will return false.
   *
   * @param other an SDL_Rect structure representing the second rectangle.
   * @returns an SDL_Rect structure filled in with the intersection of
   *          if there is intersection, an empty FRect otherwise.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa FRect.HasIntersection
   */
  constexpr FRect GetIntersection(const FRectRaw& other) const;

  /**
   * Calculate the union of two rectangles with float precision.
   *
   * @param other an SDL_Rect structure representing the second rectangle.
   * @returns Rect representing union of two rectangles
   * @throws Error on failure.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr FRect GetUnion(const FRectRaw& other) const;

  /**
   * Get a rect extended by specified amount of pixels
   *
   * @param[in] amount Number of pixels to extend by
   *
   * @returns Extended rect
   *
   */
  constexpr FRect GetExtension(unsigned int amount) const
  {
    FRect r = *this;
    r.Extend(amount);
    return r;
  }

  /**
   * Get a rect extended by specified amount of pixels
   *
   * @param[in] hAmount Number of pixels to extend by
   *                    in horizontal direction
   * @param[in] vAmount Number of pixels to extend by
   *                    in vertical direction
   *
   * @returns Extended rect
   *
   */
  constexpr FRect GetExtension(float hAmount, float vAmount) const
  {
    FRect r = *this;
    r.Extend(hAmount, vAmount);
    return r;
  }

  /**
   * Extend a rect by specified amount of pixels
   *
   * @param[in] amount Number of pixels to extend by
   *
   * @returns Reference to self
   *
   */
  constexpr FRect& Extend(float amount) { return Extend(amount, amount); }

  /**
   * Extend a rect by specified amount of pixels
   *
   * @param[in] hAmount Number of pixels to extend by
   *                    in horizontal direction
   * @param[in] vAmount Number of pixels to extend by
   *                    in vertical direction
   *
   * @returns Reference to self
   *
   */
  constexpr FRect& Extend(float hAmount, float vAmount)
  {
    x -= hAmount;
    y -= vAmount;
    w += hAmount * 2;
    h += vAmount * 2;
    return *this;
  }

  /**
   * Get rectangle moved by a given offset
   *
   * @param[in] offset Point specifying an offset
   *
   * @returns Moved rectangle
   *
   */
  constexpr FRect operator+(const FPoint& offset) const
  {
    return FRect(x + offset.x, y + offset.y, w, h);
  }

  /**
   * Get rectangle moved by an opposite of given offset
   *
   * @param[in] offset Point specifying an offset
   *
   * @returns Moved rectangle
   *
   */
  constexpr FRect operator-(const FPoint& offset) const
  {
    return FRect(x - offset.x, y - offset.y, w, h);
  }

  /**
   * Move by then given offset
   *
   * @param[in] offset Point specifying an offset
   *
   * @returns Reference to self
   *
   */
  constexpr FRect& operator+=(const FPoint& offset)
  {
    x += offset.x;
    y += offset.y;
    return *this;
  }

  /**
   * Move by an opposite of the given offset
   *
   * @param[in] offset Point specifying an offset
   *
   * @returns Reference to self
   *
   */
  constexpr FRect& operator-=(const FPoint& offset)
  {
    x -= offset.x;
    y -= offset.y;
    return *this;
  }
};

/**
 * Convert an Rect to FRect
 *
 * @param rect a pointer to an Rect.
 * @param frect a pointer filled in with the floating point representation of
 *              `rect`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
constexpr FRect RectToFRect(const RectRaw& rect)
{
  FRect frect;
  SDL_RectToFRect(&rect, &frect);
  return frect;
}

constexpr Rect::operator SDL_FRect() const { return RectToFRect(*this); }

/**
 * Determine whether a point resides inside a rectangle.
 *
 * A point is considered part of a rectangle if both `p` and `r` are not
 * nullptr, and `p`'s x and y coordinates are >= to the rectangle's top left
 * corner, and < the rectangle's x+w and y+h. So a 1x1 rectangle considers point
 * (0,0) as "inside" and (0,1) as not.
 *
 * Note that this is a forced-inline function in a header, and not a public
 * API function available in the SDL library (which is to say, the code is
 * embedded in the calling program and the linker and dynamic loader will not
 * be able to find this function inside SDL itself).
 *
 * @param p the point to test.
 * @param r the rectangle to test.
 * @returns true if `p` is contained by `r`, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
constexpr bool PointInRect(const PointRaw& p, const RectRaw& r)
{
  return SDL_PointInRect(&p, &r);
}

constexpr bool Point::InRect(const RectRaw& r) const
{
  return SDL::PointInRect(*this, r);
}

/**
 * Determine whether a rectangle has no area.
 *
 * A rectangle is considered "empty" for this function if `r` is nullptr, or if
 * `r`'s width and/or height are <= 0.
 *
 * Note that this is a forced-inline function in a header, and not a public
 * API function available in the SDL library (which is to say, the code is
 * embedded in the calling program and the linker and dynamic loader will not
 * be able to find this function inside SDL itself).
 *
 * @param r the rectangle to test.
 * @returns true if the rectangle is "empty", false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
constexpr bool RectEmpty(const RectRaw& r) { return SDL_RectEmpty(&r); }

constexpr bool Rect::Empty() const { return SDL::RectEmpty(*this); }

/**
 * Determine whether two rectangles are equal.
 *
 * Rectangles are considered equal if both are not nullptr and each of their x,
 * y, width and height match.
 *
 * Note that this is a forced-inline function in a header, and not a public
 * API function available in the SDL library (which is to say, the code is
 * embedded in the calling program and the linker and dynamic loader will not
 * be able to find this function inside SDL itself).
 *
 * @param a the first rectangle to test.
 * @param b the second rectangle to test.
 * @returns true if the rectangles are equal, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
constexpr bool RectsEqual(const RectRaw& a, const RectRaw& b)
{
  return SDL_RectsEqual(&a, &b);
}

constexpr bool Rect::Equal(const RectRaw& other) const
{
  return SDL::RectsEqual(*this, other);
}

/**
 * Determine whether two rectangles intersect.
 *
 * If either pointer is nullptr the function will return false.
 *
 * @param A an Rect structure representing the first rectangle.
 * @param B an Rect structure representing the second rectangle.
 * @returns true if there is an intersection, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Rect.GetIntersection
 */
constexpr bool HasRectIntersection(const RectRaw& A, const RectRaw& B)
{
  return SDL_HasRectIntersection(&A, &B);
}

constexpr bool Rect::HasIntersection(const RectRaw& other) const
{
  return SDL::HasRectIntersection(*this, other);
}

/**
 * Calculate the intersection of two rectangles.
 *
 * If `result` is nullptr then this function will return false.
 *
 * @param A an Rect structure representing the first rectangle.
 * @param B an Rect structure representing the second rectangle.
 * @param result an Rect structure filled in with the intersection of
 *               rectangles `A` and `B`.
 * @returns true if there is an intersection, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Rect.HasIntersection
 */
constexpr std::optional<Rect> GetRectIntersection(const RectRaw& A,
                                                  const RectRaw& B)
{
  if (Rect result; SDL_GetRectIntersection(&A, &B, &result)) return result;
  return {};
}

constexpr std::optional<Rect> Rect::GetIntersection(const RectRaw& other) const
{
  return SDL::GetRectIntersection(*this, other);
}

/**
 * Calculate the union of two rectangles.
 *
 * @param A an Rect structure representing the first rectangle.
 * @param B an Rect structure representing the second rectangle.
 * @param result an Rect structure filled in with the union of rectangles
 *               `A` and `B`.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 */
constexpr Rect GetRectUnion(const RectRaw& A, const RectRaw& B)
{
  Rect r;
  CheckError(SDL_GetRectUnion(&A, &B, &r));
  return r;
}

constexpr Rect Rect::GetUnion(const RectRaw& other) const
{
  return SDL::GetRectUnion(*this, other);
}

/**
 * Calculate a minimal rectangle enclosing a set of points.
 *
 * If `clip` is not nullptr then only points inside of the clipping rectangle
 * are considered.
 *
 * @param points an array of Point structures representing points to be
 *               enclosed.
 * @param count the number of structures in the `points` array.
 * @param clip an Rect used for clipping or nullptr to enclose all points.
 * @returns Result if any points were enclosed or empty rect if all the points
 * were outside of the clipping rectangle.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Rect GetRectEnclosingPoints(SpanRef<const PointRaw> points,
                                   OptionalRef<const RectRaw> clip)
{
  if (Rect result;
      SDL_GetRectEnclosingPoints(points.data(), points.size(), clip, &result)) {
    return result;
  }
  return {};
}

inline Rect Rect::GetEnclosingPoints(SpanRef<const PointRaw> points,
                                     OptionalRef<const RectRaw> clip)
{
  return SDL::GetRectEnclosingPoints(points, clip);
}

/**
 * Calculate the intersection of a rectangle and line segment.
 *
 * This function is used to clip a line segment to a rectangle. A line segment
 * contained entirely within the rectangle or that does not intersect will
 * remain unchanged. A line segment that crosses the rectangle at either or
 * both ends will be clipped to the boundary of the rectangle and the new
 * coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.
 *
 * @param rect an Rect structure representing the rectangle to intersect.
 * @param X1 a pointer to the starting X-coordinate of the line.
 * @param Y1 a pointer to the starting Y-coordinate of the line.
 * @param X2 a pointer to the ending X-coordinate of the line.
 * @param Y2 a pointer to the ending Y-coordinate of the line.
 * @returns true if there is an intersection, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline bool GetRectAndLineIntersection(const RectRaw& rect,
                                       int* X1,
                                       int* Y1,
                                       int* X2,
                                       int* Y2)
{
  return SDL_GetRectAndLineIntersection(&rect, X1, Y1, X2, Y2);
}

inline bool Rect::GetLineIntersection(int* X1, int* Y1, int* X2, int* Y2) const
{
  return SDL::GetRectAndLineIntersection(*this, X1, Y1, X2, Y2);
}

/**
 * Determine whether a point resides inside a floating point rectangle.
 *
 * A point is considered part of a rectangle if both `p` and `r` are not
 * nullptr, and `p`'s x and y coordinates are >= to the rectangle's top left
 * corner, and <= the rectangle's x+w and y+h. So a 1x1 rectangle considers
 * point (0,0) and (0,1) as "inside" and (0,2) as not.
 *
 * Note that this is a forced-inline function in a header, and not a public
 * API function available in the SDL library (which is to say, the code is
 * embedded in the calling program and the linker and dynamic loader will not
 * be able to find this function inside SDL itself).
 *
 * @param p the point to test.
 * @param r the rectangle to test.
 * @returns true if `p` is contained by `r`, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
constexpr bool PointInRectFloat(const FPointRaw& p, const FRectRaw& r)
{
  return SDL_PointInRectFloat(&p, &r);
}

constexpr bool FPoint::InRect(const FRectRaw& r) const
{
  return SDL::PointInRectFloat(*this, r);
}

/**
 * Determine whether a floating point rectangle can contain any point.
 *
 * A rectangle is considered "empty" for this function if `r` is nullptr, or
 * if `r`'s width and/or height are < 0.0f.
 *
 * Note that this is a forced-inline function in a header, and not a public
 * API function available in the SDL library (which is to say, the code is
 * embedded in the calling program and the linker and dynamic loader will not
 * be able to find this function inside SDL itself).
 *
 * @param r the rectangle to test.
 * @returns true if the rectangle is "empty", false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
constexpr bool RectEmptyFloat(const FRectRaw& r)
{
  return SDL_RectEmptyFloat(&r);
}

constexpr bool FRect::Empty() const { return SDL::RectEmptyFloat(*this); }

/**
 * Determine whether two floating point rectangles are equal, within some
 * given epsilon.
 *
 * Rectangles are considered equal if both are not nullptr and each of their
 * x, y, width and height are within `epsilon` of each other. If you don't
 * know what value to use for `epsilon`, you should call the FRect.Equal
 * function instead.
 *
 * Note that this is a forced-inline function in a header, and not a public
 * API function available in the SDL library (which is to say, the code is
 * embedded in the calling program and the linker and dynamic loader will not
 * be able to find this function inside SDL itself).
 *
 * @param a the first rectangle to test.
 * @param b the second rectangle to test.
 * @param epsilon the epsilon value for comparison.
 * @returns true if the rectangles are equal, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa FRect.Equal
 */
constexpr bool RectsEqualEpsilon(const FRectRaw& a,
                                 const FRectRaw& b,
                                 const float epsilon)
{
  return SDL_RectsEqualEpsilon(&a, &b, epsilon);
}

constexpr bool FRect::EqualEpsilon(const FRectRaw& other,
                                   const float epsilon) const
{
  return SDL::RectsEqualEpsilon(*this, other, epsilon);
}

/**
 * Determine whether two floating point rectangles are equal, within a default
 * epsilon.
 *
 * Rectangles are considered equal if both are not nullptr and each of their
 * x, y, width and height are within SDL_FLT_EPSILON of each other. This is
 * often a reasonable way to compare two floating point rectangles and deal
 * with the slight precision variations in floating point calculations that
 * tend to pop up.
 *
 * Note that this is a forced-inline function in a header, and not a public
 * API function available in the SDL library (which is to say, the code is
 * embedded in the calling program and the linker and dynamic loader will not
 * be able to find this function inside SDL itself).
 *
 * @param a the first rectangle to test.
 * @param b the second rectangle to test.
 * @returns true if the rectangles are equal, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa FRect.EqualEpsilon
 */
constexpr bool RectsEqualFloat(const FRectRaw& a, const FRectRaw& b)
{
  return SDL_RectsEqualFloat(&a, &b);
}

constexpr bool FRect::Equal(const FRectRaw& other) const
{
  return SDL::RectsEqualFloat(*this, other);
}

/**
 * Determine whether two rectangles intersect with float precision.
 *
 * If either pointer is nullptr the function will return false.
 *
 * @param A an FRect structure representing the first rectangle.
 * @param B an FRect structure representing the second rectangle.
 * @returns true if there is an intersection, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Rect.GetIntersection
 */
constexpr bool HasRectIntersectionFloat(const FRectRaw& A, const FRectRaw& B)
{
  return SDL_HasRectIntersectionFloat(&A, &B);
}

constexpr bool FRect::HasIntersection(const FRectRaw& other) const
{
  return SDL::HasRectIntersectionFloat(*this, other);
}

/**
 * Calculate the intersection of two rectangles with float precision.
 *
 * If `result` is nullptr then this function will return false.
 *
 * @param A an FRect structure representing the first rectangle.
 * @param B an FRect structure representing the second rectangle.
 * @param result an FRect structure filled in with the intersection of
 *               rectangles `A` and `B`.
 * @returns an FRect structure filled in with the intersection of rectangles `A`
 *          and `B`if there is an intersection, an empty FRect otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa FRect.HasIntersection
 */
constexpr FRect GetRectIntersectionFloat(const FRectRaw& A, const FRectRaw& B)
{
  if (FRect r; SDL_GetRectIntersectionFloat(&A, &B, &r)) return r;
  return {};
}

constexpr FRect FRect::GetIntersection(const FRectRaw& other) const
{
  return SDL::GetRectIntersectionFloat(*this, other);
}

/**
 * Calculate the union of two rectangles with float precision.
 *
 * @param A an FRect structure representing the first rectangle.
 * @param B an FRect structure representing the second rectangle.
 * @returns result an FRect structure filled in with the union of rectangles
 *          A` and `B`.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 */
constexpr FRect GetRectUnionFloat(const FRectRaw& A, const FRectRaw& B)
{
  FRect r;
  CheckError(SDL_GetRectUnionFloat(&A, &B, &r));
  return r;
}

constexpr FRect FRect::GetUnion(const FRectRaw& other) const
{
  return SDL::GetRectUnionFloat(*this, other);
}

/**
 * Calculate a minimal rectangle enclosing a set of points with float
 * precision.
 *
 * If `clip` is not nullptr then only points inside of the clipping rectangle
 * are considered.
 *
 * @param points an array of FPoint structures representing points to be
 *               enclosed.
 * @param count the number of structures in the `points` array.
 * @param clip an FRect used for clipping or nullptr to enclose all points.
 * @param result an FRect structure filled in with the minimal enclosing
 *               rectangle.
 * @returns true if any points were enclosed or false if all the points were
 *          outside of the clipping rectangle.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline FRect GetRectEnclosingPointsFloat(SpanRef<const FPointRaw> points,
                                         OptionalRef<const FRectRaw> clip)
{
  if (FRect result; SDL_GetRectEnclosingPointsFloat(
        points.data(), points.size(), clip, &result)) {
    return result;
  }
  return {};
}

constexpr FRect FRect::GetEnclosingPoints(SpanRef<const FPointRaw> points,
                                          OptionalRef<const FRectRaw> clip)
{
  return SDL::GetRectEnclosingPointsFloat(points, clip);
}

/**
 * Calculate the intersection of a rectangle and line segment with float
 * precision.
 *
 * This function is used to clip a line segment to a rectangle. A line segment
 * contained entirely within the rectangle or that does not intersect will
 * remain unchanged. A line segment that crosses the rectangle at either or
 * both ends will be clipped to the boundary of the rectangle and the new
 * coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.
 *
 * @param rect an FRect structure representing the rectangle to intersect.
 * @param X1 a pointer to the starting X-coordinate of the line.
 * @param Y1 a pointer to the starting Y-coordinate of the line.
 * @param X2 a pointer to the ending X-coordinate of the line.
 * @param Y2 a pointer to the ending Y-coordinate of the line.
 * @returns true if there is an intersection, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline bool GetRectAndLineIntersectionFloat(const FRectRaw& rect,
                                            float* X1,
                                            float* Y1,
                                            float* X2,
                                            float* Y2)
{
  return SDL_GetRectAndLineIntersectionFloat(&rect, X1, Y1, X2, Y2);
}

inline bool FRect::GetLineIntersection(float* X1,
                                       float* Y1,
                                       float* X2,
                                       float* Y2) const
{
  return SDL::GetRectAndLineIntersectionFloat(*this, X1, Y1, X2, Y2);
}

/// @}

constexpr Point::operator FPoint() const { return {float(x), float(y)}; }

constexpr FPoint Point::operator/(float value) const
{
  return FPoint(*this) / value;
}
constexpr FPoint Point::operator*(float value) const
{
  return FPoint(*this) * value;
}

constexpr Point Point::GetClamped(const Rect& rect) const
{
  Point p = *this;
  p.Clamp(rect);
  return p;
}

constexpr Point& Point::Clamp(const Rect& rect)
{
  if (x < rect.x) x = rect.x;
  if (x > rect.GetX2()) x = rect.GetX2();
  if (y < rect.y) y = rect.y;
  if (y > rect.GetY2()) y = rect.GetY2();
  return *this;
}

constexpr Point Point::GetWrapped(const Rect& rect) const
{
  Point p = *this;
  p.Wrap(rect);
  return p;
}

constexpr Point& Point::Wrap(const Rect& rect)
{
  if (x < rect.x)
    x = rect.x + rect.w - 1 - (rect.x - x + rect.w - 1) % rect.w;
  else if (x >= rect.x + rect.w)
    x = rect.x + (x - rect.x - rect.w) % rect.w;

  if (y < rect.y)
    y = rect.y + rect.h - 1 - (rect.y - y + rect.h - 1) % rect.h;
  else if (y >= rect.y + rect.h)
    y = rect.y + (y - rect.y - rect.h) % rect.h;

  return *this;
}

constexpr FPoint FPoint::GetClamped(const FRect& rect) const
{
  FPoint p = *this;
  p.Clamp(rect);
  return p;
}

constexpr FPoint& FPoint::Clamp(const FRect& rect)
{
  if (x < rect.x) x = rect.x;
  if (x > rect.GetX2()) x = rect.GetX2();
  if (y < rect.y) y = rect.y;
  if (y > rect.GetY2()) y = rect.GetY2();
  return *this;
}

constexpr FPoint FPoint::GetWrapped(const FRect& rect) const
{
  FPoint p = *this;
  p.Wrap(rect);
  return p;
}

constexpr FPoint& FPoint::Wrap(const FRect& rect)
{
  if (x < rect.x)
    x = rect.x + rect.w - 1 - SDL_fmod(rect.x - x + rect.w - 1, rect.w);
  else if (x >= rect.x + rect.w)
    x = rect.x + SDL_fmod(x - rect.x - rect.w, rect.w);

  if (y < rect.y)
    y = rect.y + rect.h - 1 - SDL_fmod(rect.y - y + rect.h - 1, rect.h);
  else if (y >= rect.y + rect.h)
    y = rect.y + SDL_fmod(y - rect.y - rect.h, rect.h);

  return *this;
}

constexpr Rect::operator FRect() const
{
  return {float(x), float(y), float(w), float(h)};
}

/**
 * @defgroup CategoryScancode Keyboard Scancodes
 *
 * Defines keyboard scancodes.
 *
 * Please refer to the Best Keyboard Practices document for details on what
 * this information means and how best to use it.
 *
 * https://wiki.libsdl.org/SDL3/BestKeyboardPractices
 *
 * @{
 */

using ScancodeRaw = SDL_Scancode;

// Forward decl
struct Keycode;

/**
 * The SDL keyboard scancode representation.
 *
 * An SDL scancode is the physical representation of a key on the keyboard,
 * independent of language and keyboard mapping.
 *
 * Values of this type are used to represent keyboard keys, among other places
 * in the `scancode` field of the KeyboardEvent structure.
 *
 * The values in this enumeration are based on the USB usage page standard:
 * https://usb.org/sites/default/files/hut1_5.pdf
 *
 * @since This enum is available since SDL 3.2.0.
 */
class Scancode
{
  ScancodeRaw m_scancode;

public:
  /**
   * Wraps Scancode.
   *
   * @param scancode the value to be wrapped
   */
  constexpr Scancode(ScancodeRaw scancode = {})
    : m_scancode(scancode)
  {
  }

  /**
   * Get a scancode from a human-readable name.
   *
   * @param name the human-readable scancode name.
   * @post the Scancode, or `SCANCODE_UNKNOWN` if the name wasn't
   *          recognized; call GetError() for more information.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Keycode.Keycode
   * @sa Keycode.GetScancode
   * @sa Scancode.GetName
   */
  Scancode(StringParam name);

  /// Default comparison operator
  constexpr auto operator<=>(const Scancode& other) const = default;

  /// Compares with the underlying type
  constexpr auto operator<=>(ScancodeRaw scancode) const
  {
    return operator<=>(Scancode(scancode));
  }

  /**
   * Unwraps to the underlying Scancode.
   *
   * @returns the underlying ScancodeRaw.
   */
  constexpr operator ScancodeRaw() const { return m_scancode; }

  /**
   * Check if valid.
   *
   * @returns True if valid state, false otherwise.
   */
  constexpr explicit operator bool() const { return m_scancode != 0; }

  /**
   * Set a human-readable name for a scancode.
   *
   * @param name the name to use for the scancode, encoded as UTF-8. The string
   *             is not copied, so the pointer given to this function must stay
   *             valid while SDL is being used.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Scancode.GetName
   */
  void SetName(StringParam name);

  /**
   * Get a human-readable name for a scancode.
   *
   * **Warning**: The returned name is by design not stable across platforms,
   * e.g. the name for `SCANCODE_LGUI` is "Left GUI" under Linux but "Left
   * Windows" under Microsoft Windows, and some scancodes like
   * `SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even
   * scancodes that share names, e.g. `SCANCODE_RETURN` and
   * `SCANCODE_RETURN2` (both called "Return"). This function is therefore
   * unsuitable for creating a stable cross-platform two-way mapping between
   * strings and scancodes.
   *
   * @returns a pointer to the name for the scancode. If the scancode doesn't
   *          have a name this function returns an empty string ("").
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Keycode.GetScancode
   * @sa Scancode.Scancode
   * @sa Scancode.SetName
   */
  const char* GetName() const;
};

constexpr Scancode SCANCODE_UNKNOWN = SDL_SCANCODE_UNKNOWN; ///< UNKNOWN

constexpr Scancode SCANCODE_A = SDL_SCANCODE_A; ///< A

constexpr Scancode SCANCODE_B = SDL_SCANCODE_B; ///< B

constexpr Scancode SCANCODE_C = SDL_SCANCODE_C; ///< C

constexpr Scancode SCANCODE_D = SDL_SCANCODE_D; ///< D

constexpr Scancode SCANCODE_E = SDL_SCANCODE_E; ///< E

constexpr Scancode SCANCODE_F = SDL_SCANCODE_F; ///< F

constexpr Scancode SCANCODE_G = SDL_SCANCODE_G; ///< G

constexpr Scancode SCANCODE_H = SDL_SCANCODE_H; ///< H

constexpr Scancode SCANCODE_I = SDL_SCANCODE_I; ///< I

constexpr Scancode SCANCODE_J = SDL_SCANCODE_J; ///< J

constexpr Scancode SCANCODE_K = SDL_SCANCODE_K; ///< K

constexpr Scancode SCANCODE_L = SDL_SCANCODE_L; ///< L

constexpr Scancode SCANCODE_M = SDL_SCANCODE_M; ///< M

constexpr Scancode SCANCODE_N = SDL_SCANCODE_N; ///< N

constexpr Scancode SCANCODE_O = SDL_SCANCODE_O; ///< O

constexpr Scancode SCANCODE_P = SDL_SCANCODE_P; ///< P

constexpr Scancode SCANCODE_Q = SDL_SCANCODE_Q; ///< Q

constexpr Scancode SCANCODE_R = SDL_SCANCODE_R; ///< R

constexpr Scancode SCANCODE_S = SDL_SCANCODE_S; ///< S

constexpr Scancode SCANCODE_T = SDL_SCANCODE_T; ///< T

constexpr Scancode SCANCODE_U = SDL_SCANCODE_U; ///< U

constexpr Scancode SCANCODE_V = SDL_SCANCODE_V; ///< V

constexpr Scancode SCANCODE_W = SDL_SCANCODE_W; ///< W

constexpr Scancode SCANCODE_X = SDL_SCANCODE_X; ///< X

constexpr Scancode SCANCODE_Y = SDL_SCANCODE_Y; ///< Y

constexpr Scancode SCANCODE_Z = SDL_SCANCODE_Z; ///< Z

constexpr Scancode SCANCODE_1 = SDL_SCANCODE_1; ///< 1

constexpr Scancode SCANCODE_2 = SDL_SCANCODE_2; ///< 2

constexpr Scancode SCANCODE_3 = SDL_SCANCODE_3; ///< 3

constexpr Scancode SCANCODE_4 = SDL_SCANCODE_4; ///< 4

constexpr Scancode SCANCODE_5 = SDL_SCANCODE_5; ///< 5

constexpr Scancode SCANCODE_6 = SDL_SCANCODE_6; ///< 6

constexpr Scancode SCANCODE_7 = SDL_SCANCODE_7; ///< 7

constexpr Scancode SCANCODE_8 = SDL_SCANCODE_8; ///< 8

constexpr Scancode SCANCODE_9 = SDL_SCANCODE_9; ///< 9

constexpr Scancode SCANCODE_0 = SDL_SCANCODE_0; ///< 0

constexpr Scancode SCANCODE_RETURN = SDL_SCANCODE_RETURN; ///< RETURN

constexpr Scancode SCANCODE_ESCAPE = SDL_SCANCODE_ESCAPE; ///< ESCAPE

constexpr Scancode SCANCODE_BACKSPACE = SDL_SCANCODE_BACKSPACE; ///< BACKSPACE

constexpr Scancode SCANCODE_TAB = SDL_SCANCODE_TAB; ///< TAB

constexpr Scancode SCANCODE_SPACE = SDL_SCANCODE_SPACE; ///< SPACE

constexpr Scancode SCANCODE_MINUS = SDL_SCANCODE_MINUS; ///< MINUS

constexpr Scancode SCANCODE_EQUALS = SDL_SCANCODE_EQUALS; ///< EQUALS

constexpr Scancode SCANCODE_LEFTBRACKET =
  SDL_SCANCODE_LEFTBRACKET; ///< LEFTBRACKET

constexpr Scancode SCANCODE_RIGHTBRACKET =
  SDL_SCANCODE_RIGHTBRACKET; ///< RIGHTBRACKET

/**
 * Located at the lower left of the return key on ISO keyboards and at the right
 * end of the QWERTY row on ANSI keyboards.  Produces REVERSE SOLIDUS
 * (backslash) and VERTICAL LINE in a US layout, REVERSE SOLIDUS and VERTICAL
 * LINE in a UK Mac layout, NUMBER SIGN and TILDE in a UK Windows layout, DOLLAR
 * SIGN and POUND SIGN in a Swiss German layout, NUMBER SIGN and APOSTROPHE in a
 * German layout, GRAVE ACCENT and POUND SIGN in a French Mac layout, and
 * ASTERISK and MICRO SIGN in a French Windows layout.
 */
constexpr Scancode SCANCODE_BACKSLASH = SDL_SCANCODE_BACKSLASH;

/**
 * ISO USB keyboards actually use this code instead of 49 for the same key, but
 * all OSes I've seen treat the two codes identically.  So, as an implementor,
 * unless your keyboard generates both of those codes and your OS treats them
 * differently, you should generate SCANCODE_BACKSLASH instead of this code. As
 * a user, you should not rely on this code because SDL will never generate it
 * with most (all?) keyboards.
 */
constexpr Scancode SCANCODE_NONUSHASH = SDL_SCANCODE_NONUSHASH;

constexpr Scancode SCANCODE_SEMICOLON = SDL_SCANCODE_SEMICOLON; ///< SEMICOLON

constexpr Scancode SCANCODE_APOSTROPHE =
  SDL_SCANCODE_APOSTROPHE; ///< APOSTROPHE

/**
 * Located in the top left corner (on both ANSI and ISO keyboards).  Produces
 * GRAVE ACCENT and TILDE in a US Windows layout and in US and UK Mac layouts on
 * ANSI keyboards, GRAVE ACCENT and NOT SIGN in a UK Windows layout, SECTION
 * SIGN and PLUS-MINUS SIGN in US and UK Mac layouts on ISO keyboards, SECTION
 * SIGN and DEGREE SIGN in a Swiss German layout (Mac: only on ISO keyboards),
 * CIRCUMFLEX ACCENT and DEGREE SIGN in a German layout (Mac: only on ISO
 * keyboards), SUPERSCRIPT TWO and TILDE in a French Windows layout, COMMERCIAL
 * AT and NUMBER SIGN in a French Mac layout on ISO keyboards, and LESS-THAN
 * SIGN and GREATER-THAN SIGN in a Swiss German, German, or French Mac layout on
 * ANSI keyboards.
 */
constexpr Scancode SCANCODE_GRAVE = SDL_SCANCODE_GRAVE;

constexpr Scancode SCANCODE_COMMA = SDL_SCANCODE_COMMA; ///< COMMA

constexpr Scancode SCANCODE_PERIOD = SDL_SCANCODE_PERIOD; ///< PERIOD

constexpr Scancode SCANCODE_SLASH = SDL_SCANCODE_SLASH; ///< SLASH

constexpr Scancode SCANCODE_CAPSLOCK = SDL_SCANCODE_CAPSLOCK; ///< CAPSLOCK

constexpr Scancode SCANCODE_F1 = SDL_SCANCODE_F1; ///< F1

constexpr Scancode SCANCODE_F2 = SDL_SCANCODE_F2; ///< F2

constexpr Scancode SCANCODE_F3 = SDL_SCANCODE_F3; ///< F3

constexpr Scancode SCANCODE_F4 = SDL_SCANCODE_F4; ///< F4

constexpr Scancode SCANCODE_F5 = SDL_SCANCODE_F5; ///< F5

constexpr Scancode SCANCODE_F6 = SDL_SCANCODE_F6; ///< F6

constexpr Scancode SCANCODE_F7 = SDL_SCANCODE_F7; ///< F7

constexpr Scancode SCANCODE_F8 = SDL_SCANCODE_F8; ///< F8

constexpr Scancode SCANCODE_F9 = SDL_SCANCODE_F9; ///< F9

constexpr Scancode SCANCODE_F10 = SDL_SCANCODE_F10; ///< F10

constexpr Scancode SCANCODE_F11 = SDL_SCANCODE_F11; ///< F11

constexpr Scancode SCANCODE_F12 = SDL_SCANCODE_F12; ///< F12

constexpr Scancode SCANCODE_PRINTSCREEN =
  SDL_SCANCODE_PRINTSCREEN; ///< PRINTSCREEN

constexpr Scancode SCANCODE_SCROLLLOCK =
  SDL_SCANCODE_SCROLLLOCK; ///< SCROLLLOCK

constexpr Scancode SCANCODE_PAUSE = SDL_SCANCODE_PAUSE; ///< PAUSE

/// insert on PC, help on some Mac keyboards (but does send code 73, not 117)
constexpr Scancode SCANCODE_INSERT = SDL_SCANCODE_INSERT;

constexpr Scancode SCANCODE_HOME = SDL_SCANCODE_HOME; ///< HOME

constexpr Scancode SCANCODE_PAGEUP = SDL_SCANCODE_PAGEUP; ///< PAGEUP

constexpr Scancode SCANCODE_DELETE = SDL_SCANCODE_DELETE; ///< DELETE

constexpr Scancode SCANCODE_END = SDL_SCANCODE_END; ///< END

constexpr Scancode SCANCODE_PAGEDOWN = SDL_SCANCODE_PAGEDOWN; ///< PAGEDOWN

constexpr Scancode SCANCODE_RIGHT = SDL_SCANCODE_RIGHT; ///< RIGHT

constexpr Scancode SCANCODE_LEFT = SDL_SCANCODE_LEFT; ///< LEFT

constexpr Scancode SCANCODE_DOWN = SDL_SCANCODE_DOWN; ///< DOWN

constexpr Scancode SCANCODE_UP = SDL_SCANCODE_UP; ///< UP

constexpr Scancode SCANCODE_NUMLOCKCLEAR =
  SDL_SCANCODE_NUMLOCKCLEAR; ///< num lock on PC, clear on Mac keyboards

constexpr Scancode SCANCODE_KP_DIVIDE = SDL_SCANCODE_KP_DIVIDE; ///< KP_DIVIDE

constexpr Scancode SCANCODE_KP_MULTIPLY =
  SDL_SCANCODE_KP_MULTIPLY; ///< KP_MULTIPLY

constexpr Scancode SCANCODE_KP_MINUS = SDL_SCANCODE_KP_MINUS; ///< KP_MINUS

constexpr Scancode SCANCODE_KP_PLUS = SDL_SCANCODE_KP_PLUS; ///< KP_PLUS

constexpr Scancode SCANCODE_KP_ENTER = SDL_SCANCODE_KP_ENTER; ///< KP_ENTER

constexpr Scancode SCANCODE_KP_1 = SDL_SCANCODE_KP_1; ///< KP_1

constexpr Scancode SCANCODE_KP_2 = SDL_SCANCODE_KP_2; ///< KP_2

constexpr Scancode SCANCODE_KP_3 = SDL_SCANCODE_KP_3; ///< KP_3

constexpr Scancode SCANCODE_KP_4 = SDL_SCANCODE_KP_4; ///< KP_4

constexpr Scancode SCANCODE_KP_5 = SDL_SCANCODE_KP_5; ///< KP_5

constexpr Scancode SCANCODE_KP_6 = SDL_SCANCODE_KP_6; ///< KP_6

constexpr Scancode SCANCODE_KP_7 = SDL_SCANCODE_KP_7; ///< KP_7

constexpr Scancode SCANCODE_KP_8 = SDL_SCANCODE_KP_8; ///< KP_8

constexpr Scancode SCANCODE_KP_9 = SDL_SCANCODE_KP_9; ///< KP_9

constexpr Scancode SCANCODE_KP_0 = SDL_SCANCODE_KP_0; ///< KP_0

constexpr Scancode SCANCODE_KP_PERIOD = SDL_SCANCODE_KP_PERIOD; ///< KP_PERIOD

/**
 * This is the additional key that ISO keyboards have over ANSI ones, located
 * between left shift and Z.  Produces GRAVE ACCENT and TILDE in a US or UK Mac
 * layout, REVERSE SOLIDUS (backslash) and VERTICAL LINE in a US or UK Windows
 * layout, and LESS-THAN SIGN and GREATER-THAN SIGN in a Swiss German, German,
 * or French layout.
 */
constexpr Scancode SCANCODE_NONUSBACKSLASH = SDL_SCANCODE_NONUSBACKSLASH;

constexpr Scancode SCANCODE_APPLICATION =
  SDL_SCANCODE_APPLICATION; ///< windows contextual menu, compose

/**
 * The USB document says this is a status flag, not a physical key - but some
 * Mac keyboards do have a power key.
 */
constexpr Scancode SCANCODE_POWER = SDL_SCANCODE_POWER;

constexpr Scancode SCANCODE_KP_EQUALS = SDL_SCANCODE_KP_EQUALS; ///< KP_EQUALS

constexpr Scancode SCANCODE_F13 = SDL_SCANCODE_F13; ///< F13

constexpr Scancode SCANCODE_F14 = SDL_SCANCODE_F14; ///< F14

constexpr Scancode SCANCODE_F15 = SDL_SCANCODE_F15; ///< F15

constexpr Scancode SCANCODE_F16 = SDL_SCANCODE_F16; ///< F16

constexpr Scancode SCANCODE_F17 = SDL_SCANCODE_F17; ///< F17

constexpr Scancode SCANCODE_F18 = SDL_SCANCODE_F18; ///< F18

constexpr Scancode SCANCODE_F19 = SDL_SCANCODE_F19; ///< F19

constexpr Scancode SCANCODE_F20 = SDL_SCANCODE_F20; ///< F20

constexpr Scancode SCANCODE_F21 = SDL_SCANCODE_F21; ///< F21

constexpr Scancode SCANCODE_F22 = SDL_SCANCODE_F22; ///< F22

constexpr Scancode SCANCODE_F23 = SDL_SCANCODE_F23; ///< F23

constexpr Scancode SCANCODE_F24 = SDL_SCANCODE_F24; ///< F24

constexpr Scancode SCANCODE_EXECUTE = SDL_SCANCODE_EXECUTE; ///< EXECUTE

constexpr Scancode SCANCODE_HELP =
  SDL_SCANCODE_HELP; ///< AL Integrated Help Center.

constexpr Scancode SCANCODE_MENU = SDL_SCANCODE_MENU; ///< Menu (show menu)

constexpr Scancode SCANCODE_SELECT = SDL_SCANCODE_SELECT; ///< SELECT

constexpr Scancode SCANCODE_STOP = SDL_SCANCODE_STOP; ///< AC Stop.

constexpr Scancode SCANCODE_AGAIN = SDL_SCANCODE_AGAIN; ///< AC Redo/Repeat.

constexpr Scancode SCANCODE_UNDO = SDL_SCANCODE_UNDO; ///< AC Undo.

constexpr Scancode SCANCODE_CUT = SDL_SCANCODE_CUT; ///< AC Cut.

constexpr Scancode SCANCODE_COPY = SDL_SCANCODE_COPY; ///< AC Copy.

constexpr Scancode SCANCODE_PASTE = SDL_SCANCODE_PASTE; ///< AC Paste.

constexpr Scancode SCANCODE_FIND = SDL_SCANCODE_FIND; ///< AC Find.

constexpr Scancode SCANCODE_MUTE = SDL_SCANCODE_MUTE; ///< MUTE

constexpr Scancode SCANCODE_VOLUMEUP = SDL_SCANCODE_VOLUMEUP; ///< VOLUMEUP

constexpr Scancode SCANCODE_VOLUMEDOWN =
  SDL_SCANCODE_VOLUMEDOWN; ///< VOLUMEDOWN

constexpr Scancode SCANCODE_KP_COMMA = SDL_SCANCODE_KP_COMMA; ///< KP_COMMA

constexpr Scancode SCANCODE_KP_EQUALSAS400 =
  SDL_SCANCODE_KP_EQUALSAS400; ///< KP_EQUALSAS400

constexpr Scancode SCANCODE_INTERNATIONAL1 =
  SDL_SCANCODE_INTERNATIONAL1; ///< used on Asian keyboards, see footnotes in
                               ///< USB doc

constexpr Scancode SCANCODE_INTERNATIONAL2 =
  SDL_SCANCODE_INTERNATIONAL2; ///< INTERNATIONAL2

constexpr Scancode SCANCODE_INTERNATIONAL3 =
  SDL_SCANCODE_INTERNATIONAL3; ///< Yen.

constexpr Scancode SCANCODE_INTERNATIONAL4 =
  SDL_SCANCODE_INTERNATIONAL4; ///< INTERNATIONAL4

constexpr Scancode SCANCODE_INTERNATIONAL5 =
  SDL_SCANCODE_INTERNATIONAL5; ///< INTERNATIONAL5

constexpr Scancode SCANCODE_INTERNATIONAL6 =
  SDL_SCANCODE_INTERNATIONAL6; ///< INTERNATIONAL6

constexpr Scancode SCANCODE_INTERNATIONAL7 =
  SDL_SCANCODE_INTERNATIONAL7; ///< INTERNATIONAL7

constexpr Scancode SCANCODE_INTERNATIONAL8 =
  SDL_SCANCODE_INTERNATIONAL8; ///< INTERNATIONAL8

constexpr Scancode SCANCODE_INTERNATIONAL9 =
  SDL_SCANCODE_INTERNATIONAL9; ///< INTERNATIONAL9

constexpr Scancode SCANCODE_LANG1 =
  SDL_SCANCODE_LANG1; ///< Hangul/English toggle.

constexpr Scancode SCANCODE_LANG2 = SDL_SCANCODE_LANG2; ///< Hanja conversion.

constexpr Scancode SCANCODE_LANG3 = SDL_SCANCODE_LANG3; ///< Katakana.

constexpr Scancode SCANCODE_LANG4 = SDL_SCANCODE_LANG4; ///< Hiragana.

constexpr Scancode SCANCODE_LANG5 = SDL_SCANCODE_LANG5; ///< Zenkaku/Hankaku.

constexpr Scancode SCANCODE_LANG6 = SDL_SCANCODE_LANG6; ///< reserved

constexpr Scancode SCANCODE_LANG7 = SDL_SCANCODE_LANG7; ///< reserved

constexpr Scancode SCANCODE_LANG8 = SDL_SCANCODE_LANG8; ///< reserved

constexpr Scancode SCANCODE_LANG9 = SDL_SCANCODE_LANG9; ///< reserved

constexpr Scancode SCANCODE_ALTERASE = SDL_SCANCODE_ALTERASE; ///< Erase-Eaze.

constexpr Scancode SCANCODE_SYSREQ = SDL_SCANCODE_SYSREQ; ///< SYSREQ

constexpr Scancode SCANCODE_CANCEL = SDL_SCANCODE_CANCEL; ///< AC Cancel.

constexpr Scancode SCANCODE_CLEAR = SDL_SCANCODE_CLEAR; ///< CLEAR

constexpr Scancode SCANCODE_PRIOR = SDL_SCANCODE_PRIOR; ///< PRIOR

constexpr Scancode SCANCODE_RETURN2 = SDL_SCANCODE_RETURN2; ///< RETURN2

constexpr Scancode SCANCODE_SEPARATOR = SDL_SCANCODE_SEPARATOR; ///< SEPARATOR

constexpr Scancode SCANCODE_OUT = SDL_SCANCODE_OUT; ///< OUT

constexpr Scancode SCANCODE_OPER = SDL_SCANCODE_OPER; ///< OPER

constexpr Scancode SCANCODE_CLEARAGAIN =
  SDL_SCANCODE_CLEARAGAIN; ///< CLEARAGAIN

constexpr Scancode SCANCODE_CRSEL = SDL_SCANCODE_CRSEL; ///< CRSEL

constexpr Scancode SCANCODE_EXSEL = SDL_SCANCODE_EXSEL; ///< EXSEL

constexpr Scancode SCANCODE_KP_00 = SDL_SCANCODE_KP_00; ///< KP_00

constexpr Scancode SCANCODE_KP_000 = SDL_SCANCODE_KP_000; ///< KP_000

constexpr Scancode SCANCODE_THOUSANDSSEPARATOR =
  SDL_SCANCODE_THOUSANDSSEPARATOR; ///< THOUSANDSSEPARATOR

constexpr Scancode SCANCODE_DECIMALSEPARATOR =
  SDL_SCANCODE_DECIMALSEPARATOR; ///< DECIMALSEPARATOR

constexpr Scancode SCANCODE_CURRENCYUNIT =
  SDL_SCANCODE_CURRENCYUNIT; ///< CURRENCYUNIT

constexpr Scancode SCANCODE_CURRENCYSUBUNIT =
  SDL_SCANCODE_CURRENCYSUBUNIT; ///< CURRENCYSUBUNIT

constexpr Scancode SCANCODE_KP_LEFTPAREN =
  SDL_SCANCODE_KP_LEFTPAREN; ///< KP_LEFTPAREN

constexpr Scancode SCANCODE_KP_RIGHTPAREN =
  SDL_SCANCODE_KP_RIGHTPAREN; ///< KP_RIGHTPAREN

constexpr Scancode SCANCODE_KP_LEFTBRACE =
  SDL_SCANCODE_KP_LEFTBRACE; ///< KP_LEFTBRACE

constexpr Scancode SCANCODE_KP_RIGHTBRACE =
  SDL_SCANCODE_KP_RIGHTBRACE; ///< KP_RIGHTBRACE

constexpr Scancode SCANCODE_KP_TAB = SDL_SCANCODE_KP_TAB; ///< KP_TAB

constexpr Scancode SCANCODE_KP_BACKSPACE =
  SDL_SCANCODE_KP_BACKSPACE; ///< KP_BACKSPACE

constexpr Scancode SCANCODE_KP_A = SDL_SCANCODE_KP_A; ///< KP_A

constexpr Scancode SCANCODE_KP_B = SDL_SCANCODE_KP_B; ///< KP_B

constexpr Scancode SCANCODE_KP_C = SDL_SCANCODE_KP_C; ///< KP_C

constexpr Scancode SCANCODE_KP_D = SDL_SCANCODE_KP_D; ///< KP_D

constexpr Scancode SCANCODE_KP_E = SDL_SCANCODE_KP_E; ///< KP_E

constexpr Scancode SCANCODE_KP_F = SDL_SCANCODE_KP_F; ///< KP_F

constexpr Scancode SCANCODE_KP_XOR = SDL_SCANCODE_KP_XOR; ///< KP_XOR

constexpr Scancode SCANCODE_KP_POWER = SDL_SCANCODE_KP_POWER; ///< KP_POWER

constexpr Scancode SCANCODE_KP_PERCENT =
  SDL_SCANCODE_KP_PERCENT; ///< KP_PERCENT

constexpr Scancode SCANCODE_KP_LESS = SDL_SCANCODE_KP_LESS; ///< KP_LESS

constexpr Scancode SCANCODE_KP_GREATER =
  SDL_SCANCODE_KP_GREATER; ///< KP_GREATER

constexpr Scancode SCANCODE_KP_AMPERSAND =
  SDL_SCANCODE_KP_AMPERSAND; ///< KP_AMPERSAND

constexpr Scancode SCANCODE_KP_DBLAMPERSAND =
  SDL_SCANCODE_KP_DBLAMPERSAND; ///< KP_DBLAMPERSAND

constexpr Scancode SCANCODE_KP_VERTICALBAR =
  SDL_SCANCODE_KP_VERTICALBAR; ///< KP_VERTICALBAR

constexpr Scancode SCANCODE_KP_DBLVERTICALBAR =
  SDL_SCANCODE_KP_DBLVERTICALBAR; ///< KP_DBLVERTICALBAR

constexpr Scancode SCANCODE_KP_COLON = SDL_SCANCODE_KP_COLON; ///< KP_COLON

constexpr Scancode SCANCODE_KP_HASH = SDL_SCANCODE_KP_HASH; ///< KP_HASH

constexpr Scancode SCANCODE_KP_SPACE = SDL_SCANCODE_KP_SPACE; ///< KP_SPACE

constexpr Scancode SCANCODE_KP_AT = SDL_SCANCODE_KP_AT; ///< KP_AT

constexpr Scancode SCANCODE_KP_EXCLAM = SDL_SCANCODE_KP_EXCLAM; ///< KP_EXCLAM

constexpr Scancode SCANCODE_KP_MEMSTORE =
  SDL_SCANCODE_KP_MEMSTORE; ///< KP_MEMSTORE

constexpr Scancode SCANCODE_KP_MEMRECALL =
  SDL_SCANCODE_KP_MEMRECALL; ///< KP_MEMRECALL

constexpr Scancode SCANCODE_KP_MEMCLEAR =
  SDL_SCANCODE_KP_MEMCLEAR; ///< KP_MEMCLEAR

constexpr Scancode SCANCODE_KP_MEMADD = SDL_SCANCODE_KP_MEMADD; ///< KP_MEMADD

constexpr Scancode SCANCODE_KP_MEMSUBTRACT =
  SDL_SCANCODE_KP_MEMSUBTRACT; ///< KP_MEMSUBTRACT

constexpr Scancode SCANCODE_KP_MEMMULTIPLY =
  SDL_SCANCODE_KP_MEMMULTIPLY; ///< KP_MEMMULTIPLY

constexpr Scancode SCANCODE_KP_MEMDIVIDE =
  SDL_SCANCODE_KP_MEMDIVIDE; ///< KP_MEMDIVIDE

constexpr Scancode SCANCODE_KP_PLUSMINUS =
  SDL_SCANCODE_KP_PLUSMINUS; ///< KP_PLUSMINUS

constexpr Scancode SCANCODE_KP_CLEAR = SDL_SCANCODE_KP_CLEAR; ///< KP_CLEAR

constexpr Scancode SCANCODE_KP_CLEARENTRY =
  SDL_SCANCODE_KP_CLEARENTRY; ///< KP_CLEARENTRY

constexpr Scancode SCANCODE_KP_BINARY = SDL_SCANCODE_KP_BINARY; ///< KP_BINARY

constexpr Scancode SCANCODE_KP_OCTAL = SDL_SCANCODE_KP_OCTAL; ///< KP_OCTAL

constexpr Scancode SCANCODE_KP_DECIMAL =
  SDL_SCANCODE_KP_DECIMAL; ///< KP_DECIMAL

constexpr Scancode SCANCODE_KP_HEXADECIMAL =
  SDL_SCANCODE_KP_HEXADECIMAL; ///< KP_HEXADECIMAL

constexpr Scancode SCANCODE_LCTRL = SDL_SCANCODE_LCTRL; ///< LCTRL

constexpr Scancode SCANCODE_LSHIFT = SDL_SCANCODE_LSHIFT; ///< LSHIFT

constexpr Scancode SCANCODE_LALT = SDL_SCANCODE_LALT; ///< alt, option

constexpr Scancode SCANCODE_LGUI =
  SDL_SCANCODE_LGUI; ///< windows, command (apple), meta

constexpr Scancode SCANCODE_RCTRL = SDL_SCANCODE_RCTRL; ///< RCTRL

constexpr Scancode SCANCODE_RSHIFT = SDL_SCANCODE_RSHIFT; ///< RSHIFT

constexpr Scancode SCANCODE_RALT = SDL_SCANCODE_RALT; ///< alt gr, option

constexpr Scancode SCANCODE_RGUI =
  SDL_SCANCODE_RGUI; ///< windows, command (apple), meta

/**
 * I'm not sure if this is really not covered by any of the above, but since
 * there's a special KMOD_MODE for it I'm adding it here.
 */
constexpr Scancode SCANCODE_MODE = SDL_SCANCODE_MODE;

constexpr Scancode SCANCODE_SLEEP = SDL_SCANCODE_SLEEP; ///< Sleep.

constexpr Scancode SCANCODE_WAKE = SDL_SCANCODE_WAKE; ///< Wake.

constexpr Scancode SCANCODE_CHANNEL_INCREMENT =
  SDL_SCANCODE_CHANNEL_INCREMENT; ///< Channel Increment.

constexpr Scancode SCANCODE_CHANNEL_DECREMENT =
  SDL_SCANCODE_CHANNEL_DECREMENT; ///< Channel Decrement.

constexpr Scancode SCANCODE_MEDIA_PLAY = SDL_SCANCODE_MEDIA_PLAY; ///< Play.

constexpr Scancode SCANCODE_MEDIA_PAUSE = SDL_SCANCODE_MEDIA_PAUSE; ///< Pause.

constexpr Scancode SCANCODE_MEDIA_RECORD =
  SDL_SCANCODE_MEDIA_RECORD; ///< Record.

constexpr Scancode SCANCODE_MEDIA_FAST_FORWARD =
  SDL_SCANCODE_MEDIA_FAST_FORWARD; ///< Fast Forward.

constexpr Scancode SCANCODE_MEDIA_REWIND =
  SDL_SCANCODE_MEDIA_REWIND; ///< Rewind.

constexpr Scancode SCANCODE_MEDIA_NEXT_TRACK =
  SDL_SCANCODE_MEDIA_NEXT_TRACK; ///< Next Track.

constexpr Scancode SCANCODE_MEDIA_PREVIOUS_TRACK =
  SDL_SCANCODE_MEDIA_PREVIOUS_TRACK; ///< Previous Track.

constexpr Scancode SCANCODE_MEDIA_STOP = SDL_SCANCODE_MEDIA_STOP; ///< Stop.

constexpr Scancode SCANCODE_MEDIA_EJECT = SDL_SCANCODE_MEDIA_EJECT; ///< Eject.

constexpr Scancode SCANCODE_MEDIA_PLAY_PAUSE =
  SDL_SCANCODE_MEDIA_PLAY_PAUSE; ///< Play / Pause.

constexpr Scancode SCANCODE_MEDIA_SELECT =
  SDL_SCANCODE_MEDIA_SELECT; ///< MEDIA_SELECT

constexpr Scancode SCANCODE_AC_NEW = SDL_SCANCODE_AC_NEW; ///< AC New.

constexpr Scancode SCANCODE_AC_OPEN = SDL_SCANCODE_AC_OPEN; ///< AC Open.

constexpr Scancode SCANCODE_AC_CLOSE = SDL_SCANCODE_AC_CLOSE; ///< AC Close.

constexpr Scancode SCANCODE_AC_EXIT = SDL_SCANCODE_AC_EXIT; ///< AC Exit.

constexpr Scancode SCANCODE_AC_SAVE = SDL_SCANCODE_AC_SAVE; ///< AC Save.

constexpr Scancode SCANCODE_AC_PRINT = SDL_SCANCODE_AC_PRINT; ///< AC Print.

constexpr Scancode SCANCODE_AC_PROPERTIES =
  SDL_SCANCODE_AC_PROPERTIES; ///< AC Properties.

constexpr Scancode SCANCODE_AC_SEARCH = SDL_SCANCODE_AC_SEARCH; ///< AC Search.

constexpr Scancode SCANCODE_AC_HOME = SDL_SCANCODE_AC_HOME; ///< AC Home.

constexpr Scancode SCANCODE_AC_BACK = SDL_SCANCODE_AC_BACK; ///< AC Back.

constexpr Scancode SCANCODE_AC_FORWARD =
  SDL_SCANCODE_AC_FORWARD; ///< AC Forward.

constexpr Scancode SCANCODE_AC_STOP = SDL_SCANCODE_AC_STOP; ///< AC Stop.

constexpr Scancode SCANCODE_AC_REFRESH =
  SDL_SCANCODE_AC_REFRESH; ///< AC Refresh.

constexpr Scancode SCANCODE_AC_BOOKMARKS =
  SDL_SCANCODE_AC_BOOKMARKS; ///< AC Bookmarks.

/**
 * Usually situated below the display on phones and used as a multi-function
 * feature key for selecting a software defined function shown on the bottom
 * left of the display.
 */
constexpr Scancode SCANCODE_SOFTLEFT = SDL_SCANCODE_SOFTLEFT;

/**
 * Usually situated below the display on phones and used as a multi-function
 * feature key for selecting a software defined function shown on the bottom
 * right of the display.
 */
constexpr Scancode SCANCODE_SOFTRIGHT = SDL_SCANCODE_SOFTRIGHT;

constexpr Scancode SCANCODE_CALL =
  SDL_SCANCODE_CALL; ///< Used for accepting phone calls.

constexpr Scancode SCANCODE_ENDCALL =
  SDL_SCANCODE_ENDCALL; ///< Used for rejecting phone calls.

constexpr Scancode SCANCODE_RESERVED =
  SDL_SCANCODE_RESERVED; ///< 400-500 reserved for dynamic keycodes

/// not a key, just marks the number of scancodes for array bounds
constexpr Scancode SCANCODE_COUNT = SDL_SCANCODE_COUNT;

/// @}

/**
 * @defgroup CategoryTime Date and Time
 *
 * SDL realtime clock and date/time routines.
 *
 * There are two data types that are used in this category: Time, which
 * represents the nanoseconds since a specific moment (an "epoch"), and
 * DateTime, which breaks time down into human-understandable components:
 * years, months, days, hours, etc.
 *
 * Much of the functionality is involved in converting those two types to
 * other useful forms.
 *
 * @{
 */

using DateTimeRaw = SDL_DateTime;

/**
 * A structure holding a calendar date and time broken down into its
 * components.
 *
 * @since This struct is available since SDL 3.2.0.
 */
struct DateTime : DateTimeRaw
{
  /**
   * Wraps DateTime.
   *
   * @param dateTime the value to be wrapped
   */
  constexpr DateTime(const DateTimeRaw& dateTime = {})
    : DateTimeRaw(dateTime)
  {
  }

  /**
   * Constructs from its fields.
   *
   * @param year the value for year.
   * @param month the value for month.
   * @param day the value for day.
   * @param hour the value for hour.
   * @param minute the value for minute.
   * @param second the value for second.
   * @param nanosecond the value for nanosecond.
   * @param day_of_week the value for day_of_week.
   * @param utc_offset the value for utc_offset.
   */
  constexpr DateTime(int year,
                     int month,
                     int day,
                     int hour,
                     int minute,
                     int second,
                     int nanosecond,
                     int day_of_week,
                     int utc_offset)
    : DateTimeRaw{year,
                  month,
                  day,
                  hour,
                  minute,
                  second,
                  nanosecond,
                  day_of_week,
                  utc_offset}
  {
  }

  /**
   * Converts an Time in nanoseconds since the epoch to a calendar time in
   * the DateTime format.
   *
   * @param ticks the Time to be converted.
   * @param localTime the resulting DateTime will be expressed in local time
   *                  if true, otherwise it will be in Universal Coordinated
   *                  Time (UTC).
   * @throws Error on failure.
   *
   * @since This function is available since SDL 3.2.0.
   */
  DateTime(Time ticks, bool localTime = true)
  {
    CheckError(SDL_TimeToDateTime(ticks.ToNS(), this, localTime));
  }

  /**
   * Check if valid.
   *
   * @returns True if valid state, false otherwise.
   */
  constexpr explicit operator bool() const
  {
    return year != 0 || month != 0 || day != 0 || hour != 0 || minute != 0 ||
           second != 0 || nanosecond != 0;
  }

  /**
   * Get the year.
   *
   * @returns current year value.
   */
  constexpr int GetYear() const { return year; }

  /**
   * Set the year.
   *
   * @param newYear the new year value.
   * @returns Reference to self.
   */
  constexpr DateTime& SetYear(int newYear)
  {
    year = newYear;
    return *this;
  }

  /**
   * Get the month.
   *
   * @returns current month value.
   */
  constexpr int GetMonth() const { return month; }

  /**
   * Set the month.
   *
   * @param newMonth the new month value.
   * @returns Reference to self.
   */
  constexpr DateTime& SetMonth(int newMonth)
  {
    month = newMonth;
    return *this;
  }

  /**
   * Get the day.
   *
   * @returns current day value.
   */
  constexpr int GetDay() const { return day; }

  /**
   * Set the day.
   *
   * @param newDay the new day value.
   * @returns Reference to self.
   */
  constexpr DateTime& SetDay(int newDay)
  {
    day = newDay;
    return *this;
  }

  /**
   * Get the hour.
   *
   * @returns current hour value.
   */
  constexpr int GetHour() const { return hour; }

  /**
   * Set the hour.
   *
   * @param newHour the new hour value.
   * @returns Reference to self.
   */
  constexpr DateTime& SetHour(int newHour)
  {
    hour = newHour;
    return *this;
  }

  /**
   * Get the minute.
   *
   * @returns current minute value.
   */
  constexpr int GetMinute() const { return minute; }

  /**
   * Set the minute.
   *
   * @param newMinute the new minute value.
   * @returns Reference to self.
   */
  constexpr DateTime& SetMinute(int newMinute)
  {
    minute = newMinute;
    return *this;
  }

  /**
   * Get the second.
   *
   * @returns current second value.
   */
  constexpr int GetSecond() const { return second; }

  /**
   * Set the second.
   *
   * @param newSecond the new second value.
   * @returns Reference to self.
   */
  constexpr DateTime& SetSecond(int newSecond)
  {
    second = newSecond;
    return *this;
  }

  /**
   * Get the nanosecond.
   *
   * @returns current nanosecond value.
   */
  constexpr int GetNanosecond() const { return nanosecond; }

  /**
   * Set the nanosecond.
   *
   * @param newNanosecond the new nanosecond value.
   * @returns Reference to self.
   */
  constexpr DateTime& SetNanosecond(int newNanosecond)
  {
    nanosecond = newNanosecond;
    return *this;
  }

  /**
   * Get the day_of_week.
   *
   * @returns current day_of_week value.
   */
  constexpr int GetDay_of_week() const { return day_of_week; }

  /**
   * Set the day_of_week.
   *
   * @param newDay_of_week the new day_of_week value.
   * @returns Reference to self.
   */
  constexpr DateTime& SetDay_of_week(int newDay_of_week)
  {
    day_of_week = newDay_of_week;
    return *this;
  }

  /**
   * Get the utc_offset.
   *
   * @returns current utc_offset value.
   */
  constexpr int GetUtc_offset() const { return utc_offset; }

  /**
   * Set the utc_offset.
   *
   * @param newUtc_offset the new utc_offset value.
   * @returns Reference to self.
   */
  constexpr DateTime& SetUtc_offset(int newUtc_offset)
  {
    utc_offset = newUtc_offset;
    return *this;
  }

  /**
   * Converts a calendar time to an Time in nanoseconds since the epoch.
   *
   * This function ignores the day_of_week member of the DateTime struct, so
   * it may remain unset.
   *
   * @returns time on success.
   * @throws Error on failure.
   *
   * @since This function is available since SDL 3.2.0.
   */
  operator Time() const;
};

/**
 * The preferred date format of the current system locale.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa GetDateTimeLocalePreferences
 */
using DateFormat = SDL_DateFormat;

constexpr DateFormat DATE_FORMAT_YYYYMMDD =
  SDL_DATE_FORMAT_YYYYMMDD; ///< Year/Month/Day.

constexpr DateFormat DATE_FORMAT_DDMMYYYY =
  SDL_DATE_FORMAT_DDMMYYYY; ///< Day/Month/Year.

constexpr DateFormat DATE_FORMAT_MMDDYYYY =
  SDL_DATE_FORMAT_MMDDYYYY; ///< Month/Day/Year.

/**
 * The preferred time format of the current system locale.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa GetDateTimeLocalePreferences
 */
using TimeFormat = SDL_TimeFormat;

constexpr TimeFormat TIME_FORMAT_24HR = SDL_TIME_FORMAT_24HR; ///< 24 hour time

constexpr TimeFormat TIME_FORMAT_12HR = SDL_TIME_FORMAT_12HR; ///< 12 hour time

/**
 * Gets the current preferred date and time format for the system locale.
 *
 * This might be a "slow" call that has to query the operating system. It's
 * best to ask for this once and save the results. However, the preferred
 * formats can change, usually because the user has changed a system
 * preference outside of your program.
 *
 * @param dateFormat a pointer to the DateFormat to hold the returned date
 *                   format, may be nullptr.
 * @param timeFormat a pointer to the TimeFormat to hold the returned time
 *                   format, may be nullptr.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void GetDateTimeLocalePreferences(DateFormat* dateFormat,
                                         TimeFormat* timeFormat)
{
  CheckError(SDL_GetDateTimeLocalePreferences(dateFormat, timeFormat));
}

/**
 * Gets the current value of the system realtime clock in nanoseconds since
 * Jan 1, 1970 in Universal Coordinated Time (UTC).
 *
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Time Time::Current()
{
  SDL_Time t;
  CheckError(SDL_GetCurrentTime(&t));
  return Time::FromNS(t);
}

/**
 * Converts an Time in nanoseconds since the epoch to a calendar time in
 * the DateTime format.
 *
 * @param ticks the Time to be converted.
 * @param dt the resulting DateTime.
 * @param localTime the resulting DateTime will be expressed in local time
 *                  if true, otherwise it will be in Universal Coordinated
 *                  Time (UTC).
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline DateTime TimeToDateTime(Time ticks, bool localTime = true)
{
  return DateTime(ticks, localTime);
}

/**
 * Converts a calendar time to an Time in nanoseconds since the epoch.
 *
 * This function ignores the day_of_week member of the DateTime struct, so
 * it may remain unset.
 *
 * @param dt the source DateTime.
 * @param ticks the resulting Time.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Time DateTimeToTime(const DateTimeRaw& dt)
{
  SDL_Time t;
  CheckError(SDL_DateTimeToTime(&dt, &t));
  return Time::FromNS(t);
}

inline DateTime::operator Time() const { return SDL::DateTimeToTime(*this); }

/**
 * Converts an SDL time into a Windows FILETIME (100-nanosecond intervals
 * since January 1, 1601).
 *
 * This function fills in the two 32-bit values of the FILETIME structure.
 *
 * @param dwLowDateTime a pointer filled in with the low portion of the
 *                      Windows FILETIME value.
 * @param dwHighDateTime a pointer filled in with the high portion of the
 *                       Windows FILETIME value.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void Time::ToWindows(Uint32* dwLowDateTime, Uint32* dwHighDateTime) const
{
  SDL_TimeToWindows(ToNS(), dwLowDateTime, dwHighDateTime);
}

/**
 * Converts a Windows FILETIME (100-nanosecond intervals since January 1,
 * 1601) to an SDL time.
 *
 * This function takes the two 32-bit values of the FILETIME structure as
 * parameters.
 *
 * @param dwLowDateTime the low portion of the Windows FILETIME value.
 * @param dwHighDateTime the high portion of the Windows FILETIME value.
 * @returns the converted SDL time.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Time Time::FromWindows(Uint32 dwLowDateTime, Uint32 dwHighDateTime)
{
  return Time::FromNS(SDL_TimeFromWindows(dwLowDateTime, dwHighDateTime));
}

/**
 * Get the number of days in a month for a given year.
 *
 * @param year the year.
 * @param month the month [1-12].
 * @returns the number of days in the requested month.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int GetDaysInMonth(int year, int month)
{
  return CheckError(SDL_GetDaysInMonth(year, month), -1);
}

/**
 * Get the day of year for a calendar date.
 *
 * @param year the year component of the date.
 * @param month the month component of the date.
 * @param day the day component of the date.
 * @returns the day of year [0-365] if the date is valid.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int GetDayOfYear(int year, int month, int day)
{
  return CheckError(SDL_GetDayOfYear(year, month, day), -1);
}

/**
 * Get the day of week for a calendar date.
 *
 * @param year the year component of the date.
 * @param month the month component of the date.
 * @param day the day component of the date.
 * @returns a value between 0 and 6 (0 being Sunday) if the date is valid.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int GetDayOfWeek(int year, int month, int day)
{
  return CheckError(SDL_GetDayOfWeek(year, month, day), -1);
}

/// @}

/**
 * @defgroup CategoryTimer Timer Support
 *
 * SDL provides time management functionality. It is useful for dealing with
 * (usually) small durations of time.
 *
 * This is not to be confused with _calendar time_ management, which is
 * provided by [CategoryTime](#CategoryTime).
 *
 * This category covers measuring time elapsed (SDL_GetTicks(),
 * GetPerformanceCounter()), putting a thread to sleep for a certain
 * amount of time (Delay(), SDL_DelayNS(), DelayPrecise()), and firing
 * a callback function after a certain amount of time has elasped
 * (SDL_AddTimer(), etc).
 *
 * @{
 */

/**
 * Convert seconds to nanoseconds.
 *
 * This only converts whole numbers, not fractional seconds.
 *
 * @param time the number of seconds to convert.
 * @returns the converted Time.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
constexpr Time Time::FromPosix(Sint64 time)
{
  return Time::FromNS(SDL_SECONDS_TO_NS(time));
}

/**
 * Convert nanoseconds to seconds.
 *
 * This only converts whole numbers, not fractional seconds.
 *
 * @returns Posix time (in seconds).
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
constexpr Sint64 Time::ToPosix() const
{
  return SDL_NS_TO_SECONDS(m_value.count());
}

/**
 * Get the time elapsed since SDL library initialization.
 *
 * @returns a std::chrono::nanoseconds value representing the number of
 * nanoseconds since the SDL library initialized.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline std::chrono::nanoseconds GetTicks()
{
  return std::chrono::nanoseconds{SDL_GetTicksNS()};
}

/**
 * Get the current value of the high resolution counter.
 *
 * This function is typically used for profiling.
 *
 * The counter values are only meaningful relative to each other. Differences
 * between values can be converted to times by using
 * GetPerformanceFrequency().
 *
 * @returns the current counter value.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetPerformanceFrequency
 */
inline Uint64 GetPerformanceCounter() { return SDL_GetPerformanceCounter(); }

/**
 * Get the count per second of the high resolution counter.
 *
 * @returns a platform-specific count per second.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetPerformanceCounter
 */
inline Uint64 GetPerformanceFrequency()
{
  return SDL_GetPerformanceFrequency();
}

/**
 * Wait a specified duration before returning.
 *
 * This function waits a specified duration before returning. It
 * waits at least the specified time, but possibly longer due to OS
 * scheduling.
 *
 * @param duration the duration to delay, with max precision in ns.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa DelayPrecise
 */
inline void Delay(std::chrono::nanoseconds duration)
{
  SDL_DelayNS(duration.count());
}

/**
 * Wait a specified duration before returning.
 *
 * This function waits a specified duration before returning. It
 * will attempt to wait as close to the requested time as possible, busy
 * waiting if necessary, but could return later due to OS scheduling.
 *
 * @param duration the duration to delay.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Delay
 */
inline void DelayPrecise(std::chrono::nanoseconds duration)
{
  SDL_DelayPrecise(duration.count());
}

/**
 * Definition of the timer ID type.
 *
 * @since This datatype is available since SDL 3.2.0.
 */
using TimerID = SDL_TimerID;

/**
 * Function prototype for the nanosecond timer callback function.
 *
 * The callback function is passed the current timer interval and returns the
 * next timer interval, in nanoseconds. If the returned value is the same as
 * the one passed in, the periodic alarm continues, otherwise a new alarm is
 * scheduled. If the callback returns 0, the periodic alarm is canceled and
 * will be removed.
 *
 * @param userdata an arbitrary pointer provided by the app through
 *                 SDL_AddTimer, for its own use.
 * @param timerID the current timer being processed.
 * @param interval the current callback time interval.
 * @returns the new callback time interval, or 0 to disable further runs of
 *          the callback.
 *
 * @threadsafety SDL may call this callback at any time from a background
 *               thread; the application is responsible for locking resources
 *               the callback touches that need to be protected.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa AddTimer
 */
using TimerCallback = SDL_NSTimerCallback;

/**
 * Function prototype for the nanosecond timer callback function.
 *
 * The callback function is passed the current timer interval and returns the
 * next timer interval, in nanoseconds. If the returned value is the same as
 * the one passed in, the periodic alarm continues, otherwise a new alarm is
 * scheduled. If the callback returns 0, the periodic alarm is canceled and
 * will be removed.
 *
 * @param timerID the current timer being processed.
 * @param interval the current callback time interval.
 * @returns the new callback time interval, or 0 to disable further runs of
 *          the callback.
 *
 * @threadsafety SDL may call this callback at any time from a background
 *               thread; the application is responsible for locking resources
 *               the callback touches that need to be protected.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @cat listener-callback
 *
 * @sa AddTimer
 * @sa TimerCallback
 */
using TimerCB =
  std::function<std::chrono::nanoseconds(TimerID, std::chrono::nanoseconds)>;

/**
 * Call a callback function at a future time.
 *
 * The callback function is passed the current timer interval and the user
 * supplied parameter from the AddTimer() call and should return the
 * next timer interval. If the value returned from the callback is 0, the
 * timer is canceled and will be removed.
 *
 * The callback is run on a separate thread, and for short timeouts can
 * potentially be called before this function returns.
 *
 * Timers take into account the amount of time it took to execute the
 * callback. For example, if the callback took 250 ns to execute and returned
 * 1000 (ns), the timer would only wait another 750 ns before its next
 * iteration.
 *
 * Timing may be inexact due to OS scheduling. Be sure to note the current
 * time with GetTicks() or GetPerformanceCounter() in case your
 * callback needs to adjust for variances.
 *
 * @param interval the timer delay, in std::chrono::nanoseconds, passed to
 *                 `callback`.
 * @param callback the NSTimerCallback function to call when the specified
 *                 `interval` elapses.
 * @param userdata a pointer that is passed to `callback`.
 * @returns a timer ID.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa RemoveTimer
 */
inline TimerID AddTimer(std::chrono::nanoseconds interval,
                        TimerCallback callback,
                        void* userdata)
{
  return CheckError(SDL_AddTimerNS(interval.count(), callback, userdata));
}

/**
 * Call a callback function at a future time.
 *
 * The callback function is passed the current timer interval and the user
 * supplied parameter from the AddTimer() call and should return the
 * next timer interval. If the value returned from the callback is 0, the
 * timer is canceled and will be removed.
 *
 * The callback is run on a separate thread, and for short timeouts can
 * potentially be called before this function returns.
 *
 * Timers take into account the amount of time it took to execute the
 * callback. For example, if the callback took 250 ns to execute and returned
 * 1000 (ns), the timer would only wait another 750 ns before its next
 * iteration.
 *
 * Timing may be inexact due to OS scheduling. Be sure to note the current
 * time with GetTicks() or GetPerformanceCounter() in case your
 * callback needs to adjust for variances.
 *
 * @param interval the timer delay, in std::chrono::nanoseconds, passed to
 * `callback`.
 * @param callback the TimerCB function to call when the specified
 *                 `interval` elapses.
 * @returns a timer ID.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @cat listener-callback
 *
 * @sa listener-callback
 * @sa RemoveTimer()
 */
inline TimerID AddTimer(std::chrono::nanoseconds interval, TimerCB callback)
{
  using Wrapper = CallbackWrapper<TimerCB>;
  using Store = KeyValueWrapper<TimerID, TimerCB*>;

  auto cb = Wrapper::Wrap(std::move(callback));

  if (TimerID id = SDL_AddTimerNS(
        interval.count(),
        [](void* userdata, TimerID timerID, Uint64 interval) -> Uint64 {
          auto& f = *static_cast<TimerCB*>(userdata);
          auto next = f(timerID, std::chrono::nanoseconds(interval)).count();
          // If ask to removal, then remove it
          if (next == 0) delete Store::release(timerID);
          return next;
        },
        cb)) {
    Store::Wrap(id, std::move(cb));
    return id;
  }
  delete cb;
  throw Error{};
}

/**
 * Remove a timer created with SDL_AddTimer().
 *
 * @param id the ID of the timer to remove.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AddTimer
 */
inline void RemoveTimer(TimerID id)
{
  delete KeyValueWrapper<TimerID, TimerCB*>::release(id);
  CheckError(SDL_RemoveTimer(id));
}

/// @}

/**
 * @defgroup CategoryAudio Audio Playback, Recording, and Mixing
 *
 * Audio functionality for the SDL library.
 *
 * All audio in SDL3 revolves around AudioStream. Whether you want to play
 * or record audio, convert it, stream it, buffer it, or mix it, you're going
 * to be passing it through an audio stream.
 *
 * Audio streams are quite flexible; they can accept any amount of data at a
 * time, in any supported format, and output it as needed in any other format,
 * even if the data format changes on either side halfway through.
 *
 * An app opens an audio device and binds any number of audio streams to it,
 * feeding more data to the streams as available. When the device needs more
 * data, it will pull it from all bound streams and mix them together for
 * playback.
 *
 * Audio streams can also use an app-provided callback to supply data
 * on-demand, which maps pretty closely to the SDL2 audio model.
 *
 * SDL also provides a simple .WAV loader in LoadWAV (and LoadWAV
 * if you aren't reading from a file) as a basic means to load sound data into
 * your program.
 *
 * ## Logical audio devices
 *
 * In SDL3, opening a physical device (like a SoundBlaster 16 Pro) gives you a
 * logical device ID that you can bind audio streams to. In almost all cases,
 * logical devices can be used anywhere in the API that a physical device is
 * normally used. However, since each device opening generates a new logical
 * device, different parts of the program (say, a VoIP library, or
 * text-to-speech framework, or maybe some other sort of mixer on top of SDL)
 * can have their own device opens that do not interfere with each other; each
 * logical device will mix its separate audio down to a single buffer, fed to
 * the physical device, behind the scenes. As many logical devices as you like
 * can come and go; SDL will only have to open the physical device at the OS
 * level once, and will manage all the logical devices on top of it
 * internally.
 *
 * One other benefit of logical devices: if you don't open a specific physical
 * device, instead opting for the default, SDL can automatically migrate those
 * logical devices to different hardware as circumstances change: a user
 * plugged in headphones? The system default changed? SDL can transparently
 * migrate the logical devices to the correct physical device seamlessly and
 * keep playing; the app doesn't even have to know it happened if it doesn't
 * want to.
 *
 * ## Simplified audio
 *
 * As a simplified model for when a single source of audio is all that's
 * needed, an app can use AudioStream.AudioStream, which is a single
 * function to open an audio device, create an audio stream, bind that stream
 * to the newly-opened device, and (optionally) provide a callback for
 * obtaining audio data. When using this function, the primary interface is
 * the AudioStream and the device handle is mostly hidden away; destroying
 * a stream created through this function will also close the device, stream
 * bindings cannot be changed, etc. One other quirk of this is that the device
 * is started in a _paused_ state and must be explicitly resumed; this is
 * partially to offer a clean migration for SDL2 apps and partially because
 * the app might have to do more setup before playback begins; in the
 * non-simplified form, nothing will play until a stream is bound to a device,
 * so they start _unpaused_.
 *
 * ## Channel layouts
 *
 * Audio data passing through SDL is uncompressed PCM data, interleaved. One
 * can provide their own decompression through an MP3, etc, decoder, but SDL
 * does not provide this directly. Each interleaved channel of data is meant
 * to be in a specific order.
 *
 * Abbreviations:
 *
 * - FRONT = single mono speaker
 * - FL = front left speaker
 * - FR = front right speaker
 * - FC = front center speaker
 * - BL = back left speaker
 * - BR = back right speaker
 * - SR = surround right speaker
 * - SL = surround left speaker
 * - BC = back center speaker
 * - LFE = low-frequency speaker
 *
 * These are listed in the order they are laid out in memory, so "FL, FR"
 * means "the front left speaker is laid out in memory first, then the front
 * right, then it repeats for the next audio frame".
 *
 * - 1 channel (mono) layout: FRONT
 * - 2 channels (stereo) layout: FL, FR
 * - 3 channels (2.1) layout: FL, FR, LFE
 * - 4 channels (quad) layout: FL, FR, BL, BR
 * - 5 channels (4.1) layout: FL, FR, LFE, BL, BR
 * - 6 channels (5.1) layout: FL, FR, FC, LFE, BL, BR (last two can also be
 *   SL, SR)
 * - 7 channels (6.1) layout: FL, FR, FC, LFE, BC, SL, SR
 * - 8 channels (7.1) layout: FL, FR, FC, LFE, BL, BR, SL, SR
 *
 * This is the same order as DirectSound expects, but applied to all
 * platforms; SDL will swizzle the channels as necessary if a platform expects
 * something different.
 *
 * AudioStream can also be provided channel maps to change this ordering
 * to whatever is necessary, in other audio processing scenarios.
 *
 * @{
 */

using AudioFormatRaw = SDL_AudioFormat;

// Forward decl
struct AudioDevice;

using AudioDeviceID = SDL_AudioDeviceID;

// Forward decl
struct AudioDeviceRef;

/// Safely wrap AudioDevice for non owning parameters
struct AudioDeviceParam
{
  AudioDeviceID value; ///< parameter's AudioDeviceID

  /// Constructs from AudioDeviceID
  constexpr AudioDeviceParam(AudioDeviceID value)
    : value(value)
  {
  }

  /// Constructs null/invalid
  constexpr AudioDeviceParam(std::nullptr_t _ = nullptr)
    : value(0)
  {
  }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!value; }

  /// Comparison
  constexpr auto operator<=>(const AudioDeviceParam& other) const = default;

  /// Converts to underlying AudioDeviceID
  constexpr operator AudioDeviceID() const { return value; }
};

// Forward decl
struct AudioStream;

using AudioStreamRaw = SDL_AudioStream*;

// Forward decl
struct AudioStreamRef;

/// Safely wrap AudioStream for non owning parameters
struct AudioStreamParam
{
  AudioStreamRaw value; ///< parameter's AudioStreamRaw

  /// Constructs from AudioStreamRaw
  constexpr AudioStreamParam(AudioStreamRaw value)
    : value(value)
  {
  }

  /// Constructs null/invalid
  constexpr AudioStreamParam(std::nullptr_t _ = nullptr)
    : value(nullptr)
  {
  }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!value; }

  /// Comparison
  constexpr auto operator<=>(const AudioStreamParam& other) const = default;

  /// Converts to underlying AudioStreamRaw
  constexpr operator AudioStreamRaw() const { return value; }
};

/**
 * Format specifier for audio data.
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @sa AudioFormat
 */
using AudioSpec = SDL_AudioSpec;

#ifdef SDL3PP_DOC

/**
 * Mask of bits in an AudioFormat that contains the format bit size.
 *
 * Generally one should use AudioFormat.GetBitSize instead of this macro
 * directly.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_AUDIO_MASK_BITSIZE (0xFFu)

/**
 * Mask of bits in an AudioFormat that contain the floating point flag.
 *
 * Generally one should use AudioFormat.IsFloat instead of this macro directly.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_AUDIO_MASK_FLOAT (1u << 8)

/**
 * Mask of bits in an AudioFormat that contain the bigendian flag.
 *
 * Generally one should use AudioFormat.IsBigEndian or
 * AudioFormat.IsLittleEndian instead of this macro directly.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_AUDIO_MASK_BIG_ENDIAN (1u << 12)

/**
 * Mask of bits in an AudioFormat that contain the signed data flag.
 *
 * Generally one should use AudioFormat.IsSigned instead of this macro directly.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_AUDIO_MASK_SIGNED (1u << 15)

#endif // SDL3PP_DOC

/**
 * Audio format.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa AudioFormat.GetBitSize
 * @sa AudioFormat.GetByteSize
 * @sa AudioFormat.IsInt
 * @sa AudioFormat.IsFloat
 * @sa AudioFormat.IsBigEndian
 * @sa AudioFormat.IsLittleEndian
 * @sa AudioFormat.IsSigned
 * @sa AudioFormat.IsUnsigned
 */
class AudioFormat
{
  AudioFormatRaw m_audioFormat;

public:
  /**
   * Wraps AudioFormat.
   *
   * @param audioFormat the value to be wrapped
   */
  constexpr AudioFormat(AudioFormatRaw audioFormat = {})
    : m_audioFormat(audioFormat)
  {
  }

  /**
   * Define an AudioFormat value.
   *
   * SDL does not support custom audio formats, so this macro is not of much use
   * externally, but it can be illustrative as to what the various bits of an
   * AudioFormat mean.
   *
   * For example, AUDIO_S32LE looks like this:
   *
   * ```c
   * AudioFormat.AudioFormat(1, 0, 0, 32)
   * ```
   *
   * @param signed 1 for signed data, 0 for unsigned data.
   * @param bigendian 1 for bigendian data, 0 for littleendian data.
   * @param flt 1 for floating point data, 0 for integer data.
   * @param size number of bits per sample.
   * @post a format value in the style of AudioFormat.
   *
   * @threadsafety It is safe to call this macro from any thread.
   *
   * @since This macro is available since SDL 3.2.0.
   */
  constexpr AudioFormat(bool sign, bool bigendian, bool flt, Uint16 size)
    : m_audioFormat(
        AudioFormatRaw(SDL_DEFINE_AUDIO_FORMAT(sign, bigendian, flt, size)))
  {
  }

  /// Default comparison operator
  constexpr bool operator==(const AudioFormat& other) const = default;

  /// Compares with the underlying type
  constexpr bool operator==(AudioFormatRaw audioFormat) const
  {
    return operator==(AudioFormat(audioFormat));
  }

  /**
   * Unwraps to the underlying AudioFormat.
   *
   * @returns the underlying AudioFormatRaw.
   */
  constexpr operator AudioFormatRaw() const { return m_audioFormat; }

  /**
   * Check if valid.
   *
   * @returns True if valid state, false otherwise.
   */
  constexpr explicit operator bool() const { return m_audioFormat != 0; }

  /**
   * Retrieve the size, in bits, from an AudioFormat.
   *
   * For example, `AudioFormat.GetBitSize(AUDIO_S16)` returns 16.
   *
   * @returns data size in bits.
   *
   * @threadsafety It is safe to call this function from any thread
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr Uint16 GetBitSize();

  /**
   * Retrieve the size, in bytes, from an AudioFormat.
   *
   * For example, `AudioFormat.GetByteSize(AUDIO_S16)` returns 2.
   *
   * @returns data size in bytes.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr Uint16 GetByteSize();

  /**
   * Determine if an AudioFormat represents floating point data.
   *
   * For example, `AudioFormat.IsFloat(AUDIO_S16)` returns 0.
   *
   * @returns non-zero if format is floating point, zero otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool IsFloat();

  /**
   * Determine if an AudioFormat represents bigendian data.
   *
   * For example, `AudioFormat.IsBigEndian(AUDIO_S16LE)` returns 0.
   *
   * @returns non-zero if format is bigendian, zero otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool IsBigEndian();

  /**
   * Determine if an AudioFormat represents littleendian data.
   *
   * For example, `AudioFormat.IsLittleEndian(AUDIO_S16BE)` returns 0.
   *
   * @returns non-zero if format is littleendian, zero otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool IsLittleEndian();

  /**
   * Determine if an AudioFormat represents signed data.
   *
   * For example, `AudioFormat.IsSigned(AUDIO_U8)` returns 0.
   *
   * @returns non-zero if format is signed, zero otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool IsSigned();

  /**
   * Determine if an AudioFormat represents integer data.
   *
   * For example, `AudioFormat.IsInt(AUDIO_F32)` returns 0.
   *
   * @returns non-zero if format is integer, zero otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool IsInt();

  /**
   * Determine if an AudioFormat represents unsigned data.
   *
   * For example, `AudioFormat.IsUnsigned(AUDIO_S16)` returns 0.
   *
   * @returns non-zero if format is unsigned, zero otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool IsUnsigned();

  /**
   * Get the human readable name of an audio format.
   *
   * @returns the human readable name of the specified audio format or
   *          "AUDIO_UNKNOWN" if the format isn't recognized.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  const char* GetName() const;

  /**
   * Get the appropriate memset value for silencing an audio format.
   *
   * The value returned by this function can be used as the second argument to
   * memset (or memset) to set an audio buffer in a specific format to
   * silence.
   *
   * @returns a byte value that can be passed to memset.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  int GetSilenceValue() const;
};

// Unfortunate name clash with SDL_oldnames.h
#undef AUDIO_U8
#undef AUDIO_S8
#undef AUDIO_S16
#undef AUDIO_S32
#undef AUDIO_F32

constexpr AudioFormat AUDIO_UNKNOWN =
  SDL_AUDIO_UNKNOWN; ///< Unspecified audio format.

constexpr AudioFormat AUDIO_U8 = SDL_AUDIO_U8; ///< Unsigned 8-bit samples.

constexpr AudioFormat AUDIO_S8 = SDL_AUDIO_S8; ///< Signed 8-bit samples.

constexpr AudioFormat AUDIO_S16LE = SDL_AUDIO_S16LE; ///< Signed 16-bit samples.

constexpr AudioFormat AUDIO_S16BE =
  SDL_AUDIO_S16BE; ///< As above, but big-endian byte order.

constexpr AudioFormat AUDIO_S32LE = SDL_AUDIO_S32LE; ///< 32-bit integer samples

constexpr AudioFormat AUDIO_S32BE =
  SDL_AUDIO_S32BE; ///< As above, but big-endian byte order.

constexpr AudioFormat AUDIO_F32LE =
  SDL_AUDIO_F32LE; ///< 32-bit floating point samples

constexpr AudioFormat AUDIO_F32BE =
  SDL_AUDIO_F32BE; ///< As above, but big-endian byte order.

constexpr AudioFormat AUDIO_S16 = SDL_AUDIO_S16; ///< AUDIO_S16

constexpr AudioFormat AUDIO_S32 = SDL_AUDIO_S32; ///< AUDIO_S32

constexpr AudioFormat AUDIO_F32 = SDL_AUDIO_F32; ///< AUDIO_F32

/**
 * Define an AudioFormat value.
 *
 * SDL does not support custom audio formats, so this macro is not of much use
 * externally, but it can be illustrative as to what the various bits of an
 * AudioFormat mean.
 *
 * For example, AUDIO_S32LE looks like this:
 *
 * ```c
 * AudioFormat.AudioFormat(1, 0, 0, 32)
 * ```
 *
 * @param signed 1 for signed data, 0 for unsigned data.
 * @param bigendian 1 for bigendian data, 0 for littleendian data.
 * @param flt 1 for floating point data, 0 for integer data.
 * @param size number of bits per sample.
 * @returns a format value in the style of AudioFormat.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr AudioFormat DEFINE_AUDIO_FORMAT(bool sign,
                                          bool bigendian,
                                          bool flt,
                                          Uint16 size)
{
  return AudioFormat(sign, bigendian, flt, size);
}

/**
 * Retrieve the size, in bits, from an AudioFormat.
 *
 * For example, `AudioFormat.GetBitSize(AUDIO_S16)` returns 16.
 *
 * @param x an AudioFormat value.
 * @returns data size in bits.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr Uint16 AUDIO_BITSIZE(AudioFormatRaw x)
{
  return SDL_AUDIO_BITSIZE(x);
}

constexpr Uint16 AudioFormat::GetBitSize()
{
  return SDL::AUDIO_BITSIZE(m_audioFormat);
}

/**
 * Retrieve the size, in bytes, from an AudioFormat.
 *
 * For example, `AudioFormat.GetByteSize(AUDIO_S16)` returns 2.
 *
 * @param x an AudioFormat value.
 * @returns data size in bytes.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr Uint16 AUDIO_BYTESIZE(AudioFormatRaw x)
{
  return SDL_AUDIO_BYTESIZE(x);
}

constexpr Uint16 AudioFormat::GetByteSize()
{
  return SDL::AUDIO_BYTESIZE(m_audioFormat);
}

/**
 * Determine if an AudioFormat represents floating point data.
 *
 * For example, `AudioFormat.IsFloat(AUDIO_S16)` returns 0.
 *
 * @param x an AudioFormat value.
 * @returns non-zero if format is floating point, zero otherwise.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr bool AUDIO_ISFLOAT(AudioFormatRaw x) { return SDL_AUDIO_ISFLOAT(x); }

constexpr bool AudioFormat::IsFloat()
{
  return SDL::AUDIO_ISFLOAT(m_audioFormat);
}

/**
 * Determine if an AudioFormat represents bigendian data.
 *
 * For example, `AudioFormat.IsBigEndian(AUDIO_S16LE)` returns 0.
 *
 * @param x an AudioFormat value.
 * @returns non-zero if format is bigendian, zero otherwise.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr bool AUDIO_ISBIGENDIAN(AudioFormatRaw x)
{
  return SDL_AUDIO_ISBIGENDIAN(x);
}

constexpr bool AudioFormat::IsBigEndian()
{
  return SDL::AUDIO_ISBIGENDIAN(m_audioFormat);
}

/**
 * Determine if an AudioFormat represents littleendian data.
 *
 * For example, `AudioFormat.IsLittleEndian(AUDIO_S16BE)` returns 0.
 *
 * @param x an AudioFormat value.
 * @returns non-zero if format is littleendian, zero otherwise.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr bool AUDIO_ISLITTLEENDIAN(AudioFormatRaw x)
{
  return SDL_AUDIO_ISLITTLEENDIAN(x);
}

constexpr bool AudioFormat::IsLittleEndian()
{
  return SDL::AUDIO_ISLITTLEENDIAN(m_audioFormat);
}

/**
 * Determine if an AudioFormat represents signed data.
 *
 * For example, `AudioFormat.IsSigned(AUDIO_U8)` returns 0.
 *
 * @param x an AudioFormat value.
 * @returns non-zero if format is signed, zero otherwise.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr bool AUDIO_ISSIGNED(AudioFormatRaw x)
{
  return SDL_AUDIO_ISSIGNED(x);
}

constexpr bool AudioFormat::IsSigned()
{
  return SDL::AUDIO_ISSIGNED(m_audioFormat);
}

/**
 * Determine if an AudioFormat represents integer data.
 *
 * For example, `AudioFormat.IsInt(AUDIO_F32)` returns 0.
 *
 * @param x an AudioFormat value.
 * @returns non-zero if format is integer, zero otherwise.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr bool AUDIO_ISINT(AudioFormatRaw x) { return SDL_AUDIO_ISINT(x); }

constexpr bool AudioFormat::IsInt() { return SDL::AUDIO_ISINT(m_audioFormat); }

/**
 * Determine if an AudioFormat represents unsigned data.
 *
 * For example, `AudioFormat.IsUnsigned(AUDIO_S16)` returns 0.
 *
 * @param x an AudioFormat value.
 * @returns non-zero if format is unsigned, zero otherwise.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr bool AUDIO_ISUNSIGNED(AudioFormatRaw x)
{
  return SDL_AUDIO_ISUNSIGNED(x);
}

constexpr bool AudioFormat::IsUnsigned()
{
  return SDL::AUDIO_ISUNSIGNED(m_audioFormat);
}

/**
 * A callback that fires when data is about to be fed to an audio device.
 *
 * This is useful for accessing the final mix, perhaps for writing a
 * visualizer or applying a final effect to the audio data before playback.
 *
 * This callback should run as quickly as possible and not block for any
 * significant time, as this callback delays submission of data to the audio
 * device, which can cause audio playback problems.
 *
 * The postmix callback _must_ be able to handle any audio data format
 * specified in `spec`, which can change between callbacks if the audio device
 * changed. However, this only covers frequency and channel count; data is
 * always provided here in AUDIO_F32 format.
 *
 * The postmix callback runs _after_ logical device gain and audiostream gain
 * have been applied, which is to say you can make the output data louder at
 * this point than the gain settings would suggest.
 *
 * @param userdata a pointer provided by the app through
 *                 AudioDevice.SetPostmixCallback, for its own use.
 * @param spec the current format of audio that is to be submitted to the
 *             audio device.
 * @param buffer the buffer of audio samples to be submitted. The callback can
 *               inspect and/or modify this data.
 * @param buflen the size of `buffer` in bytes.
 *
 * @threadsafety This will run from a background thread owned by SDL. The
 *               application is responsible for locking resources the callback
 *               touches that need to be protected.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa AudioDevice.SetPostmixCallback
 */
using AudioPostmixCallback = SDL_AudioPostmixCallback;

/**
 * A callback that fires when data is about to be fed to an audio device.
 *
 * This is useful for accessing the final mix, perhaps for writing a
 * visualizer or applying a final effect to the audio data before playback.
 *
 * This callback should run as quickly as possible and not block for any
 * significant time, as this callback delays submission of data to the audio
 * device, which can cause audio playback problems.
 *
 * The postmix callback _must_ be able to handle any audio data format
 * specified in `spec`, which can change between callbacks if the audio device
 * changed. However, this only covers frequency and channel count; data is
 * always provided here in AUDIO_F32 format.
 *
 * The postmix callback runs _after_ logical device gain and audiostream gain
 * have been applied, which is to say you can make the output data louder at
 * this point than the gain settings would suggest.
 *
 * @param spec the current format of audio that is to be submitted to the
 *             audio device.
 * @param buffer the buffer of audio samples to be submitted. The callback can
 *               inspect and/or modify this data.
 * @param buflen the size of `buffer` in bytes.
 *
 * @threadsafety This will run from a background thread owned by SDL. The
 *               application is responsible for locking resources the callback
 *               touches that need to be protected.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa AudioDevice.SetPostmixCallback
 * @sa AudioPostmixCallback
 */
using AudioPostmixCB =
  std::function<void(const AudioSpec& spec, std::span<float> buffer)>;

/**
 * A callback that fires when data passes through an AudioStream.
 *
 * Apps can (optionally) register a callback with an audio stream that is
 * called when data is added with AudioStream.PutData, or requested with
 * AudioStream.GetData.
 *
 * Two values are offered here: one is the amount of additional data needed to
 * satisfy the immediate request (which might be zero if the stream already
 * has enough data queued) and the other is the total amount being requested.
 * In a Get call triggering a Put callback, these values can be different. In
 * a Put call triggering a Get callback, these values are always the same.
 *
 * Byte counts might be slightly overestimated due to buffering or resampling,
 * and may change from call to call.
 *
 * This callback is not required to do anything. Generally this is useful for
 * adding/reading data on demand, and the app will often put/get data as
 * appropriate, but the system goes on with the data currently available to it
 * if this callback does nothing.
 *
 * @param stream the SDL audio stream associated with this callback.
 * @param additional_amount the amount of data, in bytes, that is needed right
 *                          now.
 * @param total_amount the total amount of data requested, in bytes, that is
 *                     requested or available.
 * @param userdata an opaque pointer provided by the app for their personal
 *                 use.
 *
 * @threadsafety This callbacks may run from any thread, so if you need to
 *               protect shared data, you should use AudioStream.Lock to
 *               serialize access; this lock will be held before your callback
 *               is called, so your callback does not need to manage the lock
 *               explicitly.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa AudioStream.SetGetCallback
 * @sa AudioStream.SetPutCallback
 */
using AudioStreamCallback = SDL_AudioStreamCallback;

/**
 * A callback that fires when data passes through an AudioStream.
 *
 * Apps can (optionally) register a callback with an audio stream that is
 * called when data is added with AudioStream.PutData, or requested with
 * AudioStream.GetData.
 *
 * Two values are offered here: one is the amount of additional data needed to
 * satisfy the immediate request (which might be zero if the stream already
 * has enough data queued) and the other is the total amount being requested.
 * In a Get call triggering a Put callback, these values can be different. In
 * a Put call triggering a Get callback, these values are always the same.
 *
 * Byte counts might be slightly overestimated due to buffering or resampling,
 * and may change from call to call.
 *
 * This callback is not required to do anything. Generally this is useful for
 * adding/reading data on demand, and the app will often put/get data as
 * appropriate, but the system goes on with the data currently available to it
 * if this callback does nothing.
 *
 * @param stream the SDL audio stream associated with this callback.
 * @param additional_amount the amount of data, in bytes, that is needed right
 *                          now.
 * @param total_amount the total amount of data requested, in bytes, that is
 *                     requested or available.
 *
 * @threadsafety This callbacks may run from any thread, so if you need to
 *               protect shared data, you should use AudioStream.Lock to
 *               serialize access; this lock will be held before your callback
 *               is called, so your callback does not need to manage the lock
 *               explicitly.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa AudioStream.SetGetCallback
 * @sa AudioStream.SetPutCallback
 * @sa AudioStreamCB
 */
using AudioStreamCB = std::function<
  void(AudioStreamRef stream, int additional_amount, int total_amount)>;

/**
 * SDL Audio Device instance IDs.
 *
 * Zero is used to signify an invalid/null device.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @cat resource
 */
class AudioDevice
{
  AudioDeviceID m_resource = 0;

public:
  /// Default ctor
  constexpr AudioDevice() = default;

  /**
   * Constructs from AudioDeviceParam.
   *
   * @param resource a AudioDeviceID to be wrapped.
   *
   * This assumes the ownership, call release() if you need to take back.
   */
  constexpr explicit AudioDevice(const AudioDeviceID resource)
    : m_resource(resource)
  {
  }

  /// Copy constructor
  constexpr AudioDevice(const AudioDevice& other) = delete;

  /// Move constructor
  constexpr AudioDevice(AudioDevice&& other)
    : AudioDevice(other.release())
  {
  }

  constexpr AudioDevice(const AudioDeviceRef& other) = delete;

  constexpr AudioDevice(AudioDeviceRef&& other) = delete;

  /**
   * Open a specific audio device.
   *
   * You can open both playback and recording devices through this function.
   * Playback devices will take data from bound audio streams, mix it, and send
   * it to the hardware. Recording devices will feed any bound audio streams
   * with a copy of any incoming data.
   *
   * An opened audio device starts out with no audio streams bound. To start
   * audio playing, bind a stream and supply audio data to it. Unlike SDL2,
   * there is no audio callback; you only bind audio streams and make sure they
   * have data flowing into them (however, you can simulate SDL2's semantics
   * fairly closely by using AudioStream.AudioStream instead of this
   * function).
   *
   * If you don't care about opening a specific device, pass a `devid` of either
   * `AUDIO_DEVICE_DEFAULT_PLAYBACK` or
   * `AUDIO_DEVICE_DEFAULT_RECORDING`. In this case, SDL will try to pick
   * the most reasonable default, and may also switch between physical devices
   * seamlessly later, if the most reasonable default changes during the
   * lifetime of this opened device (user changed the default in the OS's system
   * preferences, the default got unplugged so the system jumped to a new
   * default, the user plugged in headphones on a mobile device, etc). Unless
   * you have a good reason to choose a specific device, this is probably what
   * you want.
   *
   * You may request a specific format for the audio device, but there is no
   * promise the device will honor that request for several reasons. As such,
   * it's only meant to be a hint as to what data your app will provide. Audio
   * streams will accept data in whatever format you specify and manage
   * conversion for you as appropriate. AudioDevice.GetFormat can tell you
   * the preferred format for the device before opening and the actual format
   * the device is using after opening.
   *
   * It's legal to open the same device ID more than once; each successful open
   * will generate a new logical AudioDevice that is managed separately
   * from others on the same physical device. This allows libraries to open a
   * device separately from the main app and bind its own streams without
   * conflicting.
   *
   * It is also legal to open a device ID returned by a previous call to this
   * function; doing so just creates another logical device on the same physical
   * device. This may be useful for making logical groupings of audio streams.
   *
   * This function returns the opened device ID on success. This is a new,
   * unique AudioDevice that represents a logical device.
   *
   * Some backends might offer arbitrary devices (for example, a networked audio
   * protocol that can connect to an arbitrary server). For these, as a change
   * from SDL2, you should open a default device ID and use an SDL hint to
   * specify the target if you care, or otherwise let the backend figure out a
   * reasonable default. Most backends don't offer anything like this, and often
   * this would be an end user setting an environment variable for their custom
   * need, and not something an application should specifically manage.
   *
   * When done with an audio device, possibly at the end of the app's life, one
   * should call AudioDevice.Close() on the returned device id.
   *
   * @param devid the device instance id to open, or
   *              AUDIO_DEVICE_DEFAULT_PLAYBACK or
   *              AUDIO_DEVICE_DEFAULT_RECORDING for the most reasonable
   *              default device.
   * @param spec the requested device configuration. Can be nullptr to use
   *             reasonable defaults.
   * @post the device ID on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioDevice.Close
   * @sa AudioDevice.GetFormat
   */
  AudioDevice(AudioDeviceParam devid, OptionalRef<const AudioSpec> spec)
    : m_resource(CheckError(SDL_OpenAudioDevice(devid, spec)))
  {
  }

  /// Destructor
  ~AudioDevice() { SDL_CloseAudioDevice(m_resource); }

  /// Assignment operator.
  AudioDevice& operator=(AudioDevice other)
  {
    std::swap(m_resource, other.m_resource);
    return *this;
  }

  /// Retrieves underlying AudioDeviceID.
  constexpr AudioDeviceID get() const { return m_resource; }

  /// Retrieves underlying AudioDeviceID and clear this.
  constexpr AudioDeviceID release()
  {
    auto r = m_resource;
    m_resource = 0;
    return r;
  }

  /// Comparison
  constexpr auto operator<=>(const AudioDevice& other) const = default;

  /// Comparison
  constexpr bool operator==(std::nullptr_t _) const { return !m_resource; }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!m_resource; }

  /// Converts to AudioDeviceParam
  constexpr operator AudioDeviceParam() const { return {m_resource}; }

  /**
   * Close a previously-opened audio device.
   *
   * The application should close open audio devices once they are no longer
   * needed.
   *
   * This function may block briefly while pending audio data is played by the
   * hardware, so that applications don't drop the last buffer of data they
   * supplied if terminating immediately afterwards.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioDevice.AudioDevice
   */
  void Close();

  /**
   * Get the human-readable name of a specific audio device.
   *
   * @returns the name of the audio device on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa GetAudioPlaybackDevices
   * @sa GetAudioRecordingDevices
   */
  const char* GetName() const;

  /**
   * Get the current audio format of a specific audio device.
   *
   * For an opened device, this will report the format the device is currently
   * using. If the device isn't yet opened, this will report the device's
   * preferred format (or a reasonable default if this can't be determined).
   *
   * You may also specify AUDIO_DEVICE_DEFAULT_PLAYBACK or
   * AUDIO_DEVICE_DEFAULT_RECORDING here, which is useful for getting a
   * reasonable recommendation before opening the system-recommended default
   * device.
   *
   * You can also use this to request the current device buffer size. This is
   * specified in sample frames and represents the amount of data SDL will feed
   * to the physical hardware in each chunk. This can be converted to
   * milliseconds of audio with the following equation:
   *
   * `ms = (int) ((((Sint64) frames) * 1000) / spec.freq);`
   *
   * Buffer size is only important if you need low-level control over the audio
   * playback timing. Most apps do not need this.
   *
   * @param sample_frames pointer to store device buffer size, in sample frames.
   *                      Can be nullptr.
   * @returns the device format details on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  AudioSpec GetFormat(int* sample_frames = nullptr) const;

  /**
   * Get the current channel map of an audio device.
   *
   * Channel maps are optional; most things do not need them, instead passing
   * data in the [order that SDL expects](CategoryAudio#channel-layouts).
   *
   * Audio devices usually have no remapping applied. This is represented by
   * returning nullptr, and does not signify an error.
   *
   * @returns an array of the current channel mapping, with as many elements as
   *          the current output spec's channels, or nullptr if default
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.SetInputChannelMap
   */
  OwnArray<int> GetChannelMap() const;

  /**
   * Determine if an audio device is physical (instead of logical).
   *
   * An AudioDevice that represents physical hardware is a physical
   * device; there is one for each piece of hardware that SDL can see. Logical
   * devices are created by calling AudioDevice.AudioDevice or
   * AudioStream.AudioStream, and while each is associated with a physical
   * device, there can be any number of logical devices on one physical device.
   *
   * For the most part, logical and physical IDs are interchangeable--if you try
   * to open a logical device, SDL understands to assign that effort to the
   * underlying physical device, etc. However, it might be useful to know if an
   * arbitrary device ID is physical or logical. This function reports which.
   *
   * This function may return either true or false for invalid device IDs.
   *
   * @returns true if devid is a physical device, false if it is logical.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  bool IsPhysical() const;

  /**
   * Determine if an audio device is a playback device (instead of recording).
   *
   * This function may return either true or false for invalid device IDs.
   *
   * @returns true if devid is a playback device, false if it is recording.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  bool IsPlayback() const;

  /**
   * Use this function to pause audio playback on a specified device.
   *
   * This function pauses audio processing for a given device. Any bound audio
   * streams will not progress, and no audio will be generated. Pausing one
   * device does not prevent other unpaused devices from running.
   *
   * Unlike in SDL2, audio devices start in an _unpaused_ state, since an app
   * has to bind a stream before any audio will flow. Pausing a paused device is
   * a legal no-op.
   *
   * Pausing a device can be useful to halt all audio without unbinding all the
   * audio streams. This might be useful while a game is paused, or a level is
   * loading, etc.
   *
   * Physical devices can not be paused or unpaused, only logical devices
   * created through AudioDevice.AudioDevice() can be.
   *
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioDevice.Resume
   * @sa AudioDevice.Paused
   */
  void Pause();

  /**
   * Use this function to unpause audio playback on a specified device.
   *
   * This function unpauses audio processing for a given device that has
   * previously been paused with AudioDevice.Pause(). Once unpaused, any
   * bound audio streams will begin to progress again, and audio can be
   * generated.
   *
   * Unlike in SDL2, audio devices start in an _unpaused_ state, since an app
   * has to bind a stream before any audio will flow. Unpausing an unpaused
   * device is a legal no-op.
   *
   * Physical devices can not be paused or unpaused, only logical devices
   * created through AudioDevice.AudioDevice() can be.
   *
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioDevice.Paused
   * @sa AudioDevice.Pause
   */
  void Resume();

  /**
   * Use this function to query if an audio device is paused.
   *
   * Unlike in SDL2, audio devices start in an _unpaused_ state, since an app
   * has to bind a stream before any audio will flow.
   *
   * Physical devices can not be paused or unpaused, only logical devices
   * created through AudioDevice.AudioDevice() can be. Physical and invalid
   * device IDs will report themselves as unpaused here.
   *
   * @returns true if device is valid and paused, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioDevice.Pause
   * @sa AudioDevice.Resume
   */
  bool Paused() const;

  /**
   * Get the gain of an audio device.
   *
   * The gain of a device is its volume; a larger gain means a louder output,
   * with a gain of zero being silence.
   *
   * Audio devices default to a gain of 1.0f (no change in output).
   *
   * Physical devices may not have their gain changed, only logical devices, and
   * this function will always return -1.0f when used on physical devices.
   *
   * @returns the gain of the device or -1.0f on failure; call GetError()
   *          for more information.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioDevice.SetGain
   */
  float GetGain() const;

  /**
   * Change the gain of an audio device.
   *
   * The gain of a device is its volume; a larger gain means a louder output,
   * with a gain of zero being silence.
   *
   * Audio devices default to a gain of 1.0f (no change in output).
   *
   * Physical devices may not have their gain changed, only logical devices, and
   * this function will always return false when used on physical devices. While
   * it might seem attractive to adjust several logical devices at once in this
   * way, it would allow an app or library to interfere with another portion of
   * the program's otherwise-isolated devices.
   *
   * This is applied, along with any per-audiostream gain, during playback to
   * the hardware, and can be continuously changed to create various effects. On
   * recording devices, this will adjust the gain before passing the data into
   * an audiostream; that recording audiostream can then adjust its gain further
   * when outputting the data elsewhere, if it likes, but that second gain is
   * not applied until the data leaves the audiostream again.
   *
   * @param gain the gain. 1.0f is no change, 0.0f is silence.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread, as it holds
   *               a stream-specific mutex while running.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioDevice.GetGain
   */
  void SetGain(float gain);

  /**
   * Bind a list of audio streams to an audio device.
   *
   * Audio data will flow through any bound streams. For a playback device, data
   * for all bound streams will be mixed together and fed to the device. For a
   * recording device, a copy of recorded data will be provided to each bound
   * stream.
   *
   * Audio streams can only be bound to an open device. This operation is
   * atomic--all streams bound in the same call will start processing at the
   * same time, so they can stay in sync. Also: either all streams will be bound
   * or none of them will be.
   *
   * It is an error to bind an already-bound stream; it must be explicitly
   * unbound first.
   *
   * Binding a stream to a device will set its output format for playback
   * devices, and its input format for recording devices, so they match the
   * device's settings. The caller is welcome to change the other end of the
   * stream's format at any time with AudioStream.SetFormat(). If the other
   * end of the stream's format has never been set (the audio stream was created
   * with a nullptr audio spec), this function will set it to match the device
   * end's format.
   *
   * @param streams an array of audio streams to bind.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioDevice.BindAudioStreams
   * @sa AudioStream.Unbind
   * @sa AudioStream.GetDevice
   */
  void BindAudioStreams(std::span<AudioStreamRef> streams);

  /**
   * Bind a single audio stream to an audio device.
   *
   * This is a convenience function, equivalent to calling
   * `AudioDevice.BindAudioStreams(devid, &stream, 1)`.
   *
   * @param stream an audio stream to bind to a device.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioDevice.BindAudioStreams
   * @sa AudioStream.Unbind
   * @sa AudioStream.GetDevice
   */
  void BindAudioStream(AudioStreamParam stream);

  /**
   * Set a callback that fires when data is about to be fed to an audio device.
   *
   * This is useful for accessing the final mix, perhaps for writing a
   * visualizer or applying a final effect to the audio data before playback.
   *
   * The buffer is the final mix of all bound audio streams on an opened device;
   * this callback will fire regularly for any device that is both opened and
   * unpaused. If there is no new data to mix, either because no streams are
   * bound to the device or all the streams are empty, this callback will still
   * fire with the entire buffer set to silence.
   *
   * This callback is allowed to make changes to the data; the contents of the
   * buffer after this call is what is ultimately passed along to the hardware.
   *
   * The callback is always provided the data in float format (values from -1.0f
   * to 1.0f), but the number of channels or sample rate may be different than
   * the format the app requested when opening the device; SDL might have had to
   * manage a conversion behind the scenes, or the playback might have jumped to
   * new physical hardware when a system default changed, etc. These details may
   * change between calls. Accordingly, the size of the buffer might change
   * between calls as well.
   *
   * This callback can run at any time, and from any thread; if you need to
   * serialize access to your app's data, you should provide and use a mutex or
   * other synchronization device.
   *
   * All of this to say: there are specific needs this callback can fulfill, but
   * it is not the simplest interface. Apps should generally provide audio in
   * their preferred format through an AudioStream and let SDL handle the
   * difference.
   *
   * This function is extremely time-sensitive; the callback should do the least
   * amount of work possible and return as quickly as it can. The longer the
   * callback runs, the higher the risk of audio dropouts or other problems.
   *
   * This function will block until the audio device is in between iterations,
   * so any existing callback that might be running will finish before this
   * function sets the new callback and returns.
   *
   * Setting a nullptr callback function disables any previously-set callback.
   *
   * @param callback a callback function to be called. Can be nullptr.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void SetPostmixCallback(AudioPostmixCB callback);

  /**
   * Set a callback that fires when data is about to be fed to an audio device.
   *
   * This is useful for accessing the final mix, perhaps for writing a
   * visualizer or applying a final effect to the audio data before playback.
   *
   * The buffer is the final mix of all bound audio streams on an opened device;
   * this callback will fire regularly for any device that is both opened and
   * unpaused. If there is no new data to mix, either because no streams are
   * bound to the device or all the streams are empty, this callback will still
   * fire with the entire buffer set to silence.
   *
   * This callback is allowed to make changes to the data; the contents of the
   * buffer after this call is what is ultimately passed along to the hardware.
   *
   * The callback is always provided the data in float format (values from -1.0f
   * to 1.0f), but the number of channels or sample rate may be different than
   * the format the app requested when opening the device; SDL might have had to
   * manage a conversion behind the scenes, or the playback might have jumped to
   * new physical hardware when a system default changed, etc. These details may
   * change between calls. Accordingly, the size of the buffer might change
   * between calls as well.
   *
   * This callback can run at any time, and from any thread; if you need to
   * serialize access to your app's data, you should provide and use a mutex or
   * other synchronization device.
   *
   * All of this to say: there are specific needs this callback can fulfill, but
   * it is not the simplest interface. Apps should generally provide audio in
   * their preferred format through an AudioStream and let SDL handle the
   * difference.
   *
   * This function is extremely time-sensitive; the callback should do the least
   * amount of work possible and return as quickly as it can. The longer the
   * callback runs, the higher the risk of audio dropouts or other problems.
   *
   * This function will block until the audio device is in between iterations,
   * so any existing callback that might be running will finish before this
   * function sets the new callback and returns.
   *
   * Setting a nullptr callback function disables any previously-set callback.
   *
   * @param callback a callback function to be called. Can be nullptr.
   * @param userdata app-controlled pointer passed to callback. Can be nullptr.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void SetPostmixCallback(AudioPostmixCallback callback, void* userdata);

  /**
   * Convenience function for straightforward audio init for the common case.
   *
   * If all your app intends to do is provide a single source of PCM audio, this
   * function allows you to do all your audio setup in a single call.
   *
   * This is also intended to be a clean means to migrate apps from SDL2.
   *
   * This function will open an audio device, create a stream and bind it.
   * Unlike other methods of setup, the audio device will be closed when this
   * stream is destroyed, so the app can treat the returned AudioStream as
   * the only object needed to manage audio playback.
   *
   * Also unlike other functions, the audio device begins paused. This is to map
   * more closely to SDL2-style behavior, since there is no extra step here to
   * bind a stream to begin audio flowing. The audio device should be resumed
   * with `AudioStream.ResumeDevice(stream);`
   *
   * This function works with both playback and recording devices.
   *
   * The `spec` parameter represents the app's side of the audio stream. That
   * is, for recording audio, this will be the output format, and for playing
   * audio, this will be the input format. If spec is nullptr, the system will
   * choose the format, and the app can use AudioStream.GetFormat() to obtain
   * this information later.
   *
   * If you don't care about opening a specific audio device, you can (and
   * probably _should_), use AUDIO_DEVICE_DEFAULT_PLAYBACK for playback and
   * AUDIO_DEVICE_DEFAULT_RECORDING for recording.
   *
   * One can optionally provide a callback function; if nullptr, the app is
   * expected to queue audio data for playback (or unqueue audio data if
   * capturing). Otherwise, the callback will begin to fire once the device is
   * unpaused.
   *
   * Destroying the returned stream with AudioStream.Destroy will also close
   * the audio device associated with this stream.
   *
   * @param spec the audio stream's data format. Can be nullptr.
   * @param callback a callback where the app will provide new data for
   *                 playback, or receive new data for recording. Can be
   * nullptr, in which case the app will need to call AudioStream.PutData or
   * AudioStream.GetData as necessary.
   * @param userdata app-controlled pointer passed to callback. Can be nullptr.
   *                 Ignored if callback is nullptr.
   * @returns an audio stream on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.GetDevice
   * @sa AudioStream.ResumeDevice
   */
  AudioStream OpenStream(OptionalRef<const AudioSpec> spec,
                         AudioStreamCallback callback,
                         void* userdata);

  /**
   * Convenience function for straightforward audio init for the common case.
   *
   * If all your app intends to do is provide a single source of PCM audio, this
   * function allows you to do all your audio setup in a single call.
   *
   * This is also intended to be a clean means to migrate apps from SDL2.
   *
   * This function will open an audio device, create a stream and bind it.
   * Unlike other methods of setup, the audio device will be closed when this
   * stream is destroyed, so the app can treat the returned AudioStream as
   * the only object needed to manage audio playback.
   *
   * Also unlike other functions, the audio device begins paused. This is to map
   * more closely to SDL2-style behavior, since there is no extra step here to
   * bind a stream to begin audio flowing. The audio device should be resumed
   * with `AudioStream.ResumeDevice(stream);`
   *
   * This function works with both playback and recording devices.
   *
   * The `spec` parameter represents the app's side of the audio stream. That
   * is, for recording audio, this will be the output format, and for playing
   * audio, this will be the input format. If spec is nullptr, the system will
   * choose the format, and the app can use AudioStream.GetFormat() to obtain
   * this information later.
   *
   * If you don't care about opening a specific audio device, you can (and
   * probably _should_), use AUDIO_DEVICE_DEFAULT_PLAYBACK for playback and
   * AUDIO_DEVICE_DEFAULT_RECORDING for recording.
   *
   * One can optionally provide a callback function; if nullptr, the app is
   * expected to queue audio data for playback (or unqueue audio data if
   * capturing). Otherwise, the callback will begin to fire once the device is
   * unpaused.
   *
   * Destroying the returned stream with AudioStream.Destroy will also close
   * the audio device associated with this stream.
   *
   * @param spec the audio stream's data format. Can be nullptr.
   * @param callback a callback where the app will provide new data for
   *                 playback, or receive new data for recording.
   * @returns an audio stream on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.GetDevice
   * @sa AudioStream.ResumeDevice
   */
  AudioStream OpenStream(OptionalRef<const AudioSpec> spec,
                         AudioStreamCB callback);
};

/// Semi-safe reference for AudioDevice.
struct AudioDeviceRef : AudioDevice
{
  /**
   * Constructs from AudioDeviceParam.
   *
   * @param resource a AudioDeviceID or AudioDevice.
   *
   * This does not takes ownership!
   */
  AudioDeviceRef(AudioDeviceParam resource)
    : AudioDevice(resource.value)
  {
  }

  /// Copy constructor.
  AudioDeviceRef(const AudioDeviceRef& other)
    : AudioDevice(other.get())
  {
  }

  /// Destructor
  ~AudioDeviceRef() { release(); }
};

/**
 * A value used to request a default playback audio device.
 *
 * Several functions that require an AudioDevice will accept this value
 * to signify the app just wants the system to choose a default device instead
 * of the app providing a specific one.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr AudioDeviceID AUDIO_DEVICE_DEFAULT_PLAYBACK =
  SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK;

/**
 * A value used to request a default recording audio device.
 *
 * Several functions that require an AudioDevice will accept this value
 * to signify the app just wants the system to choose a default device instead
 * of the app providing a specific one.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr AudioDeviceID AUDIO_DEVICE_DEFAULT_RECORDING =
  SDL_AUDIO_DEVICE_DEFAULT_RECORDING;

/**
 * Calculate the size of each audio frame (in bytes) from an AudioSpec.
 *
 * This reports on the size of an audio sample frame: stereo Sint16 data (2
 * channels of 2 bytes each) would be 4 bytes per frame, for example.
 *
 * @param x an AudioSpec to query.
 * @returns the number of bytes used per sample frame.
 *
 * @threadsafety It is safe to call this macro from any thread.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr int AudioFrameSize(const AudioSpec& x)
{
  return SDL_AUDIO_FRAMESIZE(x);
}

/**
 * The opaque handle that represents an audio stream.
 *
 * AudioStream is an audio conversion interface.
 *
 * - It can handle resampling data in chunks without generating artifacts,
 *   when it doesn't have the complete buffer available.
 * - It can handle incoming data in any variable size.
 * - It can handle input/output format changes on the fly.
 * - It can remap audio channels between inputs and outputs.
 * - You push data as you have it, and pull it when you need it
 * - It can also function as a basic audio data queue even if you just have
 *   sound that needs to pass from one place to another.
 * - You can hook callbacks up to them when more data is added or requested,
 *   to manage data on-the-fly.
 *
 * Audio streams are the core of the SDL3 audio interface. You create one or
 * more of them, bind them to an opened audio device, and feed data to them
 * (or for recording, consume data from them).
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @sa AudioStream.AudioStream
 *
 * @cat resource
 */
class AudioStream
{
  AudioStreamRaw m_resource = nullptr;

public:
  /// Default ctor
  constexpr AudioStream() = default;

  /**
   * Constructs from AudioStreamParam.
   *
   * @param resource a AudioStreamRaw to be wrapped.
   *
   * This assumes the ownership, call release() if you need to take back.
   */
  constexpr explicit AudioStream(const AudioStreamRaw resource)
    : m_resource(resource)
  {
  }

  /// Copy constructor
  constexpr AudioStream(const AudioStream& other) = delete;

  /// Move constructor
  constexpr AudioStream(AudioStream&& other)
    : AudioStream(other.release())
  {
  }

  constexpr AudioStream(const AudioStreamRef& other) = delete;

  constexpr AudioStream(AudioStreamRef&& other) = delete;

  /**
   * Create a new audio stream.
   *
   * @param src_spec the format details of the input audio.
   * @param dst_spec the format details of the output audio.
   * @post a new audio stream on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.PutData
   * @sa AudioStream.GetData
   * @sa AudioStream.GetAvailable
   * @sa AudioStream.Flush
   * @sa AudioStream.Clear
   * @sa AudioStream.SetFormat
   * @sa AudioStream.Destroy
   */
  AudioStream(OptionalRef<const AudioSpec> src_spec,
              OptionalRef<const AudioSpec> dst_spec)
    : m_resource(CheckError(SDL_CreateAudioStream(src_spec, dst_spec)))
  {
  }

  /**
   * Convenience function for straightforward audio init for the common case.
   *
   * If all your app intends to do is provide a single source of PCM audio, this
   * function allows you to do all your audio setup in a single call.
   *
   * This is also intended to be a clean means to migrate apps from SDL2.
   *
   * This function will open an audio device, create a stream and bind it.
   * Unlike other methods of setup, the audio device will be closed when this
   * stream is destroyed, so the app can treat the returned AudioStream as
   * the only object needed to manage audio playback.
   *
   * Also unlike other functions, the audio device begins paused. This is to map
   * more closely to SDL2-style behavior, since there is no extra step here to
   * bind a stream to begin audio flowing. The audio device should be resumed
   * with `AudioStream.ResumeDevice(stream);`
   *
   * This function works with both playback and recording devices.
   *
   * The `spec` parameter represents the app's side of the audio stream. That
   * is, for recording audio, this will be the output format, and for playing
   * audio, this will be the input format. If spec is nullptr, the system will
   * choose the format, and the app can use AudioStream.GetFormat() to obtain
   * this information later.
   *
   * If you don't care about opening a specific audio device, you can (and
   * probably _should_), use AUDIO_DEVICE_DEFAULT_PLAYBACK for playback and
   * AUDIO_DEVICE_DEFAULT_RECORDING for recording.
   *
   * One can optionally provide a callback function; if nullptr, the app is
   * expected to queue audio data for playback (or unqueue audio data if
   * capturing). Otherwise, the callback will begin to fire once the device is
   * unpaused.
   *
   * Destroying the returned stream with AudioStream.Destroy will also close
   * the audio device associated with this stream.
   *
   * @param devid an audio device to open, or AUDIO_DEVICE_DEFAULT_PLAYBACK
   *              or AUDIO_DEVICE_DEFAULT_RECORDING.
   * @param spec the audio stream's data format. Can be nullptr.
   * @param callback a callback where the app will provide new data for
   *                 playback, or receive new data for recording. Can be
   * nullptr, in which case the app will need to call AudioStream.PutData or
   * AudioStream.GetData as necessary.
   * @param userdata app-controlled pointer passed to callback. Can be nullptr.
   *                 Ignored if callback is nullptr.
   * @post an audio stream on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.GetDevice
   * @sa AudioStream.ResumeDevice
   */
  AudioStream(AudioDeviceParam devid,
              OptionalRef<const AudioSpec> spec = std::nullopt,
              AudioStreamCallback callback = nullptr,
              void* userdata = nullptr)
    : m_resource(
        CheckError(SDL_OpenAudioDeviceStream(devid, spec, callback, userdata)))
  {
  }

  /**
   * Convenience function for straightforward audio init for the common case.
   *
   * If all your app intends to do is provide a single source of PCM audio, this
   * function allows you to do all your audio setup in a single call.
   *
   * This is also intended to be a clean means to migrate apps from SDL2.
   *
   * This function will open an audio device, create a stream and bind it.
   * Unlike other methods of setup, the audio device will be closed when this
   * stream is destroyed, so the app can treat the returned AudioStream as
   * the only object needed to manage audio playback.
   *
   * Also unlike other functions, the audio device begins paused. This is to map
   * more closely to SDL2-style behavior, since there is no extra step here to
   * bind a stream to begin audio flowing. The audio device should be resumed
   * with `AudioStream.ResumeDevice(stream);`
   *
   * This function works with both playback and recording devices.
   *
   * The `spec` parameter represents the app's side of the audio stream. That
   * is, for recording audio, this will be the output format, and for playing
   * audio, this will be the input format. If spec is nullptr, the system will
   * choose the format, and the app can use AudioStream.GetFormat() to obtain
   * this information later.
   *
   * If you don't care about opening a specific audio device, you can (and
   * probably _should_), use AUDIO_DEVICE_DEFAULT_PLAYBACK for playback and
   * AUDIO_DEVICE_DEFAULT_RECORDING for recording.
   *
   * One can optionally provide a callback function; if nullptr, the app is
   * expected to queue audio data for playback (or unqueue audio data if
   * capturing). Otherwise, the callback will begin to fire once the device is
   * unpaused.
   *
   * Destroying the returned stream with AudioStream.Destroy will also close
   * the audio device associated with this stream.
   *
   * @param devid an audio device to open, or AUDIO_DEVICE_DEFAULT_PLAYBACK
   *              or AUDIO_DEVICE_DEFAULT_RECORDING.
   * @param spec the audio stream's data format. Can be nullptr.
   * @param callback a callback where the app will provide new data for
   *                 playback, or receive new data for recording.
   * @post an audio stream on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.GetDevice
   * @sa AudioStream.ResumeDevice
   */
  AudioStream(AudioDeviceParam devid,
              OptionalRef<const AudioSpec> spec,
              AudioStreamCB callback);

  /// Destructor
  ~AudioStream() { SDL_DestroyAudioStream(m_resource); }

  /// Assignment operator.
  AudioStream& operator=(AudioStream other)
  {
    std::swap(m_resource, other.m_resource);
    return *this;
  }

  /// Retrieves underlying AudioStreamRaw.
  constexpr AudioStreamRaw get() const { return m_resource; }

  /// Retrieves underlying AudioStreamRaw and clear this.
  constexpr AudioStreamRaw release()
  {
    auto r = m_resource;
    m_resource = nullptr;
    return r;
  }

  /// Comparison
  constexpr auto operator<=>(const AudioStream& other) const = default;

  /// Comparison
  constexpr bool operator==(std::nullptr_t _) const { return !m_resource; }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!m_resource; }

  /// Converts to AudioStreamParam
  constexpr operator AudioStreamParam() const { return {m_resource}; }

  /**
   * Free an audio stream.
   *
   * This will release all allocated data, including any audio that is still
   * queued. You do not need to manually clear the stream first.
   *
   * If this stream was bound to an audio device, it is unbound during this
   * call. If this stream was created with AudioStream.AudioStream, the audio
   * device that was opened alongside this stream's creation will be closed,
   * too.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.AudioStream
   */
  void Destroy();

  /**
   * Get the properties associated with an audio stream.
   *
   * @returns a valid property ID on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  PropertiesRef GetProperties() const;

  /**
   * Query the current input format of an audio stream.
   *
   * @returns the input audio format.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread, as it holds
   *               a stream-specific mutex while running.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.SetFormat
   */
  AudioSpec GetInputFormat() const
  {
    AudioSpec spec;
    GetFormat(&spec, nullptr);
    return spec;
  }

  /**
   * Query the current output format of an audio stream.
   *
   * @returns the output audio format.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread, as it holds
   *               a stream-specific mutex while running.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.SetFormat
   */
  AudioSpec GetOutputFormat() const
  {
    AudioSpec spec;
    GetFormat(nullptr, &spec);
    return spec;
  }

  /**
   * Query the current format of an audio stream.
   *
   * @param src_spec where to store the input audio format; ignored if nullptr.
   * @param dst_spec where to store the output audio format; ignored if nullptr.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread, as it holds
   *               a stream-specific mutex while running.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.SetFormat
   */
  void GetFormat(AudioSpec* src_spec, AudioSpec* dst_spec) const;

  /**
   * Change the input format of an audio stream.
   *
   * Future calls to and AudioStreamRef.GetAvailable and
   * AudioStreamRef.GetData will reflect the new format, and future calls to
   * AudioStreamRef.PutData must provide data in the new input formats.
   *
   * Data that was previously queued in the stream will still be operated on in
   * the format that was current when it was added, which is to say you can put
   * the end of a sound file in one format to a stream, change formats for the
   * next sound file, and start putting that new data while the previous sound
   * file is still queued, and everything will still play back correctly.
   *
   * If a stream is bound to a device, then the format of the side of the stream
   * bound to a device cannot be changed (src_spec for recording devices,
   * dst_spec for playback devices). Attempts to make a change to this side will
   * be ignored, but this will not report an error. The other side's format can
   * be changed.
   *
   * @param spec the new format of the audio input.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread, as it holds
   *               a stream-specific mutex while running.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.GetFormat
   * @sa AudioStream.SetFrequencyRatio
   */
  void SetInputFormat(const AudioSpec& spec) { SetFormat(spec, std::nullopt); }

  /**
   * Change the output format of an audio stream.
   *
   * Future calls to and AudioStreamRef.GetAvailable and
   * AudioStreamRef.GetData will reflect the new format, and future calls to
   * AudioStreamRef.PutData must provide data in the new input formats.
   *
   * Data that was previously queued in the stream will still be operated on in
   * the format that was current when it was added, which is to say you can put
   * the end of a sound file in one format to a stream, change formats for the
   * next sound file, and start putting that new data while the previous sound
   * file is still queued, and everything will still play back correctly.
   *
   * If a stream is bound to a device, then the format of the side of the stream
   * bound to a device cannot be changed (src_spec for recording devices,
   * dst_spec for playback devices). Attempts to make a change to this side will
   * be ignored, but this will not report an error. The other side's format can
   * be changed.
   *
   * @param spec the new format of the audio output.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread, as it holds
   *               a stream-specific mutex while running.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.GetFormat
   * @sa AudioStream.SetFrequencyRatio
   */
  void SetOutputFormat(const AudioSpec& spec) { SetFormat(std::nullopt, spec); }

  /**
   * Change the input and output formats of an audio stream.
   *
   * Future calls to and AudioStream.GetAvailable and AudioStream.GetData
   * will reflect the new format, and future calls to AudioStream.PutData
   * must provide data in the new input formats.
   *
   * Data that was previously queued in the stream will still be operated on in
   * the format that was current when it was added, which is to say you can put
   * the end of a sound file in one format to a stream, change formats for the
   * next sound file, and start putting that new data while the previous sound
   * file is still queued, and everything will still play back correctly.
   *
   * If a stream is bound to a device, then the format of the side of the stream
   * bound to a device cannot be changed (src_spec for recording devices,
   * dst_spec for playback devices). Attempts to make a change to this side will
   * be ignored, but this will not report an error. The other side's format can
   * be changed.
   *
   * @param src_spec the new format of the audio input; if nullptr, it is not
   *                 changed.
   * @param dst_spec the new format of the audio output; if nullptr, it is not
   *                 changed.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread, as it holds
   *               a stream-specific mutex while running.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.GetFormat
   * @sa AudioStream.SetFrequencyRatio
   */
  void SetFormat(OptionalRef<const AudioSpec> src_spec,
                 OptionalRef<const AudioSpec> dst_spec);

  /**
   * Get the frequency ratio of an audio stream.
   *
   * @returns the frequency ratio of the stream or 0.0 on failure; call
   *          GetError() for more information.
   *
   * @threadsafety It is safe to call this function from any thread, as it holds
   *               a stream-specific mutex while running.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.SetFrequencyRatio
   */
  float GetFrequencyRatio() const;

  /**
   * Change the frequency ratio of an audio stream.
   *
   * The frequency ratio is used to adjust the rate at which input data is
   * consumed. Changing this effectively modifies the speed and pitch of the
   * audio. A value greater than 1.0 will play the audio faster, and at a higher
   * pitch. A value less than 1.0 will play the audio slower, and at a lower
   * pitch.
   *
   * This is applied during AudioStream.GetData, and can be continuously
   * changed to create various effects.
   *
   * @param ratio the frequency ratio. 1.0 is normal speed. Must be between 0.01
   *              and 100.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread, as it holds
   *               a stream-specific mutex while running.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.GetFrequencyRatio
   * @sa AudioStream.SetFormat
   */
  void SetFrequencyRatio(float ratio);

  /**
   * Get the gain of an audio stream.
   *
   * The gain of a stream is its volume; a larger gain means a louder output,
   * with a gain of zero being silence.
   *
   * Audio streams default to a gain of 1.0f (no change in output).
   *
   * @returns the gain of the stream or -1.0f on failure; call GetError()
   *          for more information.
   *
   * @threadsafety It is safe to call this function from any thread, as it holds
   *               a stream-specific mutex while running.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.SetGain
   */
  float GetGain() const;

  /**
   * Change the gain of an audio stream.
   *
   * The gain of a stream is its volume; a larger gain means a louder output,
   * with a gain of zero being silence.
   *
   * Audio streams default to a gain of 1.0f (no change in output).
   *
   * This is applied during AudioStream.GetData, and can be continuously
   * changed to create various effects.
   *
   * @param gain the gain. 1.0f is no change, 0.0f is silence.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread, as it holds
   *               a stream-specific mutex while running.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.GetGain
   */
  void SetGain(float gain);

  /**
   * Get the current input channel map of an audio stream.
   *
   * Channel maps are optional; most things do not need them, instead passing
   * data in the [order that SDL expects](CategoryAudio#channel-layouts).
   *
   * Audio streams default to no remapping applied. This is represented by
   * returning nullptr, and does not signify an error.
   *
   * @returns an array of the current channel mapping, with as many elements as
   *          the current output spec's channels, or nullptr if default.
   *
   * @threadsafety It is safe to call this function from any thread, as it holds
   *               a stream-specific mutex while running.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.SetInputChannelMap
   */
  OwnArray<int> GetInputChannelMap() const;

  /**
   * Get the current output channel map of an audio stream.
   *
   * Channel maps are optional; most things do not need them, instead passing
   * data in the [order that SDL expects](CategoryAudio#channel-layouts).
   *
   * Audio streams default to no remapping applied. This is represented by
   * returning nullptr, and does not signify an error.
   *
   * @returns an array of the current channel mapping, with as many elements as
   *          the current output spec's channels, or nullptr if default.
   *
   * @threadsafety It is safe to call this function from any thread, as it holds
   *               a stream-specific mutex while running.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.SetInputChannelMap
   */
  OwnArray<int> GetOutputChannelMap() const;

  /**
   * Set the current input channel map of an audio stream.
   *
   * Channel maps are optional; most things do not need them, instead passing
   * data in the [order that SDL expects](CategoryAudio#channel-layouts).
   *
   * The input channel map reorders data that is added to a stream via
   * AudioStream.PutData. Future calls to AudioStream.PutData must provide
   * data in the new channel order.
   *
   * Each item in the array represents an input channel, and its value is the
   * channel that it should be remapped to. To reverse a stereo signal's left
   * and right values, you'd have an array of `{ 1, 0 }`. It is legal to remap
   * multiple channels to the same thing, so `{ 1, 1 }` would duplicate the
   * right channel to both channels of a stereo signal. An element in the
   * channel map set to -1 instead of a valid channel will mute that channel,
   * setting it to a silence value.
   *
   * You cannot change the number of channels through a channel map, just
   * reorder/mute them.
   *
   * Data that was previously queued in the stream will still be operated on in
   * the order that was current when it was added, which is to say you can put
   * the end of a sound file in one order to a stream, change orders for the
   * next sound file, and start putting that new data while the previous sound
   * file is still queued, and everything will still play back correctly.
   *
   * Audio streams default to no remapping applied. Passing a nullptr channel
   * map is legal, and turns off remapping.
   *
   * SDL will copy the channel map; the caller does not have to save this array
   * after this call.
   *
   * If `count` is not equal to the current number of channels in the audio
   * stream's format, this will fail. This is a safety measure to make sure a
   * race condition hasn't changed the format while this call is setting the
   * channel map.
   *
   * Unlike attempting to change the stream's format, the input channel map on a
   * stream bound to a recording device is permitted to change at any time; any
   * data added to the stream from the device after this call will have the new
   * mapping, but previously-added data will still have the prior mapping.
   *
   * @param chmap the new channel map, nullptr to reset to default.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread, as it holds
   *               a stream-specific mutex while running. Don't change the
   *               stream's format to have a different number of channels from a
   *               a different thread at the same time, though!
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.SetInputChannelMap
   */
  void SetInputChannelMap(std::span<int> chmap);

  /**
   * Set the current output channel map of an audio stream.
   *
   * Channel maps are optional; most things do not need them, instead passing
   * data in the [order that SDL expects](CategoryAudio#channel-layouts).
   *
   * The output channel map reorders data that leaving a stream via
   * AudioStream.GetData.
   *
   * Each item in the array represents an input channel, and its value is the
   * channel that it should be remapped to. To reverse a stereo signal's left
   * and right values, you'd have an array of `{ 1, 0 }`. It is legal to remap
   * multiple channels to the same thing, so `{ 1, 1 }` would duplicate the
   * right channel to both channels of a stereo signal. An element in the
   * channel map set to -1 instead of a valid channel will mute that channel,
   * setting it to a silence value.
   *
   * You cannot change the number of channels through a channel map, just
   * reorder/mute them.
   *
   * The output channel map can be changed at any time, as output remapping is
   * applied during AudioStream.GetData.
   *
   * Audio streams default to no remapping applied. Passing a nullptr channel
   * map is legal, and turns off remapping.
   *
   * SDL will copy the channel map; the caller does not have to save this array
   * after this call.
   *
   * If `count` is not equal to the current number of channels in the audio
   * stream's format, this will fail. This is a safety measure to make sure a
   * race condition hasn't changed the format while this call is setting the
   * channel map.
   *
   * Unlike attempting to change the stream's format, the output channel map on
   * a stream bound to a recording device is permitted to change at any time;
   * any data added to the stream after this call will have the new mapping, but
   * previously-added data will still have the prior mapping. When the channel
   * map doesn't match the hardware's channel layout, SDL will convert the data
   * before feeding it to the device for playback.
   *
   * @param chmap the new channel map, nullptr to reset to default.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread, as it holds
   *               a stream-specific mutex while running. Don't change the
   *               stream's format to have a different number of channels from a
   *               a different thread at the same time, though!
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.SetInputChannelMap
   */
  void SetOutputChannelMap(std::span<int> chmap);

  /**
   * Add data to the stream.
   *
   * This data must match the format/channels/samplerate specified in the latest
   * call to AudioStream.SetFormat, or the format specified when creating the
   * stream if it hasn't been changed.
   *
   * Note that this call simply copies the unconverted data for later. This is
   * different than SDL2, where data was converted during the Put call and the
   * Get call would just dequeue the previously-converted data.
   *
   * @param buf a pointer to the audio data to add.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread, but if the
   *               stream has a callback set, the caller might need to manage
   *               extra locking.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.Clear
   * @sa AudioStream.Flush
   * @sa AudioStream.GetData
   * @sa AudioStream.GetQueued
   */
  void PutData(SourceBytes buf);

  /**
   * Get converted/resampled data from the stream.
   *
   * The input/output data format/channels/samplerate is specified when creating
   * the stream, and can be changed after creation by calling
   * AudioStream.SetFormat.
   *
   * Note that any conversion and resampling necessary is done during this call,
   * and AudioStream.PutData simply queues unconverted data for later. This
   * is different than SDL2, where that work was done while inputting new data
   * to the stream and requesting the output just copied the converted data.
   *
   * @param buf a buffer to fill with audio data.
   * @returns the number of bytes read from the stream or -1 on failure; call
   *          GetError() for more information.
   *
   * @threadsafety It is safe to call this function from any thread, but if the
   *               stream has a callback set, the caller might need to manage
   *               extra locking.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.Clear
   * @sa AudioStream.GetAvailable
   * @sa AudioStream.PutData
   */
  int GetData(TargetBytes buf);

  /**
   * Get the number of converted/resampled bytes available.
   *
   * The stream may be buffering data behind the scenes until it has enough to
   * resample correctly, so this number might be lower than what you expect, or
   * even be zero. Add more data or flush the stream if you need the data now.
   *
   * If the stream has so much data that it would overflow an int, the return
   * value is clamped to a maximum value, but no queued data is lost; if there
   * are gigabytes of data queued, the app might need to read some of it with
   * AudioStream.GetData before this function's return value is no longer
   * clamped.
   *
   * @returns the number of converted/resampled bytes available or -1 on
   *          failure; call GetError() for more information.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.GetData
   * @sa AudioStream.PutData
   */
  int GetAvailable() const;

  /**
   * Get the number of bytes currently queued.
   *
   * This is the number of bytes put into a stream as input, not the number that
   * can be retrieved as output. Because of several details, it's not possible
   * to calculate one number directly from the other. If you need to know how
   * much usable data can be retrieved right now, you should use
   * AudioStream.GetAvailable() and not this function.
   *
   * Note that audio streams can change their input format at any time, even if
   * there is still data queued in a different format, so the returned byte
   * count will not necessarily match the number of _sample frames_ available.
   * Users of this API should be aware of format changes they make when feeding
   * a stream and plan accordingly.
   *
   * Queued data is not converted until it is consumed by
   * AudioStream.GetData, so this value should be representative of the exact
   * data that was put into the stream.
   *
   * If the stream has so much data that it would overflow an int, the return
   * value is clamped to a maximum value, but no queued data is lost; if there
   * are gigabytes of data queued, the app might need to read some of it with
   * AudioStream.GetData before this function's return value is no longer
   * clamped.
   *
   * @returns the number of bytes queued or -1 on failure; call GetError()
   *          for more information.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.PutData
   * @sa AudioStream.Clear
   */
  int GetQueued() const;

  /**
   * Tell the stream that you're done sending data, and anything being buffered
   * should be converted/resampled and made available immediately.
   *
   * It is legal to add more data to a stream after flushing, but there may be
   * audio gaps in the output. Generally this is intended to signal the end of
   * input, so the complete output becomes available.
   *
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.PutData
   */
  void Flush();

  /**
   * Clear any pending data in the stream.
   *
   * This drops any queued data, so there will be nothing to read from the
   * stream until more is added.
   *
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.GetAvailable
   * @sa AudioStream.GetData
   * @sa AudioStream.GetQueued
   * @sa AudioStream.PutData
   */
  void Clear();

  /**
   * Use this function to pause audio playback on the audio device associated
   * with an audio stream.
   *
   * This function pauses audio processing for a given device. Any bound audio
   * streams will not progress, and no audio will be generated. Pausing one
   * device does not prevent other unpaused devices from running.
   *
   * Pausing a device can be useful to halt all audio without unbinding all the
   * audio streams. This might be useful while a game is paused, or a level is
   * loading, etc.
   *
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.ResumeDevice
   */
  void PauseDevice();

  /**
   * Use this function to unpause audio playback on the audio device associated
   * with an audio stream.
   *
   * This function unpauses audio processing for a given device that has
   * previously been paused. Once unpaused, any bound audio streams will begin
   * to progress again, and audio can be generated.
   *
   * Remember, AudioStream.AudioStream opens device in a paused state, so this
   * function call is required for audio playback to begin on such device.
   *
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.PauseDevice
   */
  void ResumeDevice();

  /**
   * Use this function to query if an audio device associated with a stream is
   * paused.
   *
   * Unlike in SDL2, audio devices start in an _unpaused_ state, since an app
   * has to bind a stream before any audio will flow.
   *
   * @returns true if device is valid and paused, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.PauseDevice
   * @sa AudioStream.ResumeDevice
   */
  bool DevicePaused() const;

  /**
   * Lock an audio stream for serialized access.
   *
   * Each AudioStream has an internal mutex it uses to protect its data
   * structures from threading conflicts. This function allows an app to lock
   * that mutex, which could be useful if registering callbacks on this stream.
   *
   * One does not need to lock a stream to use in it most cases, as the stream
   * manages this lock internally. However, this lock is held during callbacks,
   * which may run from arbitrary threads at any time, so if an app needs to
   * protect shared data during those callbacks, locking the stream guarantees
   * that the callback is not running while the lock is held.
   *
   * As this is just a wrapper over SDL_LockMutex for an internal lock; it has
   * all the same attributes (recursive locks are allowed, etc).
   *
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.Unlock
   */
  void Lock();

  /**
   * Unlock an audio stream for serialized access.
   *
   * This unlocks an audio stream after a call to AudioStream.Lock.
   *
   * @throws Error on failure.
   *
   * @threadsafety You should only call this from the same thread that
   *               previously called AudioStream.Lock.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.Lock
   */
  void Unlock();

  /**
   * Set a callback that runs when data is requested from an audio stream.
   *
   * This callback is called _before_ data is obtained from the stream, giving
   * the callback the chance to add more on-demand.
   *
   * The callback can (optionally) call AudioStreamRef.PutData() to add more
   * audio to the stream during this call; if needed, the request that triggered
   * this callback will obtain the new data immediately.
   *
   * The callback's `additional_amount` argument is roughly how many bytes of
   * _unconverted_ data (in the stream's input format) is needed by the caller,
   * although this may overestimate a little for safety. This takes into account
   * how much is already in the stream and only asks for any extra necessary to
   * resolve the request, which means the callback may be asked for zero bytes,
   * and a different amount on each call.
   *
   * The callback is not required to supply exact amounts; it is allowed to
   * supply too much or too little or none at all. The caller will get what's
   * available, up to the amount they requested, regardless of this callback's
   * outcome.
   *
   * Clearing or flushing an audio stream does not call this callback.
   *
   * This function obtains the stream's lock, which means any existing callback
   * (get or put) in progress will finish running before setting the new
   * callback.
   *
   * Setting a nullptr function turns off the callback.
   *
   * @param callback the new callback function to call when data is requested
   *                 from the stream.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.SetPutCallback
   */
  void SetGetCallback(AudioStreamCB callback);

  /**
   * Set a callback that runs when data is requested from an audio stream.
   *
   * This callback is called _before_ data is obtained from the stream, giving
   * the callback the chance to add more on-demand.
   *
   * The callback can (optionally) call AudioStream.PutData() to add more
   * audio to the stream during this call; if needed, the request that triggered
   * this callback will obtain the new data immediately.
   *
   * The callback's `additional_amount` argument is roughly how many bytes of
   * _unconverted_ data (in the stream's input format) is needed by the caller,
   * although this may overestimate a little for safety. This takes into account
   * how much is already in the stream and only asks for any extra necessary to
   * resolve the request, which means the callback may be asked for zero bytes,
   * and a different amount on each call.
   *
   * The callback is not required to supply exact amounts; it is allowed to
   * supply too much or too little or none at all. The caller will get what's
   * available, up to the amount they requested, regardless of this callback's
   * outcome.
   *
   * Clearing or flushing an audio stream does not call this callback.
   *
   * This function obtains the stream's lock, which means any existing callback
   * (get or put) in progress will finish running before setting the new
   * callback.
   *
   * Setting a nullptr function turns off the callback.
   *
   * @param callback the new callback function to call when data is requested
   *                 from the stream.
   * @param userdata an opaque pointer provided to the callback for its own
   *                 personal use.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.SetPutCallback
   */
  void SetGetCallback(AudioStreamCallback callback, void* userdata);

  /**
   * Set a callback that runs when data is added to an audio stream.
   *
   * This callback is called _after_ the data is added to the stream, giving the
   * callback the chance to obtain it immediately.
   *
   * The callback can (optionally) call AudioStreamRef.GetData() to obtain
   * audio from the stream during this call.
   *
   * The callback's `additional_amount` argument is how many bytes of
   * _converted_ data (in the stream's output format) was provided by the
   * caller, although this may underestimate a little for safety. This value
   * might be less than what is currently available in the stream, if data was
   * already there, and might be less than the caller provided if the stream
   * needs to keep a buffer to aid in resampling. Which means the callback may
   * be provided with zero bytes, and a different amount on each call.
   *
   * The callback may call AudioStreamRef.GetAvailable to see the total amount
   * currently available to read from the stream, instead of the total provided
   * by the current call.
   *
   * The callback is not required to obtain all data. It is allowed to read less
   * or none at all. Anything not read now simply remains in the stream for
   * later access.
   *
   * Clearing or flushing an audio stream does not call this callback.
   *
   * This function obtains the stream's lock, which means any existing callback
   * (get or put) in progress will finish running before setting the new
   * callback.
   *
   * Setting a nullptr function turns off the callback.
   *
   * @param callback the new callback function to call when data is added to the
   *                 stream.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.SetGetCallback
   */
  void SetPutCallback(AudioStreamCB callback);

  /**
   * Set a callback that runs when data is added to an audio stream.
   *
   * This callback is called _after_ the data is added to the stream, giving the
   * callback the chance to obtain it immediately.
   *
   * The callback can (optionally) call AudioStream.GetData() to obtain audio
   * from the stream during this call.
   *
   * The callback's `additional_amount` argument is how many bytes of
   * _converted_ data (in the stream's output format) was provided by the
   * caller, although this may underestimate a little for safety. This value
   * might be less than what is currently available in the stream, if data was
   * already there, and might be less than the caller provided if the stream
   * needs to keep a buffer to aid in resampling. Which means the callback may
   * be provided with zero bytes, and a different amount on each call.
   *
   * The callback may call AudioStream.GetAvailable to see the total amount
   * currently available to read from the stream, instead of the total provided
   * by the current call.
   *
   * The callback is not required to obtain all data. It is allowed to read less
   * or none at all. Anything not read now simply remains in the stream for
   * later access.
   *
   * Clearing or flushing an audio stream does not call this callback.
   *
   * This function obtains the stream's lock, which means any existing callback
   * (get or put) in progress will finish running before setting the new
   * callback.
   *
   * Setting a nullptr function turns off the callback.
   *
   * @param callback the new callback function to call when data is added to the
   *                 stream.
   * @param userdata an opaque pointer provided to the callback for its own
   *                 personal use.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioStream.SetGetCallback
   */
  void SetPutCallback(AudioStreamCallback callback, void* userdata);

  /**
   * Unbind a single audio stream from its audio device.
   *
   * This is a convenience function, equivalent to calling
   * `UnbindAudioStreams(&stream, 1)`.
   *
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioDevice.BindAudioStream
   */
  void Unbind();

  /**
   * Query an audio stream for its currently-bound device.
   *
   * This reports the logical audio device that an audio stream is currently
   * bound to.
   *
   * If not bound, or invalid, this returns zero, which is not a valid device
   * ID.
   *
   * @returns the bound audio device, or 0 if not bound or invalid.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa AudioDevice.BindAudioStream
   * @sa AudioDevice.BindAudioStreams
   */
  AudioDeviceRef GetDevice() const;
};

/// Semi-safe reference for AudioStream.
struct AudioStreamRef : AudioStream
{
  /**
   * Constructs from AudioStreamParam.
   *
   * @param resource a AudioStreamRaw or AudioStream.
   *
   * This does not takes ownership!
   */
  AudioStreamRef(AudioStreamParam resource)
    : AudioStream(resource.value)
  {
  }

  /// Copy constructor.
  AudioStreamRef(const AudioStreamRef& other)
    : AudioStream(other.get())
  {
  }

  /// Destructor
  ~AudioStreamRef() { release(); }
};

/**
 * Use this function to get the number of built-in audio drivers.
 *
 * This function returns a hardcoded number. This never returns a negative
 * value; if there are no drivers compiled into this build of SDL, this
 * function returns zero. The presence of a driver in this list does not mean
 * it will function, it just means SDL is capable of interacting with that
 * interface. For example, a build of SDL might have esound support, but if
 * there's no esound server available, SDL's esound driver would fail if used.
 *
 * By default, SDL tries all drivers, in its preferred order, until one is
 * found to be usable.
 *
 * @returns the number of built-in audio drivers.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetAudioDriver
 */
inline int GetNumAudioDrivers() { return SDL_GetNumAudioDrivers(); }

/**
 * Use this function to get the name of a built in audio driver.
 *
 * The list of audio drivers is given in the order that they are normally
 * initialized by default; the drivers that seem more reasonable to choose
 * first (as far as the SDL developers believe) are earlier in the list.
 *
 * The names of drivers are all simple, low-ASCII identifiers, like "alsa",
 * "coreaudio" or "wasapi". These never have Unicode characters, and are not
 * meant to be proper names.
 *
 * @param index the index of the audio driver; the value ranges from 0 to
 *              GetNumAudioDrivers() - 1.
 * @returns the name of the audio driver at the requested index, or nullptr if
 * an invalid index was specified.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetNumAudioDrivers
 */
inline const char* GetAudioDriver(int index)
{
  return SDL_GetAudioDriver(index);
}

/**
 * Get the name of the current audio driver.
 *
 * The names of drivers are all simple, low-ASCII identifiers, like "alsa",
 * "coreaudio" or "wasapi". These never have Unicode characters, and are not
 * meant to be proper names.
 *
 * @returns the name of the current audio driver or nullptr if no driver has
 * been initialized.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline const char* GetCurrentAudioDriver()
{
  return SDL_GetCurrentAudioDriver();
}

/**
 * Get a list of currently-connected audio playback devices.
 *
 * This returns of list of available devices that play sound, perhaps to
 * speakers or headphones ("playback" devices). If you want devices that
 * record audio, like a microphone ("recording" devices), use
 * GetAudioRecordingDevices() instead.
 *
 * This only returns a list of physical devices; it will not have any device
 * IDs returned by AudioDevice.AudioDevice().
 *
 * If this function returns nullptr, to signify an error, `*count` will be set
 * to zero.
 *
 * @returns a 0 terminated array of device instance IDs on success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioDevice.AudioDevice
 * @sa GetAudioRecordingDevices
 */
inline OwnArray<AudioDeviceRef> GetAudioPlaybackDevices()
{
  int count;
  auto data = CheckError(SDL_GetAudioPlaybackDevices(&count));
  return OwnArray<AudioDeviceRef>{reinterpret_cast<AudioDeviceRef*>(data),
                                  size_t(count)};
}

/**
 * Get a list of currently-connected audio recording devices.
 *
 * This returns of list of available devices that record audio, like a
 * microphone ("recording" devices). If you want devices that play sound,
 * perhaps to speakers or headphones ("playback" devices), use
 * GetAudioPlaybackDevices() instead.
 *
 * This only returns a list of physical devices; it will not have any device
 * IDs returned by AudioDevice.AudioDevice().
 *
 * If this function returns nullptr, to signify an error, `*count` will be set
 * to zero.
 *
 * @returns a 0 terminated array of device instance IDs on success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioDevice.AudioDevice
 * @sa GetAudioPlaybackDevices
 */
inline OwnArray<AudioDeviceRef> GetAudioRecordingDevices()
{
  int count;
  auto data = CheckError(SDL_GetAudioRecordingDevices(&count));
  return OwnArray<AudioDeviceRef>{reinterpret_cast<AudioDeviceRef*>(data),
                                  size_t(count)};
}

/**
 * Get the human-readable name of a specific audio device.
 *
 * @param devid the instance ID of the device to query.
 * @returns the name of the audio device on success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetAudioPlaybackDevices
 * @sa GetAudioRecordingDevices
 */
inline const char* GetAudioDeviceName(AudioDeviceParam devid)
{
  return CheckError(SDL_GetAudioDeviceName(devid));
}

inline const char* AudioDevice::GetName() const
{
  return SDL::GetAudioDeviceName(m_resource);
}

/**
 * Get the current audio format of a specific audio device.
 *
 * For an opened device, this will report the format the device is currently
 * using. If the device isn't yet opened, this will report the device's
 * preferred format (or a reasonable default if this can't be determined).
 *
 * You may also specify AUDIO_DEVICE_DEFAULT_PLAYBACK or
 * AUDIO_DEVICE_DEFAULT_RECORDING here, which is useful for getting a
 * reasonable recommendation before opening the system-recommended default
 * device.
 *
 * You can also use this to request the current device buffer size. This is
 * specified in sample frames and represents the amount of data SDL will feed
 * to the physical hardware in each chunk. This can be converted to
 * milliseconds of audio with the following equation:
 *
 * `ms = (int) ((((Sint64) frames) * 1000) / spec.freq);`
 *
 * Buffer size is only important if you need low-level control over the audio
 * playback timing. Most apps do not need this.
 *
 * @param devid the instance ID of the device to query.
 * @param spec on return, will be filled with device details.
 * @param sample_frames pointer to store device buffer size, in sample frames.
 *                      Can be nullptr.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline AudioSpec GetAudioDeviceFormat(AudioDeviceParam devid,
                                      int* sample_frames = nullptr)
{
  AudioSpec spec;
  CheckError(SDL_GetAudioDeviceFormat(devid, &spec, sample_frames));
  return spec;
}

inline AudioSpec AudioDevice::GetFormat(int* sample_frames) const
{
  return SDL::GetAudioDeviceFormat(m_resource, sample_frames);
}

/**
 * Get the current channel map of an audio device.
 *
 * Channel maps are optional; most things do not need them, instead passing
 * data in the [order that SDL expects](CategoryAudio#channel-layouts).
 *
 * Audio devices usually have no remapping applied. This is represented by
 * returning nullptr, and does not signify an error.
 *
 * @param devid the instance ID of the device to query.
 * @returns an array of the current channel mapping, with as many elements as
 *          the current output spec's channels, or nullptr if default
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.SetInputChannelMap
 */
inline OwnArray<int> GetAudioDeviceChannelMap(AudioDeviceParam devid)
{
  int count;
  auto data = SDL_GetAudioDeviceChannelMap(devid, &count);
  return OwnArray<int>{data, size_t(count)};
}

inline OwnArray<int> AudioDevice::GetChannelMap() const
{
  return SDL::GetAudioDeviceChannelMap(m_resource);
}

/**
 * Open a specific audio device.
 *
 * You can open both playback and recording devices through this function.
 * Playback devices will take data from bound audio streams, mix it, and send
 * it to the hardware. Recording devices will feed any bound audio streams
 * with a copy of any incoming data.
 *
 * An opened audio device starts out with no audio streams bound. To start
 * audio playing, bind a stream and supply audio data to it. Unlike SDL2,
 * there is no audio callback; you only bind audio streams and make sure they
 * have data flowing into them (however, you can simulate SDL2's semantics
 * fairly closely by using AudioStream.AudioStream instead of this
 * function).
 *
 * If you don't care about opening a specific device, pass a `devid` of either
 * `AUDIO_DEVICE_DEFAULT_PLAYBACK` or
 * `AUDIO_DEVICE_DEFAULT_RECORDING`. In this case, SDL will try to pick
 * the most reasonable default, and may also switch between physical devices
 * seamlessly later, if the most reasonable default changes during the
 * lifetime of this opened device (user changed the default in the OS's system
 * preferences, the default got unplugged so the system jumped to a new
 * default, the user plugged in headphones on a mobile device, etc). Unless
 * you have a good reason to choose a specific device, this is probably what
 * you want.
 *
 * You may request a specific format for the audio device, but there is no
 * promise the device will honor that request for several reasons. As such,
 * it's only meant to be a hint as to what data your app will provide. Audio
 * streams will accept data in whatever format you specify and manage
 * conversion for you as appropriate. AudioDevice.GetFormat can tell you
 * the preferred format for the device before opening and the actual format
 * the device is using after opening.
 *
 * It's legal to open the same device ID more than once; each successful open
 * will generate a new logical AudioDevice that is managed separately
 * from others on the same physical device. This allows libraries to open a
 * device separately from the main app and bind its own streams without
 * conflicting.
 *
 * It is also legal to open a device ID returned by a previous call to this
 * function; doing so just creates another logical device on the same physical
 * device. This may be useful for making logical groupings of audio streams.
 *
 * This function returns the opened device ID on success. This is a new,
 * unique AudioDevice that represents a logical device.
 *
 * Some backends might offer arbitrary devices (for example, a networked audio
 * protocol that can connect to an arbitrary server). For these, as a change
 * from SDL2, you should open a default device ID and use an SDL hint to
 * specify the target if you care, or otherwise let the backend figure out a
 * reasonable default. Most backends don't offer anything like this, and often
 * this would be an end user setting an environment variable for their custom
 * need, and not something an application should specifically manage.
 *
 * When done with an audio device, possibly at the end of the app's life, one
 * should call AudioDevice.Close() on the returned device id.
 *
 * @param devid the device instance id to open, or
 *              AUDIO_DEVICE_DEFAULT_PLAYBACK or
 *              AUDIO_DEVICE_DEFAULT_RECORDING for the most reasonable
 *              default device.
 * @param spec the requested device configuration. Can be nullptr to use
 *             reasonable defaults.
 * @returns the device ID on success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioDevice.Close
 * @sa AudioDevice.GetFormat
 */
inline AudioDevice OpenAudioDevice(AudioDeviceParam devid,
                                   OptionalRef<const AudioSpec> spec)
{
  return AudioDevice(devid, spec);
}

/**
 * Determine if an audio device is physical (instead of logical).
 *
 * An AudioDevice that represents physical hardware is a physical
 * device; there is one for each piece of hardware that SDL can see. Logical
 * devices are created by calling AudioDevice.AudioDevice or
 * AudioStream.AudioStream, and while each is associated with a physical
 * device, there can be any number of logical devices on one physical device.
 *
 * For the most part, logical and physical IDs are interchangeable--if you try
 * to open a logical device, SDL understands to assign that effort to the
 * underlying physical device, etc. However, it might be useful to know if an
 * arbitrary device ID is physical or logical. This function reports which.
 *
 * This function may return either true or false for invalid device IDs.
 *
 * @param devid the device ID to query.
 * @returns true if devid is a physical device, false if it is logical.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline bool IsAudioDevicePhysical(AudioDeviceParam devid)
{
  return SDL_IsAudioDevicePhysical(devid);
}

inline bool AudioDevice::IsPhysical() const
{
  return SDL::IsAudioDevicePhysical(m_resource);
}

/**
 * Determine if an audio device is a playback device (instead of recording).
 *
 * This function may return either true or false for invalid device IDs.
 *
 * @param devid the device ID to query.
 * @returns true if devid is a playback device, false if it is recording.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline bool IsAudioDevicePlayback(AudioDeviceParam devid)
{
  return SDL_IsAudioDevicePlayback(devid);
}

inline bool AudioDevice::IsPlayback() const
{
  return SDL::IsAudioDevicePlayback(m_resource);
}

/**
 * Use this function to pause audio playback on a specified device.
 *
 * This function pauses audio processing for a given device. Any bound audio
 * streams will not progress, and no audio will be generated. Pausing one
 * device does not prevent other unpaused devices from running.
 *
 * Unlike in SDL2, audio devices start in an _unpaused_ state, since an app
 * has to bind a stream before any audio will flow. Pausing a paused device is
 * a legal no-op.
 *
 * Pausing a device can be useful to halt all audio without unbinding all the
 * audio streams. This might be useful while a game is paused, or a level is
 * loading, etc.
 *
 * Physical devices can not be paused or unpaused, only logical devices
 * created through AudioDevice.AudioDevice() can be.
 *
 * @param devid a device opened by AudioDevice.AudioDevice().
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioDevice.Resume
 * @sa AudioDevice.Paused
 */
inline void PauseAudioDevice(AudioDeviceParam devid)
{
  CheckError(SDL_PauseAudioDevice(devid));
}

inline void AudioDevice::Pause() { SDL::PauseAudioDevice(m_resource); }

/**
 * Use this function to unpause audio playback on a specified device.
 *
 * This function unpauses audio processing for a given device that has
 * previously been paused with AudioDevice.Pause(). Once unpaused, any
 * bound audio streams will begin to progress again, and audio can be
 * generated.
 *
 * Unlike in SDL2, audio devices start in an _unpaused_ state, since an app
 * has to bind a stream before any audio will flow. Unpausing an unpaused
 * device is a legal no-op.
 *
 * Physical devices can not be paused or unpaused, only logical devices
 * created through AudioDevice.AudioDevice() can be.
 *
 * @param devid a device opened by AudioDevice.AudioDevice().
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioDevice.Paused
 * @sa AudioDevice.Pause
 */
inline void ResumeAudioDevice(AudioDeviceParam devid)
{
  CheckError(SDL_ResumeAudioDevice(devid));
}

inline void AudioDevice::Resume() { SDL::ResumeAudioDevice(m_resource); }

/**
 * Use this function to query if an audio device is paused.
 *
 * Unlike in SDL2, audio devices start in an _unpaused_ state, since an app
 * has to bind a stream before any audio will flow.
 *
 * Physical devices can not be paused or unpaused, only logical devices
 * created through AudioDevice.AudioDevice() can be. Physical and invalid device
 * IDs will report themselves as unpaused here.
 *
 * @param devid a device opened by AudioDevice.AudioDevice().
 * @returns true if device is valid and paused, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioDevice.Pause
 * @sa AudioDevice.Resume
 */
inline bool AudioDevicePaused(AudioDeviceParam devid)
{
  return SDL_AudioDevicePaused(devid);
}

inline bool AudioDevice::Paused() const
{
  return SDL::AudioDevicePaused(m_resource);
}

/**
 * Get the gain of an audio device.
 *
 * The gain of a device is its volume; a larger gain means a louder output,
 * with a gain of zero being silence.
 *
 * Audio devices default to a gain of 1.0f (no change in output).
 *
 * Physical devices may not have their gain changed, only logical devices, and
 * this function will always return -1.0f when used on physical devices.
 *
 * @param devid the audio device to query.
 * @returns the gain of the device or -1.0f on failure; call GetError()
 *          for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioDevice.SetGain
 */
inline float GetAudioDeviceGain(AudioDeviceParam devid)
{
  return SDL_GetAudioDeviceGain(devid);
}

inline float AudioDevice::GetGain() const
{
  return SDL::GetAudioDeviceGain(m_resource);
}

/**
 * Change the gain of an audio device.
 *
 * The gain of a device is its volume; a larger gain means a louder output,
 * with a gain of zero being silence.
 *
 * Audio devices default to a gain of 1.0f (no change in output).
 *
 * Physical devices may not have their gain changed, only logical devices, and
 * this function will always return false when used on physical devices. While
 * it might seem attractive to adjust several logical devices at once in this
 * way, it would allow an app or library to interfere with another portion of
 * the program's otherwise-isolated devices.
 *
 * This is applied, along with any per-audiostream gain, during playback to
 * the hardware, and can be continuously changed to create various effects. On
 * recording devices, this will adjust the gain before passing the data into
 * an audiostream; that recording audiostream can then adjust its gain further
 * when outputting the data elsewhere, if it likes, but that second gain is
 * not applied until the data leaves the audiostream again.
 *
 * @param devid the audio device on which to change gain.
 * @param gain the gain. 1.0f is no change, 0.0f is silence.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioDevice.GetGain
 */
inline void SetAudioDeviceGain(AudioDeviceParam devid, float gain)
{
  CheckError(SDL_SetAudioDeviceGain(devid, gain));
}

inline void AudioDevice::SetGain(float gain)
{
  SDL::SetAudioDeviceGain(m_resource, gain);
}

/**
 * Close a previously-opened audio device.
 *
 * The application should close open audio devices once they are no longer
 * needed.
 *
 * This function may block briefly while pending audio data is played by the
 * hardware, so that applications don't drop the last buffer of data they
 * supplied if terminating immediately afterwards.
 *
 * @param devid an audio device id previously returned by
 *              AudioDevice.AudioDevice().
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioDevice.AudioDevice
 */
inline void CloseAudioDevice(AudioDeviceID devid)
{
  SDL_CloseAudioDevice(devid);
}

inline void AudioDevice::Close()
{
  SDL_CloseAudioDevice(m_resource);
  m_resource = 0;
}

/**
 * Bind a list of audio streams to an audio device.
 *
 * Audio data will flow through any bound streams. For a playback device, data
 * for all bound streams will be mixed together and fed to the device. For a
 * recording device, a copy of recorded data will be provided to each bound
 * stream.
 *
 * Audio streams can only be bound to an open device. This operation is
 * atomic--all streams bound in the same call will start processing at the
 * same time, so they can stay in sync. Also: either all streams will be bound
 * or none of them will be.
 *
 * It is an error to bind an already-bound stream; it must be explicitly
 * unbound first.
 *
 * Binding a stream to a device will set its output format for playback
 * devices, and its input format for recording devices, so they match the
 * device's settings. The caller is welcome to change the other end of the
 * stream's format at any time with AudioStream.SetFormat(). If the other
 * end of the stream's format has never been set (the audio stream was created
 * with a nullptr audio spec), this function will set it to match the device
 * end's format.
 *
 * @param devid an audio device to bind a stream to.
 * @param streams an array of audio streams to bind.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioDevice.BindAudioStreams
 * @sa AudioStream.Unbind
 * @sa AudioStream.GetDevice
 */
inline void BindAudioStreams(AudioDeviceParam devid,
                             std::span<AudioStreamRef> streams)
{
  CheckError(SDL_BindAudioStreams(
    devid,
    reinterpret_cast<SDL_AudioStream* const*>(streams.data()),
    streams.size()));
}

inline void AudioDevice::BindAudioStreams(std::span<AudioStreamRef> streams)
{
  SDL::BindAudioStreams(m_resource, streams);
}

/**
 * Bind a single audio stream to an audio device.
 *
 * This is a convenience function, equivalent to calling
 * `AudioDevice.BindAudioStreams(devid, &stream, 1)`.
 *
 * @param devid an audio device to bind a stream to.
 * @param stream an audio stream to bind to a device.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioDevice.BindAudioStreams
 * @sa AudioStream.Unbind
 * @sa AudioStream.GetDevice
 */
inline void BindAudioStream(AudioDeviceParam devid, AudioStreamParam stream)
{
  CheckError(SDL_BindAudioStream(devid, stream));
}

inline void AudioDevice::BindAudioStream(AudioStreamParam stream)
{
  SDL::BindAudioStream(m_resource, stream);
}

/**
 * Unbind a list of audio streams from their audio devices.
 *
 * The streams being unbound do not all have to be on the same device. All
 * streams on the same device will be unbound atomically (data will stop
 * flowing through all unbound streams on the same device at the same time).
 *
 * Unbinding a stream that isn't bound to a device is a legal no-op.
 *
 * @param streams an array of audio streams to unbind. Can be nullptr or contain
 *                nullptr.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioDevice.BindAudioStreams
 */
inline void UnbindAudioStreams(std::span<AudioStreamRef> streams)
{
  SDL_UnbindAudioStreams(
    reinterpret_cast<SDL_AudioStream* const*>(streams.data()), streams.size());
}

/**
 * Unbind a single audio stream from its audio device.
 *
 * This is a convenience function, equivalent to calling
 * `UnbindAudioStreams(&stream, 1)`.
 *
 * @param stream an audio stream to unbind from a device. Can be nullptr.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioDevice.BindAudioStream
 */
inline void UnbindAudioStream(AudioStreamParam stream)
{
  SDL_UnbindAudioStream(stream);
}

inline void AudioStream::Unbind() { SDL::UnbindAudioStream(m_resource); }

/**
 * Query an audio stream for its currently-bound device.
 *
 * This reports the logical audio device that an audio stream is currently bound
 * to.
 *
 * If not bound, or invalid, this returns zero, which is not a valid device
 * ID.
 *
 * @param stream the audio stream to query.
 * @returns the bound audio device, or 0 if not bound or invalid.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioDevice.BindAudioStream
 * @sa AudioDevice.BindAudioStreams
 */
inline AudioDeviceRef GetAudioStreamDevice(AudioStreamParam stream)
{
  return {SDL_GetAudioStreamDevice(stream)};
}

inline AudioDeviceRef AudioStream::GetDevice() const
{
  return SDL::GetAudioStreamDevice(m_resource);
}

/**
 * Create a new audio stream.
 *
 * @param src_spec the format details of the input audio.
 * @param dst_spec the format details of the output audio.
 * @returns a new audio stream on success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.PutData
 * @sa AudioStream.GetData
 * @sa AudioStream.GetAvailable
 * @sa AudioStream.Flush
 * @sa AudioStream.Clear
 * @sa AudioStream.SetFormat
 * @sa AudioStream.Destroy
 */
inline AudioStream CreateAudioStream(OptionalRef<const AudioSpec> src_spec,
                                     OptionalRef<const AudioSpec> dst_spec)
{
  return AudioStream(src_spec, dst_spec);
}

/**
 * Get the properties associated with an audio stream.
 *
 * @param stream the AudioStream to query.
 * @returns a valid property ID on success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline PropertiesRef GetAudioStreamProperties(AudioStreamParam stream)
{
  return {CheckError(SDL_GetAudioStreamProperties(stream))};
}

inline PropertiesRef AudioStream::GetProperties() const
{
  return SDL::GetAudioStreamProperties(m_resource);
}

/**
 * Query the current format of an audio stream.
 *
 * @param stream the AudioStream to query.
 * @param src_spec where to store the input audio format; ignored if nullptr.
 * @param dst_spec where to store the output audio format; ignored if nullptr.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.SetFormat
 */
inline void GetAudioStreamFormat(AudioStreamParam stream,
                                 AudioSpec* src_spec,
                                 AudioSpec* dst_spec)
{
  CheckError(SDL_GetAudioStreamFormat(stream, src_spec, dst_spec));
}

inline void AudioStream::GetFormat(AudioSpec* src_spec,
                                   AudioSpec* dst_spec) const
{
  SDL::GetAudioStreamFormat(m_resource, src_spec, dst_spec);
}

/**
 * Change the input and output formats of an audio stream.
 *
 * Future calls to and AudioStream.GetAvailable and AudioStream.GetData
 * will reflect the new format, and future calls to AudioStream.PutData
 * must provide data in the new input formats.
 *
 * Data that was previously queued in the stream will still be operated on in
 * the format that was current when it was added, which is to say you can put
 * the end of a sound file in one format to a stream, change formats for the
 * next sound file, and start putting that new data while the previous sound
 * file is still queued, and everything will still play back correctly.
 *
 * If a stream is bound to a device, then the format of the side of the stream
 * bound to a device cannot be changed (src_spec for recording devices,
 * dst_spec for playback devices). Attempts to make a change to this side will
 * be ignored, but this will not report an error. The other side's format can
 * be changed.
 *
 * @param stream the stream the format is being changed.
 * @param src_spec the new format of the audio input; if nullptr, it is not
 *                 changed.
 * @param dst_spec the new format of the audio output; if nullptr, it is not
 *                 changed.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.GetFormat
 * @sa AudioStream.SetFrequencyRatio
 */
inline void SetAudioStreamFormat(AudioStreamParam stream,
                                 OptionalRef<const AudioSpec> src_spec,
                                 OptionalRef<const AudioSpec> dst_spec)
{
  CheckError(SDL_SetAudioStreamFormat(stream, src_spec, dst_spec));
}

inline void AudioStream::SetFormat(OptionalRef<const AudioSpec> src_spec,
                                   OptionalRef<const AudioSpec> dst_spec)
{
  SDL::SetAudioStreamFormat(m_resource, src_spec, dst_spec);
}

/**
 * Get the frequency ratio of an audio stream.
 *
 * @param stream the AudioStream to query.
 * @returns the frequency ratio of the stream or 0.0 on failure; call
 *          GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.SetFrequencyRatio
 */
inline float GetAudioStreamFrequencyRatio(AudioStreamParam stream)
{
  return SDL_GetAudioStreamFrequencyRatio(stream);
}

inline float AudioStream::GetFrequencyRatio() const
{
  return SDL::GetAudioStreamFrequencyRatio(m_resource);
}

/**
 * Change the frequency ratio of an audio stream.
 *
 * The frequency ratio is used to adjust the rate at which input data is
 * consumed. Changing this effectively modifies the speed and pitch of the
 * audio. A value greater than 1.0 will play the audio faster, and at a higher
 * pitch. A value less than 1.0 will play the audio slower, and at a lower
 * pitch.
 *
 * This is applied during AudioStream.GetData, and can be continuously
 * changed to create various effects.
 *
 * @param stream the stream the frequency ratio is being changed.
 * @param ratio the frequency ratio. 1.0 is normal speed. Must be between 0.01
 *              and 100.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.GetFrequencyRatio
 * @sa AudioStream.SetFormat
 */
inline void SetAudioStreamFrequencyRatio(AudioStreamParam stream, float ratio)
{
  CheckError(SDL_SetAudioStreamFrequencyRatio(stream, ratio));
}

inline void AudioStream::SetFrequencyRatio(float ratio)
{
  SDL::SetAudioStreamFrequencyRatio(m_resource, ratio);
}

/**
 * Get the gain of an audio stream.
 *
 * The gain of a stream is its volume; a larger gain means a louder output,
 * with a gain of zero being silence.
 *
 * Audio streams default to a gain of 1.0f (no change in output).
 *
 * @param stream the AudioStream to query.
 * @returns the gain of the stream or -1.0f on failure; call GetError()
 *          for more information.
 *
 * @threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.SetGain
 */
inline float GetAudioStreamGain(AudioStreamParam stream)
{
  return SDL_GetAudioStreamGain(stream);
}

inline float AudioStream::GetGain() const
{
  return SDL::GetAudioStreamGain(m_resource);
}

/**
 * Change the gain of an audio stream.
 *
 * The gain of a stream is its volume; a larger gain means a louder output,
 * with a gain of zero being silence.
 *
 * Audio streams default to a gain of 1.0f (no change in output).
 *
 * This is applied during AudioStream.GetData, and can be continuously
 * changed to create various effects.
 *
 * @param stream the stream on which the gain is being changed.
 * @param gain the gain. 1.0f is no change, 0.0f is silence.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.GetGain
 */
inline void SetAudioStreamGain(AudioStreamParam stream, float gain)
{
  CheckError(SDL_SetAudioStreamGain(stream, gain));
}

inline void AudioStream::SetGain(float gain)
{
  SDL::SetAudioStreamGain(m_resource, gain);
}

/**
 * Get the current input channel map of an audio stream.
 *
 * Channel maps are optional; most things do not need them, instead passing
 * data in the [order that SDL expects](CategoryAudio#channel-layouts).
 *
 * Audio streams default to no remapping applied. This is represented by
 * returning nullptr, and does not signify an error.
 *
 * @param stream the AudioStream to query.
 * @returns an array of the current channel mapping, with as many elements as
 *          the current output spec's channels, or nullptr if default.
 *
 * @threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.SetInputChannelMap
 */
inline OwnArray<int> GetAudioStreamInputChannelMap(AudioStreamParam stream)
{
  int count;
  auto data = SDL_GetAudioStreamInputChannelMap(stream, &count);
  if (!data) return {};
  return OwnArray<int>{data, size_t(count)};
}

inline OwnArray<int> AudioStream::GetInputChannelMap() const
{
  return SDL::GetAudioStreamInputChannelMap(m_resource);
}

/**
 * Get the current output channel map of an audio stream.
 *
 * Channel maps are optional; most things do not need them, instead passing
 * data in the [order that SDL expects](CategoryAudio#channel-layouts).
 *
 * Audio streams default to no remapping applied. This is represented by
 * returning nullptr, and does not signify an error.
 *
 * @param stream the AudioStream to query.
 * @returns an array of the current channel mapping, with as many elements as
 *          the current output spec's channels, or nullptr if default.
 *
 * @threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.SetInputChannelMap
 */
inline OwnArray<int> GetAudioStreamOutputChannelMap(AudioStreamParam stream)
{
  int count;
  auto data = SDL_GetAudioStreamOutputChannelMap(stream, &count);
  if (!data) return {};
  return OwnArray<int>{data, size_t(count)};
}

inline OwnArray<int> AudioStream::GetOutputChannelMap() const
{
  return SDL::GetAudioStreamOutputChannelMap(m_resource);
}

/**
 * Set the current input channel map of an audio stream.
 *
 * Channel maps are optional; most things do not need them, instead passing
 * data in the [order that SDL expects](CategoryAudio#channel-layouts).
 *
 * The input channel map reorders data that is added to a stream via
 * AudioStream.PutData. Future calls to AudioStream.PutData must provide
 * data in the new channel order.
 *
 * Each item in the array represents an input channel, and its value is the
 * channel that it should be remapped to. To reverse a stereo signal's left
 * and right values, you'd have an array of `{ 1, 0 }`. It is legal to remap
 * multiple channels to the same thing, so `{ 1, 1 }` would duplicate the
 * right channel to both channels of a stereo signal. An element in the
 * channel map set to -1 instead of a valid channel will mute that channel,
 * setting it to a silence value.
 *
 * You cannot change the number of channels through a channel map, just
 * reorder/mute them.
 *
 * Data that was previously queued in the stream will still be operated on in
 * the order that was current when it was added, which is to say you can put
 * the end of a sound file in one order to a stream, change orders for the
 * next sound file, and start putting that new data while the previous sound
 * file is still queued, and everything will still play back correctly.
 *
 * Audio streams default to no remapping applied. Passing a nullptr channel map
 * is legal, and turns off remapping.
 *
 * SDL will copy the channel map; the caller does not have to save this array
 * after this call.
 *
 * If `count` is not equal to the current number of channels in the audio
 * stream's format, this will fail. This is a safety measure to make sure a
 * race condition hasn't changed the format while this call is setting the
 * channel map.
 *
 * Unlike attempting to change the stream's format, the input channel map on a
 * stream bound to a recording device is permitted to change at any time; any
 * data added to the stream from the device after this call will have the new
 * mapping, but previously-added data will still have the prior mapping.
 *
 * @param stream the AudioStream to change.
 * @param chmap the new channel map, nullptr to reset to default.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running. Don't change the
 *               stream's format to have a different number of channels from a
 *               a different thread at the same time, though!
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.SetInputChannelMap
 */
inline void SetAudioStreamInputChannelMap(AudioStreamParam stream,
                                          std::span<int> chmap)
{
  CheckError(
    SDL_SetAudioStreamInputChannelMap(stream, chmap.data(), chmap.size()));
}

inline void AudioStream::SetInputChannelMap(std::span<int> chmap)
{
  SDL::SetAudioStreamInputChannelMap(m_resource, chmap);
}

/**
 * Set the current output channel map of an audio stream.
 *
 * Channel maps are optional; most things do not need them, instead passing
 * data in the [order that SDL expects](CategoryAudio#channel-layouts).
 *
 * The output channel map reorders data that leaving a stream via
 * AudioStream.GetData.
 *
 * Each item in the array represents an input channel, and its value is the
 * channel that it should be remapped to. To reverse a stereo signal's left
 * and right values, you'd have an array of `{ 1, 0 }`. It is legal to remap
 * multiple channels to the same thing, so `{ 1, 1 }` would duplicate the
 * right channel to both channels of a stereo signal. An element in the
 * channel map set to -1 instead of a valid channel will mute that channel,
 * setting it to a silence value.
 *
 * You cannot change the number of channels through a channel map, just
 * reorder/mute them.
 *
 * The output channel map can be changed at any time, as output remapping is
 * applied during AudioStream.GetData.
 *
 * Audio streams default to no remapping applied. Passing a nullptr channel map
 * is legal, and turns off remapping.
 *
 * SDL will copy the channel map; the caller does not have to save this array
 * after this call.
 *
 * If `count` is not equal to the current number of channels in the audio
 * stream's format, this will fail. This is a safety measure to make sure a
 * race condition hasn't changed the format while this call is setting the
 * channel map.
 *
 * Unlike attempting to change the stream's format, the output channel map on
 * a stream bound to a recording device is permitted to change at any time;
 * any data added to the stream after this call will have the new mapping, but
 * previously-added data will still have the prior mapping. When the channel
 * map doesn't match the hardware's channel layout, SDL will convert the data
 * before feeding it to the device for playback.
 *
 * @param stream the AudioStream to change.
 * @param chmap the new channel map, nullptr to reset to default.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running. Don't change the
 *               stream's format to have a different number of channels from a
 *               a different thread at the same time, though!
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.SetInputChannelMap
 */
inline void SetAudioStreamOutputChannelMap(AudioStreamParam stream,
                                           std::span<int> chmap)
{
  CheckError(
    SDL_SetAudioStreamOutputChannelMap(stream, chmap.data(), chmap.size()));
}

inline void AudioStream::SetOutputChannelMap(std::span<int> chmap)
{
  SDL::SetAudioStreamOutputChannelMap(m_resource, chmap);
}

/**
 * Add data to the stream.
 *
 * This data must match the format/channels/samplerate specified in the latest
 * call to AudioStream.SetFormat, or the format specified when creating the
 * stream if it hasn't been changed.
 *
 * Note that this call simply copies the unconverted data for later. This is
 * different than SDL2, where data was converted during the Put call and the
 * Get call would just dequeue the previously-converted data.
 *
 * @param stream the stream the audio data is being added to.
 * @param buf a pointer to the audio data to add.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread, but if the
 *               stream has a callback set, the caller might need to manage
 *               extra locking.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.Clear
 * @sa AudioStream.Flush
 * @sa AudioStream.GetData
 * @sa AudioStream.GetQueued
 */
inline void PutAudioStreamData(AudioStreamParam stream, SourceBytes buf)
{
  CheckError(SDL_PutAudioStreamData(stream, buf.data, buf.size_bytes));
}

inline void AudioStream::PutData(SourceBytes buf)
{
  SDL::PutAudioStreamData(m_resource, std::move(buf));
}

/**
 * Get converted/resampled data from the stream.
 *
 * The input/output data format/channels/samplerate is specified when creating
 * the stream, and can be changed after creation by calling
 * AudioStream.SetFormat.
 *
 * Note that any conversion and resampling necessary is done during this call,
 * and AudioStream.PutData simply queues unconverted data for later. This
 * is different than SDL2, where that work was done while inputting new data
 * to the stream and requesting the output just copied the converted data.
 *
 * @param stream the stream the audio is being requested from.
 * @param buf a buffer to fill with audio data.
 * @returns the number of bytes read from the stream or -1 on failure; call
 *          GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread, but if the
 *               stream has a callback set, the caller might need to manage
 *               extra locking.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.Clear
 * @sa AudioStream.GetAvailable
 * @sa AudioStream.PutData
 */
inline int GetAudioStreamData(AudioStreamParam stream, TargetBytes buf)
{
  return SDL_GetAudioStreamData(stream, buf.data, buf.size_bytes);
}

inline int AudioStream::GetData(TargetBytes buf)
{
  return SDL::GetAudioStreamData(m_resource, std::move(buf));
}

/**
 * Get the number of converted/resampled bytes available.
 *
 * The stream may be buffering data behind the scenes until it has enough to
 * resample correctly, so this number might be lower than what you expect, or
 * even be zero. Add more data or flush the stream if you need the data now.
 *
 * If the stream has so much data that it would overflow an int, the return
 * value is clamped to a maximum value, but no queued data is lost; if there
 * are gigabytes of data queued, the app might need to read some of it with
 * AudioStream.GetData before this function's return value is no longer
 * clamped.
 *
 * @param stream the audio stream to query.
 * @returns the number of converted/resampled bytes available or -1 on
 *          failure; call GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.GetData
 * @sa AudioStream.PutData
 */
inline int GetAudioStreamAvailable(AudioStreamParam stream)
{
  return SDL_GetAudioStreamAvailable(stream);
}

inline int AudioStream::GetAvailable() const
{
  return SDL::GetAudioStreamAvailable(m_resource);
}

/**
 * Get the number of bytes currently queued.
 *
 * This is the number of bytes put into a stream as input, not the number that
 * can be retrieved as output. Because of several details, it's not possible
 * to calculate one number directly from the other. If you need to know how
 * much usable data can be retrieved right now, you should use
 * AudioStream.GetAvailable() and not this function.
 *
 * Note that audio streams can change their input format at any time, even if
 * there is still data queued in a different format, so the returned byte
 * count will not necessarily match the number of _sample frames_ available.
 * Users of this API should be aware of format changes they make when feeding
 * a stream and plan accordingly.
 *
 * Queued data is not converted until it is consumed by
 * AudioStream.GetData, so this value should be representative of the exact
 * data that was put into the stream.
 *
 * If the stream has so much data that it would overflow an int, the return
 * value is clamped to a maximum value, but no queued data is lost; if there
 * are gigabytes of data queued, the app might need to read some of it with
 * AudioStream.GetData before this function's return value is no longer
 * clamped.
 *
 * @param stream the audio stream to query.
 * @returns the number of bytes queued or -1 on failure; call GetError()
 *          for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.PutData
 * @sa AudioStream.Clear
 */
inline int GetAudioStreamQueued(AudioStreamParam stream)
{
  return SDL_GetAudioStreamQueued(stream);
}

inline int AudioStream::GetQueued() const
{
  return SDL::GetAudioStreamQueued(m_resource);
}

/**
 * Tell the stream that you're done sending data, and anything being buffered
 * should be converted/resampled and made available immediately.
 *
 * It is legal to add more data to a stream after flushing, but there may be
 * audio gaps in the output. Generally this is intended to signal the end of
 * input, so the complete output becomes available.
 *
 * @param stream the audio stream to flush.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.PutData
 */
inline void FlushAudioStream(AudioStreamParam stream)
{
  CheckError(SDL_FlushAudioStream(stream));
}

inline void AudioStream::Flush() { SDL::FlushAudioStream(m_resource); }

/**
 * Clear any pending data in the stream.
 *
 * This drops any queued data, so there will be nothing to read from the
 * stream until more is added.
 *
 * @param stream the audio stream to clear.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.GetAvailable
 * @sa AudioStream.GetData
 * @sa AudioStream.GetQueued
 * @sa AudioStream.PutData
 */
inline void ClearAudioStream(AudioStreamParam stream)
{
  CheckError(SDL_ClearAudioStream(stream));
}

inline void AudioStream::Clear() { SDL::ClearAudioStream(m_resource); }

/**
 * Use this function to pause audio playback on the audio device associated
 * with an audio stream.
 *
 * This function pauses audio processing for a given device. Any bound audio
 * streams will not progress, and no audio will be generated. Pausing one
 * device does not prevent other unpaused devices from running.
 *
 * Pausing a device can be useful to halt all audio without unbinding all the
 * audio streams. This might be useful while a game is paused, or a level is
 * loading, etc.
 *
 * @param stream the audio stream associated with the audio device to pause.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.ResumeDevice
 */
inline void PauseAudioStreamDevice(AudioStreamParam stream)
{
  CheckError(SDL_PauseAudioStreamDevice(stream));
}

inline void AudioStream::PauseDevice()
{
  SDL::PauseAudioStreamDevice(m_resource);
}

/**
 * Use this function to unpause audio playback on the audio device associated
 * with an audio stream.
 *
 * This function unpauses audio processing for a given device that has
 * previously been paused. Once unpaused, any bound audio streams will begin
 * to progress again, and audio can be generated.
 *
 * Remember, AudioStream.AudioStream opens device in a paused state, so this
 * function call is required for audio playback to begin on such device.
 *
 * @param stream the audio stream associated with the audio device to resume.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.PauseDevice
 */
inline void ResumeAudioStreamDevice(AudioStreamParam stream)
{
  CheckError(SDL_ResumeAudioStreamDevice(stream));
}

inline void AudioStream::ResumeDevice()
{
  SDL::ResumeAudioStreamDevice(m_resource);
}

/**
 * Use this function to query if an audio device associated with a stream is
 * paused.
 *
 * Unlike in SDL2, audio devices start in an _unpaused_ state, since an app
 * has to bind a stream before any audio will flow.
 *
 * @param stream the audio stream associated with the audio device to query.
 * @returns true if device is valid and paused, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.PauseDevice
 * @sa AudioStream.ResumeDevice
 */
inline bool AudioStreamDevicePaused(AudioStreamParam stream)
{
  return SDL_AudioStreamDevicePaused(stream);
}

inline bool AudioStream::DevicePaused() const
{
  return SDL::AudioStreamDevicePaused(m_resource);
}

/**
 * Lock an audio stream for serialized access.
 *
 * Each AudioStream has an internal mutex it uses to protect its data
 * structures from threading conflicts. This function allows an app to lock
 * that mutex, which could be useful if registering callbacks on this stream.
 *
 * One does not need to lock a stream to use in it most cases, as the stream
 * manages this lock internally. However, this lock is held during callbacks,
 * which may run from arbitrary threads at any time, so if an app needs to
 * protect shared data during those callbacks, locking the stream guarantees
 * that the callback is not running while the lock is held.
 *
 * As this is just a wrapper over SDL_LockMutex for an internal lock; it has
 * all the same attributes (recursive locks are allowed, etc).
 *
 * @param stream the audio stream to lock.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.Unlock
 */
inline void LockAudioStream(AudioStreamParam stream)
{
  CheckError(SDL_LockAudioStream(stream));
}

inline void AudioStream::Lock() { SDL::LockAudioStream(m_resource); }

/**
 * Unlock an audio stream for serialized access.
 *
 * This unlocks an audio stream after a call to AudioStream.Lock.
 *
 * @param stream the audio stream to unlock.
 * @throws Error on failure.
 *
 * @threadsafety You should only call this from the same thread that
 *               previously called AudioStream.Lock.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.Lock
 */
inline void UnlockAudioStream(AudioStreamParam stream)
{
  CheckError(SDL_UnlockAudioStream(stream));
}

inline void AudioStream::Unlock() { SDL::UnlockAudioStream(m_resource); }

/**
 * Set a callback that runs when data is requested from an audio stream.
 *
 * This callback is called _before_ data is obtained from the stream, giving
 * the callback the chance to add more on-demand.
 *
 * The callback can (optionally) call AudioStream.PutData() to add more
 * audio to the stream during this call; if needed, the request that triggered
 * this callback will obtain the new data immediately.
 *
 * The callback's `additional_amount` argument is roughly how many bytes of
 * _unconverted_ data (in the stream's input format) is needed by the caller,
 * although this may overestimate a little for safety. This takes into account
 * how much is already in the stream and only asks for any extra necessary to
 * resolve the request, which means the callback may be asked for zero bytes,
 * and a different amount on each call.
 *
 * The callback is not required to supply exact amounts; it is allowed to
 * supply too much or too little or none at all. The caller will get what's
 * available, up to the amount they requested, regardless of this callback's
 * outcome.
 *
 * Clearing or flushing an audio stream does not call this callback.
 *
 * This function obtains the stream's lock, which means any existing callback
 * (get or put) in progress will finish running before setting the new
 * callback.
 *
 * Setting a nullptr function turns off the callback.
 *
 * @param stream the audio stream to set the new callback on.
 * @param callback the new callback function to call when data is requested
 *                 from the stream.
 * @param userdata an opaque pointer provided to the callback for its own
 *                 personal use.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.SetPutCallback
 */
inline void SetAudioStreamGetCallback(AudioStreamParam stream,
                                      AudioStreamCallback callback,
                                      void* userdata)
{
  CheckError(SDL_SetAudioStreamGetCallback(stream, callback, userdata));
}

inline void AudioStream::SetGetCallback(AudioStreamCallback callback,
                                        void* userdata)
{
  SDL::SetAudioStreamGetCallback(m_resource, callback, userdata);
}

/**
 * Set a callback that runs when data is added to an audio stream.
 *
 * This callback is called _after_ the data is added to the stream, giving the
 * callback the chance to obtain it immediately.
 *
 * The callback can (optionally) call AudioStream.GetData() to obtain audio
 * from the stream during this call.
 *
 * The callback's `additional_amount` argument is how many bytes of
 * _converted_ data (in the stream's output format) was provided by the
 * caller, although this may underestimate a little for safety. This value
 * might be less than what is currently available in the stream, if data was
 * already there, and might be less than the caller provided if the stream
 * needs to keep a buffer to aid in resampling. Which means the callback may
 * be provided with zero bytes, and a different amount on each call.
 *
 * The callback may call AudioStream.GetAvailable to see the total amount
 * currently available to read from the stream, instead of the total provided
 * by the current call.
 *
 * The callback is not required to obtain all data. It is allowed to read less
 * or none at all. Anything not read now simply remains in the stream for
 * later access.
 *
 * Clearing or flushing an audio stream does not call this callback.
 *
 * This function obtains the stream's lock, which means any existing callback
 * (get or put) in progress will finish running before setting the new
 * callback.
 *
 * Setting a nullptr function turns off the callback.
 *
 * @param stream the audio stream to set the new callback on.
 * @param callback the new callback function to call when data is added to the
 *                 stream.
 * @param userdata an opaque pointer provided to the callback for its own
 *                 personal use.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.SetGetCallback
 */
inline void SetAudioStreamPutCallback(AudioStreamParam stream,
                                      AudioStreamCallback callback,
                                      void* userdata)
{
  CheckError(SDL_SetAudioStreamPutCallback(stream, callback, userdata));
}

inline void AudioStream::SetPutCallback(AudioStreamCallback callback,
                                        void* userdata)
{
  SDL::SetAudioStreamPutCallback(m_resource, callback, userdata);
}

/**
 * Free an audio stream.
 *
 * This will release all allocated data, including any audio that is still
 * queued. You do not need to manually clear the stream first.
 *
 * If this stream was bound to an audio device, it is unbound during this
 * call. If this stream was created with AudioStream.AudioStream, the audio
 * device that was opened alongside this stream's creation will be closed,
 * too.
 *
 * @param stream the audio stream to destroy.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.AudioStream
 */
inline void DestroyAudioStream(AudioStreamRaw stream)
{
  SDL_DestroyAudioStream(stream);
}

inline void AudioStream::Destroy()
{
  SDL_DestroyAudioStream(m_resource);
  m_resource = nullptr;
}

inline AudioStream AudioDevice::OpenStream(OptionalRef<const AudioSpec> spec,
                                           AudioStreamCallback callback,
                                           void* userdata)
{
  return AudioStream(m_resource, spec, callback, userdata);
}

inline AudioStream AudioDevice::OpenStream(OptionalRef<const AudioSpec> spec,
                                           AudioStreamCB callback)
{
  return AudioStream(m_resource, spec, callback);
}

/**
 * Convenience function for straightforward audio init for the common case.
 *
 * If all your app intends to do is provide a single source of PCM audio, this
 * function allows you to do all your audio setup in a single call.
 *
 * This is also intended to be a clean means to migrate apps from SDL2.
 *
 * This function will open an audio device, create a stream and bind it.
 * Unlike other methods of setup, the audio device will be closed when this
 * stream is destroyed, so the app can treat the returned AudioStream as
 * the only object needed to manage audio playback.
 *
 * Also unlike other functions, the audio device begins paused. This is to map
 * more closely to SDL2-style behavior, since there is no extra step here to
 * bind a stream to begin audio flowing. The audio device should be resumed
 * with `AudioStream.ResumeDevice(stream);`
 *
 * This function works with both playback and recording devices.
 *
 * The `spec` parameter represents the app's side of the audio stream. That
 * is, for recording audio, this will be the output format, and for playing
 * audio, this will be the input format. If spec is nullptr, the system will
 * choose the format, and the app can use AudioStream.GetFormat() to obtain
 * this information later.
 *
 * If you don't care about opening a specific audio device, you can (and
 * probably _should_), use AUDIO_DEVICE_DEFAULT_PLAYBACK for playback and
 * AUDIO_DEVICE_DEFAULT_RECORDING for recording.
 *
 * One can optionally provide a callback function; if nullptr, the app is
 * expected to queue audio data for playback (or unqueue audio data if
 * capturing). Otherwise, the callback will begin to fire once the device is
 * unpaused.
 *
 * Destroying the returned stream with AudioStream.Destroy will also close
 * the audio device associated with this stream.
 *
 * @param devid an audio device to open, or AUDIO_DEVICE_DEFAULT_PLAYBACK
 *              or AUDIO_DEVICE_DEFAULT_RECORDING.
 * @param spec the audio stream's data format. Can be nullptr.
 * @param callback a callback where the app will provide new data for
 *                 playback, or receive new data for recording. Can be nullptr,
 *                 in which case the app will need to call
 *                 AudioStream.PutData or AudioStream.GetData as
 *                 necessary.
 * @param userdata app-controlled pointer passed to callback. Can be nullptr.
 *                 Ignored if callback is nullptr.
 * @returns an audio stream on success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.GetDevice
 * @sa AudioStream.ResumeDevice
 */
inline AudioStream OpenAudioDeviceStream(AudioDeviceParam devid,
                                         OptionalRef<const AudioSpec> spec,
                                         AudioStreamCallback callback = nullptr,
                                         void* userdata = nullptr)
{
  return AudioStream(devid, spec, callback, userdata);
}

/**
 * Convenience function for straightforward audio init for the common case.
 *
 * If all your app intends to do is provide a single source of PCM audio, this
 * function allows you to do all your audio setup in a single call.
 *
 * This is also intended to be a clean means to migrate apps from SDL2.
 *
 * This function will open an audio device, create a stream and bind it.
 * Unlike other methods of setup, the audio device will be closed when this
 * stream is destroyed, so the app can treat the returned AudioStream as
 * the only object needed to manage audio playback.
 *
 * Also unlike other functions, the audio device begins paused. This is to map
 * more closely to SDL2-style behavior, since there is no extra step here to
 * bind a stream to begin audio flowing. The audio device should be resumed
 * with `AudioStream.ResumeDevice(stream);`
 *
 * This function works with both playback and recording devices.
 *
 * The `spec` parameter represents the app's side of the audio stream. That
 * is, for recording audio, this will be the output format, and for playing
 * audio, this will be the input format. If spec is nullptr, the system will
 * choose the format, and the app can use AudioStream.GetFormat() to obtain
 * this information later.
 *
 * If you don't care about opening a specific audio device, you can (and
 * probably _should_), use AUDIO_DEVICE_DEFAULT_PLAYBACK for playback and
 * AUDIO_DEVICE_DEFAULT_RECORDING for recording.
 *
 * One can optionally provide a callback function; if nullptr, the app is
 * expected to queue audio data for playback (or unqueue audio data if
 * capturing). Otherwise, the callback will begin to fire once the device is
 * unpaused.
 *
 * Destroying the returned stream with AudioStream.Destroy will also close
 * the audio device associated with this stream.
 *
 * @param devid an audio device to open, or AUDIO_DEVICE_DEFAULT_PLAYBACK
 *              or AUDIO_DEVICE_DEFAULT_RECORDING.
 * @param spec the audio stream's data format. Can be nullptr.
 * @param callback a callback where the app will provide new data for
 *                 playback, or receive new data for recording.
 * @returns an audio stream on success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AudioStream.GetDevice
 * @sa AudioStream.ResumeDevice
 */
inline AudioStream OpenAudioDeviceStream(AudioDeviceParam devid,
                                         OptionalRef<const AudioSpec> spec,
                                         AudioStreamCB callback)
{
  return AudioStream(devid, spec, callback);
}

inline AudioStream::AudioStream(AudioDeviceParam devid,
                                OptionalRef<const AudioSpec> spec,
                                AudioStreamCB callback)
  : AudioStream(devid, spec)
{
  if (IsAudioDevicePlayback(devid)) {
    SetGetCallback(std::move(callback));
  } else {
    SetPutCallback(std::move(callback));
  }
}

/**
 * Set a callback that fires when data is about to be fed to an audio device.
 *
 * This is useful for accessing the final mix, perhaps for writing a
 * visualizer or applying a final effect to the audio data before playback.
 *
 * The buffer is the final mix of all bound audio streams on an opened device;
 * this callback will fire regularly for any device that is both opened and
 * unpaused. If there is no new data to mix, either because no streams are
 * bound to the device or all the streams are empty, this callback will still
 * fire with the entire buffer set to silence.
 *
 * This callback is allowed to make changes to the data; the contents of the
 * buffer after this call is what is ultimately passed along to the hardware.
 *
 * The callback is always provided the data in float format (values from -1.0f
 * to 1.0f), but the number of channels or sample rate may be different than
 * the format the app requested when opening the device; SDL might have had to
 * manage a conversion behind the scenes, or the playback might have jumped to
 * new physical hardware when a system default changed, etc. These details may
 * change between calls. Accordingly, the size of the buffer might change
 * between calls as well.
 *
 * This callback can run at any time, and from any thread; if you need to
 * serialize access to your app's data, you should provide and use a mutex or
 * other synchronization device.
 *
 * All of this to say: there are specific needs this callback can fulfill, but
 * it is not the simplest interface. Apps should generally provide audio in
 * their preferred format through an AudioStream and let SDL handle the
 * difference.
 *
 * This function is extremely time-sensitive; the callback should do the least
 * amount of work possible and return as quickly as it can. The longer the
 * callback runs, the higher the risk of audio dropouts or other problems.
 *
 * This function will block until the audio device is in between iterations,
 * so any existing callback that might be running will finish before this
 * function sets the new callback and returns.
 *
 * Setting a nullptr callback function disables any previously-set callback.
 *
 * @param devid the ID of an opened audio device.
 * @param callback a callback function to be called. Can be nullptr.
 * @param userdata app-controlled pointer passed to callback. Can be nullptr.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void SetAudioPostmixCallback(AudioDeviceParam devid,
                                    AudioPostmixCallback callback,
                                    void* userdata)
{
  CheckError(SDL_SetAudioPostmixCallback(devid, callback, userdata));
}

inline void AudioDevice::SetPostmixCallback(AudioPostmixCallback callback,
                                            void* userdata)
{
  SDL::SetAudioPostmixCallback(m_resource, callback, userdata);
}

/**
 * Load the audio data of a WAVE file into memory.
 *
 * Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to
 * be valid pointers. The entire data portion of the file is then loaded into
 * memory and decoded if necessary.
 *
 * Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and
 * 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and
 * A-law and mu-law (8 bits). Other formats are currently unsupported and
 * cause an error.
 *
 * If this function succeeds, the return value is zero and the pointer to the
 * audio data allocated by the function is written to `audio_buf` and its
 * length in bytes to `audio_len`. The AudioSpec members `freq`,
 * `channels`, and `format` are set to the values of the audio data in the
 * buffer.
 *
 * It's necessary to use free() to free the audio data returned in
 * `audio_buf` when it is no longer used.
 *
 * Because of the underspecification of the .WAV format, there are many
 * problematic files in the wild that cause issues with strict decoders. To
 * provide compatibility with these files, this decoder is lenient in regards
 * to the truncation of the file, the fact chunk, and the size of the RIFF
 * chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,
 * `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to
 * tune the behavior of the loading process.
 *
 * Any file that is invalid (due to truncation, corruption, or wrong values in
 * the headers), too big, or unsupported causes an error. Additionally, any
 * critical I/O error from the data source will terminate the loading process
 * with an error. The function returns nullptr on error and in all cases (with
 * the exception of `src` being nullptr), an appropriate error message will be
 * set.
 *
 * It is required that the data source supports seeking.
 *
 * Example:
 *
 * ```cpp
 * LoadWAV(IOStream.FromFile("sample.wav", "rb"), &spec);
 * ```
 *
 * Note that the LoadWAV function does this same thing for you, but in a
 * less messy way:
 *
 * ```cpp
 * LoadWAV("sample.wav", &spec);
 * ```
 *
 * @param src the data source for the WAVE data.
 * @param spec a pointer to an AudioSpec that will be set to the WAVE
 *             data's format details on successful return.
 * @param closeio if true, calls IOStream.Close() on `src` before returning,
 *                even in the case of an error.
 * @throws Error on failure.
 *
 * This function throws if the .WAV file cannot be opened, uses an unknown data
 * format, or is corrupt; call GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa LoadWAV
 */
inline OwnArray<Uint8> LoadWAV(IOStreamParam src,
                               AudioSpec* spec,
                               bool closeio = false)
{
  Uint8* buf;
  Uint32 len;
  if (!SDL_LoadWAV_IO(src, closeio, spec, &buf, &len)) return {};
  return OwnArray<Uint8>{buf, size_t(len)};
}

/**
 * Loads a WAV from a file path.
 *
 * This is a convenience function that is effectively the same as:
 *
 * ```c
 * LoadWAV(IOStream.FromFile(path, "rb"), true, spec, audio_buf, audio_len);
 * ```
 *
 * @param path the file path of the WAV file to open.
 * @param spec a pointer to an AudioSpec that will be set to the WAVE
 *             data's format details on successful return.
 * @throws Error on failure.
 *
 * This function throws if the .WAV file cannot be opened, uses an unknown data
 * format, or is corrupt,
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa LoadWAV
 */
inline OwnArray<Uint8> LoadWAV(StringParam path, AudioSpec* spec)
{
  Uint8* buf;
  Uint32 len;
  if (!SDL_LoadWAV(path, spec, &buf, &len)) return {};
  return OwnArray<Uint8>{buf, size_t(len)};
}

/**
 * Mix audio data in a specified format.
 *
 * This takes an audio buffer `src` of `len` bytes of `format` data and mixes
 * it into `dst`, performing addition, volume adjustment, and overflow
 * clipping. The buffer pointed to by `dst` must also be `len` bytes of
 * `format` data.
 *
 * This is provided for convenience -- you can mix your own audio data.
 *
 * Do not use this function for mixing together more than two streams of
 * sample data. The output from repeated application of this function may be
 * distorted by clipping, because there is no accumulator with greater range
 * than the input (not to mention this being an inefficient way of doing it).
 *
 * It is a common misconception that this function is required to write audio
 * data to an output stream in an audio callback. While you can do that,
 * MixAudio() is really only needed when you're mixing a single audio
 * stream with a volume adjustment.
 *
 * @param dst the destination for the mixed audio.
 * @param src the source audio buffer to be mixed.
 * @param format the AudioFormat structure representing the desired audio
 *               format.
 * @param volume ranges from 0.0 - 1.0, and should be set to 1.0 for full
 *               audio volume.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void MixAudio(Uint8* dst,
                     SourceBytes src,
                     AudioFormat format,
                     float volume)
{
  CheckError(SDL_MixAudio(
    dst, static_cast<const Uint8*>(src.data), format, src.size_bytes, volume));
}

/**
 * Mix audio data in a specified format.
 *
 * This takes an audio buffer `src` of `len` bytes of `format` data and mixes
 * it into `dst`, performing addition, volume adjustment, and overflow
 * clipping. The buffer pointed to by `dst` must also be `len` bytes of
 * `format` data.
 *
 * This is provided for convenience -- you can mix your own audio data.
 *
 * Do not use this function for mixing together more than two streams of
 * sample data. The output from repeated application of this function may be
 * distorted by clipping, because there is no accumulator with greater range
 * than the input (not to mention this being an inefficient way of doing it).
 *
 * It is a common misconception that this function is required to write audio
 * data to an output stream in an audio callback. While you can do that,
 * MixAudio() is really only needed when you're mixing a single audio
 * stream with a volume adjustment.
 *
 * @param dst the destination for the mixed audio.
 * @param src the source audio buffer to be mixed.
 * @param format the AudioFormat structure representing the desired audio
 *               format.
 * @param volume ranges from 0.0 - 1.0, and should be set to 1.0 for full
 *               audio volume.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void MixAudio(TargetBytes dst,
                     SourceBytes src,
                     AudioFormat format,
                     float volume)
{
  if (dst.size_bytes < src.size_bytes) src.size_bytes = dst.size_bytes;
  MixAudio(static_cast<Uint8*>(dst.data), src, format, volume);
}

/**
 * Convert some audio data of one format to another format.
 *
 * Please note that this function is for convenience, but should not be used
 * to resample audio in blocks, as it will introduce audio artifacts on the
 * boundaries. You should only use this function if you are converting audio
 * data in its entirety in one call. If you want to convert audio in smaller
 * chunks, use an AudioStream, which is designed for this situation.
 *
 * Internally, this function creates and destroys an AudioStream on each
 * use, so it's also less efficient than using one directly, if you need to
 * convert multiple times.
 *
 * @param src_spec the format details of the input audio.
 * @param src_data the audio data to be converted.
 * @param dst_spec the format details of the output audio.
 * @param dst_data will be filled with a pointer to converted audio data,
 *                 which should be freed with free(). On error, it will be
 *                 nullptr.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline OwnArray<Uint8> ConvertAudioSamples(const AudioSpec& src_spec,
                                           SourceBytes src_data,
                                           const AudioSpec& dst_spec)
{
  Uint8* buf;
  int len;
  CheckError(SDL_ConvertAudioSamples(&src_spec,
                                     static_cast<const Uint8*>(src_data.data),
                                     src_data.size_bytes,
                                     &dst_spec,
                                     &buf,
                                     &len));
  return OwnArray<Uint8>{buf, size_t(len)};
}

/**
 * Get the human readable name of an audio format.
 *
 * @param format the audio format to query.
 * @returns the human readable name of the specified audio format or
 *          "AUDIO_UNKNOWN" if the format isn't recognized.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline const char* GetAudioFormatName(AudioFormatRaw format)
{
  return SDL_GetAudioFormatName(format);
}

inline const char* AudioFormat::GetName() const
{
  return SDL::GetAudioFormatName(m_audioFormat);
}

/**
 * Get the appropriate memset value for silencing an audio format.
 *
 * The value returned by this function can be used as the second argument to
 * memset (or memset) to set an audio buffer in a specific format to
 * silence.
 *
 * @param format the audio data format to query.
 * @returns a byte value that can be passed to memset.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline int GetSilenceValueForFormat(AudioFormatRaw format)
{
  return SDL_GetSilenceValueForFormat(format);
}

inline int AudioFormat::GetSilenceValue() const
{
  return SDL::GetSilenceValueForFormat(m_audioFormat);
}

/// @}

/**
 * @defgroup CategoryKeycode Keyboard Keycodes
 *
 * Defines constants which identify keyboard keys and modifiers.
 *
 * Please refer to the Best Keyboard Practices document for details on what
 * this information means and how best to use it.
 *
 * https://wiki.libsdl.org/SDL3/BestKeyboardPractices
 *
 * @{
 */

using KeycodeRaw = SDL_Keycode;

/**
 * Valid key modifiers (possibly OR'd together).
 *
 * @since This datatype is available since SDL 3.2.0.
 */
using Keymod = Uint16;

// To remove clash with old names:
#undef KMOD_ALT
#undef KMOD_CAPS
#undef KMOD_CTRL
#undef KMOD_GUI
#undef KMOD_LALT
#undef KMOD_LCTRL
#undef KMOD_LGUI
#undef KMOD_LSHIFT
#undef KMOD_MODE
#undef KMOD_NONE
#undef KMOD_NUM
#undef KMOD_RALT
#undef KMOD_RCTRL
#undef KMOD_RGUI
#undef KMOD_RSHIFT
#undef KMOD_SCROLL
#undef KMOD_SHIFT

constexpr Keymod KMOD_NONE = SDL_KMOD_NONE; ///< no modifier is applicable.

constexpr Keymod KMOD_LSHIFT = SDL_KMOD_LSHIFT; ///< the left Shift key is down.

constexpr Keymod KMOD_RSHIFT =
  SDL_KMOD_RSHIFT; ///< the right Shift key is down.

constexpr Keymod KMOD_LEVEL5 =
  SDL_KMOD_LEVEL5; ///< the Level 5 Shift key is down.

constexpr Keymod KMOD_LCTRL =
  SDL_KMOD_LCTRL; ///< the left Ctrl (Control) key is down.

constexpr Keymod KMOD_RCTRL =
  SDL_KMOD_RCTRL; ///< the right Ctrl (Control) key is down.

constexpr Keymod KMOD_LALT = SDL_KMOD_LALT; ///< the left Alt key is down.

constexpr Keymod KMOD_RALT = SDL_KMOD_RALT; ///< the right Alt key is down.

constexpr Keymod KMOD_LGUI =
  SDL_KMOD_LGUI; ///< the left GUI key (often the Windows key) is down.

constexpr Keymod KMOD_RGUI =
  SDL_KMOD_RGUI; ///< the right GUI key (often the Windows key) is down.

/// the Num Lock key (may be located on an extended keypad) is down.
constexpr Keymod KMOD_NUM = SDL_KMOD_NUM;

constexpr Keymod KMOD_CAPS = SDL_KMOD_CAPS; ///< the Caps Lock key is down.

constexpr Keymod KMOD_MODE = SDL_KMOD_MODE; ///< the !AltGr key is down.

constexpr Keymod KMOD_SCROLL =
  SDL_KMOD_SCROLL; ///< the Scroll Lock key is down.

constexpr Keymod KMOD_CTRL = SDL_KMOD_CTRL; ///< Any Ctrl key is down.

constexpr Keymod KMOD_SHIFT = SDL_KMOD_SHIFT; ///< Any Shift key is down.

constexpr Keymod KMOD_ALT = SDL_KMOD_ALT; ///< Any Alt key is down.

constexpr Keymod KMOD_GUI = SDL_KMOD_GUI; ///< Any GUI key is down.

/**
 * The SDL virtual key representation.
 *
 * Values of this type are used to represent keyboard keys using the current
 * layout of the keyboard. These values include Unicode values representing
 * the unmodified character that would be generated by pressing the key, or an
 * `SDLK_*` constant for those keys that do not generate characters.
 *
 * A special exception is the number keys at the top of the keyboard which map
 * to SDLK_0...SDLK_9 on AZERTY layouts.
 *
 * Keys with the `SDLK_EXTENDED_MASK` bit set do not map to a scancode or
 * unicode code point.
 *
 * @since This datatype is available since SDL 3.2.0.
 */
class Keycode
{
  KeycodeRaw m_keycode;

public:
  /**
   * Wraps Keycode.
   *
   * @param keycode the value to be wrapped
   */
  constexpr Keycode(KeycodeRaw keycode = {})
    : m_keycode(keycode)
  {
  }

  /**
   * Get the key code corresponding to the given scancode according to the
   * current keyboard layout.
   *
   * If you want to get the keycode as it would be delivered in key events,
   * including options specified in SDL_HINT_KEYCODE_OPTIONS, then you should
   * pass `key_event` as true. Otherwise this function simply translates the
   * scancode based on the given modifier state.
   *
   * @param scancode the desired Scancode to query.
   * @param modstate the modifier state to use when translating the scancode to
   *                 a keycode.
   * @param key_event true if the keycode will be used in key events.
   * @post the Keycode that corresponds to the given Scancode.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Keycode.GetName
   * @sa Keycode.GetScancode
   */
  Keycode(Scancode scancode, Keymod modstate, bool key_event);

  /**
   * Get a key code from a human-readable name.
   *
   * @param name the human-readable key name.
   * @post key code, or `SDLK_UNKNOWN` if the name wasn't recognized; call
   *          GetError() for more information.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Keycode.Keycode
   * @sa Keycode.GetName
   * @sa Scancode.Scancode
   */
  Keycode(StringParam name);

  /// Default comparison operator
  constexpr auto operator<=>(const Keycode& other) const = default;

  /// Compares with the underlying type
  constexpr auto operator<=>(KeycodeRaw keycode) const
  {
    return operator<=>(Keycode(keycode));
  }

  /**
   * Unwraps to the underlying Keycode.
   *
   * @returns the underlying KeycodeRaw.
   */
  constexpr operator KeycodeRaw() const { return m_keycode; }

  /**
   * Check if valid.
   *
   * @returns True if valid state, false otherwise.
   */
  constexpr explicit operator bool() const { return m_keycode != SDLK_UNKNOWN; }

  /// Has Extended flag.
  constexpr bool IsExtended() const;

  /// Has Scancode flag.
  constexpr bool IsScancode() const;

  /**
   * Get the scancode corresponding to the given key code according to the
   * current keyboard layout.
   *
   * Note that there may be multiple scancode+modifier states that can generate
   * this keycode, this will just return the first one found.
   *
   * @param modstate a pointer to the modifier state that would be used when the
   *                 scancode generates this key, may be nullptr.
   * @returns the Scancode that corresponds to the given Keycode.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Keycode.Keycode
   * @sa Scancode.GetName
   */
  Scancode GetScancode(Keymod* modstate) const;

  /**
   * Get a human-readable name for a key.
   *
   * If the key doesn't have a name, this function returns an empty string ("").
   *
   * Letters will be presented in their uppercase form, if applicable.
   *
   * @returns a UTF-8 encoded string of the key name.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Keycode.Keycode
   * @sa Keycode.Keycode
   * @sa Keycode.GetScancode
   */
  const char* GetName() const;
};

constexpr Keycode KEYCODE_UNKNOWN = SDLK_UNKNOWN; ///< 0

constexpr Keycode KEYCODE_RETURN = SDLK_RETURN; ///< '\\r'

constexpr Keycode KEYCODE_ESCAPE = SDLK_ESCAPE; ///< '\\x1B'

constexpr Keycode KEYCODE_BACKSPACE = SDLK_BACKSPACE; ///< '\\b'

constexpr Keycode KEYCODE_TAB = SDLK_TAB; ///< '\\t'

constexpr Keycode KEYCODE_SPACE = SDLK_SPACE; ///< ' '

constexpr Keycode KEYCODE_EXCLAIM = SDLK_EXCLAIM; ///< '!'

constexpr Keycode KEYCODE_DBLAPOSTROPHE = SDLK_DBLAPOSTROPHE; ///< '"'

constexpr Keycode KEYCODE_HASH = SDLK_HASH; ///< '#'

constexpr Keycode KEYCODE_DOLLAR = SDLK_DOLLAR; ///< '$'

constexpr Keycode KEYCODE_PERCENT = SDLK_PERCENT; ///< '%'

constexpr Keycode KEYCODE_AMPERSAND = SDLK_AMPERSAND; ///< '&'

constexpr Keycode KEYCODE_APOSTROPHE = SDLK_APOSTROPHE; ///< '\''

constexpr Keycode KEYCODE_LEFTPAREN = SDLK_LEFTPAREN; ///< '('

constexpr Keycode KEYCODE_RIGHTPAREN = SDLK_RIGHTPAREN; ///< ')'

constexpr Keycode KEYCODE_ASTERISK = SDLK_ASTERISK; ///< '*'

constexpr Keycode KEYCODE_PLUS = SDLK_PLUS; ///< '+'

constexpr Keycode KEYCODE_COMMA = SDLK_COMMA; ///< ','

constexpr Keycode KEYCODE_MINUS = SDLK_MINUS; ///< '-'

constexpr Keycode KEYCODE_PERIOD = SDLK_PERIOD; ///< '.'

constexpr Keycode KEYCODE_SLASH = SDLK_SLASH; ///< '/'

constexpr Keycode KEYCODE_0 = SDLK_0; ///< '0'

constexpr Keycode KEYCODE_1 = SDLK_1; ///< '1'

constexpr Keycode KEYCODE_2 = SDLK_2; ///< '2'

constexpr Keycode KEYCODE_3 = SDLK_3; ///< '3'

constexpr Keycode KEYCODE_4 = SDLK_4; ///< '4'

constexpr Keycode KEYCODE_5 = SDLK_5; ///< '5'

constexpr Keycode KEYCODE_6 = SDLK_6; ///< '6'

constexpr Keycode KEYCODE_7 = SDLK_7; ///< '7'

constexpr Keycode KEYCODE_8 = SDLK_8; ///< '8'

constexpr Keycode KEYCODE_9 = SDLK_9; ///< '9'

constexpr Keycode KEYCODE_COLON = SDLK_COLON; ///< ':'

constexpr Keycode KEYCODE_SEMICOLON = SDLK_SEMICOLON; ///< ';'

constexpr Keycode KEYCODE_LESS = SDLK_LESS; ///< '<'

constexpr Keycode KEYCODE_EQUALS = SDLK_EQUALS; ///< '='

constexpr Keycode KEYCODE_GREATER = SDLK_GREATER; ///< '>'

constexpr Keycode KEYCODE_QUESTION = SDLK_QUESTION; ///< '?'

constexpr Keycode KEYCODE_AT = SDLK_AT; ///< '@'

constexpr Keycode KEYCODE_LEFTBRACKET = SDLK_LEFTBRACKET; ///< '['

constexpr Keycode KEYCODE_BACKSLASH = SDLK_BACKSLASH; ///< '\\b'

constexpr Keycode KEYCODE_RIGHTBRACKET = SDLK_RIGHTBRACKET; ///< ']'

constexpr Keycode KEYCODE_CARET = SDLK_CARET; ///< '^'

constexpr Keycode KEYCODE_UNDERSCORE = SDLK_UNDERSCORE; ///< '_'

constexpr Keycode KEYCODE_GRAVE = SDLK_GRAVE; ///< '`'

constexpr Keycode KEYCODE_A = SDLK_A; ///< 'a'

constexpr Keycode KEYCODE_B = SDLK_B; ///< 'b'

constexpr Keycode KEYCODE_C = SDLK_C; ///< 'c'

constexpr Keycode KEYCODE_D = SDLK_D; ///< 'd'

constexpr Keycode KEYCODE_E = SDLK_E; ///< 'e'

constexpr Keycode KEYCODE_F = SDLK_F; ///< 'f'

constexpr Keycode KEYCODE_G = SDLK_G; ///< 'g'

constexpr Keycode KEYCODE_H = SDLK_H; ///< 'h'

constexpr Keycode KEYCODE_I = SDLK_I; ///< 'i'

constexpr Keycode KEYCODE_J = SDLK_J; ///< 'j'

constexpr Keycode KEYCODE_K = SDLK_K; ///< 'k'

constexpr Keycode KEYCODE_L = SDLK_L; ///< 'l'

constexpr Keycode KEYCODE_M = SDLK_M; ///< 'm'

constexpr Keycode KEYCODE_N = SDLK_N; ///< 'n'

constexpr Keycode KEYCODE_O = SDLK_O; ///< 'o'

constexpr Keycode KEYCODE_P = SDLK_P; ///< 'p'

constexpr Keycode KEYCODE_Q = SDLK_Q; ///< 'q'

constexpr Keycode KEYCODE_R = SDLK_R; ///< 'r'

constexpr Keycode KEYCODE_S = SDLK_S; ///< 's'

constexpr Keycode KEYCODE_T = SDLK_T; ///< 't'

constexpr Keycode KEYCODE_U = SDLK_U; ///< 'u'

constexpr Keycode KEYCODE_V = SDLK_V; ///< 'v'

constexpr Keycode KEYCODE_W = SDLK_W; ///< 'w'

constexpr Keycode KEYCODE_X = SDLK_X; ///< 'x'

constexpr Keycode KEYCODE_Y = SDLK_Y; ///< 'y'

constexpr Keycode KEYCODE_Z = SDLK_Z; ///< 'z'

constexpr Keycode KEYCODE_LEFTBRACE = SDLK_LEFTBRACE; ///< '{'

constexpr Keycode KEYCODE_PIPE = SDLK_PIPE; ///< '|'

constexpr Keycode KEYCODE_RIGHTBRACE = SDLK_RIGHTBRACE; ///< '}'

constexpr Keycode KEYCODE_TILDE = SDLK_TILDE; ///< '~'

constexpr Keycode KEYCODE_DELETE = SDLK_DELETE; ///< '\\x7F'

constexpr Keycode KEYCODE_PLUSMINUS = SDLK_PLUSMINUS; ///< '\\xB1'

constexpr Keycode KEYCODE_CAPSLOCK =
  SDLK_CAPSLOCK; ///< ScancodeToKeycode(SCANCODE_CAPSLOCK)

constexpr Keycode KEYCODE_F1 = SDLK_F1; ///< ScancodeToKeycode(SCANCODE_F1)

constexpr Keycode KEYCODE_F2 = SDLK_F2; ///< ScancodeToKeycode(SCANCODE_F2)

constexpr Keycode KEYCODE_F3 = SDLK_F3; ///< ScancodeToKeycode(SCANCODE_F3)

constexpr Keycode KEYCODE_F4 = SDLK_F4; ///< ScancodeToKeycode(SCANCODE_F4)

constexpr Keycode KEYCODE_F5 = SDLK_F5; ///< ScancodeToKeycode(SCANCODE_F5)

constexpr Keycode KEYCODE_F6 = SDLK_F6; ///< ScancodeToKeycode(SCANCODE_F6)

constexpr Keycode KEYCODE_F7 = SDLK_F7; ///< ScancodeToKeycode(SCANCODE_F7)

constexpr Keycode KEYCODE_F8 = SDLK_F8; ///< ScancodeToKeycode(SCANCODE_F8)

constexpr Keycode KEYCODE_F9 = SDLK_F9; ///< ScancodeToKeycode(SCANCODE_F9)

constexpr Keycode KEYCODE_F10 = SDLK_F10; ///< ScancodeToKeycode(SCANCODE_F10)

constexpr Keycode KEYCODE_F11 = SDLK_F11; ///< ScancodeToKeycode(SCANCODE_F11)

constexpr Keycode KEYCODE_F12 = SDLK_F12; ///< ScancodeToKeycode(SCANCODE_F12)

constexpr Keycode KEYCODE_PRINTSCREEN =
  SDLK_PRINTSCREEN; ///< ScancodeToKeycode(SCANCODE_PRINTSCREEN)

constexpr Keycode KEYCODE_SCROLLLOCK =
  SDLK_SCROLLLOCK; ///< ScancodeToKeycode(SCANCODE_SCROLLLOCK)

constexpr Keycode KEYCODE_PAUSE =
  SDLK_PAUSE; ///< ScancodeToKeycode(SCANCODE_PAUSE)

constexpr Keycode KEYCODE_INSERT =
  SDLK_INSERT; ///< ScancodeToKeycode(SCANCODE_INSERT)

constexpr Keycode KEYCODE_HOME =
  SDLK_HOME; ///< ScancodeToKeycode(SCANCODE_HOME)

constexpr Keycode KEYCODE_PAGEUP =
  SDLK_PAGEUP; ///< ScancodeToKeycode(SCANCODE_PAGEUP)

constexpr Keycode KEYCODE_END = SDLK_END; ///< ScancodeToKeycode(SCANCODE_END)

constexpr Keycode KEYCODE_PAGEDOWN =
  SDLK_PAGEDOWN; ///< ScancodeToKeycode(SCANCODE_PAGEDOWN)

constexpr Keycode KEYCODE_RIGHT =
  SDLK_RIGHT; ///< ScancodeToKeycode(SCANCODE_RIGHT)

constexpr Keycode KEYCODE_LEFT =
  SDLK_LEFT; ///< ScancodeToKeycode(SCANCODE_LEFT)

constexpr Keycode KEYCODE_DOWN =
  SDLK_DOWN; ///< ScancodeToKeycode(SCANCODE_DOWN)

constexpr Keycode KEYCODE_UP = SDLK_UP; ///< ScancodeToKeycode(SCANCODE_UP)

constexpr Keycode KEYCODE_NUMLOCKCLEAR =
  SDLK_NUMLOCKCLEAR; ///< ScancodeToKeycode(SCANCODE_NUMLOCKCLEAR)

constexpr Keycode KEYCODE_KP_DIVIDE =
  SDLK_KP_DIVIDE; ///< ScancodeToKeycode(SCANCODE_KP_DIVIDE)

constexpr Keycode KEYCODE_KP_MULTIPLY =
  SDLK_KP_MULTIPLY; ///< ScancodeToKeycode(SCANCODE_KP_MULTIPLY)

constexpr Keycode KEYCODE_KP_MINUS =
  SDLK_KP_MINUS; ///< ScancodeToKeycode(SCANCODE_KP_MINUS)

constexpr Keycode KEYCODE_KP_PLUS =
  SDLK_KP_PLUS; ///< ScancodeToKeycode(SCANCODE_KP_PLUS)

constexpr Keycode KEYCODE_KP_ENTER =
  SDLK_KP_ENTER; ///< ScancodeToKeycode(SCANCODE_KP_ENTER)

constexpr Keycode KEYCODE_KP_1 =
  SDLK_KP_1; ///< ScancodeToKeycode(SCANCODE_KP_1)

constexpr Keycode KEYCODE_KP_2 =
  SDLK_KP_2; ///< ScancodeToKeycode(SCANCODE_KP_2)

constexpr Keycode KEYCODE_KP_3 =
  SDLK_KP_3; ///< ScancodeToKeycode(SCANCODE_KP_3)

constexpr Keycode KEYCODE_KP_4 =
  SDLK_KP_4; ///< ScancodeToKeycode(SCANCODE_KP_4)

constexpr Keycode KEYCODE_KP_5 =
  SDLK_KP_5; ///< ScancodeToKeycode(SCANCODE_KP_5)

constexpr Keycode KEYCODE_KP_6 =
  SDLK_KP_6; ///< ScancodeToKeycode(SCANCODE_KP_6)

constexpr Keycode KEYCODE_KP_7 =
  SDLK_KP_7; ///< ScancodeToKeycode(SCANCODE_KP_7)

constexpr Keycode KEYCODE_KP_8 =
  SDLK_KP_8; ///< ScancodeToKeycode(SCANCODE_KP_8)

constexpr Keycode KEYCODE_KP_9 =
  SDLK_KP_9; ///< ScancodeToKeycode(SCANCODE_KP_9)

constexpr Keycode KEYCODE_KP_0 =
  SDLK_KP_0; ///< ScancodeToKeycode(SCANCODE_KP_0)

constexpr Keycode KEYCODE_KP_PERIOD =
  SDLK_KP_PERIOD; ///< ScancodeToKeycode(SCANCODE_KP_PERIOD)

constexpr Keycode KEYCODE_APPLICATION =
  SDLK_APPLICATION; ///< ScancodeToKeycode(SCANCODE_APPLICATION)

constexpr Keycode KEYCODE_POWER =
  SDLK_POWER; ///< ScancodeToKeycode(SCANCODE_POWER)

constexpr Keycode KEYCODE_KP_EQUALS =
  SDLK_KP_EQUALS; ///< ScancodeToKeycode(SCANCODE_KP_EQUALS)

constexpr Keycode KEYCODE_F13 = SDLK_F13; ///< ScancodeToKeycode(SCANCODE_F13)

constexpr Keycode KEYCODE_F14 = SDLK_F14; ///< ScancodeToKeycode(SCANCODE_F14)

constexpr Keycode KEYCODE_F15 = SDLK_F15; ///< ScancodeToKeycode(SCANCODE_F15)

constexpr Keycode KEYCODE_F16 = SDLK_F16; ///< ScancodeToKeycode(SCANCODE_F16)

constexpr Keycode KEYCODE_F17 = SDLK_F17; ///< ScancodeToKeycode(SCANCODE_F17)

constexpr Keycode KEYCODE_F18 = SDLK_F18; ///< ScancodeToKeycode(SCANCODE_F18)

constexpr Keycode KEYCODE_F19 = SDLK_F19; ///< ScancodeToKeycode(SCANCODE_F19)

constexpr Keycode KEYCODE_F20 = SDLK_F20; ///< ScancodeToKeycode(SCANCODE_F20)

constexpr Keycode KEYCODE_F21 = SDLK_F21; ///< ScancodeToKeycode(SCANCODE_F21)

constexpr Keycode KEYCODE_F22 = SDLK_F22; ///< ScancodeToKeycode(SCANCODE_F22)

constexpr Keycode KEYCODE_F23 = SDLK_F23; ///< ScancodeToKeycode(SCANCODE_F23)

constexpr Keycode KEYCODE_F24 = SDLK_F24; ///< ScancodeToKeycode(SCANCODE_F24)

constexpr Keycode KEYCODE_EXECUTE =
  SDLK_EXECUTE; ///< ScancodeToKeycode(SCANCODE_EXECUTE)

constexpr Keycode KEYCODE_HELP =
  SDLK_HELP; ///< ScancodeToKeycode(SCANCODE_HELP)

constexpr Keycode KEYCODE_MENU =
  SDLK_MENU; ///< ScancodeToKeycode(SCANCODE_MENU)

constexpr Keycode KEYCODE_SELECT =
  SDLK_SELECT; ///< ScancodeToKeycode(SCANCODE_SELECT)

constexpr Keycode KEYCODE_STOP =
  SDLK_STOP; ///< ScancodeToKeycode(SCANCODE_STOP)

constexpr Keycode KEYCODE_AGAIN =
  SDLK_AGAIN; ///< ScancodeToKeycode(SCANCODE_AGAIN)

constexpr Keycode KEYCODE_UNDO =
  SDLK_UNDO; ///< ScancodeToKeycode(SCANCODE_UNDO)

constexpr Keycode KEYCODE_CUT = SDLK_CUT; ///< ScancodeToKeycode(SCANCODE_CUT)

constexpr Keycode KEYCODE_COPY =
  SDLK_COPY; ///< ScancodeToKeycode(SCANCODE_COPY)

constexpr Keycode KEYCODE_PASTE =
  SDLK_PASTE; ///< ScancodeToKeycode(SCANCODE_PASTE)

constexpr Keycode KEYCODE_FIND =
  SDLK_FIND; ///< ScancodeToKeycode(SCANCODE_FIND)

constexpr Keycode KEYCODE_MUTE =
  SDLK_MUTE; ///< ScancodeToKeycode(SCANCODE_MUTE)

constexpr Keycode KEYCODE_VOLUMEUP =
  SDLK_VOLUMEUP; ///< ScancodeToKeycode(SCANCODE_VOLUMEUP)

constexpr Keycode KEYCODE_VOLUMEDOWN =
  SDLK_VOLUMEDOWN; ///< ScancodeToKeycode(SCANCODE_VOLUMEDOWN)

constexpr Keycode KEYCODE_KP_COMMA =
  SDLK_KP_COMMA; ///< ScancodeToKeycode(SCANCODE_KP_COMMA)

constexpr Keycode KEYCODE_KP_EQUALSAS400 =
  SDLK_KP_EQUALSAS400; ///< ScancodeToKeycode(SCANCODE_KP_EQUALSAS400)

constexpr Keycode KEYCODE_ALTERASE =
  SDLK_ALTERASE; ///< ScancodeToKeycode(SCANCODE_ALTERASE)

constexpr Keycode KEYCODE_SYSREQ =
  SDLK_SYSREQ; ///< ScancodeToKeycode(SCANCODE_SYSREQ)

constexpr Keycode KEYCODE_CANCEL =
  SDLK_CANCEL; ///< ScancodeToKeycode(SCANCODE_CANCEL)

constexpr Keycode KEYCODE_CLEAR =
  SDLK_CLEAR; ///< ScancodeToKeycode(SCANCODE_CLEAR)

constexpr Keycode KEYCODE_PRIOR =
  SDLK_PRIOR; ///< ScancodeToKeycode(SCANCODE_PRIOR)

constexpr Keycode KEYCODE_RETURN2 =
  SDLK_RETURN2; ///< ScancodeToKeycode(SCANCODE_RETURN2)

constexpr Keycode KEYCODE_SEPARATOR =
  SDLK_SEPARATOR; ///< ScancodeToKeycode(SCANCODE_SEPARATOR)

constexpr Keycode KEYCODE_OUT = SDLK_OUT; ///< ScancodeToKeycode(SCANCODE_OUT)

constexpr Keycode KEYCODE_OPER =
  SDLK_OPER; ///< ScancodeToKeycode(SCANCODE_OPER)

constexpr Keycode KEYCODE_CLEARAGAIN =
  SDLK_CLEARAGAIN; ///< ScancodeToKeycode(SCANCODE_CLEARAGAIN)

constexpr Keycode KEYCODE_CRSEL =
  SDLK_CRSEL; ///< ScancodeToKeycode(SCANCODE_CRSEL)

constexpr Keycode KEYCODE_EXSEL =
  SDLK_EXSEL; ///< ScancodeToKeycode(SCANCODE_EXSEL)

constexpr Keycode KEYCODE_KP_00 =
  SDLK_KP_00; ///< ScancodeToKeycode(SCANCODE_KP_00)

constexpr Keycode KEYCODE_KP_000 =
  SDLK_KP_000; ///< ScancodeToKeycode(SCANCODE_KP_000)

constexpr Keycode KEYCODE_THOUSANDSSEPARATOR =
  SDLK_THOUSANDSSEPARATOR; ///< ScancodeToKeycode(SCANCODE_THOUSANDSSEPARATOR)

constexpr Keycode KEYCODE_DECIMALSEPARATOR =
  SDLK_DECIMALSEPARATOR; ///< ScancodeToKeycode(SCANCODE_DECIMALSEPARATOR)

constexpr Keycode KEYCODE_CURRENCYUNIT =
  SDLK_CURRENCYUNIT; ///< ScancodeToKeycode(SCANCODE_CURRENCYUNIT)

constexpr Keycode KEYCODE_CURRENCYSUBUNIT =
  SDLK_CURRENCYSUBUNIT; ///< ScancodeToKeycode(SCANCODE_CURRENCYSUBUNIT)

constexpr Keycode KEYCODE_KP_LEFTPAREN =
  SDLK_KP_LEFTPAREN; ///< ScancodeToKeycode(SCANCODE_KP_LEFTPAREN)

constexpr Keycode KEYCODE_KP_RIGHTPAREN =
  SDLK_KP_RIGHTPAREN; ///< ScancodeToKeycode(SCANCODE_KP_RIGHTPAREN)

constexpr Keycode KEYCODE_KP_LEFTBRACE =
  SDLK_KP_LEFTBRACE; ///< ScancodeToKeycode(SCANCODE_KP_LEFTBRACE)

constexpr Keycode KEYCODE_KP_RIGHTBRACE =
  SDLK_KP_RIGHTBRACE; ///< ScancodeToKeycode(SCANCODE_KP_RIGHTBRACE)

constexpr Keycode KEYCODE_KP_TAB =
  SDLK_KP_TAB; ///< ScancodeToKeycode(SCANCODE_KP_TAB)

constexpr Keycode KEYCODE_KP_BACKSPACE =
  SDLK_KP_BACKSPACE; ///< ScancodeToKeycode(SCANCODE_KP_BACKSPACE)

constexpr Keycode KEYCODE_KP_A =
  SDLK_KP_A; ///< ScancodeToKeycode(SCANCODE_KP_A)

constexpr Keycode KEYCODE_KP_B =
  SDLK_KP_B; ///< ScancodeToKeycode(SCANCODE_KP_B)

constexpr Keycode KEYCODE_KP_C =
  SDLK_KP_C; ///< ScancodeToKeycode(SCANCODE_KP_C)

constexpr Keycode KEYCODE_KP_D =
  SDLK_KP_D; ///< ScancodeToKeycode(SCANCODE_KP_D)

constexpr Keycode KEYCODE_KP_E =
  SDLK_KP_E; ///< ScancodeToKeycode(SCANCODE_KP_E)

constexpr Keycode KEYCODE_KP_F =
  SDLK_KP_F; ///< ScancodeToKeycode(SCANCODE_KP_F)

constexpr Keycode KEYCODE_KP_XOR =
  SDLK_KP_XOR; ///< ScancodeToKeycode(SCANCODE_KP_XOR)

constexpr Keycode KEYCODE_KP_POWER =
  SDLK_KP_POWER; ///< ScancodeToKeycode(SCANCODE_KP_POWER)

constexpr Keycode KEYCODE_KP_PERCENT =
  SDLK_KP_PERCENT; ///< ScancodeToKeycode(SCANCODE_KP_PERCENT)

constexpr Keycode KEYCODE_KP_LESS =
  SDLK_KP_LESS; ///< ScancodeToKeycode(SCANCODE_KP_LESS)

constexpr Keycode KEYCODE_KP_GREATER =
  SDLK_KP_GREATER; ///< ScancodeToKeycode(SCANCODE_KP_GREATER)

constexpr Keycode KEYCODE_KP_AMPERSAND =
  SDLK_KP_AMPERSAND; ///< ScancodeToKeycode(SCANCODE_KP_AMPERSAND)

constexpr Keycode KEYCODE_KP_DBLAMPERSAND =
  SDLK_KP_DBLAMPERSAND; ///< ScancodeToKeycode(SCANCODE_KP_DBLAMPERSAND)

constexpr Keycode KEYCODE_KP_VERTICALBAR =
  SDLK_KP_VERTICALBAR; ///< ScancodeToKeycode(SCANCODE_KP_VERTICALBAR)

constexpr Keycode KEYCODE_KP_DBLVERTICALBAR =
  SDLK_KP_DBLVERTICALBAR; ///< ScancodeToKeycode(SCANCODE_KP_DBLVERTICALBAR)

constexpr Keycode KEYCODE_KP_COLON =
  SDLK_KP_COLON; ///< ScancodeToKeycode(SCANCODE_KP_COLON)

constexpr Keycode KEYCODE_KP_HASH =
  SDLK_KP_HASH; ///< ScancodeToKeycode(SCANCODE_KP_HASH)

constexpr Keycode KEYCODE_KP_SPACE =
  SDLK_KP_SPACE; ///< ScancodeToKeycode(SCANCODE_KP_SPACE)

constexpr Keycode KEYCODE_KP_AT =
  SDLK_KP_AT; ///< ScancodeToKeycode(SCANCODE_KP_AT)

constexpr Keycode KEYCODE_KP_EXCLAM =
  SDLK_KP_EXCLAM; ///< ScancodeToKeycode(SCANCODE_KP_EXCLAM)

constexpr Keycode KEYCODE_KP_MEMSTORE =
  SDLK_KP_MEMSTORE; ///< ScancodeToKeycode(SCANCODE_KP_MEMSTORE)

constexpr Keycode KEYCODE_KP_MEMRECALL =
  SDLK_KP_MEMRECALL; ///< ScancodeToKeycode(SCANCODE_KP_MEMRECALL)

constexpr Keycode KEYCODE_KP_MEMCLEAR =
  SDLK_KP_MEMCLEAR; ///< ScancodeToKeycode(SCANCODE_KP_MEMCLEAR)

constexpr Keycode KEYCODE_KP_MEMADD =
  SDLK_KP_MEMADD; ///< ScancodeToKeycode(SCANCODE_KP_MEMADD)

constexpr Keycode KEYCODE_KP_MEMSUBTRACT =
  SDLK_KP_MEMSUBTRACT; ///< ScancodeToKeycode(SCANCODE_KP_MEMSUBTRACT)

constexpr Keycode KEYCODE_KP_MEMMULTIPLY =
  SDLK_KP_MEMMULTIPLY; ///< ScancodeToKeycode(SCANCODE_KP_MEMMULTIPLY)

constexpr Keycode KEYCODE_KP_MEMDIVIDE =
  SDLK_KP_MEMDIVIDE; ///< ScancodeToKeycode(SCANCODE_KP_MEMDIVIDE)

constexpr Keycode KEYCODE_KP_PLUSMINUS =
  SDLK_KP_PLUSMINUS; ///< ScancodeToKeycode(SCANCODE_KP_PLUSMINUS)

constexpr Keycode KEYCODE_KP_CLEAR =
  SDLK_KP_CLEAR; ///< ScancodeToKeycode(SCANCODE_KP_CLEAR)

constexpr Keycode KEYCODE_KP_CLEARENTRY =
  SDLK_KP_CLEARENTRY; ///< ScancodeToKeycode(SCANCODE_KP_CLEARENTRY)

constexpr Keycode KEYCODE_KP_BINARY =
  SDLK_KP_BINARY; ///< ScancodeToKeycode(SCANCODE_KP_BINARY)

constexpr Keycode KEYCODE_KP_OCTAL =
  SDLK_KP_OCTAL; ///< ScancodeToKeycode(SCANCODE_KP_OCTAL)

constexpr Keycode KEYCODE_KP_DECIMAL =
  SDLK_KP_DECIMAL; ///< ScancodeToKeycode(SCANCODE_KP_DECIMAL)

constexpr Keycode KEYCODE_KP_HEXADECIMAL =
  SDLK_KP_HEXADECIMAL; ///< ScancodeToKeycode(SCANCODE_KP_HEXADECIMAL)

constexpr Keycode KEYCODE_LCTRL =
  SDLK_LCTRL; ///< ScancodeToKeycode(SCANCODE_LCTRL)

constexpr Keycode KEYCODE_LSHIFT =
  SDLK_LSHIFT; ///< ScancodeToKeycode(SCANCODE_LSHIFT)

constexpr Keycode KEYCODE_LALT =
  SDLK_LALT; ///< ScancodeToKeycode(SCANCODE_LALT)

constexpr Keycode KEYCODE_LGUI =
  SDLK_LGUI; ///< ScancodeToKeycode(SCANCODE_LGUI)

constexpr Keycode KEYCODE_RCTRL =
  SDLK_RCTRL; ///< ScancodeToKeycode(SCANCODE_RCTRL)

constexpr Keycode KEYCODE_RSHIFT =
  SDLK_RSHIFT; ///< ScancodeToKeycode(SCANCODE_RSHIFT)

constexpr Keycode KEYCODE_RALT =
  SDLK_RALT; ///< ScancodeToKeycode(SCANCODE_RALT)

constexpr Keycode KEYCODE_RGUI =
  SDLK_RGUI; ///< ScancodeToKeycode(SCANCODE_RGUI)

constexpr Keycode KEYCODE_MODE =
  SDLK_MODE; ///< ScancodeToKeycode(SCANCODE_MODE)

constexpr Keycode KEYCODE_SLEEP =
  SDLK_SLEEP; ///< ScancodeToKeycode(SCANCODE_SLEEP)

constexpr Keycode KEYCODE_WAKE =
  SDLK_WAKE; ///< ScancodeToKeycode(SCANCODE_WAKE)

constexpr Keycode KEYCODE_CHANNEL_INCREMENT =
  SDLK_CHANNEL_INCREMENT; ///< ScancodeToKeycode(SCANCODE_CHANNEL_INCREMENT)

constexpr Keycode KEYCODE_CHANNEL_DECREMENT =
  SDLK_CHANNEL_DECREMENT; ///< ScancodeToKeycode(SCANCODE_CHANNEL_DECREMENT)

constexpr Keycode KEYCODE_MEDIA_PLAY =
  SDLK_MEDIA_PLAY; ///< ScancodeToKeycode(SCANCODE_MEDIA_PLAY)

constexpr Keycode KEYCODE_MEDIA_PAUSE =
  SDLK_MEDIA_PAUSE; ///< ScancodeToKeycode(SCANCODE_MEDIA_PAUSE)

constexpr Keycode KEYCODE_MEDIA_RECORD =
  SDLK_MEDIA_RECORD; ///< ScancodeToKeycode(SCANCODE_MEDIA_RECORD)

constexpr Keycode KEYCODE_MEDIA_FAST_FORWARD =
  SDLK_MEDIA_FAST_FORWARD; ///< ScancodeToKeycode(SCANCODE_MEDIA_FAST_FORWARD)

constexpr Keycode KEYCODE_MEDIA_REWIND =
  SDLK_MEDIA_REWIND; ///< ScancodeToKeycode(SCANCODE_MEDIA_REWIND)

constexpr Keycode KEYCODE_MEDIA_NEXT_TRACK =
  SDLK_MEDIA_NEXT_TRACK; ///< ScancodeToKeycode(SCANCODE_MEDIA_NEXT_TRACK)

constexpr Keycode KEYCODE_MEDIA_PREVIOUS_TRACK =
  SDLK_MEDIA_PREVIOUS_TRACK; ///< ScancodeToKeycode(SCANCODE_MEDIA_PREVIOUS_TRACK)

constexpr Keycode KEYCODE_MEDIA_STOP =
  SDLK_MEDIA_STOP; ///< ScancodeToKeycode(SCANCODE_MEDIA_STOP)

constexpr Keycode KEYCODE_MEDIA_EJECT =
  SDLK_MEDIA_EJECT; ///< ScancodeToKeycode(SCANCODE_MEDIA_EJECT)

constexpr Keycode KEYCODE_MEDIA_PLAY_PAUSE =
  SDLK_MEDIA_PLAY_PAUSE; ///< ScancodeToKeycode(SCANCODE_MEDIA_PLAY_PAUSE)

constexpr Keycode KEYCODE_MEDIA_SELECT =
  SDLK_MEDIA_SELECT; ///< ScancodeToKeycode(SCANCODE_MEDIA_SELECT)

constexpr Keycode KEYCODE_AC_NEW =
  SDLK_AC_NEW; ///< ScancodeToKeycode(SCANCODE_AC_NEW)

constexpr Keycode KEYCODE_AC_OPEN =
  SDLK_AC_OPEN; ///< ScancodeToKeycode(SCANCODE_AC_OPEN)

constexpr Keycode KEYCODE_AC_CLOSE =
  SDLK_AC_CLOSE; ///< ScancodeToKeycode(SCANCODE_AC_CLOSE)

constexpr Keycode KEYCODE_AC_EXIT =
  SDLK_AC_EXIT; ///< ScancodeToKeycode(SCANCODE_AC_EXIT)

constexpr Keycode KEYCODE_AC_SAVE =
  SDLK_AC_SAVE; ///< ScancodeToKeycode(SCANCODE_AC_SAVE)

constexpr Keycode KEYCODE_AC_PRINT =
  SDLK_AC_PRINT; ///< ScancodeToKeycode(SCANCODE_AC_PRINT)

constexpr Keycode KEYCODE_AC_PROPERTIES =
  SDLK_AC_PROPERTIES; ///< ScancodeToKeycode(SCANCODE_AC_PROPERTIES)

constexpr Keycode KEYCODE_AC_SEARCH =
  SDLK_AC_SEARCH; ///< ScancodeToKeycode(SCANCODE_AC_SEARCH)

constexpr Keycode KEYCODE_AC_HOME =
  SDLK_AC_HOME; ///< ScancodeToKeycode(SCANCODE_AC_HOME)

constexpr Keycode KEYCODE_AC_BACK =
  SDLK_AC_BACK; ///< ScancodeToKeycode(SCANCODE_AC_BACK)

constexpr Keycode KEYCODE_AC_FORWARD =
  SDLK_AC_FORWARD; ///< ScancodeToKeycode(SCANCODE_AC_FORWARD)

constexpr Keycode KEYCODE_AC_STOP =
  SDLK_AC_STOP; ///< ScancodeToKeycode(SCANCODE_AC_STOP)

constexpr Keycode KEYCODE_AC_REFRESH =
  SDLK_AC_REFRESH; ///< ScancodeToKeycode(SCANCODE_AC_REFRESH)

constexpr Keycode KEYCODE_AC_BOOKMARKS =
  SDLK_AC_BOOKMARKS; ///< ScancodeToKeycode(SCANCODE_AC_BOOKMARKS)

constexpr Keycode KEYCODE_SOFTLEFT =
  SDLK_SOFTLEFT; ///< ScancodeToKeycode(SCANCODE_SOFTLEFT)

constexpr Keycode KEYCODE_SOFTRIGHT =
  SDLK_SOFTRIGHT; ///< ScancodeToKeycode(SCANCODE_SOFTRIGHT)

constexpr Keycode KEYCODE_CALL =
  SDLK_CALL; ///< ScancodeToKeycode(SCANCODE_CALL)

constexpr Keycode KEYCODE_ENDCALL =
  SDLK_ENDCALL; ///< ScancodeToKeycode(SCANCODE_ENDCALL)

constexpr Keycode KEYCODE_LEFT_TAB = SDLK_LEFT_TAB; ///< Extended key Left Tab

constexpr Keycode KEYCODE_LEVEL5_SHIFT =
  SDLK_LEVEL5_SHIFT; ///< Extended key Level 5 Shift

constexpr Keycode KEYCODE_MULTI_KEY_COMPOSE =
  SDLK_MULTI_KEY_COMPOSE; ///< Extended key Multi-key Compose

constexpr Keycode KEYCODE_LMETA = SDLK_LMETA; ///< Extended key Left Meta

constexpr Keycode KEYCODE_RMETA = SDLK_RMETA; ///< Extended key Right Meta

constexpr Keycode KEYCODE_LHYPER = SDLK_LHYPER; ///< Extended key Left Hyper

constexpr Keycode KEYCODE_RHYPER = SDLK_RHYPER; ///< Extended key Right Hyper

constexpr Keycode KEYCODE_EXTENDED_MASK = SDLK_EXTENDED_MASK; ///< EXTENDED_MASK

constexpr bool Keycode::IsExtended() const
{
  return m_keycode & SDLK_EXTENDED_MASK;
}

constexpr Keycode KEYCODE_SCANCODE_MASK = SDLK_SCANCODE_MASK; ///< SCANCODE_MASK

constexpr bool Keycode::IsScancode() const
{
  return m_keycode & SDLK_SCANCODE_MASK;
}

/**
 * Transform scancode to keycode
 *
 * @param x scancode
 * @return keycode
 */
constexpr Keycode ScancodeToKeycode(Scancode x)
{
  return SDL_SCANCODE_TO_KEYCODE(x);
}

/// @}

/**
 * @defgroup CategoryStorage Storage Abstraction
 *
 * The storage API is a high-level API designed to abstract away the
 * portability issues that come up when using something lower-level (in SDL's
 * case, this sits on top of the [Filesystem](CategoryFilesystem) and
 * [IOStream](CategoryIOStream) subsystems). It is significantly more
 * restrictive than a typical filesystem API, for a number of reasons:
 *
 * 1. **What to Access:** A common pitfall with existing filesystem APIs is
 * the assumption that all storage is monolithic. However, many other
 * platforms (game consoles in particular) are more strict about what _type_
 * of filesystem is being accessed; for example, game content and user data
 * are usually two separate storage devices with entirely different
 * characteristics (and possibly different low-level APIs altogether!).
 *
 * 2. **How to Access:** Another common mistake is applications assuming that
 * all storage is universally writeable - again, many platforms treat game
 * content and user data as two separate storage devices, and only user data
 * is writeable while game content is read-only.
 *
 * 3. **When to Access:** The most common portability issue with filesystem
 * access is _timing_ - you cannot always assume that the storage device is
 * always accessible all of the time, nor can you assume that there are no
 * limits to how long you have access to a particular device.
 *
 * Consider the following example:
 *
 * ```c
 * void ReadGameData(void)
 * {
 *     extern char** fileNames;
 *     extern size_t numFiles;
 *     for (size_t i = 0; i < numFiles; i += 1) {
 *         FILE *data = fopen(fileNames[i], "rwb");
 *         if (data == nullptr) {
 *             // Something bad happened!
 *         } else {
 *             // A bunch of stuff happens here
 *             fclose(data);
 *         }
 *     }
 * }
 *
 * void ReadSave(void)
 * {
 *     FILE *save = fopen("saves/save0.sav", "rb");
 *     if (save == nullptr) {
 *         // Something bad happened!
 *     } else {
 *         // A bunch of stuff happens here
 *         fclose(save);
 *     }
 * }
 *
 * void WriteSave(void)
 * {
 *     FILE *save = fopen("saves/save0.sav", "wb");
 *     if (save == nullptr) {
 *         // Something bad happened!
 *     } else {
 *         // A bunch of stuff happens here
 *         fclose(save);
 *     }
 * }
 * ```
 *
 * Going over the bullet points again:
 *
 * 1. **What to Access:** This code accesses a global filesystem; game data
 * and saves are all presumed to be in the current working directory (which
 * may or may not be the game's installation folder!).
 *
 * 2. **How to Access:** This code assumes that content paths are writeable,
 * and that save data is also writeable despite being in the same location as
 * the game data.
 *
 * 3. **When to Access:** This code assumes that they can be called at any
 * time, since the filesystem is always accessible and has no limits on how
 * long the filesystem is being accessed.
 *
 * Due to these assumptions, the filesystem code is not portable and will fail
 * under these common scenarios:
 *
 * - The game is installed on a device that is read-only, both content loading
 *   and game saves will fail or crash outright
 * - Game/User storage is not implicitly mounted, so no files will be found
 *   for either scenario when a platform requires explicitly mounting
 *   filesystems
 * - Save data may not be safe since the I/O is not being flushed or
 *   validated, so an error occurring elsewhere in the program may result in
 *   missing/corrupted save data
 *
 * When using Storage, these types of problems are virtually impossible to
 * trip over:
 *
 * ```cpp
 * void ReadGameData(void)
 * {
 *     extern char** fileNames;
 *     extern size_t numFiles;
 *
 *     Storage title(nullptr, 0);
 *     if (title == nullptr) {
 *         // Something bad happened!
 *     }
 *     while (!title.Ready()) {
 *         Delay(1);
 *     }
 *
 *     for (size_t i = 0; i < numFiles; i += 1) {
 *         void* dst;
 *         Uint64 dstLen = title.GetSize(fileNames[i]);
 *
 *         if (dstLen > 0) {
 *           dst = malloc(dstLen);
 *           if (title.ReadFile(fileNames[i], dst, dstLen)) {
 *                 // A bunch of stuff happens here
 *             } else {
 *                 // Something bad happened!
 *             }
 *             free(dst);
 *         } else {
 *             // Something bad happened!
 *         }
 *     }
 * }
 *
 * void ReadSave(void)
 * {
 *     Storage user("libsdl", "Storage Example", 0);
 *     if (user == nullptr) {
 *         // Something bad happened!
 *     }
 *     while (!user.Ready()) {
 *         Delay(1);
 *     }
 *
 *     Uint64 saveLen = user.GetFileSize();
 *     if (saveLen > 0) {
 *         void* dst = malloc(saveLen);
 *         if (user.ReadFile("save0.sav", dst, saveLen)) {
 *             // A bunch of stuff happens here
 *         } else {
 *             // Something bad happened!
 *         }
 *         free(dst);
 *     } else {
 *         // Something bad happened!
 *     }
 * }
 *
 * void WriteSave(void)
 * {
 *     Storage user("libsdl", "Storage Example", 0);
 *     if (user == nullptr) {
 *         // Something bad happened!
 *     }
 *     while (!user.Ready()) {
 *         Delay(1);
 *     }
 *
 *     extern void *saveData; // A bunch of stuff happened here...
 *     extern Uint64 saveLen;
 *     if (!user.WriteFile("save0.sav", saveData, saveLen)) {
 *         // Something bad happened!
 *     }
 * }
 * ```
 *
 * Note the improvements that Storage makes:
 *
 * 1. **What to Access:** This code explicitly reads from a title or user
 * storage device based on the context of the function.
 *
 * 2. **How to Access:** This code explicitly uses either a read or write
 * function based on the context of the function.
 *
 * 3. **When to Access:** This code explicitly opens the device when it needs
 * to, and closes it when it is finished working with the filesystem.
 *
 * The result is an application that is significantly more robust against the
 * increasing demands of platforms and their filesystems!
 *
 * A publicly available example of an Storage backend is the
 * [Steam Cloud](https://partner.steamgames.com/doc/features/cloud)
 * backend - you can initialize Steamworks when starting the program, and then
 * SDL will recognize that Steamworks is initialized and automatically use
 * ISteamRemoteStorage when the application opens user storage. More
 * importantly, when you _open_ storage it knows to begin a "batch" of
 * filesystem operations, and when you _close_ storage it knows to end and
 * flush the batch. This is used by Steam to support
 * [Dynamic Cloud
 * Sync](https://steamcommunity.com/groups/steamworks/announcements/detail/3142949576401813670)
 * ; users can save data on one PC, put the device to sleep, and then continue
 * playing on another PC (and vice versa) with the save data fully
 * synchronized across all devices, allowing for a seamless experience without
 * having to do full restarts of the program.
 *
 * ## Notes on valid paths
 *
 * All paths in the Storage API use Unix-style path separators ('/'). Using a
 * different path separator will not work, even if the underlying platform
 * would otherwise accept it. This is to keep code using the Storage API
 * portable between platforms and Storage implementations and simplify app
 * code.
 *
 * Paths with relative directories ("." and "..") are forbidden by the Storage
 * API.
 *
 * All valid UTF-8 strings (discounting the nullptr terminator character and the
 * '/' path separator) are usable for filenames, however, an underlying
 * Storage implementation may not support particularly strange sequences and
 * refuse to create files with those names, etc.
 *
 * @{
 */

// Forward decl
struct Storage;

using StorageRaw = SDL_Storage*;

// Forward decl
struct StorageRef;

/// Safely wrap Storage for non owning parameters
struct StorageParam
{
  StorageRaw value; ///< parameter's StorageRaw

  /// Constructs from StorageRaw
  constexpr StorageParam(StorageRaw value)
    : value(value)
  {
  }

  /// Constructs null/invalid
  constexpr StorageParam(std::nullptr_t _ = nullptr)
    : value(nullptr)
  {
  }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!value; }

  /// Comparison
  constexpr auto operator<=>(const StorageParam& other) const = default;

  /// Converts to underlying StorageRaw
  constexpr operator StorageRaw() const { return value; }
};

/**
 * Function interface for Storage.
 *
 * Apps that want to supply a custom implementation of Storage will fill
 * in all the functions in this struct, and then pass it to Storage.Storage to
 * create a custom Storage object.
 *
 * It is not usually necessary to do this; SDL provides standard
 * implementations for many things you might expect to do with an Storage.
 *
 * This structure should be initialized using SDL_INIT_INTERFACE()
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @sa SDL_INIT_INTERFACE
 */
using StorageInterface = SDL_StorageInterface;

/**
 * An abstract interface for filesystem access.
 *
 * This is an opaque datatype. One can create this object using standard SDL
 * functions like Storage.Storage, etc, or create
 * an object with a custom implementation using Storage.Storage.
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @cat resource
 */
class Storage
{
  StorageRaw m_resource = nullptr;

public:
  /// Default ctor
  constexpr Storage() = default;

  /**
   * Constructs from StorageParam.
   *
   * @param resource a StorageRaw to be wrapped.
   *
   * This assumes the ownership, call release() if you need to take back.
   */
  constexpr explicit Storage(const StorageRaw resource)
    : m_resource(resource)
  {
  }

  /// Copy constructor
  constexpr Storage(const Storage& other) = delete;

  /// Move constructor
  constexpr Storage(Storage&& other)
    : Storage(other.release())
  {
  }

  constexpr Storage(const StorageRef& other) = delete;

  constexpr Storage(StorageRef&& other) = delete;

  /**
   * Opens up a read-only container for the application's filesystem.
   *
   * @param override a path to override the backend's default title root.
   * @param props a property list that may contain backend-specific information.
   * @post a title storage container on success.
   * @throws Error on failure.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Storage.Close
   * @sa Storage.GetFileSize
   * @sa Storage.Storage
   * @sa Storage.ReadFile
   */
  Storage(StringParam override, PropertiesParam props)
    : m_resource(CheckError(SDL_OpenTitleStorage(override, props)))
  {
  }

  /**
   * Opens up a container for a user's unique read/write filesystem.
   *
   * While title storage can generally be kept open throughout runtime, user
   * storage should only be opened when the client is ready to read/write files.
   * This allows the backend to properly batch file operations and flush them
   * when the container has been closed; ensuring safe and optimal save I/O.
   *
   * @param org the name of your organization.
   * @param app the name of your application.
   * @param props a property list that may contain backend-specific information.
   * @post a user storage container on success.
   * @throws Error on failure.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Storage.Close
   * @sa Storage.GetFileSize
   * @sa Storage.GetSpaceRemaining
   * @sa Storage.Storage
   * @sa Storage.ReadFile
   * @sa Storage.Ready
   * @sa Storage.WriteFile
   */
  Storage(StringParam org, StringParam app, PropertiesParam props)
    : m_resource(CheckError(SDL_OpenUserStorage(org, app, props)))
  {
  }

  /**
   * Opens up a container for local filesystem storage.
   *
   * This is provided for development and tools. Portable applications should
   * use Storage.Storage() for access to game data and
   * Storage.Storage() for access to user data.
   *
   * @param path the base path prepended to all storage paths, or nullptr for no
   *             base path.
   * @post a filesystem storage container on success.
   * @throws Error on failure.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Storage.Close
   * @sa Storage.GetFileSize
   * @sa Storage.GetSpaceRemaining
   * @sa Storage.Storage
   * @sa Storage.Storage
   * @sa Storage.ReadFile
   * @sa Storage.WriteFile
   */
  Storage(StringParam path)
    : m_resource(CheckError(SDL_OpenFileStorage(path)))
  {
  }

  /**
   * Opens up a container using a client-provided storage interface.
   *
   * Applications do not need to use this function unless they are providing
   * their own Storage implementation. If you just need an Storage, you
   * should use the built-in implementations in SDL, like Storage.Storage()
   * or Storage.Storage().
   *
   * This function makes a copy of `iface` and the caller does not need to keep
   * it around after this call.
   *
   * @param iface the interface that implements this storage, initialized using
   *              SDL_INIT_INTERFACE().
   * @param userdata the pointer that will be passed to the interface functions.
   * @post a storage container on success.
   * @throws Error on failure.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Storage.Close
   * @sa Storage.GetFileSize
   * @sa Storage.GetSpaceRemaining
   * @sa SDL_INIT_INTERFACE
   * @sa Storage.ReadFile
   * @sa Storage.Ready
   * @sa Storage.WriteFile
   */
  Storage(const StorageInterface* iface, void* userdata)
    : m_resource(CheckError(SDL_OpenStorage(iface, userdata)))
  {
  }

  /// Destructor
  ~Storage() { CheckError(SDL_CloseStorage(m_resource)); }

  /// Assignment operator.
  Storage& operator=(Storage other)
  {
    std::swap(m_resource, other.m_resource);
    return *this;
  }

  /// Retrieves underlying StorageRaw.
  constexpr StorageRaw get() const { return m_resource; }

  /// Retrieves underlying StorageRaw and clear this.
  constexpr StorageRaw release()
  {
    auto r = m_resource;
    m_resource = nullptr;
    return r;
  }

  /// Comparison
  constexpr auto operator<=>(const Storage& other) const = default;

  /// Comparison
  constexpr bool operator==(std::nullptr_t _) const { return !m_resource; }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!m_resource; }

  /// Converts to StorageParam
  constexpr operator StorageParam() const { return {m_resource}; }

  /**
   * Closes and frees a storage container.
   *
   * @returns true if the container was freed with no errors, false otherwise;
   *          call GetError() for more information. Even if the function
   *          returns an error, the container data will be freed; the error is
   *          only for informational purposes.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Storage.Storage
   */
  bool Close();

  /**
   * Checks if the storage container is ready to use.
   *
   * This function should be called in regular intervals until it returns true -
   * however, it is not recommended to spinwait on this call, as the backend may
   * depend on a synchronous message loop. You might instead poll this in your
   * game's main loop while processing events and drawing a loading screen.
   *
   * @returns true if the container is ready, false otherwise.
   *
   * @since This function is available since SDL 3.2.0.
   */
  bool Ready();

  /**
   * Query the size of a file within a storage container.
   *
   * @param path the relative path of the file to query.
   * @returns the file's length on success or 0 on failure; call
   *          GetError() for more information.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Storage.ReadFile
   * @sa Storage.Ready
   */
  std::optional<Uint64> GetFileSize(StringParam path);

  /**
   * Synchronously read a file from a storage container into a client-provided
   * buffer.
   *
   * The value of `length` must match the length of the file exactly; call
   * Storage.GetFileSize() to get this value. This behavior may be relaxed in
   * a future release.
   *
   * @param path the relative path of the file to read.
   * @param destination a client-provided buffer to read the file into.
   * @returns true if the file was read or false on failure; call GetError()
   *          for more information.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Storage.GetFileSize
   * @sa Storage.Ready
   * @sa Storage.WriteFile
   */
  bool ReadFile(StringParam path, TargetBytes destination);

  /**
   * Synchronously read a file from a storage container into a client-provided
   * buffer.
   *
   * The value of `length` must match the length of the file exactly; call
   * Storage.GetFileSize() to get this value. This behavior may be relaxed in
   * a future release.
   *
   * @param path the relative path of the file to read.
   * @returns true if the file was read or false on failure; call GetError()
   *          for more information.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Storage.GetFileSize
   * @sa Storage.Ready
   * @sa Storage.WriteFile
   */
  std::string ReadFile(StringParam path);

  /**
   * Synchronously write a file from client memory into a storage container.
   *
   * @param path the relative path of the file to write.
   * @param source a client-provided buffer to write from.
   * @returns true if the file was written or false on failure; call
   *          GetError() for more information.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Storage.GetSpaceRemaining
   * @sa Storage.ReadFile
   * @sa Storage.Ready
   */
  void WriteFile(StringParam path, SourceBytes source);

  /**
   * Create a directory in a writable storage container.
   *
   * @param path the path of the directory to create.
   * @throws Error on failure.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Storage.Ready
   */
  void CreateDirectory(StringParam path);

  /**
   * Enumerate a directory in a storage container through a callback function.
   *
   * This function provides every directory entry through an app-provided
   * callback, called once for each directory entry, until all results have been
   * provided or the callback returns either ENUM_SUCCESS or
   * ENUM_FAILURE.
   *
   * This will return false if there was a system problem in general, or if a
   * callback returns ENUM_FAILURE. A successful return means a callback
   * returned ENUM_SUCCESS to halt enumeration, or all directory entries
   * were enumerated.
   *
   * If `path` is nullptr, this is treated as a request to enumerate the root of
   * the storage container's tree. An empty string also works for this.
   *
   * @param path the path of the directory to enumerate, or nullptr for the
   * root.
   * @param callback a function that is called for each entry in the directory.
   * @param userdata a pointer that is passed to `callback`.
   * @throws Error on failure.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Storage.Ready
   */
  void EnumerateDirectory(StringParam path,
                          EnumerateDirectoryCallback callback,
                          void* userdata);

  /**
   * Enumerate a directory in a storage container through a callback function.
   *
   * This function provides every directory entry through an app-provided
   * callback, called once for each directory entry, until all results have been
   * provided or the callback returns either ENUM_SUCCESS or
   * ENUM_FAILURE.
   *
   * This will return false if there was a system problem in general, or if a
   * callback returns ENUM_FAILURE. A successful return means a callback
   * returned ENUM_SUCCESS to halt enumeration, or all directory entries
   * were enumerated.
   *
   * If `path` is nullptr, this is treated as a request to enumerate the root of
   * the storage container's tree. An empty string also works for this.
   *
   * @param path the path of the directory to enumerate, or nullptr for the
   * root.
   * @param callback a function that is called for each entry in the directory.
   * @returns all the directory contents.
   * @throws Error on failure.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Storage.Ready
   */
  void EnumerateDirectory(StringParam path, EnumerateDirectoryCB callback);

  /**
   * Remove a file or an empty directory in a writable storage container.
   *
   * @param path the path of the directory to enumerate.
   * @throws Error on failure.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Storage.Ready
   */
  void RemovePath(StringParam path);

  /**
   * Rename a file or directory in a writable storage container.
   *
   * @param oldpath the old path.
   * @param newpath the new path.
   * @throws Error on failure.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Storage.Ready
   */
  void RenamePath(StringParam oldpath, StringParam newpath);

  /**
   * Copy a file in a writable storage container.
   *
   * @param oldpath the old path.
   * @param newpath the new path.
   * @throws Error on failure.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Storage.Ready
   */
  void CopyFile(StringParam oldpath, StringParam newpath);

  /**
   * Get information about a filesystem path in a storage container.
   *
   * @param path the path to query.
   * @returns the info on success or false if the file doesn't exist, or another
   *          failure; call GetError() for more information.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Storage.Ready
   */
  PathInfo GetPathInfo(StringParam path);

  /**
   * Queries the remaining space in a storage container.
   *
   * @returns the amount of remaining space, in bytes.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Storage.Ready
   * @sa Storage.WriteFile
   */
  Uint64 GetSpaceRemaining();

  /**
   * Enumerate a directory tree, filtered by pattern, and return a list.
   *
   * Files are filtered out if they don't match the string in `pattern`, which
   * may contain wildcard characters `*` (match everything) and `?` (match one
   * character). If pattern is nullptr, no filtering is done and all results are
   * returned. Subdirectories are permitted, and are specified with a path
   * separator of '/'. Wildcard characters `*` and `?` never match a path
   * separator.
   *
   * `flags` may be set to GLOB_CASEINSENSITIVE to make the pattern matching
   * case-insensitive.
   *
   * The returned array is always nullptr-terminated, for your iterating
   * convenience, but if `count` is non-nullptr, on return it will contain the
   * number of items in the array, not counting the nullptr terminator.
   *
   * If `path` is nullptr, this is treated as a request to enumerate the root of
   * the storage container's tree. An empty string also works for this.
   *
   * @param path the path of the directory to enumerate, or nullptr for the
   * root.
   * @param pattern the pattern that files in the directory must match. Can be
   *                nullptr.
   * @param flags `SDL_GLOB_*` bitflags that affect this search.
   * @returns an array of strings on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread, assuming
   *               the `storage` object is thread-safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  OwnArray<char*> GlobDirectory(StringParam path,
                                StringParam pattern,
                                GlobFlags flags);

  /**
   * Synchronously read a file from a storage container into a client-provided
   * buffer.
   *
   * The value of `length` must match the length of the file exactly; call
   * Storage.GetFileSize() to get this value. This behavior may be relaxed
   * in a future release.
   *
   * @param path the relative path of the file to read.
   * @returns the content if the file was read or empty string on failure; call
   *          GetError() for more information.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Storage.GetFileSize
   * @sa Storage.Ready
   * @sa Storage.WriteFile
   */
  template<class T>
  std::vector<T> ReadFileAs(StringParam path);
};

/// Semi-safe reference for Storage.
struct StorageRef : Storage
{
  /**
   * Constructs from StorageParam.
   *
   * @param resource a StorageRaw or Storage.
   *
   * This does not takes ownership!
   */
  StorageRef(StorageParam resource)
    : Storage(resource.value)
  {
  }

  /// Copy constructor.
  StorageRef(const StorageRef& other)
    : Storage(other.get())
  {
  }

  /// Destructor
  ~StorageRef() { release(); }
};

/**
 * Opens up a read-only container for the application's filesystem.
 *
 * @param override a path to override the backend's default title root.
 * @param props a property list that may contain backend-specific information.
 * @returns a title storage container on success.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Storage.Close
 * @sa Storage.GetFileSize
 * @sa Storage.Storage
 * @sa Storage.ReadFile
 */
inline Storage OpenTitleStorage(StringParam override, PropertiesParam props)
{
  return Storage(std::move(override), props);
}

/**
 * Opens up a container for a user's unique read/write filesystem.
 *
 * While title storage can generally be kept open throughout runtime, user
 * storage should only be opened when the client is ready to read/write files.
 * This allows the backend to properly batch file operations and flush them
 * when the container has been closed; ensuring safe and optimal save I/O.
 *
 * @param org the name of your organization.
 * @param app the name of your application.
 * @param props a property list that may contain backend-specific information.
 * @returns a user storage container on success.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Storage.Close
 * @sa Storage.GetFileSize
 * @sa Storage.GetSpaceRemaining
 * @sa Storage.Storage
 * @sa Storage.ReadFile
 * @sa Storage.Ready
 * @sa Storage.WriteFile
 */
inline Storage OpenUserStorage(StringParam org,
                               StringParam app,
                               PropertiesParam props)
{
  return Storage(std::move(org), std::move(app), props);
}

/**
 * Opens up a container for local filesystem storage.
 *
 * This is provided for development and tools. Portable applications should
 * use Storage.Storage() for access to game data and
 * Storage.Storage() for access to user data.
 *
 * @param path the base path prepended to all storage paths, or nullptr for no
 *             base path.
 * @returns a filesystem storage container on success.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Storage.Close
 * @sa Storage.GetFileSize
 * @sa Storage.GetSpaceRemaining
 * @sa Storage.Storage
 * @sa Storage.Storage
 * @sa Storage.ReadFile
 * @sa Storage.WriteFile
 */
inline Storage OpenFileStorage(StringParam path)
{
  return Storage(std::move(path));
}

/**
 * Opens up a container using a client-provided storage interface.
 *
 * Applications do not need to use this function unless they are providing
 * their own Storage implementation. If you just need an Storage, you
 * should use the built-in implementations in SDL, like Storage.Storage()
 * or Storage.Storage().
 *
 * This function makes a copy of `iface` and the caller does not need to keep
 * it around after this call.
 *
 * @param iface the interface that implements this storage, initialized using
 *              SDL_INIT_INTERFACE().
 * @param userdata the pointer that will be passed to the interface functions.
 * @returns a storage container on success.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Storage.Close
 * @sa Storage.GetFileSize
 * @sa Storage.GetSpaceRemaining
 * @sa SDL_INIT_INTERFACE
 * @sa Storage.ReadFile
 * @sa Storage.Ready
 * @sa Storage.WriteFile
 */
inline Storage OpenStorage(const StorageInterface* iface, void* userdata)
{
  return Storage(iface, userdata);
}

/**
 * Closes and frees a storage container.
 *
 * @param storage a storage container to close.
 * @returns true if the container was freed with no errors, false otherwise;
 *          call GetError() for more information. Even if the function
 *          returns an error, the container data will be freed; the error is
 *          only for informational purposes.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Storage.Storage
 * @sa Storage.Storage
 * @sa Storage.Storage
 * @sa Storage.Storage
 */
inline bool CloseStorage(StorageRaw storage)
{
  return SDL_CloseStorage(storage);
}

inline bool Storage::Close()
{
  auto r = SDL_CloseStorage(m_resource);
  m_resource = nullptr;
  return r;
}

/**
 * Checks if the storage container is ready to use.
 *
 * This function should be called in regular intervals until it returns true -
 * however, it is not recommended to spinwait on this call, as the backend may
 * depend on a synchronous message loop. You might instead poll this in your
 * game's main loop while processing events and drawing a loading screen.
 *
 * @param storage a storage container to query.
 * @returns true if the container is ready, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline bool StorageReady(StorageParam storage)
{
  return SDL_StorageReady(storage);
}

inline bool Storage::Ready() { return SDL::StorageReady(m_resource); }

/**
 * Query the size of a file within a storage container.
 *
 * @param storage a storage container to query.
 * @param path the relative path of the file to query.
 * @returns the file's length on success or std::nullopt on failure; call
 *          GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Storage.ReadFile
 * @sa Storage.Ready
 */
inline std::optional<Uint64> GetStorageFileSize(StorageParam storage,
                                                StringParam path)
{
  if (Uint64 length; SDL_GetStorageFileSize(storage, path, &length)) {
    return length;
  }
  return {};
}

inline std::optional<Uint64> Storage::GetFileSize(StringParam path)
{
  return SDL::GetStorageFileSize(m_resource, std::move(path));
}

/**
 * Synchronously read a file from a storage container into a client-provided
 * buffer.
 *
 * @param storage a storage container to read from.
 * @param path the relative path of the file to read.
 * @param destination a client-provided buffer to read the file into.
 * @returns true if the file was read or false on failure; call GetError()
 *          for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Storage.GetFileSize
 * @sa Storage.Ready
 * @sa Storage.WriteFile
 */
inline bool ReadStorageFile(StorageParam storage,
                            StringParam path,
                            TargetBytes destination)
{
  return SDL_ReadStorageFile(
    storage, path, destination.data, destination.size_bytes);
}

/**
 * Synchronously read a file from a storage container into a client-provided
 * buffer.
 *
 * @param storage a storage container to read from.
 * @param path the relative path of the file to read.
 * @returns the content if the file was read.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Storage.GetFileSize
 * @sa Storage.Ready
 * @sa Storage.WriteFile
 */
inline std::string ReadStorageFile(StorageParam storage, StringParam path)
{
  auto sz = GetStorageFileSize(storage, path.c_str());
  if (!sz || *sz == 0) return {};
  std::string buffer(*sz, 0);
  CheckError(ReadStorageFile(storage, std::move(path), buffer));
  return buffer;
}

inline bool Storage::ReadFile(StringParam path, TargetBytes destination)
{
  return SDL::ReadStorageFile(
    m_resource, std::move(path), std::move(destination));
}

inline std::string Storage::ReadFile(StringParam path)
{
  return SDL::ReadStorageFile(m_resource, std::move(path));
}

/**
 * Synchronously read a file from a storage container into a client-provided
 * buffer.
 *
 * @param storage a storage container to read from.
 * @param path the relative path of the file to read.
 * @returns the content if the file was read.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Storage.GetFileSize
 * @sa Storage.Ready
 * @sa Storage.WriteFile
 */
template<class T>
inline std::vector<T> ReadStorageFileAs(StorageParam storage, StringParam path)
{
  auto sz = GetStorageFileSize(storage, path.c_str());
  if (!sz || *sz == 0) return {};
  std::vector<T> buffer(*sz / sizeof(T) + (*sz % sizeof(T) ? 1 : 0), 0);
  CheckError(ReadFile(std::move(path), {buffer.data(), *sz}));
  return buffer;
}

template<class T>
inline std::vector<T> Storage::ReadFileAs(StringParam path)
{
  return SDL::ReadStorageFileAs<T>(m_resource, std::move(path));
}

/**
 * Synchronously write a file from client memory into a storage container.
 *
 * @param storage a storage container to write to.
 * @param path the relative path of the file to write.
 * @param source a client-provided buffer to write from.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Storage.GetSpaceRemaining
 * @sa Storage.ReadFile
 * @sa Storage.Ready
 */
inline void WriteStorageFile(StorageParam storage,
                             StringParam path,
                             SourceBytes source)
{
  CheckError(
    SDL_WriteStorageFile(storage, path, source.data, source.size_bytes));
}

inline void Storage::WriteFile(StringParam path, SourceBytes source)
{
  SDL::WriteStorageFile(m_resource, std::move(path), std::move(source));
}

/**
 * Create a directory in a writable storage container.
 *
 * @param storage a storage container.
 * @param path the path of the directory to create.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Storage.Ready
 */
inline void CreateStorageDirectory(StorageParam storage, StringParam path)
{
  CheckError(SDL_CreateStorageDirectory(storage, path));
}

inline void Storage::CreateDirectory(StringParam path)
{
  SDL::CreateStorageDirectory(m_resource, std::move(path));
}

/**
 * Enumerate a directory in a storage container through a callback function.
 *
 * This function provides every directory entry through an app-provided
 * callback, called once for each directory entry, until all results have been
 * provided or the callback returns either ENUM_SUCCESS or
 * ENUM_FAILURE.
 *
 * This will return false if there was a system problem in general, or if a
 * callback returns ENUM_FAILURE. A successful return means a callback
 * returned ENUM_SUCCESS to halt enumeration, or all directory entries
 * were enumerated.
 *
 * If `path` is nullptr, this is treated as a request to enumerate the root of
 * the storage container's tree. An empty string also works for this.
 *
 * @param storage a storage container.
 * @param path the path of the directory to enumerate, or nullptr for the root.
 * @param callback a function that is called for each entry in the directory.
 * @param userdata a pointer that is passed to `callback`.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Storage.Ready
 */
inline void EnumerateStorageDirectory(StorageParam storage,
                                      StringParam path,
                                      EnumerateDirectoryCallback callback,
                                      void* userdata)
{
  CheckError(SDL_EnumerateStorageDirectory(storage, path, callback, userdata));
}

/**
 * Enumerate a directory in a storage container through a callback function.
 *
 * This function provides every directory entry through an app-provided
 * callback, called once for each directory entry, until all results have been
 * provided or the callback returns either ENUM_SUCCESS or
 * ENUM_FAILURE.
 *
 * This will return false if there was a system problem in general, or if a
 * callback returns ENUM_FAILURE. A successful return means a callback
 * returned ENUM_SUCCESS to halt enumeration, or all directory entries
 * were enumerated.
 *
 * If `path` is nullptr, this is treated as a request to enumerate the root of
 * the storage container's tree. An empty string also works for this.
 *
 * @param storage a storage container.
 * @param path the path of the directory to enumerate, or nullptr for the root.
 * @param callback a function that is called for each entry in the directory.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Storage.Ready
 */
inline void EnumerateStorageDirectory(StorageParam storage,
                                      StringParam path,
                                      EnumerateDirectoryCB callback)
{
  EnumerateStorageDirectory(
    storage,
    std::move(path),
    [](void* userdata, const char* dirname, const char* fname) {
      auto& cb = *static_cast<EnumerateDirectoryCB*>(userdata);
      return cb(dirname, fname);
    },
    &callback);
}

/**
 * Enumerate a directory in a storage container through a callback function.
 *
 * This function provides every directory entry through an app-provided
 * callback, called once for each directory entry, until all results have been
 * provided or the callback returns either ENUM_SUCCESS or
 * ENUM_FAILURE.
 *
 * This will return false if there was a system problem in general, or if a
 * callback returns ENUM_FAILURE. A successful return means a callback
 * returned ENUM_SUCCESS to halt enumeration, or all directory entries
 * were enumerated.
 *
 * If `path` is nullptr, this is treated as a request to enumerate the root of
 * the storage container's tree. An empty string also works for this.
 *
 * @param storage a storage container.
 * @param path the path of the directory to enumerate, or nullptr for the root.
 * @returns all the directory contents.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Storage.Ready
 */
inline std::vector<Path> EnumerateStorageDirectory(StorageParam storage,
                                                   StringParam path)
{
  std::vector<Path> r;
  EnumerateDirectory(std::move(path), [&](const char*, const char* fname) {
    r.emplace_back(fname);
    return ENUM_CONTINUE;
  });
  return r;
}

inline void Storage::EnumerateDirectory(StringParam path,
                                        EnumerateDirectoryCallback callback,
                                        void* userdata)
{
  SDL::EnumerateStorageDirectory(
    m_resource, std::move(path), callback, userdata);
}

inline void Storage::EnumerateDirectory(StringParam path,
                                        EnumerateDirectoryCB callback)
{
  SDL::EnumerateStorageDirectory(m_resource, std::move(path), callback);
}

/**
 * Remove a file or an empty directory in a writable storage container.
 *
 * @param storage a storage container.
 * @param path the path of the directory to enumerate.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Storage.Ready
 */
inline void RemoveStoragePath(StorageParam storage, StringParam path)
{
  CheckError(SDL_RemoveStoragePath(storage, path));
}

inline void Storage::RemovePath(StringParam path)
{
  SDL::RemoveStoragePath(m_resource, std::move(path));
}

/**
 * Rename a file or directory in a writable storage container.
 *
 * @param storage a storage container.
 * @param oldpath the old path.
 * @param newpath the new path.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Storage.Ready
 */
inline void RenameStoragePath(StorageParam storage,
                              StringParam oldpath,
                              StringParam newpath)
{
  CheckError(SDL_RenameStoragePath(storage, oldpath, newpath));
}

inline void Storage::RenamePath(StringParam oldpath, StringParam newpath)
{
  SDL::RenameStoragePath(m_resource, std::move(oldpath), std::move(newpath));
}

/**
 * Copy a file in a writable storage container.
 *
 * @param storage a storage container.
 * @param oldpath the old path.
 * @param newpath the new path.
 * @throws Error on failure.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Storage.Ready
 */
inline void CopyStorageFile(StorageParam storage,
                            StringParam oldpath,
                            StringParam newpath)
{
  CheckError(SDL_CopyStorageFile(storage, oldpath, newpath));
}

inline void Storage::CopyFile(StringParam oldpath, StringParam newpath)
{
  SDL::CopyStorageFile(m_resource, std::move(oldpath), std::move(newpath));
}

/**
 * Get information about a filesystem path in a storage container.
 *
 * @param storage a storage container.
 * @param path the path to query.
 * @returns the info on success or false if the file doesn't exist, or another
 *          failure; call GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Storage.Ready
 */
inline PathInfo GetStoragePathInfo(StorageParam storage, StringParam path)
{
  if (PathInfo info; SDL_GetStoragePathInfo(storage, path, &info)) {
    return info;
  }
  return {};
}

inline PathInfo Storage::GetPathInfo(StringParam path)
{
  return SDL::GetStoragePathInfo(m_resource, std::move(path));
}

/**
 * Queries the remaining space in a storage container.
 *
 * @param storage a storage container to query.
 * @returns the amount of remaining space, in bytes.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Storage.Ready
 * @sa Storage.WriteFile
 */
inline Uint64 GetStorageSpaceRemaining(StorageParam storage)
{
  return SDL_GetStorageSpaceRemaining(storage);
}

inline Uint64 Storage::GetSpaceRemaining()
{
  return SDL::GetStorageSpaceRemaining(m_resource);
}

/**
 * Enumerate a directory tree, filtered by pattern, and return a list.
 *
 * Files are filtered out if they don't match the string in `pattern`, which
 * may contain wildcard characters `*` (match everything) and `?` (match one
 * character). If pattern is nullptr, no filtering is done and all results are
 * returned. Subdirectories are permitted, and are specified with a path
 * separator of '/'. Wildcard characters `*` and `?` never match a path
 * separator.
 *
 * `flags` may be set to GLOB_CASEINSENSITIVE to make the pattern matching
 * case-insensitive.
 *
 * The returned array is always nullptr-terminated, for your iterating
 * convenience, but if `count` is non-nullptr, on return it will contain the
 * number of items in the array, not counting the nullptr terminator.
 *
 * If `path` is nullptr, this is treated as a request to enumerate the root of
 * the storage container's tree. An empty string also works for this.
 *
 * @param storage a storage container.
 * @param path the path of the directory to enumerate, or nullptr for the root.
 * @param pattern the pattern that files in the directory must match. Can be
 *                nullptr.
 * @param flags `SDL_GLOB_*` bitflags that affect this search.
 * @returns an array of strings on success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread, assuming
 *               the `storage` object is thread-safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline OwnArray<char*> GlobStorageDirectory(StorageParam storage,
                                            StringParam path,
                                            StringParam pattern,
                                            GlobFlags flags)
{
  int count;
  auto data =
    CheckError(SDL_GlobStorageDirectory(storage, path, pattern, flags, &count));
  return OwnArray<char*>{data, size_t(count)};
}

inline OwnArray<char*> Storage::GlobDirectory(StringParam path,
                                              StringParam pattern,
                                              GlobFlags flags)
{
  return SDL::GlobStorageDirectory(
    m_resource, std::move(path), std::move(pattern), flags);
}

/// @}

/**
 * @defgroup CategorySurface Surface Creation and Simple Drawing
 *
 * SDL surfaces are buffers of pixels in system RAM. These are useful for
 * passing around and manipulating images that are not stored in GPU memory.
 *
 * Surface makes serious efforts to manage images in various formats, and
 * provides a reasonable toolbox for transforming the data, including copying
 * between surfaces, filling rectangles in the image data, etc.
 *
 * There is also a simple .bmp loader, Surface.LoadBMP(). SDL itself does not
 * provide loaders for various other file formats, but there are several
 * excellent external libraries that do, including its own satellite library,
 * SDL_image:
 *
 * https://github.com/libsdl-org/SDL_image
 *
 * @{
 */

// Forward decl
struct Surface;

using SurfaceRaw = SDL_Surface*;

/// Safely wrap Surface for non owning parameters
struct SurfaceParam
{
  SurfaceRaw value; ///< parameter's SurfaceRaw

  /// Constructs from SurfaceRaw
  constexpr SurfaceParam(SurfaceRaw value)
    : value(value)
  {
  }

  /// Constructs null/invalid
  constexpr SurfaceParam(std::nullptr_t _ = nullptr)
    : value(nullptr)
  {
  }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!value; }

  /// Comparison
  constexpr auto operator<=>(const SurfaceParam& other) const = default;

  /// Converts to underlying SurfaceRaw
  constexpr operator SurfaceRaw() const { return value; }
};

/// Safely wrap Surface for non owning const parameters
struct SurfaceConstParam
{
  const SurfaceRaw value; ///< parameter's const SurfaceRaw

  constexpr SurfaceConstParam(const SurfaceRaw value)
    : value(value)
  {
  }

  /// Constructs from SurfaceParam
  constexpr SurfaceConstParam(SurfaceParam value)
    : value(value.value)
  {
  }

  /// Constructs null/invalid
  constexpr SurfaceConstParam(std::nullptr_t _ = nullptr)
    : value(nullptr)
  {
  }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!value; }

  /// Comparison
  constexpr auto operator<=>(const SurfaceConstParam& other) const = default;

  /// Converts to underlying const SurfaceRaw
  constexpr operator const SurfaceRaw() const { return value; }
};

/**
 * The flags on an Surface.
 *
 * These are generally considered read-only.
 *
 * @since This datatype is available since SDL 3.2.0.
 */
using SurfaceFlags = Uint32;

constexpr SurfaceFlags SURFACE_PREALLOCATED =
  SDL_SURFACE_PREALLOCATED; ///< Surface uses preallocated pixel memory

constexpr SurfaceFlags SURFACE_LOCK_NEEDED =
  SDL_SURFACE_LOCK_NEEDED; ///< Surface needs to be locked to access pixels

constexpr SurfaceFlags SURFACE_LOCKED =
  SDL_SURFACE_LOCKED; ///< Surface is currently locked

/// Surface uses pixel memory allocated with aligned_alloc()
constexpr SurfaceFlags SURFACE_SIMD_ALIGNED = SDL_SURFACE_SIMD_ALIGNED;

/**
 * Evaluates to true if the surface needs to be locked before access.
 *
 * @since This macro is available since SDL 3.2.0.
 */
constexpr bool MUSTLOCK(SurfaceConstParam S) { return SDL_MUSTLOCK((S.value)); }

/**
 * The scaling mode.
 *
 * @since This enum is available since SDL 3.2.0.
 */
using ScaleMode = SDL_ScaleMode;

#if SDL_VERSION_ATLEAST(3, 2, 10)

constexpr ScaleMode SCALEMODE_INVALID = SDL_SCALEMODE_INVALID; ///< INVALID

#endif // SDL_VERSION_ATLEAST(3, 2, 10)

constexpr ScaleMode SCALEMODE_NEAREST =
  SDL_SCALEMODE_NEAREST; ///< nearest pixel sampling

constexpr ScaleMode SCALEMODE_LINEAR =
  SDL_SCALEMODE_LINEAR; ///< linear filtering

/**
 * The flip mode.
 *
 * @since This enum is available since SDL 3.2.0.
 */
using FlipMode = SDL_FlipMode;

constexpr FlipMode FLIP_NONE = SDL_FLIP_NONE; ///< Do not flip.

constexpr FlipMode FLIP_HORIZONTAL = SDL_FLIP_HORIZONTAL; ///< flip horizontally

constexpr FlipMode FLIP_VERTICAL = SDL_FLIP_VERTICAL; ///< flip vertically

/**
 * A collection of pixels used in software blitting.
 *
 * Pixels are arranged in memory in rows, with the top row first. Each row
 * occupies an amount of memory given by the pitch (sometimes known as the row
 * stride in non-SDL APIs).
 *
 * Within each row, pixels are arranged from left to right until the width is
 * reached. Each pixel occupies a number of bits appropriate for its format,
 * with most formats representing each pixel as one or more whole bytes (in
 * some indexed formats, instead multiple pixels are packed into each byte),
 * and a byte order given by the format. After encoding all pixels, any
 * remaining bytes to reach the pitch are used as padding to reach a desired
 * alignment, and have undefined contents.
 *
 * When a surface holds YUV format data, the planes are assumed to be
 * contiguous without padding between them, e.g. a 32x32 surface in NV12
 * format with a pitch of 32 would consist of 32x32 bytes of Y plane followed
 * by 32x16 bytes of UV plane.
 *
 * When a surface holds MJPG format data, pixels points at the compressed JPEG
 * image and pitch is the length of that data.
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @cat resource
 *
 * @sa Surface.Surface
 * @sa Surface.Destroy
 */
class Surface
{
  SurfaceRaw m_resource = nullptr;

public:
  /// Default ctor
  constexpr Surface() = default;

  /**
   * Constructs from SurfaceParam.
   *
   * @param resource a SurfaceRaw to be wrapped.
   *
   * This assumes the ownership, call release() if you need to take back.
   */
  constexpr explicit Surface(const SurfaceRaw resource)
    : m_resource(resource)
  {
  }

  /// Copy constructor
  constexpr Surface(const Surface& other) { ++m_resource->refcount; }

  /// Move constructor
  constexpr Surface(Surface&& other)
    : Surface(other.release())
  {
  }

  /**
   * Allocate a new surface with a specific pixel format.
   *
   * The pixels of the new surface are initialized to zero.
   *
   * @param size the width and height of the surface.
   * @param format the PixelFormat for the new surface's pixel format.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.Surface
   * @sa Surface.Destroy
   */
  Surface(const PointRaw& size, PixelFormat format)
    : m_resource(CheckError(SDL_CreateSurface(size.x, size.y, format)))
  {
  }

  /**
   * Allocate a new surface with a specific pixel format and existing pixel
   * data.
   *
   * No copy is made of the pixel data. Pixel data is not managed automatically;
   * you must free the surface before you free the pixel data.
   *
   * Pitch is the offset in bytes from one row of pixels to the next, e.g.
   * `width*4` for `PIXELFORMAT_RGBA8888`.
   *
   * You may pass nullptr for pixels and 0 for pitch to create a surface that
   * you will fill in with valid values later.
   *
   * @param size the width and height of the surface.
   * @param format the PixelFormat for the new surface's pixel format.
   * @param pixels a pointer to existing pixel data.
   * @param pitch the number of bytes between each row, including padding.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.Surface
   * @sa Surface.Destroy
   */
  Surface(const PointRaw& size, PixelFormat format, void* pixels, int pitch)
    : m_resource(CheckError(
        SDL_CreateSurfaceFrom(size.x, size.y, format, pixels, pitch)))
  {
  }

  /**
   * Load an image from a filesystem path into a software surface.
   *
   * An Surface is a buffer of pixels in memory accessible by the CPU. Use
   * this if you plan to hand the data to something else or manipulate it
   * further in code.
   *
   * There are no guarantees about what format the new Surface data will be;
   * in many cases, SDL_image will attempt to supply a surface that exactly
   * matches the provided image, but in others it might have to convert (either
   * because the image is in a format that SDL doesn't directly support or
   * because it's compressed data that could reasonably uncompress to various
   * formats and SDL_image had to pick one). You can inspect an Surface for
   * its specifics, and use Surface.Convert to then migrate to any supported
   * format.
   *
   * If the image format supports a transparent pixel, SDL will set the colorkey
   * for the surface. You can enable RLE acceleration on the surface afterwards
   * by calling: Surface.SetColorKey(image, SDL_RLEACCEL,
   * image->format->colorkey);
   *
   * There is a separate function to read files from an IOStream, if you
   * need an i/o abstraction to provide data from anywhere instead of a simple
   * filesystem read; that function is Surface.Surface().
   *
   * If you are using SDL's 2D rendering API, there is an equivalent call to
   * load images directly into an Texture for use by the GPU without using a
   * software surface: call Texture.Texture() instead.
   *
   * @param file a path on the filesystem to load an image from.
   * @post a new SDL surface, or nullptr on error.
   *
   * @since This function is available since SDL_image 3.0.0.
   *
   * @sa LoadSurfaceTyped
   * @sa Surface.Surface
   * @sa Surface.Destroy
   */
  Surface(StringParam file);

  /**
   * Load an image from an SDL data source into a software surface.
   *
   * An Surface is a buffer of pixels in memory accessible by the CPU. Use
   * this if you plan to hand the data to something else or manipulate it
   * further in code.
   *
   * There are no guarantees about what format the new Surface data will be;
   * in many cases, SDL_image will attempt to supply a surface that exactly
   * matches the provided image, but in others it might have to convert (either
   * because the image is in a format that SDL doesn't directly support or
   * because it's compressed data that could reasonably uncompress to various
   * formats and SDL_image had to pick one). You can inspect an Surface for
   * its specifics, and use Surface.Convert to then migrate to any supported
   * format.
   *
   * If the image format supports a transparent pixel, SDL will set the colorkey
   * for the surface. You can enable RLE acceleration on the surface afterwards
   * by calling: Surface.SetColorKey(image, SDL_RLEACCEL,
   * image->format->colorkey);
   *
   * If `closeio` is true, `src` will be closed before returning, whether this
   * function succeeds or not. SDL_image reads everything it needs from `src`
   * during this call in any case.
   *
   * There is a separate function to read files from disk without having to deal
   * with IOStream: `Surface.Surface("filename.jpg")` will call this function
   * and manage those details for you, determining the file type from the
   * filename's extension.
   *
   * There is also LoadSurfaceTyped(), which is equivalent to this function
   * except a file extension (like "BMP", "JPG", etc) can be specified, in case
   * SDL_image cannot autodetect the file format.
   *
   * If you are using SDL's 2D rendering API, there is an equivalent call to
   * load images directly into an Texture for use by the GPU without using a
   * software surface: call Texture.Texture() instead.
   *
   * @param src an IOStream that data will be read from.
   * @param closeio true to close/free the IOStream before returning, false
   *                to leave it open.
   * @post a new SDL surface, or nullptr on error.
   *
   * @since This function is available since SDL_image 3.0.0.
   *
   * @sa Surface.Surface
   * @sa LoadSurfaceTyped
   * @sa Surface.Destroy
   */
  Surface(IOStreamParam src, bool closeio = false);

  /**
   * Safely borrows the from SurfaceParam.
   *
   * @param resource a SurfaceRaw or Surface.
   *
   * This does not takes ownership!
   */
  static constexpr Surface Borrow(SurfaceParam resource)
  {
    ++resource.value->refcount;
    return Surface(resource.value);
  }

  /**
   * Load a BMP image from a seekable SDL data stream.
   *
   * The new surface should be freed with Surface.Destroy(). Not doing so
   * will result in a memory leak.
   *
   * @param src the data stream for the surface.
   * @param closeio if true, calls IOStream.Close() on `src` before returning,
   * even in the case of an error.
   * @returns a pointer to a new Surface structure or nullptr on failure; call
   *          GetError() for more information.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.Destroy
   * @sa Surface.LoadBMP
   * @sa Surface.SaveBMP
   */
  static Surface LoadBMP(IOStreamParam src, bool closeio = false);

  /**
   * Load a BMP image from a file.
   *
   * The new surface should be freed with Surface.Destroy(). Not doing so
   * will result in a memory leak.
   *
   * @param file the BMP file to load.
   * @returns a pointer to a new Surface structure or nullptr on failure; call
   *          GetError() for more information.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.Destroy
   * @sa Surface.LoadBMP
   * @sa Surface.SaveBMP
   */
  static Surface LoadBMP(StringParam file);

  /// Destructor
  ~Surface() { SDL_DestroySurface(m_resource); }

  /// Assignment operator.
  Surface& operator=(Surface other)
  {
    std::swap(m_resource, other.m_resource);
    return *this;
  }

  /// Retrieves underlying SurfaceRaw.
  constexpr SurfaceRaw get() const { return m_resource; }

  /// Retrieves underlying SurfaceRaw and clear this.
  constexpr SurfaceRaw release()
  {
    auto r = m_resource;
    m_resource = nullptr;
    return r;
  }

  /// Comparison
  constexpr auto operator<=>(const Surface& other) const = default;

  /// Comparison
  constexpr bool operator==(std::nullptr_t _) const { return !m_resource; }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!m_resource; }

  /// Converts to SurfaceParam
  constexpr operator SurfaceParam() const { return {m_resource}; }

  /**
   * Free a surface.
   *
   * It is safe to pass nullptr to this function.
   *
   *
   * @threadsafety No other thread should be using the surface when it is freed.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.Surface
   * @sa Surface.Surface
   */
  void Destroy();

  /**
   * Get the properties associated with a surface.
   *
   * The following properties are understood by SDL:
   *
   * - `prop::Surface.SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point
   *   surfaces, this defines the value of 100% diffuse white, with higher
   *   values being displayed in the High Dynamic Range headroom. This defaults
   *   to 203 for HDR10 surfaces and 1.0 for floating point surfaces.
   * - `prop::Surface.HDR_HEADROOM_FLOAT`: for HDR10 and floating point
   *   surfaces, this defines the maximum dynamic range used by the content, in
   *   terms of the SDR white point. This defaults to 0.0, which disables tone
   *   mapping.
   * - `prop::Surface.TONEMAP_OPERATOR_STRING`: the tone mapping operator
   *   used when compressing from a surface with high dynamic range to another
   *   with lower dynamic range. Currently this supports "chrome", which uses
   *   the same tone mapping that Chrome uses for HDR content, the form "*=N",
   *   where N is a floating point scale factor applied in linear space, and
   *   "none", which disables tone mapping. This defaults to "chrome".
   * - `prop::Surface.HOTSPOT_X_NUMBER`: the hotspot pixel offset from the
   *   left edge of the image, if this surface is being used as a cursor.
   * - `prop::Surface.HOTSPOT_Y_NUMBER`: the hotspot pixel offset from the
   *   top edge of the image, if this surface is being used as a cursor.
   *
   * @returns a valid property ID on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  PropertiesRef GetProperties() const;

  /**
   * Set the colorspace used by a surface.
   *
   * Setting the colorspace doesn't change the pixels, only how they are
   * interpreted in color operations.
   *
   * @param colorspace a Colorspace value describing the surface colorspace.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.GetColorspace
   */
  void SetColorspace(Colorspace colorspace);

  /**
   * Get the colorspace used by a surface.
   *
   * The colorspace defaults to COLORSPACE_SRGB_LINEAR for floating point
   * formats, COLORSPACE_HDR10 for 10-bit formats, COLORSPACE_SRGB for
   * other RGB surfaces and COLORSPACE_BT709_FULL for YUV textures.
   *
   * @returns the colorspace used by the surface, or COLORSPACE_UNKNOWN if
   *          the surface is nullptr.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.SetColorspace
   */
  Colorspace GetColorspace() const;

  /**
   * Create a palette and associate it with a surface.
   *
   * This function creates a palette compatible with the provided surface. The
   * palette is then returned for you to modify, and the surface will
   * automatically use the new palette in future operations. You do not need to
   * destroy the returned palette, it will be freed when the reference count
   * reaches 0, usually when the surface is destroyed.
   *
   * Bitmap surfaces (with format PIXELFORMAT_INDEX1LSB or
   * PIXELFORMAT_INDEX1MSB) will have the palette initialized with 0 as
   * white and 1 as black. Other surfaces will get a palette initialized with
   * white in every entry.
   *
   * If this function is called for a surface that already has a palette, a new
   * palette will be created to replace it.
   *
   * @returns a new Palette structure on success.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Palette.SetColors
   */
  Palette CreatePalette();

  /**
   * Set the palette used by a surface.
   *
   * A single palette can be shared with many surfaces.
   *
   * @param palette the Palette structure to use.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Palette.Palette
   * @sa Surface.GetPalette
   */
  void SetPalette(PaletteParam palette);

  /**
   * Get the palette used by a surface.
   *
   * @returns a pointer to the palette used by the surface, or nullptr if there
   * is no palette used.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.SetPalette
   */
  Palette GetPalette() const;

  /**
   * Add an alternate version of a surface.
   *
   * This function adds an alternate version of this surface, usually used for
   * content with high DPI representations like cursors or icons. The size,
   * format, and content do not need to match the original surface, and these
   * alternate versions will not be updated when the original surface changes.
   *
   * This function adds a reference to the alternate version, so you should call
   * Surface.Destroy() on the image after this call.
   *
   * @param image an alternate Surface to associate with this surface.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.RemoveAlternateImages
   * @sa Surface.GetImages
   * @sa Surface.HasAlternateImages
   */
  void AddAlternateImage(SurfaceParam image);

  /**
   * Return whether a surface has alternate versions available.
   *
   * @returns true if alternate versions are available or false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.AddAlternateImage
   * @sa Surface.RemoveAlternateImages
   * @sa Surface.GetImages
   */
  bool HasAlternateImages() const;

  /**
   * Get an array including all versions of a surface.
   *
   * This returns all versions of a surface, with the surface being queried as
   * the first element in the returned array.
   *
   * @returns a nullptr terminated array of Surface pointers or nullptr on
   *          failure; call GetError() for more information.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.AddAlternateImage
   * @sa Surface.RemoveAlternateImages
   * @sa Surface.HasAlternateImages
   */
  OwnArray<SurfaceRaw> GetImages() const;

  /**
   * Remove all alternate versions of a surface.
   *
   * This function removes a reference from all the alternative versions,
   * destroying them if this is the last reference to them.
   *
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.AddAlternateImage
   * @sa Surface.GetImages
   * @sa Surface.HasAlternateImages
   */
  void RemoveAlternateImages();

  /**
   * Evaluates to true if the surface needs to be locked before access.
   *
   * @since This function is available since SDL 3.2.0.
   */
  constexpr bool MustLock() const;

  /**
   * Set up a surface for directly accessing the pixels.
   *
   * Between calls to Surface.Lock() / Surface.Unlock(), you can write to
   * and read from `surface->pixels`, using the pixel format stored in
   * `surface->format`. Once you are done accessing the surface, you should use
   * Surface.Unlock() to release it.
   *
   * Not all surfaces require locking. If `Surface.MustLock()` evaluates to
   * false, then you can read and write to the surface at any time, and the
   * pixel format of the surface will not change.
   *
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe. The locking referred to by
   *               this function is making the pixels available for direct
   *               access, not thread-safe locking.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.MustLock
   * @sa Surface.Unlock
   */
  void Lock();

  /**
   * Release a surface after directly accessing the pixels.
   *
   *
   * @threadsafety This function is not thread safe. The locking referred to by
   *               this function is making the pixels available for direct
   *               access, not thread-safe locking.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.Lock
   */
  void Unlock();

  /**
   * Save a surface to a seekable SDL data stream in BMP format.
   *
   * Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
   * BMP directly. Other RGB formats with 8-bit or higher get converted to a
   * 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
   * surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
   * not supported.
   *
   * @param dst a data stream to save to.
   * @param closeio if true, calls IOStream.Close() on `dst` before returning,
   * even in the case of an error.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.LoadBMP
   * @sa Surface.SaveBMP
   */
  void SaveBMP(IOStreamParam dst, bool closeio = false) const;

  /**
   * Save a surface to a file.
   *
   * Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
   * BMP directly. Other RGB formats with 8-bit or higher get converted to a
   * 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
   * surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
   * not supported.
   *
   * @param file a file to save to.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.LoadBMP
   * @sa Surface.SaveBMP
   */
  void SaveBMP(StringParam file) const;

  /**
   * Set the RLE acceleration hint for a surface.
   *
   * If RLE is enabled, color key and alpha blending blits are much faster, but
   * the surface must be locked before directly accessing the pixels.
   *
   * @param enabled true to enable RLE acceleration, false to disable it.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.Blit
   * @sa Surface.Lock
   * @sa Surface.Unlock
   */
  void SetRLE(bool enabled);

  /**
   * Returns whether the surface is RLE enabled.
   *
   * It is safe to pass a nullptr `surface` here; it will return false.
   *
   * @returns true if the surface is RLE enabled, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.SetRLE
   */
  bool HasRLE() const;

  /**
   * Set the color key (transparent pixel) in a surface.
   *
   * The color key defines a pixel value that will be treated as transparent in
   * a blit. For example, one can use this to specify that cyan pixels should be
   * considered transparent, and therefore not rendered.
   *
   * It is a pixel of the format used by the surface, as generated by
   * MapRGB().
   *
   * @param key the transparent pixel or std::nullopt to disable it.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.GetColorKey
   * @sa Surface.SetRLE
   * @sa Surface.HasColorKey
   */
  void SetColorKey(std::optional<Uint32> key);

  /**
   * Unset the color key (transparent pixel) in a surface.
   *
   * The color key defines a pixel value that will be treated as transparent in
   * a blit. For example, one can use this to specify that cyan pixels should be
   * considered transparent, and therefore not rendered.
   *
   * @throws Error on failure.
   */
  void ClearColorKey() { SetColorKey(std::nullopt); }

  /**
   * Returns whether the surface has a color key.
   *
   * @returns true if the surface has a color key, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.SetColorKey
   * @sa Surface.GetColorKey
   */
  bool HasColorKey() const;

  /**
   * Get the color key (transparent pixel) for a surface.
   *
   * The color key is a pixel of the format used by the surface, as generated by
   * MapRGB().
   *
   * If the surface doesn't have color key enabled this function returns false.
   *
   * @param key a pointer filled in with the transparent pixel.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.SetColorKey
   * @sa Surface.HasColorKey
   */
  std::optional<Uint32> GetColorKey() const;

  /**
   * Set an additional color value multiplied into blit operations.
   *
   * When this surface is blitted, during the blit operation each source color
   * channel is modulated by the appropriate color value according to the
   * following formula:
   *
   * `srcC = srcC * (color / 255)`
   *
   * @param r the red color value multiplied into blit operations.
   * @param g the green color value multiplied into blit operations.
   * @param b the blue color value multiplied into blit operations.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.GetColorMod
   * @sa Surface.SetAlphaMod
   */
  void SetColorMod(Uint8 r, Uint8 g, Uint8 b);

  /**
   * Get the additional color value multiplied into blit operations.
   *
   * @param r a pointer filled in with the current red color value.
   * @param g a pointer filled in with the current green color value.
   * @param b a pointer filled in with the current blue color value.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.GetAlphaMod
   * @sa Surface.SetColorMod
   */
  void GetColorMod(Uint8* r, Uint8* g, Uint8* b) const;

  /**
   * Set an additional alpha value used in blit operations.
   *
   * When this surface is blitted, during the blit operation the source alpha
   * value is modulated by this alpha value according to the following formula:
   *
   * `srcA = srcA * (alpha / 255)`
   *
   * @param alpha the alpha value multiplied into blit operations.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.GetAlphaMod
   * @sa Surface.SetColorMod
   */
  void SetAlphaMod(Uint8 alpha);

  /**
   * Get the additional alpha value used in blit operations.
   *
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.GetColorMod
   * @sa Surface.SetAlphaMod
   */
  Uint8 GetAlphaMod() const;

  /**
   * Set an additional color and alpha value multiplied into blit
   * operations.
   *
   * When this surface is blitted, during the blit operation each source color
   * channel is modulated by the appropriate color value according to the
   * following formula:
   *
   * `srcC = srcC * (color / 255)`
   * `srcA = srcA * (alpha / 255)`
   *
   * @param color the color to be multiplied in blit operations
   * @throws Error on failure.
   */
  void SetMod(Color color)
  {
    SetColorMod(color.r, color.g, color.b);
    SetAlphaMod(color.a);
  }

  /**
   * Get the additional color and alpha value multiplied into blit
   * operations.
   *
   * @returns a Color containing RGBA value on success or std::nullopt on
   * failure; call GetError() for more information.
   */
  Color GetMod() const
  {
    Color c;
    GetColorMod(&c.r, &c.g, &c.b);
    c.a = GetAlphaMod();
    return c;
  }

  /**
   * Set the blend mode used for blit operations.
   *
   * To copy a surface to another surface (or texture) without blending with the
   * existing data, the blendmode of the SOURCE surface should be set to
   * `BLENDMODE_NONE`.
   *
   * @param blendMode the BlendMode to use for blit blending.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.GetBlendMode
   */
  void SetBlendMode(BlendMode blendMode);

  /**
   * Get the blend mode used for blit operations.
   *
   * @param blendMode a pointer filled in with the current BlendMode.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.SetBlendMode
   */
  BlendMode GetBlendMode() const;

  /**
   * Set the clipping rectangle for a surface.
   *
   * When `surface` is the destination of a blit, only the area within the clip
   * rectangle is drawn into.
   *
   * Note that blits are automatically clipped to the edges of the source and
   * destination surfaces.
   *
   * @param rect the Rect structure representing the clipping rectangle, or
   *             nullptr to disable clipping.
   * @returns true if the rectangle intersects the surface, otherwise false and
   *          blits will be completely clipped.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.ResetClipRect()
   * @sa Surface.GetClipRect
   */
  bool SetClipRect(OptionalRef<const RectRaw> rect);

  /**
   * Disable the clipping rectangle for a surface.
   *
   * @sa SetClipRect()
   */
  void ResetClipRect() { SDL_SetSurfaceClipRect(m_resource, nullptr); }

  /**
   * Get the clipping rectangle for a surface.
   *
   * When `surface` is the destination of a blit, only the area within the clip
   * rectangle is drawn into.
   *
   * @returns the Rect structure filled in with the clipping rectangle for the
   *          surface on success.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.SetClipRect
   */
  Rect GetClipRect() const;

  /**
   * Flip a surface vertically or horizontally.
   *
   * @param flip the direction to flip.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void Flip(FlipMode flip);

  /**
   * Creates a new surface identical to the existing surface.
   *
   * If the original surface has alternate images, the new surface will have a
   * reference to them as well.
   *
   * @returns a copy of the surface or nullptr on failure; call GetError() for
   *          more information.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.Destroy
   */
  Surface Duplicate() const;

  /**
   * Creates a new surface identical to the existing surface, scaled to the
   * desired size.
   *
   * @param size the width and height of the new surface.
   * @param scaleMode the ScaleMode to be used.
   * @returns a copy of the surface or nullptr on failure; call GetError() for
   *          more information.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.Destroy
   */
  Surface Scale(const PointRaw& size, ScaleMode scaleMode) const;

  /**
   * Copy an existing surface to a new surface of the specified format.
   *
   * This function is used to optimize images for faster *repeat* blitting. This
   * is accomplished by converting the original and storing the result as a new
   * surface. The new, optimized surface can then be used as the source for
   * future blits, making them faster.
   *
   * If you are converting to an indexed surface and want to map colors to a
   * palette, you can use Surface.Convert() instead.
   *
   * If the original surface has alternate images, the new surface will have a
   * reference to them as well.
   *
   * @param format the new pixel format.
   * @returns the new Surface structure that is created or nullptr on failure;
   *          call GetError() for more information.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.Convert
   * @sa Surface.Destroy
   */
  Surface Convert(PixelFormat format) const;

  /**
   * Copy an existing surface to a new surface of the specified format and
   * colorspace.
   *
   * This function converts an existing surface to a new format and colorspace
   * and returns the new surface. This will perform any pixel format and
   * colorspace conversion needed.
   *
   * If the original surface has alternate images, the new surface will have a
   * reference to them as well.
   *
   * @param format the new pixel format.
   * @param palette an optional palette to use for indexed formats, may be
   * nullptr.
   * @param colorspace the new colorspace.
   * @param props an Properties with additional color properties, or 0.
   * @returns the new Surface structure that is created or nullptr on failure;
   *          call GetError() for more information.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.Convert
   * @sa Surface.Destroy
   */
  Surface Convert(PixelFormat format,
                  PaletteParam palette,
                  Colorspace colorspace,
                  PropertiesParam props) const;

  /**
   * Premultiply the alpha in a surface.
   *
   * This is safe to use with src == dst, but not for other overlapping areas.
   *
   * @param linear true to convert from sRGB to linear space for the alpha
   *               multiplication, false to do multiplication in sRGB space.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void PremultiplyAlpha(bool linear);

  /**
   * Clear a surface with a specific color, with floating point precision.
   *
   * This function handles all surface formats, and ignores any clip rectangle.
   *
   * If the surface is YUV, the color is assumed to be in the sRGB colorspace,
   * otherwise the color is assumed to be in the colorspace of the surface.
   *
   * @param c the color components of the pixel, normally in the range 0-1.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void Clear(const FColorRaw& color);

  /**
   * Perform a fast fill of a rectangle with a specific color.
   *
   * If there is a clip rectangle set on the destination (set via
   * Surface.SetClipRect()), then this function will fill based on the
   * intersection of the clip rectangle and `rect`.
   *
   * @param color the color to fill with.
   * @throws Error on failure.
   */
  void Fill(Uint32 color) { FillRect({}, color); }

  /**
   * Perform a fast fill of a rectangle with a specific color.
   *
   * `color` should be a pixel of the format used by the surface, and can be
   * generated by MapRGB() or MapRGBA(). If the color value contains an
   * alpha component then the destination is simply filled with that alpha
   * information, no blending takes place.
   *
   * If there is a clip rectangle set on the destination (set via
   * Surface.SetClipRect()), then this function will fill based on the
   * intersection of the clip rectangle and `rect`.
   *
   * @param rect the Rect structure representing the rectangle to fill, or
   *             nullptr to fill the entire surface.
   * @param color the color to fill with.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.FillRects
   */
  void FillRect(OptionalRef<const RectRaw> rect, Uint32 color);

  /**
   * Perform a fast fill of a set of rectangles with a specific color.
   *
   * `color` should be a pixel of the format used by the surface, and can be
   * generated by MapRGB() or MapRGBA(). If the color value contains an
   * alpha component then the destination is simply filled with that alpha
   * information, no blending takes place.
   *
   * If there is a clip rectangle set on the destination (set via
   * Surface.SetClipRect()), then this function will fill based on the
   * intersection of the clip rectangle and `rect`.
   *
   * @param rects an array of SDL_Rects representing the rectangles to fill.
   * @param color the color to fill with.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.FillRect
   */
  void FillRects(SpanRef<const RectRaw> rects, Uint32 color);

  /**
   * Performs a fast blit from the source surface to the destination surface
   * with clipping.
   *
   * If either `srcrect` or `dstrect` are nullptr, the entire surface (`src` or
   * `dst`) is copied while ensuring clipping to `dst->clip_rect`.
   *
   * The blit function should not be called on a locked surface.
   *
   * The blit semantics for surfaces with and without blending and colorkey are
   * defined as follows:
   *
   * ```
   *    RGBA->RGB:
   *      Source surface blend mode set to BLENDMODE_BLEND:
   *       alpha-blend (using the source alpha-channel and per-surface alpha)
   *       SDL_SRCCOLORKEY ignored.
   *     Source surface blend mode set to BLENDMODE_NONE:
   *       copy RGB.
   *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
   *       RGB values of the source color key, ignoring alpha in the
   *       comparison.
   *
   *   RGB->RGBA:
   *     Source surface blend mode set to BLENDMODE_BLEND:
   *       alpha-blend (using the source per-surface alpha)
   *     Source surface blend mode set to BLENDMODE_NONE:
   *       copy RGB, set destination alpha to source per-surface alpha value.
   *     both:
   *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
   *       source color key.
   *
   *   RGBA->RGBA:
   *     Source surface blend mode set to BLENDMODE_BLEND:
   *       alpha-blend (using the source alpha-channel and per-surface alpha)
   *       SDL_SRCCOLORKEY ignored.
   *     Source surface blend mode set to BLENDMODE_NONE:
   *       copy all of RGBA to the destination.
   *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
   *       RGB values of the source color key, ignoring alpha in the
   *       comparison.
   *
   *   RGB->RGB:
   *     Source surface blend mode set to BLENDMODE_BLEND:
   *       alpha-blend (using the source per-surface alpha)
   *     Source surface blend mode set to BLENDMODE_NONE:
   *       copy RGB.
   *     both:
   *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
   *       source color key.
   * ```
   *
   * @param src the SurfaceRaw structure to be copied from.
   * @param srcrect the Rect structure representing the rectangle to be
   *                copied, or nullptr to copy the entire surface.
   * @param dstrect the Rect structure representing the x and y position in
   *                the destination surface, or nullptr for (0,0). The width and
   *                height are ignored, and are copied from `srcrect`. If you
   *                want a specific width and height, you should use
   *                Surface.BlitScaled().
   * @throws Error on failure.
   *
   * @threadsafety Only one thread should be using the `src` and `dst` surfaces
   *               at any given time.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.BlitScaled
   */
  void Blit(SurfaceParam src,
            OptionalRef<const RectRaw> srcrect,
            OptionalRef<const RectRaw> dstrect);

  /**
   * Performs a fast blit from the source surface to the destination surface
   * with clipping.
   *
   * If either `srcrect` or `dstrect` are nullptr, the entire surface (`src` or
   * `dst`) is copied while ensuring clipping to `dst->clip_rect`.
   *
   * The blit function should not be called on a locked surface.
   *
   * The blit semantics for surfaces with and without blending and colorkey are
   * defined as follows:
   *
   * ```
   *    RGBA->RGB:
   *      Source surface blend mode set to BLENDMODE_BLEND:
   *       alpha-blend (using the source alpha-channel and per-surface alpha)
   *       SDL_SRCCOLORKEY ignored.
   *     Source surface blend mode set to BLENDMODE_NONE:
   *       copy RGB.
   *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
   *       RGB values of the source color key, ignoring alpha in the
   *       comparison.
   *
   *   RGB->RGBA:
   *     Source surface blend mode set to BLENDMODE_BLEND:
   *       alpha-blend (using the source per-surface alpha)
   *     Source surface blend mode set to BLENDMODE_NONE:
   *       copy RGB, set destination alpha to source per-surface alpha value.
   *     both:
   *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
   *       source color key.
   *
   *   RGBA->RGBA:
   *     Source surface blend mode set to BLENDMODE_BLEND:
   *       alpha-blend (using the source alpha-channel and per-surface alpha)
   *       SDL_SRCCOLORKEY ignored.
   *     Source surface blend mode set to BLENDMODE_NONE:
   *       copy all of RGBA to the destination.
   *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
   *       RGB values of the source color key, ignoring alpha in the
   *       comparison.
   *
   *   RGB->RGB:
   *     Source surface blend mode set to BLENDMODE_BLEND:
   *       alpha-blend (using the source per-surface alpha)
   *     Source surface blend mode set to BLENDMODE_NONE:
   *       copy RGB.
   *     both:
   *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
   *       source color key.
   * ```
   *
   * @param src the SurfaceRaw structure to be copied from.
   * @param srcrect the Rect structure representing the rectangle to be
   *                copied, or nullptr to copy the entire surface.
   * @param dstpos the Point structure representing the x and y position in
   *                the destination surface, or nullptr for (0,0). The width and
   *                height are ignored, and are copied from `srcrect`. If you
   *                want a specific width and height, you should use
   *                Surface.BlitScaled().
   * @throws Error on failure.
   *
   * @threadsafety Only one thread should be using the `src` and `dst` surfaces
   *               at any given time.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.Blit
   * @sa Surface.BlitScaled
   */
  void BlitAt(SurfaceParam src,
              OptionalRef<const RectRaw> srcrect,
              const PointRaw& dstpos)
  {
    Blit(src, srcrect, Rect{dstpos, {}});
  }

  /**
   * Perform low-level surface blitting only.
   *
   * This is a semi-private blit function and it performs low-level surface
   * blitting, assuming the input rectangles have already been clipped.
   *
   * @param src the Surface structure to be copied from.
   * @param srcrect the Rect structure representing the rectangle to be
   *                copied, may not be nullptr.
   * @param dstrect the Rect structure representing the target rectangle in
   *                the destination surface, may not be nullptr.
   * @throws Error on failure.
   *
   * @threadsafety Only one thread should be using the `src` and `dst` surfaces
   *               at any given time.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.Blit
   */
  void BlitUnchecked(SurfaceParam src,
                     const RectRaw& srcrect,
                     const RectRaw& dstrect);

  /**
   * Perform a scaled blit to a destination surface, which may be of a different
   * format.
   *
   * @param src the Surface structure to be copied from.
   * @param srcrect the Rect structure representing the rectangle to be
   *                copied, or nullptr to copy the entire surface.
   * @param dstrect the Rect structure representing the target rectangle in
   *                the destination surface, or nullptr to fill the entire
   *                destination surface.
   * @param scaleMode the ScaleMode to be used.
   * @throws Error on failure.
   *
   * @threadsafety Only one thread should be using the `src` and `dst` surfaces
   *               at any given time.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.Blit
   */
  void BlitScaled(SurfaceParam src,
                  OptionalRef<const RectRaw> srcrect,
                  OptionalRef<const RectRaw> dstrect,
                  ScaleMode scaleMode);

  /**
   * Perform low-level surface scaled blitting only.
   *
   * This is a semi-private function and it performs low-level surface blitting,
   * assuming the input rectangles have already been clipped.
   *
   * @param src the Surface structure to be copied from.
   * @param srcrect the Rect structure representing the rectangle to be
   *                copied, may not be nullptr.
   * @param dstrect the Rect structure representing the target rectangle in
   *                the destination surface, may not be nullptr.
   * @param scaleMode the ScaleMode to be used.
   * @throws Error on failure.
   *
   * @threadsafety Only one thread should be using the `src` and `dst` surfaces
   *               at any given time.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.BlitScaled
   */
  void BlitUncheckedScaled(SurfaceParam src,
                           const RectRaw& srcrect,
                           const RectRaw& dstrect,
                           ScaleMode scaleMode);

#if SDL_VERSION_ATLEAST(3, 2, 4)

  /**
   * Perform a stretched pixel copy from one surface to another.
   *
   * @param src the Surface structure to be copied from.
   * @param srcrect the Rect structure representing the rectangle to be
   *                copied, or nullptr to copy the entire surface.
   * @param dstrect the Rect structure representing the target rectangle in
   *                the destination surface, or nullptr to fill the entire
   *                destination surface.
   * @param scaleMode the ScaleMode to be used.
   * @throws Error on failure.
   *
   * @threadsafety Only one thread should be using the `src` and `dst` surfaces
   *               at any given time.
   *
   * @since This function is available since SDL 3.2.4.
   *
   * @sa Surface.BlitScaled
   */
  void Stretch(SurfaceParam src,
               OptionalRef<RectRaw> srcrect,
               OptionalRef<RectRaw> dstrect,
               ScaleMode scaleMode);

#endif // SDL_VERSION_ATLEAST(3, 2, 4)

  /**
   * Perform a tiled blit to a destination surface, which may be of a different
   * format.
   *
   * The pixels in `srcrect` will be repeated as many times as needed to
   * completely fill `dstrect`.
   *
   * @param src the SDL_Surface structure to be copied from.
   * @param srcrect the Rect structure representing the rectangle to be
   *                copied, or nullptr to copy the entire surface.
   * @param dstrect the Rect structure representing the target rectangle in
   *                the destination surface, or nullptr to fill the entire
   * surface.
   * @throws Error on failure.
   *
   * @threadsafety Only one thread should be using the `src` and `dst` surfaces
   *               at any given time.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.Blit
   */
  void BlitTiled(SurfaceParam src,
                 OptionalRef<const RectRaw> srcrect,
                 OptionalRef<const RectRaw> dstrect);

  /**
   * Perform a scaled and tiled blit to a destination surface, which may be of a
   * different format.
   *
   * The pixels in `srcrect` will be scaled and repeated as many times as needed
   * to completely fill `dstrect`.
   *
   * @param src the SDL_Surface structure to be copied from.
   * @param srcrect the Rect structure representing the rectangle to be
   *                copied, or nullptr to copy the entire surface.
   * @param scale the scale used to transform srcrect into the destination
   *              rectangle, e.g. a 32x32 texture with a scale of 2 would fill
   *              64x64 tiles.
   * @param scaleMode scale algorithm to be used.
   * @param dstrect the Rect structure representing the target rectangle in
   *                the destination surface, or nullptr to fill the entire
   * surface.
   * @throws Error on failure.
   *
   * @threadsafety Only one thread should be using the `src` and `dst` surfaces
   *               at any given time.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.Blit
   */
  void BlitTiledWithScale(SurfaceParam src,
                          OptionalRef<const RectRaw> srcrect,
                          float scale,
                          SDL_ScaleMode scaleMode,
                          OptionalRef<const RectRaw> dstrect);

  /**
   * Perform a scaled blit using the 9-grid algorithm to a destination surface,
   * which may be of a different format.
   *
   * The pixels in the source surface are split into a 3x3 grid, using the
   * different corner sizes for each corner, and the sides and center making up
   * the remaining pixels. The corners are then scaled using `scale` and fit
   * into the corners of the destination rectangle. The sides and center are
   * then stretched into place to cover the remaining destination rectangle.
   *
   * @param src the SDL_Surface structure to be copied from.
   * @param srcrect the Rect structure representing the rectangle to be used
   *                for the 9-grid, or nullptr to use the entire surface.
   * @param left_width the width, in pixels, of the left corners in `srcrect`.
   * @param right_width the width, in pixels, of the right corners in `srcrect`.
   * @param top_height the height, in pixels, of the top corners in `srcrect`.
   * @param bottom_height the height, in pixels, of the bottom corners in
   *                      `srcrect`.
   * @param dstrect the Rect structure representing the target rectangle in
   *                the destination surface, or nullptr to fill the entire
   * surface.
   * @throws Error on failure.
   *
   * @threadsafety Only one thread should be using the `src` and `dst` surfaces
   *               at any given time.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.Blit
   */
  void Blit9Grid(SurfaceParam src,
                 OptionalRef<const RectRaw> srcrect,
                 int left_width,
                 int right_width,
                 int top_height,
                 int bottom_height,
                 OptionalRef<const RectRaw> dstrect)
  {
    Blit9GridWithScale(src,
                       srcrect,
                       left_width,
                       right_width,
                       top_height,
                       bottom_height,
                       0.0,
                       SDL_SCALEMODE_NEAREST,
                       dstrect);
  }

  /**
   * Perform a scaled blit using the 9-grid algorithm to a destination surface,
   * which may be of a different format.
   *
   * The pixels in the source surface are split into a 3x3 grid, using the
   * different corner sizes for each corner, and the sides and center making up
   * the remaining pixels. The corners are then scaled using `scale` and fit
   * into the corners of the destination rectangle. The sides and center are
   * then stretched into place to cover the remaining destination rectangle.
   *
   * @param src the SDL_Surface structure to be copied from.
   * @param srcrect the Rect structure representing the rectangle to be used
   *                for the 9-grid, or nullptr to use the entire surface.
   * @param left_width the width, in pixels, of the left corners in `srcrect`.
   * @param right_width the width, in pixels, of the right corners in `srcrect`.
   * @param top_height the height, in pixels, of the top corners in `srcrect`.
   * @param bottom_height the height, in pixels, of the bottom corners in
   *                      `srcrect`.
   * @param scale the scale used to transform the corner of `srcrect` into the
   *              corner of `dstrect`, or 0.0f for an unscaled blit.
   * @param scaleMode scale algorithm to be used.
   * @param dstrect the Rect structure representing the target rectangle in
   *                the destination surface, or nullptr to fill the entire
   * surface.
   * @throws Error on failure.
   *
   * @threadsafety Only one thread should be using the `src` and `dst` surfaces
   *               at any given time.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.Blit
   */
  void Blit9GridWithScale(SurfaceParam src,
                          OptionalRef<const RectRaw> srcrect,
                          int left_width,
                          int right_width,
                          int top_height,
                          int bottom_height,
                          float scale,
                          SDL_ScaleMode scaleMode,
                          OptionalRef<const RectRaw> dstrect);

  /**
   * Map an RGB triple to an opaque pixel value for a surface.
   *
   * This function maps the RGB color value to the specified pixel format and
   * returns the pixel value best approximating the given RGB color value for
   * the given pixel format.
   *
   * If the surface has a palette, the index of the closest matching color in
   * the palette will be returned.
   *
   * If the surface pixel format has an alpha component it will be returned as
   * all 1 bits (fully opaque).
   *
   * If the pixel format bpp (color depth) is less than 32-bpp then the unused
   * upper bits of the return value can safely be ignored (e.g., with a 16-bpp
   * format the return value can be assigned to a Uint16, and similarly a Uint8
   * for an 8-bpp format).
   *
   * @param r the red component of the pixel in the range 0-255.
   * @param g the green component of the pixel in the range 0-255.
   * @param b the blue component of the pixel in the range 0-255.
   * @returns a pixel value.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.MapRGBA
   */
  Uint32 MapRGB(Uint8 r, Uint8 g, Uint8 b) const;

  /**
   * Map an RGBA quadruple to a pixel value for a surface.
   *
   * This function maps the RGBA color value to the specified pixel format and
   * returns the pixel value best approximating the given RGBA color value for
   * the given pixel format.
   *
   * If the surface pixel format has no alpha component the alpha value will be
   * ignored (as it will be in formats with a palette).
   *
   * If the surface has a palette, the index of the closest matching color in
   * the palette will be returned.
   *
   * If the pixel format bpp (color depth) is less than 32-bpp then the unused
   * upper bits of the return value can safely be ignored (e.g., with a 16-bpp
   * format the return value can be assigned to a Uint16, and similarly a Uint8
   * for an 8-bpp format).
   *
   * @param c the color components of the pixel in the range 0-255.
   * @returns a pixel value.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Surface.MapRGB
   */
  Uint32 MapRGBA(ColorRaw c) const;

  /**
   * This function prioritizes correctness over speed: it is suitable for
   * unit tests, but is not intended for use in a game engine.
   *
   * Like SDL_GetRGBA, this uses the entire 0..255 range when converting color
   * components from pixel formats with less than 8 bits per RGB component.
   *
   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
   * @returns color on success.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   */
  Color ReadPixel(const PointRaw& p) const
  {
    Color c;
    ReadPixel(p, &c.r, &c.g, &c.b, &c.a);
    return c;
  }

  /**
   * Retrieves a single pixel from a surface.
   *
   * This function prioritizes correctness over speed: it is suitable for unit
   * tests, but is not intended for use in a game engine.
   *
   * Like GetRGBA, this uses the entire 0..255 range when converting color
   * components from pixel formats with less than 8 bits per RGB component.
   *
   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
   * @param r a pointer filled in with the red channel, 0-255, or nullptr to
   * ignore this channel.
   * @param g a pointer filled in with the green channel, 0-255, or nullptr to
   *          ignore this channel.
   * @param b a pointer filled in with the blue channel, 0-255, or nullptr to
   *          ignore this channel.
   * @param a a pointer filled in with the alpha channel, 0-255, or nullptr to
   *          ignore this channel.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void ReadPixel(const PointRaw& p,
                 Uint8* r,
                 Uint8* g,
                 Uint8* b,
                 Uint8* a) const;

  /**
   * Retrieves a single pixel from a surface.
   *
   * This function prioritizes correctness over speed: it is suitable for unit
   * tests, but is not intended for use in a game engine.
   *
   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
   * @returns color on success.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   */
  FColor ReadPixelFloat(const PointRaw& p) const
  {
    FColor c;
    ReadPixelFloat(p, &c.r, &c.g, &c.b, &c.a);
    return c;
  }

  /**
   * Retrieves a single pixel from a surface.
   *
   * This function prioritizes correctness over speed: it is suitable for unit
   * tests, but is not intended for use in a game engine.
   *
   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
   * @param r a pointer filled in with the red channel, normally in the range
   *          0-1, or nullptr to ignore this channel.
   * @param g a pointer filled in with the green channel, normally in the range
   *          0-1, or nullptr to ignore this channel.
   * @param b a pointer filled in with the blue channel, normally in the range
   *          0-1, or nullptr to ignore this channel.
   * @param a a pointer filled in with the alpha channel, normally in the range
   *          0-1, or nullptr to ignore this channel.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void ReadPixelFloat(const PointRaw& p,
                      float* r,
                      float* g,
                      float* b,
                      float* a) const;

  /**
   * Writes a single pixel to a surface.
   *
   * This function prioritizes correctness over speed: it is suitable for unit
   * tests, but is not intended for use in a game engine.
   *
   * Like MapRGBA, this uses the entire 0..255 range when converting color
   * components from pixel formats with less than 8 bits per RGB component.
   *
   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
   * @param c the color values, 0-255.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void WritePixel(const PointRaw& p, ColorRaw c);

  /**
   * Writes a single pixel to a surface.
   *
   * This function prioritizes correctness over speed: it is suitable for unit
   * tests, but is not intended for use in a game engine.
   *
   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
   * @param c the color values, normally in the range 0-1.
   * @throws Error on failure.
   *
   * @threadsafety This function is not thread safe.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void WritePixelFloat(const PointRaw& p, const FColorRaw& c);

  /**
   * Get the width in pixels.
   */
  constexpr int GetWidth() const { return m_resource->w; }

  /**
   * Get the height in pixels.
   */
  constexpr int GetHeight() const { return m_resource->h; }

  /**
   * Get the size in pixels.
   */
  constexpr Point GetSize() const { return Point(GetWidth(), GetHeight()); }

  /**
   * Get pitch in bytes.
   */
  constexpr int GetPitch() const { return m_resource->pitch; }

  /**
   * Get the pixel format.
   */
  constexpr PixelFormat GetFormat() const { return m_resource->format; }

  /**
   * Get the pixels.
   */
  constexpr void* GetPixels() const { return m_resource->pixels; }
};

/**
 * Allocate a new surface with a specific pixel format.
 *
 * The pixels of the new surface are initialized to zero.
 *
 * @param size the width and height of the surface.
 * @param format the PixelFormat for the new surface's pixel format.
 * @returns the new Surface structure that is created or nullptr on failure;
 *          call GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.Surface
 * @sa Surface.Destroy
 */
inline Surface CreateSurface(const PointRaw& size, PixelFormat format)
{
  return Surface(size, format);
}

/**
 * Allocate a new surface with a specific pixel format and existing pixel
 * data.
 *
 * No copy is made of the pixel data. Pixel data is not managed automatically;
 * you must free the surface before you free the pixel data.
 *
 * Pitch is the offset in bytes from one row of pixels to the next, e.g.
 * `width*4` for `PIXELFORMAT_RGBA8888`.
 *
 * You may pass nullptr for pixels and 0 for pitch to create a surface that you
 * will fill in with valid values later.
 *
 * @param size the width and height of the surface.
 * @param format the PixelFormat for the new surface's pixel format.
 * @param pixels a pointer to existing pixel data.
 * @param pitch the number of bytes between each row, including padding.
 * @returns the new Surface structure that is created or nullptr on failure;
 *          call GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.Surface
 * @sa Surface.Destroy
 */
inline Surface CreateSurfaceFrom(const PointRaw& size,
                                 PixelFormat format,
                                 void* pixels,
                                 int pitch)
{
  return Surface(size, format, pixels, pitch);
}

/**
 * Free a surface.
 *
 * It is safe to pass nullptr to this function.
 *
 * @param surface the Surface to free.
 *
 * @threadsafety No other thread should be using the surface when it is freed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.Surface
 * @sa Surface.Surface
 */
inline void DestroySurface(SurfaceRaw surface) { SDL_DestroySurface(surface); }

inline void Surface::Destroy()
{
  SDL_DestroySurface(m_resource);
  m_resource = nullptr;
}

/**
 * Get the properties associated with a surface.
 *
 * The following properties are understood by SDL:
 *
 * - `prop::Surface.SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point
 *   surfaces, this defines the value of 100% diffuse white, with higher
 *   values being displayed in the High Dynamic Range headroom. This defaults
 *   to 203 for HDR10 surfaces and 1.0 for floating point surfaces.
 * - `prop::Surface.HDR_HEADROOM_FLOAT`: for HDR10 and floating point
 *   surfaces, this defines the maximum dynamic range used by the content, in
 *   terms of the SDR white point. This defaults to 0.0, which disables tone
 *   mapping.
 * - `prop::Surface.TONEMAP_OPERATOR_STRING`: the tone mapping operator
 *   used when compressing from a surface with high dynamic range to another
 *   with lower dynamic range. Currently this supports "chrome", which uses
 *   the same tone mapping that Chrome uses for HDR content, the form "*=N",
 *   where N is a floating point scale factor applied in linear space, and
 *   "none", which disables tone mapping. This defaults to "chrome".
 * - `prop::Surface.HOTSPOT_X_NUMBER`: the hotspot pixel offset from the
 *   left edge of the image, if this surface is being used as a cursor.
 * - `prop::Surface.HOTSPOT_Y_NUMBER`: the hotspot pixel offset from the
 *   top edge of the image, if this surface is being used as a cursor.
 *
 * @param surface the Surface structure to query.
 * @returns a valid property ID on success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline PropertiesRef GetSurfaceProperties(SurfaceConstParam surface)
{
  return {CheckError(SDL_GetSurfaceProperties(surface))};
}

inline PropertiesRef Surface::GetProperties() const
{
  return SDL::GetSurfaceProperties(m_resource);
}

namespace prop::Surface {

constexpr auto SDR_WHITE_POINT_FLOAT = SDL_PROP_SURFACE_SDR_WHITE_POINT_FLOAT;

constexpr auto HDR_HEADROOM_FLOAT = SDL_PROP_SURFACE_HDR_HEADROOM_FLOAT;

constexpr auto TONEMAP_OPERATOR_STRING =
  SDL_PROP_SURFACE_TONEMAP_OPERATOR_STRING;

#if SDL_VERSION_ATLEAST(3, 2, 6)

constexpr auto HOTSPOT_X_NUMBER = SDL_PROP_SURFACE_HOTSPOT_X_NUMBER;

constexpr auto HOTSPOT_Y_NUMBER = SDL_PROP_SURFACE_HOTSPOT_Y_NUMBER;

#endif // SDL_VERSION_ATLEAST(3, 2, 6)

} // namespace prop::Surface

/**
 * Set the colorspace used by a surface.
 *
 * Setting the colorspace doesn't change the pixels, only how they are
 * interpreted in color operations.
 *
 * @param surface the Surface structure to update.
 * @param colorspace an Colorspace value describing the surface
 *                   colorspace.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.GetColorspace
 */
inline void SetSurfaceColorspace(SurfaceParam surface, Colorspace colorspace)
{
  CheckError(SDL_SetSurfaceColorspace(surface, colorspace));
}

inline void Surface::SetColorspace(Colorspace colorspace)
{
  SDL::SetSurfaceColorspace(m_resource, colorspace);
}

/**
 * Get the colorspace used by a surface.
 *
 * The colorspace defaults to COLORSPACE_SRGB_LINEAR for floating point
 * formats, COLORSPACE_HDR10 for 10-bit formats, COLORSPACE_SRGB for
 * other RGB surfaces and COLORSPACE_BT709_FULL for YUV textures.
 *
 * @param surface the Surface structure to query.
 * @returns the colorspace used by the surface, or COLORSPACE_UNKNOWN if
 *          the surface is nullptr.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.SetColorspace
 */
inline Colorspace GetSurfaceColorspace(SurfaceConstParam surface)
{
  return SDL_GetSurfaceColorspace(surface);
}

inline Colorspace Surface::GetColorspace() const
{
  return SDL::GetSurfaceColorspace(m_resource);
}

/**
 * Create a palette and associate it with a surface.
 *
 * This function creates a palette compatible with the provided surface. The
 * palette is then returned for you to modify, and the surface will
 * automatically use the new palette in future operations. You do not need to
 * destroy the returned palette, it will be freed when the reference count
 * reaches 0, usually when the surface is destroyed.
 *
 * Bitmap surfaces (with format PIXELFORMAT_INDEX1LSB or
 * PIXELFORMAT_INDEX1MSB) will have the palette initialized with 0 as
 * white and 1 as black. Other surfaces will get a palette initialized with
 * white in every entry.
 *
 * If this function is called for a surface that already has a palette, a new
 * palette will be created to replace it.
 *
 * @param surface the Surface structure to update.
 * @returns a new Palette structure on success.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Palette.SetColors
 */
inline Palette CreateSurfacePalette(SurfaceParam surface)
{
  return Palette::Borrow(CheckError(SDL_CreateSurfacePalette(surface)));
}

inline Palette Surface::CreatePalette()
{
  return SDL::CreateSurfacePalette(m_resource);
}

/**
 * Set the palette used by a surface.
 *
 * A single palette can be shared with many surfaces.
 *
 * @param surface the Surface structure to update.
 * @param palette the Palette structure to use.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Palette.Palette
 * @sa Surface.GetPalette
 */
inline void SetSurfacePalette(SurfaceParam surface, PaletteParam palette)
{
  CheckError(SDL_SetSurfacePalette(surface, palette));
}

inline void Surface::SetPalette(PaletteParam palette)
{
  SDL::SetSurfacePalette(m_resource, palette);
}

/**
 * Get the palette used by a surface.
 *
 * @param surface the Surface structure to query.
 * @returns a pointer to the palette used by the surface, or nullptr if there is
 *          no palette used.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.SetPalette
 */
inline Palette GetSurfacePalette(SurfaceConstParam surface)
{
  return Palette::Borrow(SDL_GetSurfacePalette(surface));
}

inline Palette Surface::GetPalette() const
{
  return SDL::GetSurfacePalette(m_resource);
}

/**
 * Add an alternate version of a surface.
 *
 * This function adds an alternate version of this surface, usually used for
 * content with high DPI representations like cursors or icons. The size,
 * format, and content do not need to match the original surface, and these
 * alternate versions will not be updated when the original surface changes.
 *
 * This function adds a reference to the alternate version, so you should call
 * Surface.Destroy() on the image after this call.
 *
 * @param surface the Surface structure to update.
 * @param image a pointer to an alternate Surface to associate with this
 *              surface.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.RemoveAlternateImages
 * @sa Surface.GetImages
 * @sa Surface.HasAlternateImages
 */
inline void AddSurfaceAlternateImage(SurfaceParam surface, SurfaceParam image)
{
  CheckError(SDL_AddSurfaceAlternateImage(surface, image));
}

inline void Surface::AddAlternateImage(SurfaceParam image)
{
  SDL::AddSurfaceAlternateImage(m_resource, image);
}

/**
 * Return whether a surface has alternate versions available.
 *
 * @param surface the Surface structure to query.
 * @returns true if alternate versions are available or false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.AddAlternateImage
 * @sa Surface.RemoveAlternateImages
 * @sa Surface.GetImages
 */
inline bool SurfaceHasAlternateImages(SurfaceConstParam surface)
{
  return SDL_SurfaceHasAlternateImages(surface);
}

inline bool Surface::HasAlternateImages() const
{
  return SDL::SurfaceHasAlternateImages(m_resource);
}

/**
 * Get an array including all versions of a surface.
 *
 * This returns all versions of a surface, with the surface being queried as
 * the first element in the returned array.
 *
 * Freeing the array of surfaces does not affect the surfaces in the array.
 * They are still referenced by the surface being queried and will be cleaned
 * up normally.
 *
 * @param surface the Surface structure to query.
 * @param count a pointer filled in with the number of surface pointers
 *              returned, may be nullptr.
 * @returns a nullptr terminated array of Surface pointers or nullptr on
 *          failure; call GetError() for more information. This should be
 *          freed with free() when it is no longer needed.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.AddAlternateImage
 * @sa Surface.RemoveAlternateImages
 * @sa Surface.HasAlternateImages
 */
inline OwnArray<SurfaceRaw> GetSurfaceImages(SurfaceConstParam surface)
{
  int count = 0;
  auto data = SDL_GetSurfaceImages(surface, &count);
  return OwnArray<SurfaceRaw>(CheckError(data), count);
}

inline OwnArray<SurfaceRaw> Surface::GetImages() const
{
  return SDL::GetSurfaceImages(m_resource);
}

/**
 * Remove all alternate versions of a surface.
 *
 * This function removes a reference from all the alternative versions,
 * destroying them if this is the last reference to them.
 *
 * @param surface the Surface structure to update.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.AddAlternateImage
 * @sa Surface.GetImages
 * @sa Surface.HasAlternateImages
 */
inline void RemoveSurfaceAlternateImages(SurfaceParam surface)
{
  SDL_RemoveSurfaceAlternateImages(surface);
}

inline void Surface::RemoveAlternateImages()
{
  SDL::RemoveSurfaceAlternateImages(m_resource);
}

/**
 * Set up a surface for directly accessing the pixels.
 *
 * Between calls to Surface.Lock() / Surface.Unlock(), you can write to
 * and read from `surface->pixels`, using the pixel format stored in
 * `surface->format`. Once you are done accessing the surface, you should use
 * Surface.Unlock() to release it.
 *
 * Not all surfaces require locking. If `Surface.MustLock()` evaluates to
 * 0, then you can read and write to the surface at any time, and the pixel
 * format of the surface will not change.
 *
 * @param surface the Surface structure to be locked.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe. The locking referred to by
 *               this function is making the pixels available for direct
 *               access, not thread-safe locking.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.MustLock
 * @sa Surface.Unlock
 */
inline void LockSurface(SurfaceParam surface)
{
  CheckError(SDL_LockSurface(surface));
}

inline void Surface::Lock() { SDL::LockSurface(m_resource); }

/**
 * Release a surface after directly accessing the pixels.
 *
 * @param surface the Surface structure to be unlocked.
 *
 * @threadsafety This function is not thread safe. The locking referred to by
 *               this function is making the pixels available for direct
 *               access, not thread-safe locking.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.Lock
 */
inline void UnlockSurface(SurfaceParam surface) { SDL_UnlockSurface(surface); }

inline void Surface::Unlock() { SDL::UnlockSurface(m_resource); }

/**
 * Load a BMP image from a seekable SDL data stream.
 *
 * The new surface should be freed with Surface.Destroy(). Not doing so
 * will result in a memory leak.
 *
 * @param src the data stream for the surface.
 * @param closeio if true, calls IOStream.Close() on `src` before returning,
 * even in the case of an error.
 * @returns a pointer to a new Surface structure or nullptr on failure; call
 *          GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.Destroy
 * @sa Surface.LoadBMP
 * @sa Surface.SaveBMP
 */
inline Surface LoadBMP(IOStreamParam src, bool closeio = false)
{
  return Surface(SDL_LoadBMP_IO(src, closeio));
}

/**
 * Load a BMP image from a file.
 *
 * The new surface should be freed with Surface.Destroy(). Not doing so
 * will result in a memory leak.
 *
 * @param file the BMP file to load.
 * @returns a pointer to a new Surface structure or nullptr on failure; call
 *          GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.Destroy
 * @sa Surface.LoadBMP
 * @sa Surface.SaveBMP
 */
inline Surface LoadBMP(StringParam file) { return Surface(SDL_LoadBMP(file)); }

inline Surface Surface::LoadBMP(IOStreamParam src, bool closeio)
{
  return SDL::LoadBMP(src, closeio);
}

inline Surface Surface::LoadBMP(StringParam file)
{
  return SDL::LoadBMP(std::move(file));
}

/**
 * Save a surface to a seekable SDL data stream in BMP format.
 *
 * Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
 * BMP directly. Other RGB formats with 8-bit or higher get converted to a
 * 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
 * surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
 * not supported.
 *
 * @param surface the Surface structure containing the image to be saved.
 * @param dst a data stream to save to.
 * @param closeio if true, calls IOStream.Close() on `dst` before returning,
 * even in the case of an error.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.LoadBMP
 * @sa Surface.SaveBMP
 */
inline void SaveBMP(SurfaceConstParam surface,
                    IOStreamParam dst,
                    bool closeio = false)
{
  CheckError(SDL_SaveBMP_IO(surface, dst, closeio));
}

/**
 * Save a surface to a file.
 *
 * Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
 * BMP directly. Other RGB formats with 8-bit or higher get converted to a
 * 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
 * surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
 * not supported.
 *
 * @param surface the Surface structure containing the image to be saved.
 * @param file a file to save to.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.LoadBMP
 * @sa Surface.SaveBMP
 */
inline void SaveBMP(SurfaceConstParam surface, StringParam file)
{
  CheckError(SDL_SaveBMP(surface, file));
}

inline void Surface::SaveBMP(IOStreamParam dst, bool closeio) const
{
  SDL::SaveBMP(m_resource, dst, closeio);
}

inline void Surface::SaveBMP(StringParam file) const
{
  SDL::SaveBMP(m_resource, std::move(file));
}

/**
 * Set the RLE acceleration hint for a surface.
 *
 * If RLE is enabled, color key and alpha blending blits are much faster, but
 * the surface must be locked before directly accessing the pixels.
 *
 * @param surface the Surface structure to optimize.
 * @param enabled true to enable RLE acceleration, false to disable it.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.Blit
 * @sa Surface.Lock
 * @sa Surface.Unlock
 */
inline void SetSurfaceRLE(SurfaceParam surface, bool enabled)
{
  CheckError(SDL_SetSurfaceRLE(surface, enabled));
}

inline void Surface::SetRLE(bool enabled)
{
  SDL::SetSurfaceRLE(m_resource, enabled);
}

/**
 * Returns whether the surface is RLE enabled.
 *
 * It is safe to pass a nullptr `surface` here; it will return false.
 *
 * @param surface the Surface structure to query.
 * @returns true if the surface is RLE enabled, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.SetRLE
 */
inline bool SurfaceHasRLE(SurfaceConstParam surface)
{
  return SDL_SurfaceHasRLE(surface);
}

inline bool Surface::HasRLE() const { return SDL::SurfaceHasRLE(m_resource); }

/**
 * Set the color key (transparent pixel) in a surface.
 *
 * The color key defines a pixel value that will be treated as transparent in
 * a blit. For example, one can use this to specify that cyan pixels should be
 * considered transparent, and therefore not rendered.
 *
 * It is a pixel of the format used by the surface, as generated by
 * MapRGB().
 *
 * @param surface the Surface structure to update.
 * @param enabled true to enable color key, false to disable color key.
 * @param key the transparent pixel.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.GetColorKey
 * @sa Surface.SetRLE
 * @sa Surface.HasColorKey
 */
inline void SetSurfaceColorKey(SurfaceParam surface, std::optional<Uint32> key)
{
  CheckError(SDL_SetSurfaceColorKey(surface, key.has_value(), key.value_or(0)));
}

inline void Surface::SetColorKey(std::optional<Uint32> key)
{
  SDL::SetSurfaceColorKey(m_resource, key);
}

/**
 * Returns whether the surface has a color key.
 *
 * It is safe to pass a nullptr `surface` here; it will return false.
 *
 * @param surface the Surface structure to query.
 * @returns true if the surface has a color key, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.SetColorKey
 * @sa Surface.GetColorKey
 */
inline bool SurfaceHasColorKey(SurfaceConstParam surface)
{
  return SDL_SurfaceHasColorKey(surface);
}

inline bool Surface::HasColorKey() const
{
  return SDL::SurfaceHasColorKey(m_resource);
}

/**
 * Get the color key (transparent pixel) for a surface.
 *
 * The color key is a pixel of the format used by the surface, as generated by
 * MapRGB().
 *
 * If the surface doesn't have color key enabled this function returns false.
 *
 * @param surface the Surface structure to query.
 * @param key a pointer filled in with the transparent pixel.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.SetColorKey
 * @sa Surface.HasColorKey
 */
inline std::optional<Uint32> GetSurfaceColorKey(SurfaceConstParam surface)
{
  if (Uint32 key; SDL_GetSurfaceColorKey(surface, &key)) return key;
  return std::nullopt;
}

inline std::optional<Uint32> Surface::GetColorKey() const
{
  return SDL::GetSurfaceColorKey(m_resource);
}

/**
 * Set an additional color value multiplied into blit operations.
 *
 * When this surface is blitted, during the blit operation each source color
 * channel is modulated by the appropriate color value according to the
 * following formula:
 *
 * `srcC = srcC * (color / 255)`
 *
 * @param surface the Surface structure to update.
 * @param r the red color value multiplied into blit operations.
 * @param g the green color value multiplied into blit operations.
 * @param b the blue color value multiplied into blit operations.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.GetColorMod
 * @sa Surface.SetAlphaMod
 */
inline void SetSurfaceColorMod(SurfaceParam surface, Uint8 r, Uint8 g, Uint8 b)
{
  CheckError(SDL_SetSurfaceColorMod(surface, r, g, b));
}

inline void Surface::SetColorMod(Uint8 r, Uint8 g, Uint8 b)
{
  SDL::SetSurfaceColorMod(m_resource, r, g, b);
}

/**
 * Get the additional color value multiplied into blit operations.
 *
 * @param surface the Surface structure to query.
 * @param r a pointer filled in with the current red color value.
 * @param g a pointer filled in with the current green color value.
 * @param b a pointer filled in with the current blue color value.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.GetAlphaMod
 * @sa Surface.SetColorMod
 */
inline void GetSurfaceColorMod(SurfaceConstParam surface,
                               Uint8* r,
                               Uint8* g,
                               Uint8* b)
{
  CheckError(SDL_GetSurfaceColorMod(surface, r, g, b));
}

inline void Surface::GetColorMod(Uint8* r, Uint8* g, Uint8* b) const
{
  SDL::GetSurfaceColorMod(m_resource, r, g, b);
}

/**
 * Set an additional alpha value used in blit operations.
 *
 * When this surface is blitted, during the blit operation the source alpha
 * value is modulated by this alpha value according to the following formula:
 *
 * `srcA = srcA * (alpha / 255)`
 *
 * @param surface the Surface structure to update.
 * @param alpha the alpha value multiplied into blit operations.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.GetAlphaMod
 * @sa Surface.SetColorMod
 */
inline void SetSurfaceAlphaMod(SurfaceParam surface, Uint8 alpha)
{
  CheckError(SDL_SetSurfaceAlphaMod(surface, alpha));
}

inline void Surface::SetAlphaMod(Uint8 alpha)
{
  SDL::SetSurfaceAlphaMod(m_resource, alpha);
}

/**
 * Get the additional alpha value used in blit operations.
 *
 * @param surface the Surface structure to query.
 * @param alpha a pointer filled in with the current alpha value.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.GetColorMod
 * @sa Surface.SetAlphaMod
 */
inline Uint8 GetSurfaceAlphaMod(SurfaceConstParam surface)
{
  Uint8 alpha;
  CheckError(SDL_GetSurfaceAlphaMod(surface, &alpha));
  return alpha;
}

inline Uint8 Surface::GetAlphaMod() const
{
  return SDL::GetSurfaceAlphaMod(m_resource);
}

/**
 * Set the blend mode used for blit operations.
 *
 * To copy a surface to another surface (or texture) without blending with the
 * existing data, the blendmode of the SOURCE surface should be set to
 * `BLENDMODE_NONE`.
 *
 * @param surface the Surface structure to update.
 * @param blendMode the BlendMode to use for blit blending.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.GetBlendMode
 */
inline void SetSurfaceBlendMode(SurfaceParam surface, BlendMode blendMode)
{
  CheckError(SDL_SetSurfaceBlendMode(surface, blendMode));
}

inline void Surface::SetBlendMode(BlendMode blendMode)
{
  SDL::SetSurfaceBlendMode(m_resource, blendMode);
}

/**
 * Get the blend mode used for blit operations.
 *
 * @param surface the Surface structure to query.
 * @param blendMode a pointer filled in with the current BlendMode.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.SetBlendMode
 */
inline BlendMode GetSurfaceBlendMode(SurfaceConstParam surface)
{
  BlendMode blendmode;
  CheckError(SDL_GetSurfaceBlendMode(surface, &blendmode));
  return blendmode;
}

inline BlendMode Surface::GetBlendMode() const
{
  return SDL::GetSurfaceBlendMode(m_resource);
}

/**
 * Set the clipping rectangle for a surface.
 *
 * When `surface` is the destination of a blit, only the area within the clip
 * rectangle is drawn into.
 *
 * Note that blits are automatically clipped to the edges of the source and
 * destination surfaces.
 *
 * @param surface the Surface structure to be clipped.
 * @param rect the Rect structure representing the clipping rectangle, or
 *             nullptr to disable clipping.
 * @returns true if the rectangle intersects the surface, otherwise false and
 *          blits will be completely clipped.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.GetClipRect
 */
inline bool SetSurfaceClipRect(SurfaceParam surface,
                               OptionalRef<const RectRaw> rect)
{
  return SDL_SetSurfaceClipRect(surface, rect);
}

inline bool Surface::SetClipRect(OptionalRef<const RectRaw> rect)
{
  return SDL::SetSurfaceClipRect(m_resource, rect);
}

/**
 * Get the clipping rectangle for a surface.
 *
 * When `surface` is the destination of a blit, only the area within the clip
 * rectangle is drawn into.
 *
 * @param surface the Surface structure representing the surface to be
 *                clipped.
 * @param rect an Rect structure filled in with the clipping rectangle for
 *             the surface.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.SetClipRect
 */
inline Rect GetSurfaceClipRect(SurfaceConstParam surface)
{
  Rect r;
  CheckError(SDL_GetSurfaceClipRect(surface, &r));
  return r;
}

inline Rect Surface::GetClipRect() const
{
  return SDL::GetSurfaceClipRect(m_resource);
}

/**
 * Flip a surface vertically or horizontally.
 *
 * @param surface the surface to flip.
 * @param flip the direction to flip.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void FlipSurface(SurfaceParam surface, FlipMode flip)
{
  CheckError(SDL_FlipSurface(surface, flip));
}

inline void Surface::Flip(FlipMode flip) { SDL::FlipSurface(m_resource, flip); }

/**
 * Creates a new surface identical to the existing surface.
 *
 * If the original surface has alternate images, the new surface will have a
 * reference to them as well.
 *
 * The returned surface should be freed with Surface.Destroy().
 *
 * @param surface the surface to duplicate.
 * @returns a copy of the surface or nullptr on failure; call GetError() for
 *          more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.Destroy
 */
inline Surface DuplicateSurface(SurfaceConstParam surface)
{
  return Surface(SDL_DuplicateSurface(surface));
}

inline Surface Surface::Duplicate() const
{
  return SDL::DuplicateSurface(m_resource);
}

/**
 * Creates a new surface identical to the existing surface, scaled to the
 * desired size.
 *
 * The returned surface should be freed with Surface.Destroy().
 *
 * @param surface the surface to duplicate and scale.
 * @param size the width and height of the surface.
 * @param scaleMode the ScaleMode to be used.
 * @returns a copy of the surface or nullptr on failure; call GetError() for
 *          more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.Destroy
 */
inline Surface ScaleSurface(SurfaceConstParam surface,
                            const PointRaw& size,
                            ScaleMode scaleMode)
{
  return Surface(SDL_ScaleSurface(surface, size.x, size.y, scaleMode));
}

inline Surface Surface::Scale(const PointRaw& size, ScaleMode scaleMode) const
{
  return SDL::ScaleSurface(m_resource, size, scaleMode);
}

/**
 * Copy an existing surface to a new surface of the specified format.
 *
 * This function is used to optimize images for faster *repeat* blitting. This
 * is accomplished by converting the original and storing the result as a new
 * surface. The new, optimized surface can then be used as the source for
 * future blits, making them faster.
 *
 * If you are converting to an indexed surface and want to map colors to a
 * palette, you can use Surface.Convert() instead.
 *
 * If the original surface has alternate images, the new surface will have a
 * reference to them as well.
 *
 * @param surface the existing Surface structure to convert.
 * @param format the new pixel format.
 * @returns the new Surface structure that is created or nullptr on failure;
 *          call GetError() for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.Convert
 * @sa Surface.Destroy
 */
inline Surface ConvertSurface(SurfaceConstParam surface, PixelFormat format)
{
  return Surface(SDL_ConvertSurface(surface, format));
}

inline Surface Surface::Convert(PixelFormat format) const
{
  return SDL::ConvertSurface(m_resource, format);
}

/**
 * Copy an existing surface to a new surface of the specified format and
 * colorspace.
 *
 * This function converts an existing surface to a new format and colorspace
 * and returns the new surface. This will perform any pixel format and
 * colorspace conversion needed.
 *
 * If the original surface has alternate images, the new surface will have a
 * reference to them as well.
 *
 * @param surface the existing Surface structure to convert.
 * @param format the new pixel format.
 * @param palette an optional palette to use for indexed formats, may be
 * nullptr.
 * @param colorspace the new colorspace.
 * @param props an Properties with additional color properties, or 0.
 * @returns the new Surface structure that is created or nullptr on failure;
 *          call GetError() for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.Convert
 * @sa Surface.Destroy
 */
inline Surface ConvertSurfaceAndColorspace(SurfaceConstParam surface,
                                           PixelFormat format,
                                           PaletteParam palette,
                                           Colorspace colorspace,
                                           PropertiesParam props)
{
  return Surface{SDL_ConvertSurfaceAndColorspace(
    surface, format, palette, colorspace, props)};
}

inline Surface Surface::Convert(PixelFormat format,
                                PaletteParam palette,
                                Colorspace colorspace,
                                PropertiesParam props) const
{
  return SDL::ConvertSurfaceAndColorspace(
    m_resource, format, palette, colorspace, props);
}

/**
 * Copy a block of pixels of one format to another format.
 *
 * @param size the width and height of the surface.
 * @param src_format an PixelFormat value of the `src` pixels format.
 * @param src a pointer to the source pixels.
 * @param src_pitch the pitch of the source pixels, in bytes.
 * @param dst_format an PixelFormat value of the `dst` pixels format.
 * @param dst a pointer to be filled in with new pixel data.
 * @param dst_pitch the pitch of the destination pixels, in bytes.
 * @throws Error on failure.
 *
 * @threadsafety The same destination pixels should not be used from two
 *               threads at once. It is safe to use the same source pixels
 *               from multiple threads.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa ConvertPixelsAndColorspace
 */
inline void ConvertPixels(const PointRaw& size,
                          PixelFormat src_format,
                          const void* src,
                          int src_pitch,
                          PixelFormat dst_format,
                          void* dst,
                          int dst_pitch)
{
  CheckError(SDL_ConvertPixels(
    size.x, size.y, src_format, src, src_pitch, dst_format, dst, dst_pitch));
}

/**
 * Copy a block of pixels of one format and colorspace to another format and
 * colorspace.
 *
 * @param size the width and height  of the block to copy, in pixels.
 * @param src_format an PixelFormat value of the `src` pixels format.
 * @param src_colorspace an Colorspace value describing the colorspace of
 *                       the `src` pixels.
 * @param src_properties an Properties with additional source color
 *                       properties, or 0.
 * @param src a pointer to the source pixels.
 * @param src_pitch the pitch of the source pixels, in bytes.
 * @param dst_format an PixelFormat value of the `dst` pixels format.
 * @param dst_colorspace an Colorspace value describing the colorspace of
 *                       the `dst` pixels.
 * @param dst_properties an Properties with additional destination color
 *                       properties, or 0.
 * @param dst a pointer to be filled in with new pixel data.
 * @param dst_pitch the pitch of the destination pixels, in bytes.
 * @throws Error on failure.
 *
 * @threadsafety The same destination pixels should not be used from two
 *               threads at once. It is safe to use the same source pixels
 *               from multiple threads.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa ConvertPixels
 */
inline void ConvertPixelsAndColorspace(const PointRaw& size,
                                       PixelFormat src_format,
                                       Colorspace src_colorspace,
                                       PropertiesParam src_properties,
                                       const void* src,
                                       int src_pitch,
                                       PixelFormat dst_format,
                                       Colorspace dst_colorspace,
                                       PropertiesParam dst_properties,
                                       void* dst,
                                       int dst_pitch)
{
  CheckError(SDL_ConvertPixelsAndColorspace(size.x,
                                            size.y,
                                            src_format,
                                            src_colorspace,
                                            src_properties,
                                            src,
                                            src_pitch,
                                            dst_format,
                                            dst_colorspace,
                                            dst_properties,
                                            dst,
                                            dst_pitch));
}

/**
 * Premultiply the alpha on a block of pixels.
 *
 * This is safe to use with src == dst, but not for other overlapping areas.
 *
 * @param size the width and height of the surface.
 * @param src_format an PixelFormat value of the `src` pixels format.
 * @param src a pointer to the source pixels.
 * @param src_pitch the pitch of the source pixels, in bytes.
 * @param dst_format an PixelFormat value of the `dst` pixels format.
 * @param dst a pointer to be filled in with premultiplied pixel data.
 * @param dst_pitch the pitch of the destination pixels, in bytes.
 * @param linear true to convert from sRGB to linear space for the alpha
 *               multiplication, false to do multiplication in sRGB space.
 * @throws Error on failure.
 *
 * @threadsafety The same destination pixels should not be used from two
 *               threads at once. It is safe to use the same source pixels
 *               from multiple threads.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void PremultiplyAlpha(const PointRaw& size,
                             PixelFormat src_format,
                             const void* src,
                             int src_pitch,
                             PixelFormat dst_format,
                             void* dst,
                             int dst_pitch,
                             bool linear)
{
  CheckError(SDL_PremultiplyAlpha(size.x,
                                  size.y,
                                  src_format,
                                  src,
                                  src_pitch,
                                  dst_format,
                                  dst,
                                  dst_pitch,
                                  linear));
}

/**
 * Premultiply the alpha in a surface.
 *
 * This is safe to use with src == dst, but not for other overlapping areas.
 *
 * @param surface the surface to modify.
 * @param linear true to convert from sRGB to linear space for the alpha
 *               multiplication, false to do multiplication in sRGB space.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void PremultiplySurfaceAlpha(SurfaceParam surface, bool linear)
{
  CheckError(SDL_PremultiplySurfaceAlpha(surface, linear));
}

inline void Surface::PremultiplyAlpha(bool linear)
{
  SDL::PremultiplySurfaceAlpha(m_resource, linear);
}

/**
 * Clear a surface with a specific color, with floating point precision.
 *
 * This function handles all surface formats, and ignores any clip rectangle.
 *
 * If the surface is YUV, the color is assumed to be in the sRGB colorspace,
 * otherwise the color is assumed to be in the colorspace of the suface.
 *
 * @param surface the Surface to clear.
 * @param c the color components of the pixel, normally in the range 0-1.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void ClearSurface(SurfaceParam surface, const FColorRaw& color)
{
  CheckError(SDL_ClearSurface(surface, color.r, color.g, color.b, color.a));
}

inline void Surface::Clear(const FColorRaw& color)
{
  SDL::ClearSurface(m_resource, color);
}

/**
 * Perform a fast fill of a rectangle with a specific color.
 *
 * `color` should be a pixel of the format used by the surface, and can be
 * generated by MapRGB() or MapRGBA(). If the color value contains an
 * alpha component then the destination is simply filled with that alpha
 * information, no blending takes place.
 *
 * If there is a clip rectangle set on the destination (set via
 * Surface.SetClipRect()), then this function will fill based on the
 * intersection of the clip rectangle and `rect`.
 *
 * @param dst the Surface structure that is the drawing target.
 * @param rect the Rect structure representing the rectangle to fill, or
 *             nullptr to fill the entire surface.
 * @param color the color to fill with.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.FillRects
 */
inline void FillSurfaceRect(SurfaceParam dst,
                            OptionalRef<const RectRaw> rect,
                            Uint32 color)
{
  CheckError(SDL_FillSurfaceRect(dst, rect, color));
}

inline void Surface::FillRect(OptionalRef<const RectRaw> rect, Uint32 color)
{
  SDL::FillSurfaceRect(m_resource, rect, color);
}

/**
 * Perform a fast fill of a set of rectangles with a specific color.
 *
 * `color` should be a pixel of the format used by the surface, and can be
 * generated by MapRGB() or MapRGBA(). If the color value contains an
 * alpha component then the destination is simply filled with that alpha
 * information, no blending takes place.
 *
 * If there is a clip rectangle set on the destination (set via
 * Surface.SetClipRect()), then this function will fill based on the
 * intersection of the clip rectangle and `rect`.
 *
 * @param dst the Surface structure that is the drawing target.
 * @param rects an array of SDL_Rects representing the rectangles to fill.
 * @param count the number of rectangles in the array.
 * @param color the color to fill with.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.FillRect
 */
inline void FillSurfaceRects(SurfaceParam dst,
                             SpanRef<const RectRaw> rects,
                             Uint32 color)
{
  CheckError(SDL_FillSurfaceRects(dst, rects.data(), rects.size(), color));
}

inline void Surface::FillRects(SpanRef<const RectRaw> rects, Uint32 color)
{
  SDL::FillSurfaceRects(m_resource, rects, color);
}

/**
 * Performs a fast blit from the source surface to the destination surface
 * with clipping.
 *
 * If either `srcrect` or `dstrect` are nullptr, the entire surface (`src` or
 * `dst`) is copied while ensuring clipping to `dst->clip_rect`.
 *
 * The blit function should not be called on a locked surface.
 *
 * The blit semantics for surfaces with and without blending and colorkey are
 * defined as follows:
 *
 * ```
 *    RGBA->RGB:
 *      Source surface blend mode set to BLENDMODE_BLEND:
 *       alpha-blend (using the source alpha-channel and per-surface alpha)
 *       SDL_SRCCOLORKEY ignored.
 *     Source surface blend mode set to BLENDMODE_NONE:
 *       copy RGB.
 *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
 *       RGB values of the source color key, ignoring alpha in the
 *       comparison.
 *
 *   RGB->RGBA:
 *     Source surface blend mode set to BLENDMODE_BLEND:
 *       alpha-blend (using the source per-surface alpha)
 *     Source surface blend mode set to BLENDMODE_NONE:
 *       copy RGB, set destination alpha to source per-surface alpha value.
 *     both:
 *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
 *       source color key.
 *
 *   RGBA->RGBA:
 *     Source surface blend mode set to BLENDMODE_BLEND:
 *       alpha-blend (using the source alpha-channel and per-surface alpha)
 *       SDL_SRCCOLORKEY ignored.
 *     Source surface blend mode set to BLENDMODE_NONE:
 *       copy all of RGBA to the destination.
 *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
 *       RGB values of the source color key, ignoring alpha in the
 *       comparison.
 *
 *   RGB->RGB:
 *     Source surface blend mode set to BLENDMODE_BLEND:
 *       alpha-blend (using the source per-surface alpha)
 *     Source surface blend mode set to BLENDMODE_NONE:
 *       copy RGB.
 *     both:
 *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
 *       source color key.
 * ```
 *
 * @param src the Surface structure to be copied from.
 * @param srcrect the Rect structure representing the rectangle to be
 *                copied, or nullptr to copy the entire surface.
 * @param dst the Surface structure that is the blit target.
 * @param dstrect the Rect structure representing the x and y position in
 *                the destination surface, or nullptr for (0,0). The width and
 *                height are ignored, and are copied from `srcrect`. If you
 *                want a specific width and height, you should use
 *                Surface.BlitScaled().
 * @throws Error on failure.
 *
 * @threadsafety Only one thread should be using the `src` and `dst` surfaces
 *               at any given time.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.BlitScaled
 */
inline void BlitSurface(SurfaceParam src,
                        OptionalRef<const RectRaw> srcrect,
                        SurfaceParam dst,
                        OptionalRef<const RectRaw> dstrect)
{
  CheckError(SDL_BlitSurface(src, srcrect, dst, dstrect));
}

inline void Surface::Blit(SurfaceParam src,
                          OptionalRef<const RectRaw> srcrect,
                          OptionalRef<const RectRaw> dstrect)
{
  SDL::BlitSurface(src, srcrect, m_resource, dstrect);
}

/**
 * Performs a fast blit from the source surface to the destination surface
 * with clipping.
 *
 * If either `srcrect` or `dstrect` are nullptr, the entire surface (`src` or
 * `dst`) is copied while ensuring clipping to `dst->clip_rect`.
 *
 * The blit function should not be called on a locked surface.
 *
 * The blit semantics for surfaces with and without blending and colorkey are
 * defined as follows:
 *
 * ```
 *    RGBA->RGB:
 *      Source surface blend mode set to BLENDMODE_BLEND:
 *       alpha-blend (using the source alpha-channel and per-surface alpha)
 *       SDL_SRCCOLORKEY ignored.
 *     Source surface blend mode set to BLENDMODE_NONE:
 *       copy RGB.
 *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
 *       RGB values of the source color key, ignoring alpha in the
 *       comparison.
 *
 *   RGB->RGBA:
 *     Source surface blend mode set to BLENDMODE_BLEND:
 *       alpha-blend (using the source per-surface alpha)
 *     Source surface blend mode set to BLENDMODE_NONE:
 *       copy RGB, set destination alpha to source per-surface alpha value.
 *     both:
 *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
 *       source color key.
 *
 *   RGBA->RGBA:
 *     Source surface blend mode set to BLENDMODE_BLEND:
 *       alpha-blend (using the source alpha-channel and per-surface alpha)
 *       SDL_SRCCOLORKEY ignored.
 *     Source surface blend mode set to BLENDMODE_NONE:
 *       copy all of RGBA to the destination.
 *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
 *       RGB values of the source color key, ignoring alpha in the
 *       comparison.
 *
 *   RGB->RGB:
 *     Source surface blend mode set to BLENDMODE_BLEND:
 *       alpha-blend (using the source per-surface alpha)
 *     Source surface blend mode set to BLENDMODE_NONE:
 *       copy RGB.
 *     both:
 *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
 *       source color key.
 * ```
 *
 * @param src the Surface structure to be copied from.
 * @param srcrect the Rect structure representing the rectangle to be
 *                copied, or nullptr to copy the entire surface.
 * @param dst the Surface structure that is the blit target.
 * @param dstpos the Point structure representing the x and y position in
 *                the destination surface.
 * @throws Error on failure.
 *
 * @threadsafety Only one thread should be using the `src` and `dst` surfaces
 *               at any given time.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.BlitSurface
 */
inline void BlitSurfaceAt(SurfaceParam src,
                          OptionalRef<const RectRaw> srcrect,
                          SurfaceParam dst,
                          const PointRaw& dstpos)
{
  BlitSurface(src, srcrect, dst, SDL_Rect{dstpos.x, dstpos.y});
}

/**
 * Perform low-level surface blitting only.
 *
 * This is a semi-private blit function and it performs low-level surface
 * blitting, assuming the input rectangles have already been clipped.
 *
 * @param src the Surface structure to be copied from.
 * @param srcrect the Rect structure representing the rectangle to be
 *                copied, may not be nullptr.
 * @param dst the Surface structure that is the blit target.
 * @param dstrect the Rect structure representing the target rectangle in
 *                the destination surface, may not be nullptr.
 * @throws Error on failure.
 *
 * @threadsafety Only one thread should be using the `src` and `dst` surfaces
 *               at any given time.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.Blit
 */
inline void BlitSurfaceUnchecked(SurfaceParam src,
                                 const RectRaw& srcrect,
                                 SurfaceParam dst,
                                 const RectRaw& dstrect)
{
  CheckError(SDL_BlitSurfaceUnchecked(src, &srcrect, dst, &dstrect));
}

inline void Surface::BlitUnchecked(SurfaceParam src,
                                   const RectRaw& srcrect,
                                   const RectRaw& dstrect)
{
  SDL::BlitSurfaceUnchecked(src, srcrect, m_resource, dstrect);
}

/**
 * Perform a scaled blit to a destination surface, which may be of a different
 * format.
 *
 * @param src the Surface structure to be copied from.
 * @param srcrect the Rect structure representing the rectangle to be
 *                copied, or nullptr to copy the entire surface.
 * @param dst the Surface structure that is the blit target.
 * @param dstrect the Rect structure representing the target rectangle in
 *                the destination surface, or nullptr to fill the entire
 *                destination surface.
 * @param scaleMode the ScaleMode to be used.
 * @throws Error on failure.
 *
 * @threadsafety Only one thread should be using the `src` and `dst` surfaces
 *               at any given time.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.Blit
 */
inline void BlitSurfaceScaled(SurfaceParam src,
                              OptionalRef<const RectRaw> srcrect,
                              SurfaceParam dst,
                              OptionalRef<const RectRaw> dstrect,
                              ScaleMode scaleMode)
{
  CheckError(SDL_BlitSurfaceScaled(src, srcrect, dst, dstrect, scaleMode));
}

inline void Surface::BlitScaled(SurfaceParam src,
                                OptionalRef<const RectRaw> srcrect,
                                OptionalRef<const RectRaw> dstrect,
                                ScaleMode scaleMode)
{
  SDL::BlitSurfaceScaled(src, srcrect, m_resource, dstrect, scaleMode);
}

/**
 * Perform low-level surface scaled blitting only.
 *
 * This is a semi-private function and it performs low-level surface blitting,
 * assuming the input rectangles have already been clipped.
 *
 * @param src the Surface structure to be copied from.
 * @param srcrect the Rect structure representing the rectangle to be
 *                copied, may not be nullptr.
 * @param dst the Surface structure that is the blit target.
 * @param dstrect the Rect structure representing the target rectangle in
 *                the destination surface, may not be nullptr.
 * @param scaleMode the ScaleMode to be used.
 * @throws Error on failure.
 *
 * @threadsafety Only one thread should be using the `src` and `dst` surfaces
 *               at any given time.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.BlitScaled
 */
inline void BlitSurfaceUncheckedScaled(SurfaceParam src,
                                       const RectRaw& srcrect,
                                       SurfaceParam dst,
                                       const RectRaw& dstrect,
                                       ScaleMode scaleMode)
{
  CheckError(
    SDL_BlitSurfaceUncheckedScaled(src, &srcrect, dst, &dstrect, scaleMode));
}

inline void Surface::BlitUncheckedScaled(SurfaceParam src,
                                         const RectRaw& srcrect,
                                         const RectRaw& dstrect,
                                         ScaleMode scaleMode)
{
  SDL::BlitSurfaceUncheckedScaled(src, srcrect, m_resource, dstrect, scaleMode);
}

#if SDL_VERSION_ATLEAST(3, 2, 4)

/**
 * Perform a stretched pixel copy from one surface to another.
 *
 * @param src the Surface structure to be copied from.
 * @param srcrect the Rect structure representing the rectangle to be
 *                copied, or nullptr to copy the entire surface.
 * @param dst the Surface structure that is the blit target.
 * @param dstrect the Rect structure representing the target rectangle in
 *                the destination surface, or nullptr to fill the entire
 *                destination surface.
 * @param scaleMode the ScaleMode to be used.
 * @throws Error on failure.
 *
 * @threadsafety Only one thread should be using the `src` and `dst` surfaces
 *               at any given time.
 *
 * @since This function is available since SDL 3.4.0.
 *
 * @sa Surface.BlitScaled
 */
inline void StretchSurface(SurfaceParam src,
                           OptionalRef<RectRaw> srcrect,
                           SurfaceParam dst,
                           OptionalRef<RectRaw> dstrect,
                           ScaleMode scaleMode)
{
  CheckError(SDL_StretchSurface(src, srcrect, dst, dstrect, scaleMode));
}

inline void Surface::Stretch(SurfaceParam src,
                             OptionalRef<RectRaw> srcrect,
                             OptionalRef<RectRaw> dstrect,
                             ScaleMode scaleMode)
{
  SDL::StretchSurface(src, srcrect, m_resource, dstrect, scaleMode);
}

#endif // SDL_VERSION_ATLEAST(3, 2, 4)

/**
 * Perform a tiled blit to a destination surface, which may be of a different
 * format.
 *
 * The pixels in `srcrect` will be repeated as many times as needed to
 * completely fill `dstrect`.
 *
 * @param src the Surface structure to be copied from.
 * @param srcrect the Rect structure representing the rectangle to be
 *                copied, or nullptr to copy the entire surface.
 * @param dst the Surface structure that is the blit target.
 * @param dstrect the Rect structure representing the target rectangle in
 *                the destination surface, or nullptr to fill the entire
 * surface.
 * @throws Error on failure.
 *
 * @threadsafety Only one thread should be using the `src` and `dst` surfaces
 *               at any given time.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.Blit
 */
inline void BlitSurfaceTiled(SurfaceParam src,
                             OptionalRef<const RectRaw> srcrect,
                             SurfaceParam dst,
                             OptionalRef<const RectRaw> dstrect)
{
  CheckError(SDL_BlitSurfaceTiled(src, srcrect, dst, dstrect));
}

inline void Surface::BlitTiled(SurfaceParam src,
                               OptionalRef<const RectRaw> srcrect,
                               OptionalRef<const RectRaw> dstrect)
{
  SDL::BlitSurfaceTiled(src, srcrect, m_resource, dstrect);
}

/**
 * Perform a scaled and tiled blit to a destination surface, which may be of a
 * different format.
 *
 * The pixels in `srcrect` will be scaled and repeated as many times as needed
 * to completely fill `dstrect`.
 *
 * @param src the Surface structure to be copied from.
 * @param srcrect the Rect structure representing the rectangle to be
 *                copied, or nullptr to copy the entire surface.
 * @param scale the scale used to transform srcrect into the destination
 *              rectangle, e.g. a 32x32 texture with a scale of 2 would fill
 *              64x64 tiles.
 * @param scaleMode scale algorithm to be used.
 * @param dst the Surface structure that is the blit target.
 * @param dstrect the Rect structure representing the target rectangle in
 *                the destination surface, or nullptr to fill the entire
 * surface.
 * @throws Error on failure.
 *
 * @threadsafety Only one thread should be using the `src` and `dst` surfaces
 *               at any given time.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.Blit
 */
inline void BlitSurfaceTiledWithScale(SurfaceParam src,
                                      OptionalRef<const RectRaw> srcrect,
                                      float scale,
                                      SDL_ScaleMode scaleMode,
                                      SurfaceParam dst,
                                      OptionalRef<const RectRaw> dstrect)
{
  CheckError(SDL_BlitSurfaceTiledWithScale(
    src, srcrect, scale, scaleMode, dst, dstrect));
}

inline void Surface::BlitTiledWithScale(SurfaceParam src,
                                        OptionalRef<const RectRaw> srcrect,
                                        float scale,
                                        SDL_ScaleMode scaleMode,
                                        OptionalRef<const RectRaw> dstrect)
{
  SDL::BlitSurfaceTiledWithScale(
    src, srcrect, scale, scaleMode, m_resource, dstrect);
}

/**
 * Perform a scaled blit using the 9-grid algorithm to a destination surface,
 * which may be of a different format.
 *
 * The pixels in the source surface are split into a 3x3 grid, using the
 * different corner sizes for each corner, and the sides and center making up
 * the remaining pixels. The corners are then scaled using `scale` and fit
 * into the corners of the destination rectangle. The sides and center are
 * then stretched into place to cover the remaining destination rectangle.
 *
 * @param src the Surface structure to be copied from.
 * @param srcrect the Rect structure representing the rectangle to be used
 *                for the 9-grid, or nullptr to use the entire surface.
 * @param left_width the width, in pixels, of the left corners in `srcrect`.
 * @param right_width the width, in pixels, of the right corners in `srcrect`.
 * @param top_height the height, in pixels, of the top corners in `srcrect`.
 * @param bottom_height the height, in pixels, of the bottom corners in
 *                      `srcrect`.
 * @param scale the scale used to transform the corner of `srcrect` into the
 *              corner of `dstrect`, or 0.0f for an unscaled blit.
 * @param scaleMode scale algorithm to be used.
 * @param dst the Surface structure that is the blit target.
 * @param dstrect the Rect structure representing the target rectangle in
 *                the destination surface, or nullptr to fill the entire
 * surface.
 * @throws Error on failure.
 *
 * @threadsafety Only one thread should be using the `src` and `dst` surfaces
 *               at any given time.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.Blit
 */
inline void BlitSurface9Grid(SurfaceParam src,
                             OptionalRef<const RectRaw> srcrect,
                             int left_width,
                             int right_width,
                             int top_height,
                             int bottom_height,
                             float scale,
                             SDL_ScaleMode scaleMode,
                             SurfaceParam dst,
                             OptionalRef<const RectRaw> dstrect)
{
  CheckError(SDL_BlitSurface9Grid(src,
                                  srcrect,
                                  left_width,
                                  right_width,
                                  top_height,
                                  bottom_height,
                                  scale,
                                  scaleMode,
                                  dst,
                                  dstrect));
}

/**
 * Perform a scaled blit using the 9-grid algorithm to a destination surface,
 * which may be of a different format.
 *
 * The pixels in the source surface are split into a 3x3 grid, using the
 * different corner sizes for each corner, and the sides and center making up
 * the remaining pixels. The corners are then scaled using `scale` and fit
 * into the corners of the destination rectangle. The sides and center are
 * then stretched into place to cover the remaining destination rectangle.
 *
 * @param src the Surface structure to be copied from.
 * @param srcrect the Rect structure representing the rectangle to be used
 *                for the 9-grid, or nullptr to use the entire surface.
 * @param left_width the width, in pixels, of the left corners in `srcrect`.
 * @param right_width the width, in pixels, of the right corners in `srcrect`.
 * @param top_height the height, in pixels, of the top corners in `srcrect`.
 * @param bottom_height the height, in pixels, of the bottom corners in
 *                      `srcrect`.
 * @param scale the scale used to transform the corner of `srcrect` into the
 *              corner of `dstrect`, or 0.0f for an unscaled blit.
 * @param scaleMode scale algorithm to be used.
 * @param dst the Surface structure that is the blit target.
 * @param dstrect the Rect structure representing the target rectangle in
 *                the destination surface, or nullptr to fill the entire
 * surface.
 * @throws Error on failure.
 *
 * @threadsafety Only one thread should be using the `src` and `dst` surfaces
 *               at any given time.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.Blit
 */
inline void BlitSurface9Grid(SurfaceParam src,
                             OptionalRef<const RectRaw> srcrect,
                             int left_width,
                             int right_width,
                             int top_height,
                             int bottom_height,
                             SurfaceParam dst,
                             OptionalRef<const RectRaw> dstrect)
{
  BlitSurface9Grid(src,
                   srcrect,
                   left_width,
                   right_width,
                   top_height,
                   bottom_height,
                   0.0,
                   SDL_SCALEMODE_NEAREST,
                   dst,
                   dstrect);
}

inline void Surface::Blit9GridWithScale(SurfaceParam src,
                                        OptionalRef<const RectRaw> srcrect,
                                        int left_width,
                                        int right_width,
                                        int top_height,
                                        int bottom_height,
                                        float scale,
                                        SDL_ScaleMode scaleMode,
                                        OptionalRef<const RectRaw> dstrect)
{
  SDL::BlitSurface9Grid(src,
                        srcrect,
                        left_width,
                        right_width,
                        top_height,
                        bottom_height,
                        scale,
                        scaleMode,
                        m_resource,
                        dstrect);
}

/**
 * Map an RGB triple to an opaque pixel value for a surface.
 *
 * This function maps the RGB color value to the specified pixel format and
 * returns the pixel value best approximating the given RGB color value for
 * the given pixel format.
 *
 * If the surface has a palette, the index of the closest matching color in
 * the palette will be returned.
 *
 * If the surface pixel format has an alpha component it will be returned as
 * all 1 bits (fully opaque).
 *
 * If the pixel format bpp (color depth) is less than 32-bpp then the unused
 * upper bits of the return value can safely be ignored (e.g., with a 16-bpp
 * format the return value can be assigned to a Uint16, and similarly a Uint8
 * for an 8-bpp format).
 *
 * @param surface the surface to use for the pixel format and palette.
 * @param r the red component of the pixel in the range 0-255.
 * @param g the green component of the pixel in the range 0-255.
 * @param b the blue component of the pixel in the range 0-255.
 * @returns a pixel value.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.MapRGBA
 */
inline Uint32 MapSurfaceRGB(SurfaceConstParam surface,
                            Uint8 r,
                            Uint8 g,
                            Uint8 b)
{
  return SDL_MapSurfaceRGB(surface, r, g, b);
}

inline Uint32 Surface::MapRGB(Uint8 r, Uint8 g, Uint8 b) const
{
  return SDL::MapSurfaceRGB(m_resource, r, g, b);
}

/**
 * Map an RGBA quadruple to a pixel value for a surface.
 *
 * This function maps the RGBA color value to the specified pixel format and
 * returns the pixel value best approximating the given RGBA color value for
 * the given pixel format.
 *
 * If the surface pixel format has no alpha component the alpha value will be
 * ignored (as it will be in formats with a palette).
 *
 * If the surface has a palette, the index of the closest matching color in
 * the palette will be returned.
 *
 * If the pixel format bpp (color depth) is less than 32-bpp then the unused
 * upper bits of the return value can safely be ignored (e.g., with a 16-bpp
 * format the return value can be assigned to a Uint16, and similarly a Uint8
 * for an 8-bpp format).
 *
 * @param surface the surface to use for the pixel format and palette.
 * @param r the red component of the pixel in the range 0-255.
 * @param g the green component of the pixel in the range 0-255.
 * @param b the blue component of the pixel in the range 0-255.
 * @param a the alpha component of the pixel in the range 0-255.
 * @returns a pixel value.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Surface.MapRGB
 */
inline Uint32 MapSurfaceRGBA(SurfaceConstParam surface, ColorRaw c)
{
  return SDL_MapSurfaceRGBA(surface, c.r, c.g, c.b, c.a);
}

inline Uint32 Surface::MapRGBA(ColorRaw c) const
{
  return SDL::MapSurfaceRGBA(m_resource, c);
}

/**
 * Retrieves a single pixel from a surface.
 *
 * This function prioritizes correctness over speed: it is suitable for unit
 * tests, but is not intended for use in a game engine.
 *
 * Like GetRGBA, this uses the entire 0..255 range when converting color
 * components from pixel formats with less than 8 bits per RGB component.
 *
 * @param surface the surface to read.
 * @param x the horizontal coordinate, 0 <= x < width.
 * @param y the vertical coordinate, 0 <= y < height.
 * @param r a pointer filled in with the red channel, 0-255, or nullptr to
 * ignore this channel.
 * @param g a pointer filled in with the green channel, 0-255, or nullptr to
 *          ignore this channel.
 * @param b a pointer filled in with the blue channel, 0-255, or nullptr to
 *          ignore this channel.
 * @param a a pointer filled in with the alpha channel, 0-255, or nullptr to
 *          ignore this channel.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void ReadSurfacePixel(SurfaceConstParam surface,
                             const PointRaw& p,
                             Uint8* r,
                             Uint8* g,
                             Uint8* b,
                             Uint8* a)
{
  CheckError(SDL_ReadSurfacePixel(surface, p.x, p.y, r, g, b, a));
}

inline void Surface::ReadPixel(const PointRaw& p,
                               Uint8* r,
                               Uint8* g,
                               Uint8* b,
                               Uint8* a) const
{
  SDL::ReadSurfacePixel(m_resource, p, r, g, b, a);
}

/**
 * Retrieves a single pixel from a surface.
 *
 * This function prioritizes correctness over speed: it is suitable for unit
 * tests, but is not intended for use in a game engine.
 *
 * @param surface the surface to read.
 * @param x the horizontal coordinate, 0 <= x < width.
 * @param y the vertical coordinate, 0 <= y < height.
 * @param r a pointer filled in with the red channel, normally in the range
 *          0-1, or nullptr to ignore this channel.
 * @param g a pointer filled in with the green channel, normally in the range
 *          0-1, or nullptr to ignore this channel.
 * @param b a pointer filled in with the blue channel, normally in the range
 *          0-1, or nullptr to ignore this channel.
 * @param a a pointer filled in with the alpha channel, normally in the range
 *          0-1, or nullptr to ignore this channel.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void ReadSurfacePixelFloat(SurfaceConstParam surface,
                                  const PointRaw& p,
                                  float* r,
                                  float* g,
                                  float* b,
                                  float* a)
{
  CheckError(SDL_ReadSurfacePixelFloat(surface, p.x, p.y, r, g, b, a));
}

inline void Surface::ReadPixelFloat(const PointRaw& p,
                                    float* r,
                                    float* g,
                                    float* b,
                                    float* a) const
{
  SDL::ReadSurfacePixelFloat(m_resource, p, r, g, b, a);
}

/**
 * Writes a single pixel to a surface.
 *
 * This function prioritizes correctness over speed: it is suitable for unit
 * tests, but is not intended for use in a game engine.
 *
 * Like MapRGBA, this uses the entire 0..255 range when converting color
 * components from pixel formats with less than 8 bits per RGB component.
 *
 * @param surface the surface to write.
 * @param p the coordinates, 0 <= x < width, 0 <= y < height.
 * @param c the color channels value, 0-255.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void WriteSurfacePixel(SurfaceParam surface,
                              const PointRaw& p,
                              ColorRaw c)
{
  CheckError(SDL_WriteSurfacePixel(surface, p.x, p.y, c.r, c.g, c.b, c.a));
}

inline void Surface::WritePixel(const PointRaw& p, ColorRaw c)
{
  SDL::WriteSurfacePixel(m_resource, p, c);
}

/**
 * Writes a single pixel to a surface.
 *
 * This function prioritizes correctness over speed: it is suitable for unit
 * tests, but is not intended for use in a game engine.
 *
 * @param surface the surface to write.
 * @param p the coordinates, 0 <= x < width, 0 <= y < height.
 * @param c the color channels values, normally in the range 0-1.
 * @throws Error on failure.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void WriteSurfacePixelFloat(SurfaceParam surface,
                                   const PointRaw& p,
                                   const FColorRaw& c)
{
  CheckError(SDL_WriteSurfacePixelFloat(surface, p.x, p.y, c.r, c.g, c.b, c.a));
}

inline void Surface::WritePixelFloat(const PointRaw& p, const FColorRaw& c)
{
  SDL::WriteSurfacePixelFloat(m_resource, p, c);
}

/// @}

/**
 * @defgroup CategoryVideo Display and Window Management
 *
 * SDL's video subsystem is largely interested in abstracting window
 * management from the underlying operating system. You can create windows,
 * manage them in various ways, set them fullscreen, and get events when
 * interesting things happen with them, such as the mouse or keyboard
 * interacting with a window.
 *
 * The video subsystem is also interested in abstracting away some
 * platform-specific differences in OpenGL: context creation, swapping
 * buffers, etc. This may be crucial to your app, but also you are not
 * required to use OpenGL at all. In fact, SDL can provide rendering to those
 * windows as well, either with an easy-to-use
 * [2D API](https://wiki.libsdl.org/SDL3/CategoryRender)
 * or with a more-powerful
 * [GPU API](https://wiki.libsdl.org/SDL3/CategoryGPU)
 * . Of course, it can simply get out of your way and give you the window
 * handles you need to use Vulkan, Direct3D, Metal, or whatever else you like
 * directly, too.
 *
 * The video subsystem covers a lot of functionality, out of necessity, so it
 * is worth perusing the list of functions just to see what's available, but
 * most apps can get by with simply creating a window and listening for
 * events, so start with Window.Window() and PollEvent().
 *
 * @{
 */

using DisplayID = SDL_DisplayID;

// Forward decl
struct Window;

using WindowRaw = SDL_Window*;

// Forward decl
struct WindowRef;

/// Safely wrap Window for non owning parameters
struct WindowParam
{
  WindowRaw value; ///< parameter's WindowRaw

  /// Constructs from WindowRaw
  constexpr WindowParam(WindowRaw value)
    : value(value)
  {
  }

  /// Constructs null/invalid
  constexpr WindowParam(std::nullptr_t _ = nullptr)
    : value(nullptr)
  {
  }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!value; }

  /// Comparison
  constexpr auto operator<=>(const WindowParam& other) const = default;

  /// Converts to underlying WindowRaw
  constexpr operator WindowRaw() const { return value; }
};

// Forward decl
struct GLContext;

using GLContextRaw = SDL_GLContext;

// Forward decl
struct GLContextScoped;

/// Safely wrap GLContext for non owning parameters
struct GLContextParam
{
  GLContextRaw value; ///< parameter's GLContextRaw

  /// Constructs from GLContextRaw
  constexpr GLContextParam(GLContextRaw value)
    : value(value)
  {
  }

  /// Constructs null/invalid
  constexpr GLContextParam(std::nullptr_t _ = nullptr)
    : value(nullptr)
  {
  }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!value; }

  /// Comparison
  constexpr auto operator<=>(const GLContextParam& other) const = default;

  /// Converts to underlying GLContextRaw
  constexpr operator GLContextRaw() const { return value; }
};

// Forward decl
struct RendererRef;

/**
 * Display orientation values; the way a display is rotated.
 *
 * @since This enum is available since SDL 3.2.0.
 */
using DisplayOrientation = SDL_DisplayOrientation;

constexpr DisplayOrientation ORIENTATION_UNKNOWN =
  SDL_ORIENTATION_UNKNOWN; ///< The display orientation can't be determined.

/**
 * The display is in landscape mode, with the right side up, relative to
 * portrait mode.
 */
constexpr DisplayOrientation ORIENTATION_LANDSCAPE = SDL_ORIENTATION_LANDSCAPE;

/**
 * The display is in landscape mode, with the left side up, relative to portrait
 * mode.
 */
constexpr DisplayOrientation ORIENTATION_LANDSCAPE_FLIPPED =
  SDL_ORIENTATION_LANDSCAPE_FLIPPED;

constexpr DisplayOrientation ORIENTATION_PORTRAIT =
  SDL_ORIENTATION_PORTRAIT; ///< The display is in portrait mode.

constexpr DisplayOrientation ORIENTATION_PORTRAIT_FLIPPED =
  SDL_ORIENTATION_PORTRAIT_FLIPPED; ///< The display is in portrait mode, upside
                                    ///< down.

/**
 * The structure that defines a display mode.
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @sa Display.GetFullscreenModes
 * @sa Display.GetDesktopMode
 * @sa Display.GetCurrentMode
 * @sa Window.SetFullscreenMode
 * @sa Window.GetFullscreenMode
 */
using DisplayMode = SDL_DisplayMode;

/**
 * This is a unique ID for a display for the time it is connected to the
 * system, and is never reused for the lifetime of the application.
 *
 * If the display is disconnected and reconnected, it will get a new ID.
 *
 * The value 0 is an invalid ID.
 *
 * @since This datatype is available since SDL 3.2.0.
 */
class Display
{
  DisplayID m_displayID;

public:
  /**
   * Wraps Display.
   *
   * @param displayID the value to be wrapped
   */
  constexpr Display(DisplayID displayID = {})
    : m_displayID(displayID)
  {
  }

  /// Default comparison operator
  constexpr bool operator==(const Display& other) const = default;

  /// Compares with the underlying type
  constexpr bool operator==(DisplayID displayID) const
  {
    return operator==(Display(displayID));
  }

  /**
   * Unwraps to the underlying Display.
   *
   * @returns the underlying DisplayID.
   */
  constexpr operator DisplayID() const { return m_displayID; }

  /**
   * Check if valid.
   *
   * @returns True if valid state, false otherwise.
   */
  constexpr explicit operator bool() const { return m_displayID != 0; }

  /**
   * Get a list of currently connected displays.
   *
   * @param count a pointer filled in with the number of displays returned, may
   *              be nullptr.
   * @returns a 0 terminated array of display instance IDs or nullptr on
   * failure; call GetError() for more information. This should be freed with
   * free() when it is no longer needed.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  static OwnArray<DisplayID> GetAll();

  /**
   * Return the primary display.
   *
   * @returns the instance ID of the primary display on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Display.GetAll
   */
  static Display GetPrimary();

  /**
   * Get the properties associated with a display.
   *
   * The following read-only properties are provided by SDL:
   *
   * - `prop::Display.HDR_ENABLED_BOOLEAN`: true if the display has HDR
   *   headroom above the SDR white point. This is for informational and
   *   diagnostic purposes only, as not all platforms provide this information
   *   at the display level.
   *
   * On KMS/DRM:
   *
   * - `prop::Display.KMSDRM_PANEL_ORIENTATION_NUMBER`: the "panel
   *   orientation" property for the display in degrees of clockwise rotation.
   *   Note that this is provided only as a hint, and the application is
   *   responsible for any coordinate transformations needed to conform to the
   *   requested display orientation.
   *
   * @returns a valid property ID on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  PropertiesRef GetProperties() const;

  /**
   * Get the name of a display in UTF-8 encoding.
   *
   * @returns the name of a display or nullptr on failure; call GetError() for
   *          more information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Display.GetAll
   */
  const char* GetName() const;

  /**
   * Get the desktop area represented by a display.
   *
   * The primary display is often located at (0,0), but may be placed at a
   * different location depending on monitor layout.
   *
   * @param rect the Rect structure filled in with the display bounds.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Display.GetUsableBounds
   * @sa Display.GetAll
   */
  Rect GetBounds() const;

  /**
   * Get the usable desktop area represented by a display, in screen
   * coordinates.
   *
   * This is the same area as Display.GetBounds() reports, but with portions
   * reserved by the system removed. For example, on Apple's macOS, this
   * subtracts the area occupied by the menu bar and dock.
   *
   * Setting a window to be fullscreen generally bypasses these unusable areas,
   * so these are good guidelines for the maximum space available to a
   * non-fullscreen window.
   *
   * @param displayID the instance ID of the display to query.
   * @param rect the Rect structure filled in with the display bounds.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Display.GetBounds
   * @sa Display.GetAll
   */
  Rect GetUsableBounds() const;

  /**
   * Get the orientation of a display when it is unrotated.
   *
   * @returns the DisplayOrientation enum value of the display, or
   *          `ORIENTATION_UNKNOWN` if it isn't available.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Display.GetAll
   */
  DisplayOrientation GetNaturalOrientation() const;

  /**
   * Get the orientation of a display.
   *
   * @returns the DisplayOrientation enum value of the display, or
   *          `ORIENTATION_UNKNOWN` if it isn't available.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Display.GetAll
   */
  DisplayOrientation GetCurrentOrientation() const;

  /**
   * Get the content scale of a display.
   *
   * The content scale is the expected scale for content based on the DPI
   * settings of the display. For example, a 4K display might have a 2.0 (200%)
   * display scale, which means that the user expects UI elements to be twice as
   * big on this display, to aid in readability.
   *
   * After window creation, Window.GetDisplayScale() should be used to query
   * the content scale factor for individual windows instead of querying the
   * display for a window and calling this function, as the per-window content
   * scale factor may differ from the base value of the display it is on,
   * particularly on high-DPI and/or multi-monitor desktop configurations.
   *
   * @returns the content scale of the display, or 0.0f on failure; call
   *          GetError() for more information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetDisplayScale
   * @sa Display.GetAll
   */
  float GetContentScale() const;

  /**
   * Get a list of fullscreen display modes available on a display.
   *
   * The display modes are sorted in this priority:
   *
   * - w -> largest to smallest
   * - h -> largest to smallest
   * - bits per pixel -> more colors to fewer colors
   * - packed pixel layout -> largest to smallest
   * - refresh rate -> highest to lowest
   * - pixel density -> lowest to highest
   *
   * @param count a pointer filled in with the number of display modes returned,
   *              may be nullptr.
   * @returns a nullptr terminated array of display mode pointers or nullptr on
   *          failure; call GetError() for more information. This is a
   *          single allocation that should be freed with free() when it is
   *          no longer needed.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Display.GetAll
   */
  OwnArray<DisplayMode*> GetFullscreenModes() const;

  /**
   * Get the closest match to the requested display mode.
   *
   * The available display modes are scanned and `closest` is filled in with the
   * closest mode matching the requested mode and returned. The mode format and
   * refresh rate default to the desktop mode if they are set to 0. The modes
   * are scanned with size being first priority, format being second priority,
   * and finally checking the refresh rate. If all the available modes are too
   * small, then false is returned.
   *
   * @param size the width and height in pixels of the desired display mode.
   * @param refresh_rate the refresh rate of the desired display mode, or 0.0f
   *                     for the desktop refresh rate.
   * @param include_high_density_modes boolean to include high density modes in
   *                                   the search.
   * @param closest a pointer filled in with the closest display mode equal to
   *                or larger than the desired mode.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Display.GetAll
   * @sa Display.GetFullscreenModes
   */
  DisplayMode GetClosestFullscreenMode(const PointRaw& size,
                                       float refresh_rate,
                                       bool include_high_density_modes) const;

  /**
   * Get information about the desktop's display mode.
   *
   * There's a difference between this function and Display.GetCurrentMode()
   * when SDL runs fullscreen and has changed the resolution. In that case this
   * function will return the previous native display mode, and not the current
   * display mode.
   *
   * @returns a pointer to the desktop display mode or nullptr on failure; call
   *          GetError() for more information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Display.GetCurrentMode
   * @sa Display.GetAll
   */
  const DisplayMode* GetDesktopMode() const;

  /**
   * Get information about the current display mode.
   *
   * There's a difference between this function and Display.GetDesktopMode()
   * when SDL runs fullscreen and has changed the resolution. In that case this
   * function will return the current display mode, and not the previous native
   * display mode.
   *
   * @returns a pointer to the desktop display mode or nullptr on failure; call
   *          GetError() for more information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Display.GetDesktopMode
   * @sa Display.GetAll
   */
  const DisplayMode* GetCurrentMode() const;

  /**
   * Get the display containing a point.
   *
   * @param point the point to query.
   * @returns the instance ID of the display containing the point or 0 on
   *          failure; call GetError() for more information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Display.GetBounds
   * @sa Display.GetAll
   */
  static Display GetForPoint(const PointRaw& point);

  /**
   * Get the display primarily containing a rect.
   *
   * @param rect the rect to query.
   * @returns the instance ID of the display entirely containing the rect or
   *          closest to the center of the rect on success or 0 on failure; call
   *          GetError() for more information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Display.GetBounds
   * @sa Display.GetAll
   */
  static Display GetForRect(const RectRaw& rect);
};

/**
 * This is a unique ID for a window.
 *
 * The value 0 is an invalid ID.
 *
 * @since This datatype is available since SDL 3.2.0.
 */
using WindowID = SDL_WindowID;

namespace prop::Global {

/**
 * The pointer to the global `wl_display` object used by the Wayland video
 * backend.
 *
 * Can be set before the video subsystem is initialized to import an external
 * `wl_display` object from an application or toolkit for use in SDL, or read
 * after initialization to export the `wl_display` used by the Wayland video
 * backend. Setting this property after the video subsystem has been
 * initialized has no effect, and reading it when the video subsystem is
 * uninitialized will either return the user provided value, if one was set
 * prior to initialization, or nullptr. See docs/README-wayland.md for more
 * information.
 */
constexpr auto VIDEO_WAYLAND_WL_DISPLAY_POINTER =
  SDL_PROP_GLOBAL_VIDEO_WAYLAND_WL_DISPLAY_POINTER;

} // namespace prop::Global

/**
 * System theme.
 *
 * @since This enum is available since SDL 3.2.0.
 */
using SystemTheme = SDL_SystemTheme;

constexpr SystemTheme SYSTEM_THEME_UNKNOWN =
  SDL_SYSTEM_THEME_UNKNOWN; ///< Unknown system theme.

constexpr SystemTheme SYSTEM_THEME_LIGHT =
  SDL_SYSTEM_THEME_LIGHT; ///< Light colored system theme.

constexpr SystemTheme SYSTEM_THEME_DARK =
  SDL_SYSTEM_THEME_DARK; ///< Dark colored system theme.

/**
 * Internal display mode data.
 *
 * This lives as a field in DisplayMode, as opaque data.
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @sa DisplayMode
 */
using DisplayModeData = SDL_DisplayModeData;

/**
 * The flags on a window.
 *
 * These cover a lot of true/false, or on/off, window state. Some of it is
 * immutable after being set through Window.Window(), some of it can be
 * changed on existing windows by the app, and some of it might be altered by
 * the user or system outside of the app's control.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa Window.GetFlags
 */
using WindowFlags = Uint64;

constexpr WindowFlags WINDOW_FULLSCREEN =
  SDL_WINDOW_FULLSCREEN; ///< window is in fullscreen mode

constexpr WindowFlags WINDOW_OPENGL =
  SDL_WINDOW_OPENGL; ///< window usable with OpenGL context

constexpr WindowFlags WINDOW_OCCLUDED =
  SDL_WINDOW_OCCLUDED; ///< window is occluded

/**
 * window is neither mapped onto the desktop nor shown in the
 * taskbar/dock/window list; Window.Show() is required for it to become visible
 */
constexpr WindowFlags WINDOW_HIDDEN = SDL_WINDOW_HIDDEN;

constexpr WindowFlags WINDOW_BORDERLESS =
  SDL_WINDOW_BORDERLESS; ///< no window decoration

constexpr WindowFlags WINDOW_RESIZABLE =
  SDL_WINDOW_RESIZABLE; ///< window can be resized

constexpr WindowFlags WINDOW_MINIMIZED =
  SDL_WINDOW_MINIMIZED; ///< window is minimized

constexpr WindowFlags WINDOW_MAXIMIZED =
  SDL_WINDOW_MAXIMIZED; ///< window is maximized

constexpr WindowFlags WINDOW_MOUSE_GRABBED =
  SDL_WINDOW_MOUSE_GRABBED; ///< window has grabbed mouse input

constexpr WindowFlags WINDOW_INPUT_FOCUS =
  SDL_WINDOW_INPUT_FOCUS; ///< window has input focus

constexpr WindowFlags WINDOW_MOUSE_FOCUS =
  SDL_WINDOW_MOUSE_FOCUS; ///< window has mouse focus

constexpr WindowFlags WINDOW_EXTERNAL =
  SDL_WINDOW_EXTERNAL; ///< window not created by SDL

constexpr WindowFlags WINDOW_MODAL = SDL_WINDOW_MODAL; ///< window is modal

/// window uses high pixel density back buffer if possible
constexpr WindowFlags WINDOW_HIGH_PIXEL_DENSITY = SDL_WINDOW_HIGH_PIXEL_DENSITY;

/// window has mouse captured (unrelated to MOUSE_GRABBED)
constexpr WindowFlags WINDOW_MOUSE_CAPTURE = SDL_WINDOW_MOUSE_CAPTURE;

constexpr WindowFlags WINDOW_MOUSE_RELATIVE_MODE =
  SDL_WINDOW_MOUSE_RELATIVE_MODE; ///< window has relative mode enabled

constexpr WindowFlags WINDOW_ALWAYS_ON_TOP =
  SDL_WINDOW_ALWAYS_ON_TOP; ///< window should always be above others

/**
 * window should be treated as a utility window, not showing in the task bar and
 * window list
 */
constexpr WindowFlags WINDOW_UTILITY = SDL_WINDOW_UTILITY;

/**
 * window should be treated as a tooltip and does not get mouse or keyboard
 * focus, requires a parent window
 */
constexpr WindowFlags WINDOW_TOOLTIP = SDL_WINDOW_TOOLTIP;

/// window should be treated as a popup menu, requires a parent window
constexpr WindowFlags WINDOW_POPUP_MENU = SDL_WINDOW_POPUP_MENU;

constexpr WindowFlags WINDOW_KEYBOARD_GRABBED =
  SDL_WINDOW_KEYBOARD_GRABBED; ///< window has grabbed keyboard input

constexpr WindowFlags WINDOW_VULKAN =
  SDL_WINDOW_VULKAN; ///< window usable for Vulkan surface

constexpr WindowFlags WINDOW_METAL =
  SDL_WINDOW_METAL; ///< window usable for Metal view

constexpr WindowFlags WINDOW_TRANSPARENT =
  SDL_WINDOW_TRANSPARENT; ///< window with transparent buffer

constexpr WindowFlags WINDOW_NOT_FOCUSABLE =
  SDL_WINDOW_NOT_FOCUSABLE; ///< window should not be focusable

/**
 * Window flash operation.
 *
 * @since This enum is available since SDL 3.2.0.
 */
using FlashOperation = SDL_FlashOperation;

constexpr FlashOperation FLASH_CANCEL =
  SDL_FLASH_CANCEL; ///< Cancel any window flash state.

constexpr FlashOperation FLASH_BRIEFLY =
  SDL_FLASH_BRIEFLY; ///< Flash the window briefly to get attention.

constexpr FlashOperation FLASH_UNTIL_FOCUSED =
  SDL_FLASH_UNTIL_FOCUSED; ///< Flash the window until it gets focus.

/**
 * Possible return values from the HitTest callback.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa HitTest
 * @sa HitTestCB
 */
using HitTestResult = SDL_HitTestResult;

constexpr HitTestResult HITTEST_NORMAL =
  SDL_HITTEST_NORMAL; ///< Region is normal.  No special properties.

constexpr HitTestResult HITTEST_DRAGGABLE =
  SDL_HITTEST_DRAGGABLE; ///< Region can drag entire window.

constexpr HitTestResult HITTEST_RESIZE_TOPLEFT =
  SDL_HITTEST_RESIZE_TOPLEFT; ///< Region is the resizable top-left corner
                              ///< border.

constexpr HitTestResult HITTEST_RESIZE_TOP =
  SDL_HITTEST_RESIZE_TOP; ///< Region is the resizable top border.

constexpr HitTestResult HITTEST_RESIZE_TOPRIGHT =
  SDL_HITTEST_RESIZE_TOPRIGHT; ///< Region is the resizable top-right corner
                               ///< border.

constexpr HitTestResult HITTEST_RESIZE_RIGHT =
  SDL_HITTEST_RESIZE_RIGHT; ///< Region is the resizable right border.

/// Region is the resizable bottom-right corner border.
constexpr HitTestResult HITTEST_RESIZE_BOTTOMRIGHT =
  SDL_HITTEST_RESIZE_BOTTOMRIGHT;

constexpr HitTestResult HITTEST_RESIZE_BOTTOM =
  SDL_HITTEST_RESIZE_BOTTOM; ///< Region is the resizable bottom border.

constexpr HitTestResult HITTEST_RESIZE_BOTTOMLEFT =
  SDL_HITTEST_RESIZE_BOTTOMLEFT; ///< Region is the resizable bottom-left corner
                                 ///< border.

constexpr HitTestResult HITTEST_RESIZE_LEFT =
  SDL_HITTEST_RESIZE_LEFT; ///< Region is the resizable left border.

/**
 * Callback used for hit-testing.
 *
 * @param win the Window where hit-testing was set on.
 * @param area an Point which should be hit-tested.
 * @param data what was passed as `callback_data` to Window.SetHitTest().
 * @returns an HitTestResult value.
 *
 * @sa Window.SetHitTest
 */
using HitTest = SDL_HitTest;

/**
 * Callback used for hit-testing.
 *
 * @param win the WindowRef where hit-testing was set on.
 * @param area a Point const reference which should be hit-tested.
 * @returns an SDL::HitTestResult value.
 *
 * @cat listener-callback
 *
 * @sa HitTest
 * @sa Window.SetHitTest
 */
using HitTestCB =
  std::function<HitTestResult(WindowRaw window, const Point& area)>;

/**
 * The struct used as an opaque handle to a window.
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @cat resource
 *
 * @sa Window.Window
 */
class Window
{
  WindowRaw m_resource = nullptr;

public:
  /// Default ctor
  constexpr Window() = default;

  /**
   * Constructs from WindowParam.
   *
   * @param resource a WindowRaw to be wrapped.
   *
   * This assumes the ownership, call release() if you need to take back.
   */
  constexpr explicit Window(const WindowRaw resource)
    : m_resource(resource)
  {
  }

  /// Copy constructor
  constexpr Window(const Window& other) = delete;

  /// Move constructor
  constexpr Window(Window&& other)
    : Window(other.release())
  {
  }

  constexpr Window(const WindowRef& other) = delete;

  constexpr Window(WindowRef&& other) = delete;

  /**
   * Create a window with the specified dimensions and flags.
   *
   * The window size is a request and may be different than expected based on
   * the desktop layout and window manager policies. Your application should be
   * prepared to handle a window of any size.
   *
   * `flags` may be any of the following OR'd together:
   *
   * - `WINDOW_FULLSCREEN`: fullscreen window at desktop resolution
   * - `WINDOW_OPENGL`: window usable with an OpenGL context
   * - `WINDOW_OCCLUDED`: window partially or completely obscured by another
   *   window
   * - `WINDOW_HIDDEN`: window is not visible
   * - `WINDOW_BORDERLESS`: no window decoration
   * - `WINDOW_RESIZABLE`: window can be resized
   * - `WINDOW_MINIMIZED`: window is minimized
   * - `WINDOW_MAXIMIZED`: window is maximized
   * - `WINDOW_MOUSE_GRABBED`: window has grabbed mouse focus
   * - `WINDOW_INPUT_FOCUS`: window has input focus
   * - `WINDOW_MOUSE_FOCUS`: window has mouse focus
   * - `WINDOW_EXTERNAL`: window not created by SDL
   * - `WINDOW_MODAL`: window is modal
   * - `WINDOW_HIGH_PIXEL_DENSITY`: window uses high pixel density back
   *   buffer if possible
   * - `WINDOW_MOUSE_CAPTURE`: window has mouse captured (unrelated to
   *   MOUSE_GRABBED)
   * - `WINDOW_ALWAYS_ON_TOP`: window should always be above others
   * - `WINDOW_UTILITY`: window should be treated as a utility window, not
   *   showing in the task bar and window list
   * - `WINDOW_TOOLTIP`: window should be treated as a tooltip and does not
   *   get mouse or keyboard focus, requires a parent window
   * - `WINDOW_POPUP_MENU`: window should be treated as a popup menu,
   *   requires a parent window
   * - `WINDOW_KEYBOARD_GRABBED`: window has grabbed keyboard input
   * - `WINDOW_VULKAN`: window usable with a Vulkan instance
   * - `WINDOW_METAL`: window usable with a Metal instance
   * - `WINDOW_TRANSPARENT`: window with transparent buffer
   * - `WINDOW_NOT_FOCUSABLE`: window should not be focusable
   *
   * The Window is implicitly shown if WINDOW_HIDDEN is not set.
   *
   * On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist
   * property to YES, otherwise you will not receive a High-DPI OpenGL canvas.
   *
   * The window pixel size may differ from its window coordinate size if the
   * window is on a high pixel density display. Use Window.GetSize() to query
   * the client area's size in window coordinates, and
   * Window.GetSizeInPixels() or Renderer.GetOutputSize() to query the
   * drawable size in pixels. Note that the drawable size can vary after the
   * window is created and should be queried again if you get an
   * EVENT_WINDOW_PIXEL_SIZE_CHANGED event.
   *
   * If the window is created with any of the WINDOW_OPENGL or
   * WINDOW_VULKAN flags, then the corresponding LoadLibrary function
   * (GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the
   * corresponding UnloadLibrary function is called by Window.Destroy().
   *
   * If WINDOW_VULKAN is specified and there isn't a working Vulkan driver,
   * Window.Window() will fail, because SDL_Vulkan_LoadLibrary() will fail.
   *
   * If WINDOW_METAL is specified on an OS that does not support Metal,
   * Window.Window() will fail.
   *
   * If you intend to use this window with an Renderer, you should use
   * CreateWindowAndRenderer() instead of this function, to avoid window
   * flicker.
   *
   * On non-Apple devices, SDL requires you to either not link to the Vulkan
   * loader or link to a dynamic library version. This limitation may be removed
   * in a future version of SDL.
   *
   * @param title the title of the window, in UTF-8 encoding.
   * @param size the width and height of the window.
   * @param flags 0, or one or more WindowFlags OR'd together.
   * @post the window that was created or nullptr on failure; call
   *          GetError() for more information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa CreateWindowAndRenderer
   * @sa Window.Window
   * @sa Window.Window
   * @sa Window.Destroy
   */
  Window(StringParam title, const PointRaw& size, WindowFlags flags = 0)
    : m_resource(SDL_CreateWindow(title, size.x, size.y, flags))
  {
  }

  /**
   * Create a child popup window of the specified parent window.
   *
   * The window size is a request and may be different than expected based on
   * the desktop layout and window manager policies. Your application should be
   * prepared to handle a window of any size.
   *
   * The flags parameter **must** contain at least one of the following:
   *
   * - `WINDOW_TOOLTIP`: The popup window is a tooltip and will not pass any
   *   input events.
   * - `WINDOW_POPUP_MENU`: The popup window is a popup menu. The topmost
   *   popup menu will implicitly gain the keyboard focus.
   *
   * The following flags are not relevant to popup window creation and will be
   * ignored:
   *
   * - `WINDOW_MINIMIZED`
   * - `WINDOW_MAXIMIZED`
   * - `WINDOW_FULLSCREEN`
   * - `WINDOW_BORDERLESS`
   *
   * The following flags are incompatible with popup window creation and will
   * cause it to fail:
   *
   * - `WINDOW_UTILITY`
   * - `WINDOW_MODAL`
   *
   * The parent parameter **must** be non-null and a valid window. The parent of
   * a popup window can be either a regular, toplevel window, or another popup
   * window.
   *
   * Popup windows cannot be minimized, maximized, made fullscreen, raised,
   * flash, be made a modal window, be the parent of a toplevel window, or grab
   * the mouse and/or keyboard. Attempts to do so will fail.
   *
   * Popup windows implicitly do not have a border/decorations and do not appear
   * on the taskbar/dock or in lists of windows such as alt-tab menus.
   *
   * By default, popup window positions will automatically be constrained to
   * keep the entire window within display bounds. This can be overridden with
   * the `prop::Window.CREATE_CONSTRAIN_POPUP_BOOLEAN` property.
   *
   * By default, popup menus will automatically grab keyboard focus from the
   * parent when shown. This behavior can be overridden by setting the
   * `WINDOW_NOT_FOCUSABLE` flag, setting the
   * `prop::Window.CREATE_FOCUSABLE_BOOLEAN` property to false, or toggling it
   * after creation via the `Window.SetFocusable()` function.
   *
   * If a parent window is hidden or destroyed, any child popup windows will be
   * recursively hidden or destroyed as well. Child popup windows not explicitly
   * hidden will be restored when the parent is shown.
   *
   * @param parent the parent of the window, must not be nullptr.
   * @param offset the x, y position of the popup window relative to the origin
   *               of the parent.
   * @param size the width and height of the window.
   * @param flags WINDOW_TOOLTIP or WINDOW_POPUP_MENU, and zero or more
   *              additional WindowFlags OR'd together.
   * @post the window that was created or nullptr on failure; call
   *          GetError() for more information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.Window
   * @sa Window.Window
   * @sa Window.Destroy
   * @sa Window.GetParent
   */
  Window(WindowParam parent,
         const PointRaw& offset,
         const PointRaw& size,
         WindowFlags flags = 0)
    : m_resource(SDL_CreatePopupWindow(parent,
                                       offset.x,
                                       offset.y,
                                       size.x,
                                       size.y,
                                       flags))
  {
  }

  /**
   * Create a window with the specified properties.
   *
   * The window size is a request and may be different than expected based on
   * the desktop layout and window manager policies. Your application should be
   * prepared to handle a window of any size.
   *
   * These are the supported properties:
   *
   * - `prop::Window.CREATE_ALWAYS_ON_TOP_BOOLEAN`: true if the window should
   *   be always on top
   * - `prop::Window.CREATE_BORDERLESS_BOOLEAN`: true if the window has no
   *   window decoration
   * - `prop::Window.CREATE_CONSTRAIN_POPUP_BOOLEAN`: true if the "tooltip" and
   *   "menu" window types should be automatically constrained to be entirely
   * within display bounds (default), false if no constraints on the position
   * are desired.
   * - `prop::Window.CREATE_EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN`: true if the
   *   window will be used with an externally managed graphics context.
   * - `prop::Window.CREATE_FOCUSABLE_BOOLEAN`: true if the window should
   *   accept keyboard input (defaults true)
   * - `prop::Window.CREATE_FULLSCREEN_BOOLEAN`: true if the window should
   *   start in fullscreen mode at desktop resolution
   * - `prop::Window.CREATE_HEIGHT_NUMBER`: the height of the window
   * - `prop::Window.CREATE_HIDDEN_BOOLEAN`: true if the window should start
   *   hidden
   * - `prop::Window.CREATE_HIGH_PIXEL_DENSITY_BOOLEAN`: true if the window
   *   uses a high pixel density buffer if possible
   * - `prop::Window.CREATE_MAXIMIZED_BOOLEAN`: true if the window should
   *   start maximized
   * - `prop::Window.CREATE_MENU_BOOLEAN`: true if the window is a popup menu
   * - `prop::Window.CREATE_METAL_BOOLEAN`: true if the window will be used
   *   with Metal rendering
   * - `prop::Window.CREATE_MINIMIZED_BOOLEAN`: true if the window should
   *   start minimized
   * - `prop::Window.CREATE_MODAL_BOOLEAN`: true if the window is modal to
   *   its parent
   * - `prop::Window.CREATE_MOUSE_GRABBED_BOOLEAN`: true if the window starts
   *   with grabbed mouse focus
   * - `prop::Window.CREATE_OPENGL_BOOLEAN`: true if the window will be used
   *   with OpenGL rendering
   * - `prop::Window.CREATE_PARENT_POINTER`: an Window that will be the
   *   parent of this window, required for windows with the "tooltip", "menu",
   *   and "modal" properties
   * - `prop::Window.CREATE_RESIZABLE_BOOLEAN`: true if the window should be
   *   resizable
   * - `prop::Window.CREATE_TITLE_STRING`: the title of the window, in UTF-8
   *   encoding
   * - `prop::Window.CREATE_TRANSPARENT_BOOLEAN`: true if the window show
   *   transparent in the areas with alpha of 0
   * - `prop::Window.CREATE_TOOLTIP_BOOLEAN`: true if the window is a tooltip
   * - `prop::Window.CREATE_UTILITY_BOOLEAN`: true if the window is a utility
   *   window, not showing in the task bar and window list
   * - `prop::Window.CREATE_VULKAN_BOOLEAN`: true if the window will be used
   *   with Vulkan rendering
   * - `prop::Window.CREATE_WIDTH_NUMBER`: the width of the window
   * - `prop::Window.CREATE_X_NUMBER`: the x position of the window, or
   *   `SDL_WINDOWPOS_CENTERED`, defaults to `SDL_WINDOWPOS_UNDEFINED`. This is
   *   relative to the parent for windows with the "tooltip" or "menu" property
   *   set.
   * - `prop::Window.CREATE_Y_NUMBER`: the y position of the window, or
   *   `SDL_WINDOWPOS_CENTERED`, defaults to `SDL_WINDOWPOS_UNDEFINED`. This is
   *   relative to the parent for windows with the "tooltip" or "menu" property
   *   set.
   *
   * These are additional supported properties on macOS:
   *
   * - `prop::Window.CREATE_COCOA_WINDOW_POINTER`: the
   *   `(__unsafe_unretained)` NSWindow associated with the window, if you want
   *   to wrap an existing window.
   * - `prop::Window.CREATE_COCOA_VIEW_POINTER`: the `(__unsafe_unretained)`
   *   NSView associated with the window, defaults to `[window contentView]`
   *
   * These are additional supported properties on Wayland:
   *
   * - `prop::Window.CREATE_WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN` - true if
   *   the application wants to use the Wayland surface for a custom role and
   *   does not want it attached to an XDG toplevel window. See
   *   [README/wayland](README/wayland) for more information on using custom
   *   surfaces.
   * - `prop::Window.CREATE_WAYLAND_CREATE_EGL_WINDOW_BOOLEAN` - true if the
   *   application wants an associated `wl_egl_window` object to be created and
   *   attached to the window, even if the window does not have the OpenGL
   *   property or `WINDOW_OPENGL` flag set.
   * - `prop::Window.CREATE_WAYLAND_WL_SURFACE_POINTER` - the wl_surface
   *   associated with the window, if you want to wrap an existing window. See
   *   [README/wayland](README/wayland) for more information.
   *
   * These are additional supported properties on Windows:
   *
   * - `prop::Window.CREATE_WIN32_HWND_POINTER`: the HWND associated with the
   *   window, if you want to wrap an existing window.
   * - `prop::Window.CREATE_WIN32_PIXEL_FORMAT_HWND_POINTER`: optional,
   *   another window to share pixel format with, useful for OpenGL windows
   *
   * These are additional supported properties with X11:
   *
   * - `prop::Window.CREATE_X11_WINDOW_NUMBER`: the X11 Window associated
   *   with the window, if you want to wrap an existing window.
   *
   * The window is implicitly shown if the "hidden" property is not set.
   *
   * Windows with the "tooltip" and "menu" properties are popup windows and have
   * the behaviors and guidelines outlined in Window.Window().
   *
   * If this window is being created to be used with an Renderer, you should
   * not add a graphics API specific property
   * (`prop::Window.CREATE_OPENGL_BOOLEAN`, etc), as SDL will handle that
   * internally when it chooses a renderer. However, SDL might need to recreate
   * your window at that point, which may cause the window to appear briefly,
   * and then flicker as it is recreated. The correct approach to this is to
   * create the window with the `prop::Window.CREATE_HIDDEN_BOOLEAN` property
   * set to true, then create the renderer, then show the window with
   * Window.Show().
   *
   * @param props the properties to use.
   * @post the window that was created or nullptr on failure; call
   *          GetError() for more information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Properties.Create
   * @sa Window.Window
   * @sa Window.Destroy
   */
  Window(PropertiesParam props)
    : m_resource(SDL_CreateWindowWithProperties(props))
  {
  }

  /// Destructor
  ~Window() { SDL_DestroyWindow(m_resource); }

  /// Assignment operator.
  Window& operator=(Window other)
  {
    std::swap(m_resource, other.m_resource);
    return *this;
  }

  /// Retrieves underlying WindowRaw.
  constexpr WindowRaw get() const { return m_resource; }

  /// Retrieves underlying WindowRaw and clear this.
  constexpr WindowRaw release()
  {
    auto r = m_resource;
    m_resource = nullptr;
    return r;
  }

  /// Comparison
  constexpr auto operator<=>(const Window& other) const = default;

  /// Comparison
  constexpr bool operator==(std::nullptr_t _) const { return !m_resource; }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!m_resource; }

  /// Converts to WindowParam
  constexpr operator WindowParam() const { return {m_resource}; }

  /**
   * Destroy a window.
   *
   * Any child windows owned by the window will be recursively destroyed as
   * well.
   *
   * Note that on some platforms, the visible window may not actually be removed
   * from the screen until the SDL event loop is pumped again, even though the
   * Window is no longer valid after this call.
   *
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.Window
   * @sa Window.Window
   * @sa Window.Window
   */
  void Destroy();

  /**
   * Get the display associated with a window.
   *
   * @returns the instance ID of the display containing the center of the window
   *          on success or 0 on failure; call GetError() for more
   *          information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Display.GetBounds
   * @sa Display.GetAll
   */
  Display GetDisplay() const;

  /**
   * Get the pixel density of a window.
   *
   * This is a ratio of pixel size to window size. For example, if the window is
   * 1920x1080 and it has a high density back buffer of 3840x2160 pixels, it
   * would have a pixel density of 2.0.
   *
   * @returns the pixel density or 0.0f on failure; call GetError() for more
   *          information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetDisplayScale
   */
  float GetPixelDensity() const;

  /**
   * Get the content display scale relative to a window's pixel size.
   *
   * This is a combination of the window pixel density and the display content
   * scale, and is the expected scale for displaying content in this window. For
   * example, if a 3840x2160 window had a display scale of 2.0, the user expects
   * the content to take twice as many pixels and be the same physical size as
   * if it were being displayed in a 1920x1080 window with a display scale of
   * 1.0.
   *
   * Conceptually this value corresponds to the scale display setting, and is
   * updated when that setting is changed, or the window moves to a display with
   * a different scale setting.
   *
   * @returns the display scale, or 0.0f on failure; call GetError() for
   *          more information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  float GetDisplayScale() const;

  /**
   * Set the display mode to use when a window is visible and fullscreen.
   *
   * This only affects the display mode used when the window is fullscreen. To
   * change the window size when the window is not fullscreen, use
   * Window.SetSize().
   *
   * If the window is currently in the fullscreen state, this request is
   * asynchronous on some windowing systems and the new mode dimensions may not
   * be applied immediately upon the return of this function. If an immediate
   * change is required, call Window.Sync() to block until the changes have
   * taken effect.
   *
   * When the new mode takes effect, an EVENT_WINDOW_RESIZED and/or an
   * EVENT_WINDOW_PIXEL_SIZE_CHANGED event will be emitted with the new mode
   * dimensions.
   *
   * @param mode a pointer to the display mode to use, which can be nullptr for
   *             borderless fullscreen desktop mode, or one of the fullscreen
   *             modes returned by Display.GetFullscreenModes() to set an
   *             exclusive fullscreen mode.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetFullscreenMode
   * @sa Window.SetFullscreen
   * @sa Window.Sync
   */
  void SetFullscreenMode(OptionalRef<const DisplayMode> mode);

  /**
   * Query the display mode to use when a window is visible at fullscreen.
   *
   * @returns a pointer to the exclusive fullscreen mode to use or nullptr for
   *          borderless fullscreen desktop mode.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.SetFullscreenMode
   * @sa Window.SetFullscreen
   */
  const DisplayMode* GetFullscreenMode() const;

  /**
   * Get the raw ICC profile data for the screen the window is currently on.
   *
   * @returns the raw ICC profile data on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  OwnPtr<void> GetICCProfile() const;

  /**
   * Get the pixel format associated with the window.
   *
   * @returns the pixel format of the window on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  PixelFormat GetPixelFormat() const;

  /**
   * Get the numeric ID of a window.
   *
   * The numeric ID is what WindowEvent references, and is necessary to map
   * these events to specific Window objects.
   *
   * @returns the ID of the window on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.FromID
   */
  WindowID GetID() const;

  /**
   * Get parent of a window.
   *
   * @returns the parent of the window on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.Window
   */
  WindowRef GetParent() const;

  /**
   * Get the properties associated with a window.
   *
   * The following read-only properties are provided by SDL:
   *
   * - `prop::Window.SHAPE_POINTER`: the surface associated with a shaped
   *   window
   * - `prop::Window.HDR_ENABLED_BOOLEAN`: true if the window has HDR
   *   headroom above the SDR white point. This property can change dynamically
   *   when EVENT_WINDOW_HDR_STATE_CHANGED is sent.
   * - `prop::Window.SDR_WHITE_LEVEL_FLOAT`: the value of SDR white in the
   *   COLORSPACE_SRGB_LINEAR colorspace. On Windows this corresponds to the
   *   SDR white level in scRGB colorspace, and on Apple platforms this is
   *   always 1.0 for EDR content. This property can change dynamically when
   *   EVENT_WINDOW_HDR_STATE_CHANGED is sent.
   * - `prop::Window.HDR_HEADROOM_FLOAT`: the additional high dynamic range
   *   that can be displayed, in terms of the SDR white point. When HDR is not
   *   enabled, this will be 1.0. This property can change dynamically when
   *   EVENT_WINDOW_HDR_STATE_CHANGED is sent.
   *
   * On Android:
   *
   * - `prop::Window.ANDROID_WINDOW_POINTER`: the ANativeWindow associated
   *   with the window
   * - `prop::Window.ANDROID_SURFACE_POINTER`: the EGLSurface associated with
   *   the window
   *
   * On iOS:
   *
   * - `prop::Window.UIKIT_WINDOW_POINTER`: the `(__unsafe_unretained)`
   *   UIWindow associated with the window
   * - `prop::Window.UIKIT_METAL_VIEW_TAG_NUMBER`: the NSInteger tag
   *   associated with metal views on the window
   * - `prop::Window.UIKIT_OPENGL_FRAMEBUFFER_NUMBER`: the OpenGL view's
   *   framebuffer object. It must be bound when rendering to the screen using
   *   OpenGL.
   * - `prop::Window.UIKIT_OPENGL_RENDERBUFFER_NUMBER`: the OpenGL view's
   *   renderbuffer object. It must be bound when GL_SwapWindow is called.
   * - `prop::Window.UIKIT_OPENGL_RESOLVE_FRAMEBUFFER_NUMBER`: the OpenGL
   *   view's resolve framebuffer, when MSAA is used.
   *
   * On KMS/DRM:
   *
   * - `prop::Window.KMSDRM_DEVICE_INDEX_NUMBER`: the device index associated
   *   with the window (e.g. the X in /dev/dri/cardX)
   * - `prop::Window.KMSDRM_DRM_FD_NUMBER`: the DRM FD associated with the
   *   window
   * - `prop::Window.KMSDRM_GBM_DEVICE_POINTER`: the GBM device associated
   *   with the window
   *
   * On macOS:
   *
   * - `prop::Window.COCOA_WINDOW_POINTER`: the `(__unsafe_unretained)`
   *   NSWindow associated with the window
   * - `prop::Window.COCOA_METAL_VIEW_TAG_NUMBER`: the NSInteger tag
   *   associated with metal views on the window
   *
   * On OpenVR:
   *
   * - `prop::Window.OPENVR_OVERLAY_ID`: the OpenVR Overlay Handle ID for the
   *   associated overlay window.
   *
   * On Vivante:
   *
   * - `prop::Window.VIVANTE_DISPLAY_POINTER`: the EGLNativeDisplayType
   *   associated with the window
   * - `prop::Window.VIVANTE_WINDOW_POINTER`: the EGLNativeWindowType
   *   associated with the window
   * - `prop::Window.VIVANTE_SURFACE_POINTER`: the EGLSurface associated with
   *   the window
   *
   * On Windows:
   *
   * - `prop::Window.WIN32_HWND_POINTER`: the HWND associated with the window
   * - `prop::Window.WIN32_HDC_POINTER`: the HDC associated with the window
   * - `prop::Window.WIN32_INSTANCE_POINTER`: the HINSTANCE associated with
   *   the window
   *
   * On Wayland:
   *
   * Note: The `xdg_*` window objects do not internally persist across window
   * show/hide calls. They will be null if the window is hidden and must be
   * queried each time it is shown.
   *
   * - `prop::Window.WAYLAND_DISPLAY_POINTER`: the wl_display associated with
   *   the window
   * - `prop::Window.WAYLAND_SURFACE_POINTER`: the wl_surface associated with
   *   the window
   * - `prop::Window.WAYLAND_VIEWPORT_POINTER`: the wp_viewport associated
   *   with the window
   * - `prop::Window.WAYLAND_EGL_WINDOW_POINTER`: the wl_egl_window
   *   associated with the window
   * - `prop::Window.WAYLAND_XDG_SURFACE_POINTER`: the xdg_surface associated
   *   with the window
   * - `prop::Window.WAYLAND_XDG_TOPLEVEL_POINTER`: the xdg_toplevel role
   *   associated with the window
   * - 'prop::Window.WAYLAND_XDG_TOPLEVEL_EXPORT_HANDLE_STRING': the export
   *   handle associated with the window
   * - `prop::Window.WAYLAND_XDG_POPUP_POINTER`: the xdg_popup role
   *   associated with the window
   * - `prop::Window.WAYLAND_XDG_POSITIONER_POINTER`: the xdg_positioner
   *   associated with the window, in popup mode
   *
   * On X11:
   *
   * - `prop::Window.X11_DISPLAY_POINTER`: the X11 Display associated with
   *   the window
   * - `prop::Window.X11_SCREEN_NUMBER`: the screen number associated with
   *   the window
   * - `prop::Window.X11_WINDOW_NUMBER`: the X11 Window associated with the
   *   window
   *
   * @returns a valid property ID on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  PropertiesRef GetProperties() const;

  /**
   * Get the window flags.
   *
   * @returns a mask of the WindowFlags associated with `window`.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.Window
   * @sa Window.Hide
   * @sa Window.Maximize
   * @sa Window.Minimize
   * @sa Window.SetFullscreen
   * @sa Window.SetMouseGrab
   * @sa Window.Show
   */
  WindowFlags GetFlags() const;

  /**
   * Set the title of a window.
   *
   * This string is expected to be in UTF-8 encoding.
   *
   * @param title the desired window title in UTF-8 format.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetTitle
   */
  void SetTitle(StringParam title);

  /**
   * Get the title of a window.
   *
   * @returns the title of the window in UTF-8 format or "" if there is no
   *          title.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.SetTitle
   */
  const char* GetTitle() const;

  /**
   * Set the icon for a window.
   *
   * If this function is passed a surface with alternate representations, the
   * surface will be interpreted as the content to be used for 100% display
   * scale, and the alternate representations will be used for high DPI
   * situations. For example, if the original surface is 32x32, then on a 2x
   * macOS display or 200% display scale on Windows, a 64x64 version of the
   * image will be used, if available. If a matching version of the image isn't
   * available, the closest larger size image will be downscaled to the
   * appropriate size and be used instead, if available. Otherwise, the closest
   * smaller image will be upscaled and be used instead.
   *
   * @param icon an Surface structure containing the icon for the window.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void SetIcon(SurfaceParam icon);

  /**
   * @brief Request the window's position and size to be set.
   *
   * @param rect the rect containing the new coordinates
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @sa WindowRef.SetPosition()
   * @sa WindowRef.SetSize()
   */
  void SetRect(Rect rect)
  {
    SetPosition(rect.GetTopLeft());
    SetSize(rect.GetSize());
  }

  /**
   * Get the position and client size of a window.
   *
   * This is the current position of the window as last reported by the
   * windowing system.
   *
   * The window pixel size may differ from its window coordinate size if the
   * window is on a high pixel density display. Use Window.GetSizeInPixels()
   * or RendererRef.GetOutputSize() to get the real client area size in pixels.
   *
   * @return Rect with the position and size
   * @throws Error on failure.
   */
  Rect GetRect() const { return Rect{GetPosition(), GetSize()}; }

  /**
   * Request that the window's position be set.
   *
   * If the window is in an exclusive fullscreen or maximized state, this
   * request has no effect.
   *
   * This can be used to reposition fullscreen-desktop windows onto a different
   * display, however, as exclusive fullscreen windows are locked to a specific
   * display, they can only be repositioned programmatically via
   * Window.SetFullscreenMode().
   *
   * On some windowing systems this request is asynchronous and the new
   * coordinates may not have have been applied immediately upon the return of
   * this function. If an immediate change is required, call Window.Sync() to
   * block until the changes have taken effect.
   *
   * When the window position changes, an EVENT_WINDOW_MOVED event will be
   * emitted with the window's new coordinates. Note that the new coordinates
   * may not match the exact coordinates requested, as some windowing systems
   * can restrict the position of the window in certain scenarios (e.g.
   * constraining the position so the window is always within desktop bounds).
   * Additionally, as this is just a request, it can be denied by the windowing
   * system.
   *
   * @param window the window to reposition.
   * @param p the coordinates of the window, or `SDL_WINDOWPOS_CENTERED` or
   *          `SDL_WINDOWPOS_UNDEFINED`.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetPosition
   * @sa Window.Sync
   */
  void SetPosition(const PointRaw& p);

  /**
   * Get the position of a window.
   *
   * This is the current position of the window as last reported by the
   * windowing system.
   *
   * @returns the position on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa SetPosition()
   * @sa SetPosition(int *, int *)
   */
  Point GetPosition() const
  {
    Point p;
    GetPosition(&p.x, &p.y);
    return p;
  }

  /**
   * Get the position of a window.
   *
   * This is the current position of the window as last reported by the
   * windowing system.
   *
   * If you do not need the value for one of the positions a nullptr may be
   * passed in the `x` or `y` parameter.
   *
   * @param x a pointer filled in with the x position of the window, may be
   *          nullptr.
   * @param y a pointer filled in with the y position of the window, may be
   *          nullptr.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.SetPosition
   */
  void GetPosition(int* x, int* y) const;

  /**
   * Request that the size of a window's client area be set.
   *
   * If the window is in a fullscreen or maximized state, this request has no
   * effect.
   *
   * To change the exclusive fullscreen mode of a window, use
   * Window.SetFullscreenMode().
   *
   * On some windowing systems, this request is asynchronous and the new window
   * size may not have have been applied immediately upon the return of this
   * function. If an immediate change is required, call Window.Sync() to
   * block until the changes have taken effect.
   *
   * When the window size changes, an EVENT_WINDOW_RESIZED event will be
   * emitted with the new window dimensions. Note that the new dimensions may
   * not match the exact size requested, as some windowing systems can restrict
   * the window size in certain scenarios (e.g. constraining the size of the
   * content area to remain within the usable desktop bounds). Additionally, as
   * this is just a request, it can be denied by the windowing system.
   *
   * @param window the window to change.
   * @param w the width of the window, must be > 0.
   * @param h the height of the window, must be > 0.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetSize
   * @sa Window.SetFullscreenMode
   * @sa Window.Sync
   */
  void SetSize(const PointRaw& p);

  /**
   * Get the size of a window's client area.
   *
   * The window pixel size may differ from its window coordinate size if the
   * window is on a high pixel density display. Use GetSizeInPixels()
   * or Renderer.GetOutputSize() to get the real client area size in pixels.
   *
   * @returns a point with width and height on success or std::nullopt on
   * failure; call GetError() for more information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.GetOutputSize()
   * @sa GetSizeInPixels()
   * @sa SetSize()
   * @sa GetSize(int *, int *)
   */
  Point GetSize() const
  {
    Point p;
    GetSize(&p.x, &p.y);
    return p;
  }

  /**
   * Get the size of a window's client area.
   *
   * The window pixel size may differ from its window coordinate size if the
   * window is on a high pixel density display. Use Window.GetSizeInPixels()
   * or Renderer.GetOutputSize() to get the real client area size in pixels.
   *
   * @param w a pointer filled in with the width of the window, may be nullptr.
   * @param h a pointer filled in with the height of the window, may be nullptr.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.GetOutputSize
   * @sa Window.GetSizeInPixels
   * @sa Window.SetSize
   */
  void GetSize(int* w, int* h) const;

  /**
   * Get the safe area for this window.
   *
   * Some devices have portions of the screen which are partially obscured or
   * not interactive, possibly due to on-screen controls, curved edges, camera
   * notches, TV overscan, etc. This function provides the area of the window
   * which is safe to have interactable content. You should continue rendering
   * into the rest of the window, but it should not contain visually important
   * or interactible content.
   *
   * @param window the window to query.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  Rect GetSafeArea() const;

  /**
   * Request that the aspect ratio of a window's client area be set.
   *
   * The aspect ratio is the ratio of width divided by height, e.g. 2560x1600
   * would be 1.6. Larger aspect ratios are wider and smaller aspect ratios are
   * narrower.
   *
   * If, at the time of this request, the window in a fixed-size state, such as
   * maximized or fullscreen, the request will be deferred until the window
   * exits this state and becomes resizable again.
   *
   * On some windowing systems, this request is asynchronous and the new window
   * aspect ratio may not have have been applied immediately upon the return of
   * this function. If an immediate change is required, call Window.Sync() to
   * block until the changes have taken effect.
   *
   * When the window size changes, an EVENT_WINDOW_RESIZED event will be
   * emitted with the new window dimensions. Note that the new dimensions may
   * not match the exact aspect ratio requested, as some windowing systems can
   * restrict the window size in certain scenarios (e.g. constraining the size
   * of the content area to remain within the usable desktop bounds).
   * Additionally, as this is just a request, it can be denied by the windowing
   * system.
   *
   * @param min_aspect the minimum aspect ratio of the window, or 0.0f for no
   *                   limit.
   * @param max_aspect the maximum aspect ratio of the window, or 0.0f for no
   *                   limit.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetAspectRatio
   * @sa Window.Sync
   */
  void SetAspectRatio(float min_aspect, float max_aspect);

  /**
   * Get the size of a window's client area.
   *
   * @param min_aspect a pointer filled in with the minimum aspect ratio of the
   *                   window, may be nullptr.
   * @param max_aspect a pointer filled in with the maximum aspect ratio of the
   *                   window, may be nullptr.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.SetAspectRatio
   */
  void GetAspectRatio(float* min_aspect, float* max_aspect) const;

  /**
   * Get the size of a window's borders (decorations) around the client area.
   *
   * Note: If this function fails (returns false), the size values will be
   * initialized to 0, 0, 0, 0 (if a non-nullptr pointer is provided), as if the
   * window in question was borderless.
   *
   * Note: This function may fail on systems where the window has not yet been
   * decorated by the display server (for example, immediately after calling
   * Window.Window). It is recommended that you wait at least until the
   * window has been presented and composited, so that the window system has a
   * chance to decorate the window and provide the border dimensions to SDL.
   *
   * This function also returns false if getting the information is not
   * supported.
   *
   *               (decorations) from.
   * @param top pointer to variable for storing the size of the top border;
   * nullptr is permitted.
   * @param left pointer to variable for storing the size of the left border;
   *             nullptr is permitted.
   * @param bottom pointer to variable for storing the size of the bottom
   *               border; nullptr is permitted.
   * @param right pointer to variable for storing the size of the right border;
   *              nullptr is permitted.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetSize
   */
  void GetBordersSize(int* top, int* left, int* bottom, int* right) const;

  /**
   * Get the size of a window's client area, in pixels.
   *
   * @returns the size on success or std::nullopt on failure; call GetError()
   * for more information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa GetSize()
   * @sa GetSizeInPixels(int*, int*)
   */
  Point GetSizeInPixels() const
  {
    Point p;
    GetSizeInPixels(&p.x, &p.y);
    return p;
  }

  /**
   * Get the size of a window's client area, in pixels.
   *
   * @param w a pointer to variable for storing the width in pixels, may be
   *          nullptr.
   * @param h a pointer to variable for storing the height in pixels, may be
   *          nullptr.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.Window
   * @sa Window.GetSize
   */
  void GetSizeInPixels(int* w, int* h) const;

  /**
   * Set the minimum size of a window's client area.
   *
   * @param window the window to change.
   * @param min_w the minimum width of the window, or 0 for no limit.
   * @param min_h the minimum height of the window, or 0 for no limit.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetMinimumSize
   * @sa Window.SetMaximumSize
   */
  void SetMinimumSize(const PointRaw& p);

  /**
   * Get the minimum size of a window's client area.
   *
   * @param w a pointer filled in with the minimum width of the window, may be
   *          nullptr.
   * @param h a pointer filled in with the minimum height of the window, may be
   *          nullptr.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetMaximumSize
   * @sa Window.SetMinimumSize
   */
  void GetMinimumSize(int* w, int* h) const;

  /**
   * Set the maximum size of a window's client area.
   *
   * @param window the window to change.
   * @param max_w the maximum width of the window, or 0 for no limit.
   * @param max_h the maximum height of the window, or 0 for no limit.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetMaximumSize
   * @sa Window.SetMinimumSize
   */
  void SetMaximumSize(const PointRaw& p);

  /**
   * Get the maximum size of a window's client area.
   *
   * @param w a pointer filled in with the maximum width of the window, may be
   *          nullptr.
   * @param h a pointer filled in with the maximum height of the window, may be
   *          nullptr.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetMinimumSize
   * @sa Window.SetMaximumSize
   */
  void GetMaximumSize(int* w, int* h) const;

  /**
   * Set the border state of a window.
   *
   * This will add or remove the window's `WINDOW_BORDERLESS` flag and add
   * or remove the border from the actual window. This is a no-op if the
   * window's border already matches the requested state.
   *
   * You can't change the border state of a fullscreen window.
   *
   * @param bordered false to remove border, true to add border.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetFlags
   */
  void SetBordered(bool bordered);

  /**
   * Set the user-resizable state of a window.
   *
   * This will add or remove the window's `WINDOW_RESIZABLE` flag and
   * allow/disallow user resizing of the window. This is a no-op if the window's
   * resizable state already matches the requested state.
   *
   * You can't change the resizable state of a fullscreen window.
   *
   * @param resizable true to allow resizing, false to disallow.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetFlags
   */
  void SetResizable(bool resizable);

  /**
   * Set the window to always be above the others.
   *
   * This will add or remove the window's `WINDOW_ALWAYS_ON_TOP` flag. This
   * will bring the window to the front and keep the window above the rest.
   *
   * @param on_top true to set the window always on top, false to disable.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetFlags
   */
  void SetAlwaysOnTop(bool on_top);

  /**
   * Show a window.
   *
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.Hide
   * @sa Window.Raise
   */
  void Show();

  /**
   * Hide a window.
   *
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.Show
   * @sa WINDOW_HIDDEN
   */
  void Hide();

  /**
   * Request that a window be raised above other windows and gain the input
   * focus.
   *
   * The result of this request is subject to desktop window manager policy,
   * particularly if raising the requested window would result in stealing focus
   * from another application. If the window is successfully raised and gains
   * input focus, an EVENT_WINDOW_FOCUS_GAINED event will be emitted, and
   * the window will have the WINDOW_INPUT_FOCUS flag set.
   *
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void Raise();

  /**
   * Request that the window be made as large as possible.
   *
   * Non-resizable windows can't be maximized. The window must have the
   * WINDOW_RESIZABLE flag set, or this will have no effect.
   *
   * On some windowing systems this request is asynchronous and the new window
   * state may not have have been applied immediately upon the return of this
   * function. If an immediate change is required, call Window.Sync() to
   * block until the changes have taken effect.
   *
   * When the window state changes, an EVENT_WINDOW_MAXIMIZED event will be
   * emitted. Note that, as this is just a request, the windowing system can
   * deny the state change.
   *
   * When maximizing a window, whether the constraints set via
   * Window.SetMaximumSize() are honored depends on the policy of the window
   * manager. Win32 and macOS enforce the constraints when maximizing, while X11
   * and Wayland window managers may vary.
   *
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.Minimize
   * @sa Window.Restore
   * @sa Window.Sync
   */
  void Maximize();

  /**
   * Request that the window be minimized to an iconic representation.
   *
   * If the window is in a fullscreen state, this request has no direct effect.
   * It may alter the state the window is returned to when leaving fullscreen.
   *
   * On some windowing systems this request is asynchronous and the new window
   * state may not have been applied immediately upon the return of this
   * function. If an immediate change is required, call Window.Sync() to
   * block until the changes have taken effect.
   *
   * When the window state changes, an EVENT_WINDOW_MINIMIZED event will be
   * emitted. Note that, as this is just a request, the windowing system can
   * deny the state change.
   *
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.Maximize
   * @sa Window.Restore
   * @sa Window.Sync
   */
  void Minimize();

  /**
   * Request that the size and position of a minimized or maximized window be
   * restored.
   *
   * If the window is in a fullscreen state, this request has no direct effect.
   * It may alter the state the window is returned to when leaving fullscreen.
   *
   * On some windowing systems this request is asynchronous and the new window
   * state may not have have been applied immediately upon the return of this
   * function. If an immediate change is required, call Window.Sync() to
   * block until the changes have taken effect.
   *
   * When the window state changes, an EVENT_WINDOW_RESTORED event will be
   * emitted. Note that, as this is just a request, the windowing system can
   * deny the state change.
   *
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.Maximize
   * @sa Window.Minimize
   * @sa Window.Sync
   */
  void Restore();

  /**
   * Request that the window's fullscreen state be changed.
   *
   * By default a window in fullscreen state uses borderless fullscreen desktop
   * mode, but a specific exclusive display mode can be set using
   * Window.SetFullscreenMode().
   *
   * On some windowing systems this request is asynchronous and the new
   * fullscreen state may not have have been applied immediately upon the return
   * of this function. If an immediate change is required, call Window.Sync()
   * to block until the changes have taken effect.
   *
   * When the window state changes, an EVENT_WINDOW_ENTER_FULLSCREEN or
   * EVENT_WINDOW_LEAVE_FULLSCREEN event will be emitted. Note that, as this
   * is just a request, it can be denied by the windowing system.
   *
   * @param fullscreen true for fullscreen mode, false for windowed mode.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetFullscreenMode
   * @sa Window.SetFullscreenMode
   * @sa Window.Sync
   * @sa WINDOW_FULLSCREEN
   */
  void SetFullscreen(bool fullscreen);

  /**
   * Block until any pending window state is finalized.
   *
   * On asynchronous windowing systems, this acts as a synchronization barrier
   * for pending window state. It will attempt to wait until any pending window
   * state has been applied and is guaranteed to return within finite time. Note
   * that for how long it can potentially block depends on the underlying window
   * system, as window state changes may involve somewhat lengthy animations
   * that must complete before the window is in its final requested state.
   *
   * On windowing systems where changes are immediate, this does nothing.
   *
   *               applied.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.SetSize
   * @sa Window.SetPosition
   * @sa Window.SetFullscreen
   * @sa Window.Minimize
   * @sa Window.Maximize
   * @sa Window.Restore
   * @sa SDL_HINT_VIDEO_SYNC_WINDOW_OPERATIONS
   */
  void Sync();

  /**
   * Return whether the window has a surface associated with it.
   *
   * @returns true if there is a surface associated with the window, or false
   *          otherwise.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetSurface
   */
  bool HasSurface() const;

  /**
   * Get the SDL surface associated with the window.
   *
   * A new surface will be created with the optimal format for the window, if
   * necessary. This surface will be freed when the window is destroyed. Do not
   * free this surface.
   *
   * This surface will be invalidated if the window is resized. After resizing a
   * window this function must be called again to return a valid surface.
   *
   * You may not combine this with 3D or the rendering API on this window.
   *
   * This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.
   *
   * @returns the surface associated with the window, or nullptr on failure;
   * call GetError() for more information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.DestroySurface
   * @sa Window.HasSurface
   * @sa Window.UpdateSurface
   * @sa Window.UpdateSurfaceRects
   */
  Surface GetSurface();

  /**
   * Toggle VSync for the window surface.
   *
   * When a window surface is created, vsync defaults to
   * WINDOW_SURFACE_VSYNC_DISABLED.
   *
   * The `vsync` parameter can be 1 to synchronize present with every vertical
   * refresh, 2 to synchronize present with every second vertical refresh, etc.,
   * WINDOW_SURFACE_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync),
   * or WINDOW_SURFACE_VSYNC_DISABLED to disable. Not every value is
   * supported by every driver, so you should check the return value to see
   * whether the requested setting is supported.
   *
   * @param vsync the vertical refresh sync interval.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetSurfaceVSync
   */
  void SetSurfaceVSync(int vsync);

  /**
   * Get VSync for the window surface.
   *
   * @param window the window to query.
   * @param vsync an int filled with the current vertical refresh sync interval.
   *              See Window.SetSurfaceVSync() for the meaning of the value.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.SetSurfaceVSync
   */
  int GetSurfaceVSync() const;

  /**
   * Copy the window surface to the screen.
   *
   * This is the function you use to reflect any changes to the surface on the
   * screen.
   *
   * This function is equivalent to the SDL 1.2 API SDL_Flip().
   *
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetSurface
   * @sa Window.UpdateSurfaceRects
   */
  void UpdateSurface();

  /**
   * Copy areas of the window surface to the screen.
   *
   * This is the function you use to reflect changes to portions of the surface
   * on the screen.
   *
   * This function is equivalent to the SDL 1.2 API SDL_UpdateRects().
   *
   * Note that this function will update _at least_ the rectangles specified,
   * but this is only intended as an optimization; in practice, this might
   * update more of the screen (or all of the screen!), depending on what method
   * SDL uses to send pixels to the system.
   *
   * @param rects an array of Rect structures representing areas of the
   *              surface to copy, in pixels.
   * @param numrects the number of rectangles.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetSurface
   * @sa Window.UpdateSurface
   */
  void UpdateSurfaceRects(SpanRef<const RectRaw> rects);

  /**
   * Destroy the surface associated with the window.
   *
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetSurface
   * @sa Window.HasSurface
   */
  void DestroySurface();

  /**
   * Set a window's keyboard grab mode.
   *
   * Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or
   * the Meta/Super key. Note that not all system keyboard shortcuts can be
   * captured by applications (one example is Ctrl+Alt+Del on Windows).
   *
   * This is primarily intended for specialized applications such as VNC clients
   * or VM frontends. Normal games should not use keyboard grab.
   *
   * When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the
   * window is full-screen to ensure the user is not trapped in your
   * application. If you have a custom keyboard shortcut to exit fullscreen
   * mode, you may suppress this behavior with
   * `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.
   *
   * If the caller enables a grab while another window is currently grabbed, the
   * other window loses its grab in favor of the caller's window.
   *
   * @param grabbed this is true to grab keyboard, and false to release.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetKeyboardGrab
   * @sa Window.SetMouseGrab
   */
  void SetKeyboardGrab(bool grabbed);

  /**
   * Set a window's mouse grab mode.
   *
   * Mouse grab confines the mouse cursor to the window.
   *
   * @param grabbed this is true to grab mouse, and false to release.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetMouseRect
   * @sa Window.SetMouseRect
   * @sa Window.SetMouseGrab
   * @sa Window.SetKeyboardGrab
   */
  void SetMouseGrab(bool grabbed);

  /**
   * Get a window's keyboard grab mode.
   *
   * @returns true if keyboard is grabbed, and false otherwise.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.SetKeyboardGrab
   */
  bool GetKeyboardGrab() const;

  /**
   * Get a window's mouse grab mode.
   *
   * @returns true if mouse is grabbed, and false otherwise.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetMouseRect
   * @sa Window.SetMouseRect
   * @sa Window.SetMouseGrab
   * @sa Window.SetKeyboardGrab
   */
  bool GetMouseGrab() const;

  /**
   * Confines the cursor to the specified area of a window.
   *
   * Note that this does NOT grab the cursor, it only defines the area a cursor
   * is restricted to when the window has mouse focus.
   *
   * @param rect a rectangle area in window-relative coordinates. If nullptr the
   *             barrier for the specified window will be destroyed.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetMouseRect
   * @sa Window.GetMouseGrab
   * @sa Window.SetMouseGrab
   */
  void SetMouseRect(const RectRaw& rect);

  /**
   * Get the mouse confinement rectangle of a window.
   *
   * @returns a pointer to the mouse confinement rectangle of a window, or
   * nullptr if there isn't one.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.SetMouseRect
   * @sa Window.GetMouseGrab
   * @sa Window.SetMouseGrab
   */
  const RectRaw* GetMouseRect() const;

  /**
   * Set the opacity for a window.
   *
   * The parameter `opacity` will be clamped internally between 0.0f
   * (transparent) and 1.0f (opaque).
   *
   * This function also returns false if setting the opacity isn't supported.
   *
   * @param opacity the opacity value (0.0f - transparent, 1.0f - opaque).
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetOpacity
   */
  void SetOpacity(float opacity);

  /**
   * Get the opacity of a window.
   *
   * If transparency isn't supported on this platform, opacity will be returned
   * as 1.0f without error.
   *
   * @returns the opacity, (0.0f - transparent, 1.0f - opaque), or -1.0f on
   *          failure; call GetError() for more information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.SetOpacity
   */
  float GetOpacity() const;

  /**
   * Set the window as a child of a parent window.
   *
   * If the window is already the child of an existing window, it will be
   * reparented to the new owner. Setting the parent window to nullptr unparents
   * the window and removes child window status.
   *
   * If a parent window is hidden or destroyed, the operation will be
   * recursively applied to child windows. Child windows hidden with the parent
   * that did not have their hidden status explicitly set will be restored when
   * the parent is shown.
   *
   * Attempting to set the parent of a window that is currently in the modal
   * state will fail. Use Window.SetModal() to cancel the modal status before
   * attempting to change the parent.
   *
   * Popup windows cannot change parents and attempts to do so will fail.
   *
   * Setting a parent window that is currently the sibling or descendent of the
   * child window results in undefined behavior.
   *
   * @param parent the new parent window for the child window.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.SetModal
   */
  void SetParent(WindowParam parent);

  /**
   * Toggle the state of the window as modal.
   *
   * To enable modal status on a window, the window must currently be the child
   * window of a parent, or toggling modal status on will fail.
   *
   * @param modal true to toggle modal status on, false to toggle it off.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.SetParent
   * @sa WINDOW_MODAL
   */
  void SetModal(bool modal);

  /**
   * Set whether the window may have input focus.
   *
   * @param focusable true to allow input focus, false to not allow input focus.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void SetFocusable(bool focusable);

  /**
   * Display the system-level window menu.
   *
   * This default window menu is provided by the system and on some platforms
   * provides functionality for setting or changing privileged state on the
   * window, such as moving it between workspaces or displays, or toggling the
   * always-on-top property.
   *
   * On platforms or desktops where this is unsupported, this function does
   * nothing.
   *
   * @param window the window for which the menu will be displayed.
   * @param x the x coordinate of the menu, relative to the origin (top-left) of
   *          the client area.
   * @param y the y coordinate of the menu, relative to the origin (top-left) of
   *          the client area.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void ShowSystemMenu(const PointRaw& p);

  /**
   * Provide a callback that decides if a window region has special properties.
   *
   * Normally windows are dragged and resized by decorations provided by the
   * system window manager (a title bar, borders, etc), but for some apps, it
   * makes sense to drag them from somewhere else inside the window itself; for
   * example, one might have a borderless window that wants to be draggable from
   * any part, or simulate its own title bar, etc.
   *
   * This function lets the app provide a callback that designates pieces of a
   * given window as special. This callback is run during event processing if we
   * need to tell the OS to treat a region of the window specially; the use of
   * this callback is known as "hit testing."
   *
   * Mouse input may not be delivered to your application if it is within a
   * special area; the OS will often apply that input to moving the window or
   * resizing the window and not deliver it to the application.
   *
   * Specifying nullptr for a callback disables hit-testing. Hit-testing is
   * disabled by default.
   *
   * Platforms that don't support this functionality will return false
   * unconditionally, even if you're attempting to disable hit-testing.
   *
   * Your callback may fire at any time, and its firing does not indicate any
   * specific behavior (for example, on Windows, this certainly might fire when
   * the OS is deciding whether to drag your window, but it fires for lots of
   * other reasons, too, some unrelated to anything you probably care about _and
   * when the mouse isn't actually at the location it is testing_). Since this
   * can fire at any time, you should try to keep your callback efficient,
   * devoid of allocations, etc.
   *
   * @param callback the function to call when doing a hit-test.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @cat listener-callback
   */
  void SetHitTest(HitTestCB callback)
  {
    using Wrapper = KeyValueCallbackWrapper<WindowRaw, HitTestCB>;
    void* cbHandle = Wrapper::Wrap(m_resource, std::move(callback));
    SetHitTest(
      [](SDL_Window* win, const SDL_Point* area, void* data) {
        return Wrapper::Call(data, win, Point(*area));
      },
      cbHandle);
  }

  /**
   * Provide a callback that decides if a window region has special properties.
   *
   * Normally windows are dragged and resized by decorations provided by the
   * system window manager (a title bar, borders, etc), but for some apps, it
   * makes sense to drag them from somewhere else inside the window itself; for
   * example, one might have a borderless window that wants to be draggable from
   * any part, or simulate its own title bar, etc.
   *
   * This function lets the app provide a callback that designates pieces of a
   * given window as special. This callback is run during event processing if we
   * need to tell the OS to treat a region of the window specially; the use of
   * this callback is known as "hit testing."
   *
   * Mouse input may not be delivered to your application if it is within a
   * special area; the OS will often apply that input to moving the window or
   * resizing the window and not deliver it to the application.
   *
   * Specifying nullptr for a callback disables hit-testing. Hit-testing is
   * disabled by default.
   *
   * Platforms that don't support this functionality will return false
   * unconditionally, even if you're attempting to disable hit-testing.
   *
   * Your callback may fire at any time, and its firing does not indicate any
   * specific behavior (for example, on Windows, this certainly might fire when
   * the OS is deciding whether to drag your window, but it fires for lots of
   * other reasons, too, some unrelated to anything you probably care about _and
   * when the mouse isn't actually at the location it is testing_). Since this
   * can fire at any time, you should try to keep your callback efficient,
   * devoid of allocations, etc.
   *
   * @param callback the function to call when doing a hit-test.
   * @param callback_data an app-defined void pointer passed to **callback**.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void SetHitTest(HitTest callback, void* callback_data);

  /**
   * Set the shape of a transparent window.
   *
   * This sets the alpha channel of a transparent window and any fully
   * transparent areas are also transparent to mouse clicks. If you are using
   * something besides the SDL render API, then you are responsible for drawing
   * the alpha channel of the window to match the shape alpha channel to get
   * consistent cross-platform results.
   *
   * The shape is copied inside this function, so you can free it afterwards. If
   * your shape surface changes, you should call Window.SetShape() again to
   * update the window. This is an expensive operation, so should be done
   * sparingly.
   *
   * The window must have been created with the WINDOW_TRANSPARENT flag.
   *
   * @param shape the surface representing the shape of the window, or nullptr
   * to remove any current shape.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void SetShape(SurfaceParam shape);

  /**
   * Request a window to demand attention from the user.
   *
   * @param operation the operation to perform.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void Flash(FlashOperation operation);

  /**
   * Get a window from a stored ID.
   *
   * The numeric ID is what WindowEvent references, and is necessary to map
   * these events to specific Window objects.
   *
   * @param id the ID of the window.
   * @returns the window associated with `id` or nullptr if it doesn't exist;
   * call GetError() for more information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetID
   */
  static WindowRef FromID(WindowID id);

  /**
   * Get the window that currently has an input grab enabled.
   *
   * @returns the window if input is grabbed or nullptr otherwise.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.SetMouseGrab
   * @sa Window.SetKeyboardGrab
   */
  static WindowRef GetGrabbed();

  /**
   * Get the renderer associated with a window.
   *
   * @returns the rendering context on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  RendererRef GetRenderer() const;

  /**
   * Start accepting Unicode text input events in a window.
   *
   * This function will enable text input (EVENT_TEXT_INPUT and
   * EVENT_TEXT_EDITING events) in the specified window. Please use this
   * function paired with Window.StopTextInput().
   *
   * Text input events are not received by default.
   *
   * On some platforms using this function shows the screen keyboard and/or
   * activates an IME, which can prevent some key press events from being passed
   * through.
   *
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.SetTextInputArea
   * @sa Window.StartTextInput
   * @sa Window.StopTextInput
   * @sa Window.IsTextInputActive
   */
  void StartTextInput();

  /**
   * Start accepting Unicode text input events in a window, with properties
   * describing the input.
   *
   * This function will enable text input (EVENT_TEXT_INPUT and
   * EVENT_TEXT_EDITING events) in the specified window. Please use this
   * function paired with Window.StopTextInput().
   *
   * Text input events are not received by default.
   *
   * On some platforms using this function shows the screen keyboard and/or
   * activates an IME, which can prevent some key press events from being passed
   * through.
   *
   * These are the supported properties:
   *
   * - `prop::TextInput.TYPE_NUMBER` - an TextInputType value that
   *   describes text being input, defaults to TEXTINPUT_TYPE_TEXT.
   * - `prop::TextInput.CAPITALIZATION_NUMBER` - an Capitalization value
   *   that describes how text should be capitalized, defaults to
   *   CAPITALIZE_SENTENCES for normal text entry, CAPITALIZE_WORDS for
   *   TEXTINPUT_TYPE_TEXT_NAME, and CAPITALIZE_NONE for e-mail
   *   addresses, usernames, and passwords.
   * - `prop::TextInput.AUTOCORRECT_BOOLEAN` - true to enable auto completion
   *   and auto correction, defaults to true.
   * - `prop::TextInput.MULTILINE_BOOLEAN` - true if multiple lines of text
   *   are allowed. This defaults to true if SDL_HINT_RETURN_KEY_HIDES_IME is
   *   "0" or is not set, and defaults to false if SDL_HINT_RETURN_KEY_HIDES_IME
   *   is "1".
   *
   * On Android you can directly specify the input type:
   *
   * - `prop::TextInput.ANDROID_INPUTTYPE_NUMBER` - the text input type to
   *   use, overriding other properties. This is documented at
   *   https://developer.android.com/reference/android/text/InputType
   *
   * @param props the properties to use.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.SetTextInputArea
   * @sa Window.StartTextInput
   * @sa Window.StopTextInput
   * @sa Window.IsTextInputActive
   */
  void StartTextInput(PropertiesParam props);

  /**
   * Check whether or not Unicode text input events are enabled for a window.
   *
   * @returns true if text input events are enabled else false.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.StartTextInput
   */
  bool IsTextInputActive() const;

  /**
   * Stop receiving any text input events in a window.
   *
   * If Window.StartTextInput() showed the screen keyboard, this function will
   * hide it.
   *
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.StartTextInput
   */
  void StopTextInput();

  /**
   * Dismiss the composition window/IME without disabling the subsystem.
   *
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.StartTextInput
   * @sa Window.StopTextInput
   */
  void ClearComposition();

  /**
   * Set the area used to type Unicode text input.
   *
   * Native input methods may place a window with word suggestions near the
   * cursor, without covering the text being entered.
   *
   * @param rect the Rect representing the text input area, in window
   *             coordinates, or nullptr to clear it.
   * @param cursor the offset of the current cursor location relative to
   *               `rect->x`, in window coordinates.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetTextInputArea
   * @sa Window.StartTextInput
   */
  void SetTextInputArea(const RectRaw& rect, int cursor);

  /**
   * Get the area used to type Unicode text input.
   *
   * This returns the values previously set by Window.SetTextInputArea().
   *
   * @param rect a pointer to an Rect filled in with the text input area,
   *             may be nullptr.
   * @param cursor a pointer to the offset of the current cursor location
   *               relative to `rect->x`, may be nullptr.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.SetTextInputArea
   */
  void GetTextInputArea(RectRaw* rect, int* cursor);

  /**
   * Check whether the screen keyboard is shown for given window.
   *
   * @returns true if screen keyboard is shown or false if not.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa HasScreenKeyboardSupport
   */
  bool IsScreenKeyboardShown() const;

  /**
   * Move the mouse cursor to the given position within the window.
   *
   * This function generates a mouse motion event if relative mode is not
   * enabled. If relative mode is enabled, you can force mouse events for the
   * warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.
   *
   * Note that this function will appear to succeed, but not actually move the
   * mouse when used over Microsoft Remote Desktop.
   *
   *               mouse focus.
   * @param x the x coordinate within the window.
   * @param y the y coordinate within the window.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa WarpMouse
   */
  void WarpMouse(const FPointRaw& p);

  /**
   * Set relative mouse mode for a window.
   *
   * While the window has focus and relative mouse mode is enabled, the cursor
   * is hidden, the mouse position is constrained to the window, and SDL will
   * report continuous relative mouse motion even if the mouse is at the edge of
   * the window.
   *
   * If you'd like to keep the mouse position fixed while in relative mode you
   * can use Window.SetMouseRect(). If you'd like the cursor to be at a
   * specific location when relative mode ends, you should use
   * Window.WarpMouse() before disabling relative mode.
   *
   * This function will flush any pending mouse motion for this window.
   *
   * @param enabled true to enable relative mode, false to disable.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.GetRelativeMouseMode
   */
  void SetRelativeMouseMode(bool enabled);

  /**
   * Query whether relative mouse mode is enabled for a window.
   *
   * @returns true if relative mode is enabled for a window or false otherwise.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Window.SetRelativeMouseMode
   */
  bool GetRelativeMouseMode() const;
};

/// Semi-safe reference for Window.
struct WindowRef : Window
{
  /**
   * Constructs from WindowParam.
   *
   * @param resource a WindowRaw or Window.
   *
   * This does not takes ownership!
   */
  WindowRef(WindowParam resource)
    : Window(resource.value)
  {
  }

  /// Copy constructor.
  WindowRef(const WindowRef& other)
    : Window(other.get())
  {
  }

  /// Destructor
  ~WindowRef() { release(); }
};

#ifdef SDL3PP_DOC

/**
 * A magic value used with SDL_WINDOWPOS_UNDEFINED.
 *
 * Generally this macro isn't used directly, but rather through
 * SDL_WINDOWPOS_UNDEFINED or SDL_WINDOWPOS_UNDEFINED_DISPLAY.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_WINDOWPOS_UNDEFINED_MASK 0x1FFF0000u

/**
 * Used to indicate that you don't care what the window position is.
 *
 * If you _really_ don't care, SDL_WINDOWPOS_UNDEFINED is the same, but always
 * uses the primary display instead of specifying one.
 *
 * @param X the Display of the display to use.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_WINDOWPOS_UNDEFINED_DISPLAY(X) (SDL_WINDOWPOS_UNDEFINED_MASK | (X))

/**
 * Used to indicate that you don't care what the window position/display is.
 *
 * This always uses the primary display.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_WINDOWPOS_UNDEFINED SDL_WINDOWPOS_UNDEFINED_DISPLAY(0)

/**
 * A macro to test if the window position is marked as "undefined."
 *
 * @param X the window position value.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_WINDOWPOS_ISUNDEFINED(X)                                           \
  (((X) & 0xFFFF0000) == SDL_WINDOWPOS_UNDEFINED_MASK)

/**
 * A magic value used with SDL_WINDOWPOS_CENTERED.
 *
 * Generally this macro isn't used directly, but rather through
 * SDL_WINDOWPOS_CENTERED or SDL_WINDOWPOS_CENTERED_DISPLAY.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_WINDOWPOS_CENTERED_MASK 0x2FFF0000u

/**
 * Used to indicate that the window position should be centered.
 *
 * SDL_WINDOWPOS_CENTERED is the same, but always uses the primary display
 * instead of specifying one.
 *
 * @param X the Display of the display to use.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_WINDOWPOS_CENTERED_DISPLAY(X) (SDL_WINDOWPOS_CENTERED_MASK | (X))

/**
 * Used to indicate that the window position should be centered.
 *
 * This always uses the primary display.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_WINDOWPOS_CENTERED SDL_WINDOWPOS_CENTERED_DISPLAY(0)

/**
 * A macro to test if the window position is marked as "centered."
 *
 * @param X the window position value.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_WINDOWPOS_ISCENTERED(X)                                            \
  (((X) & 0xFFFF0000) == SDL_WINDOWPOS_CENTERED_MASK)

#endif // SDL3PP_DOC

/**
 * An opaque handle to an OpenGL context.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa GLContext.GLContext
 *
 * @cat resource
 */
class GLContext
{
  GLContextRaw m_resource = nullptr;

public:
  /// Default ctor
  constexpr GLContext() = default;

  /**
   * Constructs from GLContextParam.
   *
   * @param resource a GLContextRaw to be wrapped.
   */
  constexpr GLContext(const GLContextRaw resource)
    : m_resource(resource)
  {
  }

  /// Copy constructor
  constexpr GLContext(const GLContext& other) = default;

  /// Move constructor
  constexpr GLContext(GLContext&& other)
    : GLContext(other.release())
  {
  }

  /**
   * Create an OpenGL context for an OpenGL window, and make it current.
   *
   * Windows users new to OpenGL should note that, for historical reasons, GL
   * functions added after OpenGL version 1.1 are not available by default.
   * Those functions must be loaded at run-time, either with an OpenGL
   * extension-handling library or with GL_GetProcAddress() and its related
   * functions.
   *
   * GLContext is opaque to the application.
   *
   * @param window the window to associate with the context.
   * @post the OpenGL context associated with `window` or nullptr on failure;
   *          call GetError() for more information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa GLContext.Destroy
   * @sa GLContext.MakeCurrent
   */
  GLContext(WindowParam window)
    : m_resource(SDL_GL_CreateContext(window))
  {
  }

  /// Destructor
  ~GLContext() {}

  /// Assignment operator.
  GLContext& operator=(GLContext other)
  {
    std::swap(m_resource, other.m_resource);
    return *this;
  }

  /// Retrieves underlying GLContextRaw.
  constexpr GLContextRaw get() const { return m_resource; }

  /// Retrieves underlying GLContextRaw and clear this.
  constexpr GLContextRaw release()
  {
    auto r = m_resource;
    m_resource = nullptr;
    return r;
  }

  /// Comparison
  constexpr auto operator<=>(const GLContext& other) const = default;

  /// Comparison
  constexpr bool operator==(std::nullptr_t _) const { return !m_resource; }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!m_resource; }

  /// Converts to GLContextParam
  constexpr operator GLContextParam() const { return {m_resource}; }

  /**
   * Delete an OpenGL context.
   *
   * @returns true on success or false on failure; call GetError() for more
   *          information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa GLContext.GLContext
   */
  void Destroy();

  /**
   * Set up an OpenGL context for rendering into an OpenGL window.
   *
   * The context must have been created with a compatible window.
   *
   * @param window the window to associate with the context.
   * @param context the OpenGL context to associate with the window.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa GLContext.GLContext
   */
  void MakeCurrent(WindowParam window);
};

/// RAII owning version GLContext.
struct GLContextScoped : GLContext
{
  using GLContext::GLContext;

  constexpr GLContextScoped(const GLContext& other) = delete;

  /// Move constructor
  constexpr GLContextScoped(GLContext&& other)
    : GLContext(other.release())
  {
  }

  /// Destructor
  ~GLContextScoped() { Destroy(); }
};

/**
 * Opaque type for an EGL display.
 *
 * @since This datatype is available since SDL 3.2.0.
 */
using EGLDisplay = SDL_EGLDisplay;

/**
 * Opaque type for an EGL config.
 *
 * @since This datatype is available since SDL 3.2.0.
 */
using EGLConfig = SDL_EGLConfig;

/**
 * Opaque type for an EGL surface.
 *
 * @since This datatype is available since SDL 3.2.0.
 */
using EGLSurface = SDL_EGLSurface;

/**
 * An EGL attribute, used when creating an EGL context.
 *
 * @since This datatype is available since SDL 3.2.0.
 */
using EGLAttrib = SDL_EGLAttrib;

/**
 * An EGL integer attribute, used when creating an EGL surface.
 *
 * @since This datatype is available since SDL 3.2.0.
 */
using EGLint = SDL_EGLint;

/**
 * EGL platform attribute initialization callback.
 *
 * This is called when SDL is attempting to create an EGL context, to let the
 * app add extra attributes to its eglGetPlatformDisplay() call.
 *
 * The callback should return a pointer to an EGL attribute array terminated
 * with `EGL_NONE`. If this function returns nullptr, the Window.Window
 * process will fail gracefully.
 *
 * The returned pointer should be allocated with malloc() and will be
 * passed to free().
 *
 * The arrays returned by each callback will be appended to the existing
 * attribute arrays defined by SDL.
 *
 * @param userdata an app-controlled pointer that is passed to the callback.
 * @returns a newly-allocated array of attributes, terminated with `EGL_NONE`.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa EGL_SetAttributeCallbacks
 */
using EGLAttribArrayCallback = SDL_EGLAttribArrayCallback;

/**
 * EGL platform attribute initialization callback.
 *
 * This is called when SDL is attempting to create an EGL context, to let the
 * app add extra attributes to its eglGetPlatformDisplay() call.
 *
 * The callback should return a pointer to an EGL attribute array terminated
 * with `EGL_NONE`. If this function returns nullptr, the Window.Window
 * process will fail gracefully.
 *
 * The returned pointer should be allocated with malloc() and will be
 * passed to free().
 *
 * The arrays returned by each callback will be appended to the existing
 * attribute arrays defined by SDL.
 *
 * @param userdata an app-controlled pointer that is passed to the callback.
 * @returns a newly-allocated array of attributes, terminated with `EGL_NONE`.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa EGL_SetAttributeCallbacks
 * @sa EGLAttribArrayCallback
 */
using EGLAttribArrayCB = std::function<SDL_EGLAttrib*()>;

/**
 * EGL surface/context attribute initialization callback types.
 *
 * This is called when SDL is attempting to create an EGL surface, to let the
 * app add extra attributes to its eglCreateWindowSurface() or
 * eglCreateContext calls.
 *
 * For convenience, the EGLDisplay and EGLConfig to use are provided to the
 * callback.
 *
 * The callback should return a pointer to an EGL attribute array terminated
 * with `EGL_NONE`. If this function returns nullptr, the Window.Window
 * process will fail gracefully.
 *
 * The returned pointer should be allocated with malloc() and will be
 * passed to free().
 *
 * The arrays returned by each callback will be appended to the existing
 * attribute arrays defined by SDL.
 *
 * @param userdata an app-controlled pointer that is passed to the callback.
 * @param display the EGL display to be used.
 * @param config the EGL config to be used.
 * @returns a newly-allocated array of attributes, terminated with `EGL_NONE`.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa EGL_SetAttributeCallbacks
 */
using EGLIntArrayCallback = SDL_EGLIntArrayCallback;

/**
 * EGL surface/context attribute initialization callback types.
 *
 * This is called when SDL is attempting to create an EGL surface, to let the
 * app add extra attributes to its eglCreateWindowSurface() or
 * eglCreateContext calls.
 *
 * For convenience, the EGLDisplay and EGLConfig to use are provided to the
 * callback.
 *
 * The callback should return a pointer to an EGL attribute array terminated
 * with `EGL_NONE`. If this function returns nullptr, the Window.Window
 * process will fail gracefully.
 *
 * The returned pointer should be allocated with malloc() and will be
 * passed to free().
 *
 * The arrays returned by each callback will be appended to the existing
 * attribute arrays defined by SDL.
 *
 * @param userdata an app-controlled pointer that is passed to the callback.
 * @param display the EGL display to be used.
 * @param config the EGL config to be used.
 * @returns a newly-allocated array of attributes, terminated with `EGL_NONE`.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa EGL_SetAttributeCallbacks
 * @sa EGLIntArrayCallback
 */
using EGLIntArrayCB = std::function<SDL_EGLint*(SDL_EGLDisplay, SDL_EGLConfig)>;

/**
 * An enumeration of OpenGL configuration attributes.
 *
 * While you can set most OpenGL attributes normally, the attributes listed
 * above must be known before SDL creates the window that will be used with
 * the OpenGL context. These attributes are set and read with
 * GL_SetAttribute() and GL_GetAttribute().
 *
 * In some cases, these attributes are minimum requests; the GL does not
 * promise to give you exactly what you asked for. It's possible to ask for a
 * 16-bit depth buffer and get a 24-bit one instead, for example, or to ask
 * for no stencil buffer and still have one available. Context creation should
 * fail if the GL can't provide your requested attributes at a minimum, but
 * you should check to see exactly what you got.
 *
 * @since This enum is available since SDL 3.2.0.
 */
using GLAttr = SDL_GLAttr;

/**
 * the minimum number of bits for the red channel of the color buffer; defaults
 * to 8.
 */
constexpr GLAttr GL_RED_SIZE = SDL_GL_RED_SIZE;

/**
 * the minimum number of bits for the green channel of the color buffer;
 * defaults to 8.
 */
constexpr GLAttr GL_GREEN_SIZE = SDL_GL_GREEN_SIZE;

/**
 * the minimum number of bits for the blue channel of the color buffer; defaults
 * to 8.
 */
constexpr GLAttr GL_BLUE_SIZE = SDL_GL_BLUE_SIZE;

/**
 * the minimum number of bits for the alpha channel of the color buffer;
 * defaults to 8.
 */
constexpr GLAttr GL_ALPHA_SIZE = SDL_GL_ALPHA_SIZE;

/// the minimum number of bits for frame buffer size; defaults to 0.
constexpr GLAttr GL_BUFFER_SIZE = SDL_GL_BUFFER_SIZE;

/**
 * whether the output is single or double buffered; defaults to double buffering
 * on.
 */
constexpr GLAttr GL_DOUBLEBUFFER = SDL_GL_DOUBLEBUFFER;

/// the minimum number of bits in the depth buffer; defaults to 16.
constexpr GLAttr GL_DEPTH_SIZE = SDL_GL_DEPTH_SIZE;

/// the minimum number of bits in the stencil buffer; defaults to 0.
constexpr GLAttr GL_STENCIL_SIZE = SDL_GL_STENCIL_SIZE;

/**
 * the minimum number of bits for the red channel of the accumulation buffer;
 * defaults to 0.
 */
constexpr GLAttr GL_ACCUM_RED_SIZE = SDL_GL_ACCUM_RED_SIZE;

/**
 * the minimum number of bits for the green channel of the accumulation buffer;
 * defaults to 0.
 */
constexpr GLAttr GL_ACCUM_GREEN_SIZE = SDL_GL_ACCUM_GREEN_SIZE;

/**
 * the minimum number of bits for the blue channel of the accumulation buffer;
 * defaults to 0.
 */
constexpr GLAttr GL_ACCUM_BLUE_SIZE = SDL_GL_ACCUM_BLUE_SIZE;

/**
 * the minimum number of bits for the alpha channel of the accumulation buffer;
 * defaults to 0.
 */
constexpr GLAttr GL_ACCUM_ALPHA_SIZE = SDL_GL_ACCUM_ALPHA_SIZE;

constexpr GLAttr GL_STEREO =
  SDL_GL_STEREO; ///< whether the output is stereo 3D; defaults to off.

/// the number of buffers used for multisample anti-aliasing; defaults to 0.
constexpr GLAttr GL_MULTISAMPLEBUFFERS = SDL_GL_MULTISAMPLEBUFFERS;

/**
 * the number of samples used around the current pixel used for multisample
 * anti-aliasing.
 */
constexpr GLAttr GL_MULTISAMPLESAMPLES = SDL_GL_MULTISAMPLESAMPLES;

/**
 * set to 1 to require hardware acceleration, set to 0 to force software
 * rendering; defaults to allow either.
 */
constexpr GLAttr GL_ACCELERATED_VISUAL = SDL_GL_ACCELERATED_VISUAL;

constexpr GLAttr GL_RETAINED_BACKING =
  SDL_GL_RETAINED_BACKING; ///< not used (deprecated).

constexpr GLAttr GL_CONTEXT_MAJOR_VERSION =
  SDL_GL_CONTEXT_MAJOR_VERSION; ///< OpenGL context major version.

constexpr GLAttr GL_CONTEXT_MINOR_VERSION =
  SDL_GL_CONTEXT_MINOR_VERSION; ///< OpenGL context minor version.

/**
 * some combination of 0 or more of elements of the GLContextFlag enumeration;
 * defaults to 0.
 */
constexpr GLAttr GL_CONTEXT_FLAGS = SDL_GL_CONTEXT_FLAGS;

/**
 * type of GL context (Core, Compatibility, ES).  See GLProfile; default value
 * depends on platform.
 */
constexpr GLAttr GL_CONTEXT_PROFILE_MASK = SDL_GL_CONTEXT_PROFILE_MASK;

constexpr GLAttr GL_SHARE_WITH_CURRENT_CONTEXT =
  SDL_GL_SHARE_WITH_CURRENT_CONTEXT; ///< OpenGL context sharing; defaults to 0.

constexpr GLAttr GL_FRAMEBUFFER_SRGB_CAPABLE =
  SDL_GL_FRAMEBUFFER_SRGB_CAPABLE; ///< requests sRGB capable visual; defaults
                                   ///< to 0.

/**
 * sets context the release behavior.  See GLContextReleaseFlag; defaults to
 * FLUSH.
 */
constexpr GLAttr GL_CONTEXT_RELEASE_BEHAVIOR = SDL_GL_CONTEXT_RELEASE_BEHAVIOR;

/**
 * set context reset notification.  See GLContextResetNotification; defaults to
 * NO_NOTIFICATION.
 */
constexpr GLAttr GL_CONTEXT_RESET_NOTIFICATION =
  SDL_GL_CONTEXT_RESET_NOTIFICATION;

constexpr GLAttr GL_CONTEXT_NO_ERROR =
  SDL_GL_CONTEXT_NO_ERROR; ///< GL_CONTEXT_NO_ERROR

constexpr GLAttr GL_FLOATBUFFERS = SDL_GL_FLOATBUFFERS; ///< GL_FLOATBUFFERS

constexpr GLAttr GL_EGL_PLATFORM = SDL_GL_EGL_PLATFORM; ///< GL_EGL_PLATFORM

/**
 * Possible values to be set for the GL_CONTEXT_PROFILE_MASK attribute.
 *
 * @since This datatype is available since SDL 3.2.0.
 */
using GLProfile = Uint32;

constexpr GLProfile GL_CONTEXT_PROFILE_CORE =
  SDL_GL_CONTEXT_PROFILE_CORE; ///< OpenGL Core Profile context

constexpr GLProfile GL_CONTEXT_PROFILE_COMPATIBILITY =
  SDL_GL_CONTEXT_PROFILE_COMPATIBILITY; ///< OpenGL Compatibility Profile
                                        ///< context

constexpr GLProfile GL_CONTEXT_PROFILE_ES =
  SDL_GL_CONTEXT_PROFILE_ES; ///< GLX_CONTEXT_ES2_PROFILE_BIT_EXT

/**
 * Possible flags to be set for the GL_CONTEXT_FLAGS attribute.
 *
 * @since This datatype is available since SDL 3.2.0.
 */
using GLContextFlag = Uint32;

constexpr GLContextFlag GL_CONTEXT_DEBUG_FLAG =
  SDL_GL_CONTEXT_DEBUG_FLAG; ///< DEBUG_FLAG

constexpr GLContextFlag GL_CONTEXT_FORWARD_COMPATIBLE_FLAG =
  SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG; ///< FORWARD_COMPATIBLE_FLAG

constexpr GLContextFlag GL_CONTEXT_ROBUST_ACCESS_FLAG =
  SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG; ///< ROBUST_ACCESS_FLAG

constexpr GLContextFlag GL_CONTEXT_RESET_ISOLATION_FLAG =
  SDL_GL_CONTEXT_RESET_ISOLATION_FLAG; ///< RESET_ISOLATION_FLAG

/**
 * Possible values to be set for the GL_CONTEXT_RELEASE_BEHAVIOR
 * attribute.
 *
 * @since This datatype is available since SDL 3.2.0.
 */
using GLContextReleaseFlag = Uint32;

constexpr GLContextReleaseFlag GL_CONTEXT_RELEASE_BEHAVIOR_NONE =
  SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE; ///< BEHAVIOR_NONE

constexpr GLContextReleaseFlag GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH =
  SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH; ///< BEHAVIOR_FLUSH

/**
 * Possible values to be set GL_CONTEXT_RESET_NOTIFICATION attribute.
 *
 * @since This datatype is available since SDL 3.2.0.
 */
using GLContextResetNotification = Uint32;

constexpr GLContextResetNotification GL_CONTEXT_RESET_NO_NOTIFICATION =
  SDL_GL_CONTEXT_RESET_NO_NOTIFICATION; ///< NO_NOTIFICATION

constexpr GLContextResetNotification GL_CONTEXT_RESET_LOSE_CONTEXT =
  SDL_GL_CONTEXT_RESET_LOSE_CONTEXT; ///< LOSE_CONTEXT

/**
 * Get the number of video drivers compiled into SDL.
 *
 * @returns the number of built in video drivers.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetVideoDriver
 */
inline int GetNumVideoDrivers() { return SDL_GetNumVideoDrivers(); }

/**
 * Get the name of a built in video driver.
 *
 * The video drivers are presented in the order in which they are normally
 * checked during initialization.
 *
 * The names of drivers are all simple, low-ASCII identifiers, like "cocoa",
 * "x11" or "windows". These never have Unicode characters, and are not meant
 * to be proper names.
 *
 * @param index the index of a video driver.
 * @returns the name of the video driver with the given **index**.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetNumVideoDrivers
 */
inline const char* GetVideoDriver(int index)
{
  return SDL_GetVideoDriver(index);
}

/**
 * Get the name of the currently initialized video driver.
 *
 * The names of drivers are all simple, low-ASCII identifiers, like "cocoa",
 * "x11" or "windows". These never have Unicode characters, and are not meant
 * to be proper names.
 *
 * @returns the name of the current video driver or nullptr if no driver has
 * been initialized.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetNumVideoDrivers
 * @sa GetVideoDriver
 */
inline const char* GetCurrentVideoDriver()
{
  return SDL_GetCurrentVideoDriver();
}

/**
 * Get the current system theme.
 *
 * @returns the current system theme, light, dark, or unknown.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline SystemTheme GetSystemTheme() { return SDL_GetSystemTheme(); }

/**
 * Get a list of currently connected displays.
 *
 * @param count a pointer filled in with the number of displays returned, may
 *              be nullptr.
 * @returns a 0 terminated array of display instance IDs or nullptr on failure;
 *          call GetError() for more information. This should be freed
 *          with free() when it is no longer needed.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline OwnArray<DisplayID> GetDisplays()
{
  int count = 0;
  auto data = reinterpret_cast<DisplayID*>(SDL_GetDisplays(&count));
  return OwnArray<DisplayID>{data, size_t(count)};
}

inline OwnArray<DisplayID> Display::GetAll() { return SDL::GetDisplays(); }

/**
 * Return the primary display.
 *
 * @returns the instance ID of the primary display on success.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Display.GetAll
 */
inline Display GetPrimaryDisplay()
{
  return CheckError(SDL_GetPrimaryDisplay());
}

inline Display Display::GetPrimary() { return SDL::GetPrimaryDisplay(); }

/**
 * Get the properties associated with a display.
 *
 * The following read-only properties are provided by SDL:
 *
 * - `prop::Display.HDR_ENABLED_BOOLEAN`: true if the display has HDR
 *   headroom above the SDR white point. This is for informational and
 *   diagnostic purposes only, as not all platforms provide this information
 *   at the display level.
 *
 * On KMS/DRM:
 *
 * - `prop::Display.KMSDRM_PANEL_ORIENTATION_NUMBER`: the "panel
 *   orientation" property for the display in degrees of clockwise rotation.
 *   Note that this is provided only as a hint, and the application is
 *   responsible for any coordinate transformations needed to conform to the
 *   requested display orientation.
 *
 * @param displayID the instance ID of the display to query.
 * @returns a valid property ID on success.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline PropertiesRef GetDisplayProperties(DisplayID displayID)
{
  return {CheckError(SDL_GetDisplayProperties(displayID))};
}

inline PropertiesRef Display::GetProperties() const
{
  return SDL::GetDisplayProperties(m_displayID);
}

namespace prop::Display {

constexpr auto HDR_ENABLED_BOOLEAN = SDL_PROP_DISPLAY_HDR_ENABLED_BOOLEAN;

constexpr auto KMSDRM_PANEL_ORIENTATION_NUMBER =
  SDL_PROP_DISPLAY_KMSDRM_PANEL_ORIENTATION_NUMBER;

} // namespace prop::Display

/**
 * Get the name of a display in UTF-8 encoding.
 *
 * @param displayID the instance ID of the display to query.
 * @returns the name of a display or nullptr on failure; call GetError() for
 *          more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Display.GetAll
 */
inline const char* GetDisplayName(DisplayID displayID)
{
  return SDL_GetDisplayName(displayID);
}

inline const char* Display::GetName() const
{
  return SDL::GetDisplayName(m_displayID);
}

/**
 * Get the desktop area represented by a display.
 *
 * The primary display is often located at (0,0), but may be placed at a
 * different location depending on monitor layout.
 *
 * @param displayID the instance ID of the display to query.
 * @param rect the Rect structure filled in with the display bounds.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Display.GetUsableBounds
 * @sa Display.GetAll
 */
inline Rect GetDisplayBounds(DisplayID displayID)
{
  Rect bounds;
  SDL_GetDisplayBounds(displayID, &bounds);
  return bounds;
}

inline Rect Display::GetBounds() const
{
  return SDL::GetDisplayBounds(m_displayID);
}

/**
 * Get the usable desktop area represented by a display, in screen
 * coordinates.
 *
 * This is the same area as Display.GetBounds() reports, but with portions
 * reserved by the system removed. For example, on Apple's macOS, this
 * subtracts the area occupied by the menu bar and dock.
 *
 * Setting a window to be fullscreen generally bypasses these unusable areas,
 * so these are good guidelines for the maximum space available to a
 * non-fullscreen window.
 *
 * @param displayID the instance ID of the display to query.
 * @param rect the Rect structure filled in with the display bounds.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Display.GetBounds
 * @sa Display.GetAll
 */
inline Rect GetDisplayUsableBounds(DisplayID displayID)
{
  Rect bounds;
  SDL_GetDisplayUsableBounds(displayID, &bounds);
  return bounds;
}

inline Rect Display::GetUsableBounds() const
{
  return SDL::GetDisplayUsableBounds(m_displayID);
}

/**
 * Get the orientation of a display when it is unrotated.
 *
 * @param displayID the instance ID of the display to query.
 * @returns the DisplayOrientation enum value of the display, or
 *          `ORIENTATION_UNKNOWN` if it isn't available.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Display.GetAll
 */
inline DisplayOrientation GetNaturalDisplayOrientation(DisplayID displayID)
{
  return SDL_GetNaturalDisplayOrientation(displayID);
}

inline DisplayOrientation Display::GetNaturalOrientation() const
{
  return SDL::GetNaturalDisplayOrientation(m_displayID);
}

/**
 * Get the orientation of a display.
 *
 * @param displayID the instance ID of the display to query.
 * @returns the DisplayOrientation enum value of the display, or
 *          `ORIENTATION_UNKNOWN` if it isn't available.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Display.GetAll
 */
inline DisplayOrientation GetCurrentDisplayOrientation(DisplayID displayID)
{
  return SDL_GetCurrentDisplayOrientation(displayID);
}

inline DisplayOrientation Display::GetCurrentOrientation() const
{
  return SDL::GetCurrentDisplayOrientation(m_displayID);
}

/**
 * Get the content scale of a display.
 *
 * The content scale is the expected scale for content based on the DPI
 * settings of the display. For example, a 4K display might have a 2.0 (200%)
 * display scale, which means that the user expects UI elements to be twice as
 * big on this display, to aid in readability.
 *
 * After window creation, Window.GetDisplayScale() should be used to query
 * the content scale factor for individual windows instead of querying the
 * display for a window and calling this function, as the per-window content
 * scale factor may differ from the base value of the display it is on,
 * particularly on high-DPI and/or multi-monitor desktop configurations.
 *
 * @param displayID the instance ID of the display to query.
 * @returns the content scale of the display, or 0.0f on failure; call
 *          GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetDisplayScale
 * @sa Display.GetAll
 */
inline float GetDisplayContentScale(DisplayID displayID)
{
  return SDL_GetDisplayContentScale(displayID);
}

inline float Display::GetContentScale() const
{
  return SDL::GetDisplayContentScale(m_displayID);
}

/**
 * Get a list of fullscreen display modes available on a display.
 *
 * The display modes are sorted in this priority:
 *
 * - w -> largest to smallest
 * - h -> largest to smallest
 * - bits per pixel -> more colors to fewer colors
 * - packed pixel layout -> largest to smallest
 * - refresh rate -> highest to lowest
 * - pixel density -> lowest to highest
 *
 * @param displayID the instance ID of the display to query.
 * @param count a pointer filled in with the number of display modes returned,
 *              may be nullptr.
 * @returns a nullptr terminated array of display mode pointers or nullptr on
 *          failure; call GetError() for more information. This is a
 *          single allocation that should be freed with free() when it is
 *          no longer needed.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Display.GetAll
 */
inline OwnArray<DisplayMode*> GetFullscreenDisplayModes(DisplayID displayID)
{
  int count = 0;
  auto data = CheckError(SDL_GetFullscreenDisplayModes(displayID, &count));
  return OwnArray<DisplayMode*>{data, size_t(count)};
}

inline OwnArray<DisplayMode*> Display::GetFullscreenModes() const
{
  return SDL::GetFullscreenDisplayModes(m_displayID);
}

/**
 * Get the closest match to the requested display mode.
 *
 * The available display modes are scanned and `closest` is filled in with the
 * closest mode matching the requested mode and returned. The mode format and
 * refresh rate default to the desktop mode if they are set to 0. The modes
 * are scanned with size being first priority, format being second priority,
 * and finally checking the refresh rate. If all the available modes are too
 * small, then false is returned.
 *
 * @param displayID the instance ID of the display to query.
 * @param size the width and height in pixels of the desired display mode.
 * @param refresh_rate the refresh rate of the desired display mode, or 0.0f
 *                     for the desktop refresh rate.
 * @param include_high_density_modes boolean to include high density modes in
 *                                   the search.
 * @param closest a pointer filled in with the closest display mode equal to
 *                or larger than the desired mode.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Display.GetAll
 * @sa Display.GetFullscreenModes
 */
inline DisplayMode GetClosestFullscreenDisplayMode(
  DisplayID displayID,
  const PointRaw& size,
  float refresh_rate,
  bool include_high_density_modes)
{
  DisplayMode mode;
  CheckError(SDL_GetClosestFullscreenDisplayMode(displayID,
                                                 size.x,
                                                 size.y,
                                                 refresh_rate,
                                                 include_high_density_modes,
                                                 &mode));
  return mode;
}

inline DisplayMode Display::GetClosestFullscreenMode(
  const PointRaw& size,
  float refresh_rate,
  bool include_high_density_modes) const
{
  return SDL::GetClosestFullscreenDisplayMode(
    m_displayID, size, refresh_rate, include_high_density_modes);
}

/**
 * Get information about the desktop's display mode.
 *
 * There's a difference between this function and Display.GetCurrentMode()
 * when SDL runs fullscreen and has changed the resolution. In that case this
 * function will return the previous native display mode, and not the current
 * display mode.
 *
 * @param displayID the instance ID of the display to query.
 * @returns a pointer to the desktop display mode or nullptr on failure; call
 *          GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Display.GetCurrentMode
 * @sa Display.GetAll
 */
inline const DisplayMode* GetDesktopDisplayMode(DisplayID displayID)
{
  return SDL_GetDesktopDisplayMode(displayID);
}

inline const DisplayMode* Display::GetDesktopMode() const
{
  return SDL::GetDesktopDisplayMode(m_displayID);
}

/**
 * Get information about the current display mode.
 *
 * There's a difference between this function and Display.GetDesktopMode()
 * when SDL runs fullscreen and has changed the resolution. In that case this
 * function will return the current display mode, and not the previous native
 * display mode.
 *
 * @param displayID the instance ID of the display to query.
 * @returns a pointer to the desktop display mode or nullptr on failure; call
 *          GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Display.GetDesktopMode
 * @sa Display.GetAll
 */
inline const DisplayMode* GetCurrentDisplayMode(DisplayID displayID)
{
  return SDL_GetCurrentDisplayMode(displayID);
}

inline const DisplayMode* Display::GetCurrentMode() const
{
  return SDL::GetCurrentDisplayMode(m_displayID);
}

/**
 * Get the display containing a point.
 *
 * @param point the point to query.
 * @returns the instance ID of the display containing the point or 0 on
 *          failure; call GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Display.GetBounds
 * @sa Display.GetAll
 */
inline Display GetDisplayForPoint(const PointRaw& point)
{
  return SDL_GetDisplayForPoint(&point);
}

inline Display Display::GetForPoint(const PointRaw& point)
{
  return SDL::GetDisplayForPoint(point);
}

/**
 * Get the display primarily containing a rect.
 *
 * @param rect the rect to query.
 * @returns the instance ID of the display entirely containing the rect or
 *          closest to the center of the rect on success or 0 on failure; call
 *          GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Display.GetBounds
 * @sa Display.GetAll
 */
inline Display GetDisplayForRect(const RectRaw& rect)
{
  return SDL_GetDisplayForRect(&rect);
}

inline Display Display::GetForRect(const RectRaw& rect)
{
  return SDL::GetDisplayForRect(rect);
}

/**
 * Get the display associated with a window.
 *
 * @param window the window to query.
 * @returns the instance ID of the display containing the center of the window
 *          on success or 0 on failure; call GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Display.GetBounds
 * @sa Display.GetAll
 */
inline Display GetDisplayForWindow(WindowParam window)
{
  return SDL_GetDisplayForWindow(window);
}

inline Display Window::GetDisplay() const
{
  return SDL::GetDisplayForWindow(m_resource);
}

/**
 * Get the pixel density of a window.
 *
 * This is a ratio of pixel size to window size. For example, if the window is
 * 1920x1080 and it has a high density back buffer of 3840x2160 pixels, it
 * would have a pixel density of 2.0.
 *
 * @param window the window to query.
 * @returns the pixel density or 0.0f on failure; call GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetDisplayScale
 */
inline float GetWindowPixelDensity(WindowParam window)
{
  return SDL_GetWindowPixelDensity(window);
}

inline float Window::GetPixelDensity() const
{
  return SDL::GetWindowPixelDensity(m_resource);
}

/**
 * Get the content display scale relative to a window's pixel size.
 *
 * This is a combination of the window pixel density and the display content
 * scale, and is the expected scale for displaying content in this window. For
 * example, if a 3840x2160 window had a display scale of 2.0, the user expects
 * the content to take twice as many pixels and be the same physical size as
 * if it were being displayed in a 1920x1080 window with a display scale of
 * 1.0.
 *
 * Conceptually this value corresponds to the scale display setting, and is
 * updated when that setting is changed, or the window moves to a display with
 * a different scale setting.
 *
 * @param window the window to query.
 * @returns the display scale, or 0.0f on failure; call GetError() for
 *          more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline float GetWindowDisplayScale(WindowParam window)
{
  return SDL_GetWindowDisplayScale(window);
}

inline float Window::GetDisplayScale() const
{
  return SDL::GetWindowDisplayScale(m_resource);
}

/**
 * Set the display mode to use when a window is visible and fullscreen.
 *
 * This only affects the display mode used when the window is fullscreen. To
 * change the window size when the window is not fullscreen, use
 * Window.SetSize().
 *
 * If the window is currently in the fullscreen state, this request is
 * asynchronous on some windowing systems and the new mode dimensions may not
 * be applied immediately upon the return of this function. If an immediate
 * change is required, call Window.Sync() to block until the changes have
 * taken effect.
 *
 * When the new mode takes effect, an EVENT_WINDOW_RESIZED and/or an
 * EVENT_WINDOW_PIXEL_SIZE_CHANGED event will be emitted with the new mode
 * dimensions.
 *
 * @param window the window to affect.
 * @param mode a pointer to the display mode to use, which can be nullptr for
 *             borderless fullscreen desktop mode, or one of the fullscreen
 *             modes returned by Display.GetFullscreenModes() to set an
 *             exclusive fullscreen mode.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetFullscreenMode
 * @sa Window.SetFullscreen
 * @sa Window.Sync
 */
inline void SetWindowFullscreenMode(WindowParam window,
                                    OptionalRef<const DisplayMode> mode)
{
  CheckError(SDL_SetWindowFullscreenMode(window, mode));
}

inline void Window::SetFullscreenMode(OptionalRef<const DisplayMode> mode)
{
  SDL::SetWindowFullscreenMode(m_resource, mode);
}

/**
 * Query the display mode to use when a window is visible at fullscreen.
 *
 * @param window the window to query.
 * @returns a pointer to the exclusive fullscreen mode to use or nullptr for
 *          borderless fullscreen desktop mode.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.SetFullscreenMode
 * @sa Window.SetFullscreen
 */
inline const DisplayMode* GetWindowFullscreenMode(WindowParam window)
{
  return SDL_GetWindowFullscreenMode(window);
}

inline const DisplayMode* Window::GetFullscreenMode() const
{
  return SDL::GetWindowFullscreenMode(m_resource);
}

/**
 * Get the raw ICC profile data for the screen the window is currently on.
 *
 * @param window the window to query.
 * @returns the raw ICC profile data on success.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline OwnPtr<void> GetWindowICCProfile(WindowParam window)
{
  size_t size;
  return OwnPtr<void>{CheckError(SDL_GetWindowICCProfile(window, &size))};
}

inline OwnPtr<void> Window::GetICCProfile() const
{
  return SDL::GetWindowICCProfile(m_resource);
}

/**
 * Get the pixel format associated with the window.
 *
 * @param window the window to query.
 * @returns the pixel format of the window on success.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline PixelFormat GetWindowPixelFormat(WindowParam window)
{
  return CheckError(SDL_GetWindowPixelFormat(window));
}

inline PixelFormat Window::GetPixelFormat() const
{
  return SDL::GetWindowPixelFormat(m_resource);
}

/**
 * Get a list of valid windows.
 *
 * @returns a nullptr terminated array of Window pointers or nullptr on failure;
 *          call GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline OwnArray<WindowRef> GetWindows()
{
  int count = 0;
  auto data = CheckError(SDL_GetWindows(&count));
  return OwnArray<WindowRef>{reinterpret_cast<WindowRef*>(data), size_t(count)};
}

/**
 * Create a window with the specified dimensions and flags.
 *
 * The window size is a request and may be different than expected based on
 * the desktop layout and window manager policies. Your application should be
 * prepared to handle a window of any size.
 *
 * `flags` may be any of the following OR'd together:
 *
 * - `WINDOW_FULLSCREEN`: fullscreen window at desktop resolution
 * - `WINDOW_OPENGL`: window usable with an OpenGL context
 * - `WINDOW_OCCLUDED`: window partially or completely obscured by another
 *   window
 * - `WINDOW_HIDDEN`: window is not visible
 * - `WINDOW_BORDERLESS`: no window decoration
 * - `WINDOW_RESIZABLE`: window can be resized
 * - `WINDOW_MINIMIZED`: window is minimized
 * - `WINDOW_MAXIMIZED`: window is maximized
 * - `WINDOW_MOUSE_GRABBED`: window has grabbed mouse focus
 * - `WINDOW_INPUT_FOCUS`: window has input focus
 * - `WINDOW_MOUSE_FOCUS`: window has mouse focus
 * - `WINDOW_EXTERNAL`: window not created by SDL
 * - `WINDOW_MODAL`: window is modal
 * - `WINDOW_HIGH_PIXEL_DENSITY`: window uses high pixel density back
 *   buffer if possible
 * - `WINDOW_MOUSE_CAPTURE`: window has mouse captured (unrelated to
 *   MOUSE_GRABBED)
 * - `WINDOW_ALWAYS_ON_TOP`: window should always be above others
 * - `WINDOW_UTILITY`: window should be treated as a utility window, not
 *   showing in the task bar and window list
 * - `WINDOW_TOOLTIP`: window should be treated as a tooltip and does not
 *   get mouse or keyboard focus, requires a parent window
 * - `WINDOW_POPUP_MENU`: window should be treated as a popup menu,
 *   requires a parent window
 * - `WINDOW_KEYBOARD_GRABBED`: window has grabbed keyboard input
 * - `WINDOW_VULKAN`: window usable with a Vulkan instance
 * - `WINDOW_METAL`: window usable with a Metal instance
 * - `WINDOW_TRANSPARENT`: window with transparent buffer
 * - `WINDOW_NOT_FOCUSABLE`: window should not be focusable
 *
 * The Window is implicitly shown if WINDOW_HIDDEN is not set.
 *
 * On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist
 * property to YES, otherwise you will not receive a High-DPI OpenGL canvas.
 *
 * The window pixel size may differ from its window coordinate size if the
 * window is on a high pixel density display. Use Window.GetSize() to query
 * the client area's size in window coordinates, and
 * Window.GetSizeInPixels() or Renderer.GetOutputSize() to query the
 * drawable size in pixels. Note that the drawable size can vary after the
 * window is created and should be queried again if you get an
 * EVENT_WINDOW_PIXEL_SIZE_CHANGED event.
 *
 * If the window is created with any of the WINDOW_OPENGL or
 * WINDOW_VULKAN flags, then the corresponding LoadLibrary function
 * (GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the
 * corresponding UnloadLibrary function is called by Window.Destroy().
 *
 * If WINDOW_VULKAN is specified and there isn't a working Vulkan driver,
 * Window.Window() will fail, because SDL_Vulkan_LoadLibrary() will fail.
 *
 * If WINDOW_METAL is specified on an OS that does not support Metal,
 * Window.Window() will fail.
 *
 * If you intend to use this window with an Renderer, you should use
 * CreateWindowAndRenderer() instead of this function, to avoid window
 * flicker.
 *
 * On non-Apple devices, SDL requires you to either not link to the Vulkan
 * loader or link to a dynamic library version. This limitation may be removed
 * in a future version of SDL.
 *
 * @param title the title of the window, in UTF-8 encoding.
 * @param size the width and height of the window.
 * @param flags 0, or one or more WindowFlags OR'd together.
 * @returns the window that was created or nullptr on failure; call
 *          GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa CreateWindowAndRenderer
 * @sa Window.Window
 * @sa Window.Window
 * @sa Window.Destroy
 */
inline Window CreateWindow(StringParam title,
                           const PointRaw& size,
                           WindowFlags flags)
{
  return Window(std::move(title), size, flags);
}

/**
 * Create a child popup window of the specified parent window.
 *
 * The window size is a request and may be different than expected based on
 * the desktop layout and window manager policies. Your application should be
 * prepared to handle a window of any size.
 *
 * The flags parameter **must** contain at least one of the following:
 *
 * - `WINDOW_TOOLTIP`: The popup window is a tooltip and will not pass any
 *   input events.
 * - `WINDOW_POPUP_MENU`: The popup window is a popup menu. The topmost
 *   popup menu will implicitly gain the keyboard focus.
 *
 * The following flags are not relevant to popup window creation and will be
 * ignored:
 *
 * - `WINDOW_MINIMIZED`
 * - `WINDOW_MAXIMIZED`
 * - `WINDOW_FULLSCREEN`
 * - `WINDOW_BORDERLESS`
 *
 * The following flags are incompatible with popup window creation and will
 * cause it to fail:
 *
 * - `WINDOW_UTILITY`
 * - `WINDOW_MODAL`
 *
 * The parent parameter **must** be non-null and a valid window. The parent of
 * a popup window can be either a regular, toplevel window, or another popup
 * window.
 *
 * Popup windows cannot be minimized, maximized, made fullscreen, raised,
 * flash, be made a modal window, be the parent of a toplevel window, or grab
 * the mouse and/or keyboard. Attempts to do so will fail.
 *
 * Popup windows implicitly do not have a border/decorations and do not appear
 * on the taskbar/dock or in lists of windows such as alt-tab menus.
 *
 * By default, popup window positions will automatically be constrained to keep
 * the entire window within display bounds. This can be overridden with the
 * `prop::Window.CREATE_CONSTRAIN_POPUP_BOOLEAN` property.
 *
 * By default, popup menus will automatically grab keyboard focus from the
 * parent when shown. This behavior can be overridden by setting the
 * `WINDOW_NOT_FOCUSABLE` flag, setting the
 * `prop::Window.CREATE_FOCUSABLE_BOOLEAN` property to false, or toggling it
 * after creation via the `Window.SetFocusable()` function.
 *
 * If a parent window is hidden or destroyed, any child popup windows will be
 * recursively hidden or destroyed as well. Child popup windows not explicitly
 * hidden will be restored when the parent is shown.
 *
 * @param parent the parent of the window, must not be nullptr.
 * @param offset the x, y position of the popup window relative to the origin
 *               of the parent.
 * @param size the width and height of the window.
 * @param flags WINDOW_TOOLTIP or WINDOW_POPUP_MENU, and zero or more
 *              additional WindowFlags OR'd together.
 * @returns the window that was created or nullptr on failure; call
 *          GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.Window
 * @sa Window.Window
 * @sa Window.Destroy
 * @sa Window.GetParent
 */
inline Window CreatePopupWindow(WindowParam parent,
                                const PointRaw& offset,
                                const PointRaw& size,
                                WindowFlags flags)
{
  return Window(parent, offset, size, flags);
}

/**
 * Create a window with the specified properties.
 *
 * The window size is a request and may be different than expected based on
 * the desktop layout and window manager policies. Your application should be
 * prepared to handle a window of any size.
 *
 * These are the supported properties:
 *
 * - `prop::Window.CREATE_ALWAYS_ON_TOP_BOOLEAN`: true if the window should
 *   be always on top
 * - `prop::Window.CREATE_BORDERLESS_BOOLEAN`: true if the window has no
 *   window decoration
 * - `prop::Window.CREATE_CONSTRAIN_POPUP_BOOLEAN`: true if the "tooltip" and
 *   "menu" window types should be automatically constrained to be entirely
 * within display bounds (default), false if no constraints on the position are
 * desired.
 * - `prop::Window.CREATE_EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN`: true if the
 *   window will be used with an externally managed graphics context.
 * - `prop::Window.CREATE_FOCUSABLE_BOOLEAN`: true if the window should
 *   accept keyboard input (defaults true)
 * - `prop::Window.CREATE_FULLSCREEN_BOOLEAN`: true if the window should
 *   start in fullscreen mode at desktop resolution
 * - `prop::Window.CREATE_HEIGHT_NUMBER`: the height of the window
 * - `prop::Window.CREATE_HIDDEN_BOOLEAN`: true if the window should start
 *   hidden
 * - `prop::Window.CREATE_HIGH_PIXEL_DENSITY_BOOLEAN`: true if the window
 *   uses a high pixel density buffer if possible
 * - `prop::Window.CREATE_MAXIMIZED_BOOLEAN`: true if the window should
 *   start maximized
 * - `prop::Window.CREATE_MENU_BOOLEAN`: true if the window is a popup menu
 * - `prop::Window.CREATE_METAL_BOOLEAN`: true if the window will be used
 *   with Metal rendering
 * - `prop::Window.CREATE_MINIMIZED_BOOLEAN`: true if the window should
 *   start minimized
 * - `prop::Window.CREATE_MODAL_BOOLEAN`: true if the window is modal to
 *   its parent
 * - `prop::Window.CREATE_MOUSE_GRABBED_BOOLEAN`: true if the window starts
 *   with grabbed mouse focus
 * - `prop::Window.CREATE_OPENGL_BOOLEAN`: true if the window will be used
 *   with OpenGL rendering
 * - `prop::Window.CREATE_PARENT_POINTER`: an Window that will be the
 *   parent of this window, required for windows with the "tooltip", "menu",
 *   and "modal" properties
 * - `prop::Window.CREATE_RESIZABLE_BOOLEAN`: true if the window should be
 *   resizable
 * - `prop::Window.CREATE_TITLE_STRING`: the title of the window, in UTF-8
 *   encoding
 * - `prop::Window.CREATE_TRANSPARENT_BOOLEAN`: true if the window show
 *   transparent in the areas with alpha of 0
 * - `prop::Window.CREATE_TOOLTIP_BOOLEAN`: true if the window is a tooltip
 * - `prop::Window.CREATE_UTILITY_BOOLEAN`: true if the window is a utility
 *   window, not showing in the task bar and window list
 * - `prop::Window.CREATE_VULKAN_BOOLEAN`: true if the window will be used
 *   with Vulkan rendering
 * - `prop::Window.CREATE_WIDTH_NUMBER`: the width of the window
 * - `prop::Window.CREATE_X_NUMBER`: the x position of the window, or
 *   `SDL_WINDOWPOS_CENTERED`, defaults to `SDL_WINDOWPOS_UNDEFINED`. This is
 *   relative to the parent for windows with the "tooltip" or "menu" property
 *   set.
 * - `prop::Window.CREATE_Y_NUMBER`: the y position of the window, or
 *   `SDL_WINDOWPOS_CENTERED`, defaults to `SDL_WINDOWPOS_UNDEFINED`. This is
 *   relative to the parent for windows with the "tooltip" or "menu" property
 *   set.
 *
 * These are additional supported properties on macOS:
 *
 * - `prop::Window.CREATE_COCOA_WINDOW_POINTER`: the
 *   `(__unsafe_unretained)` NSWindow associated with the window, if you want
 *   to wrap an existing window.
 * - `prop::Window.CREATE_COCOA_VIEW_POINTER`: the `(__unsafe_unretained)`
 *   NSView associated with the window, defaults to `[window contentView]`
 *
 * These are additional supported properties on Wayland:
 *
 * - `prop::Window.CREATE_WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN` - true if
 *   the application wants to use the Wayland surface for a custom role and
 *   does not want it attached to an XDG toplevel window. See
 *   [README/wayland](README/wayland) for more information on using custom
 *   surfaces.
 * - `prop::Window.CREATE_WAYLAND_CREATE_EGL_WINDOW_BOOLEAN` - true if the
 *   application wants an associated `wl_egl_window` object to be created and
 *   attached to the window, even if the window does not have the OpenGL
 *   property or `WINDOW_OPENGL` flag set.
 * - `prop::Window.CREATE_WAYLAND_WL_SURFACE_POINTER` - the wl_surface
 *   associated with the window, if you want to wrap an existing window. See
 *   [README/wayland](README/wayland) for more information.
 *
 * These are additional supported properties on Windows:
 *
 * - `prop::Window.CREATE_WIN32_HWND_POINTER`: the HWND associated with the
 *   window, if you want to wrap an existing window.
 * - `prop::Window.CREATE_WIN32_PIXEL_FORMAT_HWND_POINTER`: optional,
 *   another window to share pixel format with, useful for OpenGL windows
 *
 * These are additional supported properties with X11:
 *
 * - `prop::Window.CREATE_X11_WINDOW_NUMBER`: the X11 Window associated
 *   with the window, if you want to wrap an existing window.
 *
 * The window is implicitly shown if the "hidden" property is not set.
 *
 * Windows with the "tooltip" and "menu" properties are popup windows and have
 * the behaviors and guidelines outlined in Window.Window().
 *
 * If this window is being created to be used with an Renderer, you should
 * not add a graphics API specific property
 * (`prop::Window.CREATE_OPENGL_BOOLEAN`, etc), as SDL will handle that
 * internally when it chooses a renderer. However, SDL might need to recreate
 * your window at that point, which may cause the window to appear briefly,
 * and then flicker as it is recreated. The correct approach to this is to
 * create the window with the `prop::Window.CREATE_HIDDEN_BOOLEAN` property
 * set to true, then create the renderer, then show the window with
 * Window.Show().
 *
 * @param props the properties to use.
 * @returns the window that was created or nullptr on failure; call
 *          GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Properties.Create
 * @sa Window.Window
 * @sa Window.Destroy
 */
inline Window CreateWindowWithProperties(PropertiesParam props)
{
  return Window(props);
}

namespace prop::Window {

constexpr auto CREATE_ALWAYS_ON_TOP_BOOLEAN =
  SDL_PROP_WINDOW_CREATE_ALWAYS_ON_TOP_BOOLEAN;

constexpr auto CREATE_BORDERLESS_BOOLEAN =
  SDL_PROP_WINDOW_CREATE_BORDERLESS_BOOLEAN;

constexpr auto CREATE_CONSTRAIN_POPUP_BOOLEAN =
  SDL_PROP_WINDOW_CREATE_CONSTRAIN_POPUP_BOOLEAN;

constexpr auto CREATE_FOCUSABLE_BOOLEAN =
  SDL_PROP_WINDOW_CREATE_FOCUSABLE_BOOLEAN;

constexpr auto CREATE_EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN =
  SDL_PROP_WINDOW_CREATE_EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN;

constexpr auto CREATE_FLAGS_NUMBER = SDL_PROP_WINDOW_CREATE_FLAGS_NUMBER;

constexpr auto CREATE_FULLSCREEN_BOOLEAN =
  SDL_PROP_WINDOW_CREATE_FULLSCREEN_BOOLEAN;

constexpr auto CREATE_HEIGHT_NUMBER = SDL_PROP_WINDOW_CREATE_HEIGHT_NUMBER;

constexpr auto CREATE_HIDDEN_BOOLEAN = SDL_PROP_WINDOW_CREATE_HIDDEN_BOOLEAN;

constexpr auto CREATE_HIGH_PIXEL_DENSITY_BOOLEAN =
  SDL_PROP_WINDOW_CREATE_HIGH_PIXEL_DENSITY_BOOLEAN;

constexpr auto CREATE_MAXIMIZED_BOOLEAN =
  SDL_PROP_WINDOW_CREATE_MAXIMIZED_BOOLEAN;

constexpr auto CREATE_MENU_BOOLEAN = SDL_PROP_WINDOW_CREATE_MENU_BOOLEAN;

constexpr auto CREATE_METAL_BOOLEAN = SDL_PROP_WINDOW_CREATE_METAL_BOOLEAN;

constexpr auto CREATE_MINIMIZED_BOOLEAN =
  SDL_PROP_WINDOW_CREATE_MINIMIZED_BOOLEAN;

constexpr auto CREATE_MODAL_BOOLEAN = SDL_PROP_WINDOW_CREATE_MODAL_BOOLEAN;

constexpr auto CREATE_MOUSE_GRABBED_BOOLEAN =
  SDL_PROP_WINDOW_CREATE_MOUSE_GRABBED_BOOLEAN;

constexpr auto CREATE_OPENGL_BOOLEAN = SDL_PROP_WINDOW_CREATE_OPENGL_BOOLEAN;

constexpr auto CREATE_PARENT_POINTER = SDL_PROP_WINDOW_CREATE_PARENT_POINTER;

constexpr auto CREATE_RESIZABLE_BOOLEAN =
  SDL_PROP_WINDOW_CREATE_RESIZABLE_BOOLEAN;

constexpr auto CREATE_TITLE_STRING = SDL_PROP_WINDOW_CREATE_TITLE_STRING;

constexpr auto CREATE_TRANSPARENT_BOOLEAN =
  SDL_PROP_WINDOW_CREATE_TRANSPARENT_BOOLEAN;

constexpr auto CREATE_TOOLTIP_BOOLEAN = SDL_PROP_WINDOW_CREATE_TOOLTIP_BOOLEAN;

constexpr auto CREATE_UTILITY_BOOLEAN = SDL_PROP_WINDOW_CREATE_UTILITY_BOOLEAN;

constexpr auto CREATE_VULKAN_BOOLEAN = SDL_PROP_WINDOW_CREATE_VULKAN_BOOLEAN;

constexpr auto CREATE_WIDTH_NUMBER = SDL_PROP_WINDOW_CREATE_WIDTH_NUMBER;

constexpr auto CREATE_X_NUMBER = SDL_PROP_WINDOW_CREATE_X_NUMBER;

constexpr auto CREATE_Y_NUMBER = SDL_PROP_WINDOW_CREATE_Y_NUMBER;

constexpr auto CREATE_COCOA_WINDOW_POINTER =
  SDL_PROP_WINDOW_CREATE_COCOA_WINDOW_POINTER;

constexpr auto CREATE_COCOA_VIEW_POINTER =
  SDL_PROP_WINDOW_CREATE_COCOA_VIEW_POINTER;

constexpr auto CREATE_WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN =
  SDL_PROP_WINDOW_CREATE_WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN;

constexpr auto CREATE_WAYLAND_CREATE_EGL_WINDOW_BOOLEAN =
  SDL_PROP_WINDOW_CREATE_WAYLAND_CREATE_EGL_WINDOW_BOOLEAN;

constexpr auto CREATE_WAYLAND_WL_SURFACE_POINTER =
  SDL_PROP_WINDOW_CREATE_WAYLAND_WL_SURFACE_POINTER;

constexpr auto CREATE_WIN32_HWND_POINTER =
  SDL_PROP_WINDOW_CREATE_WIN32_HWND_POINTER;

constexpr auto CREATE_WIN32_PIXEL_FORMAT_HWND_POINTER =
  SDL_PROP_WINDOW_CREATE_WIN32_PIXEL_FORMAT_HWND_POINTER;

constexpr auto CREATE_X11_WINDOW_NUMBER =
  SDL_PROP_WINDOW_CREATE_X11_WINDOW_NUMBER;

constexpr auto SHAPE_POINTER = SDL_PROP_WINDOW_SHAPE_POINTER;

constexpr auto HDR_ENABLED_BOOLEAN = SDL_PROP_WINDOW_HDR_ENABLED_BOOLEAN;

constexpr auto SDR_WHITE_LEVEL_FLOAT = SDL_PROP_WINDOW_SDR_WHITE_LEVEL_FLOAT;

constexpr auto HDR_HEADROOM_FLOAT = SDL_PROP_WINDOW_HDR_HEADROOM_FLOAT;

constexpr auto ANDROID_WINDOW_POINTER = SDL_PROP_WINDOW_ANDROID_WINDOW_POINTER;

constexpr auto ANDROID_SURFACE_POINTER =
  SDL_PROP_WINDOW_ANDROID_SURFACE_POINTER;

constexpr auto UIKIT_WINDOW_POINTER = SDL_PROP_WINDOW_UIKIT_WINDOW_POINTER;

constexpr auto UIKIT_METAL_VIEW_TAG_NUMBER =
  SDL_PROP_WINDOW_UIKIT_METAL_VIEW_TAG_NUMBER;

constexpr auto UIKIT_OPENGL_FRAMEBUFFER_NUMBER =
  SDL_PROP_WINDOW_UIKIT_OPENGL_FRAMEBUFFER_NUMBER;

constexpr auto UIKIT_OPENGL_RENDERBUFFER_NUMBER =
  SDL_PROP_WINDOW_UIKIT_OPENGL_RENDERBUFFER_NUMBER;

constexpr auto UIKIT_OPENGL_RESOLVE_FRAMEBUFFER_NUMBER =
  SDL_PROP_WINDOW_UIKIT_OPENGL_RESOLVE_FRAMEBUFFER_NUMBER;

constexpr auto KMSDRM_DEVICE_INDEX_NUMBER =
  SDL_PROP_WINDOW_KMSDRM_DEVICE_INDEX_NUMBER;

constexpr auto KMSDRM_DRM_FD_NUMBER = SDL_PROP_WINDOW_KMSDRM_DRM_FD_NUMBER;

constexpr auto KMSDRM_GBM_DEVICE_POINTER =
  SDL_PROP_WINDOW_KMSDRM_GBM_DEVICE_POINTER;

constexpr auto COCOA_WINDOW_POINTER = SDL_PROP_WINDOW_COCOA_WINDOW_POINTER;

constexpr auto COCOA_METAL_VIEW_TAG_NUMBER =
  SDL_PROP_WINDOW_COCOA_METAL_VIEW_TAG_NUMBER;

constexpr auto OPENVR_OVERLAY_ID = SDL_PROP_WINDOW_OPENVR_OVERLAY_ID;

constexpr auto VIVANTE_DISPLAY_POINTER =
  SDL_PROP_WINDOW_VIVANTE_DISPLAY_POINTER;

constexpr auto VIVANTE_WINDOW_POINTER = SDL_PROP_WINDOW_VIVANTE_WINDOW_POINTER;

constexpr auto VIVANTE_SURFACE_POINTER =
  SDL_PROP_WINDOW_VIVANTE_SURFACE_POINTER;

constexpr auto WIN32_HWND_POINTER = SDL_PROP_WINDOW_WIN32_HWND_POINTER;

constexpr auto WIN32_HDC_POINTER = SDL_PROP_WINDOW_WIN32_HDC_POINTER;

constexpr auto WIN32_INSTANCE_POINTER = SDL_PROP_WINDOW_WIN32_INSTANCE_POINTER;

constexpr auto WAYLAND_DISPLAY_POINTER =
  SDL_PROP_WINDOW_WAYLAND_DISPLAY_POINTER;

constexpr auto WAYLAND_SURFACE_POINTER =
  SDL_PROP_WINDOW_WAYLAND_SURFACE_POINTER;

constexpr auto WAYLAND_VIEWPORT_POINTER =
  SDL_PROP_WINDOW_WAYLAND_VIEWPORT_POINTER;

constexpr auto WAYLAND_EGL_WINDOW_POINTER =
  SDL_PROP_WINDOW_WAYLAND_EGL_WINDOW_POINTER;

constexpr auto WAYLAND_XDG_SURFACE_POINTER =
  SDL_PROP_WINDOW_WAYLAND_XDG_SURFACE_POINTER;

constexpr auto WAYLAND_XDG_TOPLEVEL_POINTER =
  SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_POINTER;

constexpr auto WAYLAND_XDG_TOPLEVEL_EXPORT_HANDLE_STRING =
  SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_EXPORT_HANDLE_STRING;

constexpr auto WAYLAND_XDG_POPUP_POINTER =
  SDL_PROP_WINDOW_WAYLAND_XDG_POPUP_POINTER;

constexpr auto WAYLAND_XDG_POSITIONER_POINTER =
  SDL_PROP_WINDOW_WAYLAND_XDG_POSITIONER_POINTER;

constexpr auto X11_DISPLAY_POINTER = SDL_PROP_WINDOW_X11_DISPLAY_POINTER;

constexpr auto X11_SCREEN_NUMBER = SDL_PROP_WINDOW_X11_SCREEN_NUMBER;

constexpr auto X11_WINDOW_NUMBER = SDL_PROP_WINDOW_X11_WINDOW_NUMBER;

} // namespace prop::Window

/**
 * Get the numeric ID of a window.
 *
 * The numeric ID is what WindowEvent references, and is necessary to map
 * these events to specific Window objects.
 *
 * @param window the window to query.
 * @returns the ID of the window on success.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.FromID
 */
inline WindowID GetWindowID(WindowParam window)
{
  return CheckError(SDL_GetWindowID(window));
}

inline WindowID Window::GetID() const { return SDL::GetWindowID(m_resource); }

/**
 * Get a window from a stored ID.
 *
 * The numeric ID is what WindowEvent references, and is necessary to map
 * these events to specific Window objects.
 *
 * @param id the ID of the window.
 * @returns the window associated with `id` or nullptr if it doesn't exist; call
 *          GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetID
 */
inline WindowRef GetWindowFromID(WindowID id)
{
  return {SDL_GetWindowFromID(id)};
}

inline WindowRef Window::FromID(WindowID id)
{
  return SDL::GetWindowFromID(id);
}

/**
 * Get parent of a window.
 *
 * @param window the window to query.
 * @returns the parent of the window on success.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.Window
 */
inline WindowRef GetWindowParent(WindowParam window)
{
  return {CheckError(SDL_GetWindowParent(window))};
}

inline WindowRef Window::GetParent() const
{
  return SDL::GetWindowParent(m_resource);
}

/**
 * Get the properties associated with a window.
 *
 * The following read-only properties are provided by SDL:
 *
 * - `prop::Window.SHAPE_POINTER`: the surface associated with a shaped
 *   window
 * - `prop::Window.HDR_ENABLED_BOOLEAN`: true if the window has HDR
 *   headroom above the SDR white point. This property can change dynamically
 *   when EVENT_WINDOW_HDR_STATE_CHANGED is sent.
 * - `prop::Window.SDR_WHITE_LEVEL_FLOAT`: the value of SDR white in the
 *   COLORSPACE_SRGB_LINEAR colorspace. On Windows this corresponds to the
 *   SDR white level in scRGB colorspace, and on Apple platforms this is
 *   always 1.0 for EDR content. This property can change dynamically when
 *   EVENT_WINDOW_HDR_STATE_CHANGED is sent.
 * - `prop::Window.HDR_HEADROOM_FLOAT`: the additional high dynamic range
 *   that can be displayed, in terms of the SDR white point. When HDR is not
 *   enabled, this will be 1.0. This property can change dynamically when
 *   EVENT_WINDOW_HDR_STATE_CHANGED is sent.
 *
 * On Android:
 *
 * - `prop::Window.ANDROID_WINDOW_POINTER`: the ANativeWindow associated
 *   with the window
 * - `prop::Window.ANDROID_SURFACE_POINTER`: the EGLSurface associated with
 *   the window
 *
 * On iOS:
 *
 * - `prop::Window.UIKIT_WINDOW_POINTER`: the `(__unsafe_unretained)`
 *   UIWindow associated with the window
 * - `prop::Window.UIKIT_METAL_VIEW_TAG_NUMBER`: the NSInteger tag
 *   associated with metal views on the window
 * - `prop::Window.UIKIT_OPENGL_FRAMEBUFFER_NUMBER`: the OpenGL view's
 *   framebuffer object. It must be bound when rendering to the screen using
 *   OpenGL.
 * - `prop::Window.UIKIT_OPENGL_RENDERBUFFER_NUMBER`: the OpenGL view's
 *   renderbuffer object. It must be bound when GL_SwapWindow is called.
 * - `prop::Window.UIKIT_OPENGL_RESOLVE_FRAMEBUFFER_NUMBER`: the OpenGL
 *   view's resolve framebuffer, when MSAA is used.
 *
 * On KMS/DRM:
 *
 * - `prop::Window.KMSDRM_DEVICE_INDEX_NUMBER`: the device index associated
 *   with the window (e.g. the X in /dev/dri/cardX)
 * - `prop::Window.KMSDRM_DRM_FD_NUMBER`: the DRM FD associated with the
 *   window
 * - `prop::Window.KMSDRM_GBM_DEVICE_POINTER`: the GBM device associated
 *   with the window
 *
 * On macOS:
 *
 * - `prop::Window.COCOA_WINDOW_POINTER`: the `(__unsafe_unretained)`
 *   NSWindow associated with the window
 * - `prop::Window.COCOA_METAL_VIEW_TAG_NUMBER`: the NSInteger tag
 *   associated with metal views on the window
 *
 * On OpenVR:
 *
 * - `prop::Window.OPENVR_OVERLAY_ID`: the OpenVR Overlay Handle ID for the
 *   associated overlay window.
 *
 * On Vivante:
 *
 * - `prop::Window.VIVANTE_DISPLAY_POINTER`: the EGLNativeDisplayType
 *   associated with the window
 * - `prop::Window.VIVANTE_WINDOW_POINTER`: the EGLNativeWindowType
 *   associated with the window
 * - `prop::Window.VIVANTE_SURFACE_POINTER`: the EGLSurface associated with
 *   the window
 *
 * On Windows:
 *
 * - `prop::Window.WIN32_HWND_POINTER`: the HWND associated with the window
 * - `prop::Window.WIN32_HDC_POINTER`: the HDC associated with the window
 * - `prop::Window.WIN32_INSTANCE_POINTER`: the HINSTANCE associated with
 *   the window
 *
 * On Wayland:
 *
 * Note: The `xdg_*` window objects do not internally persist across window
 * show/hide calls. They will be null if the window is hidden and must be
 * queried each time it is shown.
 *
 * - `prop::Window.WAYLAND_DISPLAY_POINTER`: the wl_display associated with
 *   the window
 * - `prop::Window.WAYLAND_SURFACE_POINTER`: the wl_surface associated with
 *   the window
 * - `prop::Window.WAYLAND_VIEWPORT_POINTER`: the wp_viewport associated
 *   with the window
 * - `prop::Window.WAYLAND_EGL_WINDOW_POINTER`: the wl_egl_window
 *   associated with the window
 * - `prop::Window.WAYLAND_XDG_SURFACE_POINTER`: the xdg_surface associated
 *   with the window
 * - `prop::Window.WAYLAND_XDG_TOPLEVEL_POINTER`: the xdg_toplevel role
 *   associated with the window
 * - 'prop::Window.WAYLAND_XDG_TOPLEVEL_EXPORT_HANDLE_STRING': the export
 *   handle associated with the window
 * - `prop::Window.WAYLAND_XDG_POPUP_POINTER`: the xdg_popup role
 *   associated with the window
 * - `prop::Window.WAYLAND_XDG_POSITIONER_POINTER`: the xdg_positioner
 *   associated with the window, in popup mode
 *
 * On X11:
 *
 * - `prop::Window.X11_DISPLAY_POINTER`: the X11 Display associated with
 *   the window
 * - `prop::Window.X11_SCREEN_NUMBER`: the screen number associated with
 *   the window
 * - `prop::Window.X11_WINDOW_NUMBER`: the X11 Window associated with the
 *   window
 *
 * @param window the window to query.
 * @returns a valid property ID on success.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline PropertiesRef GetWindowProperties(WindowParam window)
{
  return {CheckError(SDL_GetWindowProperties(window))};
}

inline PropertiesRef Window::GetProperties() const
{
  return SDL::GetWindowProperties(m_resource);
}

/**
 * Get the window flags.
 *
 * @param window the window to query.
 * @returns a mask of the WindowFlags associated with `window`.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.Window
 * @sa Window.Hide
 * @sa Window.Maximize
 * @sa Window.Minimize
 * @sa Window.SetFullscreen
 * @sa Window.SetMouseGrab
 * @sa Window.Show
 */
inline WindowFlags GetWindowFlags(WindowParam window)
{
  return SDL_GetWindowFlags(window);
}

inline WindowFlags Window::GetFlags() const
{
  return SDL::GetWindowFlags(m_resource);
}

/**
 * Set the title of a window.
 *
 * This string is expected to be in UTF-8 encoding.
 *
 * @param window the window to change.
 * @param title the desired window title in UTF-8 format.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetTitle
 */
inline void SetWindowTitle(WindowParam window, StringParam title)
{
  CheckError(SDL_SetWindowTitle(window, title));
}

inline void Window::SetTitle(StringParam title)
{
  SDL::SetWindowTitle(m_resource, std::move(title));
}

/**
 * Get the title of a window.
 *
 * @param window the window to query.
 * @returns the title of the window in UTF-8 format or "" if there is no
 *          title.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.SetTitle
 */
inline const char* GetWindowTitle(WindowParam window)
{
  return SDL_GetWindowTitle(window);
}

inline const char* Window::GetTitle() const
{
  return SDL::GetWindowTitle(m_resource);
}

/**
 * Set the icon for a window.
 *
 * If this function is passed a surface with alternate representations, the
 * surface will be interpreted as the content to be used for 100% display
 * scale, and the alternate representations will be used for high DPI
 * situations. For example, if the original surface is 32x32, then on a 2x
 * macOS display or 200% display scale on Windows, a 64x64 version of the
 * image will be used, if available. If a matching version of the image isn't
 * available, the closest larger size image will be downscaled to the
 * appropriate size and be used instead, if available. Otherwise, the closest
 * smaller image will be upscaled and be used instead.
 *
 * @param window the window to change.
 * @param icon an Surface structure containing the icon for the window.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void SetWindowIcon(WindowParam window, SurfaceParam icon)
{
  CheckError(SDL_SetWindowIcon(window, icon));
}

inline void Window::SetIcon(SurfaceParam icon)
{
  SDL::SetWindowIcon(m_resource, icon);
}

/**
 * Request that the window's position be set.
 *
 * If the window is in an exclusive fullscreen or maximized state, this
 * request has no effect.
 *
 * This can be used to reposition fullscreen-desktop windows onto a different
 * display, however, as exclusive fullscreen windows are locked to a specific
 * display, they can only be repositioned programmatically via
 * Window.SetFullscreenMode().
 *
 * On some windowing systems this request is asynchronous and the new
 * coordinates may not have have been applied immediately upon the return of
 * this function. If an immediate change is required, call Window.Sync() to
 * block until the changes have taken effect.
 *
 * When the window position changes, an EVENT_WINDOW_MOVED event will be
 * emitted with the window's new coordinates. Note that the new coordinates
 * may not match the exact coordinates requested, as some windowing systems
 * can restrict the position of the window in certain scenarios (e.g.
 * constraining the position so the window is always within desktop bounds).
 * Additionally, as this is just a request, it can be denied by the windowing
 * system.
 *
 * @param window the window to reposition.
 * @param p the coordinates of the window, or `SDL_WINDOWPOS_CENTERED` or
 *          `SDL_WINDOWPOS_UNDEFINED`.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetPosition
 * @sa Window.Sync
 */
inline void SetWindowPosition(WindowParam window, const PointRaw& p)
{
  CheckError(SDL_SetWindowPosition(window, p.x, p.y));
}

inline void Window::SetPosition(const PointRaw& p)
{
  SDL::SetWindowPosition(m_resource, p);
}

/**
 * Get the position of a window.
 *
 * This is the current position of the window as last reported by the
 * windowing system.
 *
 * If you do not need the value for one of the positions a nullptr may be passed
 * in the `x` or `y` parameter.
 *
 * @param window the window to query.
 * @param x a pointer filled in with the x position of the window, may be
 *          nullptr.
 * @param y a pointer filled in with the y position of the window, may be
 *          nullptr.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.SetPosition
 */
inline void GetWindowPosition(WindowParam window, int* x, int* y)
{
  CheckError(SDL_GetWindowPosition(window, x, y));
}

inline void Window::GetPosition(int* x, int* y) const
{
  SDL::GetWindowPosition(m_resource, x, y);
}

/**
 * Request that the size of a window's client area be set.
 *
 * If the window is in a fullscreen or maximized state, this request has no
 * effect.
 *
 * To change the exclusive fullscreen mode of a window, use
 * Window.SetFullscreenMode().
 *
 * On some windowing systems, this request is asynchronous and the new window
 * size may not have have been applied immediately upon the return of this
 * function. If an immediate change is required, call Window.Sync() to
 * block until the changes have taken effect.
 *
 * When the window size changes, an EVENT_WINDOW_RESIZED event will be
 * emitted with the new window dimensions. Note that the new dimensions may
 * not match the exact size requested, as some windowing systems can restrict
 * the window size in certain scenarios (e.g. constraining the size of the
 * content area to remain within the usable desktop bounds). Additionally, as
 * this is just a request, it can be denied by the windowing system.
 *
 * @param window the window to change.
 * @param p the width and height of the window, must be > 0.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetSize
 * @sa Window.SetFullscreenMode
 * @sa Window.Sync
 */
inline void SetWindowSize(WindowParam window, const PointRaw& p)
{
  CheckError(SDL_SetWindowSize(window, p.x, p.y));
}

inline void Window::SetSize(const PointRaw& p)
{
  SDL::SetWindowSize(m_resource, p);
}

/**
 * Get the size of a window's client area.
 *
 * The window pixel size may differ from its window coordinate size if the
 * window is on a high pixel density display. Use Window.GetSizeInPixels()
 * or Renderer.GetOutputSize() to get the real client area size in pixels.
 *
 * @param window the window to query the width and height from.
 * @param w a pointer filled in with the width of the window, may be nullptr.
 * @param h a pointer filled in with the height of the window, may be nullptr.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.GetOutputSize
 * @sa Window.GetSizeInPixels
 * @sa Window.SetSize
 */
inline void GetWindowSize(WindowParam window, int* w, int* h)
{
  CheckError(SDL_GetWindowSize(window, w, h));
}

inline void Window::GetSize(int* w, int* h) const
{
  SDL::GetWindowSize(m_resource, w, h);
}

/**
 * Get the safe area for this window.
 *
 * Some devices have portions of the screen which are partially obscured or
 * not interactive, possibly due to on-screen controls, curved edges, camera
 * notches, TV overscan, etc. This function provides the area of the window
 * which is safe to have interactable content. You should continue rendering
 * into the rest of the window, but it should not contain visually important
 * or interactible content.
 *
 * @param window the window to query.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Rect GetWindowSafeArea(WindowParam window)
{
  Rect rect;
  CheckError(SDL_GetWindowSafeArea(window, &rect));
  return rect;
}

inline Rect Window::GetSafeArea() const
{
  return SDL::GetWindowSafeArea(m_resource);
}

/**
 * Request that the aspect ratio of a window's client area be set.
 *
 * The aspect ratio is the ratio of width divided by height, e.g. 2560x1600
 * would be 1.6. Larger aspect ratios are wider and smaller aspect ratios are
 * narrower.
 *
 * If, at the time of this request, the window in a fixed-size state, such as
 * maximized or fullscreen, the request will be deferred until the window
 * exits this state and becomes resizable again.
 *
 * On some windowing systems, this request is asynchronous and the new window
 * aspect ratio may not have have been applied immediately upon the return of
 * this function. If an immediate change is required, call Window.Sync() to
 * block until the changes have taken effect.
 *
 * When the window size changes, an EVENT_WINDOW_RESIZED event will be
 * emitted with the new window dimensions. Note that the new dimensions may
 * not match the exact aspect ratio requested, as some windowing systems can
 * restrict the window size in certain scenarios (e.g. constraining the size
 * of the content area to remain within the usable desktop bounds).
 * Additionally, as this is just a request, it can be denied by the windowing
 * system.
 *
 * @param window the window to change.
 * @param min_aspect the minimum aspect ratio of the window, or 0.0f for no
 *                   limit.
 * @param max_aspect the maximum aspect ratio of the window, or 0.0f for no
 *                   limit.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetAspectRatio
 * @sa Window.Sync
 */
inline void SetWindowAspectRatio(WindowParam window,
                                 float min_aspect,
                                 float max_aspect)
{
  CheckError(SDL_SetWindowAspectRatio(window, min_aspect, max_aspect));
}

inline void Window::SetAspectRatio(float min_aspect, float max_aspect)
{
  SDL::SetWindowAspectRatio(m_resource, min_aspect, max_aspect);
}

/**
 * Get the size of a window's client area.
 *
 * @param window the window to query the width and height from.
 * @param min_aspect a pointer filled in with the minimum aspect ratio of the
 *                   window, may be nullptr.
 * @param max_aspect a pointer filled in with the maximum aspect ratio of the
 *                   window, may be nullptr.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.SetAspectRatio
 */
inline void GetWindowAspectRatio(WindowParam window,
                                 float* min_aspect,
                                 float* max_aspect)
{
  CheckError(SDL_GetWindowAspectRatio(window, min_aspect, max_aspect));
}

inline void Window::GetAspectRatio(float* min_aspect, float* max_aspect) const
{
  SDL::GetWindowAspectRatio(m_resource, min_aspect, max_aspect);
}

/**
 * Get the size of a window's borders (decorations) around the client area.
 *
 * Note: If this function fails (returns false), the size values will be
 * initialized to 0, 0, 0, 0 (if a non-nullptr pointer is provided), as if the
 * window in question was borderless.
 *
 * Note: This function may fail on systems where the window has not yet been
 * decorated by the display server (for example, immediately after calling
 * Window.Window). It is recommended that you wait at least until the
 * window has been presented and composited, so that the window system has a
 * chance to decorate the window and provide the border dimensions to SDL.
 *
 * This function also returns false if getting the information is not
 * supported.
 *
 * @param window the window to query the size values of the border
 *               (decorations) from.
 * @param top pointer to variable for storing the size of the top border;
 * nullptr is permitted.
 * @param left pointer to variable for storing the size of the left border;
 *             nullptr is permitted.
 * @param bottom pointer to variable for storing the size of the bottom
 *               border; nullptr is permitted.
 * @param right pointer to variable for storing the size of the right border;
 *              nullptr is permitted.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetSize
 */
inline void GetWindowBordersSize(WindowParam window,
                                 int* top,
                                 int* left,
                                 int* bottom,
                                 int* right)
{
  CheckError(SDL_GetWindowBordersSize(window, top, left, bottom, right));
}

inline void Window::GetBordersSize(int* top,
                                   int* left,
                                   int* bottom,
                                   int* right) const
{
  SDL::GetWindowBordersSize(m_resource, top, left, bottom, right);
}

/**
 * Get the size of a window's client area, in pixels.
 *
 * @param window the window from which the drawable size should be queried.
 * @param w a pointer to variable for storing the width in pixels, may be
 *          nullptr.
 * @param h a pointer to variable for storing the height in pixels, may be
 *          nullptr.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.Window
 * @sa Window.GetSize
 */
inline void GetWindowSizeInPixels(WindowParam window, int* w, int* h)
{
  CheckError(SDL_GetWindowSizeInPixels(window, w, h));
}

inline void Window::GetSizeInPixels(int* w, int* h) const
{
  SDL::GetWindowSizeInPixels(m_resource, w, h);
}

/**
 * Set the minimum size of a window's client area.
 *
 * @param window the window to change.
 * @param p the minimum width and height of the window, or 0 for no limit.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetMinimumSize
 * @sa Window.SetMaximumSize
 */
inline void SetWindowMinimumSize(WindowParam window, const PointRaw& p)
{
  CheckError(SDL_SetWindowMinimumSize(window, p.x, p.y));
}

inline void Window::SetMinimumSize(const PointRaw& p)
{
  SDL::SetWindowMinimumSize(m_resource, p);
}

/**
 * Get the minimum size of a window's client area.
 *
 * @param window the window to query.
 * @param w a pointer filled in with the minimum width of the window, may be
 *          nullptr.
 * @param h a pointer filled in with the minimum height of the window, may be
 *          nullptr.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetMaximumSize
 * @sa Window.SetMinimumSize
 */
inline void GetWindowMinimumSize(WindowParam window, int* w, int* h)
{
  CheckError(SDL_GetWindowMinimumSize(window, w, h));
}

inline void Window::GetMinimumSize(int* w, int* h) const
{
  SDL::GetWindowMinimumSize(m_resource, w, h);
}

/**
 * Set the maximum size of a window's client area.
 *
 * @param window the window to change.
 * @param p the maximum width and height of the window, or 0 for no limit.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetMaximumSize
 * @sa Window.SetMinimumSize
 */
inline void SetWindowMaximumSize(WindowParam window, const PointRaw& p)
{
  CheckError(SDL_SetWindowMaximumSize(window, p.x, p.y));
}

inline void Window::SetMaximumSize(const PointRaw& p)
{
  SDL::SetWindowMaximumSize(m_resource, p);
}

/**
 * Get the maximum size of a window's client area.
 *
 * @param window the window to query.
 * @param w a pointer filled in with the maximum width of the window, may be
 *          nullptr.
 * @param h a pointer filled in with the maximum height of the window, may be
 *          nullptr.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetMinimumSize
 * @sa Window.SetMaximumSize
 */
inline void GetWindowMaximumSize(WindowParam window, int* w, int* h)
{
  CheckError(SDL_GetWindowMaximumSize(window, w, h));
}

inline void Window::GetMaximumSize(int* w, int* h) const
{
  SDL::GetWindowMaximumSize(m_resource, w, h);
}

/**
 * Set the border state of a window.
 *
 * This will add or remove the window's `WINDOW_BORDERLESS` flag and add
 * or remove the border from the actual window. This is a no-op if the
 * window's border already matches the requested state.
 *
 * You can't change the border state of a fullscreen window.
 *
 * @param window the window of which to change the border state.
 * @param bordered false to remove border, true to add border.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetFlags
 */
inline void SetWindowBordered(WindowParam window, bool bordered)
{
  CheckError(SDL_SetWindowBordered(window, bordered));
}

inline void Window::SetBordered(bool bordered)
{
  SDL::SetWindowBordered(m_resource, bordered);
}

/**
 * Set the user-resizable state of a window.
 *
 * This will add or remove the window's `WINDOW_RESIZABLE` flag and
 * allow/disallow user resizing of the window. This is a no-op if the window's
 * resizable state already matches the requested state.
 *
 * You can't change the resizable state of a fullscreen window.
 *
 * @param window the window of which to change the resizable state.
 * @param resizable true to allow resizing, false to disallow.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetFlags
 */
inline void SetWindowResizable(WindowParam window, bool resizable)
{
  CheckError(SDL_SetWindowResizable(window, resizable));
}

inline void Window::SetResizable(bool resizable)
{
  SDL::SetWindowResizable(m_resource, resizable);
}

/**
 * Set the window to always be above the others.
 *
 * This will add or remove the window's `WINDOW_ALWAYS_ON_TOP` flag. This
 * will bring the window to the front and keep the window above the rest.
 *
 * @param window the window of which to change the always on top state.
 * @param on_top true to set the window always on top, false to disable.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetFlags
 */
inline void SetWindowAlwaysOnTop(WindowParam window, bool on_top)
{
  CheckError(SDL_SetWindowAlwaysOnTop(window, on_top));
}

inline void Window::SetAlwaysOnTop(bool on_top)
{
  SDL::SetWindowAlwaysOnTop(m_resource, on_top);
}

/**
 * Show a window.
 *
 * @param window the window to show.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.Hide
 * @sa Window.Raise
 */
inline void ShowWindow(WindowParam window)
{
  CheckError(SDL_ShowWindow(window));
}

inline void Window::Show() { SDL::ShowWindow(m_resource); }

/**
 * Hide a window.
 *
 * @param window the window to hide.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.Show
 * @sa WINDOW_HIDDEN
 */
inline void HideWindow(WindowParam window)
{
  CheckError(SDL_HideWindow(window));
}

inline void Window::Hide() { SDL::HideWindow(m_resource); }

/**
 * Request that a window be raised above other windows and gain the input
 * focus.
 *
 * The result of this request is subject to desktop window manager policy,
 * particularly if raising the requested window would result in stealing focus
 * from another application. If the window is successfully raised and gains
 * input focus, an EVENT_WINDOW_FOCUS_GAINED event will be emitted, and
 * the window will have the WINDOW_INPUT_FOCUS flag set.
 *
 * @param window the window to raise.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void RaiseWindow(WindowParam window)
{
  CheckError(SDL_RaiseWindow(window));
}

inline void Window::Raise() { SDL::RaiseWindow(m_resource); }

/**
 * Request that the window be made as large as possible.
 *
 * Non-resizable windows can't be maximized. The window must have the
 * WINDOW_RESIZABLE flag set, or this will have no effect.
 *
 * On some windowing systems this request is asynchronous and the new window
 * state may not have have been applied immediately upon the return of this
 * function. If an immediate change is required, call Window.Sync() to
 * block until the changes have taken effect.
 *
 * When the window state changes, an EVENT_WINDOW_MAXIMIZED event will be
 * emitted. Note that, as this is just a request, the windowing system can
 * deny the state change.
 *
 * When maximizing a window, whether the constraints set via
 * Window.SetMaximumSize() are honored depends on the policy of the window
 * manager. Win32 and macOS enforce the constraints when maximizing, while X11
 * and Wayland window managers may vary.
 *
 * @param window the window to maximize.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.Minimize
 * @sa Window.Restore
 * @sa Window.Sync
 */
inline void MaximizeWindow(WindowParam window)
{
  CheckError(SDL_MaximizeWindow(window));
}

inline void Window::Maximize() { SDL::MaximizeWindow(m_resource); }

/**
 * Request that the window be minimized to an iconic representation.
 *
 * If the window is in a fullscreen state, this request has no direct effect.
 * It may alter the state the window is returned to when leaving fullscreen.
 *
 * On some windowing systems this request is asynchronous and the new window
 * state may not have been applied immediately upon the return of this
 * function. If an immediate change is required, call Window.Sync() to
 * block until the changes have taken effect.
 *
 * When the window state changes, an EVENT_WINDOW_MINIMIZED event will be
 * emitted. Note that, as this is just a request, the windowing system can
 * deny the state change.
 *
 * @param window the window to minimize.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.Maximize
 * @sa Window.Restore
 * @sa Window.Sync
 */
inline void MinimizeWindow(WindowParam window)
{
  CheckError(SDL_MinimizeWindow(window));
}

inline void Window::Minimize() { SDL::MinimizeWindow(m_resource); }

/**
 * Request that the size and position of a minimized or maximized window be
 * restored.
 *
 * If the window is in a fullscreen state, this request has no direct effect.
 * It may alter the state the window is returned to when leaving fullscreen.
 *
 * On some windowing systems this request is asynchronous and the new window
 * state may not have have been applied immediately upon the return of this
 * function. If an immediate change is required, call Window.Sync() to
 * block until the changes have taken effect.
 *
 * When the window state changes, an EVENT_WINDOW_RESTORED event will be
 * emitted. Note that, as this is just a request, the windowing system can
 * deny the state change.
 *
 * @param window the window to restore.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.Maximize
 * @sa Window.Minimize
 * @sa Window.Sync
 */
inline void RestoreWindow(WindowParam window)
{
  CheckError(SDL_RestoreWindow(window));
}

inline void Window::Restore() { SDL::RestoreWindow(m_resource); }

/**
 * Request that the window's fullscreen state be changed.
 *
 * By default a window in fullscreen state uses borderless fullscreen desktop
 * mode, but a specific exclusive display mode can be set using
 * Window.SetFullscreenMode().
 *
 * On some windowing systems this request is asynchronous and the new
 * fullscreen state may not have have been applied immediately upon the return
 * of this function. If an immediate change is required, call Window.Sync()
 * to block until the changes have taken effect.
 *
 * When the window state changes, an EVENT_WINDOW_ENTER_FULLSCREEN or
 * EVENT_WINDOW_LEAVE_FULLSCREEN event will be emitted. Note that, as this
 * is just a request, it can be denied by the windowing system.
 *
 * @param window the window to change.
 * @param fullscreen true for fullscreen mode, false for windowed mode.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetFullscreenMode
 * @sa Window.SetFullscreenMode
 * @sa Window.Sync
 * @sa WINDOW_FULLSCREEN
 */
inline void SetWindowFullscreen(WindowParam window, bool fullscreen)
{
  CheckError(SDL_SetWindowFullscreen(window, fullscreen));
}

inline void Window::SetFullscreen(bool fullscreen)
{
  SDL::SetWindowFullscreen(m_resource, fullscreen);
}

/**
 * Block until any pending window state is finalized.
 *
 * On asynchronous windowing systems, this acts as a synchronization barrier
 * for pending window state. It will attempt to wait until any pending window
 * state has been applied and is guaranteed to return within finite time. Note
 * that for how long it can potentially block depends on the underlying window
 * system, as window state changes may involve somewhat lengthy animations
 * that must complete before the window is in its final requested state.
 *
 * On windowing systems where changes are immediate, this does nothing.
 *
 * @param window the window for which to wait for the pending state to be
 *               applied.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.SetSize
 * @sa Window.SetPosition
 * @sa Window.SetFullscreen
 * @sa Window.Minimize
 * @sa Window.Maximize
 * @sa Window.Restore
 * @sa SDL_HINT_VIDEO_SYNC_WINDOW_OPERATIONS
 */
inline void SyncWindow(WindowParam window)
{
  CheckError(SDL_SyncWindow(window));
}

inline void Window::Sync() { SDL::SyncWindow(m_resource); }

/**
 * Return whether the window has a surface associated with it.
 *
 * @param window the window to query.
 * @returns true if there is a surface associated with the window, or false
 *          otherwise.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetSurface
 */
inline bool WindowHasSurface(WindowParam window)
{
  return SDL_WindowHasSurface(window);
}

inline bool Window::HasSurface() const
{
  return SDL::WindowHasSurface(m_resource);
}

/**
 * Get the SDL surface associated with the window.
 *
 * A new surface will be created with the optimal format for the window, if
 * necessary. This surface will be freed when the window is destroyed. Do not
 * free this surface.
 *
 * This surface will be invalidated if the window is resized. After resizing a
 * window this function must be called again to return a valid surface.
 *
 * You may not combine this with 3D or the rendering API on this window.
 *
 * This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.
 *
 * @param window the window to query.
 * @returns the surface associated with the window, or nullptr on failure; call
 *          GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.DestroySurface
 * @sa Window.HasSurface
 * @sa Window.UpdateSurface
 * @sa Window.UpdateSurfaceRects
 */
inline Surface GetWindowSurface(WindowParam window)
{
  return Surface::Borrow(SDL_GetWindowSurface(window));
}

inline Surface Window::GetSurface()
{
  return SDL::GetWindowSurface(m_resource);
}

/**
 * Toggle VSync for the window surface.
 *
 * When a window surface is created, vsync defaults to
 * WINDOW_SURFACE_VSYNC_DISABLED.
 *
 * The `vsync` parameter can be 1 to synchronize present with every vertical
 * refresh, 2 to synchronize present with every second vertical refresh, etc.,
 * WINDOW_SURFACE_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync),
 * or WINDOW_SURFACE_VSYNC_DISABLED to disable. Not every value is
 * supported by every driver, so you should check the return value to see
 * whether the requested setting is supported.
 *
 * @param window the window.
 * @param vsync the vertical refresh sync interval.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetSurfaceVSync
 */
inline void SetWindowSurfaceVSync(WindowParam window, int vsync)
{
  CheckError(SDL_SetWindowSurfaceVSync(window, vsync));
}

inline void Window::SetSurfaceVSync(int vsync)
{
  SDL::SetWindowSurfaceVSync(m_resource, vsync);
}

constexpr int WINDOW_SURFACE_VSYNC_DISABLED = SDL_WINDOW_SURFACE_VSYNC_DISABLED;

constexpr int WINDOW_SURFACE_VSYNC_ADAPTIVE = SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE;

/**
 * Get VSync for the window surface.
 *
 * @param window the window to query.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.SetSurfaceVSync
 */
inline int GetWindowSurfaceVSync(WindowParam window)
{
  int vsync;
  CheckError(SDL_GetWindowSurfaceVSync(window, &vsync));
  return vsync;
}

inline int Window::GetSurfaceVSync() const
{
  return SDL::GetWindowSurfaceVSync(m_resource);
}

/**
 * Copy the window surface to the screen.
 *
 * This is the function you use to reflect any changes to the surface on the
 * screen.
 *
 * This function is equivalent to the SDL 1.2 API SDL_Flip().
 *
 * @param window the window to update.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetSurface
 * @sa Window.UpdateSurfaceRects
 */
inline void UpdateWindowSurface(WindowParam window)
{
  CheckError(SDL_UpdateWindowSurface(window));
}

inline void Window::UpdateSurface() { SDL::UpdateWindowSurface(m_resource); }

/**
 * Copy areas of the window surface to the screen.
 *
 * This is the function you use to reflect changes to portions of the surface
 * on the screen.
 *
 * This function is equivalent to the SDL 1.2 API SDL_UpdateRects().
 *
 * Note that this function will update _at least_ the rectangles specified,
 * but this is only intended as an optimization; in practice, this might
 * update more of the screen (or all of the screen!), depending on what method
 * SDL uses to send pixels to the system.
 *
 * @param window the window to update.
 * @param rects an array of Rect structures representing areas of the
 *              surface to copy, in pixels.
 * @param numrects the number of rectangles.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetSurface
 * @sa Window.UpdateSurface
 */
inline void UpdateWindowSurfaceRects(WindowParam window,
                                     SpanRef<const RectRaw> rects)
{
  CheckError(SDL_UpdateWindowSurfaceRects(window, rects.data(), rects.size()));
}

inline void Window::UpdateSurfaceRects(SpanRef<const RectRaw> rects)
{
  SDL::UpdateWindowSurfaceRects(m_resource, rects);
}

/**
 * Destroy the surface associated with the window.
 *
 * @param window the window to update.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetSurface
 * @sa Window.HasSurface
 */
inline void DestroyWindowSurface(WindowParam window)
{
  CheckError(SDL_DestroyWindowSurface(window));
}

inline void Window::DestroySurface() { SDL::DestroyWindowSurface(m_resource); }

/**
 * Set a window's keyboard grab mode.
 *
 * Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or
 * the Meta/Super key. Note that not all system keyboard shortcuts can be
 * captured by applications (one example is Ctrl+Alt+Del on Windows).
 *
 * This is primarily intended for specialized applications such as VNC clients
 * or VM frontends. Normal games should not use keyboard grab.
 *
 * When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the
 * window is full-screen to ensure the user is not trapped in your
 * application. If you have a custom keyboard shortcut to exit fullscreen
 * mode, you may suppress this behavior with
 * `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.
 *
 * If the caller enables a grab while another window is currently grabbed, the
 * other window loses its grab in favor of the caller's window.
 *
 * @param window the window for which the keyboard grab mode should be set.
 * @param grabbed this is true to grab keyboard, and false to release.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetKeyboardGrab
 * @sa Window.SetMouseGrab
 */
inline void SetWindowKeyboardGrab(WindowParam window, bool grabbed)
{
  CheckError(SDL_SetWindowKeyboardGrab(window, grabbed));
}

inline void Window::SetKeyboardGrab(bool grabbed)
{
  SDL::SetWindowKeyboardGrab(m_resource, grabbed);
}

/**
 * Set a window's mouse grab mode.
 *
 * Mouse grab confines the mouse cursor to the window.
 *
 * @param window the window for which the mouse grab mode should be set.
 * @param grabbed this is true to grab mouse, and false to release.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetMouseRect
 * @sa Window.SetMouseRect
 * @sa Window.SetMouseGrab
 * @sa Window.SetKeyboardGrab
 */
inline void SetWindowMouseGrab(WindowParam window, bool grabbed)
{
  CheckError(SDL_SetWindowMouseGrab(window, grabbed));
}

inline void Window::SetMouseGrab(bool grabbed)
{
  SDL::SetWindowMouseGrab(m_resource, grabbed);
}

/**
 * Get a window's keyboard grab mode.
 *
 * @param window the window to query.
 * @returns true if keyboard is grabbed, and false otherwise.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.SetKeyboardGrab
 */
inline bool GetWindowKeyboardGrab(WindowParam window)
{
  return SDL_GetWindowKeyboardGrab(window);
}

inline bool Window::GetKeyboardGrab() const
{
  return SDL::GetWindowKeyboardGrab(m_resource);
}

/**
 * Get a window's mouse grab mode.
 *
 * @param window the window to query.
 * @returns true if mouse is grabbed, and false otherwise.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetMouseRect
 * @sa Window.SetMouseRect
 * @sa Window.SetMouseGrab
 * @sa Window.SetKeyboardGrab
 */
inline bool GetWindowMouseGrab(WindowParam window)
{
  return SDL_GetWindowMouseGrab(window);
}

inline bool Window::GetMouseGrab() const
{
  return SDL::GetWindowMouseGrab(m_resource);
}

/**
 * Get the window that currently has an input grab enabled.
 *
 * @returns the window if input is grabbed or nullptr otherwise.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.SetMouseGrab
 * @sa Window.SetKeyboardGrab
 */
inline WindowRef GetGrabbedWindow() { return {SDL_GetGrabbedWindow()}; }

inline WindowRef Window::GetGrabbed() { return SDL::GetGrabbedWindow(); }

/**
 * Confines the cursor to the specified area of a window.
 *
 * Note that this does NOT grab the cursor, it only defines the area a cursor
 * is restricted to when the window has mouse focus.
 *
 * @param window the window that will be associated with the barrier.
 * @param rect a rectangle area in window-relative coordinates. If nullptr the
 *             barrier for the specified window will be destroyed.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetMouseRect
 * @sa Window.GetMouseGrab
 * @sa Window.SetMouseGrab
 */
inline void SetWindowMouseRect(WindowParam window, const RectRaw& rect)
{
  CheckError(SDL_SetWindowMouseRect(window, &rect));
}

inline void Window::SetMouseRect(const RectRaw& rect)
{
  SDL::SetWindowMouseRect(m_resource, rect);
}

/**
 * Get the mouse confinement rectangle of a window.
 *
 * @param window the window to query.
 * @returns a pointer to the mouse confinement rectangle of a window, or nullptr
 *          if there isn't one.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.SetMouseRect
 * @sa Window.GetMouseGrab
 * @sa Window.SetMouseGrab
 */
inline const RectRaw* GetWindowMouseRect(WindowParam window)
{
  return SDL_GetWindowMouseRect(window);
}

inline const RectRaw* Window::GetMouseRect() const
{
  return SDL::GetWindowMouseRect(m_resource);
}

/**
 * Set the opacity for a window.
 *
 * The parameter `opacity` will be clamped internally between 0.0f
 * (transparent) and 1.0f (opaque).
 *
 * This function also returns false if setting the opacity isn't supported.
 *
 * @param window the window which will be made transparent or opaque.
 * @param opacity the opacity value (0.0f - transparent, 1.0f - opaque).
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.GetOpacity
 */
inline void SetWindowOpacity(WindowParam window, float opacity)
{
  CheckError(SDL_SetWindowOpacity(window, opacity));
}

inline void Window::SetOpacity(float opacity)
{
  SDL::SetWindowOpacity(m_resource, opacity);
}

/**
 * Get the opacity of a window.
 *
 * If transparency isn't supported on this platform, opacity will be returned
 * as 1.0f without error.
 *
 * @param window the window to get the current opacity value from.
 * @returns the opacity, (0.0f - transparent, 1.0f - opaque), or -1.0f on
 *          failure; call GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.SetOpacity
 */
inline float GetWindowOpacity(WindowParam window)
{
  return SDL_GetWindowOpacity(window);
}

inline float Window::GetOpacity() const
{
  return SDL::GetWindowOpacity(m_resource);
}

/**
 * Set the window as a child of a parent window.
 *
 * If the window is already the child of an existing window, it will be
 * reparented to the new owner. Setting the parent window to nullptr unparents
 * the window and removes child window status.
 *
 * If a parent window is hidden or destroyed, the operation will be
 * recursively applied to child windows. Child windows hidden with the parent
 * that did not have their hidden status explicitly set will be restored when
 * the parent is shown.
 *
 * Attempting to set the parent of a window that is currently in the modal
 * state will fail. Use Window.SetModal() to cancel the modal status before
 * attempting to change the parent.
 *
 * Popup windows cannot change parents and attempts to do so will fail.
 *
 * Setting a parent window that is currently the sibling or descendent of the
 * child window results in undefined behavior.
 *
 * @param window the window that should become the child of a parent.
 * @param parent the new parent window for the child window.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.SetModal
 */
inline void SetWindowParent(WindowParam window, WindowParam parent)
{
  CheckError(SDL_SetWindowParent(window, parent));
}

inline void Window::SetParent(WindowParam parent)
{
  SDL::SetWindowParent(m_resource, parent);
}

/**
 * Toggle the state of the window as modal.
 *
 * To enable modal status on a window, the window must currently be the child
 * window of a parent, or toggling modal status on will fail.
 *
 * @param window the window on which to set the modal state.
 * @param modal true to toggle modal status on, false to toggle it off.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.SetParent
 * @sa WINDOW_MODAL
 */
inline void SetWindowModal(WindowParam window, bool modal)
{
  CheckError(SDL_SetWindowModal(window, modal));
}

inline void Window::SetModal(bool modal)
{
  SDL::SetWindowModal(m_resource, modal);
}

/**
 * Set whether the window may have input focus.
 *
 * @param window the window to set focusable state.
 * @param focusable true to allow input focus, false to not allow input focus.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void SetWindowFocusable(WindowParam window, bool focusable)
{
  CheckError(SDL_SetWindowFocusable(window, focusable));
}

inline void Window::SetFocusable(bool focusable)
{
  SDL::SetWindowFocusable(m_resource, focusable);
}

/**
 * Display the system-level window menu.
 *
 * This default window menu is provided by the system and on some platforms
 * provides functionality for setting or changing privileged state on the
 * window, such as moving it between workspaces or displays, or toggling the
 * always-on-top property.
 *
 * On platforms or desktops where this is unsupported, this function does
 * nothing.
 *
 * @param window the window for which the menu will be displayed.
 * @param p the coordinates of the menu, relative to the origin (top-left) of
 *          the client area.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void ShowWindowSystemMenu(WindowParam window, const PointRaw& p)
{
  CheckError(SDL_ShowWindowSystemMenu(window, p.x, p.y));
}

inline void Window::ShowSystemMenu(const PointRaw& p)
{
  SDL::ShowWindowSystemMenu(m_resource, p);
}

/**
 * Provide a callback that decides if a window region has special properties.
 *
 * Normally windows are dragged and resized by decorations provided by the
 * system window manager (a title bar, borders, etc), but for some apps, it
 * makes sense to drag them from somewhere else inside the window itself; for
 * example, one might have a borderless window that wants to be draggable from
 * any part, or simulate its own title bar, etc.
 *
 * This function lets the app provide a callback that designates pieces of a
 * given window as special. This callback is run during event processing if we
 * need to tell the OS to treat a region of the window specially; the use of
 * this callback is known as "hit testing."
 *
 * Mouse input may not be delivered to your application if it is within a
 * special area; the OS will often apply that input to moving the window or
 * resizing the window and not deliver it to the application.
 *
 * Specifying nullptr for a callback disables hit-testing. Hit-testing is
 * disabled by default.
 *
 * Platforms that don't support this functionality will return false
 * unconditionally, even if you're attempting to disable hit-testing.
 *
 * Your callback may fire at any time, and its firing does not indicate any
 * specific behavior (for example, on Windows, this certainly might fire when
 * the OS is deciding whether to drag your window, but it fires for lots of
 * other reasons, too, some unrelated to anything you probably care about _and
 * when the mouse isn't actually at the location it is testing_). Since this
 * can fire at any time, you should try to keep your callback efficient,
 * devoid of allocations, etc.
 *
 * @param window the window to set hit-testing on.
 * @param callback the function to call when doing a hit-test.
 * @param callback_data an app-defined void pointer passed to **callback**.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void SetWindowHitTest(WindowParam window,
                             HitTest callback,
                             void* callback_data)
{
  CheckError(SDL_SetWindowHitTest(window, callback, callback_data));
}

/**
 * Provide a callback that decides if a window region has special properties.
 *
 * Normally windows are dragged and resized by decorations provided by the
 * system window manager (a title bar, borders, etc), but for some apps, it
 * makes sense to drag them from somewhere else inside the window itself; for
 * example, one might have a borderless window that wants to be draggable from
 * any part, or simulate its own title bar, etc.
 *
 * This function lets the app provide a callback that designates pieces of a
 * given window as special. This callback is run during event processing if we
 * need to tell the OS to treat a region of the window specially; the use of
 * this callback is known as "hit testing."
 *
 * Mouse input may not be delivered to your application if it is within a
 * special area; the OS will often apply that input to moving the window or
 * resizing the window and not deliver it to the application.
 *
 * Specifying nullptr for a callback disables hit-testing. Hit-testing is
 * disabled by default.
 *
 * Platforms that don't support this functionality will return false
 * unconditionally, even if you're attempting to disable hit-testing.
 *
 * Your callback may fire at any time, and its firing does not indicate any
 * specific behavior (for example, on Windows, this certainly might fire when
 * the OS is deciding whether to drag your window, but it fires for lots of
 * other reasons, too, some unrelated to anything you probably care about _and
 * when the mouse isn't actually at the location it is testing_). Since this
 * can fire at any time, you should try to keep your callback efficient,
 * devoid of allocations, etc.
 *
 * @param window the window to set hit-testing on.
 * @param callback the function to call when doing a hit-test.
 * @param callback_data an app-defined void pointer passed to **callback**.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
void SetWindowHitTest(WindowParam window, HitTestCB callback)
{
  using Wrapper = KeyValueCallbackWrapper<WindowRaw, HitTestCB>;
  void* cbHandle = Wrapper::Wrap(window, std::move(callback));
  SetWindowHitTest(
    window,
    [](SDL_Window* win, const SDL_Point* area, void* data) {
      return Wrapper::Call(data, win, Point(*area));
    },
    cbHandle);
}

/**
 * Set the shape of a transparent window.
 *
 * This sets the alpha channel of a transparent window and any fully
 * transparent areas are also transparent to mouse clicks. If you are using
 * something besides the SDL render API, then you are responsible for drawing
 * the alpha channel of the window to match the shape alpha channel to get
 * consistent cross-platform results.
 *
 * The shape is copied inside this function, so you can free it afterwards. If
 * your shape surface changes, you should call Window.SetShape() again to
 * update the window. This is an expensive operation, so should be done
 * sparingly.
 *
 * The window must have been created with the WINDOW_TRANSPARENT flag.
 *
 * @param window the window.
 * @param shape the surface representing the shape of the window, or nullptr to
 *              remove any current shape.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void SetWindowShape(WindowParam window, SurfaceParam shape)
{
  CheckError(SDL_SetWindowShape(window, shape));
}

inline void Window::SetShape(SurfaceParam shape)
{
  SDL::SetWindowShape(m_resource, shape);
}

/**
 * Request a window to demand attention from the user.
 *
 * @param window the window to be flashed.
 * @param operation the operation to perform.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void FlashWindow(WindowParam window, FlashOperation operation)
{
  CheckError(SDL_FlashWindow(window, operation));
}

inline void Window::Flash(FlashOperation operation)
{
  SDL::FlashWindow(m_resource, operation);
}

/**
 * Destroy a window.
 *
 * Any child windows owned by the window will be recursively destroyed as
 * well.
 *
 * Note that on some platforms, the visible window may not actually be removed
 * from the screen until the SDL event loop is pumped again, even though the
 * Window is no longer valid after this call.
 *
 * @param window the window to destroy.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Window.Window
 * @sa Window.Window
 * @sa Window.Window
 */
inline void DestroyWindow(WindowRaw window) { SDL_DestroyWindow(window); }

inline void Window::Destroy()
{
  SDL_DestroyWindow(m_resource);
  m_resource = nullptr;
}

/**
 * Check whether the screensaver is currently enabled.
 *
 * The screensaver is disabled by default.
 *
 * The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.
 *
 * @returns true if the screensaver is enabled, false if it is disabled.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa DisableScreenSaver
 * @sa EnableScreenSaver
 */
inline bool ScreenSaverEnabled() { return SDL_ScreenSaverEnabled(); }

/**
 * Allow the screen to be blanked by a screen saver.
 *
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa DisableScreenSaver
 * @sa ScreenSaverEnabled
 */
inline void EnableScreenSaver() { CheckError(SDL_EnableScreenSaver()); }

/**
 * Prevent the screen from being blanked by a screen saver.
 *
 * If you disable the screensaver, it is automatically re-enabled when SDL
 * quits.
 *
 * The screensaver is disabled by default, but this may by changed by
 * SDL_HINT_VIDEO_ALLOW_SCREENSAVER.
 *
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa EnableScreenSaver
 * @sa ScreenSaverEnabled
 */
inline void DisableScreenSaver() { CheckError(SDL_DisableScreenSaver()); }

/**
 * Dynamically load an OpenGL library.
 *
 * This should be done after initializing the video driver, but before
 * creating any OpenGL windows. If no OpenGL library is loaded, the default
 * library will be loaded upon creation of the first OpenGL window.
 *
 * If you do this, you need to retrieve all of the GL functions used in your
 * program from the dynamic library using GL_GetProcAddress().
 *
 * @param path the platform dependent OpenGL library name, or nullptr to open
 * the default OpenGL library.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GL_GetProcAddress
 * @sa GL_UnloadLibrary
 */
inline void GL_LoadLibrary(StringParam path)
{
  CheckError(SDL_GL_LoadLibrary(path));
}

/**
 * Get an OpenGL function by name.
 *
 * If the GL library is loaded at runtime with GL_LoadLibrary(), then all
 * GL functions must be retrieved this way. Usually this is used to retrieve
 * function pointers to OpenGL extensions.
 *
 * There are some quirks to looking up OpenGL functions that require some
 * extra care from the application. If you code carefully, you can handle
 * these quirks without any platform-specific code, though:
 *
 * - On Windows, function pointers are specific to the current GL context;
 *   this means you need to have created a GL context and made it current
 *   before calling GL_GetProcAddress(). If you recreate your context or
 *   create a second context, you should assume that any existing function
 *   pointers aren't valid to use with it. This is (currently) a
 *   Windows-specific limitation, and in practice lots of drivers don't suffer
 *   this limitation, but it is still the way the wgl API is documented to
 *   work and you should expect crashes if you don't respect it. Store a copy
 *   of the function pointers that comes and goes with context lifespan.
 * - On X11, function pointers returned by this function are valid for any
 *   context, and can even be looked up before a context is created at all.
 *   This means that, for at least some common OpenGL implementations, if you
 *   look up a function that doesn't exist, you'll get a non-nullptr result that
 *   is _NOT_ safe to call. You must always make sure the function is actually
 *   available for a given GL context before calling it, by checking for the
 *   existence of the appropriate extension with GL_ExtensionSupported(),
 *   or verifying that the version of OpenGL you're using offers the function
 *   as core functionality.
 * - Some OpenGL drivers, on all platforms, *will* return nullptr if a function
 *   isn't supported, but you can't count on this behavior. Check for
 *   extensions you use, and if you get a nullptr anyway, act as if that
 *   extension wasn't available. This is probably a bug in the driver, but you
 *   can code defensively for this scenario anyhow.
 * - Just because you're on Linux/Unix, don't assume you'll be using X11.
 *   Next-gen display servers are waiting to replace it, and may or may not
 *   make the same promises about function pointers.
 * - OpenGL function pointers must be declared `APIENTRY` as in the example
 *   code. This will ensure the proper calling convention is followed on
 *   platforms where this matters (Win32) thereby avoiding stack corruption.
 *
 * @param proc the name of an OpenGL function.
 * @returns a pointer to the named OpenGL function. The returned pointer
 *          should be cast to the appropriate function signature.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GL_ExtensionSupported
 * @sa GL_LoadLibrary
 * @sa GL_UnloadLibrary
 */
inline FunctionPointer GL_GetProcAddress(StringParam proc)
{
  return SDL_GL_GetProcAddress(proc);
}

/**
 * Get an EGL library function by name.
 *
 * If an EGL library is loaded, this function allows applications to get entry
 * points for EGL functions. This is useful to provide to an EGL API and
 * extension loader.
 *
 * @param proc the name of an EGL function.
 * @returns a pointer to the named EGL function. The returned pointer should
 *          be cast to the appropriate function signature.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa EGL_GetCurrentDisplay
 */
inline FunctionPointer EGL_GetProcAddress(StringParam proc)
{
  return SDL_EGL_GetProcAddress(proc);
}

/**
 * Unload the OpenGL library previously loaded by GL_LoadLibrary().
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GL_LoadLibrary
 */
inline void GL_UnloadLibrary() { SDL_GL_UnloadLibrary(); }

/**
 * Check if an OpenGL extension is supported for the current context.
 *
 * This function operates on the current GL context; you must have created a
 * context and it must be current before calling this function. Do not assume
 * that all contexts you create will have the same set of extensions
 * available, or that recreating an existing context will offer the same
 * extensions again.
 *
 * While it's probably not a massive overhead, this function is not an O(1)
 * operation. Check the extensions you care about after creating the GL
 * context and save that information somewhere instead of calling the function
 * every time you need to know.
 *
 * @param extension the name of the extension to check.
 * @returns true if the extension is supported, false otherwise.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline bool GL_ExtensionSupported(StringParam extension)
{
  return SDL_GL_ExtensionSupported(extension);
}

/**
 * Reset all previously set OpenGL context attributes to their default values.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GL_GetAttribute
 * @sa GL_SetAttribute
 */
inline void GL_ResetAttributes() { SDL_GL_ResetAttributes(); }

/**
 * Set an OpenGL window attribute before window creation.
 *
 * This function sets the OpenGL attribute `attr` to `value`. The requested
 * attributes should be set before creating an OpenGL window. You should use
 * GL_GetAttribute() to check the values after creating the OpenGL
 * context, since the values obtained can differ from the requested ones.
 *
 * @param attr an GLAttr enum value specifying the OpenGL attribute to
 *             set.
 * @param value the desired value for the attribute.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GL_GetAttribute
 * @sa GL_ResetAttributes
 */
inline void GL_SetAttribute(GLAttr attr, int value)
{
  CheckError(SDL_GL_SetAttribute(attr, value));
}

/**
 * Get the actual value for an attribute from the current context.
 *
 * @param attr an GLAttr enum value specifying the OpenGL attribute to
 *             get.
 * @param value a pointer filled in with the current value of `attr`.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GL_ResetAttributes
 * @sa GL_SetAttribute
 */
inline void GL_GetAttribute(GLAttr attr, int* value)
{
  CheckError(SDL_GL_GetAttribute(attr, value));
}

/**
 * Create an OpenGL context for an OpenGL window, and make it current.
 *
 * Windows users new to OpenGL should note that, for historical reasons, GL
 * functions added after OpenGL version 1.1 are not available by default.
 * Those functions must be loaded at run-time, either with an OpenGL
 * extension-handling library or with GL_GetProcAddress() and its related
 * functions.
 *
 * GLContext is opaque to the application.
 *
 * @param window the window to associate with the context.
 * @returns the OpenGL context associated with `window` or nullptr on failure;
 *          call GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GLContext.Destroy
 * @sa GLContext.MakeCurrent
 */
inline GLContext GL_CreateContext(WindowParam window)
{
  return GLContext(window);
}

/**
 * Set up an OpenGL context for rendering into an OpenGL window.
 *
 * The context must have been created with a compatible window.
 *
 * @param window the window to associate with the context.
 * @param context the OpenGL context to associate with the window.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GLContext.GLContext
 */
inline void GL_MakeCurrent(WindowParam window, GLContext context)
{
  CheckError(SDL_GL_MakeCurrent(window, context.get()));
}

inline void GLContext::MakeCurrent(WindowParam window)
{
  SDL::GL_MakeCurrent(window, m_resource);
}

/**
 * Get the currently active OpenGL window.
 *
 * @returns the currently active OpenGL window on success.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline WindowRef GL_GetCurrentWindow()
{
  return {CheckError(SDL_GL_GetCurrentWindow())};
}

/**
 * Get the currently active OpenGL context.
 *
 * @returns the currently active OpenGL context or nullptr on failure; call
 *          GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GLContext.MakeCurrent
 */
inline GLContext GL_GetCurrentContext() { return SDL_GL_GetCurrentContext(); }

/**
 * Get the currently active EGL display.
 *
 * @returns the currently active EGL display or nullptr on failure; call
 *          GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline EGLDisplay EGL_GetCurrentDisplay()
{
  return SDL_EGL_GetCurrentDisplay();
}

/**
 * Get the currently active EGL config.
 *
 * @returns the currently active EGL config or nullptr on failure; call
 *          GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline EGLConfig EGL_GetCurrentConfig() { return SDL_EGL_GetCurrentConfig(); }

/**
 * Get the EGL surface associated with the window.
 *
 * @param window the window to query.
 * @returns the EGLSurface pointer associated with the window, or nullptr on
 *          failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline EGLSurface EGL_GetWindowSurface(WindowParam window)
{
  return SDL_EGL_GetWindowSurface(window);
}

/**
 * Sets the callbacks for defining custom EGLAttrib arrays for EGL
 * initialization.
 *
 * Callbacks that aren't needed can be set to nullptr.
 *
 * NOTE: These callback pointers will be reset after GL_ResetAttributes.
 *
 * @param platformAttribCallback callback for attributes to pass to
 *                               eglGetPlatformDisplay. May be nullptr.
 * @param surfaceAttribCallback callback for attributes to pass to
 *                              eglCreateSurface. May be nullptr.
 * @param contextAttribCallback callback for attributes to pass to
 *                              eglCreateContext. May be nullptr.
 * @param userdata a pointer that is passed to the callbacks.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void EGL_SetAttributeCallbacks(
  EGLAttribArrayCallback platformAttribCallback,
  EGLIntArrayCallback surfaceAttribCallback,
  EGLIntArrayCallback contextAttribCallback,
  void* userdata)
{
  SDL_EGL_SetAttributeCallbacks(platformAttribCallback,
                                surfaceAttribCallback,
                                contextAttribCallback,
                                userdata);
}

/**
 * Set the swap interval for the current OpenGL context.
 *
 * Some systems allow specifying -1 for the interval, to enable adaptive
 * vsync. Adaptive vsync works the same as vsync, but if you've already missed
 * the vertical retrace for a given frame, it swaps buffers immediately, which
 * might be less jarring for the user during occasional framerate drops. If an
 * application requests adaptive vsync and the system does not support it,
 * this function will fail and return false. In such a case, you should
 * probably retry the call with 1 for the interval.
 *
 * Adaptive vsync is implemented for some glX drivers with
 * GLX_EXT_swap_control_tear, and for some Windows drivers with
 * WGL_EXT_swap_control_tear.
 *
 * Read more on the Khronos wiki:
 * https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync
 *
 * @param interval 0 for immediate updates, 1 for updates synchronized with
 *                 the vertical retrace, -1 for adaptive vsync.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GL_GetSwapInterval
 */
inline void GL_SetSwapInterval(int interval)
{
  CheckError(SDL_GL_SetSwapInterval(interval));
}

/**
 * Get the swap interval for the current OpenGL context.
 *
 * If the system can't determine the swap interval, or there isn't a valid
 * current context, this function will set *interval to 0 as a safe default.
 *
 * @param interval output interval value. 0 if there is no vertical retrace
 *                 synchronization, 1 if the buffer swap is synchronized with
 *                 the vertical retrace, and -1 if late swaps happen
 *                 immediately instead of waiting for the next retrace.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GL_SetSwapInterval
 */
inline void GL_GetSwapInterval(int* interval)
{
  CheckError(SDL_GL_GetSwapInterval(interval));
}

/**
 * Update a window with OpenGL rendering.
 *
 * This is used with double-buffered OpenGL contexts, which are the default.
 *
 * On macOS, make sure you bind 0 to the draw framebuffer before swapping the
 * window, otherwise nothing will happen. If you aren't using
 * glBindFramebuffer(), this is the default and you won't have to do anything
 * extra.
 *
 * @param window the window to change.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void GL_SwapWindow(WindowParam window)
{
  CheckError(SDL_GL_SwapWindow(window));
}

/**
 * Delete an OpenGL context.
 *
 * @param context the OpenGL context to be deleted.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GLContext.GLContext
 */
inline void GL_DestroyContext(GLContextRaw context)
{
  CheckError(SDL_GL_DestroyContext(context));
}

inline void GLContext::Destroy()
{
  CheckError(SDL_GL_DestroyContext(m_resource));
  m_resource = nullptr;
}

/// @}

/**
 * @defgroup CategoryEvents Category Events
 *
 * Event queue management.
 *
 * It's extremely common--often required--that an app deal with SDL's event
 * queue. Almost all useful information about interactions with the real world
 * flow through here: the user interacting with the computer and app, hardware
 * coming and going, the system changing in some way, etc.
 *
 * An app generally takes a moment, perhaps at the start of a new frame, to
 * examine any events that have occured since the last time and process or
 * ignore them. This is generally done by calling PollEvent() in a loop
 * until it returns false (or, if using the main callbacks, events are
 * provided one at a time in calls to SDL_AppEvent() before the next call to
 * SDL_AppIterate(); in this scenario, the app does not call PollEvent()
 * at all).
 *
 * There is other forms of control, too: PeepEvents() has more
 * functionality at the cost of more complexity, and WaitEvent() can block
 * the process until something interesting happens, which might be beneficial
 * for certain types of programs on low-power hardware. One may also call
 * AddEventWatch() to set a callback when new events arrive.
 *
 * The app is free to generate their own events, too: PushEvent allows the
 * app to put events onto the queue for later retrieval; RegisterEvents
 * can guarantee that these events have a type that isn't in use by other
 * parts of the system.
 *
 * @{
 */

/**
 * @defgroup EventTypes Event Types
 *
 * Event types for Event.
 * @{
 */

/**
 * The types of events that can be delivered.
 *
 * @since This enum is available since SDL 3.2.0.
 */
using EventType = SDL_EventType;

constexpr EventType EVENT_FIRST = SDL_EVENT_FIRST; ///< Unused (do not remove)

constexpr EventType EVENT_QUIT = SDL_EVENT_QUIT; ///< User-requested quit.

/**
 * The application is being terminated by the OS.  This event must be handled in
 * a callback set with AddEventWatch(). Called on iOS in
 * applicationWillTerminate() Called on Android in onDestroy()
 */
constexpr EventType EVENT_TERMINATING = SDL_EVENT_TERMINATING;

/**
 * The application is low on memory, free memory if possible.  This event must
 * be handled in a callback set with AddEventWatch(). Called on iOS in
 * applicationDidReceiveMemoryWarning() Called on Android in onTrimMemory()
 */
constexpr EventType EVENT_LOW_MEMORY = SDL_EVENT_LOW_MEMORY;

/**
 * The application is about to enter the background.  This event must be handled
 * in a callback set with AddEventWatch(). Called on iOS in
 * applicationWillResignActive() Called on Android in onPause()
 */
constexpr EventType EVENT_WILL_ENTER_BACKGROUND =
  SDL_EVENT_WILL_ENTER_BACKGROUND;

/**
 * The application did enter the background and may not get CPU for some time.
 * This event must be handled in a callback set with AddEventWatch(). Called on
 * iOS in applicationDidEnterBackground() Called on Android in onPause()
 */
constexpr EventType EVENT_DID_ENTER_BACKGROUND = SDL_EVENT_DID_ENTER_BACKGROUND;

/**
 * The application is about to enter the foreground.  This event must be handled
 * in a callback set with AddEventWatch(). Called on iOS in
 * applicationWillEnterForeground() Called on Android in onResume()
 */
constexpr EventType EVENT_WILL_ENTER_FOREGROUND =
  SDL_EVENT_WILL_ENTER_FOREGROUND;

/**
 * The application is now interactive.  This event must be handled in a callback
 * set with AddEventWatch(). Called on iOS in applicationDidBecomeActive()
 * Called on Android in onResume()
 */
constexpr EventType EVENT_DID_ENTER_FOREGROUND = SDL_EVENT_DID_ENTER_FOREGROUND;

constexpr EventType EVENT_LOCALE_CHANGED =
  SDL_EVENT_LOCALE_CHANGED; ///< The user's locale preferences have changed.

constexpr EventType EVENT_SYSTEM_THEME_CHANGED =
  SDL_EVENT_SYSTEM_THEME_CHANGED; ///< The system theme changed.

constexpr EventType EVENT_DISPLAY_ORIENTATION =
  SDL_EVENT_DISPLAY_ORIENTATION; ///< Display orientation has changed to data1.

constexpr EventType EVENT_DISPLAY_ADDED =
  SDL_EVENT_DISPLAY_ADDED; ///< Display has been added to the system.

constexpr EventType EVENT_DISPLAY_REMOVED =
  SDL_EVENT_DISPLAY_REMOVED; ///< Display has been removed from the system.

constexpr EventType EVENT_DISPLAY_MOVED =
  SDL_EVENT_DISPLAY_MOVED; ///< Display has changed position.

constexpr EventType EVENT_DISPLAY_DESKTOP_MODE_CHANGED =
  SDL_EVENT_DISPLAY_DESKTOP_MODE_CHANGED; ///< Display has changed desktop mode.

constexpr EventType EVENT_DISPLAY_CURRENT_MODE_CHANGED =
  SDL_EVENT_DISPLAY_CURRENT_MODE_CHANGED; ///< Display has changed current mode.

constexpr EventType EVENT_DISPLAY_CONTENT_SCALE_CHANGED =
  SDL_EVENT_DISPLAY_CONTENT_SCALE_CHANGED; ///< Display has changed content
                                           ///< scale.

constexpr EventType EVENT_DISPLAY_FIRST =
  SDL_EVENT_DISPLAY_FIRST; ///< DISPLAY_FIRST

constexpr EventType EVENT_DISPLAY_LAST =
  SDL_EVENT_DISPLAY_LAST; ///< DISPLAY_LAST

constexpr EventType EVENT_WINDOW_SHOWN =
  SDL_EVENT_WINDOW_SHOWN; ///< Window has been shown.

constexpr EventType EVENT_WINDOW_HIDDEN =
  SDL_EVENT_WINDOW_HIDDEN; ///< Window has been hidden.

/**
 * Window has been exposed and should be redrawn, and can be redrawn directly
 * from event watchers for this event.
 */
constexpr EventType EVENT_WINDOW_EXPOSED = SDL_EVENT_WINDOW_EXPOSED;

constexpr EventType EVENT_WINDOW_MOVED =
  SDL_EVENT_WINDOW_MOVED; ///< Window has been moved to data1, data2.

constexpr EventType EVENT_WINDOW_RESIZED =
  SDL_EVENT_WINDOW_RESIZED; ///< Window has been resized to data1xdata2.

/// The pixel size of the window has changed to data1xdata2.
constexpr EventType EVENT_WINDOW_PIXEL_SIZE_CHANGED =
  SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED;

/// The pixel size of a Metal view associated with the window has changed.
constexpr EventType EVENT_WINDOW_METAL_VIEW_RESIZED =
  SDL_EVENT_WINDOW_METAL_VIEW_RESIZED;

constexpr EventType EVENT_WINDOW_MINIMIZED =
  SDL_EVENT_WINDOW_MINIMIZED; ///< Window has been minimized.

constexpr EventType EVENT_WINDOW_MAXIMIZED =
  SDL_EVENT_WINDOW_MAXIMIZED; ///< Window has been maximized.

/// Window has been restored to normal size and position.
constexpr EventType EVENT_WINDOW_RESTORED = SDL_EVENT_WINDOW_RESTORED;

constexpr EventType EVENT_WINDOW_MOUSE_ENTER =
  SDL_EVENT_WINDOW_MOUSE_ENTER; ///< Window has gained mouse focus.

constexpr EventType EVENT_WINDOW_MOUSE_LEAVE =
  SDL_EVENT_WINDOW_MOUSE_LEAVE; ///< Window has lost mouse focus.

constexpr EventType EVENT_WINDOW_FOCUS_GAINED =
  SDL_EVENT_WINDOW_FOCUS_GAINED; ///< Window has gained keyboard focus.

constexpr EventType EVENT_WINDOW_FOCUS_LOST =
  SDL_EVENT_WINDOW_FOCUS_LOST; ///< Window has lost keyboard focus.

/// The window manager requests that the window be closed.
constexpr EventType EVENT_WINDOW_CLOSE_REQUESTED =
  SDL_EVENT_WINDOW_CLOSE_REQUESTED;

constexpr EventType EVENT_WINDOW_HIT_TEST =
  SDL_EVENT_WINDOW_HIT_TEST; ///< Window had a hit test that wasn't
                             ///< HITTEST_NORMAL.

/// The ICC profile of the window's display has changed.
constexpr EventType EVENT_WINDOW_ICCPROF_CHANGED =
  SDL_EVENT_WINDOW_ICCPROF_CHANGED;

constexpr EventType EVENT_WINDOW_DISPLAY_CHANGED =
  SDL_EVENT_WINDOW_DISPLAY_CHANGED; ///< Window has been moved to display data1.

constexpr EventType EVENT_WINDOW_DISPLAY_SCALE_CHANGED =
  SDL_EVENT_WINDOW_DISPLAY_SCALE_CHANGED; ///< Window display scale has been
                                          ///< changed.

constexpr EventType EVENT_WINDOW_SAFE_AREA_CHANGED =
  SDL_EVENT_WINDOW_SAFE_AREA_CHANGED; ///< The window safe area has been
                                      ///< changed.

constexpr EventType EVENT_WINDOW_OCCLUDED =
  SDL_EVENT_WINDOW_OCCLUDED; ///< The window has been occluded.

constexpr EventType EVENT_WINDOW_ENTER_FULLSCREEN =
  SDL_EVENT_WINDOW_ENTER_FULLSCREEN; ///< The window has entered fullscreen
                                     ///< mode.

constexpr EventType EVENT_WINDOW_LEAVE_FULLSCREEN =
  SDL_EVENT_WINDOW_LEAVE_FULLSCREEN; ///< The window has left fullscreen mode.

/**
 * The window with the associated ID is being or has been destroyed.  If this
 * message is being handled in an event watcher, the window handle is still
 * valid and can still be used to retrieve any properties associated with the
 * window. Otherwise, the handle has already been destroyed and all resources
 * associated with it are invalid
 */
constexpr EventType EVENT_WINDOW_DESTROYED = SDL_EVENT_WINDOW_DESTROYED;

constexpr EventType EVENT_WINDOW_HDR_STATE_CHANGED =
  SDL_EVENT_WINDOW_HDR_STATE_CHANGED; ///< Window HDR properties have changed.

constexpr EventType EVENT_WINDOW_FIRST =
  SDL_EVENT_WINDOW_FIRST; ///< WINDOW_FIRST

constexpr EventType EVENT_WINDOW_LAST = SDL_EVENT_WINDOW_LAST; ///< WINDOW_LAST

constexpr EventType EVENT_KEY_DOWN = SDL_EVENT_KEY_DOWN; ///< Key pressed.

constexpr EventType EVENT_KEY_UP = SDL_EVENT_KEY_UP; ///< Key released.

constexpr EventType EVENT_TEXT_EDITING =
  SDL_EVENT_TEXT_EDITING; ///< Keyboard text editing (composition)

constexpr EventType EVENT_TEXT_INPUT =
  SDL_EVENT_TEXT_INPUT; ///< Keyboard text input.

/**
 * Keymap changed due to a system event such as an input language or keyboard
 * layout change.
 */
constexpr EventType EVENT_KEYMAP_CHANGED = SDL_EVENT_KEYMAP_CHANGED;

constexpr EventType EVENT_KEYBOARD_ADDED =
  SDL_EVENT_KEYBOARD_ADDED; ///< A new keyboard has been inserted into the
                            ///< system.

constexpr EventType EVENT_KEYBOARD_REMOVED =
  SDL_EVENT_KEYBOARD_REMOVED; ///< A keyboard has been removed.

constexpr EventType EVENT_TEXT_EDITING_CANDIDATES =
  SDL_EVENT_TEXT_EDITING_CANDIDATES; ///< Keyboard text editing candidates.

constexpr EventType EVENT_MOUSE_MOTION =
  SDL_EVENT_MOUSE_MOTION; ///< Mouse moved.

constexpr EventType EVENT_MOUSE_BUTTON_DOWN =
  SDL_EVENT_MOUSE_BUTTON_DOWN; ///< Mouse button pressed.

constexpr EventType EVENT_MOUSE_BUTTON_UP =
  SDL_EVENT_MOUSE_BUTTON_UP; ///< Mouse button released.

constexpr EventType EVENT_MOUSE_WHEEL =
  SDL_EVENT_MOUSE_WHEEL; ///< Mouse wheel motion.

constexpr EventType EVENT_MOUSE_ADDED =
  SDL_EVENT_MOUSE_ADDED; ///< A new mouse has been inserted into the system.

constexpr EventType EVENT_MOUSE_REMOVED =
  SDL_EVENT_MOUSE_REMOVED; ///< A mouse has been removed.

constexpr EventType EVENT_JOYSTICK_AXIS_MOTION =
  SDL_EVENT_JOYSTICK_AXIS_MOTION; ///< Joystick axis motion.

constexpr EventType EVENT_JOYSTICK_BALL_MOTION =
  SDL_EVENT_JOYSTICK_BALL_MOTION; ///< Joystick trackball motion.

constexpr EventType EVENT_JOYSTICK_HAT_MOTION =
  SDL_EVENT_JOYSTICK_HAT_MOTION; ///< Joystick hat position change.

constexpr EventType EVENT_JOYSTICK_BUTTON_DOWN =
  SDL_EVENT_JOYSTICK_BUTTON_DOWN; ///< Joystick button pressed.

constexpr EventType EVENT_JOYSTICK_BUTTON_UP =
  SDL_EVENT_JOYSTICK_BUTTON_UP; ///< Joystick button released.

constexpr EventType EVENT_JOYSTICK_ADDED =
  SDL_EVENT_JOYSTICK_ADDED; ///< A new joystick has been inserted into the
                            ///< system.

constexpr EventType EVENT_JOYSTICK_REMOVED =
  SDL_EVENT_JOYSTICK_REMOVED; ///< An opened joystick has been removed.

constexpr EventType EVENT_JOYSTICK_BATTERY_UPDATED =
  SDL_EVENT_JOYSTICK_BATTERY_UPDATED; ///< Joystick battery level change.

constexpr EventType EVENT_JOYSTICK_UPDATE_COMPLETE =
  SDL_EVENT_JOYSTICK_UPDATE_COMPLETE; ///< Joystick update is complete.

constexpr EventType EVENT_GAMEPAD_AXIS_MOTION =
  SDL_EVENT_GAMEPAD_AXIS_MOTION; ///< Gamepad axis motion.

constexpr EventType EVENT_GAMEPAD_BUTTON_DOWN =
  SDL_EVENT_GAMEPAD_BUTTON_DOWN; ///< Gamepad button pressed.

constexpr EventType EVENT_GAMEPAD_BUTTON_UP =
  SDL_EVENT_GAMEPAD_BUTTON_UP; ///< Gamepad button released.

constexpr EventType EVENT_GAMEPAD_ADDED =
  SDL_EVENT_GAMEPAD_ADDED; ///< A new gamepad has been inserted into the system.

constexpr EventType EVENT_GAMEPAD_REMOVED =
  SDL_EVENT_GAMEPAD_REMOVED; ///< A gamepad has been removed.

constexpr EventType EVENT_GAMEPAD_REMAPPED =
  SDL_EVENT_GAMEPAD_REMAPPED; ///< The gamepad mapping was updated.

constexpr EventType EVENT_GAMEPAD_TOUCHPAD_DOWN =
  SDL_EVENT_GAMEPAD_TOUCHPAD_DOWN; ///< Gamepad touchpad was touched.

constexpr EventType EVENT_GAMEPAD_TOUCHPAD_MOTION =
  SDL_EVENT_GAMEPAD_TOUCHPAD_MOTION; ///< Gamepad touchpad finger was moved.

constexpr EventType EVENT_GAMEPAD_TOUCHPAD_UP =
  SDL_EVENT_GAMEPAD_TOUCHPAD_UP; ///< Gamepad touchpad finger was lifted.

constexpr EventType EVENT_GAMEPAD_SENSOR_UPDATE =
  SDL_EVENT_GAMEPAD_SENSOR_UPDATE; ///< Gamepad sensor was updated.

constexpr EventType EVENT_GAMEPAD_UPDATE_COMPLETE =
  SDL_EVENT_GAMEPAD_UPDATE_COMPLETE; ///< Gamepad update is complete.

constexpr EventType EVENT_GAMEPAD_STEAM_HANDLE_UPDATED =
  SDL_EVENT_GAMEPAD_STEAM_HANDLE_UPDATED; ///< Gamepad Steam handle has changed.

constexpr EventType EVENT_FINGER_DOWN = SDL_EVENT_FINGER_DOWN; ///< FINGER_DOWN

constexpr EventType EVENT_FINGER_UP = SDL_EVENT_FINGER_UP; ///< FINGER_UP

constexpr EventType EVENT_FINGER_MOTION =
  SDL_EVENT_FINGER_MOTION; ///< FINGER_MOTION

constexpr EventType EVENT_FINGER_CANCELED =
  SDL_EVENT_FINGER_CANCELED; ///< FINGER_CANCELED

constexpr EventType EVENT_CLIPBOARD_UPDATE =
  SDL_EVENT_CLIPBOARD_UPDATE; ///< The clipboard or primary selection changed.

constexpr EventType EVENT_DROP_FILE =
  SDL_EVENT_DROP_FILE; ///< The system requests a file open.

constexpr EventType EVENT_DROP_TEXT =
  SDL_EVENT_DROP_TEXT; ///< text/plain drag-and-drop event

constexpr EventType EVENT_DROP_BEGIN =
  SDL_EVENT_DROP_BEGIN; ///< A new set of drops is beginning (NULL filename)

/// Current set of drops is now complete (NULL filename)
constexpr EventType EVENT_DROP_COMPLETE = SDL_EVENT_DROP_COMPLETE;

constexpr EventType EVENT_DROP_POSITION =
  SDL_EVENT_DROP_POSITION; ///< Position while moving over the window.

constexpr EventType EVENT_AUDIO_DEVICE_ADDED =
  SDL_EVENT_AUDIO_DEVICE_ADDED; ///< A new audio device is available.

constexpr EventType EVENT_AUDIO_DEVICE_REMOVED =
  SDL_EVENT_AUDIO_DEVICE_REMOVED; ///< An audio device has been removed.

/// An audio device's format has been changed by the system.
constexpr EventType EVENT_AUDIO_DEVICE_FORMAT_CHANGED =
  SDL_EVENT_AUDIO_DEVICE_FORMAT_CHANGED;

constexpr EventType EVENT_SENSOR_UPDATE =
  SDL_EVENT_SENSOR_UPDATE; ///< A sensor was updated.

constexpr EventType EVENT_PEN_PROXIMITY_IN =
  SDL_EVENT_PEN_PROXIMITY_IN; ///< Pressure-sensitive pen has become available.

constexpr EventType EVENT_PEN_PROXIMITY_OUT =
  SDL_EVENT_PEN_PROXIMITY_OUT; ///< Pressure-sensitive pen has become
                               ///< unavailable.

constexpr EventType EVENT_PEN_DOWN =
  SDL_EVENT_PEN_DOWN; ///< Pressure-sensitive pen touched drawing surface.

/// Pressure-sensitive pen stopped touching drawing surface.
constexpr EventType EVENT_PEN_UP = SDL_EVENT_PEN_UP;

constexpr EventType EVENT_PEN_BUTTON_DOWN =
  SDL_EVENT_PEN_BUTTON_DOWN; ///< Pressure-sensitive pen button pressed.

constexpr EventType EVENT_PEN_BUTTON_UP =
  SDL_EVENT_PEN_BUTTON_UP; ///< Pressure-sensitive pen button released.

constexpr EventType EVENT_PEN_MOTION =
  SDL_EVENT_PEN_MOTION; ///< Pressure-sensitive pen is moving on the tablet.

constexpr EventType EVENT_PEN_AXIS =
  SDL_EVENT_PEN_AXIS; ///< Pressure-sensitive pen angle/pressure/etc changed.

constexpr EventType EVENT_CAMERA_DEVICE_ADDED =
  SDL_EVENT_CAMERA_DEVICE_ADDED; ///< A new camera device is available.

constexpr EventType EVENT_CAMERA_DEVICE_REMOVED =
  SDL_EVENT_CAMERA_DEVICE_REMOVED; ///< A camera device has been removed.

/// A camera device has been approved for use by the user.
constexpr EventType EVENT_CAMERA_DEVICE_APPROVED =
  SDL_EVENT_CAMERA_DEVICE_APPROVED;

/// A camera device has been denied for use by the user.
constexpr EventType EVENT_CAMERA_DEVICE_DENIED = SDL_EVENT_CAMERA_DEVICE_DENIED;

/// The render targets have been reset and their contents need to be updated.
constexpr EventType EVENT_RENDER_TARGETS_RESET = SDL_EVENT_RENDER_TARGETS_RESET;

/// The device has been reset and all textures need to be recreated.
constexpr EventType EVENT_RENDER_DEVICE_RESET = SDL_EVENT_RENDER_DEVICE_RESET;

constexpr EventType EVENT_RENDER_DEVICE_LOST =
  SDL_EVENT_RENDER_DEVICE_LOST; ///< The device has been lost and can't be
                                ///< recovered.

constexpr EventType EVENT_PRIVATE0 = SDL_EVENT_PRIVATE0; ///< PRIVATE0

constexpr EventType EVENT_PRIVATE1 = SDL_EVENT_PRIVATE1; ///< PRIVATE1

constexpr EventType EVENT_PRIVATE2 = SDL_EVENT_PRIVATE2; ///< PRIVATE2

constexpr EventType EVENT_PRIVATE3 = SDL_EVENT_PRIVATE3; ///< PRIVATE3

constexpr EventType EVENT_POLL_SENTINEL =
  SDL_EVENT_POLL_SENTINEL; ///< Signals the end of an event poll cycle.

/**
 * Events EVENT_USER through EVENT_LAST are for your use, and should be
 * allocated with RegisterEvents()
 */
constexpr EventType EVENT_USER = SDL_EVENT_USER;

/// This last event is only for bounding internal arrays.
constexpr EventType EVENT_LAST = SDL_EVENT_LAST;

constexpr EventType EVENT_ENUM_PADDING =
  SDL_EVENT_ENUM_PADDING; ///< ENUM_PADDING

/// @}

/**
 * Fields shared by every event
 *
 * @since This struct is available since SDL 3.2.0.
 */
using CommonEvent = SDL_CommonEvent;

/**
 * Display state change event data (event.display.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using DisplayEvent = SDL_DisplayEvent;

/**
 * Window state change event data (event.window.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using WindowEvent = SDL_WindowEvent;

/**
 * Keyboard device event structure (event.kdevice.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using KeyboardDeviceEvent = SDL_KeyboardDeviceEvent;

/**
 * Keyboard button event structure (event.key.*)
 *
 * The `key` is the base Keycode generated by pressing the `scancode`
 * using the current keyboard layout, applying any options specified in
 * SDL_HINT_KEYCODE_OPTIONS. You can get the Keycode corresponding to the
 * event scancode and modifiers directly from the keyboard layout, bypassing
 * SDL_HINT_KEYCODE_OPTIONS, by calling Keycode.Keycode().
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @sa Keycode.Keycode
 * @sa SDL_HINT_KEYCODE_OPTIONS
 */
using KeyboardEvent = SDL_KeyboardEvent;

/**
 * Keyboard text editing event structure (event.edit.*)
 *
 * The start cursor is the position, in UTF-8 characters, where new typing
 * will be inserted into the editing text. The length is the number of UTF-8
 * characters that will be replaced by new typing.
 *
 * @since This struct is available since SDL 3.2.0.
 */
using TextEditingEvent = SDL_TextEditingEvent;

/**
 * Keyboard IME candidates event structure (event.edit_candidates.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using TextEditingCandidatesEvent = SDL_TextEditingCandidatesEvent;

/**
 * Keyboard text input event structure (event.text.*)
 *
 * This event will never be delivered unless text input is enabled by calling
 * Window.StartTextInput(). Text input is disabled by default!
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @sa Window.StartTextInput
 * @sa Window.StopTextInput
 */
using TextInputEvent = SDL_TextInputEvent;

/**
 * Mouse device event structure (event.mdevice.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using MouseDeviceEvent = SDL_MouseDeviceEvent;

/**
 * Mouse motion event structure (event.motion.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using MouseMotionEvent = SDL_MouseMotionEvent;

/**
 * Mouse button event structure (event.button.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using MouseButtonEvent = SDL_MouseButtonEvent;

/**
 * Mouse wheel event structure (event.wheel.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using MouseWheelEvent = SDL_MouseWheelEvent;

/**
 * Joystick axis motion event structure (event.jaxis.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using JoyAxisEvent = SDL_JoyAxisEvent;

/**
 * Joystick trackball motion event structure (event.jball.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using JoyBallEvent = SDL_JoyBallEvent;

/**
 * Joystick hat position change event structure (event.jhat.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using JoyHatEvent = SDL_JoyHatEvent;

/**
 * Joystick button event structure (event.jbutton.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using JoyButtonEvent = SDL_JoyButtonEvent;

/**
 * Joystick device event structure (event.jdevice.*)
 *
 * SDL will send JOYSTICK_ADDED events for devices that are already plugged in
 * during Init.
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @sa GamepadDeviceEvent
 */
using JoyDeviceEvent = SDL_JoyDeviceEvent;

/**
 * Joystick battery level change event structure (event.jbattery.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using JoyBatteryEvent = SDL_JoyBatteryEvent;

/**
 * Gamepad axis motion event structure (event.gaxis.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using GamepadAxisEvent = SDL_GamepadAxisEvent;

/**
 * Gamepad button event structure (event.gbutton.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using GamepadButtonEvent = SDL_GamepadButtonEvent;

/**
 * Gamepad device event structure (event.gdevice.*)
 *
 * Joysticks that are supported gamepads receive both an JoyDeviceEvent
 * and an GamepadDeviceEvent.
 *
 * SDL will send GAMEPAD_ADDED events for joysticks that are already plugged
 * in during Init() and are recognized as gamepads. It will also send
 * events for joysticks that get gamepad mappings at runtime.
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @sa JoyDeviceEvent
 */
using GamepadDeviceEvent = SDL_GamepadDeviceEvent;

/**
 * Gamepad touchpad event structure (event.gtouchpad.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using GamepadTouchpadEvent = SDL_GamepadTouchpadEvent;

/**
 * Gamepad sensor event structure (event.gsensor.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using GamepadSensorEvent = SDL_GamepadSensorEvent;

/**
 * Audio device event structure (event.adevice.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using AudioDeviceEvent = SDL_AudioDeviceEvent;

/**
 * Camera device event structure (event.cdevice.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using CameraDeviceEvent = SDL_CameraDeviceEvent;

/**
 * Renderer event structure (event.render.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using RenderEvent = SDL_RenderEvent;

/**
 * Touch finger event structure (event.tfinger.*)
 *
 * Coordinates in this event are normalized. `x` and `y` are normalized to a
 * range between 0.0f and 1.0f, relative to the window, so (0,0) is the top
 * left and (1,1) is the bottom right. Delta coordinates `dx` and `dy` are
 * normalized in the ranges of -1.0f (traversed all the way from the bottom or
 * right to all the way up or left) to 1.0f (traversed all the way from the
 * top or left to all the way down or right).
 *
 * Note that while the coordinates are _normalized_, they are not _clamped_,
 * which means in some circumstances you can get a value outside of this
 * range. For example, a renderer using logical presentation might give a
 * negative value when the touch is in the letterboxing. Some platforms might
 * report a touch outside of the window, which will also be outside of the
 * range.
 *
 * @since This struct is available since SDL 3.2.0.
 */
using TouchFingerEvent = SDL_TouchFingerEvent;

/**
 * Pressure-sensitive pen proximity event structure (event.pmotion.*)
 *
 * When a pen becomes visible to the system (it is close enough to a tablet,
 * etc), SDL will send an EVENT_PEN_PROXIMITY_IN event with the new pen's
 * ID. This ID is valid until the pen leaves proximity again (has been removed
 * from the tablet's area, the tablet has been unplugged, etc). If the same
 * pen reenters proximity again, it will be given a new ID.
 *
 * Note that "proximity" means "close enough for the tablet to know the tool
 * is there." The pen touching and lifting off from the tablet while not
 * leaving the area are handled by EVENT_PEN_DOWN and EVENT_PEN_UP.
 *
 * @since This struct is available since SDL 3.2.0.
 */
using PenProximityEvent = SDL_PenProximityEvent;

/**
 * Pressure-sensitive pen motion event structure (event.pmotion.*)
 *
 * Depending on the hardware, you may get motion events when the pen is not
 * touching a tablet, for tracking a pen even when it isn't drawing. You
 * should listen for EVENT_PEN_DOWN and EVENT_PEN_UP events, or check
 * `pen_state & SDL_PEN_INPUT_DOWN` to decide if a pen is "drawing" when
 * dealing with pen motion.
 *
 * @since This struct is available since SDL 3.2.0.
 */
using PenMotionEvent = SDL_PenMotionEvent;

/**
 * Pressure-sensitive pen touched event structure (event.ptouch.*)
 *
 * These events come when a pen touches a surface (a tablet, etc), or lifts
 * off from one.
 *
 * @since This struct is available since SDL 3.2.0.
 */
using PenTouchEvent = SDL_PenTouchEvent;

/**
 * Pressure-sensitive pen button event structure (event.pbutton.*)
 *
 * This is for buttons on the pen itself that the user might click. The pen
 * itself pressing down to draw triggers a EVENT_PEN_DOWN event instead.
 *
 * @since This struct is available since SDL 3.2.0.
 */
using PenButtonEvent = SDL_PenButtonEvent;

/**
 * Pressure-sensitive pen pressure / angle event structure (event.paxis.*)
 *
 * You might get some of these events even if the pen isn't touching the
 * tablet.
 *
 * @since This struct is available since SDL 3.2.0.
 */
using PenAxisEvent = SDL_PenAxisEvent;

/**
 * An event used to drop text or request a file open by the system
 * (event.drop.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using DropEvent = SDL_DropEvent;

/**
 * An event triggered when the clipboard contents have changed
 * (event.clipboard.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using ClipboardEvent = SDL_ClipboardEvent;

/**
 * Sensor event structure (event.sensor.*)
 *
 * @since This struct is available since SDL 3.2.0.
 */
using SensorEvent = SDL_SensorEvent;

/**
 * The "quit requested" event
 *
 * @since This struct is available since SDL 3.2.0.
 */
using QuitEvent = SDL_QuitEvent;

/**
 * A user-defined event type (event.user.*)
 *
 * This event is unique; it is never created by SDL, but only by the
 * application. The event can be pushed onto the event queue using
 * PushEvent(). The contents of the structure members are completely up to
 * the programmer; the only requirement is that '''type''' is a value obtained
 * from RegisterEvents().
 *
 * @since This struct is available since SDL 3.2.0.
 */
using UserEvent = SDL_UserEvent;

/**
 * The structure for all events in SDL.
 *
 * The Event structure is the core of all event handling in SDL. Event
 * is a union of all event structures used in SDL.
 *
 * @since This struct is available since SDL 3.2.0.
 */
using Event = SDL_Event;

/**
 * Pump the event loop, gathering events from the input devices.
 *
 * This function updates the event queue and internal input device state.
 *
 * PumpEvents() gathers all the pending input information from devices and
 * places it in the event queue. Without calls to PumpEvents() no events
 * would ever be placed on the queue. Often the need for calls to
 * PumpEvents() is hidden from the user since PollEvent() and
 * WaitEvent() implicitly call PumpEvents(). However, if you are not
 * polling or waiting for events (e.g. you are filtering them), then you must
 * call PumpEvents() to force an event queue update.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa PollEvent
 * @sa WaitEvent
 */
inline void PumpEvents() { SDL_PumpEvents(); }

/**
 * @name EventActions
 * The type of action to request from PeepEvents().
 * @{
 */

/**
 * The type of action to request from PeepEvents().
 *
 * @since This enum is available since SDL 3.2.0.
 */
using EventAction = SDL_EventAction;

constexpr EventAction ADDEVENT =
  SDL_ADDEVENT; ///< Add events to the back of the queue.

/// Check but don't remove events from the queue front.
constexpr EventAction PEEKEVENT = SDL_PEEKEVENT;

/// Retrieve/remove events from the front of the queue.
constexpr EventAction GETEVENT = SDL_GETEVENT;

/// @}

/**
 * Check the event queue for messages and optionally return them.
 *
 * `action` may be any of the following:
 *
 * ## remarks
 *
 * - `ADDEVENT`: up to `numevents` events will be added to the back of the
 *   event queue.
 * - `PEEKEVENT`: `numevents` events at the front of the event queue,
 *   within the specified minimum and maximum type, will be returned to the
 *   caller and will _not_ be removed from the queue. If you pass nullptr for
 *   `events`, then `numevents` is ignored and the total number of matching
 *   events will be returned.
 * - `GETEVENT`: up to `numevents` events at the front of the event queue,
 *   within the specified minimum and maximum type, will be returned to the
 *   caller and will be removed from the queue.
 *
 * You may have to call PumpEvents() before calling this function.
 * Otherwise, the events may not be ready to be filtered when you call
 * PeepEvents().
 *
 * @param events destination buffer for the retrieved events, may be nullptr to
 *               leave the events in the queue and return the number of events
 *               that would have been stored.
 * @param numevents if action is ADDEVENT, the number of events to add
 *                  back to the event queue; if action is PEEKEVENT or
 *                  GETEVENT, the maximum number of events to retrieve.
 * @param action action to take; see [Remarks](#remarks) for details.
 * @param minType minimum value of the event type to be considered;
 *                EVENT_FIRST is a safe choice.
 * @param maxType maximum value of the event type to be considered;
 *                EVENT_LAST is a safe choice.
 * @returns the number of events actually stored or -1 on failure; call
 *          GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa PollEvent
 * @sa PumpEvents
 * @sa PushEvent
 */
inline int PeepEvents(Event* events,
                      int numevents,
                      EventAction action,
                      Uint32 minType = EVENT_FIRST,
                      Uint32 maxType = EVENT_LAST)
{
  return SDL_PeepEvents(events, numevents, action, minType, maxType);
}

/**
 * Check for the existence of a certain event type in the event queue.
 *
 * If you need to check for a range of event types, use HasEvents()
 * instead.
 *
 * @param type the type of event to be queried; see EventType for details.
 * @returns true if events matching `type` are present, or false if events
 *          matching `type` are not present.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa HasEvents
 */
inline bool HasEvent(Uint32 type) { return SDL_HasEvent(type); }

/**
 * Check for the existence of certain event types in the event queue.
 *
 * If you need to check for a single event type, use HasEvent() instead.
 *
 * @param minType the low end of event type to be queried, inclusive; see
 *                EventType for details.
 * @param maxType the high end of event type to be queried, inclusive; see
 *                EventType for details.
 * @returns true if events with type >= `minType` and <= `maxType` are
 *          present, or false if not.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa HasEvents
 */
inline bool HasEvents(Uint32 minType = EVENT_FIRST, Uint32 maxType = EVENT_LAST)
{
  return SDL_HasEvents(minType, maxType);
}

/**
 * Clear events of a specific type from the event queue.
 *
 * This will unconditionally remove any events from the queue that match
 * `type`. If you need to remove a range of event types, use FlushEvents()
 * instead.
 *
 * It's also normal to just ignore events you don't care about in your event
 * loop without calling this function.
 *
 * This function only affects currently queued events. If you want to make
 * sure that all pending OS events are flushed, you can call PumpEvents()
 * on the main thread immediately before the flush call.
 *
 * If you have user events with custom data that needs to be freed, you should
 * use PeepEvents() to remove and clean up those events before calling
 * this function.
 *
 * @param type the type of event to be cleared; see EventType for details.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa FlushEvents
 */
inline void FlushEvent(Uint32 type) { SDL_FlushEvent(type); }

/**
 * Clear events of a range of types from the event queue.
 *
 * This will unconditionally remove any events from the queue that are in the
 * range of `minType` to `maxType`, inclusive. If you need to remove a single
 * event type, use FlushEvent() instead.
 *
 * It's also normal to just ignore events you don't care about in your event
 * loop without calling this function.
 *
 * This function only affects currently queued events. If you want to make
 * sure that all pending OS events are flushed, you can call PumpEvents()
 * on the main thread immediately before the flush call.
 *
 * @param minType the low end of event type to be cleared, inclusive; see
 *                EventType for details.
 * @param maxType the high end of event type to be cleared, inclusive; see
 *                EventType for details.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa FlushEvent
 */
inline void FlushEvents(Uint32 minType = EVENT_FIRST,
                        Uint32 maxType = EVENT_LAST)
{
  SDL_FlushEvents(minType, maxType);
}

/**
 * Poll for currently pending events.
 *
 * If `event` is not nullptr, the next event is removed from the queue and
 * stored in the Event structure pointed to by `event`. The 1 returned refers to
 * this event, immediately stored in the SDL Event structure -- not an event
 * to follow.
 *
 * If `event` is nullptr, it simply returns 1 if there is an event in the queue,
 * but will not remove it from the queue.
 *
 * As this function may implicitly call PumpEvents(), you can only call
 * this function in the thread that set the video mode.
 *
 * PollEvent() is the favored way of receiving system events since it can
 * be done from the main loop and does not suspend the main loop while waiting
 * on an event to be posted.
 *
 * The common practice is to fully process the event queue once every frame,
 * usually as a first step before updating the game's state:
 *
 * ```cpp
 * while (game_is_still_running) {
 *     SDL::Event event;
 *     while (SDL::PollEvent(&event)) {  // poll until all events are handled!
 *         // decide what to do with this event.
 *     }
 *
 *     // update game state, draw the current frame
 * }
 * ```
 *
 * @param event the Event structure to be filled with the next event from
 *              the queue, or nullptr.
 * @returns true if this got an event or false if there are none available.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa PushEvent
 * @sa WaitEvent
 * @sa WaitEventTimeout
 */
inline bool PollEvent(Event* event) { return SDL_PollEvent(event); }

/**
 * Poll for currently pending events.
 *
 * The next event is removed from the queue and returned.
 *
 * As this function may implicitly call PumpEvents(), you can only call
 * this function in the thread that set the video mode.
 *
 * PollEvent() is the favored way of receiving system events since it can
 * be done from the main loop and does not suspend the main loop while waiting
 * on an event to be posted.
 *
 * The common practice is to fully process the event queue once every frame,
 * usually as a first step before updating the game's state:
 *
 * ```c
 * while (game_is_still_running) {
 *     while (auto event = SDL::PollEvent()) {
 *         // decide what to do with this event.
 *     }
 *
 *     // update game state, draw the current frame
 * }
 * ```
 *
 * @returns Event if this got an event or std::nullopt if there are none
 * available.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa PushEvent
 * @sa WaitEvent
 * @sa WaitEventTimeout
 */
inline std::optional<Event> PollEvent()
{
  if (Event event; PollEvent(&event)) return event;
  return std::nullopt;
}

/**
 * Wait indefinitely for the next available event.
 *
 * If `event` is not nullptr, the next event is removed from the queue and
 * stored in the Event structure pointed to by `event`.
 *
 * As this function may implicitly call PumpEvents(), you can only call
 * this function in the thread that initialized the video subsystem.
 *
 * @param event the Event structure to be filled in with the next event
 *              from the queue, or nullptr.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa PollEvent
 * @sa PushEvent
 * @sa WaitEventTimeout
 */
inline void WaitEvent(Event* event) { CheckError(SDL_WaitEvent(event)); }

/**
 * Wait indefinitely for the next available event.
 *
 * The next event is removed from the queue and returned.
 *
 * As this function may implicitly call PumpEvents(), you can only call
 * this function in the thread that initialized the video subsystem.
 *
 * @returns Event on success.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa PollEvent
 * @sa PushEvent
 * @sa WaitEventTimeout
 */
inline Event WaitEvent()
{
  Event event;
  WaitEvent(&event);
  return event;
}

/**
 * Wait until the specified timeout (in milliseconds) for the next available
 * event.
 *
 * If `event` is not nullptr, the next event is removed from the queue and
 * stored in the Event structure pointed to by `event`.
 *
 * As this function may implicitly call PumpEvents(), you can only call
 * this function in the thread that initialized the video subsystem.
 *
 * The timeout is not guaranteed, the actual wait time could be longer due to
 * system scheduling.
 *
 * @param event the Event structure to be filled in with the next event
 *              from the queue, or nullptr.
 * @param timeoutMS the maximum number of milliseconds to wait for the next
 *                  available event.
 * @returns true if this got an event or false if the timeout elapsed without
 *          any events available.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa PollEvent
 * @sa PushEvent
 * @sa WaitEvent
 */
inline bool WaitEventTimeout(Event* event, Sint32 timeoutMS)
{
  return SDL_WaitEventTimeout(event, timeoutMS);
}

/**
 * Wait until the specified timeout (in milliseconds) for the next available
 * event.
 *
 * As this function may implicitly call PumpEvents(), you can only call
 * this function in the thread that initialized the video subsystem.
 *
 * The timeout is not guaranteed, the actual wait time could be longer due to
 * system scheduling.
 *
 * @param timeoutMS the maximum number of milliseconds to wait for the next
 *                  available event.
 * @returns the Event if this got an event or std::nullopt if the timeout
 * elapsed without any events available.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa PollEvent
 * @sa PushEvent
 * @sa WaitEvent
 */
inline std::optional<Event> WaitEventTimeout(Sint32 timeoutMS)
{
  if (Event event; WaitEventTimeout(&event, timeoutMS)) return event;
  return std::nullopt;
}

/**
 * Wait until the specified timeout (in milliseconds) for the next available
 * event.
 *
 * If `event` is not nullptr, the next event is removed from the queue and
 * stored in the Event structure pointed to by `event`.
 *
 * As this function may implicitly call PumpEvents(), you can only call
 * this function in the thread that initialized the video subsystem.
 *
 * The timeout is not guaranteed, the actual wait time could be longer due to
 * system scheduling.
 *
 * @param event the Event structure to be filled in with the next event
 *              from the queue, or nullptr.
 * @param timeoutDuration the duration to wait for the next available event,
 *                        with millisecond precision
 * @returns true if this got an event or false if the timeout elapsed without
 *          any events available.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa PollEvent
 * @sa PushEvent
 * @sa WaitEvent
 */
inline bool WaitEventTimeout(Event* event,
                             std::chrono::milliseconds timeoutDuration)
{
  return WaitEventTimeout(event, std::max(timeoutDuration.count(), 1l));
}

/**
 * Wait until the specified timeout (with milliseconds precision) for the next
 * available event.
 *
 * As this function may implicitly call PumpEvents(), you can only call
 * this function in the thread that initialized the video subsystem.
 *
 * The timeout is not guaranteed, the actual wait time could be longer due to
 * system scheduling.
 *
 * @param timeoutDuration the duration to wait for the next available event,
 *                        with millisecond precision.
 * @returns the Event if this got an event or std::nullopt if the timeout
 * elapsed without any events available.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa PollEvent
 * @sa PushEvent
 * @sa WaitEvent
 */
inline std::optional<Event> WaitEventTimeout(
  std::chrono::milliseconds timeoutDuration)
{
  if (Event event; WaitEventTimeout(&event, timeoutDuration)) return event;
  return std::nullopt;
}

/**
 * Add an event to the event queue.
 *
 * The event queue can actually be used as a two way communication channel.
 * Not only can events be read from the queue, but the user can also push
 * their own events onto it. `event` is a pointer to the event structure you
 * wish to push onto the queue. The event is copied into the queue, and the
 * caller may dispose of the memory pointed to after PushEvent() returns.
 *
 * Note: Pushing device input events onto the queue doesn't modify the state
 * of the device within SDL.
 *
 * Note: Events pushed onto the queue with PushEvent() get passed through
 * the event filter but events added with PeepEvents() do not.
 *
 * For pushing application-specific events, please use RegisterEvents() to
 * get an event type that does not conflict with other code that also wants
 * its own custom event types.
 *
 * @param event the Event to be added to the queue.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa PeepEvents
 * @sa PollEvent
 * @sa RegisterEvents
 */
inline void PushEvent(Event* event) { CheckError(SDL_PushEvent(event)); }

/**
 * Add an event to the event queue.
 *
 * The event queue can actually be used as a two way communication channel.
 * Not only can events be read from the queue, but the user can also push
 * their own events onto it. `event` is a pointer to the event structure you
 * wish to push onto the queue. The event is copied into the queue, and the
 * caller may dispose of the memory pointed to after PushEvent() returns.
 *
 * Note: Pushing device input events onto the queue doesn't modify the state
 * of the device within SDL.
 *
 * Note: Events pushed onto the queue with PushEvent() get passed through
 * the event filter but events added with PeepEvents() do not.
 *
 * For pushing application-specific events, please use RegisterEvents() to
 * get an event type that does not conflict with other code that also wants
 * its own custom event types.
 *
 * @param event the Event to be added to the queue.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa PeepEvents
 * @sa PollEvent
 * @sa RegisterEvents
 */
inline void PushEvent(const Event& event)
{
  PushEvent(const_cast<Event*>(&event));
}

/**
 * A function pointer used for callbacks that watch the event queue.
 *
 * @param userdata what was passed as `userdata` to SetEventFilter() or
 *                 AddEventWatch, etc.
 * @param event the event that triggered the callback.
 * @returns true to permit event to be added to the queue, and false to
 *          disallow it. When used with AddEventWatch, the return value is
 *          ignored.
 *
 * @threadsafety SDL may call this callback at any time from any thread; the
 *               application is responsible for locking resources the callback
 *               touches that need to be protected.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @sa SetEventFilter
 * @sa AddEventWatch
 */
using EventFilter = SDL_EventFilter;

/**
 * A std::function used for callbacks that watch the event queue.
 *
 * @param event the event that triggered the callback.
 * @returns true to permit event to be added to the queue, and false to
 *          disallow it. When used with AddEventWatch(), the return value is
 *          ignored.
 *
 * @threadsafety SDL may call this callback at any time from any thread; the
 *               application is responsible for locking resources the callback
 *               touches that need to be protected.
 *
 * @since This datatype is available since SDL 3.2.0.
 *
 * @cat listener-callback
 *
 * @sa listener-callback
 * @sa SetEventFilter()
 * @sa AddEventWatch()
 * @sa EventFilter
 */
using EventFilterCB = std::function<bool(const Event&)>;

/**
 * Handle returned by AddEventWatch(EventFilterCB)
 *
 * This can be used later to remove the event filter
 * RemoveEventWatch(EventFilterHandle).
 */
struct EventWatchHandle : CallbackHandle
{
  using CallbackHandle::CallbackHandle;
};

/**
 * Set up a filter to process all events before they are added to the internal
 * event queue.
 *
 * If you just want to see events without modifying them or preventing them
 * from being queued, you should use AddEventWatch() instead.
 *
 * If the filter function returns true when called, then the event will be
 * added to the internal queue. If it returns false, then the event will be
 * dropped from the queue, but the internal state will still be updated. This
 * allows selective filtering of dynamically arriving events.
 *
 * **WARNING**: Be very careful of what you do in the event filter function,
 * as it may run in a different thread!
 *
 * On platforms that support it, if the quit event is generated by an
 * interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the
 * application at the next event poll.
 *
 * Note: Disabled events never make it to the event filter function; see
 * SetEventEnabled().
 *
 * Note: Events pushed onto the queue with PushEvent() get passed through
 * the event filter, but events pushed onto the queue with PeepEvents() do
 * not.
 *
 * @param filter an EventFilter function to call when an event happens.
 * @param userdata a pointer that is passed to `filter`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AddEventWatch
 * @sa SetEventEnabled
 * @sa GetEventFilter
 * @sa PeepEvents
 * @sa PushEvent
 */
inline void SetEventFilter(EventFilter filter, void* userdata)
{
  UniqueCallbackWrapper<EventFilterCB>::erase();
  return SDL_SetEventFilter(filter, userdata);
}

/**
 * Set up a filter to process all events before they are added to the internal
 * event queue.
 *
 * If you just want to see events without modifying them or preventing them
 * from being queued, you should use AddEventWatch() instead.
 *
 * If the filter function returns true when called, then the event will be
 * added to the internal queue. If it returns false, then the event will be
 * dropped from the queue, but the internal state will still be updated. This
 * allows selective filtering of dynamically arriving events.
 *
 * **WARNING**: Be very careful of what you do in the event filter function,
 * as it may run in a different thread!
 *
 * On platforms that support it, if the quit event is generated by an
 * interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the
 * application at the next event poll.
 *
 * Note: Disabled events never make it to the event filter function; see
 * SetEventEnabled().
 *
 * Note: Events pushed onto the queue with PushEvent() get passed through
 * the event filter, but events pushed onto the queue with PeepEvents() do
 * not.
 *
 * @param filter an EventFilterCB function to call when an event happens.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @cat listener-callback
 *
 * @sa listener-callback
 * @sa AddEventWatch
 * @sa SetEventEnabled
 * @sa GetEventFilter
 * @sa PeepEvents
 * @sa PushEvent
 */
inline void SetEventFilter(EventFilterCB filter = {})
{
  using Wrapper = UniqueCallbackWrapper<EventFilterCB>;
  SDL_SetEventFilter(
    [](void* userdata, SDL_Event* event) {
      return Wrapper::Call(userdata, *event);
    },
    Wrapper::Wrap(std::move(filter)));
}

/**
 * Query the current event filter.
 *
 * This function can be used to "chain" filters, by saving the existing filter
 * before replacing it with a function that will call that saved filter.
 *
 * @param filter the current callback function will be stored here.
 * @param userdata the pointer that is passed to the current event filter will
 *                 be stored here.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SetEventFilter
 */
inline void GetEventFilter(EventFilter* filter, void** userdata)
{
  CheckError(SDL_GetEventFilter(filter, userdata));
}

/**
 * Query the current event filter.
 *
 * This function can be used to "chain" filters, by saving the existing filter
 * before replacing it with a function that will call that saved filter.
 *
 * @returns EventFilterCB on success or false if there is no event filter
 * set.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @cat listener-callback
 *
 * @sa listener-callback
 * @sa SetEventFilter
 */
inline EventFilterCB GetEventFilter()
{
  using Wrapper = UniqueCallbackWrapper<EventFilterCB>;

  EventFilter filter;
  void* userdata;
  GetEventFilter(&filter, &userdata);
  if (!userdata)
    return [filter](const Event& event) {
      return filter(nullptr, const_cast<Event*>(&event));
    };
  if (auto cb = Wrapper::at(userdata)) return cb;
  return [filter, userdata](const Event& event) {
    return filter(userdata, const_cast<Event*>(&event));
  };
}

/// @private
inline bool EventWatchAuxCallback(void* userdata, Event* event)
{
  auto& f = *static_cast<EventFilterCB*>(userdata);
  return f(*event);
}

/**
 * Add a callback to be triggered when an event is added to the event queue.
 *
 * `filter` will be called when an event happens, and its return value is
 * ignored.
 *
 * **WARNING**: Be very careful of what you do in the event filter function,
 * as it may run in a different thread!
 *
 * If the quit event is generated by a signal (e.g. SIGINT), it will bypass
 * the internal queue and be delivered to the watch callback immediately, and
 * arrive at the next event poll.
 *
 * Note: the callback is called for events posted by the user through
 * PushEvent(), but not for disabled events, nor for events by a filter
 * callback set with SetEventFilter(), nor for events posted by the user
 * through PeepEvents().
 *
 * @param filter an EventFilter function to call when an event happens.
 * @param userdata a pointer that is passed to `filter`.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa RemoveEventWatch
 * @sa SetEventFilter
 */
inline void AddEventWatch(EventFilter filter, void* userdata)
{
  CheckError(SDL_AddEventWatch(filter, userdata));
}

/**
 * Add a callback to be triggered when an event is added to the event queue.
 *
 * `filter` will be called when an event happens, and its return value is
 * ignored.
 *
 * **WARNING**: Be very careful of what you do in the event filter function,
 * as it may run in a different thread!
 *
 * If the quit event is generated by a signal (e.g. SIGINT), it will bypass
 * the internal queue and be delivered to the watch callback immediately, and
 * arrive at the next event poll.
 *
 * Note: the callback is called for events posted by the user through
 * PushEvent(), but not for disabled events, nor for events by a filter
 * callback set with SetEventFilter(), nor for events posted by the user
 * through PeepEvents().
 *
 * @param filter an EventFilterCB to call when an event happens.
 * @returns a handle that can be used on RemoveEventWatch(EventFilterHandle) on
 *          success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @cat listener-callback
 *
 * @sa listener-callback
 * @sa RemoveEventWatch
 * @sa SetEventFilter
 */
inline EventWatchHandle AddEventWatch(EventFilterCB filter)
{
  using Wrapper = CallbackWrapper<EventFilterCB>;
  auto cb = Wrapper::Wrap(std::move(filter));
  if (!SDL_AddEventWatch(&EventWatchAuxCallback, &cb)) {
    Wrapper::release(cb);
    throw Error{};
  }
  return EventWatchHandle{cb};
}

/**
 * Remove an event watch callback added with AddEventWatch().
 *
 * This function takes the same input as AddEventWatch() to identify and
 * delete the corresponding callback.
 *
 * @param filter the function originally passed to AddEventWatch().
 * @param userdata the pointer originally passed to AddEventWatch().
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa AddEventWatch
 */
inline void RemoveEventWatch(EventFilter filter, void* userdata)
{
  SDL_RemoveEventWatch(filter, userdata);
}

/**
 * Remove an event watch callback added with AddEventWatch().
 *
 * @param handle the handle returned by SDL_AddEventWatch(EventFilterCB).
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @cat listener-callback
 *
 * @sa listener-callback
 * @sa AddEventWatch(EventFilterCB)
 */
inline void RemoveEventWatch(EventWatchHandle handle)
{
  using Wrapper = CallbackWrapper<EventFilterCB>;
  Wrapper::release(handle);
}

/**
 * Run a specific filter function on the current event queue, removing any
 * events for which the filter returns false.
 *
 * See SetEventFilter() for more information. Unlike SetEventFilter(),
 * this function does not change the filter permanently, it only uses the
 * supplied filter until this function returns.
 *
 * @param filter the EventFilter function to call when an event happens.
 * @param userdata a pointer that is passed to `filter`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetEventFilter
 * @sa SetEventFilter
 */
inline void FilterEvents(EventFilter filter, void* userdata)
{
  SDL_FilterEvents(filter, userdata);
}

/**
 * Run a specific filter function on the current event queue, removing any
 * events for which the filter returns false.
 *
 * See SetEventFilter() for more information. Unlike SetEventFilter(),
 * this function does not change the filter permanently, it only uses the
 * supplied filter until this function returns.
 *
 * @param filter the EventFilter function to call when an event happens.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @cat immediate-callback
 *
 * @sa immediate-callback
 * @sa GetEventFilter
 * @sa SetEventFilter
 */
inline void FilterEvents(EventFilterCB filter)
{
  return FilterEvents(
    [](void* userdata, SDL_Event* event) {
      auto& f = *static_cast<EventFilterCB*>(userdata);
      return f(*event);
    },
    &filter);
}

/**
 * Set the state of processing events by type.
 *
 * @param type the type of event; see EventType for details.
 * @param enabled whether to process the event or not.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa EventEnabled
 */
inline void SetEventEnabled(Uint32 type, bool enabled)
{
  SDL_SetEventEnabled(type, enabled);
}

/**
 * Query the state of processing events by type.
 *
 * @param type the type of event; see EventType for details.
 * @returns true if the event is being processed, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SetEventEnabled
 */
inline bool EventEnabled(Uint32 type) { return SDL_EventEnabled(type); }

/**
 * Allocate a set of user-defined events, and return the beginning event
 * number for that set of events.
 *
 * @param numevents the number of events to be allocated.
 * @returns the beginning event number, or 0 if numevents is invalid or if
 *          there are not enough user-defined events left.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa PushEvent
 */
inline Uint32 RegisterEvents(int numevents)
{
  return SDL_RegisterEvents(numevents);
}

/**
 * Get window associated with an event.
 *
 * @param event an event containing a `windowID`.
 * @returns the associated window on success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa PollEvent
 * @sa WaitEvent
 * @sa WaitEventTimeout
 */
inline WindowRef GetWindowFromEvent(const Event& event)
{
  return {CheckError(SDL_GetWindowFromEvent(&event))};
}

/// @}

/**
 * @defgroup CategoryRender 2D Accelerated Rendering
 *
 * Header file for SDL 2D rendering functions.
 *
 * This API supports the following features:
 *
 * - single pixel points
 * - single pixel lines
 * - filled rectangles
 * - texture images
 * - 2D polygons
 *
 * The primitives may be drawn in opaque, blended, or additive modes.
 *
 * The texture images may be drawn in opaque, blended, or additive modes. They
 * can have an additional color tint or alpha modulation applied to them, and
 * may also be stretched with linear interpolation.
 *
 * This API is designed to accelerate simple 2D operations. You may want more
 * functionality such as polygons and particle effects and in that case you
 * should use SDL's OpenGL/Direct3D support, the SDL3 GPU API, or one of the
 * many good 3D engines.
 *
 * These functions must be called from the main thread. See this bug for
 * details: https://github.com/libsdl-org/SDL/issues/986
 *
 * @{
 */

// Forward decl
struct Renderer;

using RendererRaw = SDL_Renderer*;

// Forward decl
struct RendererRef;

/// Safely wrap Renderer for non owning parameters
struct RendererParam
{
  RendererRaw value; ///< parameter's RendererRaw

  /// Constructs from RendererRaw
  constexpr RendererParam(RendererRaw value)
    : value(value)
  {
  }

  /// Constructs null/invalid
  constexpr RendererParam(std::nullptr_t _ = nullptr)
    : value(nullptr)
  {
  }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!value; }

  /// Comparison
  constexpr auto operator<=>(const RendererParam& other) const = default;

  /// Converts to underlying RendererRaw
  constexpr operator RendererRaw() const { return value; }
};

// Forward decl
struct Texture;

using TextureRaw = SDL_Texture*;

/// Safely wrap Texture for non owning parameters
struct TextureParam
{
  TextureRaw value; ///< parameter's TextureRaw

  /// Constructs from TextureRaw
  constexpr TextureParam(TextureRaw value)
    : value(value)
  {
  }

  /// Constructs null/invalid
  constexpr TextureParam(std::nullptr_t _ = nullptr)
    : value(nullptr)
  {
  }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!value; }

  /// Comparison
  constexpr auto operator<=>(const TextureParam& other) const = default;

  /// Converts to underlying TextureRaw
  constexpr operator TextureRaw() const { return value; }
};

#ifdef SDL3PP_DOC

/**
 * The name of the software renderer.
 *
 * @since This macro is available since SDL 3.2.0.
 */
#define SDL_SOFTWARE_RENDERER "software"

#endif // SDL3PP_DOC

/**
 * Vertex structure.
 *
 * @since This struct is available since SDL 3.2.0.
 */
using Vertex = SDL_Vertex;

/**
 * The access pattern allowed for a texture.
 *
 * @since This enum is available since SDL 3.2.0.
 */
using TextureAccess = SDL_TextureAccess;

constexpr TextureAccess TEXTUREACCESS_STATIC =
  SDL_TEXTUREACCESS_STATIC; ///< Changes rarely, not lockable.

constexpr TextureAccess TEXTUREACCESS_STREAMING =
  SDL_TEXTUREACCESS_STREAMING; ///< Changes frequently, lockable.

constexpr TextureAccess TEXTUREACCESS_TARGET =
  SDL_TEXTUREACCESS_TARGET; ///< Texture can be used as a render target.

/**
 * How the logical size is mapped to the output.
 *
 * @since This enum is available since SDL 3.2.0.
 */
using RendererLogicalPresentation = SDL_RendererLogicalPresentation;

constexpr RendererLogicalPresentation LOGICAL_PRESENTATION_DISABLED =
  SDL_LOGICAL_PRESENTATION_DISABLED; ///< There is no logical size in effect.

/// The rendered content is stretched to the output resolution.
constexpr RendererLogicalPresentation LOGICAL_PRESENTATION_STRETCH =
  SDL_LOGICAL_PRESENTATION_STRETCH;

/**
 * The rendered content is fit to the largest dimension and the other dimension
 * is letterboxed with black bars.
 */
constexpr RendererLogicalPresentation LOGICAL_PRESENTATION_LETTERBOX =
  SDL_LOGICAL_PRESENTATION_LETTERBOX;

/**
 * The rendered content is fit to the smallest dimension and the other dimension
 * extends beyond the output bounds.
 */
constexpr RendererLogicalPresentation LOGICAL_PRESENTATION_OVERSCAN =
  SDL_LOGICAL_PRESENTATION_OVERSCAN;

/**
 * The rendered content is scaled up by integer multiples to fit the output
 * resolution.
 */
constexpr RendererLogicalPresentation LOGICAL_PRESENTATION_INTEGER_SCALE =
  SDL_LOGICAL_PRESENTATION_INTEGER_SCALE;

/**
 * A structure representing rendering state
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @cat resource
 */
class Renderer
{
  RendererRaw m_resource = nullptr;

public:
  /// Default ctor
  constexpr Renderer() = default;

  /**
   * Constructs from RendererParam.
   *
   * @param resource a RendererRaw to be wrapped.
   *
   * This assumes the ownership, call release() if you need to take back.
   */
  constexpr explicit Renderer(const RendererRaw resource)
    : m_resource(resource)
  {
  }

  /// Copy constructor
  constexpr Renderer(const Renderer& other) = delete;

  /// Move constructor
  constexpr Renderer(Renderer&& other)
    : Renderer(other.release())
  {
  }

  constexpr Renderer(const RendererRef& other) = delete;

  constexpr Renderer(RendererRef&& other) = delete;

  /**
   * Create a 2D rendering context for a window.
   *
   * If you want a specific renderer, you can specify its name here. A list of
   * available renderers can be obtained by calling GetRenderDriver()
   * multiple times, with indices from 0 to GetNumRenderDrivers()-1. If you
   * don't need a specific renderer, specify nullptr and SDL will attempt to
   * choose the best option for you, based on what is available on the user's
   * system.
   *
   * If `name` is a comma-separated list, SDL will try each name, in the order
   * listed, until one succeeds or all of them fail.
   *
   * By default the rendering size matches the window size in pixels, but you
   * can call Renderer.SetLogicalPresentation() to change the content size and
   * scaling options.
   *
   * @param window the window where rendering is displayed.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.Renderer
   * @sa Renderer.Renderer
   * @sa Renderer.Destroy
   * @sa GetNumRenderDrivers
   * @sa GetRenderDriver
   * @sa Renderer.GetName
   */
  Renderer(WindowParam window)
    : m_resource(CheckError(SDL_CreateRenderer(window, nullptr)))
  {
  }

  /**
   * Create a 2D rendering context for a window.
   *
   * If you want a specific renderer, you can specify its name here. A list of
   * available renderers can be obtained by calling GetRenderDriver()
   * multiple times, with indices from 0 to GetNumRenderDrivers()-1. If you
   * don't need a specific renderer, specify nullptr and SDL will attempt to
   * choose the best option for you, based on what is available on the user's
   * system.
   *
   * If `name` is a comma-separated list, SDL will try each name, in the order
   * listed, until one succeeds or all of them fail.
   *
   * By default the rendering size matches the window size in pixels, but you
   * can call Renderer.SetLogicalPresentation() to change the content size and
   * scaling options.
   *
   * @param window the window where rendering is displayed.
   * @param name the name of the rendering driver to initialize, or nullptr to
   * let SDL choose one.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.Renderer
   * @sa Renderer.Renderer
   * @sa Renderer.Destroy
   * @sa GetNumRenderDrivers
   * @sa GetRenderDriver
   * @sa Renderer.GetName
   */
  Renderer(WindowParam window, StringParam name)
    : m_resource(CheckError(SDL_CreateRenderer(window, name)))
  {
  }

  /**
   * Create a 2D rendering context for a window, with the specified properties.
   *
   * These are the supported properties:
   *
   * - `prop::Renderer.CREATE_NAME_STRING`: the name of the rendering driver
   *   to use, if a specific one is desired
   * - `prop::Renderer.CREATE_WINDOW_POINTER`: the window where rendering is
   *   displayed, required if this isn't a software renderer using a surface
   * - `prop::Renderer.CREATE_SURFACE_POINTER`: the surface where rendering
   *   is displayed, if you want a software renderer without a window
   * - `prop::Renderer.CREATE_OUTPUT_COLORSPACE_NUMBER`: an Colorspace
   *   value describing the colorspace for output to the display, defaults to
   *   COLORSPACE_SRGB. The direct3d11, direct3d12, and metal renderers
   *   support COLORSPACE_SRGB_LINEAR, which is a linear color space and
   *   supports HDR output. If you select COLORSPACE_SRGB_LINEAR, drawing
   *   still uses the sRGB colorspace, but values can go beyond 1.0 and float
   *   (linear) format textures can be used for HDR content.
   * - `prop::Renderer.CREATE_PRESENT_VSYNC_NUMBER`: non-zero if you want
   *   present synchronized with the refresh rate. This property can take any
   *   value that is supported by Renderer.SetVSync() for the renderer.
   *
   * With the vulkan renderer:
   *
   * - `prop::Renderer.CREATE_VULKAN_INSTANCE_POINTER`: the VkInstance to use
   *   with the renderer, optional.
   * - `prop::Renderer.CREATE_VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR to use
   *   with the renderer, optional.
   * - `prop::Renderer.CREATE_VULKAN_PHYSICAL_DEVICE_POINTER`: the
   *   VkPhysicalDevice to use with the renderer, optional.
   * - `prop::Renderer.CREATE_VULKAN_DEVICE_POINTER`: the VkDevice to use
   *   with the renderer, optional.
   * - `prop::Renderer.CREATE_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the
   *   queue family index used for rendering.
   * - `prop::Renderer.CREATE_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the
   *   queue family index used for presentation.
   *
   * @param props the properties to use.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Properties.Create
   * @sa Renderer.Renderer
   * @sa Renderer.Renderer
   * @sa Renderer.Destroy
   * @sa Renderer.GetName
   */
  Renderer(PropertiesParam props)
    : m_resource(CheckError(SDL_CreateRendererWithProperties(props)))
  {
  }

  /**
   * Create a 2D software rendering context for a surface.
   *
   * Two other API which can be used to create Renderer:
   * Renderer.Renderer() and CreateWindowAndRenderer(). These can _also_
   * create a software renderer, but they are intended to be used with an
   * Window as the final destination and not an Surface.
   *
   * @param surface the Surface structure representing the surface where
   *                rendering is done.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.Destroy
   */
  Renderer(SurfaceParam surface)
    : m_resource(CheckError(SDL_CreateSoftwareRenderer(surface)))
  {
  }

  /// Destructor
  ~Renderer() { SDL_DestroyRenderer(m_resource); }

  /// Assignment operator.
  Renderer& operator=(Renderer other)
  {
    std::swap(m_resource, other.m_resource);
    return *this;
  }

  /// Retrieves underlying RendererRaw.
  constexpr RendererRaw get() const { return m_resource; }

  /// Retrieves underlying RendererRaw and clear this.
  constexpr RendererRaw release()
  {
    auto r = m_resource;
    m_resource = nullptr;
    return r;
  }

  /// Comparison
  constexpr auto operator<=>(const Renderer& other) const = default;

  /// Comparison
  constexpr bool operator==(std::nullptr_t _) const { return !m_resource; }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!m_resource; }

  /// Converts to RendererParam
  constexpr operator RendererParam() const { return {m_resource}; }

  /**
   * Destroy the rendering context for a window and free all associated
   * textures.
   *
   * This should be called before destroying the associated window.
   *
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.Renderer
   */
  void Destroy();

  /**
   * Get the window associated with a renderer.
   *
   * @returns the window on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  WindowRef GetWindow();

  /**
   * Get the name of a renderer.
   *
   * @returns the name of the selected renderer, or nullptr on failure; call
   *          GetError() for more information.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.Renderer
   */
  const char* GetName() const;

  /**
   * Get the output size in pixels of a rendering context.
   *
   * This returns the true output size in pixels, ignoring any render targets or
   * logical size and presentation.
   *
   * @returns Point on success.
   * @throws Error on failure.
   */
  Point GetOutputSize() const
  {
    Point p;
    GetOutputSize(&p.x, &p.y);
    return p;
  }

  /**
   * Get the output size in pixels of a rendering context.
   *
   * This returns the true output size in pixels, ignoring any render targets or
   * logical size and presentation.
   *
   * For the output size of the current rendering target, with logical size
   * adjustments, use Renderer.GetCurrentOutputSize() instead.
   *
   * @param w a pointer filled in with the width in pixels.
   * @param h a pointer filled in with the height in pixels.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.GetCurrentOutputSize
   */
  void GetOutputSize(int* w, int* h) const;

  /**
   * Get the current output size in pixels of a rendering context.
   *
   * If a rendering target is active, this will return the size of the rendering
   * target in pixels, otherwise if a logical size is set, it will return the
   * logical size, otherwise it will return the value of GetOutputSize().
   *
   * @returns the size on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.GetOutputSize()
   */
  Point GetCurrentOutputSize() const
  {
    Point p;
    GetCurrentOutputSize(&p.x, &p.y);
    return p;
  }

  /**
   * Get the current output size in pixels of a rendering context.
   *
   * If a rendering target is active, this will return the size of the rendering
   * target in pixels, otherwise return the value of Renderer.GetOutputSize().
   *
   * Rendering target or not, the output will be adjusted by the current logical
   * presentation state, dictated by Renderer.SetLogicalPresentation().
   *
   * @param w a pointer filled in with the current width.
   * @param h a pointer filled in with the current height.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.GetOutputSize
   */
  void GetCurrentOutputSize(int* w, int* h) const;

  /**
   * Get the properties associated with a renderer.
   *
   * The following read-only properties are provided by SDL:
   *
   * - `prop::Renderer.NAME_STRING`: the name of the rendering driver
   * - `prop::Renderer.WINDOW_POINTER`: the window where rendering is
   *   displayed, if any
   * - `prop::Renderer.SURFACE_POINTER`: the surface where rendering is
   *   displayed, if this is a software renderer without a window
   * - `prop::Renderer.VSYNC_NUMBER`: the current vsync setting
   * - `prop::Renderer.MAX_TEXTURE_SIZE_NUMBER`: the maximum texture width
   *   and height
   * - `prop::Renderer.TEXTURE_FORMATS_POINTER`: a (const PixelFormat *)
   *   array of pixel formats, terminated with PIXELFORMAT_UNKNOWN,
   *   representing the available texture formats for this renderer.
   * - `prop::Renderer.OUTPUT_COLORSPACE_NUMBER`: an Colorspace value
   *   describing the colorspace for output to the display, defaults to
   *   COLORSPACE_SRGB.
   * - `prop::Renderer.HDR_ENABLED_BOOLEAN`: true if the output colorspace is
   *   COLORSPACE_SRGB_LINEAR and the renderer is showing on a display with
   *   HDR enabled. This property can change dynamically when
   *   EVENT_WINDOW_HDR_STATE_CHANGED is sent.
   * - `prop::Renderer.SDR_WHITE_POINT_FLOAT`: the value of SDR white in the
   *   COLORSPACE_SRGB_LINEAR colorspace. When HDR is enabled, this value is
   *   automatically multiplied into the color scale. This property can change
   *   dynamically when EVENT_WINDOW_HDR_STATE_CHANGED is sent.
   * - `prop::Renderer.HDR_HEADROOM_FLOAT`: the additional high dynamic range
   *   that can be displayed, in terms of the SDR white point. When HDR is not
   *   enabled, this will be 1.0. This property can change dynamically when
   *   EVENT_WINDOW_HDR_STATE_CHANGED is sent.
   *
   * With the direct3d renderer:
   *
   * - `prop::Renderer.D3D9_DEVICE_POINTER`: the IDirect3DDevice9 associated
   *   with the renderer
   *
   * With the direct3d11 renderer:
   *
   * - `prop::Renderer.D3D11_DEVICE_POINTER`: the ID3D11Device associated
   *   with the renderer
   * - `prop::Renderer.D3D11_SWAPCHAIN_POINTER`: the IDXGISwapChain1
   *   associated with the renderer. This may change when the window is resized.
   *
   * With the direct3d12 renderer:
   *
   * - `prop::Renderer.D3D12_DEVICE_POINTER`: the ID3D12Device associated
   *   with the renderer
   * - `prop::Renderer.D3D12_SWAPCHAIN_POINTER`: the IDXGISwapChain4
   *   associated with the renderer.
   * - `prop::Renderer.D3D12_COMMAND_QUEUE_POINTER`: the ID3D12CommandQueue
   *   associated with the renderer
   *
   * With the vulkan renderer:
   *
   * - `prop::Renderer.VULKAN_INSTANCE_POINTER`: the VkInstance associated
   *   with the renderer
   * - `prop::Renderer.VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR associated
   *   with the renderer
   * - `prop::Renderer.VULKAN_PHYSICAL_DEVICE_POINTER`: the VkPhysicalDevice
   *   associated with the renderer
   * - `prop::Renderer.VULKAN_DEVICE_POINTER`: the VkDevice associated with
   *   the renderer
   * - `prop::Renderer.VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the queue
   *   family index used for rendering
   * - `prop::Renderer.VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the queue
   *   family index used for presentation
   * - `prop::Renderer.VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER`: the number of
   *   swapchain images, or potential frames in flight, used by the Vulkan
   *   renderer
   *
   * With the gpu renderer:
   *
   * - `prop::Renderer.GPU_DEVICE_POINTER`: the SDL_GPUDevice associated with
   *   the renderer
   *
   * @returns a valid property ID on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  PropertiesRef GetProperties() const;

  /**
   * Set target texture back to window
   *
   * This is equivalent to SetTarget(nullptr)
   *
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa SetTarget(nullptr)
   * @sa GetTarget()
   */
  void ResetTarget() { SetTarget(nullptr); }

  /**
   * Set a texture as the current rendering target.
   *
   * The default render target is the window for which the renderer was created.
   * To stop rendering to a texture and render to the window again, call this
   * function with a nullptr `texture`.
   *
   * Viewport, cliprect, scale, and logical presentation are unique to each
   * render target. Get and set functions for these states apply to the current
   * render target set by this function, and those states persist on each target
   * when the current render target changes.
   *
   * @param texture the targeted texture, which must be created with the
   *                `TEXTUREACCESS_TARGET` flag, or nullptr to render to the
   *                window instead of a texture.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.GetTarget
   */
  void SetTarget(TextureParam texture);

  /**
   * Get the current render target.
   *
   * The default render target is the window for which the renderer was created,
   * and is reported a nullptr here.
   *
   * @returns the current render target or nullptr for the default render
   * target.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.SetTarget
   */
  Texture GetTarget() const;

  /**
   * Set a device-independent resolution and presentation mode for rendering.
   *
   * This function sets the width and height of the logical rendering output.
   * The renderer will act as if the current render target is always the
   * requested dimensions, scaling to the actual resolution as necessary.
   *
   * This can be useful for games that expect a fixed size, but would like to
   * scale the output to whatever is available, regardless of how a user resizes
   * a window, or if the display is high DPI.
   *
   * Logical presentation can be used with both render target textures and the
   * renderer's window; the state is unique to each render target, and this
   * function sets the state for the current render target. It might be useful
   * to draw to a texture that matches the window dimensions with logical
   * presentation enabled, and then draw that texture across the entire window
   * with logical presentation disabled. Be careful not to render both with
   * logical presentation enabled, however, as this could produce
   * double-letterboxing, etc.
   *
   * You can disable logical coordinates by setting the mode to
   * LOGICAL_PRESENTATION_DISABLED, and in that case you get the full pixel
   * resolution of the render target; it is safe to toggle logical presentation
   * during the rendering of a frame: perhaps most of the rendering is done to
   * specific dimensions but to make fonts look sharp, the app turns off logical
   * presentation while drawing text, for example.
   *
   * For the renderer's window, letterboxing is drawn into the framebuffer if
   * logical presentation is enabled during Renderer.Present; be sure to
   * reenable it before presenting if you were toggling it, otherwise the
   * letterbox areas might have artifacts from previous frames (or artifacts
   * from external overlays, etc). Letterboxing is never drawn into texture
   * render targets; be sure to call Renderer.RenderClear() before drawing into
   * the texture so the letterboxing areas are cleared, if appropriate.
   *
   * You can convert coordinates in an event into rendering coordinates using
   * Renderer.ConvertEventToRenderCoordinates().
   *
   * @param size the width and height of the logical resolution.
   * @param mode the presentation mode used.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.ConvertEventToRenderCoordinates
   * @sa Renderer.GetLogicalPresentation
   * @sa Renderer.GetLogicalPresentationRect
   */
  void SetLogicalPresentation(const PointRaw& size,
                              RendererLogicalPresentation mode);

  /**
   * Get device independent resolution and presentation mode for rendering.
   *
   * This function gets the width and height of the logical rendering output, or
   * the output size in pixels if a logical resolution is not enabled.
   *
   * @param size a Point to be filled with the width and height.
   * @param mode the presentation mode used.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.SetLogicalPresentation
   */
  void GetLogicalPresentation(PointRaw* size, RendererLogicalPresentation* mode)
  {
    if (!size) return GetLogicalPresentation(nullptr, nullptr, mode);
    return GetLogicalPresentation(&size->x, &size->y, mode);
  }

  /**
   * Get device independent resolution and presentation mode for rendering.
   *
   * This function gets the width and height of the logical rendering output, or
   * the output size in pixels if a logical resolution is not enabled.
   *
   * Each render target has its own logical presentation state. This function
   * gets the state for the current render target.
   *
   * @param w an int to be filled with the width.
   * @param h an int to be filled with the height.
   * @param mode the presentation mode used.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.SetLogicalPresentation
   */
  void GetLogicalPresentation(int* w,
                              int* h,
                              RendererLogicalPresentation* mode) const;

  /**
   * Get the final presentation rectangle for rendering.
   *
   * This function returns the calculated rectangle used for logical
   * presentation, based on the presentation mode and output size. If logical
   * presentation is disabled, it will fill the rectangle with the output size,
   * in pixels.
   *
   * Each render target has its own logical presentation state. This function
   * gets the rectangle for the current render target.
   *
   * @param rect a pointer filled in with the final presentation rectangle, may
   *             be nullptr.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.SetLogicalPresentation
   */
  FRect GetLogicalPresentationRect() const;

  /**
   * Get a point in render coordinates when given a point in window coordinates.
   *
   * This takes into account several states:
   *
   * - The window dimensions.
   * - The logical presentation settings (Renderer.SetLogicalPresentation)
   * - The scale (Renderer.SetScale)
   * - The viewport (Renderer.SetViewport)
   *
   * @param window_coord the x, y coordinate in window coordinates.
   * @returns a FPoint containing ther render coordinates on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.SetLogicalPresentation
   * @sa Renderer.SetScale
   */
  FPoint RenderCoordinatesFromWindow(const FPointRaw& window_coord) const;

  /**
   * Get a point in window coordinates when given a point in render coordinates.
   *
   * This takes into account several states:
   *
   * - The window dimensions.
   * - The logical presentation settings (RendererRef.SetLogicalPresentation)
   * - The scale (RendererRef.SetScale)
   * - The viewport (RendererRef.SetViewport)
   *
   * @param coord the x, y coordinate in render coordinates.
   * @returns a FPoint filled with window coordinates on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.SetLogicalPresentation
   * @sa Renderer.SetScale
   * @sa Renderer.SetViewport
   */
  FPoint RenderCoordinatesToWindow(const FPointRaw& coord) const;

  /**
   * Convert the coordinates in an event to render coordinates.
   *
   * This takes into account several states:
   *
   * - The window dimensions.
   * - The logical presentation settings (Renderer.SetLogicalPresentation)
   * - The scale (Renderer.SetScale)
   * - The viewport (Renderer.SetViewport)
   *
   * Various event types are converted with this function: mouse, touch, pen,
   * etc.
   *
   * Touch coordinates are converted from normalized coordinates in the window
   * to non-normalized rendering coordinates.
   *
   * Relative mouse coordinates (xrel and yrel event fields) are _also_
   * converted. Applications that do not want these fields converted should use
   * Renderer.RenderCoordinatesFromWindow() on the specific event fields instead
   * of converting the entire event structure.
   *
   * Once converted, coordinates may be outside the rendering area.
   *
   * @param event the event to modify.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.RenderCoordinatesFromWindow
   */
  void ConvertEventToRenderCoordinates(Event* event) const;

  /**
   * Reset the drawing area for rendering to the entire target
   *
   * This is equivalent to `SetViewport(std::nullopt)`
   *
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa GetViewport()
   * @sa SetViewport()
   * @sa ViewportSet()
   */
  void ResetViewport() { SetViewport(std::nullopt); }

  /**
   * Set the drawing area for rendering on the current target.
   *
   * Drawing will clip to this area (separately from any clipping done with
   * Renderer.SetClipRect), and the top left of the area will become coordinate
   * (0, 0) for future drawing commands.
   *
   * The area's width and height must be >= 0.
   *
   * Each render target has its own viewport. This function sets the viewport
   * for the current render target.
   *
   * @param rect the Rect structure representing the drawing area, or nullptr
   *             to set the viewport to the entire target.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.GetViewport
   * @sa Renderer.IsViewportSet
   */
  void SetViewport(OptionalRef<const RectRaw> rect);

  /**
   * Get the drawing area for the current target.
   *
   * Each render target has its own viewport. This function gets the viewport
   * for the current render target.
   *
   * @returns an Rect with the current drawing area.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.IsViewportSet
   * @sa Renderer.SetViewport
   */
  Rect GetViewport() const;

  /**
   * Return whether an explicit rectangle was set as the viewport.
   *
   * This is useful if you're saving and restoring the viewport and want to know
   * whether you should restore a specific rectangle or nullptr.
   *
   * Each render target has its own viewport. This function checks the viewport
   * for the current render target.
   *
   * @returns true if the viewport was set to a specific rectangle, or false if
   *          it was set to nullptr (the entire target).
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.GetViewport
   * @sa Renderer.SetViewport
   */
  bool IsViewportSet() const;

  /**
   * Get the safe area for rendering within the current viewport.
   *
   * Some devices have portions of the screen which are partially obscured or
   * not interactive, possibly due to on-screen controls, curved edges, camera
   * notches, TV overscan, etc. This function provides the area of the current
   * viewport which is safe to have interactible content. You should continue
   * rendering into the rest of the render target, but it should not contain
   * visually important or interactible content.
   *
   * @returns the rect filled the area that is safe for interactive content.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  Rect GetSafeArea() const;

  /**
   * Reset the clip rectangle for rendering to the entire render target
   *
   * This is equivalent to `SetClipRect(std::nullopt)`
   *
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa GetClipRect()
   * @sa SetClipRect()
   * @sa ClipEnabled()
   */
  void ResetClipRect() { SetClipRect({}); }

  /**
   * Set the clip rectangle for rendering on the specified target.
   *
   * Each render target has its own clip rectangle. This function sets the
   * cliprect for the current render target.
   *
   * @param rect an Rect structure representing the clip area, relative to
   *             the viewport, or nullptr to disable clipping.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.GetClipRect
   * @sa Renderer.ResetClipRect()
   * @sa Renderer.IsClipEnabled
   */
  void SetClipRect(OptionalRef<const RectRaw> rect);

  /**
   * Get the clip rectangle for the current target.
   *
   * Each render target has its own clip rectangle. This function gets the
   * cliprect for the current render target.
   *
   * @returns a Rect structure filled in with the current clipping area or an
   *          empty rectangle if clipping is disabled.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.IsClipEnabled
   * @sa Renderer.SetClipRect
   */
  Rect GetClipRect() const;

  /**
   * Get whether clipping is enabled on the given render target.
   *
   * Each render target has its own clip rectangle. This function checks the
   * cliprect for the current render target.
   *
   * @returns true if clipping is enabled or false if not; call GetError()
   *          for more information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.GetClipRect
   * @sa Renderer.SetClipRect
   */
  bool IsClipEnabled() const;

  /**
   * Set the drawing scale for rendering on the current target.
   *
   * The drawing coordinates are scaled by the x/y scaling factors before they
   * are used by the renderer. This allows resolution independent drawing with a
   * single coordinate system.
   *
   * If this results in scaling or subpixel drawing by the rendering backend, it
   * will be handled using the appropriate quality hints. For best results use
   * integer scaling factors.
   *
   * Each render target has its own scale. This function sets the scale for the
   * current render target.
   *
   * @param scale the x, y scaling factors.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.GetScale
   */
  void SetScale(const FPointRaw& scale);

  /**
   * Get the drawing scale for the current target.
   *
   * Each render target has its own scale. This function gets the scale for the
   * current render target.
   *
   * @returns the scaling factors on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.SetScale
   */
  FPoint GetScale() const
  {
    FPoint p;
    GetScale(&p.x, &p.y);
    return p;
  }

  /**
   * Get the drawing scale for the current target.
   *
   * Each render target has its own scale. This function gets the scale for the
   * current render target.
   *
   * @param scaleX a pointer filled in with the horizontal scaling factor.
   * @param scaleY a pointer filled in with the vertical scaling factor.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.SetScale
   */
  void GetScale(float* scaleX, float* scaleY) const;

  /**
   * Set the color used for drawing operations.
   *
   * Set the color for drawing or filling rectangles, lines, and points, and for
   * Renderer.RenderClear().
   *
   * @param c the color value used to draw on the rendering target.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.GetDrawColor
   * @sa Renderer.SetDrawColorFloat
   */
  void SetDrawColor(ColorRaw c);

  /**
   * Set the color used for drawing operations (Rect, Line and Clear).
   *
   * Set the color for drawing or filling rectangles, lines, and points, and for
   * Renderer.RenderClear().
   *
   * @param c the RGBA values used to draw on the rendering target.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.GetDrawColorFloat
   * @sa Renderer.SetDrawColor
   */
  void SetDrawColorFloat(const FColorRaw& c);

  /**
   * Get the color used for drawing operations (Rect, Line and Clear).
   *
   * @param c a pointer filled in with the color channel values used to draw on
   *          the rendering target. @b must @b not be nullptr.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa GetDrawColor(SDL_FColor*)
   * @sa SetDrawColor()
   */
  Color GetDrawColor() const
  {
    Color c;
    GetDrawColor(&c.r, &c.g, &c.b, &c.a);
    return c;
  }

  /**
   * Get the color used for drawing operations (Rect, Line and Clear).
   *
   * @param r a pointer filled in with the red value used to draw on the
   *          rendering target.
   * @param g a pointer filled in with the green value used to draw on the
   *          rendering target.
   * @param b a pointer filled in with the blue value used to draw on the
   *          rendering target.
   * @param a a pointer filled in with the alpha value used to draw on the
   *          rendering target; usually `ALPHA_OPAQUE` (255).
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.GetDrawColorFloat
   * @sa Renderer.SetDrawColor
   */
  void GetDrawColor(Uint8* r, Uint8* g, Uint8* b, Uint8* a) const;

  /**
   * Get the color used for drawing operations (Rect, Line and Clear).
   *
   * @returns the color on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa GetDrawColor(SDL_FColor*)
   * @sa SetDrawColor()
   */
  FColor GetDrawColorFloat() const
  {
    FColor c;
    GetDrawColorFloat(&c.r, &c.g, &c.b, &c.a);
    return c;
  }

  /**
   * Get the color used for drawing operations (Rect, Line and Clear).
   *
   * @param r a pointer filled in with the red value used to draw on the
   *          rendering target.
   * @param g a pointer filled in with the green value used to draw on the
   *          rendering target.
   * @param b a pointer filled in with the blue value used to draw on the
   *          rendering target.
   * @param a a pointer filled in with the alpha value used to draw on the
   *          rendering target.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.SetDrawColorFloat
   * @sa Renderer.GetDrawColor
   */
  void GetDrawColorFloat(float* r, float* g, float* b, float* a) const;

  /**
   * Set the color scale used for render operations.
   *
   * The color scale is an additional scale multiplied into the pixel color
   * value while rendering. This can be used to adjust the brightness of colors
   * during HDR rendering, or changing HDR video brightness when playing on an
   * SDR display.
   *
   * The color scale does not affect the alpha channel, only the color
   * brightness.
   *
   * @param scale the color scale value.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.GetColorScale
   */
  void SetColorScale(float scale);

  /**
   * Get the color scale used for render operations.
   *
   * @returns a float representing the current color scale on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.SetColorScale
   */
  float GetColorScale() const;

  /**
   * Set the blend mode used for drawing operations (Fill and Line).
   *
   * If the blend mode is not supported, the closest supported mode is chosen.
   *
   * @param blendMode the BlendMode to use for blending.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.GetDrawBlendMode
   */
  void SetDrawBlendMode(BlendMode blendMode);

  /**
   * Get the blend mode used for drawing operations.
   *
   * @returns the current BlendMode on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.SetDrawBlendMode
   */
  BlendMode GetDrawBlendMode() const;

  /**
   * Clear the current rendering target with the drawing color.
   *
   * This function clears the entire rendering target, ignoring the viewport and
   * the clip rectangle. Note, that clearing will also set/fill all pixels of
   * the rendering target to current renderer draw color, so make sure to invoke
   * Renderer.SetDrawColor() when needed.
   *
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.SetDrawColor
   */
  void RenderClear();

  /**
   * Draw a point on the current rendering target at subpixel precision.
   *
   * @param p the x, y coordinates of the point.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.RenderPoints
   */
  void RenderPoint(const FPointRaw& p);

  /**
   * Draw multiple points on the current rendering target at subpixel precision.
   *
   * @param points the points to draw.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.RenderPoint
   */
  void RenderPoints(SpanRef<const FPointRaw> points);

  /**
   * Draw a line on the current rendering target at subpixel precision.
   *
   * @param p1 the x,y coordinate of the start point.
   * @param p2 the x,y coordinate of the end point.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.RenderLines
   */
  void RenderLine(const FPointRaw& p1, const FPointRaw& p2);

  /**
   * Draw a series of connected lines on the current rendering target at
   * subpixel precision.
   *
   * @param points the points along the lines.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.RenderLine
   */
  void RenderLines(SpanRef<const FPointRaw> points);

  /**
   * Draw a rectangle on the current rendering target at subpixel precision.
   *
   * @param rect a pointer to the destination rectangle, or std::nullopt to
   *             outline the entire rendering target.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.RenderRects
   */
  void RenderRect(OptionalRef<const FRectRaw> rect);

  /**
   * Draw some number of rectangles on the current rendering target at subpixel
   * precision.
   *
   * @param rects a pointer to an array of destination rectangles.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.RenderRect
   */
  void RenderRects(SpanRef<const FRectRaw> rects);

  /**
   * Fill a rectangle on the current rendering target with the drawing color at
   * subpixel precision.
   *
   * @param rect a pointer to the destination rectangle, or std::nullopt for the
   *             entire rendering target.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.RenderFillRects
   */
  void RenderFillRect(OptionalRef<const FRectRaw> rect);

  /**
   * Fill some number of rectangles on the current rendering target with the
   * drawing color at subpixel precision.
   *
   * @param rects a pointer to an array of destination rectangles.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.RenderFillRect
   */
  void RenderFillRects(SpanRef<const FRectRaw> rects);

  /**
   * Copy a portion of the texture to the current rendering target at subpixel
   * precision.
   *
   * @param texture the source texture.
   * @param srcrect a pointer to the source rectangle, or nullptr for the entire
   *                texture.
   * @param dstrect a pointer to the destination rectangle, or nullptr for the
   *                entire rendering target.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.RenderTextureRotated
   * @sa Renderer.RenderTextureTiled
   */
  void RenderTexture(TextureParam texture,
                     OptionalRef<const FRectRaw> srcrect,
                     OptionalRef<const FRectRaw> dstrect);

  /**
   * Copy a portion of the source texture to the current rendering target, with
   * rotation and flipping, at subpixel precision.
   *
   * @param texture the source texture.
   * @param srcrect a pointer to the source rectangle, or nullptr for the entire
   *                texture.
   * @param dstrect a pointer to the destination rectangle, or nullptr for the
   *                entire rendering target.
   * @param angle an angle in degrees that indicates the rotation that will be
   *              applied to dstrect, rotating it in a clockwise direction.
   * @param center a pointer to a point indicating the point around which
   *               dstrect will be rotated (if nullptr, rotation will be done
   *               around dstrect.w/2, dstrect.h/2).
   * @param flip an FlipMode value stating which flipping actions should be
   *             performed on the texture.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.RenderTexture
   */
  void RenderTextureRotated(TextureParam texture,
                            OptionalRef<const FRectRaw> srcrect,
                            OptionalRef<const FRectRaw> dstrect,
                            double angle,
                            OptionalRef<const FPointRaw> center,
                            FlipMode flip);

  /**
   * Copy a portion of the source texture to the current rendering target, with
   * affine transform, at subpixel precision.
   *
   * @param texture the source texture.
   * @param srcrect a pointer to the source rectangle, or nullptr for the entire
   *                texture.
   * @param origin a pointer to a point indicating where the top-left corner of
   *               srcrect should be mapped to, or nullptr for the rendering
   *               target's origin.
   * @param right a pointer to a point indicating where the top-right corner of
   *              srcrect should be mapped to, or nullptr for the rendering
   *              target's top-right corner.
   * @param down a pointer to a point indicating where the bottom-left corner of
   *             srcrect should be mapped to, or nullptr for the rendering
   * target's bottom-left corner.
   * @throws Error on failure.
   *
   * @threadsafety You may only call this function from the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.RenderTexture
   */
  void RenderTextureAffine(TextureParam texture,
                           OptionalRef<const FRectRaw> srcrect,
                           OptionalRef<const FPointRaw> origin,
                           OptionalRef<const FPointRaw> right,
                           OptionalRef<const FPointRaw> down);

  /**
   * Tile a portion of the texture to the current rendering target at subpixel
   * precision.
   *
   * The pixels in `srcrect` will be repeated as many times as needed to
   * completely fill `dstrect`.
   *
   * @param texture the source texture.
   * @param srcrect a pointer to the source rectangle, or nullptr for the entire
   *                texture.
   * @param scale the scale used to transform srcrect into the destination
   *              rectangle, e.g. a 32x32 texture with a scale of 2 would fill
   *              64x64 tiles.
   * @param dstrect a pointer to the destination rectangle, or nullptr for the
   *                entire rendering target.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.RenderTexture
   */
  void RenderTextureTiled(TextureParam texture,
                          OptionalRef<const FRectRaw> srcrect,
                          float scale,
                          OptionalRef<const FRectRaw> dstrect);

  /**
   * Perform a scaled copy using the 9-grid algorithm to the current rendering
   * target at subpixel precision.
   *
   * The pixels in the texture are split into a 3x3 grid, using the different
   * corner sizes for each corner, and the sides and center making up the
   * remaining pixels. The corners are then scaled using `scale` and fit into
   * the corners of the destination rectangle. The sides and center are then
   * stretched into place to cover the remaining destination rectangle.
   *
   * @param texture the source texture.
   * @param srcrect the Rect structure representing the rectangle to be used
   *                for the 9-grid, or nullptr to use the entire texture.
   * @param left_width the width, in pixels, of the left corners in `srcrect`.
   * @param right_width the width, in pixels, of the right corners in `srcrect`.
   * @param top_height the height, in pixels, of the top corners in `srcrect`.
   * @param bottom_height the height, in pixels, of the bottom corners in
   *                      `srcrect`.
   * @param scale the scale used to transform the corner of `srcrect` into the
   *              corner of `dstrect`, or 0.0f for an unscaled copy.
   * @param dstrect a pointer to the destination rectangle, or nullptr for the
   *                entire rendering target.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.RenderTexture
   */
  void RenderTexture9Grid(TextureParam texture,
                          OptionalRef<const FRectRaw> srcrect,
                          float left_width,
                          float right_width,
                          float top_height,
                          float bottom_height,
                          float scale,
                          OptionalRef<const FRectRaw> dstrect);

  /**
   * Render a list of triangles, optionally using a texture and indices into the
   * vertex array Color and alpha modulation is done per vertex
   * (Texture.SetColorMod and Texture.SetAlphaMod are ignored).
   *
   * @param texture (optional) The SDL texture to use.
   * @param vertices vertices.
   * @param indices (optional) An array of integer indices into the 'vertices'
   *                array, if nullptr all vertices will be rendered in
   *                sequential order.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.RenderGeometryRaw
   */
  void RenderGeometry(TextureParam texture,
                      std::span<const Vertex> vertices,
                      std::span<const int> indices);

  /**
   * Render a list of triangles, optionally using a texture and indices into the
   * vertex arrays Color and alpha modulation is done per vertex
   * (Texture.SetColorMod and Texture.SetAlphaMod are ignored).
   *
   * @param texture (optional) The SDL texture to use.
   * @param xy vertex positions.
   * @param xy_stride byte size to move from one element to the next element.
   * @param color vertex colors (as FColor).
   * @param color_stride byte size to move from one element to the next element.
   * @param uv vertex normalized texture coordinates.
   * @param uv_stride byte size to move from one element to the next element.
   * @param num_vertices number of vertices.
   * @param indices (optional) An array of indices into the 'vertices' arrays,
   *                if nullptr all vertices will be rendered in sequential
   * order.
   * @param num_indices number of indices.
   * @param size_indices index size: 1 (byte), 2 (short), 4 (int).
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.RenderGeometry
   */
  void RenderGeometryRaw(TextureParam texture,
                         const float* xy,
                         int xy_stride,
                         const FColor* color,
                         int color_stride,
                         const float* uv,
                         int uv_stride,
                         int num_vertices,
                         const void* indices,
                         int num_indices,
                         int size_indices);

  /**
   * Read pixels from the current rendering target.
   *
   * The returned surface contains pixels inside the desired area clipped to the
   * current viewport, and should be freed with Surface.Destroy().
   *
   * Note that this returns the actual pixels on the screen, so if you are using
   * logical presentation you should use Renderer.GetLogicalPresentationRect()
   * to get the area containing your content.
   *
   * **WARNING**: This is a very slow operation, and should not be used
   * frequently. If you're using this on the main rendering target, it should be
   * called after rendering and before Renderer.Present().
   *
   * @param rect an Rect structure representing the area to read, which will
   *             be clipped to the current viewport, or nullptr for the entire
   *             viewport.
   * @returns a new Surface on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  Surface ReadPixels(OptionalRef<const RectRaw> rect = {}) const;

  /**
   * Update the screen with any rendering performed since the previous call.
   *
   * SDL's rendering functions operate on a backbuffer; that is, calling a
   * rendering function such as Renderer.RenderLine() does not directly put a
   * line on the screen, but rather updates the backbuffer. As such, you compose
   * your entire scene and *present* the composed backbuffer to the screen as a
   * complete picture.
   *
   * Therefore, when using SDL's rendering API, one does all drawing intended
   * for the frame, and then calls this function once per frame to present the
   * final drawing to the user.
   *
   * The backbuffer should be considered invalidated after each present; do not
   * assume that previous contents will exist between frames. You are strongly
   * encouraged to call Renderer.RenderClear() to initialize the backbuffer
   * before starting each new frame's drawing, even if you plan to overwrite
   * every pixel.
   *
   * Please note, that in case of rendering to a texture - there is **no need**
   * to call `Renderer.Present` after drawing needed objects to a texture, and
   * should not be done; you are only required to change back the rendering
   * target to default via `Renderer.SetTarget(renderer, nullptr)` afterwards,
   * as textures by themselves do not have a concept of backbuffers. Calling
   * Renderer.Present while rendering to a texture will still update the screen
   * with any current drawing that has been done _to the window itself_.
   *
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.Renderer
   * @sa Renderer.RenderClear
   * @sa Renderer.RenderFillRect
   * @sa Renderer.RenderFillRects
   * @sa Renderer.RenderLine
   * @sa Renderer.RenderLines
   * @sa Renderer.RenderPoint
   * @sa Renderer.RenderPoints
   * @sa Renderer.RenderRect
   * @sa Renderer.RenderRects
   * @sa Renderer.SetDrawBlendMode
   * @sa Renderer.SetDrawColor
   */
  void Present();

  /**
   * Force the rendering context to flush any pending commands and state.
   *
   * You do not need to (and in fact, shouldn't) call this function unless you
   * are planning to call into OpenGL/Direct3D/Metal/whatever directly, in
   * addition to using an Renderer.
   *
   * This is for a very-specific case: if you are using SDL's render API, and
   * you plan to make OpenGL/D3D/whatever calls in addition to SDL render API
   * calls. If this applies, you should call this function between calls to
   * SDL's render API and the low-level API you're using in cooperation.
   *
   * In all other cases, you can ignore this function.
   *
   * This call makes SDL flush any pending rendering work it was queueing up to
   * do later in a single batch, and marks any internal cached state as invalid,
   * so it'll prepare all its state again later, from scratch.
   *
   * This means you do not need to save state in your rendering code to protect
   * the SDL renderer. However, there lots of arbitrary pieces of Direct3D and
   * OpenGL state that can confuse things; you should use your best judgment and
   * be prepared to make changes if specific state needs to be protected.
   *
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void Flush();

  /**
   * Toggle VSync of the given renderer.
   *
   * When a renderer is created, vsync defaults to SDL_RENDERER_VSYNC_DISABLED.
   *
   * The `vsync` parameter can be 1 to synchronize present with every vertical
   * refresh, 2 to synchronize present with every second vertical refresh, etc.,
   * SDL_RENDERER_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync), or
   * SDL_RENDERER_VSYNC_DISABLED to disable. Not every value is supported by
   * every driver, so you should check the return value to see whether the
   * requested setting is supported.
   *
   * @param vsync the vertical refresh sync interval.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.GetVSync
   */
  void SetVSync(int vsync);

  /**
   * Get VSync of the given renderer.
   *
   * @returns the current vertical refresh sync interval on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.SetVSync
   */
  int GetVSync() const;

  /**
   * Draw debug text to an Renderer.
   *
   * This function will render a string of text to an Renderer. Note that
   * this is a convenience function for debugging, with severe limitations, and
   * not intended to be used for production apps and games.
   *
   * Among these limitations:
   *
   * - It accepts UTF-8 strings, but will only renders ASCII characters.
   * - It has a single, tiny size (8x8 pixels). One can use logical presentation
   *   or scaling to adjust it, but it will be blurry.
   * - It uses a simple, hardcoded bitmap font. It does not allow different font
   *   selections and it does not support truetype, for proper scaling.
   * - It does no word-wrapping and does not treat newline characters as a line
   *   break. If the text goes out of the window, it's gone.
   *
   * For serious text rendering, there are several good options, such as
   * SDL_ttf, stb_truetype, or other external libraries.
   *
   * On first use, this will create an internal texture for rendering glyphs.
   * This texture will live until the renderer is destroyed.
   *
   * The text is drawn in the color specified by Renderer.SetDrawColor().
   *
   * @param p the x, y coordinates where the top-left corner of the text will
   *          draw.
   * @param str the string to render.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.RenderDebugTextFormat
   * @sa SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE
   */
  void RenderDebugText(FPoint p, StringParam str);

  /**
   * Draw debug text to an Renderer.
   *
   * This function will render a std::format()-style format string to a
   * renderer. Note that this is a convenience function for debugging, with
   * severe limitations, and is not intended to be used for production apps and
   * games.
   *
   * For the full list of limitations and other useful information, see
   * Renderer.RenderDebugText.
   *
   * @param p the x, y coordinates where the top-left corner of the text will
   *          draw.
   * @param fmt the format string to draw.
   * @param args additional parameters matching {} tokens in the `fmt` string,
   *             if any.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.RenderDebugText
   * @sa SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE
   */
  template<class... ARGS>
  void RenderDebugTextFormat(FPoint p, std::string_view fmt, ARGS... args)
  {
    RenderDebugText(p, std::vformat(fmt, std::make_format_args(args...)));
  }

  /**
   * Create a texture for a rendering context.
   *
   * The contents of a texture when first created are not defined.
   *
   * @param format one of the enumerated values in PixelFormat.
   * @param access one of the enumerated values in TextureAccess.
   * @param w the width of the texture in pixels.
   * @param h the height of the texture in pixels.
   * @returns the created texture or nullptr on failure; call GetError() for
   *          more information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.Texture
   * @sa Texture.Texture
   * @sa Texture.Destroy
   * @sa Texture.GetSize
   * @sa Texture.Update
   */
  Texture CreateTexture(PixelFormat format,
                        TextureAccess access,
                        const PointRaw& size);

  /**
   * Create a texture from an existing surface.
   *
   * The surface is not modified or freed by this function.
   *
   * The TextureAccess hint for the created texture is
   * `TEXTUREACCESS_STATIC`.
   *
   * The pixel format of the created texture may be different from the pixel
   * format of the surface, and can be queried using the
   * prop::Texture.FORMAT_NUMBER property.
   *
   * @param surface the Surface structure containing pixel data used to fill
   *                the texture.
   * @returns the created texture or nullptr on failure; call GetError() for
   *          more information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.Texture
   * @sa Texture.Texture
   * @sa Texture.Destroy
   */
  Texture CreateTextureFromSurface(SurfaceParam surface);

  /**
   * Create a texture for a rendering context with the specified properties.
   *
   * These are the supported properties:
   *
   * - `prop::Texture.CREATE_COLORSPACE_NUMBER`: an Colorspace value
   *   describing the texture colorspace, defaults to COLORSPACE_SRGB_LINEAR
   *   for floating point textures, COLORSPACE_HDR10 for 10-bit textures,
   *   COLORSPACE_SRGB for other RGB textures and COLORSPACE_JPEG for
   *   YUV textures.
   * - `prop::Texture.CREATE_FORMAT_NUMBER`: one of the enumerated values in
   *   PixelFormat, defaults to the best RGBA format for the renderer
   * - `prop::Texture.CREATE_ACCESS_NUMBER`: one of the enumerated values in
   *   TextureAccess, defaults to TEXTUREACCESS_STATIC
   * - `prop::Texture.CREATE_WIDTH_NUMBER`: the width of the texture in
   *   pixels, required
   * - `prop::Texture.CREATE_HEIGHT_NUMBER`: the height of the texture in
   *   pixels, required
   * - `prop::Texture.CREATE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating
   *   point textures, this defines the value of 100% diffuse white, with higher
   *   values being displayed in the High Dynamic Range headroom. This defaults
   *   to 100 for HDR10 textures and 1.0 for floating point textures.
   * - `prop::Texture.CREATE_HDR_HEADROOM_FLOAT`: for HDR10 and floating
   *   point textures, this defines the maximum dynamic range used by the
   *   content, in terms of the SDR white point. This would be equivalent to
   *   maxCLL / prop::Texture.CREATE_SDR_WHITE_POINT_FLOAT for HDR10 content.
   *   If this is defined, any values outside the range supported by the display
   *   will be scaled into the available HDR headroom, otherwise they are
   *   clipped.
   *
   * With the direct3d11 renderer:
   *
   * - `prop::Texture.CREATE_D3D11_TEXTURE_POINTER`: the ID3D11Texture2D
   *   associated with the texture, if you want to wrap an existing texture.
   * - `prop::Texture.CREATE_D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D
   *   associated with the U plane of a YUV texture, if you want to wrap an
   *   existing texture.
   * - `prop::Texture.CREATE_D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D
   *   associated with the V plane of a YUV texture, if you want to wrap an
   *   existing texture.
   *
   * With the direct3d12 renderer:
   *
   * - `prop::Texture.CREATE_D3D12_TEXTURE_POINTER`: the ID3D12Resource
   *   associated with the texture, if you want to wrap an existing texture.
   * - `prop::Texture.CREATE_D3D12_TEXTURE_U_POINTER`: the ID3D12Resource
   *   associated with the U plane of a YUV texture, if you want to wrap an
   *   existing texture.
   * - `prop::Texture.CREATE_D3D12_TEXTURE_V_POINTER`: the ID3D12Resource
   *   associated with the V plane of a YUV texture, if you want to wrap an
   *   existing texture.
   *
   * With the metal renderer:
   *
   * - `prop::Texture.CREATE_METAL_PIXELBUFFER_POINTER`: the CVPixelBufferRef
   *   associated with the texture, if you want to create a texture from an
   *   existing pixel buffer.
   *
   * With the opengl renderer:
   *
   * - `prop::Texture.CREATE_OPENGL_TEXTURE_NUMBER`: the GLuint texture
   *   associated with the texture, if you want to wrap an existing texture.
   * - `prop::Texture.CREATE_OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture
   *   associated with the UV plane of an NV12 texture, if you want to wrap an
   *   existing texture.
   * - `prop::Texture.CREATE_OPENGL_TEXTURE_U_NUMBER`: the GLuint texture
   *   associated with the U plane of a YUV texture, if you want to wrap an
   *   existing texture.
   * - `prop::Texture.CREATE_OPENGL_TEXTURE_V_NUMBER`: the GLuint texture
   *   associated with the V plane of a YUV texture, if you want to wrap an
   *   existing texture.
   *
   * With the opengles2 renderer:
   *
   * - `prop::Texture.CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture
   *   associated with the texture, if you want to wrap an existing texture.
   * - `prop::Texture.CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture
   *   associated with the texture, if you want to wrap an existing texture.
   * - `prop::Texture.CREATE_OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture
   *   associated with the UV plane of an NV12 texture, if you want to wrap an
   *   existing texture.
   * - `prop::Texture.CREATE_OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture
   *   associated with the U plane of a YUV texture, if you want to wrap an
   *   existing texture.
   * - `prop::Texture.CREATE_OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture
   *   associated with the V plane of a YUV texture, if you want to wrap an
   *   existing texture.
   *
   * With the vulkan renderer:
   *
   * - `prop::Texture.CREATE_VULKAN_TEXTURE_NUMBER`: the VkImage with layout
   *   VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL associated with the texture, if
   *   you want to wrap an existing texture.
   *
   * @param props the properties to use.
   * @returns the created texture or nullptr on failure; call GetError() for
   *          more information.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Properties.Create
   * @sa Texture.Texture
   * @sa Texture.Texture
   * @sa Texture.Destroy
   * @sa Texture.GetSize
   * @sa Texture.Update
   */
  Texture CreateTextureWithProperties(PropertiesParam props);

  /**
   * Get the CAMetalLayer associated with the given Metal renderer.
   *
   * This function returns `void *`, so SDL doesn't have to include Metal's
   * headers, but it can be safely cast to a `CAMetalLayer *`.
   *
   * @returns a `CAMetalLayer *` on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.GetRenderMetalCommandEncoder
   */
  void* GetRenderMetalLayer();

  /**
   * Get the Metal command encoder for the current frame.
   *
   * This function returns `void *`, so SDL doesn't have to include Metal's
   * headers, but it can be safely cast to an `id<MTLRenderCommandEncoder>`.
   *
   * This will return nullptr if Metal refuses to give SDL a drawable to render
   * to, which might happen if the window is hidden/minimized/offscreen. This
   * doesn't apply to command encoders for render targets, just the window's
   * backbuffer. Check your return values!
   *
   * @returns an `id<MTLRenderCommandEncoder>` on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Renderer.GetRenderMetalLayer
   */
  void* GetRenderMetalCommandEncoder();

  /**
   * Add a set of synchronization semaphores for the current frame.
   *
   * The Vulkan renderer will wait for `wait_semaphore` before submitting
   * rendering commands and signal `signal_semaphore` after rendering commands
   * are complete for this frame.
   *
   * This should be called each frame that you want semaphore synchronization.
   * The Vulkan renderer may have multiple frames in flight on the GPU, so you
   * should have multiple semaphores that are used for synchronization. Querying
   * prop::Renderer.VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER will give you the
   * maximum number of semaphores you'll need.
   *
   * @param wait_stage_mask the VkPipelineStageFlags for the wait.
   * @param wait_semaphore a VkSempahore to wait on before rendering the current
   *                       frame, or 0 if not needed.
   * @param signal_semaphore a VkSempahore that SDL will signal when rendering
   *                         for the current frame is complete, or 0 if not
   *                         needed.
   * @throws Error on failure.
   *
   * @threadsafety It is **NOT** safe to call this function from two threads at
   *               once.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void AddVulkanRenderSemaphores(Uint32 wait_stage_mask,
                                 Sint64 wait_semaphore,
                                 Sint64 signal_semaphore);
};

/// Semi-safe reference for Renderer.
struct RendererRef : Renderer
{
  /**
   * Constructs from RendererParam.
   *
   * @param resource a RendererRaw or Renderer.
   *
   * This does not takes ownership!
   */
  RendererRef(RendererParam resource)
    : Renderer(resource.value)
  {
  }

  /// Copy constructor.
  RendererRef(const RendererRef& other)
    : Renderer(other.get())
  {
  }

  /// Destructor
  ~RendererRef() { release(); }
};

/**
 * An efficient driver-specific representation of pixel data
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @sa Texture.Texture
 * @sa Texture.Texture
 * @sa Texture.Texture
 * @sa Texture.Destroy
 *
 * @cat resource
 */
class Texture
{
  TextureRaw m_resource = nullptr;

public:
  /// Default ctor
  constexpr Texture() = default;

  /**
   * Constructs from TextureParam.
   *
   * @param resource a TextureRaw to be wrapped.
   *
   * This assumes the ownership, call release() if you need to take back.
   */
  constexpr explicit Texture(const TextureRaw resource)
    : m_resource(resource)
  {
  }

  /// Copy constructor
  constexpr Texture(const Texture& other) { ++m_resource->refcount; }

  /// Move constructor
  constexpr Texture(Texture&& other)
    : Texture(other.release())
  {
  }

  /**
   * Create a texture for a rendering context.
   *
   * The contents of a texture when first created are not defined.
   *
   * @param renderer the rendering context.
   * @param format one of the enumerated values in PixelFormat.
   * @param access one of the enumerated values in TextureAccess.
   * @param size the width and height of the texture in pixels.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.Texture
   * @sa Texture.Texture
   * @sa Texture.Destroy
   * @sa Texture.GetSize
   * @sa Texture.Update
   */
  Texture(RendererParam renderer,
          PixelFormat format,
          TextureAccess access,
          const PointRaw& size)
    : m_resource(
        CheckError(SDL_CreateTexture(renderer, format, access, size.x, size.y)))
  {
  }

  /**
   * Create a texture from an existing surface.
   *
   * The surface is not modified or freed by this function.
   *
   * The TextureAccess hint for the created texture is
   * `TEXTUREACCESS_STATIC`.
   *
   * The pixel format of the created texture may be different from the pixel
   * format of the surface, and can be queried using the
   * prop::Texture.FORMAT_NUMBER property.
   *
   * @param renderer the rendering context.
   * @param surface the Surface structure containing pixel data used to fill
   *                the texture.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.Texture
   * @sa Texture.Destroy
   */
  Texture(RendererParam renderer, SurfaceParam surface)
    : m_resource(CheckError(SDL_CreateTextureFromSurface(renderer, surface)))
  {
  }

  /**
   * Create a texture for a rendering context with the specified properties.
   *
   * These are the supported properties:
   *
   * - `prop::Texture.CREATE_COLORSPACE_NUMBER`: an Colorspace value
   *   describing the texture colorspace, defaults to COLORSPACE_SRGB_LINEAR
   *   for floating point textures, COLORSPACE_HDR10 for 10-bit textures,
   *   COLORSPACE_SRGB for other RGB textures and COLORSPACE_JPEG for
   *   YUV textures.
   * - `prop::Texture.CREATE_FORMAT_NUMBER`: one of the enumerated values in
   *   PixelFormat, defaults to the best RGBA format for the renderer
   * - `prop::Texture.CREATE_ACCESS_NUMBER`: one of the enumerated values in
   *   TextureAccess, defaults to TEXTUREACCESS_STATIC
   * - `prop::Texture.CREATE_WIDTH_NUMBER`: the width of the texture in
   *   pixels, required
   * - `prop::Texture.CREATE_HEIGHT_NUMBER`: the height of the texture in
   *   pixels, required
   * - `prop::Texture.CREATE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating
   *   point textures, this defines the value of 100% diffuse white, with higher
   *   values being displayed in the High Dynamic Range headroom. This defaults
   *   to 100 for HDR10 textures and 1.0 for floating point textures.
   * - `prop::Texture.CREATE_HDR_HEADROOM_FLOAT`: for HDR10 and floating
   *   point textures, this defines the maximum dynamic range used by the
   *   content, in terms of the SDR white point. This would be equivalent to
   *   maxCLL / prop::Texture.CREATE_SDR_WHITE_POINT_FLOAT for HDR10 content.
   *   If this is defined, any values outside the range supported by the display
   *   will be scaled into the available HDR headroom, otherwise they are
   *   clipped.
   *
   * With the direct3d11 renderer:
   *
   * - `prop::Texture.CREATE_D3D11_TEXTURE_POINTER`: the ID3D11Texture2D
   *   associated with the texture, if you want to wrap an existing texture.
   * - `prop::Texture.CREATE_D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D
   *   associated with the U plane of a YUV texture, if you want to wrap an
   *   existing texture.
   * - `prop::Texture.CREATE_D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D
   *   associated with the V plane of a YUV texture, if you want to wrap an
   *   existing texture.
   *
   * With the direct3d12 renderer:
   *
   * - `prop::Texture.CREATE_D3D12_TEXTURE_POINTER`: the ID3D12Resource
   *   associated with the texture, if you want to wrap an existing texture.
   * - `prop::Texture.CREATE_D3D12_TEXTURE_U_POINTER`: the ID3D12Resource
   *   associated with the U plane of a YUV texture, if you want to wrap an
   *   existing texture.
   * - `prop::Texture.CREATE_D3D12_TEXTURE_V_POINTER`: the ID3D12Resource
   *   associated with the V plane of a YUV texture, if you want to wrap an
   *   existing texture.
   *
   * With the metal renderer:
   *
   * - `prop::Texture.CREATE_METAL_PIXELBUFFER_POINTER`: the CVPixelBufferRef
   *   associated with the texture, if you want to create a texture from an
   *   existing pixel buffer.
   *
   * With the opengl renderer:
   *
   * - `prop::Texture.CREATE_OPENGL_TEXTURE_NUMBER`: the GLuint texture
   *   associated with the texture, if you want to wrap an existing texture.
   * - `prop::Texture.CREATE_OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture
   *   associated with the UV plane of an NV12 texture, if you want to wrap an
   *   existing texture.
   * - `prop::Texture.CREATE_OPENGL_TEXTURE_U_NUMBER`: the GLuint texture
   *   associated with the U plane of a YUV texture, if you want to wrap an
   *   existing texture.
   * - `prop::Texture.CREATE_OPENGL_TEXTURE_V_NUMBER`: the GLuint texture
   *   associated with the V plane of a YUV texture, if you want to wrap an
   *   existing texture.
   *
   * With the opengles2 renderer:
   *
   * - `prop::Texture.CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture
   *   associated with the texture, if you want to wrap an existing texture.
   * - `prop::Texture.CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture
   *   associated with the texture, if you want to wrap an existing texture.
   * - `prop::Texture.CREATE_OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture
   *   associated with the UV plane of an NV12 texture, if you want to wrap an
   *   existing texture.
   * - `prop::Texture.CREATE_OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture
   *   associated with the U plane of a YUV texture, if you want to wrap an
   *   existing texture.
   * - `prop::Texture.CREATE_OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture
   *   associated with the V plane of a YUV texture, if you want to wrap an
   *   existing texture.
   *
   * With the vulkan renderer:
   *
   * - `prop::Texture.CREATE_VULKAN_TEXTURE_NUMBER`: the VkImage with layout
   *   VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL associated with the texture, if
   *   you want to wrap an existing texture.
   *
   * @param renderer the rendering context.
   * @param props the properties to use.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Properties.Create
   * @sa Texture.Texture
   * @sa Texture.Texture
   * @sa Texture.Destroy
   * @sa Texture.GetSize
   * @sa Texture.Update
   */
  Texture(RendererParam renderer, PropertiesParam props)
    : m_resource(CheckError(SDL_CreateTextureWithProperties(renderer, props)))
  {
  }

  /**
   * Load an image from a filesystem path into a GPU texture.
   *
   * An Texture represents an image in GPU memory, usable by SDL's 2D Render
   * API. This can be significantly more efficient than using a CPU-bound
   * Surface if you don't need to manipulate the image directly after
   * loading it.
   *
   * If the loaded image has transparency or a colorkey, a texture with an alpha
   * channel will be created. Otherwise, SDL_image will attempt to create an
   * Texture in the most format that most reasonably represents the image
   * data (but in many cases, this will just end up being 32-bit RGB or 32-bit
   * RGBA).
   *
   * There is a separate function to read files from an IOStream, if you
   * need an i/o abstraction to provide data from anywhere instead of a simple
   * filesystem read; that function is Texture.Texture().
   *
   * If you would rather decode an image to an Surface (a buffer of pixels
   * in CPU memory), call Surface.Surface() instead.
   *
   * @param renderer the Renderer to use to create the GPU texture.
   * @param file a path on the filesystem to load an image from.
   * @post a new texture, or nullptr on error.
   *
   * @since This function is available since SDL_image 3.0.0.
   *
   * @sa LoadTextureTyped
   * @sa Texture.Texture
   */
  Texture(RendererParam renderer, StringParam file);

  /**
   * Load an image from an SDL data source into a GPU texture.
   *
   * An Texture represents an image in GPU memory, usable by SDL's 2D Render
   * API. This can be significantly more efficient than using a CPU-bound
   * Surface if you don't need to manipulate the image directly after
   * loading it.
   *
   * If the loaded image has transparency or a colorkey, a texture with an alpha
   * channel will be created. Otherwise, SDL_image will attempt to create an
   * Texture in the most format that most reasonably represents the image
   * data (but in many cases, this will just end up being 32-bit RGB or 32-bit
   * RGBA).
   *
   * If `closeio` is true, `src` will be closed before returning, whether this
   * function succeeds or not. SDL_image reads everything it needs from `src`
   * during this call in any case.
   *
   * There is a separate function to read files from disk without having to deal
   * with IOStream: `Texture.Texture(renderer, "filename.jpg")` will call
   * this function and manage those details for you, determining the file type
   * from the filename's extension.
   *
   * There is also LoadTextureTyped(), which is equivalent to this
   * function except a file extension (like "BMP", "JPG", etc) can be specified,
   * in case SDL_image cannot autodetect the file format.
   *
   * If you would rather decode an image to an Surface (a buffer of pixels
   * in CPU memory), call Surface.Surface() instead.
   *
   * @param renderer the Renderer to use to create the GPU texture.
   * @param src an IOStream that data will be read from.
   * @param closeio true to close/free the IOStream before returning, false
   *                to leave it open.
   * @post a new texture, or nullptr on error.
   *
   * @since This function is available since SDL_image 3.0.0.
   *
   * @sa Texture.Texture
   * @sa LoadTextureTyped
   * @sa Texture.Destroy
   */
  Texture(RendererParam renderer, IOStreamParam src, bool closeio = false);

  /**
   * Safely borrows the from TextureParam.
   *
   * @param resource a TextureRaw or Texture.
   *
   * This does not takes ownership!
   */
  static constexpr Texture Borrow(TextureParam resource)
  {
    ++resource.value->refcount;
    return Texture(resource.value);
  }

  /// Destructor
  ~Texture() { SDL_DestroyTexture(m_resource); }

  /// Assignment operator.
  Texture& operator=(Texture other)
  {
    std::swap(m_resource, other.m_resource);
    return *this;
  }

  /// Retrieves underlying TextureRaw.
  constexpr TextureRaw get() const { return m_resource; }

  /// Retrieves underlying TextureRaw and clear this.
  constexpr TextureRaw release()
  {
    auto r = m_resource;
    m_resource = nullptr;
    return r;
  }

  /// Comparison
  constexpr auto operator<=>(const Texture& other) const = default;

  /// Comparison
  constexpr bool operator==(std::nullptr_t _) const { return !m_resource; }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!m_resource; }

  /// Converts to TextureParam
  constexpr operator TextureParam() const { return {m_resource}; }

  /**
   * Destroy the specified texture.
   *
   * Passing nullptr or an otherwise invalid texture will set the SDL error
   * message to "Invalid texture".
   *
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.Texture
   * @sa Texture.Texture
   */
  void Destroy();

  /**
   * Get the properties associated with a texture.
   *
   * The following read-only properties are provided by SDL:
   *
   * - `prop::Texture.COLORSPACE_NUMBER`: an Colorspace value describing
   *   the texture colorspace.
   * - `prop::Texture.FORMAT_NUMBER`: one of the enumerated values in
   *   PixelFormat.
   * - `prop::Texture.ACCESS_NUMBER`: one of the enumerated values in
   *   TextureAccess.
   * - `prop::Texture.WIDTH_NUMBER`: the width of the texture in pixels.
   * - `prop::Texture.HEIGHT_NUMBER`: the height of the texture in pixels.
   * - `prop::Texture.SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point
   *   textures, this defines the value of 100% diffuse white, with higher
   *   values being displayed in the High Dynamic Range headroom. This defaults
   *   to 100 for HDR10 textures and 1.0 for other textures.
   * - `prop::Texture.HDR_HEADROOM_FLOAT`: for HDR10 and floating point
   *   textures, this defines the maximum dynamic range used by the content, in
   *   terms of the SDR white point. If this is defined, any values outside the
   *   range supported by the display will be scaled into the available HDR
   *   headroom, otherwise they are clipped. This defaults to 1.0 for SDR
   *   textures, 4.0 for HDR10 textures, and no default for floating point
   *   textures.
   *
   * With the direct3d11 renderer:
   *
   * - `prop::Texture.D3D11_TEXTURE_POINTER`: the ID3D11Texture2D associated
   *   with the texture
   * - `prop::Texture.D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D
   *   associated with the U plane of a YUV texture
   * - `prop::Texture.D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D
   *   associated with the V plane of a YUV texture
   *
   * With the direct3d12 renderer:
   *
   * - `prop::Texture.D3D12_TEXTURE_POINTER`: the ID3D12Resource associated
   *   with the texture
   * - `prop::Texture.D3D12_TEXTURE_U_POINTER`: the ID3D12Resource associated
   *   with the U plane of a YUV texture
   * - `prop::Texture.D3D12_TEXTURE_V_POINTER`: the ID3D12Resource associated
   *   with the V plane of a YUV texture
   *
   * With the vulkan renderer:
   *
   * - `prop::Texture.VULKAN_TEXTURE_NUMBER`: the VkImage associated with the
   *   texture
   *
   * With the opengl renderer:
   *
   * - `prop::Texture.OPENGL_TEXTURE_NUMBER`: the GLuint texture associated
   *   with the texture
   * - `prop::Texture.OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture
   *   associated with the UV plane of an NV12 texture
   * - `prop::Texture.OPENGL_TEXTURE_U_NUMBER`: the GLuint texture associated
   *   with the U plane of a YUV texture
   * - `prop::Texture.OPENGL_TEXTURE_V_NUMBER`: the GLuint texture associated
   *   with the V plane of a YUV texture
   * - `prop::Texture.OPENGL_TEXTURE_TARGET_NUMBER`: the GLenum for the
   *   texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE_ARB`, etc)
   * - `prop::Texture.OPENGL_TEX_W_FLOAT`: the texture coordinate width of
   *   the texture (0.0 - 1.0)
   * - `prop::Texture.OPENGL_TEX_H_FLOAT`: the texture coordinate height of
   *   the texture (0.0 - 1.0)
   *
   * With the opengles2 renderer:
   *
   * - `prop::Texture.OPENGLES2_TEXTURE_NUMBER`: the GLuint texture
   *   associated with the texture
   * - `prop::Texture.OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture
   *   associated with the UV plane of an NV12 texture
   * - `prop::Texture.OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture
   *   associated with the U plane of a YUV texture
   * - `prop::Texture.OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture
   *   associated with the V plane of a YUV texture
   * - `prop::Texture.OPENGLES2_TEXTURE_TARGET_NUMBER`: the GLenum for the
   *   texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_EXTERNAL_OES`, etc)
   *
   * @returns a valid property ID on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  PropertiesRef GetProperties() const;

  /**
   * Get the renderer that created an Texture.
   *
   * @returns a pointer to the Renderer that created the texture, or nullptr on
   *          failure; call GetError() for more information.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  RendererRef GetRenderer() const;

  /**
   * Set an additional color and alpha values multiplied into render copy
   * operations.
   *
   * When this texture is rendered, during the copy operation each source color
   * and alpha channels are modulated by the appropriate color value according
   * to the following formula:
   *
   *      srcC = srcC * (color / 255)
   *      srcA = srcA * (alpha / 255)
   *
   * Color and alpha modulation is not always supported by the renderer; it will
   * return false if either modulation is not supported.
   *
   * @param c the color and alpha channel values multiplied into copy
   *          operations.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void SetMod(Color c)
  {
    SetColorMod(c.r, c.g, c.b);
    SetAlphaMod(c.a);
  }

  /**
   * Set an additional color and alpha values multiplied into render copy
   * operations.
   *
   * When this texture is rendered, during the copy operation each source color
   * and alpha channels are modulated by the appropriate color value according
   * to the following formula:
   *
   *      srcC = srcC * (color / 255)
   *      srcA = srcA * (alpha / 255)
   *
   * Color and alpha modulation is not always supported by the renderer; it will
   * return false if either modulation is not supported.
   *
   * @param c the color and alpha channel values multiplied into copy
   *          operations.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void SetModFloat(FColor c)
  {
    SetColorMod(c.r, c.g, c.b);
    SetAlphaMod(c.a);
  }

  /**
   * Get the additional color value multiplied into render copy operations.
   *
   * @returns the color channels (0-1) on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa GetAlphaMod()
   * @sa SetColorMod()
   */
  Color GetMod() const
  {
    Color c;
    GetColorMod(&c.r, &c.g, &c.b);
    c.a = GetAlphaMod();
    return c;
  }

  /**
   * Get the additional color value multiplied into render copy operations.
   *
   * @returns the color channels (0-1) on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa GetAlphaMod()
   * @sa SetColorMod()
   */
  FColor GetModFloat() const
  {
    FColor c;
    GetColorModFloat(&c.r, &c.g, &c.b);
    c.a = GetAlphaModFloat();
    return c;
  }

  /**
   * Set an additional color value multiplied into render copy operations.
   *
   * When this texture is rendered, during the copy operation each source color
   * channel is modulated by the appropriate color value according to the
   * following formula:
   *
   * `srcC = srcC * (color / 255)`
   *
   * Color modulation is not always supported by the renderer; it will return
   * false if color modulation is not supported.
   *
   * @param r the red color value multiplied into copy operations.
   * @param g the green color value multiplied into copy operations.
   * @param b the blue color value multiplied into copy operations.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.GetColorMod
   * @sa Texture.SetAlphaMod
   * @sa Texture.SetColorModFloat
   */
  void SetColorMod(Uint8 r, Uint8 g, Uint8 b);

  /**
   * Set an additional color value multiplied into render copy operations.
   *
   * When this texture is rendered, during the copy operation each source color
   * channel is modulated by the appropriate color value according to the
   * following formula:
   *
   * `srcC = srcC * color`
   *
   * Color modulation is not always supported by the renderer; it will return
   * false if color modulation is not supported.
   *
   * @param r the red color value multiplied into copy operations.
   * @param g the green color value multiplied into copy operations.
   * @param b the blue color value multiplied into copy operations.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.GetColorModFloat
   * @sa Texture.SetAlphaModFloat
   * @sa Texture.SetColorMod
   */
  void SetColorModFloat(float r, float g, float b);

  /**
   * Get the additional color value multiplied into render copy operations.
   *
   * @param r a pointer filled in with the current red color value.
   * @param g a pointer filled in with the current green color value.
   * @param b a pointer filled in with the current blue color value.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.GetAlphaMod
   * @sa Texture.GetColorModFloat
   * @sa Texture.SetColorMod
   */
  void GetColorMod(Uint8* r, Uint8* g, Uint8* b) const;

  /**
   * Get the additional color value multiplied into render copy operations.
   *
   * @param r a pointer filled in with the current red color value.
   * @param g a pointer filled in with the current green color value.
   * @param b a pointer filled in with the current blue color value.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.GetAlphaModFloat
   * @sa Texture.GetColorMod
   * @sa Texture.SetColorModFloat
   */
  void GetColorModFloat(float* r, float* g, float* b) const;

  /**
   * Set an additional alpha value multiplied into render copy operations.
   *
   * When this texture is rendered, during the copy operation the source alpha
   * value is modulated by this alpha value according to the following formula:
   *
   * `srcA = srcA * (alpha / 255)`
   *
   * Alpha modulation is not always supported by the renderer; it will return
   * false if alpha modulation is not supported.
   *
   * @param alpha the source alpha value multiplied into copy operations.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.GetAlphaMod
   * @sa Texture.SetAlphaModFloat
   * @sa Texture.SetColorMod
   */
  void SetAlphaMod(Uint8 alpha);

  /**
   * Set an additional alpha value multiplied into render copy operations.
   *
   * When this texture is rendered, during the copy operation the source alpha
   * value is modulated by this alpha value according to the following formula:
   *
   * `srcA = srcA * alpha`
   *
   * Alpha modulation is not always supported by the renderer; it will return
   * false if alpha modulation is not supported.
   *
   * @param alpha the source alpha value multiplied into copy operations.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.GetAlphaModFloat
   * @sa Texture.SetAlphaMod
   * @sa Texture.SetColorModFloat
   */
  void SetAlphaModFloat(float alpha);

  /**
   * Get the additional alpha value multiplied into render copy operations.
   *
   * @param alpha a pointer filled in with the current alpha value.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.GetAlphaModFloat
   * @sa Texture.GetColorMod
   * @sa Texture.SetAlphaMod
   */
  Uint8 GetAlphaMod() const;

  /**
   * Get the additional alpha value multiplied into render copy operations.
   *
   * @param alpha a pointer filled in with the current alpha value.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.GetAlphaMod
   * @sa Texture.GetColorModFloat
   * @sa Texture.SetAlphaModFloat
   */
  float GetAlphaModFloat() const;

  /**
   * Set the blend mode for a texture, used by Renderer.RenderTexture().
   *
   * If the blend mode is not supported, the closest supported mode is chosen
   * and this function returns false.
   *
   * @param blendMode the BlendMode to use for texture blending.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.GetBlendMode
   */
  void SetBlendMode(BlendMode blendMode);

  /**
   * Get the blend mode used for texture copy operations.
   *
   * @returns the current SDL_BlendMode on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.SetBlendMode
   */
  BlendMode GetBlendMode() const;

  /**
   * Set the scale mode used for texture scale operations.
   *
   * The default texture scale mode is SCALEMODE_LINEAR.
   *
   * If the scale mode is not supported, the closest supported mode is chosen.
   *
   * @param scaleMode the ScaleMode to use for texture scaling.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.GetScaleMode
   */
  void SetScaleMode(ScaleMode scaleMode);

  /**
   * Get the scale mode used for texture scale operations.
   *
   * @returns the current scale mode on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.SetScaleMode
   */
  ScaleMode GetScaleMode() const;

  /**
   * Update the given texture rectangle with new pixel data.
   *
   * The pixel data must be in the pixel format of the texture, which can be
   * queried using the prop::Texture.FORMAT_NUMBER property.
   *
   * This is a fairly slow function, intended for use with static textures that
   * do not change often.
   *
   * If the texture is intended to be updated often, it is preferred to create
   * the texture as streaming and use the locking functions referenced below.
   * While this function will work with streaming textures, for optimization
   * reasons you may not get the pixels back if you lock the texture afterward.
   *
   * @param rect an Rect structure representing the area to update, or nullptr
   *             to update the entire texture.
   * @param pixels the raw pixel data in the format of the texture.
   * @param pitch the number of bytes in a row of pixel data, including padding
   *              between lines.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.Lock
   * @sa Texture.Unlock
   * @sa Texture.UpdateNV
   * @sa Texture.UpdateYUV
   */
  void Update(OptionalRef<const RectRaw> rect, const void* pixels, int pitch);

  /**
   * Update a rectangle within a planar YV12 or IYUV texture with new pixel
   * data.
   *
   * You can use Texture.Update() as long as your pixel data is a contiguous
   * block of Y and U/V planes in the proper order, but this function is
   * available if your pixel data is not contiguous.
   *
   * @param rect a pointer to the rectangle of pixels to update, or nullptr to
   *             update the entire texture.
   * @param Yplane the raw pixel data for the Y plane.
   * @param Ypitch the number of bytes between rows of pixel data for the Y
   *               plane.
   * @param Uplane the raw pixel data for the U plane.
   * @param Upitch the number of bytes between rows of pixel data for the U
   *               plane.
   * @param Vplane the raw pixel data for the V plane.
   * @param Vpitch the number of bytes between rows of pixel data for the V
   *               plane.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.UpdateNV
   * @sa Texture.Update
   */
  void UpdateYUV(OptionalRef<const RectRaw> rect,
                 const Uint8* Yplane,
                 int Ypitch,
                 const Uint8* Uplane,
                 int Upitch,
                 const Uint8* Vplane,
                 int Vpitch);

  /**
   * Update a rectangle within a planar NV12 or NV21 texture with new pixels.
   *
   * You can use Texture.Update() as long as your pixel data is a contiguous
   * block of NV12/21 planes in the proper order, but this function is available
   * if your pixel data is not contiguous.
   *
   * @param rect a pointer to the rectangle of pixels to update, or nullptr to
   *             update the entire texture.
   * @param Yplane the raw pixel data for the Y plane.
   * @param Ypitch the number of bytes between rows of pixel data for the Y
   *               plane.
   * @param UVplane the raw pixel data for the UV plane.
   * @param UVpitch the number of bytes between rows of pixel data for the UV
   *                plane.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.Update
   * @sa Texture.UpdateYUV
   */
  void UpdateNV(OptionalRef<const RectRaw> rect,
                const Uint8* Yplane,
                int Ypitch,
                const Uint8* UVplane,
                int UVpitch);

  /**
   * Lock a portion of the texture for **write-only** pixel access.
   *
   * As an optimization, the pixels made available for editing don't necessarily
   * contain the old texture data. This is a write-only operation, and if you
   * need to keep a copy of the texture data you should do that at the
   * application level.
   *
   * You must use Texture.Unlock() to unlock the pixels and apply any
   * changes.
   *
   *                `TEXTUREACCESS_STREAMING`.
   * @param rect an Rect structure representing the area to lock for access;
   *             nullptr to lock the entire texture.
   * @param pixels this is filled in with a pointer to the locked pixels,
   *               appropriately offset by the locked area.
   * @param pitch this is filled in with the pitch of the locked pixels; the
   *              pitch is the length of one row in bytes.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.LockToSurface
   * @sa Texture.Unlock
   */
  void Lock(OptionalRef<const SDL_Rect> rect, void** pixels, int* pitch);

  /**
   * Lock a portion of the texture for **write-only** pixel access, and expose
   * it as a SDL surface.
   *
   * Besides providing an Surface instead of raw pixel data, this function
   * operates like Texture.Lock.
   *
   * As an optimization, the pixels made available for editing don't necessarily
   * contain the old texture data. This is a write-only operation, and if you
   * need to keep a copy of the texture data you should do that at the
   * application level.
   *
   * You must use Texture.Unlock() to unlock the pixels and apply any
   * changes.
   *
   * The returned surface is freed internally after calling Texture.Unlock()
   * or Texture.Destroy(). The caller should not free it.
   *
   *                `TEXTUREACCESS_STREAMING`.
   * @param rect a pointer to the rectangle to lock for access. If the rect is
   *             nullptr, the entire texture will be locked.
   * @param surface a pointer to an SDL surface of size **rect**. Don't assume
   *                any specific pixel content.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.Lock
   * @sa Texture.Unlock
   */
  Surface LockToSurface(OptionalRef<const SDL_Rect> rect = std::nullopt);

  /**
   * Unlock a texture, uploading the changes to video memory, if needed.
   *
   * **Warning**: Please note that Texture.Lock() is intended to be
   * write-only; it will not guarantee the previous contents of the texture will
   * be provided. You must fully initialize any area of a texture that you lock
   * before unlocking it, as the pixels might otherwise be uninitialized memory.
   *
   * Which is to say: locking and immediately unlocking a texture can result in
   * corrupted textures, depending on the renderer in use.
   *
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   *
   * @sa Texture.Lock
   */
  void Unlock();

  /**
   * Get the width in pixels.
   */
  int GetWidth() const { return m_resource->w; }

  /**
   * Get the height in pixels.
   */
  int GetHeight() const { return m_resource->h; }

  /**
   * Get the size in pixels.
   */
  Point GetSize() const { return Point(GetWidth(), GetHeight()); }

  /**
   * Get the size of a texture, as floating point values.
   *
   * @param w a pointer filled in with the width of the texture in pixels. This
   *          argument can be nullptr if you don't need this information.
   * @param h a pointer filled in with the height of the texture in pixels. This
   *          argument can be nullptr if you don't need this information.
   * @throws Error on failure.
   *
   * @threadsafety This function should only be called on the main thread.
   *
   * @since This function is available since SDL 3.2.0.
   */
  void GetSize(float* w, float* h) const;

  /**
   * Get the size in pixels.
   */
  FPoint GetSizeFloat() const
  {
    FPoint p;
    GetSize(&p.x, &p.y);
    return p;
  }

  /**
   * Get the pixel format.
   */
  PixelFormat GetFormat() const { return m_resource->format; }
};

/**
 * Get the number of 2D rendering drivers available for the current display.
 *
 * A render driver is a set of code that handles rendering and texture
 * management on a particular display. Normally there is only one, but some
 * drivers may have several available with different capabilities.
 *
 * There may be none if SDL was compiled without render support.
 *
 * @returns the number of built in render drivers.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.Renderer
 * @sa GetRenderDriver
 */
inline int GetNumRenderDrivers() { return SDL_GetNumRenderDrivers(); }

/**
 * Use this function to get the name of a built in 2D rendering driver.
 *
 * The list of rendering drivers is given in the order that they are normally
 * initialized by default; the drivers that seem more reasonable to choose
 * first (as far as the SDL developers believe) are earlier in the list.
 *
 * The names of drivers are all simple, low-ASCII identifiers, like "opengl",
 * "direct3d12" or "metal". These never have Unicode characters, and are not
 * meant to be proper names.
 *
 * @param index the index of the rendering driver; the value ranges from 0 to
 *              GetNumRenderDrivers() - 1.
 * @returns the name of the rendering driver at the requested index, or nullptr
 *          if an invalid index was specified.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa GetNumRenderDrivers
 */
inline const char* GetRenderDriver(int index)
{
  return SDL_GetRenderDriver(index);
}

/**
 * Create a window and default renderer.
 *
 * @param title the title of the window, in UTF-8 encoding.
 * @param width the width of the window.
 * @param height the height of the window.
 * @param window_flags the flags used to create the window (see
 *                     Window.Window()).
 * @returns a pair with window and renderer.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.Renderer
 * @sa Window.Window
 */
inline std::pair<Window, Renderer> CreateWindowAndRenderer(
  StringParam title,
  const PointRaw& size,
  WindowFlags window_flags = 0)
{
  SDL_Window* window = nullptr;
  SDL_Renderer* renderer = nullptr;
  CheckError(SDL_CreateWindowAndRenderer(
    title, size.x, size.y, window_flags, &window, &renderer));
  return {Window{window}, Renderer(renderer)};
}

/**
 * Create a 2D rendering context for a window.
 *
 * If you want a specific renderer, you can specify its name here. A list of
 * available renderers can be obtained by calling GetRenderDriver()
 * multiple times, with indices from 0 to GetNumRenderDrivers()-1. If you
 * don't need a specific renderer, specify nullptr and SDL will attempt to
 * choose the best option for you, based on what is available on the user's
 * system.
 *
 * If `name` is a comma-separated list, SDL will try each name, in the order
 * listed, until one succeeds or all of them fail.
 *
 * By default the rendering size matches the window size in pixels, but you
 * can call Renderer.SetLogicalPresentation() to change the content size and
 * scaling options.
 *
 * @param window the window where rendering is displayed.
 * @param name the name of the rendering driver to initialize, or nullptr to let
 *             SDL choose one.
 * @returns a valid rendering context or nullptr if there was an error; call
 *          GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.Renderer
 * @sa Renderer.Renderer
 * @sa Renderer.Destroy
 * @sa GetNumRenderDrivers
 * @sa GetRenderDriver
 * @sa Renderer.GetName
 */
inline Renderer CreateRenderer(WindowParam window, StringParam name)
{
  return Renderer(window, std::move(name));
}

/**
 * Create a 2D rendering context for a window, with the specified properties.
 *
 * These are the supported properties:
 *
 * - `prop::Renderer.CREATE_NAME_STRING`: the name of the rendering driver
 *   to use, if a specific one is desired
 * - `prop::Renderer.CREATE_WINDOW_POINTER`: the window where rendering is
 *   displayed, required if this isn't a software renderer using a surface
 * - `prop::Renderer.CREATE_SURFACE_POINTER`: the surface where rendering
 *   is displayed, if you want a software renderer without a window
 * - `prop::Renderer.CREATE_OUTPUT_COLORSPACE_NUMBER`: an Colorspace
 *   value describing the colorspace for output to the display, defaults to
 *   COLORSPACE_SRGB. The direct3d11, direct3d12, and metal renderers
 *   support COLORSPACE_SRGB_LINEAR, which is a linear color space and
 *   supports HDR output. If you select COLORSPACE_SRGB_LINEAR, drawing
 *   still uses the sRGB colorspace, but values can go beyond 1.0 and float
 *   (linear) format textures can be used for HDR content.
 * - `prop::Renderer.CREATE_PRESENT_VSYNC_NUMBER`: non-zero if you want
 *   present synchronized with the refresh rate. This property can take any
 *   value that is supported by Renderer.SetVSync() for the renderer.
 *
 * With the vulkan renderer:
 *
 * - `prop::Renderer.CREATE_VULKAN_INSTANCE_POINTER`: the VkInstance to use
 *   with the renderer, optional.
 * - `prop::Renderer.CREATE_VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR to use
 *   with the renderer, optional.
 * - `prop::Renderer.CREATE_VULKAN_PHYSICAL_DEVICE_POINTER`: the
 *   VkPhysicalDevice to use with the renderer, optional.
 * - `prop::Renderer.CREATE_VULKAN_DEVICE_POINTER`: the VkDevice to use
 *   with the renderer, optional.
 * - `prop::Renderer.CREATE_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the
 *   queue family index used for rendering.
 * - `prop::Renderer.CREATE_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the
 *   queue family index used for presentation.
 *
 * @param props the properties to use.
 * @returns a valid rendering context or nullptr if there was an error; call
 *          GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Properties.Create
 * @sa Renderer.Renderer
 * @sa Renderer.Renderer
 * @sa Renderer.Destroy
 * @sa Renderer.GetName
 */
inline Renderer CreateRendererWithProperties(PropertiesParam props)
{
  return Renderer(props);
}

namespace prop::Renderer {

constexpr auto CREATE_NAME_STRING = SDL_PROP_RENDERER_CREATE_NAME_STRING;

constexpr auto CREATE_WINDOW_POINTER = SDL_PROP_RENDERER_CREATE_WINDOW_POINTER;

constexpr auto CREATE_SURFACE_POINTER =
  SDL_PROP_RENDERER_CREATE_SURFACE_POINTER;

constexpr auto CREATE_OUTPUT_COLORSPACE_NUMBER =
  SDL_PROP_RENDERER_CREATE_OUTPUT_COLORSPACE_NUMBER;

constexpr auto CREATE_PRESENT_VSYNC_NUMBER =
  SDL_PROP_RENDERER_CREATE_PRESENT_VSYNC_NUMBER;

constexpr auto CREATE_VULKAN_INSTANCE_POINTER =
  SDL_PROP_RENDERER_CREATE_VULKAN_INSTANCE_POINTER;

constexpr auto CREATE_VULKAN_SURFACE_NUMBER =
  SDL_PROP_RENDERER_CREATE_VULKAN_SURFACE_NUMBER;

constexpr auto CREATE_VULKAN_PHYSICAL_DEVICE_POINTER =
  SDL_PROP_RENDERER_CREATE_VULKAN_PHYSICAL_DEVICE_POINTER;

constexpr auto CREATE_VULKAN_DEVICE_POINTER =
  SDL_PROP_RENDERER_CREATE_VULKAN_DEVICE_POINTER;

constexpr auto CREATE_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER =
  SDL_PROP_RENDERER_CREATE_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER;

constexpr auto CREATE_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER =
  SDL_PROP_RENDERER_CREATE_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER;

constexpr auto NAME_STRING = SDL_PROP_RENDERER_NAME_STRING;

constexpr auto WINDOW_POINTER = SDL_PROP_RENDERER_WINDOW_POINTER;

constexpr auto SURFACE_POINTER = SDL_PROP_RENDERER_SURFACE_POINTER;

constexpr auto VSYNC_NUMBER = SDL_PROP_RENDERER_VSYNC_NUMBER;

constexpr auto MAX_TEXTURE_SIZE_NUMBER =
  SDL_PROP_RENDERER_MAX_TEXTURE_SIZE_NUMBER;

constexpr auto TEXTURE_FORMATS_POINTER =
  SDL_PROP_RENDERER_TEXTURE_FORMATS_POINTER;

constexpr auto OUTPUT_COLORSPACE_NUMBER =
  SDL_PROP_RENDERER_OUTPUT_COLORSPACE_NUMBER;

constexpr auto HDR_ENABLED_BOOLEAN = SDL_PROP_RENDERER_HDR_ENABLED_BOOLEAN;

constexpr auto SDR_WHITE_POINT_FLOAT = SDL_PROP_RENDERER_SDR_WHITE_POINT_FLOAT;

constexpr auto HDR_HEADROOM_FLOAT = SDL_PROP_RENDERER_HDR_HEADROOM_FLOAT;

constexpr auto D3D9_DEVICE_POINTER = SDL_PROP_RENDERER_D3D9_DEVICE_POINTER;

constexpr auto D3D11_DEVICE_POINTER = SDL_PROP_RENDERER_D3D11_DEVICE_POINTER;

constexpr auto D3D11_SWAPCHAIN_POINTER =
  SDL_PROP_RENDERER_D3D11_SWAPCHAIN_POINTER;

constexpr auto D3D12_DEVICE_POINTER = SDL_PROP_RENDERER_D3D12_DEVICE_POINTER;

constexpr auto D3D12_SWAPCHAIN_POINTER =
  SDL_PROP_RENDERER_D3D12_SWAPCHAIN_POINTER;

constexpr auto D3D12_COMMAND_QUEUE_POINTER =
  SDL_PROP_RENDERER_D3D12_COMMAND_QUEUE_POINTER;

constexpr auto VULKAN_INSTANCE_POINTER =
  SDL_PROP_RENDERER_VULKAN_INSTANCE_POINTER;

constexpr auto VULKAN_SURFACE_NUMBER = SDL_PROP_RENDERER_VULKAN_SURFACE_NUMBER;

constexpr auto VULKAN_PHYSICAL_DEVICE_POINTER =
  SDL_PROP_RENDERER_VULKAN_PHYSICAL_DEVICE_POINTER;

constexpr auto VULKAN_DEVICE_POINTER = SDL_PROP_RENDERER_VULKAN_DEVICE_POINTER;

constexpr auto VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER =
  SDL_PROP_RENDERER_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER;

constexpr auto VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER =
  SDL_PROP_RENDERER_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER;

constexpr auto VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER =
  SDL_PROP_RENDERER_VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER;

constexpr auto GPU_DEVICE_POINTER = SDL_PROP_RENDERER_GPU_DEVICE_POINTER;

} // namespace prop::Renderer

/**
 * Create a 2D software rendering context for a surface.
 *
 * Two other API which can be used to create Renderer:
 * Renderer.Renderer() and CreateWindowAndRenderer(). These can _also_
 * create a software renderer, but they are intended to be used with an
 * Window as the final destination and not an Surface.
 *
 * @param surface the Surface structure representing the surface where
 *                rendering is done.
 * @returns a valid rendering context or nullptr if there was an error; call
 *          GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.Destroy
 */
inline Renderer CreateSoftwareRenderer(SurfaceParam surface)
{
  return Renderer(surface);
}

/**
 * Get the renderer associated with a window.
 *
 * @returns the rendering context on success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline RendererRef Window::GetRenderer() const
{
  return {CheckError(SDL_GetRenderer(m_resource))};
}

/**
 * Get the window associated with a renderer.
 *
 * @param renderer the renderer to query.
 * @returns the window on success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline WindowRef GetRenderWindow(RendererParam renderer)
{
  return {CheckError(SDL_GetRenderWindow(renderer))};
}

inline WindowRef Renderer::GetWindow()
{
  return SDL::GetRenderWindow(m_resource);
}

/**
 * Get the name of a renderer.
 *
 * @param renderer the rendering context.
 * @returns the name of the selected renderer, or nullptr on failure; call
 *          GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.Renderer
 * @sa Renderer.Renderer
 */
inline const char* GetRendererName(RendererParam renderer)
{
  return SDL_GetRendererName(renderer);
}

inline const char* Renderer::GetName() const
{
  return SDL::GetRendererName(m_resource);
}

/**
 * Get the properties associated with a renderer.
 *
 * The following read-only properties are provided by SDL:
 *
 * - `prop::Renderer.NAME_STRING`: the name of the rendering driver
 * - `prop::Renderer.WINDOW_POINTER`: the window where rendering is
 *   displayed, if any
 * - `prop::Renderer.SURFACE_POINTER`: the surface where rendering is
 *   displayed, if this is a software renderer without a window
 * - `prop::Renderer.VSYNC_NUMBER`: the current vsync setting
 * - `prop::Renderer.MAX_TEXTURE_SIZE_NUMBER`: the maximum texture width
 *   and height
 * - `prop::Renderer.TEXTURE_FORMATS_POINTER`: a (const PixelFormat *)
 *   array of pixel formats, terminated with PIXELFORMAT_UNKNOWN,
 *   representing the available texture formats for this renderer.
 * - `prop::Renderer.OUTPUT_COLORSPACE_NUMBER`: an Colorspace value
 *   describing the colorspace for output to the display, defaults to
 *   COLORSPACE_SRGB.
 * - `prop::Renderer.HDR_ENABLED_BOOLEAN`: true if the output colorspace is
 *   COLORSPACE_SRGB_LINEAR and the renderer is showing on a display with
 *   HDR enabled. This property can change dynamically when
 *   EVENT_WINDOW_HDR_STATE_CHANGED is sent.
 * - `prop::Renderer.SDR_WHITE_POINT_FLOAT`: the value of SDR white in the
 *   COLORSPACE_SRGB_LINEAR colorspace. When HDR is enabled, this value is
 *   automatically multiplied into the color scale. This property can change
 *   dynamically when EVENT_WINDOW_HDR_STATE_CHANGED is sent.
 * - `prop::Renderer.HDR_HEADROOM_FLOAT`: the additional high dynamic range
 *   that can be displayed, in terms of the SDR white point. When HDR is not
 *   enabled, this will be 1.0. This property can change dynamically when
 *   EVENT_WINDOW_HDR_STATE_CHANGED is sent.
 *
 * With the direct3d renderer:
 *
 * - `prop::Renderer.D3D9_DEVICE_POINTER`: the IDirect3DDevice9 associated
 *   with the renderer
 *
 * With the direct3d11 renderer:
 *
 * - `prop::Renderer.D3D11_DEVICE_POINTER`: the ID3D11Device associated
 *   with the renderer
 * - `prop::Renderer.D3D11_SWAPCHAIN_POINTER`: the IDXGISwapChain1
 *   associated with the renderer. This may change when the window is resized.
 *
 * With the direct3d12 renderer:
 *
 * - `prop::Renderer.D3D12_DEVICE_POINTER`: the ID3D12Device associated
 *   with the renderer
 * - `prop::Renderer.D3D12_SWAPCHAIN_POINTER`: the IDXGISwapChain4
 *   associated with the renderer.
 * - `prop::Renderer.D3D12_COMMAND_QUEUE_POINTER`: the ID3D12CommandQueue
 *   associated with the renderer
 *
 * With the vulkan renderer:
 *
 * - `prop::Renderer.VULKAN_INSTANCE_POINTER`: the VkInstance associated
 *   with the renderer
 * - `prop::Renderer.VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR associated
 *   with the renderer
 * - `prop::Renderer.VULKAN_PHYSICAL_DEVICE_POINTER`: the VkPhysicalDevice
 *   associated with the renderer
 * - `prop::Renderer.VULKAN_DEVICE_POINTER`: the VkDevice associated with
 *   the renderer
 * - `prop::Renderer.VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the queue
 *   family index used for rendering
 * - `prop::Renderer.VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the queue
 *   family index used for presentation
 * - `prop::Renderer.VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER`: the number of
 *   swapchain images, or potential frames in flight, used by the Vulkan
 *   renderer
 *
 * With the gpu renderer:
 *
 * - `prop::Renderer.GPU_DEVICE_POINTER`: the SDL_GPUDevice associated with
 *   the renderer
 *
 * @param renderer the rendering context.
 * @returns a valid property ID on success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline PropertiesRef GetRendererProperties(RendererParam renderer)
{
  return {CheckError(SDL_GetRendererProperties(renderer))};
}

inline PropertiesRef Renderer::GetProperties() const
{
  return SDL::GetRendererProperties(m_resource);
}

/**
 * Get the output size in pixels of a rendering context.
 *
 * This returns the true output size in pixels, ignoring any render targets or
 * logical size and presentation.
 *
 * For the output size of the current rendering target, with logical size
 * adjustments, use Renderer.GetCurrentOutputSize() instead.
 *
 * @param renderer the rendering context.
 * @param w a pointer filled in with the width in pixels.
 * @param h a pointer filled in with the height in pixels.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.GetCurrentOutputSize
 */
inline void GetRenderOutputSize(RendererParam renderer, int* w, int* h)
{
  CheckError(SDL_GetRenderOutputSize(renderer, w, h));
}

inline void Renderer::GetOutputSize(int* w, int* h) const
{
  SDL::GetRenderOutputSize(m_resource, w, h);
}

/**
 * Get the current output size in pixels of a rendering context.
 *
 * If a rendering target is active, this will return the size of the rendering
 * target in pixels, otherwise return the value of Renderer.GetOutputSize().
 *
 * Rendering target or not, the output will be adjusted by the current logical
 * presentation state, dictated by Renderer.SetLogicalPresentation().
 *
 * @param renderer the rendering context.
 * @param w a pointer filled in with the current width.
 * @param h a pointer filled in with the current height.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.GetOutputSize
 */
inline void GetCurrentRenderOutputSize(RendererParam renderer, int* w, int* h)
{
  CheckError(SDL_GetCurrentRenderOutputSize(renderer, w, h));
}

inline void Renderer::GetCurrentOutputSize(int* w, int* h) const
{
  SDL::GetCurrentRenderOutputSize(m_resource, w, h);
}

inline Texture Renderer::CreateTexture(PixelFormat format,
                                       TextureAccess access,
                                       const PointRaw& size)
{
  return Texture(m_resource, format, access, size);
}

/**
 * Create a texture for a rendering context.
 *
 * The contents of a texture when first created are not defined.
 *
 * @param renderer the rendering context.
 * @param format one of the enumerated values in PixelFormat.
 * @param access one of the enumerated values in TextureAccess.
 * @param w the width of the texture in pixels.
 * @param h the height of the texture in pixels.
 * @returns the created texture or nullptr on failure; call GetError() for
 *          more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Texture.Texture
 * @sa Texture.Texture
 * @sa Texture.Destroy
 * @sa Texture.GetSize
 * @sa Texture.Update
 */
inline Texture CreateTexture(RendererParam renderer,
                             PixelFormat format,
                             TextureAccess access,
                             const PointRaw& size)
{
  return Texture(renderer, format, access, size);
}

inline Texture Renderer::CreateTextureFromSurface(SurfaceParam surface)
{
  return Texture(m_resource, surface);
}

/**
 * Create a texture from an existing surface.
 *
 * The surface is not modified or freed by this function.
 *
 * The TextureAccess hint for the created texture is
 * `TEXTUREACCESS_STATIC`.
 *
 * The pixel format of the created texture may be different from the pixel
 * format of the surface, and can be queried using the
 * prop::Texture.FORMAT_NUMBER property.
 *
 * @param renderer the rendering context.
 * @param surface the Surface structure containing pixel data used to fill
 *                the texture.
 * @returns the created texture or nullptr on failure; call GetError() for
 *          more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Texture.Texture
 * @sa Texture.Texture
 * @sa Texture.Destroy
 */
inline Texture CreateTextureFromSurface(RendererParam renderer,
                                        SurfaceParam surface)
{
  return Texture(SDL_CreateTextureFromSurface(renderer, surface));
}

inline Texture Renderer::CreateTextureWithProperties(PropertiesParam props)
{
  return Texture(m_resource, props);
}

/**
 * Create a texture for a rendering context with the specified properties.
 *
 * These are the supported properties:
 *
 * - `prop::Texture.CREATE_COLORSPACE_NUMBER`: an Colorspace value
 *   describing the texture colorspace, defaults to COLORSPACE_SRGB_LINEAR
 *   for floating point textures, COLORSPACE_HDR10 for 10-bit textures,
 *   COLORSPACE_SRGB for other RGB textures and COLORSPACE_JPEG for
 *   YUV textures.
 * - `prop::Texture.CREATE_FORMAT_NUMBER`: one of the enumerated values in
 *   PixelFormat, defaults to the best RGBA format for the renderer
 * - `prop::Texture.CREATE_ACCESS_NUMBER`: one of the enumerated values in
 *   TextureAccess, defaults to TEXTUREACCESS_STATIC
 * - `prop::Texture.CREATE_WIDTH_NUMBER`: the width of the texture in
 *   pixels, required
 * - `prop::Texture.CREATE_HEIGHT_NUMBER`: the height of the texture in
 *   pixels, required
 * - `prop::Texture.CREATE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating
 *   point textures, this defines the value of 100% diffuse white, with higher
 *   values being displayed in the High Dynamic Range headroom. This defaults
 *   to 100 for HDR10 textures and 1.0 for floating point textures.
 * - `prop::Texture.CREATE_HDR_HEADROOM_FLOAT`: for HDR10 and floating
 *   point textures, this defines the maximum dynamic range used by the
 *   content, in terms of the SDR white point. This would be equivalent to
 *   maxCLL / prop::Texture.CREATE_SDR_WHITE_POINT_FLOAT for HDR10 content.
 *   If this is defined, any values outside the range supported by the display
 *   will be scaled into the available HDR headroom, otherwise they are
 *   clipped.
 *
 * With the direct3d11 renderer:
 *
 * - `prop::Texture.CREATE_D3D11_TEXTURE_POINTER`: the ID3D11Texture2D
 *   associated with the texture, if you want to wrap an existing texture.
 * - `prop::Texture.CREATE_D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D
 *   associated with the U plane of a YUV texture, if you want to wrap an
 *   existing texture.
 * - `prop::Texture.CREATE_D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D
 *   associated with the V plane of a YUV texture, if you want to wrap an
 *   existing texture.
 *
 * With the direct3d12 renderer:
 *
 * - `prop::Texture.CREATE_D3D12_TEXTURE_POINTER`: the ID3D12Resource
 *   associated with the texture, if you want to wrap an existing texture.
 * - `prop::Texture.CREATE_D3D12_TEXTURE_U_POINTER`: the ID3D12Resource
 *   associated with the U plane of a YUV texture, if you want to wrap an
 *   existing texture.
 * - `prop::Texture.CREATE_D3D12_TEXTURE_V_POINTER`: the ID3D12Resource
 *   associated with the V plane of a YUV texture, if you want to wrap an
 *   existing texture.
 *
 * With the metal renderer:
 *
 * - `prop::Texture.CREATE_METAL_PIXELBUFFER_POINTER`: the CVPixelBufferRef
 *   associated with the texture, if you want to create a texture from an
 *   existing pixel buffer.
 *
 * With the opengl renderer:
 *
 * - `prop::Texture.CREATE_OPENGL_TEXTURE_NUMBER`: the GLuint texture
 *   associated with the texture, if you want to wrap an existing texture.
 * - `prop::Texture.CREATE_OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture
 *   associated with the UV plane of an NV12 texture, if you want to wrap an
 *   existing texture.
 * - `prop::Texture.CREATE_OPENGL_TEXTURE_U_NUMBER`: the GLuint texture
 *   associated with the U plane of a YUV texture, if you want to wrap an
 *   existing texture.
 * - `prop::Texture.CREATE_OPENGL_TEXTURE_V_NUMBER`: the GLuint texture
 *   associated with the V plane of a YUV texture, if you want to wrap an
 *   existing texture.
 *
 * With the opengles2 renderer:
 *
 * - `prop::Texture.CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture
 *   associated with the texture, if you want to wrap an existing texture.
 * - `prop::Texture.CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture
 *   associated with the texture, if you want to wrap an existing texture.
 * - `prop::Texture.CREATE_OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture
 *   associated with the UV plane of an NV12 texture, if you want to wrap an
 *   existing texture.
 * - `prop::Texture.CREATE_OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture
 *   associated with the U plane of a YUV texture, if you want to wrap an
 *   existing texture.
 * - `prop::Texture.CREATE_OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture
 *   associated with the V plane of a YUV texture, if you want to wrap an
 *   existing texture.
 *
 * With the vulkan renderer:
 *
 * - `prop::Texture.CREATE_VULKAN_TEXTURE_NUMBER`: the VkImage with layout
 *   VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL associated with the texture, if
 *   you want to wrap an existing texture.
 *
 * @param renderer the rendering context.
 * @param props the properties to use.
 * @returns the created texture or nullptr on failure; call GetError() for
 *          more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Properties.Create
 * @sa Texture.Texture
 * @sa Texture.Texture
 * @sa Texture.Destroy
 * @sa Texture.GetSize
 * @sa Texture.Update
 */
inline Texture CreateTextureWithProperties(RendererParam renderer,
                                           PropertiesParam props)
{
  return Texture(SDL_CreateTextureWithProperties(renderer, props));
}

namespace prop::Texture {

constexpr auto CREATE_COLORSPACE_NUMBER =
  SDL_PROP_TEXTURE_CREATE_COLORSPACE_NUMBER;

constexpr auto CREATE_FORMAT_NUMBER = SDL_PROP_TEXTURE_CREATE_FORMAT_NUMBER;

constexpr auto CREATE_ACCESS_NUMBER = SDL_PROP_TEXTURE_CREATE_ACCESS_NUMBER;

constexpr auto CREATE_WIDTH_NUMBER = SDL_PROP_TEXTURE_CREATE_WIDTH_NUMBER;

constexpr auto CREATE_HEIGHT_NUMBER = SDL_PROP_TEXTURE_CREATE_HEIGHT_NUMBER;

constexpr auto CREATE_SDR_WHITE_POINT_FLOAT =
  SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT;

constexpr auto CREATE_HDR_HEADROOM_FLOAT =
  SDL_PROP_TEXTURE_CREATE_HDR_HEADROOM_FLOAT;

constexpr auto CREATE_D3D11_TEXTURE_POINTER =
  SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_POINTER;

constexpr auto CREATE_D3D11_TEXTURE_U_POINTER =
  SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_U_POINTER;

constexpr auto CREATE_D3D11_TEXTURE_V_POINTER =
  SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_V_POINTER;

constexpr auto CREATE_D3D12_TEXTURE_POINTER =
  SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_POINTER;

constexpr auto CREATE_D3D12_TEXTURE_U_POINTER =
  SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_U_POINTER;

constexpr auto CREATE_D3D12_TEXTURE_V_POINTER =
  SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_V_POINTER;

constexpr auto CREATE_METAL_PIXELBUFFER_POINTER =
  SDL_PROP_TEXTURE_CREATE_METAL_PIXELBUFFER_POINTER;

constexpr auto CREATE_OPENGL_TEXTURE_NUMBER =
  SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_NUMBER;

constexpr auto CREATE_OPENGL_TEXTURE_UV_NUMBER =
  SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_UV_NUMBER;

constexpr auto CREATE_OPENGL_TEXTURE_U_NUMBER =
  SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_U_NUMBER;

constexpr auto CREATE_OPENGL_TEXTURE_V_NUMBER =
  SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_V_NUMBER;

constexpr auto CREATE_OPENGLES2_TEXTURE_NUMBER =
  SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER;

constexpr auto CREATE_OPENGLES2_TEXTURE_UV_NUMBER =
  SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_UV_NUMBER;

constexpr auto CREATE_OPENGLES2_TEXTURE_U_NUMBER =
  SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_U_NUMBER;

constexpr auto CREATE_OPENGLES2_TEXTURE_V_NUMBER =
  SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_V_NUMBER;

constexpr auto CREATE_VULKAN_TEXTURE_NUMBER =
  SDL_PROP_TEXTURE_CREATE_VULKAN_TEXTURE_NUMBER;

constexpr auto COLORSPACE_NUMBER = SDL_PROP_TEXTURE_COLORSPACE_NUMBER;

constexpr auto FORMAT_NUMBER = SDL_PROP_TEXTURE_FORMAT_NUMBER;

constexpr auto ACCESS_NUMBER = SDL_PROP_TEXTURE_ACCESS_NUMBER;

constexpr auto WIDTH_NUMBER = SDL_PROP_TEXTURE_WIDTH_NUMBER;

constexpr auto HEIGHT_NUMBER = SDL_PROP_TEXTURE_HEIGHT_NUMBER;

constexpr auto SDR_WHITE_POINT_FLOAT = SDL_PROP_TEXTURE_SDR_WHITE_POINT_FLOAT;

constexpr auto HDR_HEADROOM_FLOAT = SDL_PROP_TEXTURE_HDR_HEADROOM_FLOAT;

constexpr auto D3D11_TEXTURE_POINTER = SDL_PROP_TEXTURE_D3D11_TEXTURE_POINTER;

constexpr auto D3D11_TEXTURE_U_POINTER =
  SDL_PROP_TEXTURE_D3D11_TEXTURE_U_POINTER;

constexpr auto D3D11_TEXTURE_V_POINTER =
  SDL_PROP_TEXTURE_D3D11_TEXTURE_V_POINTER;

constexpr auto D3D12_TEXTURE_POINTER = SDL_PROP_TEXTURE_D3D12_TEXTURE_POINTER;

constexpr auto D3D12_TEXTURE_U_POINTER =
  SDL_PROP_TEXTURE_D3D12_TEXTURE_U_POINTER;

constexpr auto D3D12_TEXTURE_V_POINTER =
  SDL_PROP_TEXTURE_D3D12_TEXTURE_V_POINTER;

constexpr auto OPENGL_TEXTURE_NUMBER = SDL_PROP_TEXTURE_OPENGL_TEXTURE_NUMBER;

constexpr auto OPENGL_TEXTURE_UV_NUMBER =
  SDL_PROP_TEXTURE_OPENGL_TEXTURE_UV_NUMBER;

constexpr auto OPENGL_TEXTURE_U_NUMBER =
  SDL_PROP_TEXTURE_OPENGL_TEXTURE_U_NUMBER;

constexpr auto OPENGL_TEXTURE_V_NUMBER =
  SDL_PROP_TEXTURE_OPENGL_TEXTURE_V_NUMBER;

constexpr auto OPENGL_TEXTURE_TARGET_NUMBER =
  SDL_PROP_TEXTURE_OPENGL_TEXTURE_TARGET_NUMBER;

constexpr auto OPENGL_TEX_W_FLOAT = SDL_PROP_TEXTURE_OPENGL_TEX_W_FLOAT;

constexpr auto OPENGL_TEX_H_FLOAT = SDL_PROP_TEXTURE_OPENGL_TEX_H_FLOAT;

constexpr auto OPENGLES2_TEXTURE_NUMBER =
  SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_NUMBER;

constexpr auto OPENGLES2_TEXTURE_UV_NUMBER =
  SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_UV_NUMBER;

constexpr auto OPENGLES2_TEXTURE_U_NUMBER =
  SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_U_NUMBER;

constexpr auto OPENGLES2_TEXTURE_V_NUMBER =
  SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_V_NUMBER;

constexpr auto OPENGLES2_TEXTURE_TARGET_NUMBER =
  SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_TARGET_NUMBER;

constexpr auto VULKAN_TEXTURE_NUMBER = SDL_PROP_TEXTURE_VULKAN_TEXTURE_NUMBER;

} // namespace prop::Texture

/**
 * Get the properties associated with a texture.
 *
 * The following read-only properties are provided by SDL:
 *
 * - `prop::Texture.COLORSPACE_NUMBER`: an Colorspace value describing
 *   the texture colorspace.
 * - `prop::Texture.FORMAT_NUMBER`: one of the enumerated values in
 *   PixelFormat.
 * - `prop::Texture.ACCESS_NUMBER`: one of the enumerated values in
 *   TextureAccess.
 * - `prop::Texture.WIDTH_NUMBER`: the width of the texture in pixels.
 * - `prop::Texture.HEIGHT_NUMBER`: the height of the texture in pixels.
 * - `prop::Texture.SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point
 *   textures, this defines the value of 100% diffuse white, with higher
 *   values being displayed in the High Dynamic Range headroom. This defaults
 *   to 100 for HDR10 textures and 1.0 for other textures.
 * - `prop::Texture.HDR_HEADROOM_FLOAT`: for HDR10 and floating point
 *   textures, this defines the maximum dynamic range used by the content, in
 *   terms of the SDR white point. If this is defined, any values outside the
 *   range supported by the display will be scaled into the available HDR
 *   headroom, otherwise they are clipped. This defaults to 1.0 for SDR
 *   textures, 4.0 for HDR10 textures, and no default for floating point
 *   textures.
 *
 * With the direct3d11 renderer:
 *
 * - `prop::Texture.D3D11_TEXTURE_POINTER`: the ID3D11Texture2D associated
 *   with the texture
 * - `prop::Texture.D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D
 *   associated with the U plane of a YUV texture
 * - `prop::Texture.D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D
 *   associated with the V plane of a YUV texture
 *
 * With the direct3d12 renderer:
 *
 * - `prop::Texture.D3D12_TEXTURE_POINTER`: the ID3D12Resource associated
 *   with the texture
 * - `prop::Texture.D3D12_TEXTURE_U_POINTER`: the ID3D12Resource associated
 *   with the U plane of a YUV texture
 * - `prop::Texture.D3D12_TEXTURE_V_POINTER`: the ID3D12Resource associated
 *   with the V plane of a YUV texture
 *
 * With the vulkan renderer:
 *
 * - `prop::Texture.VULKAN_TEXTURE_NUMBER`: the VkImage associated with the
 *   texture
 *
 * With the opengl renderer:
 *
 * - `prop::Texture.OPENGL_TEXTURE_NUMBER`: the GLuint texture associated
 *   with the texture
 * - `prop::Texture.OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture
 *   associated with the UV plane of an NV12 texture
 * - `prop::Texture.OPENGL_TEXTURE_U_NUMBER`: the GLuint texture associated
 *   with the U plane of a YUV texture
 * - `prop::Texture.OPENGL_TEXTURE_V_NUMBER`: the GLuint texture associated
 *   with the V plane of a YUV texture
 * - `prop::Texture.OPENGL_TEXTURE_TARGET_NUMBER`: the GLenum for the
 *   texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE_ARB`, etc)
 * - `prop::Texture.OPENGL_TEX_W_FLOAT`: the texture coordinate width of
 *   the texture (0.0 - 1.0)
 * - `prop::Texture.OPENGL_TEX_H_FLOAT`: the texture coordinate height of
 *   the texture (0.0 - 1.0)
 *
 * With the opengles2 renderer:
 *
 * - `prop::Texture.OPENGLES2_TEXTURE_NUMBER`: the GLuint texture
 *   associated with the texture
 * - `prop::Texture.OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture
 *   associated with the UV plane of an NV12 texture
 * - `prop::Texture.OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture
 *   associated with the U plane of a YUV texture
 * - `prop::Texture.OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture
 *   associated with the V plane of a YUV texture
 * - `prop::Texture.OPENGLES2_TEXTURE_TARGET_NUMBER`: the GLenum for the
 *   texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_EXTERNAL_OES`, etc)
 *
 * @param texture the texture to query.
 * @returns a valid property ID on success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline PropertiesRef GetTextureProperties(TextureParam texture)
{
  return {CheckError(SDL_GetTextureProperties(texture))};
}

inline PropertiesRef Texture::GetProperties() const
{
  return SDL::GetTextureProperties(m_resource);
}

/**
 * Get the renderer that created an Texture.
 *
 * @param texture the texture to query.
 * @returns a pointer to the Renderer that created the texture, or nullptr on
 *          failure; call GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline RendererRef GetRendererFromTexture(TextureParam texture)
{
  return {SDL_GetRendererFromTexture(texture)};
}

inline RendererRef Texture::GetRenderer() const
{
  return SDL::GetRendererFromTexture(m_resource);
}

/**
 * Get the size of a texture, as floating point values.
 *
 * @param texture the texture to query.
 * @param w a pointer filled in with the width of the texture in pixels. This
 *          argument can be nullptr if you don't need this information.
 * @param h a pointer filled in with the height of the texture in pixels. This
 *          argument can be nullptr if you don't need this information.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void GetTextureSize(TextureParam texture, float* w, float* h)
{
  CheckError(SDL_GetTextureSize(texture, w, h));
}

inline void Texture::GetSize(float* w, float* h) const
{
  SDL::GetTextureSize(m_resource, w, h);
}

/**
 * Set an additional color value multiplied into render copy operations.
 *
 * When this texture is rendered, during the copy operation each source color
 * channel is modulated by the appropriate color value according to the
 * following formula:
 *
 * `srcC = srcC * (color / 255)`
 *
 * Color modulation is not always supported by the renderer; it will return
 * false if color modulation is not supported.
 *
 * @param texture the texture to update.
 * @param r the red color value multiplied into copy operations.
 * @param g the green color value multiplied into copy operations.
 * @param b the blue color value multiplied into copy operations.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Texture.GetColorMod
 * @sa Texture.SetAlphaMod
 * @sa Texture.SetColorModFloat
 */
inline void SetTextureColorMod(TextureParam texture, Uint8 r, Uint8 g, Uint8 b)
{
  CheckError(SDL_SetTextureColorMod(texture, r, g, b));
}

inline void Texture::SetColorMod(Uint8 r, Uint8 g, Uint8 b)
{
  SDL::SetTextureColorMod(m_resource, r, g, b);
}

/**
 * Set an additional color value multiplied into render copy operations.
 *
 * When this texture is rendered, during the copy operation each source color
 * channel is modulated by the appropriate color value according to the
 * following formula:
 *
 * `srcC = srcC * color`
 *
 * Color modulation is not always supported by the renderer; it will return
 * false if color modulation is not supported.
 *
 * @param texture the texture to update.
 * @param r the red color value multiplied into copy operations.
 * @param g the green color value multiplied into copy operations.
 * @param b the blue color value multiplied into copy operations.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Texture.GetColorModFloat
 * @sa Texture.SetAlphaModFloat
 * @sa Texture.SetColorMod
 */
inline void SetTextureColorModFloat(TextureParam texture,
                                    float r,
                                    float g,
                                    float b)
{
  CheckError(SDL_SetTextureColorModFloat(texture, r, g, b));
}

inline void Texture::SetColorModFloat(float r, float g, float b)
{
  SDL::SetTextureColorModFloat(m_resource, r, g, b);
}

/**
 * Get the additional color value multiplied into render copy operations.
 *
 * @param texture the texture to query.
 * @param r a pointer filled in with the current red color value.
 * @param g a pointer filled in with the current green color value.
 * @param b a pointer filled in with the current blue color value.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Texture.GetAlphaMod
 * @sa Texture.GetColorModFloat
 * @sa Texture.SetColorMod
 */
inline void GetTextureColorMod(TextureParam texture,
                               Uint8* r,
                               Uint8* g,
                               Uint8* b)
{
  CheckError(SDL_GetTextureColorMod(texture, r, g, b));
}

inline void Texture::GetColorMod(Uint8* r, Uint8* g, Uint8* b) const
{
  SDL::GetTextureColorMod(m_resource, r, g, b);
}

/**
 * Get the additional color value multiplied into render copy operations.
 *
 * @param texture the texture to query.
 * @param r a pointer filled in with the current red color value.
 * @param g a pointer filled in with the current green color value.
 * @param b a pointer filled in with the current blue color value.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Texture.GetAlphaModFloat
 * @sa Texture.GetColorMod
 * @sa Texture.SetColorModFloat
 */
inline void GetTextureColorModFloat(TextureParam texture,
                                    float* r,
                                    float* g,
                                    float* b)
{
  CheckError(SDL_GetTextureColorModFloat(texture, r, g, b));
}

inline void Texture::GetColorModFloat(float* r, float* g, float* b) const
{
  SDL::GetTextureColorModFloat(m_resource, r, g, b);
}

/**
 * Set an additional alpha value multiplied into render copy operations.
 *
 * When this texture is rendered, during the copy operation the source alpha
 * value is modulated by this alpha value according to the following formula:
 *
 * `srcA = srcA * (alpha / 255)`
 *
 * Alpha modulation is not always supported by the renderer; it will return
 * false if alpha modulation is not supported.
 *
 * @param texture the texture to update.
 * @param alpha the source alpha value multiplied into copy operations.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Texture.GetAlphaMod
 * @sa Texture.SetAlphaModFloat
 * @sa Texture.SetColorMod
 */
inline void SetTextureAlphaMod(TextureParam texture, Uint8 alpha)
{
  CheckError(SDL_SetTextureAlphaMod(texture, alpha));
}

inline void Texture::SetAlphaMod(Uint8 alpha)
{
  SDL::SetTextureAlphaMod(m_resource, alpha);
}

/**
 * Set an additional alpha value multiplied into render copy operations.
 *
 * When this texture is rendered, during the copy operation the source alpha
 * value is modulated by this alpha value according to the following formula:
 *
 * `srcA = srcA * alpha`
 *
 * Alpha modulation is not always supported by the renderer; it will return
 * false if alpha modulation is not supported.
 *
 * @param texture the texture to update.
 * @param alpha the source alpha value multiplied into copy operations.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Texture.GetAlphaModFloat
 * @sa Texture.SetAlphaMod
 * @sa Texture.SetColorModFloat
 */
inline void SetTextureAlphaModFloat(TextureParam texture, float alpha)
{
  CheckError(SDL_SetTextureAlphaModFloat(texture, alpha));
}

inline void Texture::SetAlphaModFloat(float alpha)
{
  SDL::SetTextureAlphaModFloat(m_resource, alpha);
}

/**
 * Get the additional alpha value multiplied into render copy operations.
 *
 * @param texture the texture to query.
 * @param alpha a pointer filled in with the current alpha value.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Texture.GetAlphaModFloat
 * @sa Texture.GetColorMod
 * @sa Texture.SetAlphaMod
 */
inline Uint8 GetTextureAlphaMod(TextureParam texture)
{
  Uint8 alpha;
  CheckError(SDL_GetTextureAlphaMod(texture, &alpha));
  return alpha;
}

inline Uint8 Texture::GetAlphaMod() const
{
  return SDL::GetTextureAlphaMod(m_resource);
}

/**
 * Get the additional alpha value multiplied into render copy operations.
 *
 * @param texture the texture to query.
 * @param alpha a pointer filled in with the current alpha value.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Texture.GetAlphaMod
 * @sa Texture.GetColorModFloat
 * @sa Texture.SetAlphaModFloat
 */
inline float GetTextureAlphaModFloat(TextureParam texture)
{
  float alpha;
  CheckError(SDL_GetTextureAlphaModFloat(texture, &alpha));
  return alpha;
}

inline float Texture::GetAlphaModFloat() const
{
  return SDL::GetTextureAlphaModFloat(m_resource);
}

/**
 * Set the blend mode for a texture, used by Renderer.RenderTexture().
 *
 * If the blend mode is not supported, the closest supported mode is chosen
 * and this function returns false.
 *
 * @param texture the texture to update.
 * @param blendMode the BlendMode to use for texture blending.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Texture.GetBlendMode
 */
inline void SetTextureBlendMode(TextureParam texture, BlendMode blendMode)
{
  CheckError(SDL_SetTextureBlendMode(texture, blendMode));
}

inline void Texture::SetBlendMode(BlendMode blendMode)
{
  SDL::SetTextureBlendMode(m_resource, blendMode);
}

/**
 * Get the blend mode used for texture copy operations.
 *
 * @param texture the texture to query.
 * @return the current BlendMode.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Texture.SetBlendMode
 */
inline BlendMode GetTextureBlendMode(TextureParam texture)
{
  BlendMode blendMode;
  CheckError(SDL_GetTextureBlendMode(texture, &blendMode));
  return blendMode;
}

inline BlendMode Texture::GetBlendMode() const
{
  return SDL::GetTextureBlendMode(m_resource);
}

/**
 * Set the scale mode used for texture scale operations.
 *
 * The default texture scale mode is SCALEMODE_LINEAR.
 *
 * If the scale mode is not supported, the closest supported mode is chosen.
 *
 * @param texture the texture to update.
 * @param scaleMode the ScaleMode to use for texture scaling.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Texture.GetScaleMode
 */
inline void SetTextureScaleMode(TextureParam texture, ScaleMode scaleMode)
{
  CheckError(SDL_SetTextureScaleMode(texture, scaleMode));
}

inline void Texture::SetScaleMode(ScaleMode scaleMode)
{
  SDL::SetTextureScaleMode(m_resource, scaleMode);
}

/**
 * Get the scale mode used for texture scale operations.
 *
 * @param texture the texture to query.
 * @return the current scale mode.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Texture.SetScaleMode
 */
inline ScaleMode GetTextureScaleMode(TextureParam texture)
{
  ScaleMode scaleMode;
  CheckError(SDL_GetTextureScaleMode(texture, &scaleMode));
  return scaleMode;
}

inline ScaleMode Texture::GetScaleMode() const
{
  return SDL::GetTextureScaleMode(m_resource);
}

/**
 * Update the given texture rectangle with new pixel data.
 *
 * The pixel data must be in the pixel format of the texture, which can be
 * queried using the prop::Texture.FORMAT_NUMBER property.
 *
 * This is a fairly slow function, intended for use with static textures that
 * do not change often.
 *
 * If the texture is intended to be updated often, it is preferred to create
 * the texture as streaming and use the locking functions referenced below.
 * While this function will work with streaming textures, for optimization
 * reasons you may not get the pixels back if you lock the texture afterward.
 *
 * @param texture the texture to update.
 * @param rect an Rect structure representing the area to update, or nullptr
 *             to update the entire texture.
 * @param pixels the raw pixel data in the format of the texture.
 * @param pitch the number of bytes in a row of pixel data, including padding
 *              between lines.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Texture.Lock
 * @sa Texture.Unlock
 * @sa Texture.UpdateNV
 * @sa Texture.UpdateYUV
 */
inline void UpdateTexture(TextureParam texture,
                          OptionalRef<const RectRaw> rect,
                          const void* pixels,
                          int pitch)
{
  CheckError(SDL_UpdateTexture(texture, rect, pixels, pitch));
}

inline void Texture::Update(OptionalRef<const RectRaw> rect,
                            const void* pixels,
                            int pitch)
{
  SDL::UpdateTexture(m_resource, rect, pixels, pitch);
}

/**
 * Update a rectangle within a planar YV12 or IYUV texture with new pixel
 * data.
 *
 * You can use Texture.Update() as long as your pixel data is a contiguous
 * block of Y and U/V planes in the proper order, but this function is
 * available if your pixel data is not contiguous.
 *
 * @param texture the texture to update.
 * @param rect a pointer to the rectangle of pixels to update, or nullptr to
 *             update the entire texture.
 * @param Yplane the raw pixel data for the Y plane.
 * @param Ypitch the number of bytes between rows of pixel data for the Y
 *               plane.
 * @param Uplane the raw pixel data for the U plane.
 * @param Upitch the number of bytes between rows of pixel data for the U
 *               plane.
 * @param Vplane the raw pixel data for the V plane.
 * @param Vpitch the number of bytes between rows of pixel data for the V
 *               plane.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Texture.UpdateNV
 * @sa Texture.Update
 */
inline void UpdateYUVTexture(TextureParam texture,
                             OptionalRef<const RectRaw> rect,
                             const Uint8* Yplane,
                             int Ypitch,
                             const Uint8* Uplane,
                             int Upitch,
                             const Uint8* Vplane,
                             int Vpitch)
{
  CheckError(SDL_UpdateYUVTexture(
    texture, rect, Yplane, Ypitch, Uplane, Upitch, Vplane, Vpitch));
}

inline void Texture::UpdateYUV(OptionalRef<const RectRaw> rect,
                               const Uint8* Yplane,
                               int Ypitch,
                               const Uint8* Uplane,
                               int Upitch,
                               const Uint8* Vplane,
                               int Vpitch)
{
  SDL::UpdateYUVTexture(
    m_resource, rect, Yplane, Ypitch, Uplane, Upitch, Vplane, Vpitch);
}

/**
 * Update a rectangle within a planar NV12 or NV21 texture with new pixels.
 *
 * You can use Texture.Update() as long as your pixel data is a contiguous
 * block of NV12/21 planes in the proper order, but this function is available
 * if your pixel data is not contiguous.
 *
 * @param texture the texture to update.
 * @param rect a pointer to the rectangle of pixels to update, or nullptr to
 *             update the entire texture.
 * @param Yplane the raw pixel data for the Y plane.
 * @param Ypitch the number of bytes between rows of pixel data for the Y
 *               plane.
 * @param UVplane the raw pixel data for the UV plane.
 * @param UVpitch the number of bytes between rows of pixel data for the UV
 *                plane.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Texture.Update
 * @sa Texture.UpdateYUV
 */
inline void UpdateNVTexture(TextureParam texture,
                            OptionalRef<const RectRaw> rect,
                            const Uint8* Yplane,
                            int Ypitch,
                            const Uint8* UVplane,
                            int UVpitch)
{
  CheckError(
    SDL_UpdateNVTexture(texture, rect, Yplane, Ypitch, UVplane, UVpitch));
}

inline void Texture::UpdateNV(OptionalRef<const RectRaw> rect,
                              const Uint8* Yplane,
                              int Ypitch,
                              const Uint8* UVplane,
                              int UVpitch)
{
  SDL::UpdateNVTexture(m_resource, rect, Yplane, Ypitch, UVplane, UVpitch);
}

/**
 * Lock a portion of the texture for **write-only** pixel access.
 *
 * As an optimization, the pixels made available for editing don't necessarily
 * contain the old texture data. This is a write-only operation, and if you
 * need to keep a copy of the texture data you should do that at the
 * application level.
 *
 * You must use Texture.Unlock() to unlock the pixels and apply any
 * changes.
 *
 * @param texture the texture to lock for access, which was created with
 *                `TEXTUREACCESS_STREAMING`.
 * @param rect an Rect structure representing the area to lock for access;
 *             nullptr to lock the entire texture.
 * @param pixels this is filled in with a pointer to the locked pixels,
 *               appropriately offset by the locked area.
 * @param pitch this is filled in with the pitch of the locked pixels; the
 *              pitch is the length of one row in bytes.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Texture.LockToSurface
 * @sa Texture.Unlock
 */
inline void LockTexture(TextureParam texture,
                        OptionalRef<const SDL_Rect> rect,
                        void** pixels,
                        int* pitch)
{
  CheckError(SDL_LockTexture(texture, rect, pixels, pitch));
}

inline void Texture::Lock(OptionalRef<const SDL_Rect> rect,
                          void** pixels,
                          int* pitch)
{
  SDL::LockTexture(m_resource, rect, pixels, pitch);
}

/**
 * Lock a portion of the texture for **write-only** pixel access, and expose
 * it as a SDL surface.
 *
 * Besides providing an Surface instead of raw pixel data, this function
 * operates like Texture.Lock.
 *
 * As an optimization, the pixels made available for editing don't necessarily
 * contain the old texture data. This is a write-only operation, and if you
 * need to keep a copy of the texture data you should do that at the
 * application level.
 *
 * You must use Texture.Unlock() to unlock the pixels and apply any
 * changes.
 *
 * The returned surface is freed internally after calling Texture.Unlock()
 * or Texture.Destroy(). The caller should not free it.
 *
 * @param texture the texture to lock for access, which must be created with
 *                `TEXTUREACCESS_STREAMING`.
 * @param rect a pointer to the rectangle to lock for access. If the rect is
 *             nullptr, the entire texture will be locked.
 * @param surface a pointer to an SDL surface of size **rect**. Don't assume
 *                any specific pixel content.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Texture.Lock
 * @sa Texture.Unlock
 */
inline Surface LockTextureToSurface(
  TextureParam texture,
  OptionalRef<const SDL_Rect> rect = std::nullopt)
{
  SurfaceRaw surface = nullptr;
  CheckError(SDL_LockTextureToSurface(texture, rect, &surface));
  return Surface::Borrow(surface);
}

inline Surface Texture::LockToSurface(OptionalRef<const SDL_Rect> rect)
{
  return SDL::LockTextureToSurface(m_resource, rect);
}

/**
 * Unlock a texture, uploading the changes to video memory, if needed.
 *
 * **Warning**: Please note that Texture.Lock() is intended to be
 * write-only; it will not guarantee the previous contents of the texture will
 * be provided. You must fully initialize any area of a texture that you lock
 * before unlocking it, as the pixels might otherwise be uninitialized memory.
 *
 * Which is to say: locking and immediately unlocking a texture can result in
 * corrupted textures, depending on the renderer in use.
 *
 * @param texture a texture locked by Texture.Lock().
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Texture.Lock
 */
inline void UnlockTexture(TextureParam texture) { SDL_UnlockTexture(texture); }

inline void Texture::Unlock() { SDL::UnlockTexture(m_resource); }

/**
 * Set a texture as the current rendering target.
 *
 * The default render target is the window for which the renderer was created.
 * To stop rendering to a texture and render to the window again, call this
 * function with a nullptr `texture`.
 *
 * Viewport, cliprect, scale, and logical presentation are unique to each
 * render target. Get and set functions for these states apply to the current
 * render target set by this function, and those states persist on each target
 * when the current render target changes.
 *
 * @param renderer the rendering context.
 * @param texture the targeted texture, which must be created with the
 *                `TEXTUREACCESS_TARGET` flag, or nullptr to render to the
 *                window instead of a texture.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.GetTarget
 */
inline void SetRenderTarget(RendererParam renderer, TextureParam texture)
{
  CheckError(SDL_SetRenderTarget(renderer, texture));
}

inline void Renderer::SetTarget(TextureParam texture)
{
  SDL::SetRenderTarget(m_resource, texture);
}

/**
 * Get the current render target.
 *
 * The default render target is the window for which the renderer was created,
 * and is reported a nullptr here.
 *
 * @param renderer the rendering context.
 * @returns the current render target or nullptr for the default render target.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.SetTarget
 */
inline Texture GetRenderTarget(RendererParam renderer)
{
  TextureRaw texture = SDL_GetRenderTarget(renderer);
  if (texture) return Texture::Borrow(texture);
  return {};
}

inline Texture Renderer::GetTarget() const
{
  return SDL::GetRenderTarget(m_resource);
}

/**
 * Set a device-independent resolution and presentation mode for rendering.
 *
 * This function sets the width and height of the logical rendering output.
 * The renderer will act as if the current render target is always the
 * requested dimensions, scaling to the actual resolution as necessary.
 *
 * This can be useful for games that expect a fixed size, but would like to
 * scale the output to whatever is available, regardless of how a user resizes
 * a window, or if the display is high DPI.
 *
 * Logical presentation can be used with both render target textures and the
 * renderer's window; the state is unique to each render target, and this
 * function sets the state for the current render target. It might be useful
 * to draw to a texture that matches the window dimensions with logical
 * presentation enabled, and then draw that texture across the entire window
 * with logical presentation disabled. Be careful not to render both with
 * logical presentation enabled, however, as this could produce
 * double-letterboxing, etc.
 *
 * You can disable logical coordinates by setting the mode to
 * LOGICAL_PRESENTATION_DISABLED, and in that case you get the full pixel
 * resolution of the render target; it is safe to toggle logical presentation
 * during the rendering of a frame: perhaps most of the rendering is done to
 * specific dimensions but to make fonts look sharp, the app turns off logical
 * presentation while drawing text, for example.
 *
 * For the renderer's window, letterboxing is drawn into the framebuffer if
 * logical presentation is enabled during Renderer.Present; be sure to
 * reenable it before presenting if you were toggling it, otherwise the
 * letterbox areas might have artifacts from previous frames (or artifacts
 * from external overlays, etc). Letterboxing is never drawn into texture
 * render targets; be sure to call Renderer.RenderClear() before drawing into
 * the texture so the letterboxing areas are cleared, if appropriate.
 *
 * You can convert coordinates in an event into rendering coordinates using
 * Renderer.ConvertEventToRenderCoordinates().
 *
 * @param renderer the rendering context.
 * @param w the width of the logical resolution.
 * @param h the height of the logical resolution.
 * @param mode the presentation mode used.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.ConvertEventToRenderCoordinates
 * @sa Renderer.GetLogicalPresentation
 * @sa Renderer.GetLogicalPresentationRect
 */
inline void SetRenderLogicalPresentation(RendererParam renderer,
                                         const PointRaw& size,
                                         RendererLogicalPresentation mode)
{
  CheckError(SDL_SetRenderLogicalPresentation(renderer, size.x, size.y, mode));
}

inline void Renderer::SetLogicalPresentation(const PointRaw& size,
                                             RendererLogicalPresentation mode)
{
  SDL::SetRenderLogicalPresentation(m_resource, size, mode);
}

/**
 * Get device independent resolution and presentation mode for rendering.
 *
 * This function gets the width and height of the logical rendering output, or
 * the output size in pixels if a logical resolution is not enabled.
 *
 * Each render target has its own logical presentation state. This function
 * gets the state for the current render target.
 *
 * @param renderer the rendering context.
 * @param w an int to be filled with the width.
 * @param h an int to be filled with the height.
 * @param mode the presentation mode used.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.SetLogicalPresentation
 */
inline void GetRenderLogicalPresentation(RendererParam renderer,
                                         int* w,
                                         int* h,
                                         RendererLogicalPresentation* mode)
{
  CheckError(SDL_GetRenderLogicalPresentation(renderer, w, h, mode));
}

inline void Renderer::GetLogicalPresentation(
  int* w,
  int* h,
  RendererLogicalPresentation* mode) const
{
  SDL::GetRenderLogicalPresentation(m_resource, w, h, mode);
}

/**
 * Get the final presentation rectangle for rendering.
 *
 * This function returns the calculated rectangle used for logical
 * presentation, based on the presentation mode and output size. If logical
 * presentation is disabled, it will fill the rectangle with the output size,
 * in pixels.
 *
 * Each render target has its own logical presentation state. This function
 * gets the rectangle for the current render target.
 *
 * @param renderer the rendering context.
 * @param rect a pointer filled in with the final presentation rectangle, may
 *             be nullptr.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.SetLogicalPresentation
 */
inline FRect GetRenderLogicalPresentationRect(RendererParam renderer)
{
  FRect rect;
  CheckError(SDL_GetRenderLogicalPresentationRect(renderer, &rect));
  return rect;
}

inline FRect Renderer::GetLogicalPresentationRect() const
{
  return SDL::GetRenderLogicalPresentationRect(m_resource);
}

/**
 * Get a point in render coordinates when given a point in window coordinates.
 *
 * This takes into account several states:
 *
 * - The window dimensions.
 * - The logical presentation settings (Renderer.SetLogicalPresentation)
 * - The scale (Renderer.SetScale)
 * - The viewport (Renderer.SetViewport)
 *
 * @param renderer the rendering context.
 * @param window_x the x coordinate in window coordinates.
 * @param window_y the y coordinate in window coordinates.
 * @param x a pointer filled with the x coordinate in render coordinates.
 * @param y a pointer filled with the y coordinate in render coordinates.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.SetLogicalPresentation
 * @sa Renderer.SetScale
 */
inline FPoint RenderCoordinatesFromWindow(RendererParam renderer,
                                          const FPointRaw& window_coord)
{
  FPoint p;
  CheckError(SDL_RenderCoordinatesFromWindow(
    renderer, window_coord.x, window_coord.y, &p.x, &p.y));
  return p;
}

inline FPoint Renderer::RenderCoordinatesFromWindow(
  const FPointRaw& window_coord) const
{
  return SDL::RenderCoordinatesFromWindow(m_resource, window_coord);
}

/**
 * Get a point in window coordinates when given a point in render coordinates.
 *
 * This takes into account several states:
 *
 * - The window dimensions.
 * - The logical presentation settings (Renderer.SetLogicalPresentation)
 * - The scale (Renderer.SetScale)
 * - The viewport (Renderer.SetViewport)
 *
 * @param renderer the rendering context.
 * @param x the x coordinate in render coordinates.
 * @param y the y coordinate in render coordinates.
 * @param window_x a pointer filled with the x coordinate in window
 *                 coordinates.
 * @param window_y a pointer filled with the y coordinate in window
 *                 coordinates.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.SetLogicalPresentation
 * @sa Renderer.SetScale
 * @sa Renderer.SetViewport
 */
inline FPoint RenderCoordinatesToWindow(RendererParam renderer,
                                        const FPointRaw& coord)
{
  FPoint p;
  CheckError(
    SDL_RenderCoordinatesToWindow(renderer, coord.x, coord.y, &p.x, &p.y));
  return p;
}

inline FPoint Renderer::RenderCoordinatesToWindow(const FPointRaw& coord) const
{
  return SDL::RenderCoordinatesToWindow(m_resource, coord);
}

/**
 * Convert the coordinates in an event to render coordinates.
 *
 * This takes into account several states:
 *
 * - The window dimensions.
 * - The logical presentation settings (Renderer.SetLogicalPresentation)
 * - The scale (Renderer.SetScale)
 * - The viewport (Renderer.SetViewport)
 *
 * Various event types are converted with this function: mouse, touch, pen,
 * etc.
 *
 * Touch coordinates are converted from normalized coordinates in the window
 * to non-normalized rendering coordinates.
 *
 * Relative mouse coordinates (xrel and yrel event fields) are _also_
 * converted. Applications that do not want these fields converted should use
 * Renderer.RenderCoordinatesFromWindow() on the specific event fields instead
 * of converting the entire event structure.
 *
 * Once converted, coordinates may be outside the rendering area.
 *
 * @param renderer the rendering context.
 * @param event the event to modify.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.RenderCoordinatesFromWindow
 */
inline void ConvertEventToRenderCoordinates(RendererParam renderer,
                                            Event* event)
{
  CheckError(SDL_ConvertEventToRenderCoordinates(renderer, event));
}

inline void Renderer::ConvertEventToRenderCoordinates(Event* event) const
{
  SDL::ConvertEventToRenderCoordinates(m_resource, event);
}

/**
 * Set the drawing area for rendering on the current target.
 *
 * Drawing will clip to this area (separately from any clipping done with
 * Renderer.SetClipRect), and the top left of the area will become coordinate
 * (0, 0) for future drawing commands.
 *
 * The area's width and height must be >= 0.
 *
 * Each render target has its own viewport. This function sets the viewport
 * for the current render target.
 *
 * @param renderer the rendering context.
 * @param rect the Rect structure representing the drawing area, or nullptr
 *             to set the viewport to the entire target.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.GetViewport
 * @sa Renderer.IsViewportSet
 */
inline void SetRenderViewport(RendererParam renderer,
                              OptionalRef<const RectRaw> rect)
{
  CheckError(SDL_SetRenderViewport(renderer, rect));
}

inline void Renderer::SetViewport(OptionalRef<const RectRaw> rect)
{
  SDL::SetRenderViewport(m_resource, rect);
}

/**
 * Get the drawing area for the current target.
 *
 * Each render target has its own viewport. This function gets the viewport
 * for the current render target.
 *
 * @param renderer the rendering context.
 * @param rect an Rect structure filled in with the current drawing area.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.IsViewportSet
 * @sa Renderer.SetViewport
 */
inline Rect GetRenderViewport(RendererParam renderer)
{
  Rect rect;
  CheckError(SDL_GetRenderViewport(renderer, &rect));
  return rect;
}

inline Rect Renderer::GetViewport() const
{
  return SDL::GetRenderViewport(m_resource);
}

/**
 * Return whether an explicit rectangle was set as the viewport.
 *
 * This is useful if you're saving and restoring the viewport and want to know
 * whether you should restore a specific rectangle or nullptr.
 *
 * Each render target has its own viewport. This function checks the viewport
 * for the current render target.
 *
 * @param renderer the rendering context.
 * @returns true if the viewport was set to a specific rectangle, or false if
 *          it was set to nullptr (the entire target).
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.GetViewport
 * @sa Renderer.SetViewport
 */
inline bool RenderViewportSet(RendererParam renderer)
{
  return SDL_RenderViewportSet(renderer);
}

inline bool Renderer::IsViewportSet() const
{
  return SDL::RenderViewportSet(m_resource);
}

/**
 * Get the safe area for rendering within the current viewport.
 *
 * Some devices have portions of the screen which are partially obscured or
 * not interactive, possibly due to on-screen controls, curved edges, camera
 * notches, TV overscan, etc. This function provides the area of the current
 * viewport which is safe to have interactible content. You should continue
 * rendering into the rest of the render target, but it should not contain
 * visually important or interactible content.
 *
 * @param renderer the rendering context.
 * @param rect a pointer filled in with the area that is safe for interactive
 *             content.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Rect GetRenderSafeArea(RendererParam renderer)
{
  Rect rect;
  CheckError(SDL_GetRenderSafeArea(renderer, &rect));
  return rect;
}

inline Rect Renderer::GetSafeArea() const
{
  return SDL::GetRenderSafeArea(m_resource);
}

/**
 * Set the clip rectangle for rendering on the specified target.
 *
 * Each render target has its own clip rectangle. This function sets the
 * cliprect for the current render target.
 *
 * @param renderer the rendering context.
 * @param rect an Rect structure representing the clip area, relative to
 *             the viewport, or nullptr to disable clipping.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.GetClipRect
 * @sa Renderer.IsClipEnabled
 */
inline void SetRenderClipRect(RendererParam renderer,
                              OptionalRef<const RectRaw> rect)
{
  CheckError(SDL_SetRenderClipRect(renderer, rect));
}

inline void Renderer::SetClipRect(OptionalRef<const RectRaw> rect)
{
  SDL::SetRenderClipRect(m_resource, rect);
}

/**
 * Get the clip rectangle for the current target.
 *
 * Each render target has its own clip rectangle. This function gets the
 * cliprect for the current render target.
 *
 * @param renderer the rendering context.
 * @param rect an Rect structure filled in with the current clipping area
 *             or an empty rectangle if clipping is disabled.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.IsClipEnabled
 * @sa Renderer.SetClipRect
 */
inline Rect GetRenderClipRect(RendererParam renderer)
{
  Rect rect;
  CheckError(SDL_GetRenderClipRect(renderer, &rect));
  return rect;
}

inline Rect Renderer::GetClipRect() const
{
  return SDL::GetRenderClipRect(m_resource);
}

/**
 * Get whether clipping is enabled on the given render target.
 *
 * Each render target has its own clip rectangle. This function checks the
 * cliprect for the current render target.
 *
 * @param renderer the rendering context.
 * @returns true if clipping is enabled or false if not; call GetError()
 *          for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.GetClipRect
 * @sa Renderer.SetClipRect
 */
inline bool RenderClipEnabled(RendererParam renderer)
{
  return SDL_RenderClipEnabled(renderer);
}

inline bool Renderer::IsClipEnabled() const
{
  return SDL::RenderClipEnabled(m_resource);
}

/**
 * Set the drawing scale for rendering on the current target.
 *
 * The drawing coordinates are scaled by the x/y scaling factors before they
 * are used by the renderer. This allows resolution independent drawing with a
 * single coordinate system.
 *
 * If this results in scaling or subpixel drawing by the rendering backend, it
 * will be handled using the appropriate quality hints. For best results use
 * integer scaling factors.
 *
 * Each render target has its own scale. This function sets the scale for the
 * current render target.
 *
 * @param renderer the rendering context.
 * @param scaleX the horizontal scaling factor.
 * @param scaleY the vertical scaling factor.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.GetScale
 */
inline void SetRenderScale(RendererParam renderer, const FPointRaw& scale)
{
  CheckError(SDL_SetRenderScale(renderer, scale.x, scale.y));
}

inline void Renderer::SetScale(const FPointRaw& scale)
{
  SDL::SetRenderScale(m_resource, scale);
}

/**
 * Get the drawing scale for the current target.
 *
 * Each render target has its own scale. This function gets the scale for the
 * current render target.
 *
 * @param renderer the rendering context.
 * @param scaleX a pointer filled in with the horizontal scaling factor.
 * @param scaleY a pointer filled in with the vertical scaling factor.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.SetScale
 */
inline void GetRenderScale(RendererParam renderer, float* scaleX, float* scaleY)
{
  CheckError(SDL_GetRenderScale(renderer, scaleX, scaleY));
}

inline void Renderer::GetScale(float* scaleX, float* scaleY) const
{
  SDL::GetRenderScale(m_resource, scaleX, scaleY);
}

/**
 * Set the color used for drawing operations.
 *
 * Set the color for drawing or filling rectangles, lines, and points, and for
 * Renderer.RenderClear().
 *
 * @param renderer the rendering context.
 * @param r the red value used to draw on the rendering target.
 * @param g the green value used to draw on the rendering target.
 * @param b the blue value used to draw on the rendering target.
 * @param a the alpha value used to draw on the rendering target; usually
 *          `ALPHA_OPAQUE` (255). Use Renderer.SetDrawBlendMode to
 *          specify how the alpha channel is used.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.GetDrawColor
 * @sa Renderer.SetDrawColorFloat
 */
inline void SetRenderDrawColor(RendererParam renderer, ColorRaw c)
{
  CheckError(SDL_SetRenderDrawColor(renderer, c.r, c.g, c.b, c.a));
}

inline void Renderer::SetDrawColor(ColorRaw c)
{
  SDL::SetRenderDrawColor(m_resource, c);
}

/**
 * Set the color used for drawing operations (Rect, Line and Clear).
 *
 * Set the color for drawing or filling rectangles, lines, and points, and for
 * Renderer.RenderClear().
 *
 * @param renderer the rendering context.
 * @param r the red value used to draw on the rendering target.
 * @param g the green value used to draw on the rendering target.
 * @param b the blue value used to draw on the rendering target.
 * @param a the alpha value used to draw on the rendering target. Use
 *          Renderer.SetDrawBlendMode to specify how the alpha channel is
 *          used.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.GetDrawColorFloat
 * @sa Renderer.SetDrawColor
 */
inline void SetRenderDrawColorFloat(RendererParam renderer, const FColorRaw& c)
{
  CheckError(SDL_SetRenderDrawColorFloat(renderer, c.r, c.g, c.b, c.a));
}

inline void Renderer::SetDrawColorFloat(const FColorRaw& c)
{
  SDL::SetRenderDrawColorFloat(m_resource, c);
}

/**
 * Get the color used for drawing operations (Rect, Line and Clear).
 *
 * @param renderer the rendering context.
 * @param r a pointer filled in with the red value used to draw on the
 *          rendering target.
 * @param g a pointer filled in with the green value used to draw on the
 *          rendering target.
 * @param b a pointer filled in with the blue value used to draw on the
 *          rendering target.
 * @param a a pointer filled in with the alpha value used to draw on the
 *          rendering target; usually `ALPHA_OPAQUE` (255).
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.GetDrawColorFloat
 * @sa Renderer.SetDrawColor
 */
inline void GetRenderDrawColor(RendererParam renderer,
                               Uint8* r,
                               Uint8* g,
                               Uint8* b,
                               Uint8* a)
{
  CheckError(SDL_GetRenderDrawColor(renderer, r, g, b, a));
}

inline void Renderer::GetDrawColor(Uint8* r, Uint8* g, Uint8* b, Uint8* a) const
{
  SDL::GetRenderDrawColor(m_resource, r, g, b, a);
}

/**
 * Get the color used for drawing operations (Rect, Line and Clear).
 *
 * @param renderer the rendering context.
 * @param r a pointer filled in with the red value used to draw on the
 *          rendering target.
 * @param g a pointer filled in with the green value used to draw on the
 *          rendering target.
 * @param b a pointer filled in with the blue value used to draw on the
 *          rendering target.
 * @param a a pointer filled in with the alpha value used to draw on the
 *          rendering target.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.SetDrawColorFloat
 * @sa Renderer.GetDrawColor
 */
inline void GetRenderDrawColorFloat(RendererParam renderer,
                                    float* r,
                                    float* g,
                                    float* b,
                                    float* a)
{
  CheckError(SDL_GetRenderDrawColorFloat(renderer, r, g, b, a));
}

inline void Renderer::GetDrawColorFloat(float* r,
                                        float* g,
                                        float* b,
                                        float* a) const
{
  SDL::GetRenderDrawColorFloat(m_resource, r, g, b, a);
}

/**
 * Set the color scale used for render operations.
 *
 * The color scale is an additional scale multiplied into the pixel color
 * value while rendering. This can be used to adjust the brightness of colors
 * during HDR rendering, or changing HDR video brightness when playing on an
 * SDR display.
 *
 * The color scale does not affect the alpha channel, only the color
 * brightness.
 *
 * @param renderer the rendering context.
 * @param scale the color scale value.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.GetColorScale
 */
inline void SetRenderColorScale(RendererParam renderer, float scale)
{
  CheckError(SDL_SetRenderColorScale(renderer, scale));
}

inline void Renderer::SetColorScale(float scale)
{
  SDL::SetRenderColorScale(m_resource, scale);
}

/**
 * Get the color scale used for render operations.
 *
 * @param renderer the rendering context.
 * @param scale a pointer filled in with the current color scale value.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.SetColorScale
 */
inline float GetRenderColorScale(RendererParam renderer)
{
  float scale;
  CheckError(SDL_GetRenderColorScale(renderer, &scale));
  return scale;
}

inline float Renderer::GetColorScale() const
{
  return SDL::GetRenderColorScale(m_resource);
}

/**
 * Set the blend mode used for drawing operations (Fill and Line).
 *
 * If the blend mode is not supported, the closest supported mode is chosen.
 *
 * @param renderer the rendering context.
 * @param blendMode the BlendMode to use for blending.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.GetDrawBlendMode
 */
inline void SetRenderDrawBlendMode(RendererParam renderer, BlendMode blendMode)
{
  CheckError(SDL_SetRenderDrawBlendMode(renderer, blendMode));
}

inline void Renderer::SetDrawBlendMode(BlendMode blendMode)
{
  SDL::SetRenderDrawBlendMode(m_resource, blendMode);
}

/**
 * Get the blend mode used for drawing operations.
 *
 * @param renderer the rendering context.
 * @param blendMode a pointer filled in with the current BlendMode.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.SetDrawBlendMode
 */
inline BlendMode GetRenderDrawBlendMode(RendererParam renderer)
{
  BlendMode blendMode;
  CheckError(SDL_GetRenderDrawBlendMode(renderer, &blendMode));
  return blendMode;
}

inline BlendMode Renderer::GetDrawBlendMode() const
{
  return SDL::GetRenderDrawBlendMode(m_resource);
}

/**
 * Clear the current rendering target with the drawing color.
 *
 * This function clears the entire rendering target, ignoring the viewport and
 * the clip rectangle. Note, that clearing will also set/fill all pixels of
 * the rendering target to current renderer draw color, so make sure to invoke
 * Renderer.SetDrawColor() when needed.
 *
 * @param renderer the rendering context.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.SetDrawColor
 */
inline void RenderClear(RendererParam renderer)
{
  CheckError(SDL_RenderClear(renderer));
}

inline void Renderer::RenderClear() { SDL::RenderClear(m_resource); }

/**
 * Draw a point on the current rendering target at subpixel precision.
 *
 * @param renderer the renderer which should draw a point.
 * @param x the x coordinate of the point.
 * @param y the y coordinate of the point.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.RenderPoints
 */
inline void RenderPoint(RendererParam renderer, const FPointRaw& p)
{
  CheckError(SDL_RenderPoint(renderer, p.x, p.y));
}

inline void Renderer::RenderPoint(const FPointRaw& p)
{
  SDL::RenderPoint(m_resource, p);
}

/**
 * Draw multiple points on the current rendering target at subpixel precision.
 *
 * @param renderer the renderer which should draw multiple points.
 * @param points the points to draw.
 * @param count the number of points to draw.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.RenderPoint
 */
inline void RenderPoints(RendererParam renderer,
                         SpanRef<const FPointRaw> points)
{
  CheckError(SDL_RenderPoints(renderer, points.data(), points.size()));
}

inline void Renderer::RenderPoints(SpanRef<const FPointRaw> points)
{
  SDL::RenderPoints(m_resource, points);
}

/**
 * Draw a line on the current rendering target at subpixel precision.
 *
 * @param renderer the renderer which should draw a line.
 * @param x1 the x coordinate of the start point.
 * @param y1 the y coordinate of the start point.
 * @param x2 the x coordinate of the end point.
 * @param y2 the y coordinate of the end point.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.RenderLines
 */
inline void RenderLine(RendererParam renderer,
                       const FPointRaw& p1,
                       const FPointRaw& p2)
{
  CheckError(SDL_RenderLine(renderer, p1.x, p1.y, p2.x, p2.y));
}

inline void Renderer::RenderLine(const FPointRaw& p1, const FPointRaw& p2)
{
  SDL::RenderLine(m_resource, p1, p2);
}

/**
 * Draw a series of connected lines on the current rendering target at
 * subpixel precision.
 *
 * @param renderer the renderer which should draw multiple lines.
 * @param points the points along the lines.
 * @param count the number of points, drawing count-1 lines.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.RenderLine
 */
inline void RenderLines(RendererParam renderer, SpanRef<const FPointRaw> points)
{
  CheckError(SDL_RenderLines(renderer, points.data(), points.size()));
}

inline void Renderer::RenderLines(SpanRef<const FPointRaw> points)
{
  SDL::RenderLines(m_resource, points);
}

/**
 * Draw a rectangle on the current rendering target at subpixel precision.
 *
 * @param renderer the renderer which should draw a rectangle.
 * @param rect a pointer to the destination rectangle, or nullptr to outline the
 *             entire rendering target.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.RenderRects
 */
inline void RenderRect(RendererParam renderer, OptionalRef<const FRectRaw> rect)
{
  CheckError(SDL_RenderRect(renderer, rect));
}

inline void Renderer::RenderRect(OptionalRef<const FRectRaw> rect)
{
  SDL::RenderRect(m_resource, rect);
}

/**
 * Draw some number of rectangles on the current rendering target at subpixel
 * precision.
 *
 * @param renderer the renderer which should draw multiple rectangles.
 * @param rects a pointer to an array of destination rectangles.
 * @param count the number of rectangles.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.RenderRect
 */
inline void RenderRects(RendererParam renderer, SpanRef<const FRectRaw> rects)
{
  CheckError(SDL_RenderRects(renderer, rects.data(), rects.size()));
}

inline void Renderer::RenderRects(SpanRef<const FRectRaw> rects)
{
  SDL::RenderRects(m_resource, rects);
}

/**
 * Fill a rectangle on the current rendering target with the drawing color at
 * subpixel precision.
 *
 * @param renderer the renderer which should fill a rectangle.
 * @param rect a pointer to the destination rectangle, or nullptr for the entire
 *             rendering target.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.RenderFillRects
 */
inline void RenderFillRect(RendererParam renderer,
                           OptionalRef<const FRectRaw> rect)
{
  CheckError(SDL_RenderFillRect(renderer, rect));
}

inline void Renderer::RenderFillRect(OptionalRef<const FRectRaw> rect)
{
  SDL::RenderFillRect(m_resource, rect);
}

/**
 * Fill some number of rectangles on the current rendering target with the
 * drawing color at subpixel precision.
 *
 * @param renderer the renderer which should fill multiple rectangles.
 * @param rects a pointer to an array of destination rectangles.
 * @param count the number of rectangles.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.RenderFillRect
 */
inline void RenderFillRects(RendererParam renderer,
                            SpanRef<const FRectRaw> rects)
{
  CheckError(SDL_RenderFillRects(renderer, rects.data(), rects.size()));
}

inline void Renderer::RenderFillRects(SpanRef<const FRectRaw> rects)
{
  SDL::RenderFillRects(m_resource, rects);
}

/**
 * Copy a portion of the texture to the current rendering target at subpixel
 * precision.
 *
 * @param renderer the renderer which should copy parts of a texture.
 * @param texture the source texture.
 * @param srcrect a pointer to the source rectangle, or nullptr for the entire
 *                texture.
 * @param dstrect a pointer to the destination rectangle, or nullptr for the
 *                entire rendering target.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.RenderTextureRotated
 * @sa Renderer.RenderTextureTiled
 */
inline void RenderTexture(RendererParam renderer,
                          TextureParam texture,
                          OptionalRef<const FRectRaw> srcrect,
                          OptionalRef<const FRectRaw> dstrect)
{
  CheckError(SDL_RenderTexture(renderer, texture, srcrect, dstrect));
}

inline void Renderer::RenderTexture(TextureParam texture,
                                    OptionalRef<const FRectRaw> srcrect,
                                    OptionalRef<const FRectRaw> dstrect)
{
  SDL::RenderTexture(m_resource, texture, srcrect, dstrect);
}

/**
 * Copy a portion of the source texture to the current rendering target, with
 * rotation and flipping, at subpixel precision.
 *
 * @param renderer the renderer which should copy parts of a texture.
 * @param texture the source texture.
 * @param srcrect a pointer to the source rectangle, or nullptr for the entire
 *                texture.
 * @param dstrect a pointer to the destination rectangle, or nullptr for the
 *                entire rendering target.
 * @param angle an angle in degrees that indicates the rotation that will be
 *              applied to dstrect, rotating it in a clockwise direction.
 * @param center a pointer to a point indicating the point around which
 *               dstrect will be rotated (if nullptr, rotation will be done
 *               around dstrect.w/2, dstrect.h/2).
 * @param flip an FlipMode value stating which flipping actions should be
 *             performed on the texture.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.RenderTexture
 */
inline void RenderTextureRotated(RendererParam renderer,
                                 TextureParam texture,
                                 OptionalRef<const FRectRaw> srcrect,
                                 OptionalRef<const FRectRaw> dstrect,
                                 double angle,
                                 OptionalRef<const FPointRaw> center,
                                 FlipMode flip)
{
  CheckError(SDL_RenderTextureRotated(
    renderer, texture, srcrect, dstrect, angle, center, flip));
}

inline void Renderer::RenderTextureRotated(TextureParam texture,
                                           OptionalRef<const FRectRaw> srcrect,
                                           OptionalRef<const FRectRaw> dstrect,
                                           double angle,
                                           OptionalRef<const FPointRaw> center,
                                           FlipMode flip)
{
  SDL::RenderTextureRotated(
    m_resource, texture, srcrect, dstrect, angle, center, flip);
}

/**
 * Copy a portion of the source texture to the current rendering target, with
 * affine transform, at subpixel precision.
 *
 * @param renderer the renderer which should copy parts of a texture.
 * @param texture the source texture.
 * @param srcrect a pointer to the source rectangle, or nullptr for the entire
 *                texture.
 * @param origin a pointer to a point indicating where the top-left corner of
 *               srcrect should be mapped to, or nullptr for the rendering
 *               target's origin.
 * @param right a pointer to a point indicating where the top-right corner of
 *              srcrect should be mapped to, or nullptr for the rendering
 *              target's top-right corner.
 * @param down a pointer to a point indicating where the bottom-left corner of
 *             srcrect should be mapped to, or nullptr for the rendering
 * target's bottom-left corner.
 * @throws Error on failure.
 *
 * @threadsafety You may only call this function from the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.RenderTexture
 */
inline void RenderTextureAffine(RendererParam renderer,
                                TextureParam texture,
                                OptionalRef<const FRectRaw> srcrect,
                                OptionalRef<const FPointRaw> origin,
                                OptionalRef<const FPointRaw> right,
                                OptionalRef<const FPointRaw> down)
{
  CheckError(
    SDL_RenderTextureAffine(renderer, texture, srcrect, origin, right, down));
}

inline void Renderer::RenderTextureAffine(TextureParam texture,
                                          OptionalRef<const FRectRaw> srcrect,
                                          OptionalRef<const FPointRaw> origin,
                                          OptionalRef<const FPointRaw> right,
                                          OptionalRef<const FPointRaw> down)
{
  SDL::RenderTextureAffine(m_resource, texture, srcrect, origin, right, down);
}

/**
 * Tile a portion of the texture to the current rendering target at subpixel
 * precision.
 *
 * The pixels in `srcrect` will be repeated as many times as needed to
 * completely fill `dstrect`.
 *
 * @param renderer the renderer which should copy parts of a texture.
 * @param texture the source texture.
 * @param srcrect a pointer to the source rectangle, or nullptr for the entire
 *                texture.
 * @param scale the scale used to transform srcrect into the destination
 *              rectangle, e.g. a 32x32 texture with a scale of 2 would fill
 *              64x64 tiles.
 * @param dstrect a pointer to the destination rectangle, or nullptr for the
 *                entire rendering target.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.RenderTexture
 */
inline void RenderTextureTiled(RendererParam renderer,
                               TextureParam texture,
                               OptionalRef<const FRectRaw> srcrect,
                               float scale,
                               OptionalRef<const FRectRaw> dstrect)
{
  CheckError(
    SDL_RenderTextureTiled(renderer, texture, srcrect, scale, dstrect));
}

inline void Renderer::RenderTextureTiled(TextureParam texture,
                                         OptionalRef<const FRectRaw> srcrect,
                                         float scale,
                                         OptionalRef<const FRectRaw> dstrect)
{
  SDL::RenderTextureTiled(m_resource, texture, srcrect, scale, dstrect);
}

/**
 * Perform a scaled copy using the 9-grid algorithm to the current rendering
 * target at subpixel precision.
 *
 * The pixels in the texture are split into a 3x3 grid, using the different
 * corner sizes for each corner, and the sides and center making up the
 * remaining pixels. The corners are then scaled using `scale` and fit into
 * the corners of the destination rectangle. The sides and center are then
 * stretched into place to cover the remaining destination rectangle.
 *
 * @param renderer the renderer which should copy parts of a texture.
 * @param texture the source texture.
 * @param srcrect the Rect structure representing the rectangle to be used
 *                for the 9-grid, or nullptr to use the entire texture.
 * @param left_width the width, in pixels, of the left corners in `srcrect`.
 * @param right_width the width, in pixels, of the right corners in `srcrect`.
 * @param top_height the height, in pixels, of the top corners in `srcrect`.
 * @param bottom_height the height, in pixels, of the bottom corners in
 *                      `srcrect`.
 * @param scale the scale used to transform the corner of `srcrect` into the
 *              corner of `dstrect`, or 0.0f for an unscaled copy.
 * @param dstrect a pointer to the destination rectangle, or nullptr for the
 *                entire rendering target.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.RenderTexture
 */
inline void RenderTexture9Grid(RendererParam renderer,
                               TextureParam texture,
                               OptionalRef<const FRectRaw> srcrect,
                               float left_width,
                               float right_width,
                               float top_height,
                               float bottom_height,
                               float scale,
                               OptionalRef<const FRectRaw> dstrect)
{
  CheckError(SDL_RenderTexture9Grid(renderer,
                                    texture,
                                    srcrect,
                                    left_width,
                                    right_width,
                                    top_height,
                                    bottom_height,
                                    scale,
                                    dstrect));
}

inline void Renderer::RenderTexture9Grid(TextureParam texture,
                                         OptionalRef<const FRectRaw> srcrect,
                                         float left_width,
                                         float right_width,
                                         float top_height,
                                         float bottom_height,
                                         float scale,
                                         OptionalRef<const FRectRaw> dstrect)
{
  SDL::RenderTexture9Grid(m_resource,
                          texture,
                          srcrect,
                          left_width,
                          right_width,
                          top_height,
                          bottom_height,
                          scale,
                          dstrect);
}

/**
 * Render a list of triangles, optionally using a texture and indices into the
 * vertex array Color and alpha modulation is done per vertex
 * (Texture.SetColorMod and Texture.SetAlphaMod are ignored).
 *
 * @param renderer the rendering context.
 * @param texture (optional) The SDL texture to use.
 * @param vertices vertices.
 * @param num_vertices number of vertices.
 * @param indices (optional) An array of integer indices into the 'vertices'
 *                array, if nullptr all vertices will be rendered in sequential
 *                order.
 * @param num_indices number of indices.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.RenderGeometryRaw
 */
inline void RenderGeometry(RendererParam renderer,
                           TextureParam texture,
                           std::span<const Vertex> vertices,
                           std::span<const int> indices)
{
  CheckError(SDL_RenderGeometry(renderer,
                                texture,
                                vertices.data(),
                                vertices.size(),
                                indices.data(),
                                indices.size()));
}

inline void Renderer::RenderGeometry(TextureParam texture,
                                     std::span<const Vertex> vertices,
                                     std::span<const int> indices)
{
  SDL::RenderGeometry(m_resource, texture, vertices, indices);
}

/**
 * Render a list of triangles, optionally using a texture and indices into the
 * vertex arrays Color and alpha modulation is done per vertex
 * (Texture.SetColorMod and Texture.SetAlphaMod are ignored).
 *
 * @param renderer the rendering context.
 * @param texture (optional) The SDL texture to use.
 * @param xy vertex positions.
 * @param xy_stride byte size to move from one element to the next element.
 * @param color vertex colors (as FColor).
 * @param color_stride byte size to move from one element to the next element.
 * @param uv vertex normalized texture coordinates.
 * @param uv_stride byte size to move from one element to the next element.
 * @param num_vertices number of vertices.
 * @param indices (optional) An array of indices into the 'vertices' arrays,
 *                if nullptr all vertices will be rendered in sequential order.
 * @param num_indices number of indices.
 * @param size_indices index size: 1 (byte), 2 (short), 4 (int).
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.RenderGeometry
 */
inline void RenderGeometryRaw(RendererParam renderer,
                              TextureParam texture,
                              const float* xy,
                              int xy_stride,
                              const FColor* color,
                              int color_stride,
                              const float* uv,
                              int uv_stride,
                              int num_vertices,
                              const void* indices,
                              int num_indices,
                              int size_indices)
{
  CheckError(SDL_RenderGeometryRaw(renderer,
                                   texture,
                                   xy,
                                   xy_stride,
                                   color,
                                   color_stride,
                                   uv,
                                   uv_stride,
                                   num_vertices,
                                   indices,
                                   num_indices,
                                   size_indices));
}

inline void Renderer::RenderGeometryRaw(TextureParam texture,
                                        const float* xy,
                                        int xy_stride,
                                        const FColor* color,
                                        int color_stride,
                                        const float* uv,
                                        int uv_stride,
                                        int num_vertices,
                                        const void* indices,
                                        int num_indices,
                                        int size_indices)
{
  SDL::RenderGeometryRaw(m_resource,
                         texture,
                         xy,
                         xy_stride,
                         color,
                         color_stride,
                         uv,
                         uv_stride,
                         num_vertices,
                         indices,
                         num_indices,
                         size_indices);
}

/**
 * Read pixels from the current rendering target.
 *
 * The returned surface contains pixels inside the desired area clipped to the
 * current viewport, and should be freed with Surface.Destroy().
 *
 * Note that this returns the actual pixels on the screen, so if you are using
 * logical presentation you should use Renderer.GetLogicalPresentationRect()
 * to get the area containing your content.
 *
 * **WARNING**: This is a very slow operation, and should not be used
 * frequently. If you're using this on the main rendering target, it should be
 * called after rendering and before Renderer.Present().
 *
 * @param renderer the rendering context.
 * @param rect an Rect structure representing the area to read, which will
 *             be clipped to the current viewport, or nullptr for the entire
 *             viewport.
 * @returns a new Surface on success.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline Surface RenderReadPixels(RendererParam renderer,
                                OptionalRef<const RectRaw> rect = {})
{
  return Surface{CheckError(SDL_RenderReadPixels(renderer, rect))};
}

inline Surface Renderer::ReadPixels(OptionalRef<const RectRaw> rect) const
{
  return SDL::RenderReadPixels(m_resource, rect);
}

/**
 * Update the screen with any rendering performed since the previous call.
 *
 * SDL's rendering functions operate on a backbuffer; that is, calling a
 * rendering function such as Renderer.RenderLine() does not directly put a line
 * on the screen, but rather updates the backbuffer. As such, you compose your
 * entire scene and *present* the composed backbuffer to the screen as a
 * complete picture.
 *
 * Therefore, when using SDL's rendering API, one does all drawing intended
 * for the frame, and then calls this function once per frame to present the
 * final drawing to the user.
 *
 * The backbuffer should be considered invalidated after each present; do not
 * assume that previous contents will exist between frames. You are strongly
 * encouraged to call Renderer.RenderClear() to initialize the backbuffer before
 * starting each new frame's drawing, even if you plan to overwrite every
 * pixel.
 *
 * Please note, that in case of rendering to a texture - there is **no need**
 * to call `Renderer.Present` after drawing needed objects to a texture, and
 * should not be done; you are only required to change back the rendering
 * target to default via `Renderer.SetTarget(renderer, nullptr)` afterwards, as
 * textures by themselves do not have a concept of backbuffers. Calling
 * Renderer.Present while rendering to a texture will still update the screen
 * with any current drawing that has been done _to the window itself_.
 *
 * @param renderer the rendering context.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.Renderer
 * @sa Renderer.RenderClear
 * @sa Renderer.RenderFillRect
 * @sa Renderer.RenderFillRects
 * @sa Renderer.RenderLine
 * @sa Renderer.RenderLines
 * @sa Renderer.RenderPoint
 * @sa Renderer.RenderPoints
 * @sa Renderer.RenderRect
 * @sa Renderer.RenderRects
 * @sa Renderer.SetDrawBlendMode
 * @sa Renderer.SetDrawColor
 */
inline void RenderPresent(RendererParam renderer)
{
  CheckError(SDL_RenderPresent(renderer));
}

inline void Renderer::Present() { SDL::RenderPresent(m_resource); }

/**
 * Destroy the specified texture.
 *
 * Passing nullptr or an otherwise invalid texture will set the SDL error
 * message to "Invalid texture".
 *
 * @param texture the texture to destroy.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Texture.Texture
 * @sa Texture.Texture
 */
inline void DestroyTexture(TextureRaw texture) { SDL_DestroyTexture(texture); }

inline void Texture::Destroy()
{
  SDL_DestroyTexture(m_resource);
  m_resource = nullptr;
}

/**
 * Destroy the rendering context for a window and free all associated
 * textures.
 *
 * This should be called before destroying the associated window.
 *
 * @param renderer the rendering context.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.Renderer
 */
inline void DestroyRenderer(RendererRaw renderer)
{
  SDL_DestroyRenderer(renderer);
}

inline void Renderer::Destroy()
{
  SDL_DestroyRenderer(m_resource);
  m_resource = nullptr;
}

/**
 * Force the rendering context to flush any pending commands and state.
 *
 * You do not need to (and in fact, shouldn't) call this function unless you
 * are planning to call into OpenGL/Direct3D/Metal/whatever directly, in
 * addition to using an Renderer.
 *
 * This is for a very-specific case: if you are using SDL's render API, and
 * you plan to make OpenGL/D3D/whatever calls in addition to SDL render API
 * calls. If this applies, you should call this function between calls to
 * SDL's render API and the low-level API you're using in cooperation.
 *
 * In all other cases, you can ignore this function.
 *
 * This call makes SDL flush any pending rendering work it was queueing up to
 * do later in a single batch, and marks any internal cached state as invalid,
 * so it'll prepare all its state again later, from scratch.
 *
 * This means you do not need to save state in your rendering code to protect
 * the SDL renderer. However, there lots of arbitrary pieces of Direct3D and
 * OpenGL state that can confuse things; you should use your best judgment and
 * be prepared to make changes if specific state needs to be protected.
 *
 * @param renderer the rendering context.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void FlushRenderer(RendererParam renderer)
{
  CheckError(SDL_FlushRenderer(renderer));
}

inline void Renderer::Flush() { SDL::FlushRenderer(m_resource); }

/**
 * Get the CAMetalLayer associated with the given Metal renderer.
 *
 * This function returns `void *`, so SDL doesn't have to include Metal's
 * headers, but it can be safely cast to a `CAMetalLayer *`.
 *
 * @param renderer the renderer to query.
 * @returns a `CAMetalLayer *` on success.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.GetRenderMetalCommandEncoder
 */
inline void* GetRenderMetalLayer(RendererParam renderer)
{
  return CheckError(SDL_GetRenderMetalLayer(renderer));
}

inline void* Renderer::GetRenderMetalLayer()
{
  return SDL::GetRenderMetalLayer(m_resource);
}

/**
 * Get the Metal command encoder for the current frame.
 *
 * This function returns `void *`, so SDL doesn't have to include Metal's
 * headers, but it can be safely cast to an `id<MTLRenderCommandEncoder>`.
 *
 * This will return nullptr if Metal refuses to give SDL a drawable to render
 * to, which might happen if the window is hidden/minimized/offscreen. This
 * doesn't apply to command encoders for render targets, just the window's
 * backbuffer. Check your return values!
 *
 * @param renderer the renderer to query.
 * @returns an `id<MTLRenderCommandEncoder>` on success.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.GetRenderMetalLayer
 */
inline void* GetRenderMetalCommandEncoder(RendererParam renderer)
{
  return CheckError(SDL_GetRenderMetalCommandEncoder(renderer));
}

inline void* Renderer::GetRenderMetalCommandEncoder()
{
  return SDL::GetRenderMetalCommandEncoder(m_resource);
}

/**
 * Add a set of synchronization semaphores for the current frame.
 *
 * The Vulkan renderer will wait for `wait_semaphore` before submitting
 * rendering commands and signal `signal_semaphore` after rendering commands
 * are complete for this frame.
 *
 * This should be called each frame that you want semaphore synchronization.
 * The Vulkan renderer may have multiple frames in flight on the GPU, so you
 * should have multiple semaphores that are used for synchronization. Querying
 * prop::Renderer.VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER will give you the
 * maximum number of semaphores you'll need.
 *
 * @param renderer the rendering context.
 * @param wait_stage_mask the VkPipelineStageFlags for the wait.
 * @param wait_semaphore a VkSempahore to wait on before rendering the current
 *                       frame, or 0 if not needed.
 * @param signal_semaphore a VkSempahore that SDL will signal when rendering
 *                         for the current frame is complete, or 0 if not
 *                         needed.
 * @throws Error on failure.
 *
 * @threadsafety It is **NOT** safe to call this function from two threads at
 *               once.
 *
 * @since This function is available since SDL 3.2.0.
 */
inline void AddVulkanRenderSemaphores(RendererParam renderer,
                                      Uint32 wait_stage_mask,
                                      Sint64 wait_semaphore,
                                      Sint64 signal_semaphore)
{
  CheckError(SDL_AddVulkanRenderSemaphores(
    renderer, wait_stage_mask, wait_semaphore, signal_semaphore));
}

inline void Renderer::AddVulkanRenderSemaphores(Uint32 wait_stage_mask,
                                                Sint64 wait_semaphore,
                                                Sint64 signal_semaphore)
{
  SDL::AddVulkanRenderSemaphores(
    m_resource, wait_stage_mask, wait_semaphore, signal_semaphore);
}

/**
 * Toggle VSync of the given renderer.
 *
 * When a renderer is created, vsync defaults to SDL_RENDERER_VSYNC_DISABLED.
 *
 * The `vsync` parameter can be 1 to synchronize present with every vertical
 * refresh, 2 to synchronize present with every second vertical refresh, etc.,
 * SDL_RENDERER_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync), or
 * SDL_RENDERER_VSYNC_DISABLED to disable. Not every value is supported by
 * every driver, so you should check the return value to see whether the
 * requested setting is supported.
 *
 * @param renderer the renderer to toggle.
 * @param vsync the vertical refresh sync interval.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.GetVSync
 */
inline void SetRenderVSync(RendererParam renderer, int vsync)
{
  CheckError(SDL_SetRenderVSync(renderer, vsync));
}

inline void Renderer::SetVSync(int vsync)
{
  SDL::SetRenderVSync(m_resource, vsync);
}

#define SDL_RENDERER_VSYNC_DISABLED 0

#define SDL_RENDERER_VSYNC_ADAPTIVE (-1)

/**
 * Get VSync of the given renderer.
 *
 * @param renderer the renderer to toggle.
 * @param vsync an int filled with the current vertical refresh sync interval.
 *              See Renderer.SetVSync() for the meaning of the value.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.SetVSync
 */
inline int GetRenderVSync(RendererParam renderer)
{
  int vsync;
  CheckError(SDL_GetRenderVSync(renderer, &vsync));
  return vsync;
}

inline int Renderer::GetVSync() const
{
  return SDL::GetRenderVSync(m_resource);
}

/**
 * The size, in pixels, of a single Renderer.RenderDebugText() character.
 *
 * The font is monospaced and square, so this applies to all characters.
 *
 * @since This macro is available since SDL 3.2.0.
 *
 * @sa Renderer.RenderDebugText
 */
#define SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE 8

/**
 * Draw debug text to an Renderer.
 *
 * This function will render a string of text to an Renderer. Note that
 * this is a convenience function for debugging, with severe limitations, and
 * not intended to be used for production apps and games.
 *
 * Among these limitations:
 *
 * - It accepts UTF-8 strings, but will only renders ASCII characters.
 * - It has a single, tiny size (8x8 pixels). One can use logical presentation
 *   or scaling to adjust it, but it will be blurry.
 * - It uses a simple, hardcoded bitmap font. It does not allow different font
 *   selections and it does not support truetype, for proper scaling.
 * - It does no word-wrapping and does not treat newline characters as a line
 *   break. If the text goes out of the window, it's gone.
 *
 * For serious text rendering, there are several good options, such as
 * SDL_ttf, stb_truetype, or other external libraries.
 *
 * On first use, this will create an internal texture for rendering glyphs.
 * This texture will live until the renderer is destroyed.
 *
 * The text is drawn in the color specified by Renderer.SetDrawColor().
 *
 * @param renderer the renderer which should draw a line of text.
 * @param x the x coordinate where the top-left corner of the text will draw.
 * @param y the y coordinate where the top-left corner of the text will draw.
 * @param str the string to render.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.RenderDebugTextFormat
 * @sa SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE
 */
inline void RenderDebugText(RendererParam renderer, FPoint p, StringParam str)
{
  CheckError(SDL_RenderDebugText(renderer, p.x, p.y, str));
}

inline void Renderer::RenderDebugText(FPoint p, StringParam str)
{
  SDL::RenderDebugText(m_resource, p, std::move(str));
}

/**
 * Draw debug text to an Renderer.
 *
 * This function will render a printf()-style format string to a renderer.
 * Note that this is a convenience function for debugging, with severe
 * limitations, and is not intended to be used for production apps and games.
 *
 * For the full list of limitations and other useful information, see
 * Renderer.RenderDebugText.
 *
 * @param renderer the renderer which should draw the text.
 * @param x the x coordinate where the top-left corner of the text will draw.
 * @param y the y coordinate where the top-left corner of the text will draw.
 * @param fmt the format string to draw.
 * @param ... additional parameters matching % tokens in the `fmt` string, if
 *            any.
 * @throws Error on failure.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa Renderer.RenderDebugText
 * @sa SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE
 */
template<class... ARGS>
inline void RenderDebugTextFormat(RendererParam renderer,
                                  FPoint p,
                                  std::string_view fmt,
                                  ARGS... args)
{
  RenderDebugText(
    renderer, p, std::vformat(fmt, std::make_format_args(args...)));
}

/// @}

} // namespace SDL
#if !defined(SDL3PP_DISABLE_IMAGE) && !defined(SDL3PP_ENABLE_IMAGE) &&         \
  __has_include(<SDL3_image/SDL_image.h>)
#define SDL3PP_ENABLE_IMAGE
#endif

#if defined(SDL3PP_ENABLE_IMAGE) || defined(SDL3PP_DOC)

#include <SDL3_image/SDL_image.h>

namespace SDL {

/**
 * @defgroup CategorySDLImage Load images from several formats
 *
 * Header file for SDL_image library
 *
 * A simple library to load images of various formats as SDL surfaces
 *
 * @{
 */

// Forward decl
struct Animation;

using AnimationRaw = IMG_Animation*;

// Forward decl
struct AnimationRef;

/// Safely wrap Animation for non owning parameters
struct AnimationParam
{
  AnimationRaw value; ///< parameter's AnimationRaw

  /// Constructs from AnimationRaw
  constexpr AnimationParam(AnimationRaw value)
    : value(value)
  {
  }

  /// Constructs null/invalid
  constexpr AnimationParam(std::nullptr_t _ = nullptr)
    : value(nullptr)
  {
  }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!value; }

  /// Comparison
  constexpr auto operator<=>(const AnimationParam& other) const = default;

  /// Converts to underlying AnimationRaw
  constexpr operator AnimationRaw() const { return value; }
};

#ifdef SDL3PP_DOC

/**
 * @name Image version
 * @{
 * Printable format: "%d.%d.%d", MAJOR, MINOR, MICRO
 */
#define SDL_IMAGE_MAJOR_VERSION

#define SDL_IMAGE_MINOR_VERSION

#define SDL_IMAGE_MICRO_VERSION

/// @}

/**
 * This is the version number macro for the current SDL_image version.
 */
#define SDL_IMAGE_VERSION                                                      \
  SDL_VERSIONNUM(                                                              \
    SDL_IMAGE_MAJOR_VERSION, SDL_IMAGE_MINOR_VERSION, SDL_IMAGE_MICRO_VERSION)

/**
 * This macro will evaluate to true if compiled with SDL_image at least X.Y.Z.
 */
#define SDL_IMAGE_VERSION_ATLEAST(X, Y, Z)                                     \
  ((SDL_IMAGE_MAJOR_VERSION >= X) &&                                           \
   (SDL_IMAGE_MAJOR_VERSION > X || SDL_IMAGE_MINOR_VERSION >= Y) &&            \
   (SDL_IMAGE_MAJOR_VERSION > X || SDL_IMAGE_MINOR_VERSION > Y ||              \
    SDL_IMAGE_MICRO_VERSION >= Z))

#endif // SDL3PP_DOC

namespace IMG {

/**
 * This function gets the version of the dynamically linked SDL_image library.
 *
 * @returns SDL_image version.
 *
 * @since This function is available since SDL_image 3.0.0.
 */
inline int Version() { return IMG_Version(); }

} // namespace IMG

/**
 * Load an image from an SDL data source into a software surface.
 *
 * An Surface is a buffer of pixels in memory accessible by the CPU. Use
 * this if you plan to hand the data to something else or manipulate it
 * further in code.
 *
 * There are no guarantees about what format the new Surface data will be;
 * in many cases, SDL_image will attempt to supply a surface that exactly
 * matches the provided image, but in others it might have to convert (either
 * because the image is in a format that SDL doesn't directly support or
 * because it's compressed data that could reasonably uncompress to various
 * formats and SDL_image had to pick one). You can inspect an Surface for
 * its specifics, and use Surface.Convert to then migrate to any supported
 * format.
 *
 * If the image format supports a transparent pixel, SDL will set the colorkey
 * for the surface. You can enable RLE acceleration on the surface afterwards
 * by calling: Surface.SetColorKey(image, SDL_RLEACCEL,
 * image->format->colorkey);
 *
 * If `closeio` is true, `src` will be closed before returning, whether this
 * function succeeds or not. SDL_image reads everything it needs from `src`
 * during this call in any case.
 *
 * Even though this function accepts a file type, SDL_image may still try
 * other decoders that are capable of detecting file type from the contents of
 * the image data, but may rely on the caller-provided type string for formats
 * that it cannot autodetect. If `type` is nullptr, SDL_image will rely solely
 * on its ability to guess the format.
 *
 * There is a separate function to read files from disk without having to deal
 * with IOStream: `Surface.Surface("filename.jpg")` will call this function and
 * manage those details for you, determining the file type from the filename's
 * extension.
 *
 * There is also Surface.Surface(), which is equivalent to this function except
 * that it will rely on SDL_image to determine what type of data it is
 * loading, much like passing a nullptr for type.
 *
 * If you are using SDL's 2D rendering API, there is an equivalent call to
 * load images directly into an Texture for use by the GPU without using a
 * software surface: call LoadTextureTyped() instead.
 *
 * @param src an IOStream that data will be read from.
 * @param type a filename extension that represent this data ("BMP", "GIF",
 *             "PNG", etc).
 * @param closeio true to close/free the IOStream before returning, false
 *                to leave it open.
 * @returns a new SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa Surface.Surface
 * @sa Surface.Surface
 * @sa Surface.Destroy
 */
inline Surface LoadSurfaceTyped(IOStreamParam src,
                                StringParam type,
                                bool closeio = false)
{
  return Surface(IMG_LoadTyped_IO(src, closeio, type));
}

/**
 * Load an image from a filesystem path into a software surface.
 *
 * An Surface is a buffer of pixels in memory accessible by the CPU. Use
 * this if you plan to hand the data to something else or manipulate it
 * further in code.
 *
 * There are no guarantees about what format the new Surface data will be;
 * in many cases, SDL_image will attempt to supply a surface that exactly
 * matches the provided image, but in others it might have to convert (either
 * because the image is in a format that SDL doesn't directly support or
 * because it's compressed data that could reasonably uncompress to various
 * formats and SDL_image had to pick one). You can inspect an Surface for
 * its specifics, and use Surface.Convert to then migrate to any supported
 * format.
 *
 * If the image format supports a transparent pixel, SDL will set the colorkey
 * for the surface. You can enable RLE acceleration on the surface afterwards
 * by calling: Surface.SetColorKey(image, SDL_RLEACCEL,
 * image->format->colorkey);
 *
 * There is a separate function to read files from an IOStream, if you
 * need an i/o abstraction to provide data from anywhere instead of a simple
 * filesystem read; that function is Surface.Surface().
 *
 * If you are using SDL's 2D rendering API, there is an equivalent call to
 * load images directly into an Texture for use by the GPU without using a
 * software surface: call Texture.Texture() instead.
 *
 * @param file a path on the filesystem to load an image from.
 * @returns a new SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadSurfaceTyped
 * @sa Surface.Surface
 * @sa Surface.Destroy
 */
inline Surface LoadSurface(StringParam file) { return Surface(IMG_Load(file)); }

/**
 * Load an image from an SDL data source into a software surface.
 *
 * An Surface is a buffer of pixels in memory accessible by the CPU. Use
 * this if you plan to hand the data to something else or manipulate it
 * further in code.
 *
 * There are no guarantees about what format the new Surface data will be;
 * in many cases, SDL_image will attempt to supply a surface that exactly
 * matches the provided image, but in others it might have to convert (either
 * because the image is in a format that SDL doesn't directly support or
 * because it's compressed data that could reasonably uncompress to various
 * formats and SDL_image had to pick one). You can inspect an Surface for
 * its specifics, and use Surface.Convert to then migrate to any supported
 * format.
 *
 * If the image format supports a transparent pixel, SDL will set the colorkey
 * for the surface. You can enable RLE acceleration on the surface afterwards
 * by calling: Surface.SetColorKey(image, SDL_RLEACCEL,
 * image->format->colorkey);
 *
 * If `closeio` is true, `src` will be closed before returning, whether this
 * function succeeds or not. SDL_image reads everything it needs from `src`
 * during this call in any case.
 *
 * There is a separate function to read files from disk without having to deal
 * with IOStream: `Surface.Surface("filename.jpg")` will call this function and
 * manage those details for you, determining the file type from the filename's
 * extension.
 *
 * There is also LoadSurfaceTyped(), which is equivalent to this function
 * except a file extension (like "BMP", "JPG", etc) can be specified, in case
 * SDL_image cannot autodetect the file format.
 *
 * If you are using SDL's 2D rendering API, there is an equivalent call to
 * load images directly into an Texture for use by the GPU without using a
 * software surface: call Texture.Texture() instead.
 *
 * @param src an IOStream that data will be read from.
 * @param closeio true to close/free the IOStream before returning, false
 *                to leave it open.
 * @returns a new SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa Surface.Surface
 * @sa LoadSurfaceTyped
 * @sa Surface.Destroy
 */
inline Surface LoadSurface(IOStreamParam src, bool closeio = false)
{
  return Surface(IMG_Load_IO(src, closeio));
}

/**
 * Load an image from a filesystem path into a software surface.
 *
 * An Surface is a buffer of pixels in memory accessible by the CPU. Use
 * this if you plan to hand the data to something else or manipulate it
 * further in code.
 *
 * There are no guarantees about what format the new Surface data will be;
 * in many cases, SDL_image will attempt to supply a surface that exactly
 * matches the provided image, but in others it might have to convert (either
 * because the image is in a format that SDL doesn't directly support or
 * because it's compressed data that could reasonably uncompress to various
 * formats and SDL_image had to pick one). You can inspect an Surface for
 * its specifics, and use Surface.Convert to then migrate to any supported
 * format.
 *
 * If the image format supports a transparent pixel, SDL will set the colorkey
 * for the surface. You can enable RLE acceleration on the surface afterwards
 * by calling: Surface.SetColorKey(image, SDL_RLEACCEL,
 * image->format->colorkey);
 *
 * There is a separate function to read files from an IOStream, if you
 * need an i/o abstraction to provide data from anywhere instead of a simple
 * filesystem read; that function is Surface.Surface().
 *
 * If you are using SDL's 2D rendering API, there is an equivalent call to
 * load images directly into an Texture for use by the GPU without using a
 * software surface: call Texture.Texture() instead.
 *
 * @param file a path on the filesystem to load an image from.
 * @post a new SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadSurfaceTyped
 * @sa Surface.Surface
 * @sa Surface.Destroy
 */
inline Surface::Surface(StringParam file)
  : m_resource(IMG_Load(file))
{
}

/**
 * Load an image from an SDL data source into a software surface.
 *
 * An Surface is a buffer of pixels in memory accessible by the CPU. Use
 * this if you plan to hand the data to something else or manipulate it
 * further in code.
 *
 * There are no guarantees about what format the new Surface data will be;
 * in many cases, SDL_image will attempt to supply a surface that exactly
 * matches the provided image, but in others it might have to convert (either
 * because the image is in a format that SDL doesn't directly support or
 * because it's compressed data that could reasonably uncompress to various
 * formats and SDL_image had to pick one). You can inspect an Surface for
 * its specifics, and use Surface.Convert to then migrate to any supported
 * format.
 *
 * If the image format supports a transparent pixel, SDL will set the colorkey
 * for the surface. You can enable RLE acceleration on the surface afterwards
 * by calling: Surface.SetColorKey(image, SDL_RLEACCEL,
 * image->format->colorkey);
 *
 * If `closeio` is true, `src` will be closed before returning, whether this
 * function succeeds or not. SDL_image reads everything it needs from `src`
 * during this call in any case.
 *
 * There is a separate function to read files from disk without having to deal
 * with IOStream: `Surface.Surface("filename.jpg")` will call this function and
 * manage those details for you, determining the file type from the filename's
 * extension.
 *
 * There is also LoadSurfaceTyped(), which is equivalent to this function
 * except a file extension (like "BMP", "JPG", etc) can be specified, in case
 * SDL_image cannot autodetect the file format.
 *
 * If you are using SDL's 2D rendering API, there is an equivalent call to
 * load images directly into an Texture for use by the GPU without using a
 * software surface: call Texture.Texture() instead.
 *
 * @param src an IOStream that data will be read from.
 * @param closeio true to close/free the IOStream before returning, false
 *                to leave it open.
 * @post a new SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa Surface.Surface
 * @sa LoadSurfaceTyped
 * @sa Surface.Destroy
 */
inline Surface::Surface(IOStreamParam src, bool closeio)
  : m_resource(IMG_Load_IO(src, closeio))
{
}

/**
 * Load an image from a filesystem path into a GPU texture.
 *
 * An Texture represents an image in GPU memory, usable by SDL's 2D Render
 * API. This can be significantly more efficient than using a CPU-bound
 * Surface if you don't need to manipulate the image directly after
 * loading it.
 *
 * If the loaded image has transparency or a colorkey, a texture with an alpha
 * channel will be created. Otherwise, SDL_image will attempt to create an
 * Texture in the most format that most reasonably represents the image
 * data (but in many cases, this will just end up being 32-bit RGB or 32-bit
 * RGBA).
 *
 * There is a separate function to read files from an IOStream, if you
 * need an i/o abstraction to provide data from anywhere instead of a simple
 * filesystem read; that function is Texture.Texture().
 *
 * If you would rather decode an image to an Surface (a buffer of pixels
 * in CPU memory), call Surface.Surface() instead.
 *
 * @param renderer the Renderer to use to create the GPU texture.
 * @param file a path on the filesystem to load an image from.
 * @returns a new texture, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadTextureTyped
 * @sa Texture.Texture
 */
inline Texture LoadTexture(RendererParam renderer, StringParam file)
{
  return Texture(IMG_LoadTexture(renderer, file));
}

/**
 * Load an image from an SDL data source into a GPU texture.
 *
 * An Texture represents an image in GPU memory, usable by SDL's 2D Render
 * API. This can be significantly more efficient than using a CPU-bound
 * Surface if you don't need to manipulate the image directly after
 * loading it.
 *
 * If the loaded image has transparency or a colorkey, a texture with an alpha
 * channel will be created. Otherwise, SDL_image will attempt to create an
 * Texture in the most format that most reasonably represents the image
 * data (but in many cases, this will just end up being 32-bit RGB or 32-bit
 * RGBA).
 *
 * If `closeio` is true, `src` will be closed before returning, whether this
 * function succeeds or not. SDL_image reads everything it needs from `src`
 * during this call in any case.
 *
 * There is a separate function to read files from disk without having to deal
 * with IOStream: `Texture.Texture(renderer, "filename.jpg")` will call
 * this function and manage those details for you, determining the file type
 * from the filename's extension.
 *
 * There is also LoadTextureTyped(), which is equivalent to this
 * function except a file extension (like "BMP", "JPG", etc) can be specified,
 * in case SDL_image cannot autodetect the file format.
 *
 * If you would rather decode an image to an Surface (a buffer of pixels
 * in CPU memory), call Surface.Surface() instead.
 *
 * @param renderer the Renderer to use to create the GPU texture.
 * @param src an IOStream that data will be read from.
 * @param closeio true to close/free the IOStream before returning, false
 *                to leave it open.
 * @returns a new texture, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa Texture.Texture
 * @sa LoadTextureTyped
 * @sa Texture.Destroy
 */
inline Texture LoadTexture(RendererParam renderer,
                           IOStreamParam src,
                           bool closeio = false)
{
  return Texture(IMG_LoadTexture_IO(renderer, src, closeio));
}

/**
 * Load an image from a filesystem path into a GPU texture.
 *
 * An Texture represents an image in GPU memory, usable by SDL's 2D Render
 * API. This can be significantly more efficient than using a CPU-bound
 * Surface if you don't need to manipulate the image directly after
 * loading it.
 *
 * If the loaded image has transparency or a colorkey, a texture with an alpha
 * channel will be created. Otherwise, SDL_image will attempt to create an
 * Texture in the most format that most reasonably represents the image
 * data (but in many cases, this will just end up being 32-bit RGB or 32-bit
 * RGBA).
 *
 * There is a separate function to read files from an IOStream, if you
 * need an i/o abstraction to provide data from anywhere instead of a simple
 * filesystem read; that function is Texture.Texture().
 *
 * If you would rather decode an image to an Surface (a buffer of pixels
 * in CPU memory), call Surface.Surface() instead.
 *
 * @param renderer the Renderer to use to create the GPU texture.
 * @param file a path on the filesystem to load an image from.
 * @post a new texture, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadTextureTyped
 * @sa Texture.Texture
 */
inline Texture::Texture(RendererParam renderer, StringParam file)
  : m_resource(IMG_LoadTexture(renderer, file))
{
}

/**
 * Load an image from an SDL data source into a GPU texture.
 *
 * An Texture represents an image in GPU memory, usable by SDL's 2D Render
 * API. This can be significantly more efficient than using a CPU-bound
 * Surface if you don't need to manipulate the image directly after
 * loading it.
 *
 * If the loaded image has transparency or a colorkey, a texture with an alpha
 * channel will be created. Otherwise, SDL_image will attempt to create an
 * Texture in the most format that most reasonably represents the image
 * data (but in many cases, this will just end up being 32-bit RGB or 32-bit
 * RGBA).
 *
 * If `closeio` is true, `src` will be closed before returning, whether this
 * function succeeds or not. SDL_image reads everything it needs from `src`
 * during this call in any case.
 *
 * There is a separate function to read files from disk without having to deal
 * with IOStream: `Texture.Texture(renderer, "filename.jpg")` will call
 * this function and manage those details for you, determining the file type
 * from the filename's extension.
 *
 * There is also LoadTextureTyped(), which is equivalent to this
 * function except a file extension (like "BMP", "JPG", etc) can be specified,
 * in case SDL_image cannot autodetect the file format.
 *
 * If you would rather decode an image to an Surface (a buffer of pixels
 * in CPU memory), call Surface.Surface() instead.
 *
 * @param renderer the Renderer to use to create the GPU texture.
 * @param src an IOStream that data will be read from.
 * @param closeio true to close/free the IOStream before returning, false
 *                to leave it open.
 * @post a new texture, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa Texture.Texture
 * @sa LoadTextureTyped
 * @sa Texture.Destroy
 */
inline Texture::Texture(RendererParam renderer, IOStreamParam src, bool closeio)
  : m_resource(IMG_LoadTexture_IO(renderer, src, closeio))
{
}

/**
 * Load an image from an SDL data source into a GPU texture.
 *
 * An Texture represents an image in GPU memory, usable by SDL's 2D Render
 * API. This can be significantly more efficient than using a CPU-bound
 * Surface if you don't need to manipulate the image directly after
 * loading it.
 *
 * If the loaded image has transparency or a colorkey, a texture with an alpha
 * channel will be created. Otherwise, SDL_image will attempt to create an
 * Texture in the most format that most reasonably represents the image
 * data (but in many cases, this will just end up being 32-bit RGB or 32-bit
 * RGBA).
 *
 * If `closeio` is true, `src` will be closed before returning, whether this
 * function succeeds or not. SDL_image reads everything it needs from `src`
 * during this call in any case.
 *
 * Even though this function accepts a file type, SDL_image may still try
 * other decoders that are capable of detecting file type from the contents of
 * the image data, but may rely on the caller-provided type string for formats
 * that it cannot autodetect. If `type` is nullptr, SDL_image will rely solely
 * on its ability to guess the format.
 *
 * There is a separate function to read files from disk without having to deal
 * with IOStream: `Texture.Texture("filename.jpg")` will call this
 * function and manage those details for you, determining the file type from
 * the filename's extension.
 *
 * There is also Texture.Texture(), which is equivalent to this function
 * except that it will rely on SDL_image to determine what type of data it is
 * loading, much like passing a nullptr for type.
 *
 * If you would rather decode an image to an Surface (a buffer of pixels
 * in CPU memory), call LoadSurfaceTyped() instead.
 *
 * @param renderer the Renderer to use to create the GPU texture.
 * @param src an IOStream that data will be read from.
 * @param type a filename extension that represent this data ("BMP", "GIF",
 *             "PNG", etc).
 * @param closeio true to close/free the IOStream before returning, false
 *                to leave it open.
 * @returns a new texture, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa Texture.Texture
 * @sa Texture.Destroy
 */
inline Texture LoadTextureTyped(RendererParam renderer,
                                IOStreamParam src,
                                StringParam type,
                                bool closeio = false)
{
  return Texture(IMG_LoadTextureTyped_IO(renderer, src, closeio, type));
}

/**
 * Detect AVIF image data on a readable/seekable IOStream.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the IOStream (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek `src` back to where it started
 * when this function was called, but it will not report any errors in doing
 * so, but assuming seeking works, this means you can immediately use this
 * with a different IMG_isTYPE function, or load the image without further
 * seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * @param src a seekable/readable IOStream to provide image data.
 * @returns non-zero if this is AVIF data, zero otherwise.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa isAVIF
 * @sa isICO
 * @sa isCUR
 * @sa isBMP
 * @sa isGIF
 * @sa isJPG
 * @sa isJXL
 * @sa isLBM
 * @sa isPCX
 * @sa isPNG
 * @sa isPNM
 * @sa isSVG
 * @sa isQOI
 * @sa isTIF
 * @sa isXCF
 * @sa isXPM
 * @sa isXV
 * @sa isWEBP
 */
inline bool isAVIF(IOStreamParam src) { return IMG_isAVIF(src); }

/**
 * Detect ICO image data on a readable/seekable IOStream.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the IOStream (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek `src` back to where it started
 * when this function was called, but it will not report any errors in doing
 * so, but assuming seeking works, this means you can immediately use this
 * with a different IMG_isTYPE function, or load the image without further
 * seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * @param src a seekable/readable IOStream to provide image data.
 * @returns non-zero if this is ICO data, zero otherwise.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa isAVIF
 * @sa isCUR
 * @sa isBMP
 * @sa isGIF
 * @sa isJPG
 * @sa isJXL
 * @sa isLBM
 * @sa isPCX
 * @sa isPNG
 * @sa isPNM
 * @sa isSVG
 * @sa isQOI
 * @sa isTIF
 * @sa isXCF
 * @sa isXPM
 * @sa isXV
 * @sa isWEBP
 */
inline bool isICO(IOStreamParam src) { return IMG_isICO(src); }

/**
 * Detect CUR image data on a readable/seekable IOStream.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the IOStream (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek `src` back to where it started
 * when this function was called, but it will not report any errors in doing
 * so, but assuming seeking works, this means you can immediately use this
 * with a different IMG_isTYPE function, or load the image without further
 * seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * @param src a seekable/readable IOStream to provide image data.
 * @returns non-zero if this is CUR data, zero otherwise.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa isAVIF
 * @sa isICO
 * @sa isBMP
 * @sa isGIF
 * @sa isJPG
 * @sa isJXL
 * @sa isLBM
 * @sa isPCX
 * @sa isPNG
 * @sa isPNM
 * @sa isSVG
 * @sa isQOI
 * @sa isTIF
 * @sa isXCF
 * @sa isXPM
 * @sa isXV
 * @sa isWEBP
 */
inline bool isCUR(IOStreamParam src) { return IMG_isCUR(src); }

/**
 * Detect BMP image data on a readable/seekable IOStream.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the IOStream (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek `src` back to where it started
 * when this function was called, but it will not report any errors in doing
 * so, but assuming seeking works, this means you can immediately use this
 * with a different IMG_isTYPE function, or load the image without further
 * seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * @param src a seekable/readable IOStream to provide image data.
 * @returns non-zero if this is BMP data, zero otherwise.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa isAVIF
 * @sa isICO
 * @sa isCUR
 * @sa isGIF
 * @sa isJPG
 * @sa isJXL
 * @sa isLBM
 * @sa isPCX
 * @sa isPNG
 * @sa isPNM
 * @sa isSVG
 * @sa isQOI
 * @sa isTIF
 * @sa isXCF
 * @sa isXPM
 * @sa isXV
 * @sa isWEBP
 */
inline bool isBMP(IOStreamParam src) { return IMG_isBMP(src); }

/**
 * Detect GIF image data on a readable/seekable IOStream.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the IOStream (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek `src` back to where it started
 * when this function was called, but it will not report any errors in doing
 * so, but assuming seeking works, this means you can immediately use this
 * with a different IMG_isTYPE function, or load the image without further
 * seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * @param src a seekable/readable IOStream to provide image data.
 * @returns non-zero if this is GIF data, zero otherwise.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa isAVIF
 * @sa isICO
 * @sa isCUR
 * @sa isBMP
 * @sa isJPG
 * @sa isJXL
 * @sa isLBM
 * @sa isPCX
 * @sa isPNG
 * @sa isPNM
 * @sa isSVG
 * @sa isQOI
 * @sa isTIF
 * @sa isXCF
 * @sa isXPM
 * @sa isXV
 * @sa isWEBP
 */
inline bool isGIF(IOStreamParam src) { return IMG_isGIF(src); }

/**
 * Detect JPG image data on a readable/seekable IOStream.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the IOStream (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek `src` back to where it started
 * when this function was called, but it will not report any errors in doing
 * so, but assuming seeking works, this means you can immediately use this
 * with a different IMG_isTYPE function, or load the image without further
 * seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * @param src a seekable/readable IOStream to provide image data.
 * @returns non-zero if this is JPG data, zero otherwise.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa isAVIF
 * @sa isICO
 * @sa isCUR
 * @sa isBMP
 * @sa isGIF
 * @sa isJXL
 * @sa isLBM
 * @sa isPCX
 * @sa isPNG
 * @sa isPNM
 * @sa isSVG
 * @sa isQOI
 * @sa isTIF
 * @sa isXCF
 * @sa isXPM
 * @sa isXV
 * @sa isWEBP
 */
inline bool isJPG(IOStreamParam src) { return IMG_isJPG(src); }

/**
 * Detect JXL image data on a readable/seekable IOStream.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the IOStream (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek `src` back to where it started
 * when this function was called, but it will not report any errors in doing
 * so, but assuming seeking works, this means you can immediately use this
 * with a different IMG_isTYPE function, or load the image without further
 * seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * @param src a seekable/readable IOStream to provide image data.
 * @returns non-zero if this is JXL data, zero otherwise.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa isAVIF
 * @sa isICO
 * @sa isCUR
 * @sa isBMP
 * @sa isGIF
 * @sa isJPG
 * @sa isLBM
 * @sa isPCX
 * @sa isPNG
 * @sa isPNM
 * @sa isSVG
 * @sa isQOI
 * @sa isTIF
 * @sa isXCF
 * @sa isXPM
 * @sa isXV
 * @sa isWEBP
 */
inline bool isJXL(IOStreamParam src) { return IMG_isJXL(src); }

/**
 * Detect LBM image data on a readable/seekable IOStream.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the IOStream (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek `src` back to where it started
 * when this function was called, but it will not report any errors in doing
 * so, but assuming seeking works, this means you can immediately use this
 * with a different IMG_isTYPE function, or load the image without further
 * seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * @param src a seekable/readable IOStream to provide image data.
 * @returns non-zero if this is LBM data, zero otherwise.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa isAVIF
 * @sa isICO
 * @sa isCUR
 * @sa isBMP
 * @sa isGIF
 * @sa isJPG
 * @sa isJXL
 * @sa isPCX
 * @sa isPNG
 * @sa isPNM
 * @sa isSVG
 * @sa isQOI
 * @sa isTIF
 * @sa isXCF
 * @sa isXPM
 * @sa isXV
 * @sa isWEBP
 */
inline bool isLBM(IOStreamParam src) { return IMG_isLBM(src); }

/**
 * Detect PCX image data on a readable/seekable IOStream.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the IOStream (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek `src` back to where it started
 * when this function was called, but it will not report any errors in doing
 * so, but assuming seeking works, this means you can immediately use this
 * with a different IMG_isTYPE function, or load the image without further
 * seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * @param src a seekable/readable IOStream to provide image data.
 * @returns non-zero if this is PCX data, zero otherwise.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa isAVIF
 * @sa isICO
 * @sa isCUR
 * @sa isBMP
 * @sa isGIF
 * @sa isJPG
 * @sa isJXL
 * @sa isLBM
 * @sa isPNG
 * @sa isPNM
 * @sa isSVG
 * @sa isQOI
 * @sa isTIF
 * @sa isXCF
 * @sa isXPM
 * @sa isXV
 * @sa isWEBP
 */
inline bool isPCX(IOStreamParam src) { return IMG_isPCX(src); }

/**
 * Detect PNG image data on a readable/seekable IOStream.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the IOStream (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek `src` back to where it started
 * when this function was called, but it will not report any errors in doing
 * so, but assuming seeking works, this means you can immediately use this
 * with a different IMG_isTYPE function, or load the image without further
 * seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * @param src a seekable/readable IOStream to provide image data.
 * @returns non-zero if this is PNG data, zero otherwise.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa isAVIF
 * @sa isICO
 * @sa isCUR
 * @sa isBMP
 * @sa isGIF
 * @sa isJPG
 * @sa isJXL
 * @sa isLBM
 * @sa isPCX
 * @sa isPNM
 * @sa isSVG
 * @sa isQOI
 * @sa isTIF
 * @sa isXCF
 * @sa isXPM
 * @sa isXV
 * @sa isWEBP
 */
inline bool isPNG(IOStreamParam src) { return IMG_isPNG(src); }

/**
 * Detect PNM image data on a readable/seekable IOStream.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the IOStream (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek `src` back to where it started
 * when this function was called, but it will not report any errors in doing
 * so, but assuming seeking works, this means you can immediately use this
 * with a different IMG_isTYPE function, or load the image without further
 * seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * @param src a seekable/readable IOStream to provide image data.
 * @returns non-zero if this is PNM data, zero otherwise.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa isAVIF
 * @sa isICO
 * @sa isCUR
 * @sa isBMP
 * @sa isGIF
 * @sa isJPG
 * @sa isJXL
 * @sa isLBM
 * @sa isPCX
 * @sa isPNG
 * @sa isSVG
 * @sa isQOI
 * @sa isTIF
 * @sa isXCF
 * @sa isXPM
 * @sa isXV
 * @sa isWEBP
 */
inline bool isPNM(IOStreamParam src) { return IMG_isPNM(src); }

/**
 * Detect SVG image data on a readable/seekable IOStream.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the IOStream (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek `src` back to where it started
 * when this function was called, but it will not report any errors in doing
 * so, but assuming seeking works, this means you can immediately use this
 * with a different IMG_isTYPE function, or load the image without further
 * seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * @param src a seekable/readable IOStream to provide image data.
 * @returns non-zero if this is SVG data, zero otherwise.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa isAVIF
 * @sa isICO
 * @sa isCUR
 * @sa isBMP
 * @sa isGIF
 * @sa isJPG
 * @sa isJXL
 * @sa isLBM
 * @sa isPCX
 * @sa isPNG
 * @sa isPNM
 * @sa isQOI
 * @sa isTIF
 * @sa isXCF
 * @sa isXPM
 * @sa isXV
 * @sa isWEBP
 */
inline bool isSVG(IOStreamParam src) { return IMG_isSVG(src); }

/**
 * Detect QOI image data on a readable/seekable IOStream.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the IOStream (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek `src` back to where it started
 * when this function was called, but it will not report any errors in doing
 * so, but assuming seeking works, this means you can immediately use this
 * with a different IMG_isTYPE function, or load the image without further
 * seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * @param src a seekable/readable IOStream to provide image data.
 * @returns non-zero if this is QOI data, zero otherwise.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa isAVIF
 * @sa isICO
 * @sa isCUR
 * @sa isBMP
 * @sa isGIF
 * @sa isJPG
 * @sa isJXL
 * @sa isLBM
 * @sa isPCX
 * @sa isPNG
 * @sa isPNM
 * @sa isSVG
 * @sa isTIF
 * @sa isXCF
 * @sa isXPM
 * @sa isXV
 * @sa isWEBP
 */
inline bool isQOI(IOStreamParam src) { return IMG_isQOI(src); }

/**
 * Detect TIFF image data on a readable/seekable IOStream.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the IOStream (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek `src` back to where it started
 * when this function was called, but it will not report any errors in doing
 * so, but assuming seeking works, this means you can immediately use this
 * with a different IMG_isTYPE function, or load the image without further
 * seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * @param src a seekable/readable IOStream to provide image data.
 * @returns non-zero if this is TIFF data, zero otherwise.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa isAVIF
 * @sa isICO
 * @sa isCUR
 * @sa isBMP
 * @sa isGIF
 * @sa isJPG
 * @sa isJXL
 * @sa isLBM
 * @sa isPCX
 * @sa isPNG
 * @sa isPNM
 * @sa isSVG
 * @sa isQOI
 * @sa isXCF
 * @sa isXPM
 * @sa isXV
 * @sa isWEBP
 */
inline bool isTIF(IOStreamParam src) { return IMG_isTIF(src); }

/**
 * Detect XCF image data on a readable/seekable IOStream.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the IOStream (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek `src` back to where it started
 * when this function was called, but it will not report any errors in doing
 * so, but assuming seeking works, this means you can immediately use this
 * with a different IMG_isTYPE function, or load the image without further
 * seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * @param src a seekable/readable IOStream to provide image data.
 * @returns non-zero if this is XCF data, zero otherwise.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa isAVIF
 * @sa isICO
 * @sa isCUR
 * @sa isBMP
 * @sa isGIF
 * @sa isJPG
 * @sa isJXL
 * @sa isLBM
 * @sa isPCX
 * @sa isPNG
 * @sa isPNM
 * @sa isSVG
 * @sa isQOI
 * @sa isTIF
 * @sa isXPM
 * @sa isXV
 * @sa isWEBP
 */
inline bool isXCF(IOStreamParam src) { return IMG_isXCF(src); }

/**
 * Detect XPM image data on a readable/seekable IOStream.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the IOStream (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek `src` back to where it started
 * when this function was called, but it will not report any errors in doing
 * so, but assuming seeking works, this means you can immediately use this
 * with a different IMG_isTYPE function, or load the image without further
 * seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * @param src a seekable/readable IOStream to provide image data.
 * @returns non-zero if this is XPM data, zero otherwise.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa isAVIF
 * @sa isICO
 * @sa isCUR
 * @sa isBMP
 * @sa isGIF
 * @sa isJPG
 * @sa isJXL
 * @sa isLBM
 * @sa isPCX
 * @sa isPNG
 * @sa isPNM
 * @sa isSVG
 * @sa isQOI
 * @sa isTIF
 * @sa isXCF
 * @sa isXV
 * @sa isWEBP
 */
inline bool isXPM(IOStreamParam src) { return IMG_isXPM(src); }

/**
 * Detect XV image data on a readable/seekable IOStream.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the IOStream (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek `src` back to where it started
 * when this function was called, but it will not report any errors in doing
 * so, but assuming seeking works, this means you can immediately use this
 * with a different IMG_isTYPE function, or load the image without further
 * seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * @param src a seekable/readable IOStream to provide image data.
 * @returns non-zero if this is XV data, zero otherwise.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa isAVIF
 * @sa isICO
 * @sa isCUR
 * @sa isBMP
 * @sa isGIF
 * @sa isJPG
 * @sa isJXL
 * @sa isLBM
 * @sa isPCX
 * @sa isPNG
 * @sa isPNM
 * @sa isSVG
 * @sa isQOI
 * @sa isTIF
 * @sa isXCF
 * @sa isXPM
 * @sa isWEBP
 */
inline bool isXV(IOStreamParam src) { return IMG_isXV(src); }

/**
 * Detect WEBP image data on a readable/seekable IOStream.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the IOStream (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek `src` back to where it started
 * when this function was called, but it will not report any errors in doing
 * so, but assuming seeking works, this means you can immediately use this
 * with a different IMG_isTYPE function, or load the image without further
 * seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * @param src a seekable/readable IOStream to provide image data.
 * @returns non-zero if this is WEBP data, zero otherwise.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa isAVIF
 * @sa isICO
 * @sa isCUR
 * @sa isBMP
 * @sa isGIF
 * @sa isJPG
 * @sa isJXL
 * @sa isLBM
 * @sa isPCX
 * @sa isPNG
 * @sa isPNM
 * @sa isSVG
 * @sa isQOI
 * @sa isTIF
 * @sa isXCF
 * @sa isXPM
 * @sa isXV
 */
inline bool isWEBP(IOStreamParam src) { return IMG_isWEBP(src); }

/**
 * Load a AVIF image directly.
 *
 * If you know you definitely have a AVIF image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an IOStream
 * interface available here.
 *
 * @param src an IOStream to load image data from.
 * @returns SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadICO
 * @sa LoadCUR
 * @sa LoadBMP
 * @sa LoadGIF
 * @sa LoadJPG
 * @sa LoadJXL
 * @sa LoadLBM
 * @sa LoadPCX
 * @sa LoadPNG
 * @sa LoadPNM
 * @sa LoadSVG
 * @sa LoadQOI
 * @sa LoadTGA
 * @sa LoadTIF
 * @sa LoadXCF
 * @sa LoadXPM
 * @sa LoadXV
 * @sa LoadWEBP
 */
inline Surface LoadAVIF(IOStreamParam src)
{
  return Surface(IMG_LoadAVIF_IO(src));
}

/**
 * Load a ICO image directly.
 *
 * If you know you definitely have a ICO image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an IOStream
 * interface available here.
 *
 * @param src an IOStream to load image data from.
 * @returns SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadAVIF
 * @sa LoadCUR
 * @sa LoadBMP
 * @sa LoadGIF
 * @sa LoadJPG
 * @sa LoadJXL
 * @sa LoadLBM
 * @sa LoadPCX
 * @sa LoadPNG
 * @sa LoadPNM
 * @sa LoadSVG
 * @sa LoadQOI
 * @sa LoadTGA
 * @sa LoadTIF
 * @sa LoadXCF
 * @sa LoadXPM
 * @sa LoadXV
 * @sa LoadWEBP
 */
inline Surface LoadICO(IOStreamParam src)
{
  return Surface{IMG_LoadICO_IO(src)};
}

/**
 * Load a CUR image directly.
 *
 * If you know you definitely have a CUR image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an IOStream
 * interface available here.
 *
 * @param src an IOStream to load image data from.
 * @returns SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadAVIF
 * @sa LoadICO
 * @sa LoadBMP
 * @sa LoadGIF
 * @sa LoadJPG
 * @sa LoadJXL
 * @sa LoadLBM
 * @sa LoadPCX
 * @sa LoadPNG
 * @sa LoadPNM
 * @sa LoadSVG
 * @sa LoadQOI
 * @sa LoadTGA
 * @sa LoadTIF
 * @sa LoadXCF
 * @sa LoadXPM
 * @sa LoadXV
 * @sa LoadWEBP
 */
inline Surface LoadCUR(IOStreamParam src)
{
  return Surface{IMG_LoadCUR_IO(src)};
}

/**
 * Load a BMP image directly.
 *
 * If you know you definitely have a BMP image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an IOStream
 * interface available here.
 *
 * @param src an IOStream to load image data from.
 * @returns SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadAVIF
 * @sa LoadICO
 * @sa LoadCUR
 * @sa LoadGIF
 * @sa LoadJPG
 * @sa LoadJXL
 * @sa LoadLBM
 * @sa LoadPCX
 * @sa LoadPNG
 * @sa LoadPNM
 * @sa LoadSVG
 * @sa LoadQOI
 * @sa LoadTGA
 * @sa LoadTIF
 * @sa LoadXCF
 * @sa LoadXPM
 * @sa LoadXV
 * @sa LoadWEBP
 */
inline Surface LoadBMP(IOStreamParam src)
{
  return Surface{IMG_LoadBMP_IO(src)};
}

/**
 * Load a GIF image directly.
 *
 * If you know you definitely have a GIF image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an IOStream
 * interface available here.
 *
 * @param src an IOStream to load image data from.
 * @returns SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadAVIF
 * @sa LoadICO
 * @sa LoadCUR
 * @sa LoadBMP
 * @sa LoadJPG
 * @sa LoadJXL
 * @sa LoadLBM
 * @sa LoadPCX
 * @sa LoadPNG
 * @sa LoadPNM
 * @sa LoadSVG
 * @sa LoadQOI
 * @sa LoadTGA
 * @sa LoadTIF
 * @sa LoadXCF
 * @sa LoadXPM
 * @sa LoadXV
 * @sa LoadWEBP
 */
inline Surface LoadGIF(IOStreamParam src)
{
  return Surface{IMG_LoadGIF_IO(src)};
}

/**
 * Load a JPG image directly.
 *
 * If you know you definitely have a JPG image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an IOStream
 * interface available here.
 *
 * @param src an IOStream to load image data from.
 * @returns SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadAVIF
 * @sa LoadICO
 * @sa LoadCUR
 * @sa LoadBMP
 * @sa LoadGIF
 * @sa LoadJXL
 * @sa LoadLBM
 * @sa LoadPCX
 * @sa LoadPNG
 * @sa LoadPNM
 * @sa LoadSVG
 * @sa LoadQOI
 * @sa LoadTGA
 * @sa LoadTIF
 * @sa LoadXCF
 * @sa LoadXPM
 * @sa LoadXV
 * @sa LoadWEBP
 */
inline Surface LoadJPG(IOStreamParam src)
{
  return Surface{IMG_LoadJPG_IO(src)};
}

/**
 * Load a JXL image directly.
 *
 * If you know you definitely have a JXL image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an IOStream
 * interface available here.
 *
 * @param src an IOStream to load image data from.
 * @returns SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadAVIF
 * @sa LoadICO
 * @sa LoadCUR
 * @sa LoadBMP
 * @sa LoadGIF
 * @sa LoadJPG
 * @sa LoadLBM
 * @sa LoadPCX
 * @sa LoadPNG
 * @sa LoadPNM
 * @sa LoadSVG
 * @sa LoadQOI
 * @sa LoadTGA
 * @sa LoadTIF
 * @sa LoadXCF
 * @sa LoadXPM
 * @sa LoadXV
 * @sa LoadWEBP
 */
inline Surface LoadJXL(IOStreamParam src)
{
  return Surface{IMG_LoadJXL_IO(src)};
}

/**
 * Load a LBM image directly.
 *
 * If you know you definitely have a LBM image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an IOStream
 * interface available here.
 *
 * @param src an IOStream to load image data from.
 * @returns SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadAVIF
 * @sa LoadICO
 * @sa LoadCUR
 * @sa LoadBMP
 * @sa LoadGIF
 * @sa LoadJPG
 * @sa LoadJXL
 * @sa LoadPCX
 * @sa LoadPNG
 * @sa LoadPNM
 * @sa LoadSVG
 * @sa LoadQOI
 * @sa LoadTGA
 * @sa LoadTIF
 * @sa LoadXCF
 * @sa LoadXPM
 * @sa LoadXV
 * @sa LoadWEBP
 */
inline Surface LoadLBM(IOStreamParam src)
{
  return Surface{IMG_LoadLBM_IO(src)};
}

/**
 * Load a PCX image directly.
 *
 * If you know you definitely have a PCX image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an IOStream
 * interface available here.
 *
 * @param src an IOStream to load image data from.
 * @returns SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadAVIF
 * @sa LoadICO
 * @sa LoadCUR
 * @sa LoadBMP
 * @sa LoadGIF
 * @sa LoadJPG
 * @sa LoadJXL
 * @sa LoadLBM
 * @sa LoadPNG
 * @sa LoadPNM
 * @sa LoadSVG
 * @sa LoadQOI
 * @sa LoadTGA
 * @sa LoadTIF
 * @sa LoadXCF
 * @sa LoadXPM
 * @sa LoadXV
 * @sa LoadWEBP
 */
inline Surface LoadPCX(IOStreamParam src)
{
  return Surface{IMG_LoadPCX_IO(src)};
}

/**
 * Load a PNG image directly.
 *
 * If you know you definitely have a PNG image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an IOStream
 * interface available here.
 *
 * @param src an IOStream to load image data from.
 * @returns SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadAVIF
 * @sa LoadICO
 * @sa LoadCUR
 * @sa LoadBMP
 * @sa LoadGIF
 * @sa LoadJPG
 * @sa LoadJXL
 * @sa LoadLBM
 * @sa LoadPCX
 * @sa LoadPNM
 * @sa LoadSVG
 * @sa LoadQOI
 * @sa LoadTGA
 * @sa LoadTIF
 * @sa LoadXCF
 * @sa LoadXPM
 * @sa LoadXV
 * @sa LoadWEBP
 */
inline Surface LoadPNG(IOStreamParam src)
{
  return Surface{IMG_LoadPNG_IO(src)};
}

/**
 * Load a PNM image directly.
 *
 * If you know you definitely have a PNM image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an IOStream
 * interface available here.
 *
 * @param src an IOStream to load image data from.
 * @returns SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadAVIF
 * @sa LoadICO
 * @sa LoadCUR
 * @sa LoadBMP
 * @sa LoadGIF
 * @sa LoadJPG
 * @sa LoadJXL
 * @sa LoadLBM
 * @sa LoadPCX
 * @sa LoadPNG
 * @sa LoadSVG
 * @sa LoadQOI
 * @sa LoadTGA
 * @sa LoadTIF
 * @sa LoadXCF
 * @sa LoadXPM
 * @sa LoadXV
 * @sa LoadWEBP
 */
inline Surface LoadPNM(IOStreamParam src)
{
  return Surface{IMG_LoadPNM_IO(src)};
}

/**
 * Load a SVG image directly.
 *
 * If you know you definitely have a SVG image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an IOStream
 * interface available here.
 *
 * @param src an IOStream to load image data from.
 * @returns SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadAVIF
 * @sa LoadICO
 * @sa LoadCUR
 * @sa LoadBMP
 * @sa LoadGIF
 * @sa LoadJPG
 * @sa LoadJXL
 * @sa LoadLBM
 * @sa LoadPCX
 * @sa LoadPNG
 * @sa LoadPNM
 * @sa LoadQOI
 * @sa LoadTGA
 * @sa LoadTIF
 * @sa LoadXCF
 * @sa LoadXPM
 * @sa LoadXV
 * @sa LoadWEBP
 */
inline Surface LoadSVG(IOStreamParam src)
{
  return Surface{IMG_LoadSVG_IO(src)};
}

/**
 * Load a QOI image directly.
 *
 * If you know you definitely have a QOI image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an IOStream
 * interface available here.
 *
 * @param src an IOStream to load image data from.
 * @returns SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadAVIF
 * @sa LoadICO
 * @sa LoadCUR
 * @sa LoadBMP
 * @sa LoadGIF
 * @sa LoadJPG
 * @sa LoadJXL
 * @sa LoadLBM
 * @sa LoadPCX
 * @sa LoadPNG
 * @sa LoadPNM
 * @sa LoadSVG
 * @sa LoadTGA
 * @sa LoadTIF
 * @sa LoadXCF
 * @sa LoadXPM
 * @sa LoadXV
 * @sa LoadWEBP
 */
inline Surface LoadQOI(IOStreamParam src)
{
  return Surface{IMG_LoadQOI_IO(src)};
}

/**
 * Load a TGA image directly.
 *
 * If you know you definitely have a TGA image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an IOStream
 * interface available here.
 *
 * @param src an IOStream to load image data from.
 * @returns SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadAVIF
 * @sa LoadICO
 * @sa LoadCUR
 * @sa LoadBMP
 * @sa LoadGIF
 * @sa LoadJPG
 * @sa LoadJXL
 * @sa LoadLBM
 * @sa LoadPCX
 * @sa LoadPNG
 * @sa LoadPNM
 * @sa LoadSVG
 * @sa LoadQOI
 * @sa LoadTIF
 * @sa LoadXCF
 * @sa LoadXPM
 * @sa LoadXV
 * @sa LoadWEBP
 */
inline Surface LoadTGA(IOStreamParam src)
{
  return Surface{IMG_LoadTGA_IO(src)};
}

/**
 * Load a TIFF image directly.
 *
 * If you know you definitely have a TIFF image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an IOStream
 * interface available here.
 *
 * @param src an IOStream to load image data from.
 * @returns SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadAVIF
 * @sa LoadICO
 * @sa LoadCUR
 * @sa LoadBMP
 * @sa LoadGIF
 * @sa LoadJPG
 * @sa LoadJXL
 * @sa LoadLBM
 * @sa LoadPCX
 * @sa LoadPNG
 * @sa LoadPNM
 * @sa LoadSVG
 * @sa LoadQOI
 * @sa LoadTGA
 * @sa LoadXCF
 * @sa LoadXPM
 * @sa LoadXV
 * @sa LoadWEBP
 */
inline Surface LoadTIF(IOStreamParam src)
{
  return Surface{IMG_LoadTIF_IO(src)};
}

/**
 * Load a XCF image directly.
 *
 * If you know you definitely have a XCF image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an IOStream
 * interface available here.
 *
 * @param src an IOStream to load image data from.
 * @returns SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadAVIF
 * @sa LoadICO
 * @sa LoadCUR
 * @sa LoadBMP
 * @sa LoadGIF
 * @sa LoadJPG
 * @sa LoadJXL
 * @sa LoadLBM
 * @sa LoadPCX
 * @sa LoadPNG
 * @sa LoadPNM
 * @sa LoadSVG
 * @sa LoadQOI
 * @sa LoadTGA
 * @sa LoadTIF
 * @sa LoadXPM
 * @sa LoadXV
 * @sa LoadWEBP
 */
inline Surface LoadXCF(IOStreamParam src)
{
  return Surface{IMG_LoadXCF_IO(src)};
}

/**
 * Load a XPM image directly.
 *
 * If you know you definitely have a XPM image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an IOStream
 * interface available here.
 *
 * @param src an IOStream to load image data from.
 * @returns SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadAVIF
 * @sa LoadICO
 * @sa LoadCUR
 * @sa LoadBMP
 * @sa LoadGIF
 * @sa LoadJPG
 * @sa LoadJXL
 * @sa LoadLBM
 * @sa LoadPCX
 * @sa LoadPNG
 * @sa LoadPNM
 * @sa LoadSVG
 * @sa LoadQOI
 * @sa LoadTGA
 * @sa LoadTIF
 * @sa LoadXCF
 * @sa LoadXV
 * @sa LoadWEBP
 */
inline Surface LoadXPM(IOStreamParam src)
{
  return Surface{IMG_LoadXPM_IO(src)};
}

/**
 * Load a XV image directly.
 *
 * If you know you definitely have a XV image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an IOStream
 * interface available here.
 *
 * @param src an IOStream to load image data from.
 * @returns SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadAVIF
 * @sa LoadICO
 * @sa LoadCUR
 * @sa LoadBMP
 * @sa LoadGIF
 * @sa LoadJPG
 * @sa LoadJXL
 * @sa LoadLBM
 * @sa LoadPCX
 * @sa LoadPNG
 * @sa LoadPNM
 * @sa LoadSVG
 * @sa LoadQOI
 * @sa LoadTGA
 * @sa LoadTIF
 * @sa LoadXCF
 * @sa LoadXPM
 * @sa LoadWEBP
 */
inline Surface LoadXV(IOStreamParam src) { return Surface{IMG_LoadXV_IO(src)}; }

/**
 * Load a WEBP image directly.
 *
 * If you know you definitely have a WEBP image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an IOStream
 * interface available here.
 *
 * @param src an IOStream to load image data from.
 * @returns SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa LoadAVIF
 * @sa LoadICO
 * @sa LoadCUR
 * @sa LoadBMP
 * @sa LoadGIF
 * @sa LoadJPG
 * @sa LoadJXL
 * @sa LoadLBM
 * @sa LoadPCX
 * @sa LoadPNG
 * @sa LoadPNM
 * @sa LoadSVG
 * @sa LoadQOI
 * @sa LoadTGA
 * @sa LoadTIF
 * @sa LoadXCF
 * @sa LoadXPM
 * @sa LoadXV
 */
inline Surface LoadWEBP(IOStreamParam src)
{
  return Surface{IMG_LoadWEBP_IO(src)};
}

/**
 * Load an SVG image, scaled to a specific size.
 *
 * Since SVG files are resolution-independent, you specify the size you would
 * like the output image to be and it will be generated at those dimensions.
 *
 * Either width or height may be 0 and the image will be auto-sized to
 * preserve aspect ratio.
 *
 * @param src an IOStream to load SVG data from.
 * @param size desired width and height of the generated surface, in pixels.
 * @returns a new SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 */
inline Surface LoadSizedSVG(IOStreamParam src, const PointRaw& size)
{
  return Surface(IMG_LoadSizedSVG_IO(src, size.x, size.y));
}

/**
 * Load an XPM image from a memory array.
 *
 * The returned surface will be an 8bpp indexed surface, if possible,
 * otherwise it will be 32bpp. If you always want 32-bit data, use
 * ReadXPMFromArrayToRGB888() instead.
 *
 * @param xpm a null-terminated array of strings that comprise XPM data.
 * @returns a new SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa ReadXPMFromArrayToRGB888
 */
inline Surface ReadXPMFromArray(char** xpm)
{
  return Surface{IMG_ReadXPMFromArray(xpm)};
}

/**
 * Load an XPM image from a memory array.
 *
 * The returned surface will always be a 32-bit RGB surface. If you want 8-bit
 * indexed colors (and the XPM data allows it), use ReadXPMFromArray()
 * instead.
 *
 * When done with the returned surface, the app should dispose of it with a
 * call to Surface.Destroy().
 *
 * @param xpm a null-terminated array of strings that comprise XPM data.
 * @returns a new SDL surface, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa ReadXPMFromArray
 */
inline Surface ReadXPMFromArrayToRGB888(char** xpm)
{
  return Surface{IMG_ReadXPMFromArrayToRGB888(xpm)};
}

/**
 * Save an Surface into a AVIF image file.
 *
 * If the file already exists, it will be overwritten.
 *
 * @param surface the SDL surface to save.
 * @param file path on the filesystem to write new file to.
 * @param quality the desired quality, ranging between 0 (lowest) and 100
 *                (highest).
 * @throws Error on failure.
 *
 * @since This function is available since SDL_image 3.0.0.
 */
inline void SaveAVIF(SurfaceParam surface, StringParam file, int quality)
{
  CheckError(IMG_SaveAVIF(surface, file, quality));
}

/**
 * Save an Surface into AVIF image data, via an IOStream.
 *
 * If you just want to save to a filename, you can use SaveAVIF() instead.
 *
 * If `closeio` is true, `dst` will be closed before returning, whether this
 * function succeeds or not.
 *
 * @param surface the SDL surface to save.
 * @param dst the IOStream to save the image data to.
 * @param quality the desired quality, ranging between 0 (lowest) and 100
 *                (highest).
 * @param closeio true to close/free the IOStream before returning, false
 *                to leave it open.
 * @throws Error on failure.
 *
 * @since This function is available since SDL_image 3.0.0.
 */
inline void SaveAVIF(SurfaceParam surface,
                     IOStreamParam dst,
                     int quality,
                     bool closeio = false)
{
  CheckError(IMG_SaveAVIF_IO(surface, dst, closeio, quality));
}

/**
 * Save an Surface into a PNG image file.
 *
 * If the file already exists, it will be overwritten.
 *
 * @param surface the SDL surface to save.
 * @param file path on the filesystem to write new file to.
 * @throws Error on failure.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa SavePNG
 */
inline void SavePNG(SurfaceParam surface, StringParam file)
{
  CheckError(IMG_SavePNG(surface, file));
}

/**
 * Save an Surface into PNG image data, via an IOStream.
 *
 * If you just want to save to a filename, you can use SavePNG() instead.
 *
 * If `closeio` is true, `dst` will be closed before returning, whether this
 * function succeeds or not.
 *
 * @param surface the SDL surface to save.
 * @param dst the IOStream to save the image data to.
 * @param closeio true to close/free the IOStream before returning, false
 *                to leave it open.
 * @throws Error on failure.
 *
 * @since This function is available since SDL_image 3.0.0.
 */
inline void SavePNG(SurfaceParam surface,
                    IOStreamParam dst,
                    bool closeio = false)
{
  CheckError(IMG_SavePNG_IO(surface, dst, closeio));
}

/**
 * Save an Surface into a JPEG image file.
 *
 * If the file already exists, it will be overwritten.
 *
 * @param surface the SDL surface to save.
 * @param file path on the filesystem to write new file to.
 * @param quality [0; 33] is Lowest quality, [34; 66] is Middle quality, [67;
 *                100] is Highest quality.
 * @throws Error on failure.
 *
 * @since This function is available since SDL_image 3.0.0.
 */
inline void SaveJPG(SurfaceParam surface, StringParam file, int quality)
{
  CheckError(IMG_SaveJPG(surface, file, quality));
}

/**
 * Save an Surface into JPEG image data, via an IOStream.
 *
 * If you just want to save to a filename, you can use SaveJPG() instead.
 *
 * If `closeio` is true, `dst` will be closed before returning, whether this
 * function succeeds or not.
 *
 * @param surface the SDL surface to save.
 * @param dst the IOStream to save the image data to.
 * @param quality [0; 33] is Lowest quality, [34; 66] is Middle quality, [67;
 *                100] is Highest quality.
 * @param closeio true to close/free the IOStream before returning, false
 *                to leave it open.
 * @throws Error on failure.
 *
 * @since This function is available since SDL_image 3.0.0.
 */
inline void SaveJPG(SurfaceParam surface,
                    IOStreamParam dst,
                    int quality,
                    bool closeio = false)
{
  CheckError(IMG_SaveJPG_IO(surface, dst, closeio, quality));
}

/**
 * Animated image support
 *
 * Currently only animated GIFs and WEBP images are supported.
 *
 * @cat resource
 */
class Animation
{
  AnimationRaw m_resource = nullptr;

public:
  /// Default ctor
  constexpr Animation() = default;

  /**
   * Constructs from AnimationParam.
   *
   * @param resource a AnimationRaw to be wrapped.
   *
   * This assumes the ownership, call release() if you need to take back.
   */
  constexpr explicit Animation(const AnimationRaw resource)
    : m_resource(resource)
  {
  }

  /// Copy constructor
  constexpr Animation(const Animation& other) = delete;

  /// Move constructor
  constexpr Animation(Animation&& other)
    : Animation(other.release())
  {
  }

  constexpr Animation(const AnimationRef& other) = delete;

  constexpr Animation(AnimationRef&& other) = delete;

  /**
   * Load an animation from a file.
   *
   * When done with the returned animation, the app should dispose of it with a
   * call to Animation.Free().
   *
   * @param file path on the filesystem containing an animated image.
   * @post a new Animation, or nullptr on error.
   *
   * @since This function is available since SDL_image 3.0.0.
   *
   * @sa Animation.Free
   */
  Animation(StringParam file)
    : m_resource(IMG_LoadAnimation(file))
  {
  }

  /**
   * Load an animation from an IOStream.
   *
   * If `closeio` is true, `src` will be closed before returning, whether this
   * function succeeds or not. SDL_image reads everything it needs from `src`
   * during this call in any case.
   *
   * When done with the returned animation, the app should dispose of it with a
   * call to Animation.Free().
   *
   * @param src an IOStream that data will be read from.
   * @param closeio true to close/free the IOStream before returning, false
   *                to leave it open.
   * @post a new Animation, or nullptr on error.
   *
   * @since This function is available since SDL_image 3.0.0.
   *
   * @sa Animation.Free
   */
  Animation(IOStreamParam src, bool closeio = false)
    : m_resource(IMG_LoadAnimation_IO(src, closeio))
  {
  }

  /// Destructor
  ~Animation() { IMG_FreeAnimation(m_resource); }

  /// Assignment operator.
  Animation& operator=(Animation other)
  {
    std::swap(m_resource, other.m_resource);
    return *this;
  }

  /// Retrieves underlying AnimationRaw.
  constexpr AnimationRaw get() const { return m_resource; }

  /// Retrieves underlying AnimationRaw and clear this.
  constexpr AnimationRaw release()
  {
    auto r = m_resource;
    m_resource = nullptr;
    return r;
  }

  /// Comparison
  constexpr auto operator<=>(const Animation& other) const = default;

  /// Comparison
  constexpr bool operator==(std::nullptr_t _) const { return !m_resource; }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!m_resource; }

  /// Converts to AnimationParam
  constexpr operator AnimationParam() const { return {m_resource}; }

  /**
   * Dispose of an Animation and free its resources.
   *
   * The provided `anim` pointer is not valid once this call returns.
   *
   *
   * @since This function is available since SDL_image 3.0.0.
   *
   * @sa Animation.Animation
   * @sa LoadAnimationTyped
   */
  void Free();

  /**
   * Get the width in pixels.
   */
  int GetWidth() const { return get()->w; }

  /**
   * Get the height in pixels.
   */
  int GetHeight() const { return get()->h; }

  /**
   * Get the size in pixels.
   */
  Point GetSize() const { return Point(GetWidth(), GetHeight()); }

  /**
   * Return the number of frames.
   */
  int GetCount() const { return m_resource->count; }

  /**
   * Return the frame image under given index.
   *
   * @param index the index to get frame, within [0, GetCount() - 1]
   */
  SurfaceRaw GetFrame(int index) const { return m_resource->frames[index]; }

  /**
   * Return the frame delay under given index.
   *
   * @param index the index to get frame, within [0, GetCount() - 1]
   */
  int GetDelay(int index) const { return m_resource->delays[index]; }
};

/// Semi-safe reference for Animation.
struct AnimationRef : Animation
{
  /**
   * Constructs from AnimationParam.
   *
   * @param resource a AnimationRaw or Animation.
   *
   * This does not takes ownership!
   */
  AnimationRef(AnimationParam resource)
    : Animation(resource.value)
  {
  }

  /// Copy constructor.
  AnimationRef(const AnimationRef& other)
    : Animation(other.get())
  {
  }

  /// Destructor
  ~AnimationRef() { release(); }
};

/**
 * Load an animation from a file.
 *
 * When done with the returned animation, the app should dispose of it with a
 * call to Animation.Free().
 *
 * @param file path on the filesystem containing an animated image.
 * @returns a new Animation, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa Animation.Free
 */
inline Animation LoadAnimation(StringParam file)
{
  return Animation(std::move(file));
}

/**
 * Load an animation from an IOStream.
 *
 * If `closeio` is true, `src` will be closed before returning, whether this
 * function succeeds or not. SDL_image reads everything it needs from `src`
 * during this call in any case.
 *
 * When done with the returned animation, the app should dispose of it with a
 * call to Animation.Free().
 *
 * @param src an IOStream that data will be read from.
 * @param closeio true to close/free the IOStream before returning, false
 *                to leave it open.
 * @returns a new Animation, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa Animation.Free
 */
inline Animation LoadAnimation(IOStreamParam src, bool closeio = false)
{
  return Animation(src, closeio);
}

/**
 * Load an animation from an SDL datasource
 *
 * Even though this function accepts a file type, SDL_image may still try
 * other decoders that are capable of detecting file type from the contents of
 * the image data, but may rely on the caller-provided type string for formats
 * that it cannot autodetect. If `type` is nullptr, SDL_image will rely solely
 * on its ability to guess the format.
 *
 * If `closeio` is true, `src` will be closed before returning, whether this
 * function succeeds or not. SDL_image reads everything it needs from `src`
 * during this call in any case.
 *
 * When done with the returned animation, the app should dispose of it with a
 * call to Animation.Free().
 *
 * @param src an IOStream that data will be read from.
 * @param type a filename extension that represent this data ("GIF", etc).
 * @param closeio true to close/free the IOStream before returning, false
 *                to leave it open.
 * @returns a new Animation, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa Animation.Animation
 * @sa Animation.Free
 */
inline Animation LoadAnimationTyped(IOStreamParam src,
                                    StringParam type,
                                    bool closeio = false)
{
  return Animation(IMG_LoadAnimationTyped_IO(src, closeio, type));
}

/**
 * Dispose of an Animation and free its resources.
 *
 * The provided `anim` pointer is not valid once this call returns.
 *
 * @param anim Animation to dispose of.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa Animation.Animation
 * @sa LoadAnimationTyped
 */
inline void FreeAnimation(AnimationRaw anim) { IMG_FreeAnimation(anim); }

inline void Animation::Free()
{
  IMG_FreeAnimation(m_resource);
  m_resource = nullptr;
}

/**
 * Load a GIF animation directly.
 *
 * If you know you definitely have a GIF image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an IOStream
 * interface available here.
 *
 * @param src an IOStream that data will be read from.
 * @returns a new Animation, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa Animation.Animation
 * @sa LoadAnimationTyped
 * @sa Animation.Free
 */
inline Animation LoadGIFAnimation(IOStreamParam src)
{
  return Animation(IMG_LoadGIFAnimation_IO(src));
}

/**
 * Load a WEBP animation directly.
 *
 * If you know you definitely have a WEBP image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an IOStream
 * interface available here.
 *
 * @param src an IOStream that data will be read from.
 * @returns a new Animation, or nullptr on error.
 *
 * @since This function is available since SDL_image 3.0.0.
 *
 * @sa Animation.Animation
 * @sa LoadAnimationTyped
 * @sa Animation.Free
 */
inline Animation LoadWEBPAnimation(IOStreamParam src)
{
  return Animation{IMG_LoadWEBPAnimation_IO(src)};
}

/// @}

} // namespace SDL

#endif // defined(SDL3PP_ENABLE_IMAGE) || defined(SDL3PP_DOC)

#if !defined(SDL3PP_DISABLE_TTF) && !defined(SDL3PP_ENABLE_TTF) &&             \
  __has_include(<SDL3_ttf/SDL_ttf.h>)
#define SDL3PP_ENABLE_TTF
#endif

#if defined(SDL3PP_ENABLE_TTF) || defined(SDL3PP_DOC)

#include <SDL3_ttf/SDL_ttf.h>

namespace SDL {

/**
 * @defgroup CategorySDLTTF True type font support
 *
 * Header file for SDL_ttf library
 *
 * This library is a wrapper around the excellent FreeType 2.0 library,
 * available at: https://www.freetype.org/
 *
 * @{
 */

// Forward decl
struct Font;

using FontRaw = TTF_Font*;

// Forward decl
struct FontRef;

/// Safely wrap Font for non owning parameters
struct FontParam
{
  FontRaw value; ///< parameter's FontRaw

  /// Constructs from FontRaw
  constexpr FontParam(FontRaw value)
    : value(value)
  {
  }

  /// Constructs null/invalid
  constexpr FontParam(std::nullptr_t _ = nullptr)
    : value(nullptr)
  {
  }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!value; }

  /// Comparison
  constexpr auto operator<=>(const FontParam& other) const = default;

  /// Converts to underlying FontRaw
  constexpr operator FontRaw() const { return value; }
};

// Forward decl
struct TextEngine;

using TextEngineRaw = TTF_TextEngine*;

/// Safely wrap TextEngine for non owning parameters
struct TextEngineParam
{
  TextEngineRaw value; ///< parameter's TextEngineRaw

  /// Constructs from TextEngineRaw
  constexpr TextEngineParam(TextEngineRaw value)
    : value(value)
  {
  }

  /// Constructs null/invalid
  constexpr TextEngineParam(std::nullptr_t _ = nullptr)
    : value(nullptr)
  {
  }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!value; }

  /// Comparison
  constexpr auto operator<=>(const TextEngineParam& other) const = default;

  /// Converts to underlying TextEngineRaw
  constexpr operator TextEngineRaw() const { return value; }
};

// Forward decl
struct Text;

using TextRaw = TTF_Text*;

// Forward decl
struct TextRef;

/// Safely wrap Text for non owning parameters
struct TextParam
{
  TextRaw value; ///< parameter's TextRaw

  /// Constructs from TextRaw
  constexpr TextParam(TextRaw value)
    : value(value)
  {
  }

  /// Constructs null/invalid
  constexpr TextParam(std::nullptr_t _ = nullptr)
    : value(nullptr)
  {
  }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!value; }

  /// Comparison
  constexpr auto operator<=>(const TextParam& other) const = default;

  /// Converts to underlying TextRaw
  constexpr operator TextRaw() const { return value; }
};

#ifdef SDL3PP_DOC

/**
 * @name TTF version
 * @{
 * Printable format: "%d.%d.%d", MAJOR, MINOR, MICRO
 */
#define SDL_TTF_MAJOR_VERSION

#define SDL_TTF_MINOR_VERSION

#define SDL_TTF_MICRO_VERSION

///@}

/**
 * This is the version number macro for the current SDL_ttf version.
 */
#define SDL_TTF_VERSION                                                        \
  SDL_VERSIONNUM(                                                              \
    SDL_TTF_MAJOR_VERSION, SDL_TTF_MINOR_VERSION, SDL_TTF_MICRO_VERSION)

/**
 * This macro will evaluate to true if compiled with SDL_ttf at least X.Y.Z.
 */
#define SDL_TTF_VERSION_ATLEAST(X, Y, Z)                                       \
  ((SDL_TTF_MAJOR_VERSION >= X) &&                                             \
   (SDL_TTF_MAJOR_VERSION > X || SDL_TTF_MINOR_VERSION >= Y) &&                \
   (SDL_TTF_MAJOR_VERSION > X || SDL_TTF_MINOR_VERSION > Y ||                  \
    SDL_TTF_MICRO_VERSION >= Z))

#endif // SDL3PP_DOC

namespace TTF {

/**
 * This function gets the version of the dynamically linked SDL_ttf library.
 *
 * @returns SDL_ttf version.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline int Version() { return TTF_Version(); }

/**
 * Initialize SDL_ttf.
 *
 * You must successfully call this function before it is safe to call any
 * other function in this library.
 *
 * It is safe to call this more than once, and each successful TTF.Init() call
 * should be paired with a matching TTF.Quit() call.
 *
 * @throws Error on failure.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa TTF.Quit
 */
inline void Init() { CheckError(TTF_Init()); }

/**
 * Deinitialize SDL_ttf.
 *
 * You must call this when done with the library, to free internal resources.
 * It is safe to call this when the library isn't initialized, as it will just
 * return immediately.
 *
 * Once you have as many quit calls as you have had successful calls to
 * TTF.Init, the library will actually deinitialize.
 *
 * Please note that this does not automatically close any fonts that are still
 * open at the time of deinitialization, and it is possibly not safe to close
 * them afterwards, as parts of the library will no longer be initialized to
 * deal with it. A well-written program should call Font.Close() on any
 * open fonts before calling this function!
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline void Quit() { TTF_Quit(); }

/**
 * Check if SDL_ttf is initialized.
 *
 * This reports the number of times the library has been initialized by a call
 * to TTF.Init(), without a paired deinitialization request from TTF.Quit().
 *
 * In short: if it's greater than zero, the library is currently initialized
 * and ready to work. If zero, it is not initialized.
 *
 * Despite the return value being a signed integer, this function should not
 * return a negative number.
 *
 * @returns the current number of initialization calls, that need to
 *          eventually be paired with this many calls to TTF.Quit().
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa TTF.Init
 * @sa TTF.Quit
 */
inline int WasInit() { return TTF_WasInit(); }

} // namespace TTF

/**
 * Query the version of the FreeType library in use.
 *
 * TTF.Init() should be called before calling this function.
 *
 * @param major to be filled in with the major version number. Can be nullptr.
 * @param minor to be filled in with the minor version number. Can be nullptr.
 * @param patch to be filled in with the param version number. Can be nullptr.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa TTF.Init
 */
inline void GetFreeTypeVersion(int* major, int* minor, int* patch)
{
  TTF_GetFreeTypeVersion(major, minor, patch);
}

/**
 * Query the version of the HarfBuzz library in use.
 *
 * If HarfBuzz is not available, the version reported is 0.0.0.
 *
 * @param major to be filled in with the major version number. Can be nullptr.
 * @param minor to be filled in with the minor version number. Can be nullptr.
 * @param patch to be filled in with the param version number. Can be nullptr.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline void GetHarfBuzzVersion(int* major, int* minor, int* patch)
{
  TTF_GetHarfBuzzVersion(major, minor, patch);
}

using TextData = TTF_TextData;

/**
 * Font style flags for Font
 *
 * These are the flags which can be used to set the style of a font in
 * SDL_ttf. A combination of these flags can be used with functions that set
 * or query font style, such as Font.SetStyle or Font.GetStyle.
 *
 * @since This datatype is available since SDL_ttf 3.0.0.
 *
 * @sa Font.SetStyle
 * @sa Font.GetStyle
 */
using FontStyleFlags = Uint32;

constexpr FontStyleFlags STYLE_NORMAL = TTF_STYLE_NORMAL; ///< No special style

constexpr FontStyleFlags STYLE_BOLD = TTF_STYLE_BOLD; ///< Bold style

constexpr FontStyleFlags STYLE_ITALIC = TTF_STYLE_ITALIC; ///< Italic style

constexpr FontStyleFlags STYLE_UNDERLINE =
  TTF_STYLE_UNDERLINE; ///< Underlined text

constexpr FontStyleFlags STYLE_STRIKETHROUGH =
  TTF_STYLE_STRIKETHROUGH; ///< Strikethrough text

/**
 * Hinting flags for TTF (TrueType Fonts)
 *
 * This enum specifies the level of hinting to be applied to the font
 * rendering. The hinting level determines how much the font's outlines are
 * adjusted for better alignment on the pixel grid.
 *
 * @since This enum is available since SDL_ttf 3.0.0.
 *
 * @sa Font.SetHinting
 * @sa Font.GetHinting
 */
using HintingFlags = TTF_HintingFlags;

constexpr HintingFlags HINTING_INVALID = TTF_HINTING_INVALID; ///< INVALID

constexpr HintingFlags HINTING_NORMAL =
  TTF_HINTING_NORMAL; ///< Normal hinting applies standard grid-fitting.

/// Light hinting applies subtle adjustments to improve rendering.
constexpr HintingFlags HINTING_LIGHT = TTF_HINTING_LIGHT;

/**
 * Monochrome hinting adjusts the font for better rendering at lower
 * resolutions.
 */
constexpr HintingFlags HINTING_MONO = TTF_HINTING_MONO;

/// No hinting, the font is rendered without any grid-fitting.
constexpr HintingFlags HINTING_NONE = TTF_HINTING_NONE;

/// Light hinting with subpixel rendering for more precise font edges.
constexpr HintingFlags HINTING_LIGHT_SUBPIXEL = TTF_HINTING_LIGHT_SUBPIXEL;

/**
 * The horizontal alignment used when rendering wrapped text.
 *
 * @since This enum is available since SDL_ttf 3.0.0.
 */
using HorizontalAlignment = TTF_HorizontalAlignment;

constexpr HorizontalAlignment HORIZONTAL_ALIGN_INVALID =
  TTF_HORIZONTAL_ALIGN_INVALID; ///< INVALID

constexpr HorizontalAlignment HORIZONTAL_ALIGN_LEFT =
  TTF_HORIZONTAL_ALIGN_LEFT; ///< LEFT

constexpr HorizontalAlignment HORIZONTAL_ALIGN_CENTER =
  TTF_HORIZONTAL_ALIGN_CENTER; ///< CENTER

constexpr HorizontalAlignment HORIZONTAL_ALIGN_RIGHT =
  TTF_HORIZONTAL_ALIGN_RIGHT; ///< RIGHT

/**
 * Direction flags
 *
 * The values here are chosen to match
 * [hb_direction_t](https://harfbuzz.github.io/harfbuzz-hb-common.html#hb-direction-t)
 * .
 *
 * @since This enum is available since SDL_ttf 3.0.0.
 *
 * @sa Font.SetDirection
 */
using Direction = TTF_Direction;

constexpr Direction DIRECTION_INVALID = TTF_DIRECTION_INVALID; ///< INVALID

constexpr Direction DIRECTION_LTR = TTF_DIRECTION_LTR; ///< Left to Right.

constexpr Direction DIRECTION_RTL = TTF_DIRECTION_RTL; ///< Right to Left.

constexpr Direction DIRECTION_TTB = TTF_DIRECTION_TTB; ///< Top to Bottom.

constexpr Direction DIRECTION_BTT = TTF_DIRECTION_BTT; ///< Bottom to Top.

/**
 * The type of data in a glyph image
 *
 * @since This enum is available since SDL_ttf 3.0.0.
 */
using ImageType = TTF_ImageType;

constexpr ImageType IMAGE_INVALID = TTF_IMAGE_INVALID; ///< INVALID

constexpr ImageType IMAGE_ALPHA =
  TTF_IMAGE_ALPHA; ///< The color channels are white.

constexpr ImageType IMAGE_COLOR =
  TTF_IMAGE_COLOR; ///< The color channels have image data.

/// The alpha channel has signed distance field information.
constexpr ImageType IMAGE_SDF = TTF_IMAGE_SDF;

/**
 * The internal structure containing font information.
 *
 * Opaque data!
 *
 * @cat resource
 */
class Font
{
  FontRaw m_resource = nullptr;

public:
  /// Default ctor
  constexpr Font() = default;

  /**
   * Constructs from FontParam.
   *
   * @param resource a FontRaw to be wrapped.
   *
   * This assumes the ownership, call release() if you need to take back.
   */
  constexpr explicit Font(const FontRaw resource)
    : m_resource(resource)
  {
  }

  /// Copy constructor
  constexpr Font(const Font& other) = delete;

  /// Move constructor
  constexpr Font(Font&& other)
    : Font(other.release())
  {
  }

  constexpr Font(const FontRef& other) = delete;

  constexpr Font(FontRef&& other) = delete;

  /**
   * Create a font from a file, using a specified point size.
   *
   * Some .fon fonts will have several sizes embedded in the file, so the point
   * size becomes the index of choosing which size. If the value is too high,
   * the last indexed size will be the default.
   *
   * @param file path to font file.
   * @param ptsize point size to use for the newly-opened font.
   * @post a valid Font on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.Close
   */
  Font(StringParam file, float ptsize)
    : m_resource(CheckError(TTF_OpenFont(file, ptsize)))
  {
  }

  /**
   * Create a font from an IOStream, using a specified point size.
   *
   * Some .fon fonts will have several sizes embedded in the file, so the point
   * size becomes the index of choosing which size. If the value is too high,
   * the last indexed size will be the default.
   *
   * If `closeio` is true, `src` will be automatically closed once the font is
   * closed. Otherwise you should keep `src` open until the font is closed.
   *
   * @param src an IOStream to provide a font file's data.
   * @param ptsize point size to use for the newly-opened font.
   * @param closeio true to close `src` when the font is closed, false to leave
   *                it open.
   * @post a valid Font on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.Close
   */
  Font(IOStreamParam src, float ptsize, bool closeio = false)
    : m_resource(CheckError(TTF_OpenFontIO(src, closeio, ptsize)))
  {
  }

  /**
   * Create a font with the specified properties.
   *
   * These are the supported properties:
   *
   * - `prop::Font.CREATE_FILENAME_STRING`: the font file to open, if an
   *   IOStream isn't being used. This is required if
   *   `prop::Font.CREATE_IOSTREAM_POINTER` and
   *   `prop::Font.CREATE_EXISTING_FONT_POINTER` aren't set.
   * - `prop::Font.CREATE_IOSTREAM_POINTER`: an IOStream containing the
   *   font to be opened. This should not be closed until the font is closed.
   *   This is required if `prop::Font.CREATE_FILENAME_STRING` and
   *   `prop::Font.CREATE_EXISTING_FONT_POINTER` aren't set.
   * - `prop::Font.CREATE_IOSTREAM_OFFSET_NUMBER`: the offset in the iostream
   *   for the beginning of the font, defaults to 0.
   * - `prop::Font.CREATE_IOSTREAM_AUTOCLOSE_BOOLEAN`: true if closing the
   *   font should also close the associated IOStream.
   * - `prop::Font.CREATE_SIZE_FLOAT`: the point size of the font. Some .fon
   *   fonts will have several sizes embedded in the file, so the point size
   *   becomes the index of choosing which size. If the value is too high, the
   *   last indexed size will be the default.
   * - `prop::Font.CREATE_FACE_NUMBER`: the face index of the font, if the
   *   font contains multiple font faces.
   * - `prop::Font.CREATE_HORIZONTAL_DPI_NUMBER`: the horizontal DPI to use
   *   for font rendering, defaults to
   *   `prop::Font.CREATE_VERTICAL_DPI_NUMBER` if set, or 72 otherwise.
   * - `prop::Font.CREATE_VERTICAL_DPI_NUMBER`: the vertical DPI to use for
   *   font rendering, defaults to `prop::Font.CREATE_HORIZONTAL_DPI_NUMBER`
   *   if set, or 72 otherwise.
   * - `prop::Font.CREATE_EXISTING_FONT_POINTER`: an optional Font that, if set,
   *   will be used as the font data source and the initial size and style of
   *   the new font.
   *
   * @param props the properties to use.
   * @post a valid Font on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.Close
   */
  Font(PropertiesParam props)
    : m_resource(CheckError(TTF_OpenFontWithProperties(props)))
  {
  }

  /// Destructor
  ~Font() { TTF_CloseFont(m_resource); }

  /// Assignment operator.
  Font& operator=(Font other)
  {
    std::swap(m_resource, other.m_resource);
    return *this;
  }

  /// Retrieves underlying FontRaw.
  constexpr FontRaw get() const { return m_resource; }

  /// Retrieves underlying FontRaw and clear this.
  constexpr FontRaw release()
  {
    auto r = m_resource;
    m_resource = nullptr;
    return r;
  }

  /// Comparison
  constexpr auto operator<=>(const Font& other) const = default;

  /// Comparison
  constexpr bool operator==(std::nullptr_t _) const { return !m_resource; }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!m_resource; }

  /// Converts to FontParam
  constexpr operator FontParam() const { return {m_resource}; }

  /**
   * Dispose of a previously-created font.
   *
   * Call this when done with a font. This function will free any resources
   * associated with it. It is safe to call this function on nullptr, for
   * example on the result of a failed call to Font.Font().
   *
   * The font is not valid after being passed to this function. String pointers
   * from functions that return information on this font, such as
   * Font.GetFamilyName() and Font.GetStyleName(), are no longer valid
   * after this call, as well.
   *
   *
   * @threadsafety This function should not be called while any other thread is
   *               using the font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.Font
   */
  void Close();

  /**
   * Create a copy of an existing font.
   *
   * The copy will be distinct from the original, but will share the font file
   * and have the same size and style as the original.
   *
   * @returns a valid Font on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               original font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.Close
   */
  Font Copy() const;

  /**
   * Get the properties associated with a font.
   *
   * The following read-write properties are provided by SDL:
   *
   * - `prop::Font.OUTLINE_LINE_CAP_NUMBER`: The FT_Stroker_LineCap value
   *   used when setting the font outline, defaults to
   *   `FT_STROKER_LINECAP_ROUND`.
   * - `prop::Font.OUTLINE_LINE_JOIN_NUMBER`: The FT_Stroker_LineJoin value
   *   used when setting the font outline, defaults to
   *   `FT_STROKER_LINEJOIN_ROUND`.
   * - `prop::Font.OUTLINE_MITER_LIMIT_NUMBER`: The FT_Fixed miter limit used
   *   when setting the font outline, defaults to 0.
   *
   * @returns a valid property ID on success.
   * @throws Error on failure.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  PropertiesRef GetProperties();

  /**
   * Get the font generation.
   *
   * The generation is incremented each time font properties change that require
   * rebuilding glyphs, such as style, size, etc.
   *
   * @returns the font generation or 0 on failure; call GetError() for more
   *          information.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  Uint32 GetGeneration() const;

  /**
   * Add a fallback font.
   *
   * Add a font that will be used for glyphs that are not in the current font.
   * The fallback font should have the same size and style as the current font.
   *
   * If there are multiple fallback fonts, they are used in the order added.
   *
   * This updates any Text objects using this font.
   *
   * @param fallback the font to add as a fallback.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created
   *               both fonts.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.ClearFallbacks
   * @sa Font.RemoveFallback
   */
  void AddFallback(FontParam fallback);

  /**
   * Remove a fallback font.
   *
   * This updates any Text objects using this font.
   *
   * @param fallback the font to remove as a fallback.
   *
   * @threadsafety This function should be called on the thread that created
   *               both fonts.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.AddFallback
   * @sa Font.ClearFallbacks
   */
  void RemoveFallback(FontParam fallback);

  /**
   * Remove all fallback fonts.
   *
   * This updates any Text objects using this font.
   *
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.AddFallback
   * @sa Font.RemoveFallback
   */
  void ClearFallbacks();

  /**
   * Set a font's size dynamically.
   *
   * This updates any Text objects using this font, and clears
   * already-generated glyphs, if any, from the cache.
   *
   * @param ptsize the new point size.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.GetSize
   */
  void SetSize(float ptsize);

  /**
   * Set font size dynamically with target resolutions, in dots per inch.
   *
   * This updates any Text objects using this font, and clears
   * already-generated glyphs, if any, from the cache.
   *
   * @param ptsize the new point size.
   * @param hdpi the target horizontal DPI.
   * @param vdpi the target vertical DPI.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.GetSize
   * @sa TTF_GetFontSizeDPI
   */
  void SetSizeDPI(float ptsize, int hdpi, int vdpi);

  /**
   * Get the size of a font.
   *
   * @returns the size of the font, or 0.0f on failure; call GetError() for
   *          more information.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.SetSize
   * @sa Font.SetSizeDPI
   */
  float GetSize() const;

  /**
   * Get font target resolutions, in dots per inch.
   *
   * @param hdpi a pointer filled in with the target horizontal DPI.
   * @param vdpi a pointer filled in with the target vertical DPI.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.SetSizeDPI
   */
  void GetDPI(int* hdpi, int* vdpi) const;

  /**
   * Set a font's current style.
   *
   * This updates any Text objects using this font, and clears
   * already-generated glyphs, if any, from the cache.
   *
   * The font styles are a set of bit flags, OR'd together:
   *
   * - `STYLE_NORMAL` (is zero)
   * - `STYLE_BOLD`
   * - `STYLE_ITALIC`
   * - `STYLE_UNDERLINE`
   * - `STYLE_STRIKETHROUGH`
   *
   * @param style the new style values to set, OR'd together.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.GetStyle
   */
  void SetStyle(FontStyleFlags style);

  /**
   * Query a font's current style.
   *
   * The font styles are a set of bit flags, OR'd together:
   *
   * - `STYLE_NORMAL` (is zero)
   * - `STYLE_BOLD`
   * - `STYLE_ITALIC`
   * - `STYLE_UNDERLINE`
   * - `STYLE_STRIKETHROUGH`
   *
   * @returns the current font style, as a set of bit flags.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.SetStyle
   */
  FontStyleFlags GetStyle() const;

  /**
   * Set a font's current outline.
   *
   * This uses the font properties `prop::Font.OUTLINE_LINE_CAP_NUMBER`,
   * `prop::Font.OUTLINE_LINE_JOIN_NUMBER`, and
   * `prop::Font.OUTLINE_MITER_LIMIT_NUMBER` when setting the font outline.
   *
   * This updates any Text objects using this font, and clears
   * already-generated glyphs, if any, from the cache.
   *
   * @param outline positive outline value, 0 to default.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.GetOutline
   */
  void SetOutline(int outline);

  /**
   * Query a font's current outline.
   *
   * @returns the font's current outline value.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.SetOutline
   */
  int GetOutline() const;

  /**
   * Set a font's current hinter setting.
   *
   * This updates any Text objects using this font, and clears
   * already-generated glyphs, if any, from the cache.
   *
   * The hinter setting is a single value:
   *
   * - `HINTING_NORMAL`
   * - `HINTING_LIGHT`
   * - `HINTING_MONO`
   * - `HINTING_NONE`
   * - `HINTING_LIGHT_SUBPIXEL` (available in SDL_ttf 3.0.0 and later)
   *
   * @param hinting the new hinter setting.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.GetHinting
   */
  void SetHinting(HintingFlags hinting);

  /**
   * Query the number of faces of a font.
   *
   * @returns the number of FreeType font faces.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  int GetNumFaces() const;

  /**
   * Query a font's current FreeType hinter setting.
   *
   * The hinter setting is a single value:
   *
   * - `HINTING_NORMAL`
   * - `HINTING_LIGHT`
   * - `HINTING_MONO`
   * - `HINTING_NONE`
   * - `HINTING_LIGHT_SUBPIXEL` (available in SDL_ttf 3.0.0 and later)
   *
   * @returns the font's current hinter value, or HINTING_INVALID if the
   *          font is invalid.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.SetHinting
   */
  HintingFlags GetHinting() const;

  /**
   * Enable Signed Distance Field rendering for a font.
   *
   * SDF is a technique that helps fonts look sharp even when scaling and
   * rotating, and requires special shader support for display.
   *
   * This works with Blended APIs, and generates the raw signed distance values
   * in the alpha channel of the resulting texture.
   *
   * This updates any Text objects using this font, and clears
   * already-generated glyphs, if any, from the cache.
   *
   * @param enabled true to enable SDF, false to disable.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.GetSDF
   */
  void SetSDF(bool enabled);

  /**
   * Query whether Signed Distance Field rendering is enabled for a font.
   *
   * @returns true if enabled, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.SetSDF
   */
  bool GetSDF() const;

#if SDL_TTF_VERSION_ATLEAST(3, 2, 2)

  /**
   * Query a font's weight, in terms of the lightness/heaviness of the strokes.
   *
   * @returns the font's current weight.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.2.2.
   */
  int GetWeight() const;

#endif // SDL_TTF_VERSION_ATLEAST(3, 2, 2)

  /**
   * Set a font's current wrap alignment option.
   *
   * This updates any Text objects using this font.
   *
   * @param align the new wrap alignment option.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.GetWrapAlignment
   */
  void SetWrapAlignment(HorizontalAlignment align);

  /**
   * Query a font's current wrap alignment option.
   *
   * @returns the font's current wrap alignment option.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.SetWrapAlignment
   */
  HorizontalAlignment GetWrapAlignment() const;

  /**
   * Query the total height of a font.
   *
   * This is usually equal to point size.
   *
   * @returns the font's height.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  int GetHeight() const;

  /**
   * Query the offset from the baseline to the top of a font.
   *
   * This is a positive value, relative to the baseline.
   *
   * @returns the font's ascent.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  int GetAscent() const;

  /**
   * Query the offset from the baseline to the bottom of a font.
   *
   * This is a negative value, relative to the baseline.
   *
   * @returns the font's descent.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  int GetDescent() const;

  /**
   * Set the spacing between lines of text for a font.
   *
   * This updates any Text objects using this font.
   *
   * @param lineskip the new line spacing for the font.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.GetLineSkip
   */
  void SetLineSkip(int lineskip);

  /**
   * Query the spacing between lines of text for a font.
   *
   * @returns the font's recommended spacing.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.SetLineSkip
   */
  int GetLineSkip() const;

  /**
   * Set if kerning is enabled for a font.
   *
   * Newly-opened fonts default to allowing kerning. This is generally a good
   * policy unless you have a strong reason to disable it, as it tends to
   * produce better rendering (with kerning disabled, some fonts might render
   * the word `kerning` as something that looks like `keming` for example).
   *
   * This updates any Text objects using this font.
   *
   * @param enabled true to enable kerning, false to disable.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.GetKerning
   */
  void SetKerning(bool enabled);

  /**
   * Query whether or not kerning is enabled for a font.
   *
   * @returns true if kerning is enabled, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.SetKerning
   */
  bool GetKerning() const;

  /**
   * Query whether a font is fixed-width.
   *
   * A "fixed-width" font means all glyphs are the same width across; a
   * lowercase 'i' will be the same size across as a capital 'W', for example.
   * This is common for terminals and text editors, and other apps that treat
   * text as a grid. Most other things (WYSIWYG word processors, web pages, etc)
   * are more likely to not be fixed-width in most cases.
   *
   * @returns true if the font is fixed-width, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  bool IsFixedWidth() const;

  /**
   * Query whether a font is scalable or not.
   *
   * Scalability lets us distinguish between outline and bitmap fonts.
   *
   * @returns true if the font is scalable, false otherwise.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.SetSDF
   */
  bool IsScalable() const;

  /**
   * Query a font's family name.
   *
   * This string is dictated by the contents of the font file.
   *
   * Note that the returned string is to internal storage, and should not be
   * modified or free'd by the caller. The string becomes invalid, with the rest
   * of the font, when `font` is handed to Font.Close().
   *
   * @returns the font's family name.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  const char* GetFamilyName() const;

  /**
   * Query a font's style name.
   *
   * This string is dictated by the contents of the font file.
   *
   * Note that the returned string is to internal storage, and should not be
   * modified or free'd by the caller. The string becomes invalid, with the rest
   * of the font, when `font` is handed to Font.Close().
   *
   * @returns the font's style name.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  const char* GetStyleName() const;

  /**
   * Set the direction to be used for text shaping by a font.
   *
   * This function only supports left-to-right text shaping if SDL_ttf was not
   * built with HarfBuzz support.
   *
   * This updates any Text objects using this font.
   *
   * @param direction the new direction for text to flow.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  void SetDirection(Direction direction);

  /**
   * Get the direction to be used for text shaping by a font.
   *
   * This defaults to DIRECTION_INVALID if it hasn't been set.
   *
   * @returns the direction to be used for text shaping.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  Direction GetDirection() const;

  /**
   * Set the script to be used for text shaping by a font.
   *
   * This returns false if SDL_ttf isn't built with HarfBuzz support.
   *
   * This updates any Text objects using this font.
   *
   * @param script an
   *               [ISO 15924
   * code](https://unicode.org/iso15924/iso15924-codes.html)
   *               .
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa StringToTag
   */
  void SetScript(Uint32 script);

  /**
   * Get the script used for text shaping a font.
   *
   * @returns an
   *          [ISO 15924 code](https://unicode.org/iso15924/iso15924-codes.html)
   *          or 0 if a script hasn't been set.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa TagToString
   */
  Uint32 GetScript() const;

  /**
   * Get the script used by a 32-bit codepoint.
   *
   * @param ch the character code to check.
   * @returns an
   *          [ISO 15924 code](https://unicode.org/iso15924/iso15924-codes.html)
   *          on success, or 0 on failure; call GetError() for more
   *          information.
   *
   * @threadsafety This function is thread-safe.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa TagToString
   */
  static Uint32 GetGlyphScript(Uint32 ch);

  /**
   * Set language to be used for text shaping by a font.
   *
   * If SDL_ttf was not built with HarfBuzz support, this function returns
   * false.
   *
   * This updates any Text objects using this font.
   *
   * @param language_bcp47 a null-terminated string containing the desired
   *                       language's BCP47 code. Or null to reset the value.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  void SetLanguage(StringParam language_bcp47);

  /**
   * Check whether a glyph is provided by the font for a UNICODE codepoint.
   *
   * @param ch the codepoint to check.
   * @returns true if font provides a glyph for this character, false if not.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  bool HasGlyph(Uint32 ch) const;

  /**
   * Get the pixel image for a UNICODE codepoint.
   *
   * @param ch the codepoint to check.
   * @param image_type a pointer filled in with the glyph image type, may be
   *                   nullptr.
   * @returns an Surface containing the glyph, or nullptr on failure; call
   *          GetError() for more information.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  Surface GetGlyphImage(Uint32 ch, ImageType* image_type) const;

  /**
   * Get the pixel image for a character index.
   *
   * This is useful for text engine implementations, which can call this with
   * the `glyph_index` in a TTF_CopyOperation
   *
   * @param glyph_index the index of the glyph to return.
   * @param image_type a pointer filled in with the glyph image type, may be
   *                   nullptr.
   * @returns an Surface containing the glyph, or nullptr on failure; call
   *          GetError() for more information.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  Surface GetGlyphImageForIndex(Uint32 glyph_index,
                                ImageType* image_type) const;

  /**
   * Query the metrics (dimensions) of a font's glyph for a UNICODE codepoint.
   *
   * To understand what these metrics mean, here is a useful link:
   *
   * https://freetype.sourceforge.net/freetype2/docs/tutorial/step2.html
   *
   * @param ch the codepoint to check.
   * @param minx a pointer filled in with the minimum x coordinate of the glyph
   *             from the left edge of its bounding box. This value may be
   *             negative.
   * @param maxx a pointer filled in with the maximum x coordinate of the glyph
   *             from the left edge of its bounding box.
   * @param miny a pointer filled in with the minimum y coordinate of the glyph
   *             from the bottom edge of its bounding box. This value may be
   *             negative.
   * @param maxy a pointer filled in with the maximum y coordinate of the glyph
   *             from the bottom edge of its bounding box.
   * @param advance a pointer filled in with the distance to the next glyph from
   *                the left edge of this glyph's bounding box.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  void GetGlyphMetrics(Uint32 ch,
                       int* minx,
                       int* maxx,
                       int* miny,
                       int* maxy,
                       int* advance) const;

  /**
   * Query the kerning size between the glyphs of two UNICODE codepoints.
   *
   * @param previous_ch the previous codepoint.
   * @param ch the current codepoint.
   * @returns the kerning size between the two glyphs, in pixels.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  int GetGlyphKerning(Uint32 previous_ch, Uint32 ch) const;

  /**
   * Calculate the dimensions of a rendered string of UTF-8 text.
   *
   * This will report the width and height, in pixels, of the space that the
   * specified string will take to fully render.
   *
   * @param text text to calculate, in UTF-8 encoding.
   * @returns return a Point with the width, height.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  Point GetStringSize(std::string_view text) const
  {
    Point p;
    GetStringSize(text, &p.x, &p.y);
    return p;
  }

  /**
   * Calculate the dimensions of a rendered string of UTF-8 text.
   *
   * This will report the width and height, in pixels, of the space that the
   * specified string will take to fully render.
   *
   * @param text text to calculate, in UTF-8 encoding.
   * @param w will be filled with width, in pixels, on return.
   * @param h will be filled with height, in pixels, on return.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  void GetStringSize(std::string_view text, int* w, int* h) const;

  /**
   * Calculate the dimensions of a rendered string of UTF-8 text.
   *
   * This will report the width and height, in pixels, of the space that the
   * specified string will take to fully render.
   *
   * Text is wrapped to multiple lines on line endings and on word boundaries if
   * it extends beyond `wrap_width` in pixels.
   *
   * If wrap_width is 0, this function will only wrap on newline characters.
   *
   * @param text text to calculate, in UTF-8 encoding.
   * @param wrap_width the maximum width or 0 to wrap on newline characters.
   * @returns return a Point with the width, height on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  Point GetStringSizeWrapped(std::string_view text, int wrap_width) const
  {
    Point p;
    GetStringSizeWrapped(text, wrap_width, &p.x, &p.y);
    return p;
  }

  /**
   * Calculate the dimensions of a rendered string of UTF-8 text.
   *
   * This will report the width and height, in pixels, of the space that the
   * specified string will take to fully render.
   *
   * Text is wrapped to multiple lines on line endings and on word boundaries if
   * it extends beyond `wrap_width` in pixels.
   *
   * If wrap_width is 0, this function will only wrap on newline characters.
   *
   * @param text text to calculate, in UTF-8 encoding.
   * @param wrap_width the maximum width or 0 to wrap on newline characters.
   * @param w will be filled with width, in pixels, on return.
   * @param h will be filled with height, in pixels, on return.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  void GetStringSizeWrapped(std::string_view text,
                            int wrap_width,
                            int* w,
                            int* h) const;

  /**
   * Calculate how much of a UTF-8 string will fit in a given width.
   *
   * This reports the number of characters that can be rendered before reaching
   * `max_width`.
   *
   * This does not need to render the string to do this calculation.
   *
   * @param text text to calculate, in UTF-8 encoding.
   * @param max_width maximum width, in pixels, available for the string, or 0
   *                  for unbounded width.
   * @param measured_width a pointer filled in with the width, in pixels, of the
   *                       string that will fit, may be nullptr.
   * @param measured_length a pointer filled in with the length, in bytes, of
   *                        the string that will fit, may be nullptr.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  void MeasureString(std::string_view text,
                     int max_width,
                     int* measured_width,
                     size_t* measured_length) const;

  /**
   * Render UTF-8 text at fast quality to a new 8-bit surface.
   *
   * This function will allocate a new 8-bit, palettized surface. The surface's
   * 0 pixel will be the colorkey, giving a transparent background. The 1 pixel
   * will be set to the text color.
   *
   * This will not word-wrap the string; you'll get a surface with a single line
   * of text, as long as the string requires. You can use
   * Font.RenderText_Solid_Wrapped() instead if you need to wrap the output to
   * multiple lines.
   *
   * This will not wrap on newline characters.
   *
   * You can render at other quality levels with Font.RenderText_Shaded,
   * Font.RenderText_Blended, and Font.RenderText_LCD.
   *
   * @param text text to render, in UTF-8 encoding.
   * @param fg the foreground color for the text.
   * @returns a new 8-bit, palettized surface, or nullptr if there was an error.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.RenderText_Blended
   * @sa Font.RenderText_LCD
   * @sa Font.RenderText_Shaded
   * @sa Font.RenderText_Solid
   * @sa Font.RenderText_Solid_Wrapped
   */
  Surface RenderText_Solid(std::string_view text, Color fg) const;

  /**
   * Render word-wrapped UTF-8 text at fast quality to a new 8-bit surface.
   *
   * This function will allocate a new 8-bit, palettized surface. The surface's
   * 0 pixel will be the colorkey, giving a transparent background. The 1 pixel
   * will be set to the text color.
   *
   * Text is wrapped to multiple lines on line endings and on word boundaries if
   * it extends beyond `wrapLength` in pixels.
   *
   * If wrapLength is 0, this function will only wrap on newline characters.
   *
   * You can render at other quality levels with Font.RenderText_Shaded_Wrapped,
   * Font.RenderText_Blended_Wrapped, and Font.RenderText_LCD_Wrapped.
   *
   * @param text text to render, in UTF-8 encoding.
   * @param fg the foreground color for the text.
   * @param wrapLength the maximum width of the text surface or 0 to wrap on
   *                   newline characters.
   * @returns a new 8-bit, palettized surface, or nullptr if there was an error.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.RenderText_Blended_Wrapped
   * @sa Font.RenderText_LCD_Wrapped
   * @sa Font.RenderText_Shaded_Wrapped
   * @sa Font.RenderText_Solid
   */
  Surface RenderText_Solid_Wrapped(std::string_view text,
                                   Color fg,
                                   int wrapLength) const;

  /**
   * Render a single 32-bit glyph at fast quality to a new 8-bit surface.
   *
   * This function will allocate a new 8-bit, palettized surface. The surface's
   * 0 pixel will be the colorkey, giving a transparent background. The 1 pixel
   * will be set to the text color.
   *
   * The glyph is rendered without any padding or centering in the X direction,
   * and aligned normally in the Y direction.
   *
   * You can render at other quality levels with Font.RenderGlyph_Shaded,
   * Font.RenderGlyph_Blended, and Font.RenderGlyph_LCD.
   *
   * @param ch the character to render.
   * @param fg the foreground color for the text.
   * @returns a new 8-bit, palettized surface, or nullptr if there was an error.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.RenderGlyph_Blended
   * @sa Font.RenderGlyph_LCD
   * @sa Font.RenderGlyph_Shaded
   */
  Surface RenderGlyph_Solid(Uint32 ch, ColorRaw fg) const;

  /**
   * Render UTF-8 text at high quality to a new 8-bit surface.
   *
   * This function will allocate a new 8-bit, palettized surface. The surface's
   * 0 pixel will be the specified background color, while other pixels have
   * varying degrees of the foreground color. This function returns the new
   * surface, or nullptr if there was an error.
   *
   * This will not word-wrap the string; you'll get a surface with a single line
   * of text, as long as the string requires. You can use
   * Font.RenderText_Shaded_Wrapped() instead if you need to wrap the output to
   * multiple lines.
   *
   * This will not wrap on newline characters.
   *
   * You can render at other quality levels with Font.RenderText_Solid,
   * Font.RenderText_Blended, and Font.RenderText_LCD.
   *
   * @param text text to render, in UTF-8 encoding.
   * @param fg the foreground color for the text.
   * @param bg the background color for the text.
   * @returns a new 8-bit, palettized surface, or nullptr if there was an error.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.RenderText_Blended
   * @sa Font.RenderText_LCD
   * @sa Font.RenderText_Shaded_Wrapped
   * @sa Font.RenderText_Solid
   */
  Surface RenderText_Shaded(std::string_view text, Color fg, Color bg) const;

  /**
   * Render word-wrapped UTF-8 text at high quality to a new 8-bit surface.
   *
   * This function will allocate a new 8-bit, palettized surface. The surface's
   * 0 pixel will be the specified background color, while other pixels have
   * varying degrees of the foreground color. This function returns the new
   * surface, or nullptr if there was an error.
   *
   * Text is wrapped to multiple lines on line endings and on word boundaries if
   * it extends beyond `wrap_width` in pixels.
   *
   * If wrap_width is 0, this function will only wrap on newline characters.
   *
   * You can render at other quality levels with Font.RenderText_Solid_Wrapped,
   * Font.RenderText_Blended_Wrapped, and Font.RenderText_LCD_Wrapped.
   *
   * @param font the font to render with.
   * @param text text to render, in UTF-8 encoding.
   * @param fg the foreground color for the text.
   * @param bg the background color for the text.
   * @param wrap_width the maximum width of the text surface or 0 to wrap on
   *                   newline characters.
   * @returns a new 8-bit, palettized surface, or nullptr if there was an error.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.RenderText_Blended_Wrapped
   * @sa Font.RenderText_LCD_Wrapped
   * @sa Font.RenderText_Shaded
   * @sa Font.RenderText_Solid_Wrapped
   */
  Surface RenderText_Shaded_Wrapped(std::string_view text,
                                    Color fg,
                                    Color bg,
                                    int wrap_width) const;

  /**
   * Render a single UNICODE codepoint at high quality to a new 8-bit surface.
   *
   * This function will allocate a new 8-bit, palettized surface. The surface's
   * 0 pixel will be the specified background color, while other pixels have
   * varying degrees of the foreground color. This function returns the new
   * surface, or nullptr if there was an error.
   *
   * The glyph is rendered without any padding or centering in the X direction,
   * and aligned normally in the Y direction.
   *
   * You can render at other quality levels with Font.RenderGlyph_Solid,
   * Font.RenderGlyph_Blended, and Font.RenderGlyph_LCD.
   *
   * @param ch the codepoint to render.
   * @param fg the foreground color for the text.
   * @param bg the background color for the text.
   * @returns a new 8-bit, palettized surface, or nullptr if there was an error.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.RenderGlyph_Blended
   * @sa Font.RenderGlyph_LCD
   * @sa Font.RenderGlyph_Solid
   */
  Surface RenderGlyph_Shaded(Uint32 ch, ColorRaw fg, ColorRaw bg) const;

  /**
   * Render UTF-8 text at high quality to a new ARGB surface.
   *
   * This function will allocate a new 32-bit, ARGB surface, using alpha
   * blending to dither the font with the given color. This function returns the
   * new surface, or nullptr if there was an error.
   *
   * This will not word-wrap the string; you'll get a surface with a single line
   * of text, as long as the string requires. You can use
   * Font.RenderText_Blended_Wrapped() instead if you need to wrap the output to
   * multiple lines.
   *
   * This will not wrap on newline characters.
   *
   * You can render at other quality levels with Font.RenderText_Solid,
   * Font.RenderText_Shaded, and Font.RenderText_LCD.
   *
   * @param font the font to render with.
   * @param text text to render, in UTF-8 encoding.
   * @param fg the foreground color for the text.
   * @returns a new 32-bit, ARGB surface, or nullptr if there was an error.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.RenderText_Blended_Wrapped
   * @sa Font.RenderText_LCD
   * @sa Font.RenderText_Shaded
   * @sa Font.RenderText_Solid
   */
  Surface RenderText_Blended(std::string_view text, Color fg) const;

  /**
   * Render word-wrapped UTF-8 text at high quality to a new ARGB surface.
   *
   * This function will allocate a new 32-bit, ARGB surface, using alpha
   * blending to dither the font with the given color. This function returns the
   * new surface, or nullptr if there was an error.
   *
   * Text is wrapped to multiple lines on line endings and on word boundaries if
   * it extends beyond `wrap_width` in pixels.
   *
   * If wrap_width is 0, this function will only wrap on newline characters.
   *
   * You can render at other quality levels with Font.RenderText_Solid_Wrapped,
   * Font.RenderText_Shaded_Wrapped, and Font.RenderText_LCD_Wrapped.
   *
   * @param font the font to render with.
   * @param text text to render, in UTF-8 encoding.
   * @param fg the foreground color for the text.
   * @param wrap_width the maximum width of the text surface or 0 to wrap on
   *                   newline characters.
   * @returns a new 32-bit, ARGB surface, or nullptr if there was an error.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.RenderText_Blended
   * @sa Font.RenderText_LCD_Wrapped
   * @sa Font.RenderText_Shaded_Wrapped
   * @sa Font.RenderText_Solid_Wrapped
   */
  Surface RenderText_Blended_Wrapped(std::string_view text,
                                     Color fg,
                                     int wrap_width) const;

  /**
   * Render a single UNICODE codepoint at high quality to a new ARGB surface.
   *
   * This function will allocate a new 32-bit, ARGB surface, using alpha
   * blending to dither the font with the given color. This function returns the
   * new surface, or nullptr if there was an error.
   *
   * The glyph is rendered without any padding or centering in the X direction,
   * and aligned normally in the Y direction.
   *
   * You can render at other quality levels with Font.RenderGlyph_Solid,
   * Font.RenderGlyph_Shaded, and Font.RenderGlyph_LCD.
   *
   * @param ch the codepoint to render.
   * @param fg the foreground color for the text.
   * @returns a new 32-bit, ARGB surface, or nullptr if there was an error.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.RenderGlyph_LCD
   * @sa Font.RenderGlyph_Shaded
   * @sa Font.RenderGlyph_Solid
   */
  Surface RenderGlyph_Blended(Uint32 ch, ColorRaw fg) const;

  /**
   * Render UTF-8 text at LCD subpixel quality to a new ARGB surface.
   *
   * This function will allocate a new 32-bit, ARGB surface, and render
   * alpha-blended text using FreeType's LCD subpixel rendering. This function
   * returns the new surface, or nullptr if there was an error.
   *
   * This will not word-wrap the string; you'll get a surface with a single line
   * of text, as long as the string requires. You can use
   * Font.RenderText_LCD_Wrapped() instead if you need to wrap the output to
   * multiple lines.
   *
   * This will not wrap on newline characters.
   *
   * You can render at other quality levels with Font.RenderText_Solid,
   * Font.RenderText_Shaded, and Font.RenderText_Blended.
   *
   * @param font the font to render with.
   * @param text text to render, in UTF-8 encoding.
   * @param fg the foreground color for the text.
   * @param bg the background color for the text.
   * @returns a new 32-bit, ARGB surface, or nullptr if there was an error.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.RenderText_Blended
   * @sa Font.RenderText_LCD_Wrapped
   * @sa Font.RenderText_Shaded
   * @sa Font.RenderText_Solid
   */
  Surface RenderText_LCD(std::string_view text, Color fg, Color bg) const;

  /**
   * Render word-wrapped UTF-8 text at LCD subpixel quality to a new ARGB
   * surface.
   *
   * This function will allocate a new 32-bit, ARGB surface, and render
   * alpha-blended text using FreeType's LCD subpixel rendering. This function
   * returns the new surface, or nullptr if there was an error.
   *
   * Text is wrapped to multiple lines on line endings and on word boundaries if
   * it extends beyond `wrap_width` in pixels.
   *
   * If wrap_width is 0, this function will only wrap on newline characters.
   *
   * You can render at other quality levels with Font.RenderText_Solid_Wrapped,
   * Font.RenderText_Shaded_Wrapped, and Font.RenderText_Blended_Wrapped.
   *
   * @param font the font to render with.
   * @param text text to render, in UTF-8 encoding.
   * @param fg the foreground color for the text.
   * @param bg the background color for the text.
   * @param wrap_width the maximum width of the text surface or 0 to wrap on
   *                   newline characters.
   * @returns a new 32-bit, ARGB surface, or nullptr if there was an error.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.RenderText_Blended_Wrapped
   * @sa Font.RenderText_LCD
   * @sa Font.RenderText_Shaded_Wrapped
   * @sa Font.RenderText_Solid_Wrapped
   */
  Surface RenderText_LCD_Wrapped(std::string_view text,
                                 Color fg,
                                 Color bg,
                                 int wrap_width) const;

  /**
   * Render a single UNICODE codepoint at LCD subpixel quality to a new ARGB
   * surface.
   *
   * This function will allocate a new 32-bit, ARGB surface, and render
   * alpha-blended text using FreeType's LCD subpixel rendering. This function
   * returns the new surface, or nullptr if there was an error.
   *
   * The glyph is rendered without any padding or centering in the X direction,
   * and aligned normally in the Y direction.
   *
   * You can render at other quality levels with Font.RenderGlyph_Solid,
   * Font.RenderGlyph_Shaded, and Font.RenderGlyph_Blended.
   *
   * @param ch the codepoint to render.
   * @param fg the foreground color for the text.
   * @param bg the background color for the text.
   * @returns a new 32-bit, ARGB surface, or nullptr if there was an error.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Font.RenderGlyph_Blended
   * @sa Font.RenderGlyph_Shaded
   * @sa Font.RenderGlyph_Solid
   */
  Surface RenderGlyph_LCD(Uint32 ch, ColorRaw fg, ColorRaw bg) const;
};

/// Semi-safe reference for Font.
struct FontRef : Font
{
  /**
   * Constructs from FontParam.
   *
   * @param resource a FontRaw or Font.
   *
   * This does not takes ownership!
   */
  FontRef(FontParam resource)
    : Font(resource.value)
  {
  }

  /// Copy constructor.
  FontRef(const FontRef& other)
    : Font(other.get())
  {
  }

  /// Destructor
  ~FontRef() { release(); }
};

/**
 * Flags for SubString
 *
 * @since This datatype is available since SDL_ttf 3.0.0.
 *
 * @sa SubString
 */
using SubStringFlags = Uint32;

constexpr SubStringFlags SUBSTRING_DIRECTION_MASK =
  TTF_SUBSTRING_DIRECTION_MASK; ///< The mask for the flow direction for this
                                ///< substring

constexpr SubStringFlags SUBSTRING_TEXT_START =
  TTF_SUBSTRING_TEXT_START; ///< This substring contains the beginning of the
                            ///< text

/// This substring contains the beginning of line `line_index`
constexpr SubStringFlags SUBSTRING_LINE_START = TTF_SUBSTRING_LINE_START;

/// This substring contains the end of line `line_index`
constexpr SubStringFlags SUBSTRING_LINE_END = TTF_SUBSTRING_LINE_END;

constexpr SubStringFlags SUBSTRING_TEXT_END =
  TTF_SUBSTRING_TEXT_END; ///< This substring contains the end of the text

/**
 * The winding order of the vertices returned by Text.GetGPUDrawData
 *
 * @since This enum is available since SDL_ttf 3.0.0.
 */
using GPUTextEngineWinding = TTF_GPUTextEngineWinding;

constexpr GPUTextEngineWinding GPU_TEXTENGINE_WINDING_INVALID =
  TTF_GPU_TEXTENGINE_WINDING_INVALID; ///< INVALID

constexpr GPUTextEngineWinding GPU_TEXTENGINE_WINDING_CLOCKWISE =
  TTF_GPU_TEXTENGINE_WINDING_CLOCKWISE; ///< CLOCKWISE

constexpr GPUTextEngineWinding GPU_TEXTENGINE_WINDING_COUNTER_CLOCKWISE =
  TTF_GPU_TEXTENGINE_WINDING_COUNTER_CLOCKWISE; ///< COUNTER_CLOCKWISE

/**
 *
 *
 * @cat resource
 */
class TextEngine
{
  TextEngineRaw m_resource = nullptr;

public:
  /// Default ctor
  constexpr TextEngine() = default;

  /**
   * Constructs from TextEngineParam.
   *
   * @param resource a TextEngineRaw to be wrapped.
   *
   * This assumes the ownership, call release() if you need to take back.
   */
  constexpr explicit TextEngine(const TextEngineRaw resource)
    : m_resource(resource)
  {
  }

  /// Copy constructor
  constexpr TextEngine(const TextEngine& other) = delete;

  /// Move constructor
  constexpr TextEngine(TextEngine&& other)
    : TextEngine(other.release())
  {
  }

  /// Destructor
  virtual ~TextEngine() = default;

  /// Assignment operator.
  TextEngine& operator=(TextEngine&& other)
  {
    std::swap(m_resource, other.m_resource);
    return *this;
  }

  /// Assignment operator.
  TextEngine& operator=(const TextEngine& other) = delete;

  /// Retrieves underlying TextEngineRaw.
  constexpr TextEngineRaw get() const { return m_resource; }

  /// Retrieves underlying TextEngineRaw and clear this.
  constexpr TextEngineRaw release()
  {
    auto r = m_resource;
    m_resource = nullptr;
    return r;
  }

  /// Comparison
  constexpr auto operator<=>(const TextEngine& other) const = default;

  /// Comparison
  constexpr bool operator==(std::nullptr_t _) const { return !m_resource; }

  /// Converts to bool
  constexpr explicit operator bool() const { return !!m_resource; }

  /// Converts to TextEngineParam
  constexpr operator TextEngineParam() const { return {m_resource}; }

  virtual void Destroy() = 0;

  /**
   * Create a text object from UTF-8 text and a text engine.
   *
   *               nullptr.
   * @param font the font to render with.
   * @param text the text to use, in UTF-8 encoding.
   * @returns a Text object or nullptr on failure; call GetError() for more
   *          information.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font and text engine.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.Destroy
   */
  Text CreateText(FontParam font, std::string_view text);
};

struct SurfaceTextEngine : TextEngine
{
  /**
   * Create a text engine for drawing text on SDL surfaces.
   *
   * @post a TextEngine object or nullptr on failure; call GetError()
   *          for more information.
   *
   * @threadsafety It is safe to call this function from any thread.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa TextEngine.DestroySurface
   * @sa Text.DrawSurface
   */
  SurfaceTextEngine()
    : TextEngine(TTF_CreateSurfaceTextEngine())
  {
  }

  ~SurfaceTextEngine() { Destroy(); }

  /**
   * Destroy a text engine created for drawing text on SDL surfaces.
   *
   * All text created by this engine should be destroyed before calling this
   * function.
   *
   * @param engine a TextEngine object created with
   *               SurfaceTextEngine.SurfaceTextEngine().
   *
   * @threadsafety This function should be called on the thread that created the
   *               engine.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa SurfaceTextEngine.SurfaceTextEngine
   */
  void Destroy() final;
};

struct RendererTextEngine : TextEngine
{
  /**
   * Create a text engine for drawing text on an SDL renderer.
   *
   * @param renderer the renderer to use for creating textures and drawing text.
   * @post a TextEngine object or nullptr on failure; call GetError()
   *          for more information.
   *
   * @threadsafety This function should be called on the thread that created the
   *               renderer.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa TextEngine.DestroyRenderer
   * @sa Text.DrawRenderer
   * @sa RendererTextEngine.RendererTextEngine
   */
  RendererTextEngine(RendererParam renderer)
    : TextEngine(TTF_CreateRendererTextEngine(renderer))
  {
  }

  /**
   * Create a text engine for drawing text on an SDL renderer, with the
   * specified properties.
   *
   * These are the supported properties:
   *
   * - `prop::RendererTextEngine.RENDERER_POINTER`: the renderer to use for
   *   creating textures and drawing text
   * - `prop::RendererTextEngine.ATLAS_TEXTURE_SIZE_NUMBER`: the size of the
   *   texture atlas
   *
   * @param props the properties to use.
   * @post a TextEngine object or nullptr on failure; call GetError()
   *          for more information.
   *
   * @threadsafety This function should be called on the thread that created the
   *               renderer.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa RendererTextEngine.RendererTextEngine
   * @sa TextEngine.DestroyRenderer
   * @sa Text.DrawRenderer
   */
  RendererTextEngine(PropertiesParam props)
    : TextEngine(TTF_CreateRendererTextEngineWithProperties(props))
  {
  }

  ~RendererTextEngine() { Destroy(); }

  /**
   * Destroy a text engine created for drawing text on an SDL renderer.
   *
   * All text created by this engine should be destroyed before calling this
   * function.
   *
   * @param engine a TextEngine object created with
   *               RendererTextEngine.RendererTextEngine().
   *
   * @threadsafety This function should be called on the thread that created the
   *               engine.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa RendererTextEngine.RendererTextEngine
   */
  void Destroy();
};

struct GPUTextEngine : TextEngine
{
  /**
   * Create a text engine for drawing text with the SDL GPU API.
   *
   * @param device the SDL_GPUDevice to use for creating textures and drawing
   *               text.
   * @post a TextEngine object or nullptr on failure; call GetError()
   *          for more information.
   *
   * @threadsafety This function should be called on the thread that created the
   *               device.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa GPUTextEngine.GPUTextEngine
   * @sa GPUTextEngine.Destroy
   * @sa GPUTextEngine.GetGPUDrawData
   */
  GPUTextEngine(SDL_GPUDevice* device)
    : TextEngine(TTF_CreateGPUTextEngine(device))
  {
  }

  /**
   * Create a text engine for drawing text with the SDL GPU API, with the
   * specified properties.
   *
   * These are the supported properties:
   *
   * - `prop::GpuTextEngine.DEVICE_POINTER`: the SDL_GPUDevice to use for
   * creating textures and drawing text.
   * - `prop::GpuTextEngine.ATLAS_TEXTURE_SIZE_NUMBER`: the size of the texture
   *   atlas
   *
   * @param props the properties to use.
   * @post a TextEngine object or nullptr on failure; call GetError()
   *          for more information.
   *
   * @threadsafety This function should be called on the thread that created the
   *               device.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa GPUTextEngine.GPUTextEngine
   * @sa TextEngine.DestroyGPU
   * @sa Text.GetGPUDrawData
   */
  GPUTextEngine(PropertiesParam props)
    : TextEngine(TTF_CreateGPUTextEngineWithProperties(props))
  {
  }

  ~GPUTextEngine() { Destroy(); }

  /**
   * Sets the winding order of the vertices returned by Text.GetGPUDrawData
   * for a particular GPU text engine.
   *
   * @param winding the new winding order option.
   *
   * @threadsafety This function should be called on the thread that created the
   *               engine.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa GPUTextEngine.GetGPUWinding
   */
  void SetGPUWinding(GPUTextEngineWinding winding);

  /**
   * Get the winding order of the vertices returned by Text.GetGPUDrawData
   * for a particular GPU text engine
   *
   * @param engine a TextEngine object created with
   *               GPUTextEngine.GPUTextEngine().
   * @returns the winding order used by the GPU text engine or
   *          GPU_TEXTENGINE_WINDING_INVALID in case of error.
   *
   * @threadsafety This function should be called on the thread that created the
   *               engine.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa GPUTextEngine.SetGPUWinding
   */
  GPUTextEngineWinding GetGPUWinding() const;

  /**
   * Destroy a text engine created for drawing text with the SDL GPU API.
   *
   * All text created by this engine should be destroyed before calling this
   * function.
   *
   * @param engine a TextEngine object created with
   *               GPUTextEngine.GPUTextEngine().
   *
   * @threadsafety This function should be called on the thread that created the
   *               engine.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa GPUTextEngine.GPUTextEngine
   */
  void Destroy();
};

/**
 * Draw sequence returned by Text.GetGPUDrawData
 *
 * @since This struct is available since SDL_ttf 3.0.0.
 *
 * @sa Text.GetGPUDrawData
 */
using GPUAtlasDrawSequence = TTF_GPUAtlasDrawSequence;

/**
 * The representation of a substring within text.
 *
 * @since This struct is available since SDL_ttf 3.0.0.
 *
 * @sa Text.GetNextSubString
 * @sa Text.GetPreviousSubString
 * @sa Text.GetSubString
 * @sa Text.GetSubStringForLine
 * @sa Text.GetSubStringForPoint
 * @sa Text.GetSubStringsForRange
 */
using SubString = TTF_SubString;

// Forward decl
struct SubStringIterator;

/**
 * Create a font from a file, using a specified point size.
 *
 * Some .fon fonts will have several sizes embedded in the file, so the point
 * size becomes the index of choosing which size. If the value is too high,
 * the last indexed size will be the default.
 *
 * When done with the returned Font, use Font.Close() to dispose of it.
 *
 * @param file path to font file.
 * @param ptsize point size to use for the newly-opened font.
 * @returns a valid Font on success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.Close
 */
inline Font OpenFont(StringParam file, float ptsize)
{
  return Font(std::move(file), ptsize);
}

/**
 * Create a font from an IOStream, using a specified point size.
 *
 * Some .fon fonts will have several sizes embedded in the file, so the point
 * size becomes the index of choosing which size. If the value is too high,
 * the last indexed size will be the default.
 *
 * If `closeio` is true, `src` will be automatically closed once the font is
 * closed. Otherwise you should keep `src` open until the font is closed.
 *
 * When done with the returned Font, use Font.Close() to dispose of it.
 *
 * @param src an IOStream to provide a font file's data.
 * @param ptsize point size to use for the newly-opened font.
 * @param closeio true to close `src` when the font is closed, false to leave
 *                it open.
 * @returns a valid Font on success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.Close
 */
inline Font OpenFont(IOStreamParam src, float ptsize, bool closeio = false)
{
  return Font(src, ptsize, closeio);
}

/**
 * Create a font with the specified properties.
 *
 * These are the supported properties:
 *
 * - `prop::Font.CREATE_FILENAME_STRING`: the font file to open, if an
 *   IOStream isn't being used. This is required if
 *   `prop::Font.CREATE_IOSTREAM_POINTER` and
 *   `prop::Font.CREATE_EXISTING_FONT_POINTER` aren't set.
 * - `prop::Font.CREATE_IOSTREAM_POINTER`: an IOStream containing the
 *   font to be opened. This should not be closed until the font is closed.
 *   This is required if `prop::Font.CREATE_FILENAME_STRING` and
 *   `prop::Font.CREATE_EXISTING_FONT_POINTER` aren't set.
 * - `prop::Font.CREATE_IOSTREAM_OFFSET_NUMBER`: the offset in the iostream
 *   for the beginning of the font, defaults to 0.
 * - `prop::Font.CREATE_IOSTREAM_AUTOCLOSE_BOOLEAN`: true if closing the
 *   font should also close the associated IOStream.
 * - `prop::Font.CREATE_SIZE_FLOAT`: the point size of the font. Some .fon
 *   fonts will have several sizes embedded in the file, so the point size
 *   becomes the index of choosing which size. If the value is too high, the
 *   last indexed size will be the default.
 * - `prop::Font.CREATE_FACE_NUMBER`: the face index of the font, if the
 *   font contains multiple font faces.
 * - `prop::Font.CREATE_HORIZONTAL_DPI_NUMBER`: the horizontal DPI to use
 *   for font rendering, defaults to
 *   `prop::Font.CREATE_VERTICAL_DPI_NUMBER` if set, or 72 otherwise.
 * - `prop::Font.CREATE_VERTICAL_DPI_NUMBER`: the vertical DPI to use for
 *   font rendering, defaults to `prop::Font.CREATE_HORIZONTAL_DPI_NUMBER`
 *   if set, or 72 otherwise.
 * - `prop::Font.CREATE_EXISTING_FONT_POINTER`: an optional Font that, if set,
 *   will be used as the font data source and the initial size and style of
 *   the new font.
 *
 * @param props the properties to use.
 * @returns a valid Font on success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.Close
 */
inline Font OpenFontWithProperties(PropertiesParam props)
{
  return Font(props);
}

namespace prop::Font {

constexpr auto CREATE_FILENAME_STRING = TTF_PROP_FONT_CREATE_FILENAME_STRING;

constexpr auto CREATE_IOSTREAM_POINTER = TTF_PROP_FONT_CREATE_IOSTREAM_POINTER;

constexpr auto CREATE_IOSTREAM_OFFSET_NUMBER =
  TTF_PROP_FONT_CREATE_IOSTREAM_OFFSET_NUMBER;

constexpr auto CREATE_IOSTREAM_AUTOCLOSE_BOOLEAN =
  TTF_PROP_FONT_CREATE_IOSTREAM_AUTOCLOSE_BOOLEAN;

constexpr auto CREATE_SIZE_FLOAT = TTF_PROP_FONT_CREATE_SIZE_FLOAT;

constexpr auto CREATE_FACE_NUMBER = TTF_PROP_FONT_CREATE_FACE_NUMBER;

constexpr auto CREATE_HORIZONTAL_DPI_NUMBER =
  TTF_PROP_FONT_CREATE_HORIZONTAL_DPI_NUMBER;

constexpr auto CREATE_VERTICAL_DPI_NUMBER =
  TTF_PROP_FONT_CREATE_VERTICAL_DPI_NUMBER;

constexpr auto CREATE_EXISTING_FONT_POINTER =
  TTF_PROP_FONT_CREATE_EXISTING_FONT_POINTER;

constexpr auto OUTLINE_LINE_CAP_NUMBER = TTF_PROP_FONT_OUTLINE_LINE_CAP_NUMBER;

constexpr auto OUTLINE_LINE_JOIN_NUMBER =
  TTF_PROP_FONT_OUTLINE_LINE_JOIN_NUMBER;

constexpr auto OUTLINE_MITER_LIMIT_NUMBER =
  TTF_PROP_FONT_OUTLINE_MITER_LIMIT_NUMBER;

} // namespace prop::Font

/**
 * Create a copy of an existing font.
 *
 * The copy will be distinct from the original, but will share the font file
 * and have the same size and style as the original.
 *
 * When done with the returned Font, use Font.Close() to dispose of it.
 *
 * @param existing_font the font to copy.
 * @returns a valid Font on success.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               original font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.Close
 */
inline Font CopyFont(FontParam existing_font)
{
  return Font(CheckError(TTF_CopyFont(existing_font)));
}

inline Font Font::Copy() const { return SDL::CopyFont(m_resource); }

/**
 * Get the properties associated with a font.
 *
 * The following read-write properties are provided by SDL:
 *
 * - `prop::Font.OUTLINE_LINE_CAP_NUMBER`: The FT_Stroker_LineCap value
 *   used when setting the font outline, defaults to
 *   `FT_STROKER_LINECAP_ROUND`.
 * - `prop::Font.OUTLINE_LINE_JOIN_NUMBER`: The FT_Stroker_LineJoin value
 *   used when setting the font outline, defaults to
 *   `FT_STROKER_LINEJOIN_ROUND`.
 * - `prop::Font.OUTLINE_MITER_LIMIT_NUMBER`: The FT_Fixed miter limit used
 *   when setting the font outline, defaults to 0.
 *
 * @param font the font to query.
 * @returns a valid property ID on success.
 * @throws Error on failure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline PropertiesRef GetFontProperties(FontParam font)
{
  return {CheckError(TTF_GetFontProperties(font))};
}

inline PropertiesRef Font::GetProperties()
{
  return SDL::GetFontProperties(m_resource);
}

/**
 * Get the font generation.
 *
 * The generation is incremented each time font properties change that require
 * rebuilding glyphs, such as style, size, etc.
 *
 * @param font the font to query.
 * @returns the font generation or 0 on failure; call GetError() for more
 *          information.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline Uint32 GetFontGeneration(FontParam font)
{
  return TTF_GetFontGeneration(font);
}

inline Uint32 Font::GetGeneration() const
{
  return SDL::GetFontGeneration(m_resource);
}

/**
 * Add a fallback font.
 *
 * Add a font that will be used for glyphs that are not in the current font.
 * The fallback font should have the same size and style as the current font.
 *
 * If there are multiple fallback fonts, they are used in the order added.
 *
 * This updates any Text objects using this font.
 *
 * @param font the font to modify.
 * @param fallback the font to add as a fallback.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created
 *               both fonts.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.ClearFallbacks
 * @sa Font.RemoveFallback
 */
inline void AddFallbackFont(FontParam font, FontParam fallback)
{
  CheckError(TTF_AddFallbackFont(font, fallback));
}

inline void Font::AddFallback(FontParam fallback)
{
  SDL::AddFallbackFont(m_resource, fallback);
}

/**
 * Remove a fallback font.
 *
 * This updates any Text objects using this font.
 *
 * @param font the font to modify.
 * @param fallback the font to remove as a fallback.
 *
 * @threadsafety This function should be called on the thread that created
 *               both fonts.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.AddFallback
 * @sa Font.ClearFallbacks
 */
inline void RemoveFallbackFont(FontParam font, FontParam fallback)
{
  TTF_RemoveFallbackFont(font, fallback);
}

inline void Font::RemoveFallback(FontParam fallback)
{
  SDL::RemoveFallbackFont(m_resource, fallback);
}

/**
 * Remove all fallback fonts.
 *
 * This updates any Text objects using this font.
 *
 * @param font the font to modify.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.AddFallback
 * @sa Font.RemoveFallback
 */
inline void ClearFallbackFonts(FontParam font) { TTF_ClearFallbackFonts(font); }

inline void Font::ClearFallbacks() { SDL::ClearFallbackFonts(m_resource); }

/**
 * Set a font's size dynamically.
 *
 * This updates any Text objects using this font, and clears
 * already-generated glyphs, if any, from the cache.
 *
 * @param font the font to resize.
 * @param ptsize the new point size.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.GetSize
 */
inline void SetFontSize(FontParam font, float ptsize)
{
  CheckError(TTF_SetFontSize(font, ptsize));
}

inline void Font::SetSize(float ptsize)
{
  SDL::SetFontSize(m_resource, ptsize);
}

/**
 * Set font size dynamically with target resolutions, in dots per inch.
 *
 * This updates any Text objects using this font, and clears
 * already-generated glyphs, if any, from the cache.
 *
 * @param font the font to resize.
 * @param ptsize the new point size.
 * @param hdpi the target horizontal DPI.
 * @param vdpi the target vertical DPI.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.GetSize
 * @sa TTF_GetFontSizeDPI
 */
inline void SetFontSizeDPI(FontParam font, float ptsize, int hdpi, int vdpi)
{
  CheckError(TTF_SetFontSizeDPI(font, ptsize, hdpi, vdpi));
}

inline void Font::SetSizeDPI(float ptsize, int hdpi, int vdpi)
{
  SDL::SetFontSizeDPI(m_resource, ptsize, hdpi, vdpi);
}

/**
 * Get the size of a font.
 *
 * @param font the font to query.
 * @returns the size of the font, or 0.0f on failure; call GetError() for
 *          more information.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.SetSize
 * @sa Font.SetSizeDPI
 */
inline float GetFontSize(FontParam font) { return TTF_GetFontSize(font); }

inline float Font::GetSize() const { return SDL::GetFontSize(m_resource); }

/**
 * Get font target resolutions, in dots per inch.
 *
 * @param font the font to query.
 * @param hdpi a pointer filled in with the target horizontal DPI.
 * @param vdpi a pointer filled in with the target vertical DPI.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.SetSizeDPI
 */
inline void GetFontDPI(FontParam font, int* hdpi, int* vdpi)
{
  CheckError(TTF_GetFontDPI(font, hdpi, vdpi));
}

inline void Font::GetDPI(int* hdpi, int* vdpi) const
{
  SDL::GetFontDPI(m_resource, hdpi, vdpi);
}

/**
 * Set a font's current style.
 *
 * This updates any Text objects using this font, and clears
 * already-generated glyphs, if any, from the cache.
 *
 * The font styles are a set of bit flags, OR'd together:
 *
 * - `STYLE_NORMAL` (is zero)
 * - `STYLE_BOLD`
 * - `STYLE_ITALIC`
 * - `STYLE_UNDERLINE`
 * - `STYLE_STRIKETHROUGH`
 *
 * @param font the font to set a new style on.
 * @param style the new style values to set, OR'd together.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.GetStyle
 */
inline void SetFontStyle(FontParam font, FontStyleFlags style)
{
  TTF_SetFontStyle(font, style);
}

inline void Font::SetStyle(FontStyleFlags style)
{
  SDL::SetFontStyle(m_resource, style);
}

/**
 * Query a font's current style.
 *
 * The font styles are a set of bit flags, OR'd together:
 *
 * - `STYLE_NORMAL` (is zero)
 * - `STYLE_BOLD`
 * - `STYLE_ITALIC`
 * - `STYLE_UNDERLINE`
 * - `STYLE_STRIKETHROUGH`
 *
 * @param font the font to query.
 * @returns the current font style, as a set of bit flags.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.SetStyle
 */
inline FontStyleFlags GetFontStyle(FontParam font)
{
  return TTF_GetFontStyle(font);
}

inline FontStyleFlags Font::GetStyle() const
{
  return SDL::GetFontStyle(m_resource);
}

/**
 * Set a font's current outline.
 *
 * This uses the font properties `prop::Font.OUTLINE_LINE_CAP_NUMBER`,
 * `prop::Font.OUTLINE_LINE_JOIN_NUMBER`, and
 * `prop::Font.OUTLINE_MITER_LIMIT_NUMBER` when setting the font outline.
 *
 * This updates any Text objects using this font, and clears
 * already-generated glyphs, if any, from the cache.
 *
 * @param font the font to set a new outline on.
 * @param outline positive outline value, 0 to default.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.GetOutline
 */
inline void SetFontOutline(FontParam font, int outline)
{
  CheckError(TTF_SetFontOutline(font, outline));
}

inline void Font::SetOutline(int outline)
{
  SDL::SetFontOutline(m_resource, outline);
}

/**
 * Query a font's current outline.
 *
 * @param font the font to query.
 * @returns the font's current outline value.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.SetOutline
 */
inline int GetFontOutline(FontParam font) { return TTF_GetFontOutline(font); }

inline int Font::GetOutline() const { return SDL::GetFontOutline(m_resource); }

/**
 * Set a font's current hinter setting.
 *
 * This updates any Text objects using this font, and clears
 * already-generated glyphs, if any, from the cache.
 *
 * The hinter setting is a single value:
 *
 * - `HINTING_NORMAL`
 * - `HINTING_LIGHT`
 * - `HINTING_MONO`
 * - `HINTING_NONE`
 * - `HINTING_LIGHT_SUBPIXEL` (available in SDL_ttf 3.0.0 and later)
 *
 * @param font the font to set a new hinter setting on.
 * @param hinting the new hinter setting.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.GetHinting
 */
inline void SetFontHinting(FontParam font, HintingFlags hinting)
{
  TTF_SetFontHinting(font, hinting);
}

inline void Font::SetHinting(HintingFlags hinting)
{
  SDL::SetFontHinting(m_resource, hinting);
}

/**
 * Query the number of faces of a font.
 *
 * @param font the font to query.
 * @returns the number of FreeType font faces.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline int GetNumFontFaces(FontParam font) { return TTF_GetNumFontFaces(font); }

inline int Font::GetNumFaces() const
{
  return SDL::GetNumFontFaces(m_resource);
}

/**
 * Query a font's current FreeType hinter setting.
 *
 * The hinter setting is a single value:
 *
 * - `HINTING_NORMAL`
 * - `HINTING_LIGHT`
 * - `HINTING_MONO`
 * - `HINTING_NONE`
 * - `HINTING_LIGHT_SUBPIXEL` (available in SDL_ttf 3.0.0 and later)
 *
 * @param font the font to query.
 * @returns the font's current hinter value, or HINTING_INVALID if the
 *          font is invalid.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.SetHinting
 */
inline HintingFlags GetFontHinting(FontParam font)
{
  return TTF_GetFontHinting(font);
}

inline HintingFlags Font::GetHinting() const
{
  return SDL::GetFontHinting(m_resource);
}

/**
 * Enable Signed Distance Field rendering for a font.
 *
 * SDF is a technique that helps fonts look sharp even when scaling and
 * rotating, and requires special shader support for display.
 *
 * This works with Blended APIs, and generates the raw signed distance values
 * in the alpha channel of the resulting texture.
 *
 * This updates any Text objects using this font, and clears
 * already-generated glyphs, if any, from the cache.
 *
 * @param font the font to set SDF support on.
 * @param enabled true to enable SDF, false to disable.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.GetSDF
 */
inline void SetFontSDF(FontParam font, bool enabled)
{
  CheckError(TTF_SetFontSDF(font, enabled));
}

inline void Font::SetSDF(bool enabled) { SDL::SetFontSDF(m_resource, enabled); }

/**
 * Query whether Signed Distance Field rendering is enabled for a font.
 *
 * @param font the font to query.
 * @returns true if enabled, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.SetSDF
 */
inline bool GetFontSDF(FontParam font) { return TTF_GetFontSDF(font); }

inline bool Font::GetSDF() const { return SDL::GetFontSDF(m_resource); }

#if SDL_TTF_VERSION_ATLEAST(3, 2, 2)

/**
 * Query a font's weight, in terms of the lightness/heaviness of the strokes.
 *
 * @param font the font to query.
 * @returns the font's current weight.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.2.2.
 */
inline int GetFontWeight(FontParam font) { return TTF_GetFontWeight(font); }

#endif // SDL_TTF_VERSION_ATLEAST(3, 2, 2)

inline int Font::GetWeight() const { return SDL::GetFontWeight(m_resource); }

/// Thin (100) named font weight value
#define SDL_FONT_WEIGHT_THIN TTF_FONT_WEIGHT_THIN

/// ExtraLight (200) named font weight value
#define SDL_FONT_WEIGHT_EXTRA_LIGHT TTF_FONT_WEIGHT_EXTRA_LIGHT

/// Light (300) named font weight value
#define SDL_FONT_WEIGHT_LIGHT TTF_FONT_WEIGHT_LIGHT

/// Normal (400) named font weight value
#define SDL_FONT_WEIGHT_NORMAL TTF_FONT_WEIGHT_NORMAL

/// Medium (500) named font weight value
#define SDL_FONT_WEIGHT_MEDIUM TTF_FONT_WEIGHT_MEDIUM

/// SemiBold (600) named font weight value
#define SDL_FONT_WEIGHT_SEMI_BOLD TTF_FONT_WEIGHT_SEMI_BOLD

/// Bold (700) named font weight value
#define SDL_FONT_WEIGHT_BOLD TTF_FONT_WEIGHT_BOLD

/// ExtraBold (800) named font weight value
#define SDL_FONT_WEIGHT_EXTRA_BOLD TTF_FONT_WEIGHT_EXTRA_BOLD

/// Black (900) named font weight value
#define SDL_FONT_WEIGHT_BLACK TTF_FONT_WEIGHT_BLACK

/// ExtraBlack (950) named font weight value
#define SDL_FONT_WEIGHT_EXTRA_BLACK TTF_FONT_WEIGHT_EXTRA_BLACK

/**
 * Set a font's current wrap alignment option.
 *
 * This updates any Text objects using this font.
 *
 * @param font the font to set a new wrap alignment option on.
 * @param align the new wrap alignment option.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.GetWrapAlignment
 */
inline void SetFontWrapAlignment(FontParam font, HorizontalAlignment align)
{
  TTF_SetFontWrapAlignment(font, align);
}

inline void Font::SetWrapAlignment(HorizontalAlignment align)
{
  SDL::SetFontWrapAlignment(m_resource, align);
}

/**
 * Query a font's current wrap alignment option.
 *
 * @param font the font to query.
 * @returns the font's current wrap alignment option.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.SetWrapAlignment
 */
inline HorizontalAlignment GetFontWrapAlignment(FontParam font)
{
  return TTF_GetFontWrapAlignment(font);
}

inline HorizontalAlignment Font::GetWrapAlignment() const
{
  return SDL::GetFontWrapAlignment(m_resource);
}

/**
 * Query the total height of a font.
 *
 * This is usually equal to point size.
 *
 * @param font the font to query.
 * @returns the font's height.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline int GetFontHeight(FontParam font) { return TTF_GetFontHeight(font); }

inline int Font::GetHeight() const { return SDL::GetFontHeight(m_resource); }

/**
 * Query the offset from the baseline to the top of a font.
 *
 * This is a positive value, relative to the baseline.
 *
 * @param font the font to query.
 * @returns the font's ascent.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline int GetFontAscent(FontParam font) { return TTF_GetFontAscent(font); }

inline int Font::GetAscent() const { return SDL::GetFontAscent(m_resource); }

/**
 * Query the offset from the baseline to the bottom of a font.
 *
 * This is a negative value, relative to the baseline.
 *
 * @param font the font to query.
 * @returns the font's descent.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline int GetFontDescent(FontParam font) { return TTF_GetFontDescent(font); }

inline int Font::GetDescent() const { return SDL::GetFontDescent(m_resource); }

/**
 * Set the spacing between lines of text for a font.
 *
 * This updates any Text objects using this font.
 *
 * @param font the font to modify.
 * @param lineskip the new line spacing for the font.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.GetLineSkip
 */
inline void SetFontLineSkip(FontParam font, int lineskip)
{
  TTF_SetFontLineSkip(font, lineskip);
}

inline void Font::SetLineSkip(int lineskip)
{
  SDL::SetFontLineSkip(m_resource, lineskip);
}

/**
 * Query the spacing between lines of text for a font.
 *
 * @param font the font to query.
 * @returns the font's recommended spacing.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.SetLineSkip
 */
inline int GetFontLineSkip(FontParam font) { return TTF_GetFontLineSkip(font); }

inline int Font::GetLineSkip() const
{
  return SDL::GetFontLineSkip(m_resource);
}

/**
 * Set if kerning is enabled for a font.
 *
 * Newly-opened fonts default to allowing kerning. This is generally a good
 * policy unless you have a strong reason to disable it, as it tends to
 * produce better rendering (with kerning disabled, some fonts might render
 * the word `kerning` as something that looks like `keming` for example).
 *
 * This updates any Text objects using this font.
 *
 * @param font the font to set kerning on.
 * @param enabled true to enable kerning, false to disable.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.GetKerning
 */
inline void SetFontKerning(FontParam font, bool enabled)
{
  TTF_SetFontKerning(font, enabled);
}

inline void Font::SetKerning(bool enabled)
{
  SDL::SetFontKerning(m_resource, enabled);
}

/**
 * Query whether or not kerning is enabled for a font.
 *
 * @param font the font to query.
 * @returns true if kerning is enabled, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.SetKerning
 */
inline bool GetFontKerning(FontParam font) { return TTF_GetFontKerning(font); }

inline bool Font::GetKerning() const { return SDL::GetFontKerning(m_resource); }

/**
 * Query whether a font is fixed-width.
 *
 * A "fixed-width" font means all glyphs are the same width across; a
 * lowercase 'i' will be the same size across as a capital 'W', for example.
 * This is common for terminals and text editors, and other apps that treat
 * text as a grid. Most other things (WYSIWYG word processors, web pages, etc)
 * are more likely to not be fixed-width in most cases.
 *
 * @param font the font to query.
 * @returns true if the font is fixed-width, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline bool FontIsFixedWidth(FontParam font)
{
  return TTF_FontIsFixedWidth(font);
}

inline bool Font::IsFixedWidth() const
{
  return SDL::FontIsFixedWidth(m_resource);
}

/**
 * Query whether a font is scalable or not.
 *
 * Scalability lets us distinguish between outline and bitmap fonts.
 *
 * @param font the font to query.
 * @returns true if the font is scalable, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.SetSDF
 */
inline bool FontIsScalable(FontParam font) { return TTF_FontIsScalable(font); }

inline bool Font::IsScalable() const { return SDL::FontIsScalable(m_resource); }

/**
 * Query a font's family name.
 *
 * This string is dictated by the contents of the font file.
 *
 * Note that the returned string is to internal storage, and should not be
 * modified or free'd by the caller. The string becomes invalid, with the rest
 * of the font, when `font` is handed to Font.Close().
 *
 * @param font the font to query.
 * @returns the font's family name.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline const char* GetFontFamilyName(FontParam font)
{
  return TTF_GetFontFamilyName(font);
}

inline const char* Font::GetFamilyName() const
{
  return SDL::GetFontFamilyName(m_resource);
}

/**
 * Query a font's style name.
 *
 * This string is dictated by the contents of the font file.
 *
 * Note that the returned string is to internal storage, and should not be
 * modified or free'd by the caller. The string becomes invalid, with the rest
 * of the font, when `font` is handed to Font.Close().
 *
 * @param font the font to query.
 * @returns the font's style name.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline const char* GetFontStyleName(FontParam font)
{
  return TTF_GetFontStyleName(font);
}

inline const char* Font::GetStyleName() const
{
  return SDL::GetFontStyleName(m_resource);
}

/**
 * Set the direction to be used for text shaping by a font.
 *
 * This function only supports left-to-right text shaping if SDL_ttf was not
 * built with HarfBuzz support.
 *
 * This updates any Text objects using this font.
 *
 * @param font the font to modify.
 * @param direction the new direction for text to flow.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline void SetFontDirection(FontParam font, Direction direction)
{
  CheckError(TTF_SetFontDirection(font, direction));
}

inline void Font::SetDirection(Direction direction)
{
  SDL::SetFontDirection(m_resource, direction);
}

/**
 * Get the direction to be used for text shaping by a font.
 *
 * This defaults to DIRECTION_INVALID if it hasn't been set.
 *
 * @param font the font to query.
 * @returns the direction to be used for text shaping.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline Direction GetFontDirection(FontParam font)
{
  return TTF_GetFontDirection(font);
}

inline Direction Font::GetDirection() const
{
  return SDL::GetFontDirection(m_resource);
}

/**
 * Convert from a 4 character string to a 32-bit tag.
 *
 * @param string the 4 character string to convert.
 * @returns the 32-bit representation of the string.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa TagToString
 */
inline Uint32 StringToTag(StringParam string)
{
  return TTF_StringToTag(string);
}

/**
 * Convert from a 32-bit tag to a 4 character string.
 *
 * @param tag the 32-bit tag to convert.
 * @param string a pointer filled in with the 4 character representation of
 *               the tag.
 * @param size the size of the buffer pointed at by string, should be at least
 *             4.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa TagToString
 */
inline void TagToString(Uint32 tag, char* string, size_t size)
{
  TTF_TagToString(tag, string, size);
}

/**
 * Set the script to be used for text shaping by a font.
 *
 * This returns false if SDL_ttf isn't built with HarfBuzz support.
 *
 * This updates any Text objects using this font.
 *
 * @param font the font to modify.
 * @param script an
 *               [ISO 15924
 * code](https://unicode.org/iso15924/iso15924-codes.html)
 *               .
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa StringToTag
 */
inline void SetFontScript(FontParam font, Uint32 script)
{
  CheckError(TTF_SetFontScript(font, script));
}

inline void Font::SetScript(Uint32 script)
{
  SDL::SetFontScript(m_resource, script);
}

/**
 * Get the script used for text shaping a font.
 *
 * @param font the font to query.
 * @returns an
 *          [ISO 15924 code](https://unicode.org/iso15924/iso15924-codes.html)
 *          or 0 if a script hasn't been set.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa TagToString
 */
inline Uint32 GetFontScript(FontParam font) { return TTF_GetFontScript(font); }

inline Uint32 Font::GetScript() const { return SDL::GetFontScript(m_resource); }

/**
 * Get the script used by a 32-bit codepoint.
 *
 * @param ch the character code to check.
 * @returns an
 *          [ISO 15924 code](https://unicode.org/iso15924/iso15924-codes.html)
 *          on success, or 0 on failure; call GetError() for more
 *          information.
 *
 * @threadsafety This function is thread-safe.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa TagToString
 */
inline Uint32 GetGlyphScript(Uint32 ch) { return TTF_GetGlyphScript(ch); }

inline Uint32 Font::GetGlyphScript(Uint32 ch)
{
  return SDL::GetGlyphScript(ch);
}

/**
 * Set language to be used for text shaping by a font.
 *
 * If SDL_ttf was not built with HarfBuzz support, this function returns
 * false.
 *
 * This updates any Text objects using this font.
 *
 * @param font the font to specify a language for.
 * @param language_bcp47 a null-terminated string containing the desired
 *                       language's BCP47 code. Or null to reset the value.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline void SetFontLanguage(FontParam font, StringParam language_bcp47)
{
  CheckError(TTF_SetFontLanguage(font, language_bcp47));
}

inline void Font::SetLanguage(StringParam language_bcp47)
{
  SDL::SetFontLanguage(m_resource, std::move(language_bcp47));
}

/**
 * Check whether a glyph is provided by the font for a UNICODE codepoint.
 *
 * @param font the font to query.
 * @param ch the codepoint to check.
 * @returns true if font provides a glyph for this character, false if not.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline bool FontHasGlyph(FontParam font, Uint32 ch)
{
  return TTF_FontHasGlyph(font, ch);
}

inline bool Font::HasGlyph(Uint32 ch) const
{
  return SDL::FontHasGlyph(m_resource, ch);
}

/**
 * Get the pixel image for a UNICODE codepoint.
 *
 * @param font the font to query.
 * @param ch the codepoint to check.
 * @param image_type a pointer filled in with the glyph image type, may be
 *                   nullptr.
 * @returns an Surface containing the glyph, or nullptr on failure; call
 *          GetError() for more information.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline Surface GetGlyphImage(FontParam font, Uint32 ch, ImageType* image_type)
{
  return Surface{TTF_GetGlyphImage(font, ch, image_type)};
}

inline Surface Font::GetGlyphImage(Uint32 ch, ImageType* image_type) const
{
  return SDL::GetGlyphImage(m_resource, ch, image_type);
}

/**
 * Get the pixel image for a character index.
 *
 * This is useful for text engine implementations, which can call this with
 * the `glyph_index` in a TTF_CopyOperation
 *
 * @param font the font to query.
 * @param glyph_index the index of the glyph to return.
 * @param image_type a pointer filled in with the glyph image type, may be
 *                   nullptr.
 * @returns an Surface containing the glyph, or nullptr on failure; call
 *          GetError() for more information.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline Surface GetGlyphImageForIndex(FontParam font,
                                     Uint32 glyph_index,
                                     ImageType* image_type)
{
  return Surface(TTF_GetGlyphImageForIndex(font, glyph_index, image_type));
}

inline Surface Font::GetGlyphImageForIndex(Uint32 glyph_index,
                                           ImageType* image_type) const
{
  return SDL::GetGlyphImageForIndex(m_resource, glyph_index, image_type);
}

/**
 * Query the metrics (dimensions) of a font's glyph for a UNICODE codepoint.
 *
 * To understand what these metrics mean, here is a useful link:
 *
 * https://freetype.sourceforge.net/freetype2/docs/tutorial/step2.html
 *
 * @param font the font to query.
 * @param ch the codepoint to check.
 * @param minx a pointer filled in with the minimum x coordinate of the glyph
 *             from the left edge of its bounding box. This value may be
 *             negative.
 * @param maxx a pointer filled in with the maximum x coordinate of the glyph
 *             from the left edge of its bounding box.
 * @param miny a pointer filled in with the minimum y coordinate of the glyph
 *             from the bottom edge of its bounding box. This value may be
 *             negative.
 * @param maxy a pointer filled in with the maximum y coordinate of the glyph
 *             from the bottom edge of its bounding box.
 * @param advance a pointer filled in with the distance to the next glyph from
 *                the left edge of this glyph's bounding box.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline void GetGlyphMetrics(FontParam font,
                            Uint32 ch,
                            int* minx,
                            int* maxx,
                            int* miny,
                            int* maxy,
                            int* advance)
{
  CheckError(TTF_GetGlyphMetrics(font, ch, minx, maxx, miny, maxy, advance));
}

inline void Font::GetGlyphMetrics(Uint32 ch,
                                  int* minx,
                                  int* maxx,
                                  int* miny,
                                  int* maxy,
                                  int* advance) const
{
  SDL::GetGlyphMetrics(m_resource, ch, minx, maxx, miny, maxy, advance);
}

/**
 * Query the kerning size between the glyphs of two UNICODE codepoints.
 *
 * @param font the font to query.
 * @param previous_ch the previous codepoint.
 * @param ch the current codepoint.
 * @param kerning a pointer filled in with the kerning size between the two
 *                glyphs, in pixels, may be nullptr.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline int GetGlyphKerning(FontParam font, Uint32 previous_ch, Uint32 ch)
{
  if (int r; TTF_GetGlyphKerning(font, previous_ch, ch, &r)) return r;
  throw Error();
}

inline int Font::GetGlyphKerning(Uint32 previous_ch, Uint32 ch) const
{
  return SDL::GetGlyphKerning(m_resource, previous_ch, ch);
}

/**
 * Calculate the dimensions of a rendered string of UTF-8 text.
 *
 * This will report the width and height, in pixels, of the space that the
 * specified string will take to fully render.
 *
 * @param font the font to query.
 * @param text text to calculate, in UTF-8 encoding.
 * @param length the length of the text, in bytes, or 0 for null terminated
 *               text.
 * @param w will be filled with width, in pixels, on return.
 * @param h will be filled with height, in pixels, on return.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline void GetStringSize(FontParam font, std::string_view text, int* w, int* h)
{
  CheckError(TTF_GetStringSize(font, text.data(), text.size(), w, h));
}

inline void Font::GetStringSize(std::string_view text, int* w, int* h) const
{
  SDL::GetStringSize(m_resource, text, w, h);
}

/**
 * Calculate the dimensions of a rendered string of UTF-8 text.
 *
 * This will report the width and height, in pixels, of the space that the
 * specified string will take to fully render.
 *
 * Text is wrapped to multiple lines on line endings and on word boundaries if
 * it extends beyond `wrap_width` in pixels.
 *
 * If wrap_width is 0, this function will only wrap on newline characters.
 *
 * @param font the font to query.
 * @param text text to calculate, in UTF-8 encoding.
 * @param length the length of the text, in bytes, or 0 for null terminated
 *               text.
 * @param wrap_width the maximum width or 0 to wrap on newline characters.
 * @param w will be filled with width, in pixels, on return.
 * @param h will be filled with height, in pixels, on return.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline void GetStringSizeWrapped(FontParam font,
                                 std::string_view text,
                                 int wrap_width,
                                 int* w,
                                 int* h)
{
  CheckError(
    TTF_GetStringSizeWrapped(font, text.data(), text.size(), wrap_width, w, h));
}

inline void Font::GetStringSizeWrapped(std::string_view text,
                                       int wrap_width,
                                       int* w,
                                       int* h) const
{
  SDL::GetStringSizeWrapped(m_resource, text, wrap_width, w, h);
}

/**
 * Calculate how much of a UTF-8 string will fit in a given width.
 *
 * This reports the number of characters that can be rendered before reaching
 * `max_width`.
 *
 * This does not need to render the string to do this calculation.
 *
 * @param font the font to query.
 * @param text text to calculate, in UTF-8 encoding.
 * @param length the length of the text, in bytes, or 0 for null terminated
 *               text.
 * @param max_width maximum width, in pixels, available for the string, or 0
 *                  for unbounded width.
 * @param measured_width a pointer filled in with the width, in pixels, of the
 *                       string that will fit, may be nullptr.
 * @param measured_length a pointer filled in with the length, in bytes, of
 *                        the string that will fit, may be nullptr.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline void MeasureString(FontParam font,
                          std::string_view text,
                          int max_width,
                          int* measured_width,
                          size_t* measured_length)
{
  CheckError(TTF_MeasureString(font,
                               text.data(),
                               text.size(),
                               max_width,
                               measured_width,
                               measured_length));
}

inline void Font::MeasureString(std::string_view text,
                                int max_width,
                                int* measured_width,
                                size_t* measured_length) const
{
  SDL::MeasureString(
    m_resource, text, max_width, measured_width, measured_length);
}

/**
 * Render UTF-8 text at fast quality to a new 8-bit surface.
 *
 * This function will allocate a new 8-bit, palettized surface. The surface's
 * 0 pixel will be the colorkey, giving a transparent background. The 1 pixel
 * will be set to the text color.
 *
 * This will not word-wrap the string; you'll get a surface with a single line
 * of text, as long as the string requires. You can use
 * Font.RenderText_Solid_Wrapped() instead if you need to wrap the output to
 * multiple lines.
 *
 * This will not wrap on newline characters.
 *
 * You can render at other quality levels with Font.RenderText_Shaded,
 * Font.RenderText_Blended, and Font.RenderText_LCD.
 *
 * @param font the font to render with.
 * @param text text to render, in UTF-8 encoding.
 * @param length the length of the text, in bytes, or 0 for null terminated
 *               text.
 * @param fg the foreground color for the text.
 * @returns a new 8-bit, palettized surface, or nullptr if there was an error.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.RenderText_Blended
 * @sa Font.RenderText_LCD
 * @sa Font.RenderText_Shaded
 * @sa Font.RenderText_Solid
 * @sa Font.RenderText_Solid_Wrapped
 */
inline Surface RenderText_Solid(FontParam font, std::string_view text, Color fg)
{
  return Surface{TTF_RenderText_Solid(font, text.data(), text.size(), fg)};
}

inline Surface Font::RenderText_Solid(std::string_view text, Color fg) const
{
  return SDL::RenderText_Solid(m_resource, text, fg);
}

/**
 * Render word-wrapped UTF-8 text at fast quality to a new 8-bit surface.
 *
 * This function will allocate a new 8-bit, palettized surface. The surface's
 * 0 pixel will be the colorkey, giving a transparent background. The 1 pixel
 * will be set to the text color.
 *
 * Text is wrapped to multiple lines on line endings and on word boundaries if
 * it extends beyond `wrapLength` in pixels.
 *
 * If wrapLength is 0, this function will only wrap on newline characters.
 *
 * You can render at other quality levels with Font.RenderText_Shaded_Wrapped,
 * Font.RenderText_Blended_Wrapped, and Font.RenderText_LCD_Wrapped.
 *
 * @param font the font to render with.
 * @param text text to render, in UTF-8 encoding.
 * @param length the length of the text, in bytes, or 0 for null terminated
 *               text.
 * @param fg the foreground color for the text.
 * @param wrapLength the maximum width of the text surface or 0 to wrap on
 *                   newline characters.
 * @returns a new 8-bit, palettized surface, or nullptr if there was an error.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.RenderText_Blended_Wrapped
 * @sa Font.RenderText_LCD_Wrapped
 * @sa Font.RenderText_Shaded_Wrapped
 * @sa Font.RenderText_Solid
 */
inline Surface RenderText_Solid_Wrapped(FontParam font,
                                        std::string_view text,
                                        Color fg,
                                        int wrapLength)
{
  return Surface(TTF_RenderText_Solid_Wrapped(
    font, text.data(), text.size(), fg, wrapLength));
}

inline Surface Font::RenderText_Solid_Wrapped(std::string_view text,
                                              Color fg,
                                              int wrapLength) const
{
  return SDL::RenderText_Solid_Wrapped(m_resource, text, fg, wrapLength);
}

/**
 * Render a single 32-bit glyph at fast quality to a new 8-bit surface.
 *
 * This function will allocate a new 8-bit, palettized surface. The surface's
 * 0 pixel will be the colorkey, giving a transparent background. The 1 pixel
 * will be set to the text color.
 *
 * The glyph is rendered without any padding or centering in the X direction,
 * and aligned normally in the Y direction.
 *
 * You can render at other quality levels with Font.RenderGlyph_Shaded,
 * Font.RenderGlyph_Blended, and Font.RenderGlyph_LCD.
 *
 * @param font the font to render with.
 * @param ch the character to render.
 * @param fg the foreground color for the text.
 * @returns a new 8-bit, palettized surface, or nullptr if there was an error.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.RenderGlyph_Blended
 * @sa Font.RenderGlyph_LCD
 * @sa Font.RenderGlyph_Shaded
 */
inline Surface RenderGlyph_Solid(FontParam font, Uint32 ch, ColorRaw fg)
{
  return Surface(TTF_RenderGlyph_Solid(font, ch, fg));
}

inline Surface Font::RenderGlyph_Solid(Uint32 ch, ColorRaw fg) const
{
  return SDL::RenderGlyph_Solid(m_resource, ch, fg);
}

/**
 * Render UTF-8 text at high quality to a new 8-bit surface.
 *
 * This function will allocate a new 8-bit, palettized surface. The surface's
 * 0 pixel will be the specified background color, while other pixels have
 * varying degrees of the foreground color. This function returns the new
 * surface, or nullptr if there was an error.
 *
 * This will not word-wrap the string; you'll get a surface with a single line
 * of text, as long as the string requires. You can use
 * Font.RenderText_Shaded_Wrapped() instead if you need to wrap the output to
 * multiple lines.
 *
 * This will not wrap on newline characters.
 *
 * You can render at other quality levels with Font.RenderText_Solid,
 * Font.RenderText_Blended, and Font.RenderText_LCD.
 *
 * @param font the font to render with.
 * @param text text to render, in UTF-8 encoding.
 * @param length the length of the text, in bytes, or 0 for null terminated
 *               text.
 * @param fg the foreground color for the text.
 * @param bg the background color for the text.
 * @returns a new 8-bit, palettized surface, or nullptr if there was an error.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.RenderText_Blended
 * @sa Font.RenderText_LCD
 * @sa Font.RenderText_Shaded_Wrapped
 * @sa Font.RenderText_Solid
 */
inline Surface RenderText_Shaded(FontParam font,
                                 std::string_view text,
                                 Color fg,
                                 Color bg)
{
  return Surface(TTF_RenderText_Shaded(font, text.data(), text.size(), fg, bg));
}

inline Surface Font::RenderText_Shaded(std::string_view text,
                                       Color fg,
                                       Color bg) const
{
  return SDL::RenderText_Shaded(m_resource, text, fg, bg);
}

/**
 * Render word-wrapped UTF-8 text at high quality to a new 8-bit surface.
 *
 * This function will allocate a new 8-bit, palettized surface. The surface's
 * 0 pixel will be the specified background color, while other pixels have
 * varying degrees of the foreground color. This function returns the new
 * surface, or nullptr if there was an error.
 *
 * Text is wrapped to multiple lines on line endings and on word boundaries if
 * it extends beyond `wrap_width` in pixels.
 *
 * If wrap_width is 0, this function will only wrap on newline characters.
 *
 * You can render at other quality levels with Font.RenderText_Solid_Wrapped,
 * Font.RenderText_Blended_Wrapped, and Font.RenderText_LCD_Wrapped.
 *
 * @param font the font to render with.
 * @param text text to render, in UTF-8 encoding.
 * @param length the length of the text, in bytes, or 0 for null terminated
 *               text.
 * @param fg the foreground color for the text.
 * @param bg the background color for the text.
 * @param wrap_width the maximum width of the text surface or 0 to wrap on
 *                   newline characters.
 * @returns a new 8-bit, palettized surface, or nullptr if there was an error.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.RenderText_Blended_Wrapped
 * @sa Font.RenderText_LCD_Wrapped
 * @sa Font.RenderText_Shaded
 * @sa Font.RenderText_Solid_Wrapped
 */
inline Surface RenderText_Shaded_Wrapped(FontParam font,
                                         std::string_view text,
                                         Color fg,
                                         Color bg,
                                         int wrap_width)
{
  return Surface(TTF_RenderText_Shaded_Wrapped(
    font, text.data(), text.size(), fg, bg, wrap_width));
}

inline Surface Font::RenderText_Shaded_Wrapped(std::string_view text,
                                               Color fg,
                                               Color bg,
                                               int wrap_width) const
{
  return SDL::RenderText_Shaded_Wrapped(m_resource, text, fg, bg, wrap_width);
}

/**
 * Render a single UNICODE codepoint at high quality to a new 8-bit surface.
 *
 * This function will allocate a new 8-bit, palettized surface. The surface's
 * 0 pixel will be the specified background color, while other pixels have
 * varying degrees of the foreground color. This function returns the new
 * surface, or nullptr if there was an error.
 *
 * The glyph is rendered without any padding or centering in the X direction,
 * and aligned normally in the Y direction.
 *
 * You can render at other quality levels with Font.RenderGlyph_Solid,
 * Font.RenderGlyph_Blended, and Font.RenderGlyph_LCD.
 *
 * @param font the font to render with.
 * @param ch the codepoint to render.
 * @param fg the foreground color for the text.
 * @param bg the background color for the text.
 * @returns a new 8-bit, palettized surface, or nullptr if there was an error.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.RenderGlyph_Blended
 * @sa Font.RenderGlyph_LCD
 * @sa Font.RenderGlyph_Solid
 */
inline Surface RenderGlyph_Shaded(FontParam font,
                                  Uint32 ch,
                                  ColorRaw fg,
                                  ColorRaw bg)
{
  return Surface(TTF_RenderGlyph_Shaded(font, ch, fg, bg));
}

inline Surface Font::RenderGlyph_Shaded(Uint32 ch,
                                        ColorRaw fg,
                                        ColorRaw bg) const
{
  return SDL::RenderGlyph_Shaded(m_resource, ch, fg, bg);
}

/**
 * Render UTF-8 text at high quality to a new ARGB surface.
 *
 * This function will allocate a new 32-bit, ARGB surface, using alpha
 * blending to dither the font with the given color. This function returns the
 * new surface, or nullptr if there was an error.
 *
 * This will not word-wrap the string; you'll get a surface with a single line
 * of text, as long as the string requires. You can use
 * Font.RenderText_Blended_Wrapped() instead if you need to wrap the output to
 * multiple lines.
 *
 * This will not wrap on newline characters.
 *
 * You can render at other quality levels with Font.RenderText_Solid,
 * Font.RenderText_Shaded, and Font.RenderText_LCD.
 *
 * @param font the font to render with.
 * @param text text to render, in UTF-8 encoding.
 * @param length the length of the text, in bytes, or 0 for null terminated
 *               text.
 * @param fg the foreground color for the text.
 * @returns a new 32-bit, ARGB surface, or nullptr if there was an error.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.RenderText_Blended_Wrapped
 * @sa Font.RenderText_LCD
 * @sa Font.RenderText_Shaded
 * @sa Font.RenderText_Solid
 */
inline Surface RenderText_Blended(FontParam font,
                                  std::string_view text,
                                  Color fg)
{
  return Surface(TTF_RenderText_Blended(font, text.data(), text.size(), fg));
}

inline Surface Font::RenderText_Blended(std::string_view text, Color fg) const
{
  return SDL::RenderText_Blended(m_resource, text, fg);
}

/**
 * Render word-wrapped UTF-8 text at high quality to a new ARGB surface.
 *
 * This function will allocate a new 32-bit, ARGB surface, using alpha
 * blending to dither the font with the given color. This function returns the
 * new surface, or nullptr if there was an error.
 *
 * Text is wrapped to multiple lines on line endings and on word boundaries if
 * it extends beyond `wrap_width` in pixels.
 *
 * If wrap_width is 0, this function will only wrap on newline characters.
 *
 * You can render at other quality levels with Font.RenderText_Solid_Wrapped,
 * Font.RenderText_Shaded_Wrapped, and Font.RenderText_LCD_Wrapped.
 *
 * @param font the font to render with.
 * @param text text to render, in UTF-8 encoding.
 * @param length the length of the text, in bytes, or 0 for null terminated
 *               text.
 * @param fg the foreground color for the text.
 * @param wrap_width the maximum width of the text surface or 0 to wrap on
 *                   newline characters.
 * @returns a new 32-bit, ARGB surface, or nullptr if there was an error.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.RenderText_Blended
 * @sa Font.RenderText_LCD_Wrapped
 * @sa Font.RenderText_Shaded_Wrapped
 * @sa Font.RenderText_Solid_Wrapped
 */
inline Surface RenderText_Blended_Wrapped(FontParam font,
                                          std::string_view text,
                                          Color fg,
                                          int wrap_width)
{
  return Surface(TTF_RenderText_Blended_Wrapped(
    font, text.data(), text.size(), fg, wrap_width));
}

inline Surface Font::RenderText_Blended_Wrapped(std::string_view text,
                                                Color fg,
                                                int wrap_width) const
{
  return SDL::RenderText_Blended_Wrapped(m_resource, text, fg, wrap_width);
}

/**
 * Render a single UNICODE codepoint at high quality to a new ARGB surface.
 *
 * This function will allocate a new 32-bit, ARGB surface, using alpha
 * blending to dither the font with the given color. This function returns the
 * new surface, or nullptr if there was an error.
 *
 * The glyph is rendered without any padding or centering in the X direction,
 * and aligned normally in the Y direction.
 *
 * You can render at other quality levels with Font.RenderGlyph_Solid,
 * Font.RenderGlyph_Shaded, and Font.RenderGlyph_LCD.
 *
 * @param font the font to render with.
 * @param ch the codepoint to render.
 * @param fg the foreground color for the text.
 * @returns a new 32-bit, ARGB surface, or nullptr if there was an error.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.RenderGlyph_LCD
 * @sa Font.RenderGlyph_Shaded
 * @sa Font.RenderGlyph_Solid
 */
inline Surface RenderGlyph_Blended(FontParam font, Uint32 ch, ColorRaw fg)
{
  return Surface(TTF_RenderGlyph_Blended(font, ch, fg));
}

inline Surface Font::RenderGlyph_Blended(Uint32 ch, ColorRaw fg) const
{
  return SDL::RenderGlyph_Blended(m_resource, ch, fg);
}

/**
 * Render UTF-8 text at LCD subpixel quality to a new ARGB surface.
 *
 * This function will allocate a new 32-bit, ARGB surface, and render
 * alpha-blended text using FreeType's LCD subpixel rendering. This function
 * returns the new surface, or nullptr if there was an error.
 *
 * This will not word-wrap the string; you'll get a surface with a single line
 * of text, as long as the string requires. You can use
 * Font.RenderText_LCD_Wrapped() instead if you need to wrap the output to
 * multiple lines.
 *
 * This will not wrap on newline characters.
 *
 * You can render at other quality levels with Font.RenderText_Solid,
 * Font.RenderText_Shaded, and Font.RenderText_Blended.
 *
 * @param font the font to render with.
 * @param text text to render, in UTF-8 encoding.
 * @param length the length of the text, in bytes, or 0 for null terminated
 *               text.
 * @param fg the foreground color for the text.
 * @param bg the background color for the text.
 * @returns a new 32-bit, ARGB surface, or nullptr if there was an error.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.RenderText_Blended
 * @sa Font.RenderText_LCD_Wrapped
 * @sa Font.RenderText_Shaded
 * @sa Font.RenderText_Solid
 */
inline Surface RenderText_LCD(FontParam font,
                              std::string_view text,
                              Color fg,
                              Color bg)
{
  return Surface(TTF_RenderText_LCD(font, text.data(), text.size(), fg, bg));
}

inline Surface Font::RenderText_LCD(std::string_view text,
                                    Color fg,
                                    Color bg) const
{
  return SDL::RenderText_LCD(m_resource, text, fg, bg);
}

/**
 * Render word-wrapped UTF-8 text at LCD subpixel quality to a new ARGB
 * surface.
 *
 * This function will allocate a new 32-bit, ARGB surface, and render
 * alpha-blended text using FreeType's LCD subpixel rendering. This function
 * returns the new surface, or nullptr if there was an error.
 *
 * Text is wrapped to multiple lines on line endings and on word boundaries if
 * it extends beyond `wrap_width` in pixels.
 *
 * If wrap_width is 0, this function will only wrap on newline characters.
 *
 * You can render at other quality levels with Font.RenderText_Solid_Wrapped,
 * Font.RenderText_Shaded_Wrapped, and Font.RenderText_Blended_Wrapped.
 *
 * @param font the font to render with.
 * @param text text to render, in UTF-8 encoding.
 * @param length the length of the text, in bytes, or 0 for null terminated
 *               text.
 * @param fg the foreground color for the text.
 * @param bg the background color for the text.
 * @param wrap_width the maximum width of the text surface or 0 to wrap on
 *                   newline characters.
 * @returns a new 32-bit, ARGB surface, or nullptr if there was an error.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.RenderText_Blended_Wrapped
 * @sa Font.RenderText_LCD
 * @sa Font.RenderText_Shaded_Wrapped
 * @sa Font.RenderText_Solid_Wrapped
 */
inline Surface RenderText_LCD_Wrapped(FontParam font,
                                      std::string_view text,
                                      Color fg,
                                      Color bg,
                                      int wrap_width)
{
  return Surface(TTF_RenderText_LCD_Wrapped(
    font, text.data(), text.size(), fg, bg, wrap_width));
}

inline Surface Font::RenderText_LCD_Wrapped(std::string_view text,
                                            Color fg,
                                            Color bg,
                                            int wrap_width) const
{
  return SDL::RenderText_LCD_Wrapped(m_resource, text, fg, bg, wrap_width);
}

/**
 * Render a single UNICODE codepoint at LCD subpixel quality to a new ARGB
 * surface.
 *
 * This function will allocate a new 32-bit, ARGB surface, and render
 * alpha-blended text using FreeType's LCD subpixel rendering. This function
 * returns the new surface, or nullptr if there was an error.
 *
 * The glyph is rendered without any padding or centering in the X direction,
 * and aligned normally in the Y direction.
 *
 * You can render at other quality levels with Font.RenderGlyph_Solid,
 * Font.RenderGlyph_Shaded, and Font.RenderGlyph_Blended.
 *
 * @param font the font to render with.
 * @param ch the codepoint to render.
 * @param fg the foreground color for the text.
 * @param bg the background color for the text.
 * @returns a new 32-bit, ARGB surface, or nullptr if there was an error.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.RenderGlyph_Blended
 * @sa Font.RenderGlyph_Shaded
 * @sa Font.RenderGlyph_Solid
 */
inline Surface RenderGlyph_LCD(FontParam font,
                               Uint32 ch,
                               ColorRaw fg,
                               ColorRaw bg)
{
  return Surface(TTF_RenderGlyph_LCD(font, ch, fg, bg));
}

inline Surface Font::RenderGlyph_LCD(Uint32 ch, ColorRaw fg, ColorRaw bg) const
{
  return SDL::RenderGlyph_LCD(m_resource, ch, fg, bg);
}

/**
 * Text created with Text.Text()
 *
 * @since This struct is available since SDL_ttf 3.0.0.
 *
 * @sa Text.Text
 * @sa Text.GetProperties
 * @sa Text.Destroy
 *
 * @cat resource
 */
class Text
{
  TextRaw m_resource = nullptr;

public:
  /// Default ctor
  constexpr Text() = default;

  /**
   * Constructs from TextParam.
   *
   * @param resource a TextRaw to be wrapped.
   *
   * This assumes the ownership, call release() if you need to take back.
   */
  constexpr explicit Text(const TextRaw resource)
    : m_resource(resource)
  {
  }

  /// Copy constructor
  constexpr Text(const Text& other) = delete;

  /// Move constructor
  constexpr Text(Text&& other)
    : Text(other.release())
  {
  }

  constexpr Text(const TextRef& other) = delete;

  constexpr Text(TextRef&& other) = delete;

  /**
   * Create a text object from UTF-8 text and a text engine.
   *
   * @param engine the text engine to use when creating the text object, may be
   *               nullptr.
   * @param font the font to render with.
   * @param text the text to use, in UTF-8 encoding.
   * @post a Text object or nullptr on failure; call GetError() for more
   *          information.
   *
   * @threadsafety This function should be called on the thread that created the
   *               font and text engine.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.Destroy
   */
  Text(TextEngineParam engine, FontParam font, std::string_view text)
    : m_resource(TTF_CreateText(engine, font, text.data(), text.size()))
  {
  }

  /// Destructor
  ~Text() { TTF_DestroyText(m_resource); }

  /// Assignment operator.
  Text& operator=(Text other)
  {
    std::swap(m_resource, other.m_resource);
    return *this;
  }

  /// Retrieves underlying TextRaw.
  constexpr TextRaw get() const { return m_resource; }

  /// Retrieves underlying TextRaw and clear this.
  constexpr TextRaw release()
  {
    auto r = m_resource;
    m_resource = nullptr;
    return r;
  }

  /// Comparison
  constexpr auto operator<=>(const Text& other) const = default;

  /// Comparison
  constexpr bool operator==(std::nullptr_t _) const { return !m_resource; }

  /// converts to bool
  constexpr explicit operator bool() const { return !!m_resource; }

  /// Converts to TextParam
  constexpr operator TextParam() const { return {m_resource}; }

  /**
   * Destroy a text object created by a text engine.
   *
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.Text
   */
  void Destroy();

  /**
   * Draw text to an SDL surface.
   *
   * `text` must have been created using a TextEngine from
   * SurfaceTextEngine.SurfaceTextEngine().
   *
   * @param x the x coordinate in pixels, positive from the left edge towards
   *          the right.
   * @param y the y coordinate in pixels, positive from the top edge towards the
   *          bottom.
   * @param surface the surface to draw on.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa SurfaceTextEngine.SurfaceTextEngine
   * @sa Text.Text
   */
  void DrawSurface(Point p, SurfaceParam surface) const;

  /**
   * Draw text to an SDL renderer.
   *
   * `text` must have been created using a TextEngine from
   * RendererTextEngine.RendererTextEngine(), and will draw using the renderer
   * passed to that function.
   *
   * @param x the x coordinate in pixels, positive from the left edge towards
   *          the right.
   * @param y the y coordinate in pixels, positive from the top edge towards the
   *          bottom.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa RendererTextEngine.RendererTextEngine
   * @sa Text.Text
   */
  void DrawRenderer(FPoint p) const;

  /**
   * Get the geometry data needed for drawing the text.
   *
   * `text` must have been created using a TextEngine from
   * GPUTextEngine.GPUTextEngine().
   *
   * The positive X-axis is taken towards the right and the positive Y-axis is
   * taken upwards for both the vertex and the texture coordinates, i.e, it
   * follows the same convention used by the SDL_GPU API. If you want to use a
   * different coordinate system you will need to transform the vertices
   * yourself.
   *
   * If the text looks blocky use linear filtering.
   *
   * @returns a nullptr terminated linked list of GPUAtlasDrawSequence objects
   *          or nullptr if the passed text is empty or in case of failure; call
   *          GetError() for more information.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa GPUTextEngine.GPUTextEngine
   * @sa Text.Text
   */
  GPUAtlasDrawSequence* GetGPUDrawData() const;

  /**
   * Get the properties associated with a text object.
   *
   * @returns a valid property ID on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  PropertiesRef GetProperties() const;

  /**
   * Set the text engine used by a text object.
   *
   * This function may cause the internal text representation to be rebuilt.
   *
   * @param engine the text engine to use for drawing.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.GetEngine
   */
  void SetEngine(TextEngineParam engine);

  /**
   * Get the text engine used by a text object.
   *
   * @returns the TextEngine used by the text on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.SetEngine
   */
  TextEngineParam GetEngine() const;

  /**
   * Set the font used by a text object.
   *
   * When a text object has a font, any changes to the font will automatically
   * regenerate the text. If you set the font to nullptr, the text will continue
   * to render but changes to the font will no longer affect the text.
   *
   * This function may cause the internal text representation to be rebuilt.
   *
   * @param font the font to use, may be nullptr.
   * @returns false if the text pointer is null; otherwise, true. call
   *          GetError() for more information.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.GetFont
   */
  bool SetFont(FontParam font);

  /**
   * Get the font used by a text object.
   *
   * @returns the Font used by the text on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.SetFont
   */
  FontRef GetFont() const;

  /**
   * Set the direction to be used for text shaping a text object.
   *
   * This function only supports left-to-right text shaping if SDL_ttf was not
   * built with HarfBuzz support.
   *
   * @param direction the new direction for text to flow.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  void SetDirection(Direction direction);

  /**
   * Get the direction to be used for text shaping a text object.
   *
   * This defaults to the direction of the font used by the text object.
   *
   * @returns the direction to be used for text shaping.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  Direction GetDirection() const;

  /**
   * Set the script to be used for text shaping a text object.
   *
   * This returns false if SDL_ttf isn't built with HarfBuzz support.
   *
   * @param script an
   *               [ISO 15924
   * code](https://unicode.org/iso15924/iso15924-codes.html)
   *               .
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa StringToTag
   */
  void SetScript(Uint32 script);

  /**
   * Get the script used for text shaping a text object.
   *
   * This defaults to the script of the font used by the text object.
   *
   * @returns an
   *          [ISO 15924 code](https://unicode.org/iso15924/iso15924-codes.html)
   *          or 0 if a script hasn't been set on either the text object or the
   *          font.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa TagToString
   */
  Uint32 GetScript() const;

  /**
   * Set the color of a text object.
   *
   * The default text color is white (255, 255, 255, 255).
   *
   * @param c the color values in the range of 0-255.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.GetColor
   * @sa Text.SetColorFloat
   */
  void SetColor(Color c);

  /**
   * Set the color of a text object.
   *
   * The default text color is white (1.0f, 1.0f, 1.0f, 1.0f).
   *
   * @param c the color value, normally in the range of 0-1.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.GetColorFloat
   * @sa Text.SetColor
   */
  void SetColorFloat(FColor c);

  /**
   * Get the color of a text object.
   *
   * @param r a pointer filled in with the red color value in the range of
   *          0-255, may be nullptr.
   * @param g a pointer filled in with the green color value in the range of
   *          0-255, may be nullptr.
   * @param b a pointer filled in with the blue color value in the range of
   *          0-255, may be nullptr.
   * @param a a pointer filled in with the alpha value in the range of 0-255,
   *          may be nullptr.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.GetColorFloat
   * @sa Text.SetColor
   */
  void GetColor(Uint8* r, Uint8* g, Uint8* b, Uint8* a) const;

  /**
   * Get the color of a text object.
   *
   * @return The color in the range of 0-255 on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.GetColorFloat
   * @sa Text.SetColor
   */
  Color GetColor() const;

  /**
   * Get the color of a text object.
   *
   * @param r a pointer filled in with the red color value, normally in the
   *          range of 0-1, may be nullptr.
   * @param g a pointer filled in with the green color value, normally in the
   *          range of 0-1, may be nullptr.
   * @param b a pointer filled in with the blue color value, normally in the
   *          range of 0-1, may be nullptr.
   * @param a a pointer filled in with the alpha value in the range of 0-1, may
   *          be nullptr.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.GetColor
   * @sa Text.SetColorFloat
   */
  void GetColorFloat(float* r, float* g, float* b, float* a) const;

  /**
   * Get the color of a text object.
   *
   * @return The color in the range of 0-1 on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.GetColor
   * @sa Text.SetColorFloat
   */
  FColor GetColorFloat() const;

  /**
   * Set the position of a text object.
   *
   * This can be used to position multiple text objects within a single wrapping
   * text area.
   *
   * This function may cause the internal text representation to be rebuilt.
   *
   * @param p the x, y offset of the upper left corner of this text in pixels.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.GetPosition
   */
  bool SetPosition(Point p);

  /**
   * Get the position of a text object.
   *
   * @param x a pointer filled in with the x offset of the upper left corner of
   *          this text in pixels, may be nullptr.
   * @param y a pointer filled in with the y offset of the upper left corner of
   *          this text in pixels, may be nullptr.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.SetPosition
   */
  bool GetPosition(int* x, int* y) const;

  /**
   * Get the position of a text object.
   *
   * @returns a Point with the offset of the upper left corner of this text in
   *          pixels on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.SetPosition
   */
  Point GetPosition() const;

  /**
   * Set whether wrapping is enabled on a text object.
   *
   * This function may cause the internal text representation to be rebuilt.
   *
   * @param wrap_width the maximum width in pixels, 0 to wrap on newline
   *                   characters.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.GetWrapWidth
   */
  void SetWrapWidth(int wrap_width);

  /**
   * Get whether wrapping is enabled on a text object.
   *
   * @returns an int with the maximum width in pixels or 0 if the text is being
   *          wrapped on newline characters on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.SetWrapWidth
   */
  int GetWrapWidth() const;

  /**
   * Set whether whitespace should be visible when wrapping a text object.
   *
   * If the whitespace is visible, it will take up space for purposes of
   * alignment and wrapping. This is good for editing, but looks better when
   * centered or aligned if whitespace around line wrapping is hidden. This
   * defaults false.
   *
   * This function may cause the internal text representation to be rebuilt.
   *
   * @param visible true to show whitespace when wrapping text, false to hide
   *                it.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.IsWrapWhitespaceVisible
   */
  void SetWrapWhitespaceVisible(bool visible);

  /**
   * Return whether whitespace is shown when wrapping a text object.
   *
   * @returns true if whitespace is shown when wrapping text, or false
   *          otherwise.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.SetWrapWhitespaceVisible
   */
  bool IsWrapWhitespaceVisible() const;

  /**
   * Set the UTF-8 text used by a text object.
   *
   * This function may cause the internal text representation to be rebuilt.
   *
   * @param string the UTF-8 text to use.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.AppendString
   * @sa Text.DeleteString
   * @sa Text.InsertString
   */
  void SetString(std::string_view string);

  /**
   * Insert UTF-8 text into a text object.
   *
   * This function may cause the internal text representation to be rebuilt.
   *
   * @param offset the offset, in bytes, from the beginning of the string if >=
   *               0, the offset from the end of the string if < 0. Note that
   *               this does not do UTF-8 validation, so you should only insert
   *               at UTF-8 sequence boundaries.
   * @param string the UTF-8 text to insert.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.AppendString
   * @sa Text.DeleteString
   * @sa Text.SetString
   */
  void InsertString(int offset, std::string_view string);

  /**
   * Append UTF-8 text to a text object.
   *
   * This function may cause the internal text representation to be rebuilt.
   *
   * @param string the UTF-8 text to insert.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.DeleteString
   * @sa Text.InsertString
   * @sa Text.SetString
   */
  void AppendString(std::string_view string);

  /**
   * Delete UTF-8 text from a text object.
   *
   * This function may cause the internal text representation to be rebuilt.
   *
   * @param offset the offset, in bytes, from the beginning of the string if >=
   *               0, the offset from the end of the string if < 0. Note that
   *               this does not do UTF-8 validation, so you should only delete
   *               at UTF-8 sequence boundaries.
   * @param length the length of text to delete, in bytes, or -1 for the
   *               remainder of the string.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa Text.AppendString
   * @sa Text.InsertString
   * @sa Text.SetString
   */
  void DeleteString(int offset, int length);

  /**
   * Get the size of a text object.
   *
   * The size of the text may change when the font or font style and size
   * change.
   *
   * @param w a pointer filled in with the width of the text, in pixels, may be
   *          nullptr.
   * @param h a pointer filled in with the height of the text, in pixels, may be
   *          nullptr.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  void GetSize(int* w, int* h) const;

  /**
   * Get the size of a text object.
   *
   * The size of the text may change when the font or font style and size
   * change.
   *
   * @returns Point containing the size on x and y axis on success.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   *
   * @sa GetSize(int*,int*) if might want only one of the coordinates
   */
  Point GetSize() const;

  /**
   * Get the substring of a text object that surrounds a text offset.
   *
   * If `offset` is less than 0, this will return a zero length substring at the
   * beginning of the text with the SUBSTRING_TEXT_START flag set. If
   * `offset` is greater than or equal to the length of the text string, this
   * will return a zero length substring at the end of the text with the
   * SUBSTRING_TEXT_END flag set.
   *
   * @param offset a byte offset into the text string.
   * @param substring a pointer filled in with the substring containing the
   *                  offset.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  void GetSubString(int offset, SubString* substring) const;

  /**
   * Get iterator to first substring
   */
  SubStringIterator begin() const;

  /**
   * Get iterator to one past last substring
   */
  SubStringIterator end() const;

  /**
   * Get iterator to substring of a text object that contains the given line.
   *
   * If `line` is greater than or equal to `text->num_lines` this will return an
   * iterator equal to end().
   *
   * @param line a zero-based line index, in the range [0 .. text->num_lines-1].
   * @returns iterator on success or false on failure; call GetError() for more
   *          information.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  SubStringIterator GetSubStringForLine(int line) const;

  /**
   * Get the substring of a text object that contains the given line.
   *
   * If `line` is less than 0, this will return a zero length substring at the
   * beginning of the text with the SUBSTRING_TEXT_START flag set. If `line`
   * is greater than or equal to `text->num_lines` this will return a zero
   * length substring at the end of the text with the SUBSTRING_TEXT_END
   * flag set.
   *
   * @param line a zero-based line index, in the range [0 .. text->num_lines-1].
   * @param substring a pointer filled in with the substring containing the
   *                  offset.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  void GetSubStringForLine(int line, SubString* substring) const;

  OwnArray<SubString*> GetSubStrings() const
  {
    return GetSubStringsForRange(0);
  }

  /**
   * Get the substrings of a text object that contain a range of text.
   *
   * @param offset a byte offset into the text string.
   * @param length the length of the range being queried, in bytes, or -1 for
   *               the remainder of the string.
   * @param count a pointer filled in with the number of substrings returned,
   *              may be nullptr.
   * @returns a nullptr terminated array of substring pointers or nullptr on
   * failure; call GetError() for more information. This is a single allocation
   * that should be freed with free() when it is no longer needed.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  OwnArray<SubString*> GetSubStringsForRange(int offset, int length = -1) const;

  SubStringIterator GetSubStringForPoint(Point p) const;

  /**
   * Get the portion of a text string that is closest to a point.
   *
   * This will return the closest substring of text to the given point.
   *
   * @param p the coordinates relative to the top-left side of the text, may be
   *          outside the bounds of the text area.
   * @param substring a pointer filled in with the closest substring of text to
   *                  the given point.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  void GetSubStringForPoint(Point p, SubString* substring) const;

  /**
   * Get the previous substring in a text object
   *
   * If called at the start of the text, this will return a zero length
   * substring with the SUBSTRING_TEXT_START flag set.
   *
   * @param substring the SubString to query.
   * @param previous a pointer filled in with the previous substring in the text
   *                 object.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  void GetPreviousSubString(const SubString& substring,
                            SubString* previous) const;

  /**
   * Get the next substring in a text object
   *
   * If called at the end of the text, this will return a zero length substring
   * with the SUBSTRING_TEXT_END flag set.
   *
   * @param substring the SubString to query.
   * @param next a pointer filled in with the next substring.
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  void GetNextSubString(const SubString& substring, SubString* next) const;

  /**
   * Update the layout of a text object.
   *
   * This is automatically done when the layout is requested or the text is
   * rendered, but you can call this if you need more control over the timing of
   * when the layout and text engine representation are updated.
   *
   * @throws Error on failure.
   *
   * @threadsafety This function should be called on the thread that created the
   *               text.
   *
   * @since This function is available since SDL_ttf 3.0.0.
   */
  void Update();

  /**
   * A copy of the UTF-8 string that this text object represents, useful for
   * layout, debugging and retrieving substring text
   */
  const char* GetText() const { return m_resource->text; }

  /// The number of lines in the text, 0 if it's empty
  int GetNumLines() const { return m_resource->num_lines; }
};

/// Semi-safe reference for Text.
struct TextRef : Text
{
  /**
   * Constructs from TextParam.
   *
   * @param resource a TextRaw or Text.
   *
   * This does not takes ownership!
   */
  TextRef(TextParam resource = nullptr)
    : Text(resource.value)
  {
  }

  /// Copy constructor.
  TextRef(const TextRef& other)
    : Text(other.get())
  {
  }

  /// Destructor
  ~TextRef() { release(); }
};

/**
 * Iterator for substrings
 *
 */
class SubStringIterator
{
  TextRef m_text;

  SubString m_subString;

  constexpr SubStringIterator(TextRef text)
    : m_text(text)
    , m_subString(0)
  {
  }

public:
  /// Default constructor.
  constexpr SubStringIterator()
    : SubStringIterator(TextRef{})
  {
  }

  /// True if pointing to valid SubString.
  constexpr operator bool() const { return bool(m_text); }

  /// Retrieve SubString
  constexpr const SubString& operator*() const { return m_subString; }

  /// Retrieve SubString.
  constexpr const SubString* operator->() const { return &m_subString; }

  /// Comparison.
  constexpr bool operator==(const SubStringIterator& other) const
  {
    return m_subString.offset == other.m_subString.offset;
  }

  /// Increment operator.
  constexpr SubStringIterator& operator++()
  {
    m_text.GetNextSubString(m_subString, &m_subString);
    return *this;
  }

  /// Increment operator.
  constexpr SubStringIterator operator++(int)
  {
    auto curr = *this;
    m_text.GetNextSubString(m_subString, &m_subString);
    return curr;
  }

  /// Decrement operator.
  constexpr SubStringIterator& operator--()
  {
    m_text.GetPreviousSubString(m_subString, &m_subString);
    return *this;
  }

  /// Decrement operator.
  constexpr SubStringIterator operator--(int)
  {
    auto curr = *this;
    m_text.GetPreviousSubString(m_subString, &m_subString);
    return curr;
  }

  friend class Text;
};

/**
 * Create a text engine for drawing text on SDL surfaces.
 *
 * @returns a TextEngine object or nullptr on failure; call GetError()
 *          for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa TextEngine.DestroySurface
 * @sa Text.DrawSurface
 */
inline SurfaceTextEngine CreateSurfaceTextEngine()
{
  return SurfaceTextEngine();
}

/**
 * Draw text to an SDL surface.
 *
 * `text` must have been created using a TextEngine from
 * SurfaceTextEngine.SurfaceTextEngine().
 *
 * @param text the text to draw.
 * @param p the (x, y) coordinate in pixels, positive from the left edge
 *          towards the right and from the top edge towards the bottom.
 * @param surface the surface to draw on.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa SurfaceTextEngine.SurfaceTextEngine
 * @sa Text.Text
 */
inline void DrawSurfaceText(TextParam text, Point p, SurfaceParam surface)
{
  CheckError(TTF_DrawSurfaceText(text, p.x, p.y, surface));
}

inline void Text::DrawSurface(Point p, SurfaceParam surface) const
{
  SDL::DrawSurfaceText(m_resource, p, surface);
}

/**
 * Destroy a text engine created for drawing text on SDL surfaces.
 *
 * All text created by this engine should be destroyed before calling this
 * function.
 *
 * @param engine a TextEngine object created with
 *               SurfaceTextEngine.SurfaceTextEngine().
 *
 * @threadsafety This function should be called on the thread that created the
 *               engine.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa SurfaceTextEngine.SurfaceTextEngine
 */
inline void DestroySurfaceTextEngine(TextEngineRaw engine)
{
  TTF_DestroySurfaceTextEngine(engine);
}

inline void SurfaceTextEngine::Destroy()
{
  DestroySurfaceTextEngine(release());
}

/**
 * Create a text engine for drawing text on an SDL renderer.
 *
 * @param renderer the renderer to use for creating textures and drawing text.
 * @returns a TextEngine object or nullptr on failure; call GetError()
 *          for more information.
 *
 * @threadsafety This function should be called on the thread that created the
 *               renderer.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa TextEngine.DestroyRenderer
 * @sa Text.DrawRenderer
 * @sa RendererTextEngine.RendererTextEngine
 */
inline RendererTextEngine CreateRendererTextEngine(RendererParam renderer)
{
  return RendererTextEngine(renderer);
}

/**
 * Create a text engine for drawing text on an SDL renderer, with the
 * specified properties.
 *
 * These are the supported properties:
 *
 * - `prop::RendererTextEngine.RENDERER_POINTER`: the renderer to use for
 *   creating textures and drawing text
 * - `prop::RendererTextEngine.ATLAS_TEXTURE_SIZE_NUMBER`: the size of the
 *   texture atlas
 *
 * @param props the properties to use.
 * @returns a TextEngine object or nullptr on failure; call GetError()
 *          for more information.
 *
 * @threadsafety This function should be called on the thread that created the
 *               renderer.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa RendererTextEngine.RendererTextEngine
 * @sa TextEngine.DestroyRenderer
 * @sa Text.DrawRenderer
 */
inline RendererTextEngine CreateRendererTextEngineWithProperties(
  PropertiesParam props)
{
  return RendererTextEngine(props);
}

namespace prop::RendererTextEngine {

constexpr auto RENDERER_POINTER =
  TTF_PROP_RENDERER_TEXT_ENGINE_RENDERER_POINTER;

constexpr auto ATLAS_TEXTURE_SIZE_NUMBER =
  TTF_PROP_RENDERER_TEXT_ENGINE_ATLAS_TEXTURE_SIZE_NUMBER;

} // namespace prop::RendererTextEngine

/**
 * Draw text to an SDL renderer.
 *
 * `text` must have been created using a TextEngine from
 * RendererTextEngine.RendererTextEngine(), and will draw using the renderer
 * passed to that function.
 *
 * @param text the text to draw.
 * @param p the (x, y) coordinate in pixels, positive from the left edge
 *          towards the right and from the top edge towards the bottom.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa RendererTextEngine.RendererTextEngine
 * @sa GPUTextEngine.GPUTextEngine
 */
inline void DrawRendererText(TextParam text, FPoint p)
{
  CheckError(TTF_DrawRendererText(text, p.x, p.y));
}

inline void Text::DrawRenderer(FPoint p) const
{
  SDL::DrawRendererText(m_resource, p);
}

/**
 * Destroy a text engine created for drawing text on an SDL renderer.
 *
 * All text created by this engine should be destroyed before calling this
 * function.
 *
 * @param engine a TextEngine object created with
 *               RendererTextEngine.RendererTextEngine().
 *
 * @threadsafety This function should be called on the thread that created the
 *               engine.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa RendererTextEngine.RendererTextEngine
 */
inline void DestroyRendererTextEngine(TextEngineRaw engine)
{
  TTF_DestroyRendererTextEngine(engine);
}

inline void RendererTextEngine::Destroy()
{
  DestroyRendererTextEngine(release());
}

/**
 * Create a text engine for drawing text with the SDL GPU API.
 *
 * @param device the SDL_GPUDevice to use for creating textures and drawing
 *               text.
 * @returns a TextEngine object or nullptr on failure; call GetError()
 *          for more information.
 *
 * @threadsafety This function should be called on the thread that created the
 *               device.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa GPUTextEngine.GPUTextEngine
 * @sa TextEngine.DestroyGPU
 * @sa Text.GetGPUDrawData
 */
inline GPUTextEngine CreateGPUTextEngine(SDL_GPUDevice* device)
{
  return GPUTextEngine(device);
}

/**
 * Create a text engine for drawing text with the SDL GPU API, with the
 * specified properties.
 *
 * These are the supported properties:
 *
 * - `prop::GpuTextEngine.DEVICE_POINTER`: the SDL_GPUDevice to use for creating
 *   textures and drawing text.
 * - `prop::GpuTextEngine.ATLAS_TEXTURE_SIZE_NUMBER`: the size of the texture
 *   atlas
 *
 * @param props the properties to use.
 * @returns a TextEngine object or nullptr on failure; call GetError()
 *          for more information.
 *
 * @threadsafety This function should be called on the thread that created the
 *               device.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa GPUTextEngine.GPUTextEngine
 * @sa TextEngine.DestroyGPU
 * @sa Text.GetGPUDrawData
 */
inline GPUTextEngine CreateGPUTextEngineWithProperties(PropertiesParam props)
{
  return GPUTextEngine(props);
}

namespace prop::GpuTextEngine {

constexpr auto DEVICE_POINTER = TTF_PROP_GPU_TEXT_ENGINE_DEVICE_POINTER;

constexpr auto ATLAS_TEXTURE_SIZE_NUMBER =
  TTF_PROP_GPU_TEXT_ENGINE_ATLAS_TEXTURE_SIZE_NUMBER;

} // namespace prop::GpuTextEngine

/**
 * Get the geometry data needed for drawing the text.
 *
 * `text` must have been created using a TextEngine from
 * GPUTextEngine.GPUTextEngine().
 *
 * The positive X-axis is taken towards the right and the positive Y-axis is
 * taken upwards for both the vertex and the texture coordinates, i.e, it
 * follows the same convention used by the SDL_GPU API. If you want to use a
 * different coordinate system you will need to transform the vertices
 * yourself.
 *
 * If the text looks blocky use linear filtering.
 *
 * @param text the text to draw.
 * @returns a nullptr terminated linked list of GPUAtlasDrawSequence objects
 *          or nullptr if the passed text is empty or in case of failure; call
 *          GetError() for more information.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa GPUTextEngine.GPUTextEngine
 * @sa GPUTextEngine.GPUTextEngine
 */
inline GPUAtlasDrawSequence* GetGPUTextDrawData(TextParam text)
{
  return TTF_GetGPUTextDrawData(text);
}

inline GPUAtlasDrawSequence* Text::GetGPUDrawData() const
{
  return SDL::GetGPUTextDrawData(m_resource);
}

/**
 * Destroy a text engine created for drawing text with the SDL GPU API.
 *
 * All text created by this engine should be destroyed before calling this
 * function.
 *
 * @param engine a TextEngine object created with
 *               GPUTextEngine.GPUTextEngine().
 *
 * @threadsafety This function should be called on the thread that created the
 *               engine.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa GPUTextEngine.GPUTextEngine
 */
inline void DestroyGPUTextEngine(TextEngineRaw engine)
{
  TTF_DestroyGPUTextEngine(engine);
}

inline void GPUTextEngine::Destroy() { DestroyGPUTextEngine(release()); }

/**
 * Sets the winding order of the vertices returned by Text.GetGPUDrawData
 * for a particular GPU text engine.
 *
 * @param engine a TextEngine object created with
 *               GPUTextEngine.GPUTextEngine().
 * @param winding the new winding order option.
 *
 * @threadsafety This function should be called on the thread that created the
 *               engine.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa GPUTextEngine.GetGPUWinding
 */
inline void SetGPUTextEngineWinding(TextEngineParam engine,
                                    GPUTextEngineWinding winding)
{
  TTF_SetGPUTextEngineWinding(engine, winding);
}

inline void GPUTextEngine::SetGPUWinding(GPUTextEngineWinding winding)
{
  SDL::SetGPUTextEngineWinding(get(), winding);
}

/**
 * Get the winding order of the vertices returned by Text.GetGPUDrawData
 * for a particular GPU text engine
 *
 * @param engine a TextEngine object created with
 *               GPUTextEngine.GPUTextEngine().
 * @returns the winding order used by the GPU text engine or
 *          GPU_TEXTENGINE_WINDING_INVALID in case of error.
 *
 * @threadsafety This function should be called on the thread that created the
 *               engine.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa GPUTextEngine.SetGPUWinding
 */
inline GPUTextEngineWinding GetGPUTextEngineWinding(TextEngineParam engine)
{
  return TTF_GetGPUTextEngineWinding(engine);
}

inline GPUTextEngineWinding GPUTextEngine::GetGPUWinding() const
{
  return SDL::GetGPUTextEngineWinding(get());
}

inline Text TextEngine::CreateText(FontParam font, std::string_view text)
{
  return Text(m_resource, font, text);
}

/**
 * Create a text object from UTF-8 text and a text engine.
 *
 * @param engine the text engine to use when creating the text object, may be
 *               nullptr.
 * @param font the font to render with.
 * @param text the text to use, in UTF-8 encoding.
 * @returns a Text object or nullptr on failure; call GetError() for more
 *          information.
 *
 * @threadsafety This function should be called on the thread that created the
 *               font and text engine.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Text.Destroy
 */
inline Text CreateText(TextEngineParam engine,
                       FontParam font,
                       std::string_view text)
{
  return Text(engine, font, text);
}

/**
 * Get the properties associated with a text object.
 *
 * @param text the Text to query.
 * @returns a valid property ID on success.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline PropertiesRef GetTextProperties(TextParam text)
{
  return {CheckError(TTF_GetTextProperties(text))};
}

inline PropertiesRef Text::GetProperties() const
{
  return SDL::GetTextProperties(m_resource);
}

/**
 * Set the text engine used by a text object.
 *
 * This function may cause the internal text representation to be rebuilt.
 *
 * @param text the Text to modify.
 * @param engine the text engine to use for drawing.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Text.GetEngine
 */
inline void SetTextEngine(TextParam text, TextEngineParam engine)
{
  CheckError(TTF_SetTextEngine(text, engine));
}

inline void Text::SetEngine(TextEngineParam engine)
{
  SDL::SetTextEngine(m_resource, engine);
}

/**
 * Get the text engine used by a text object.
 *
 * @param text the Text to query.
 * @returns the TextEngine used by the text on success.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Text.SetEngine
 */
inline TextEngineParam GetTextEngine(TextParam text)
{
  return CheckError(TTF_GetTextEngine(text));
}

inline TextEngineParam Text::GetEngine() const
{
  return SDL::GetTextEngine(m_resource);
}

/**
 * Set the font used by a text object.
 *
 * When a text object has a font, any changes to the font will automatically
 * regenerate the text. If you set the font to nullptr, the text will continue
 * to render but changes to the font will no longer affect the text.
 *
 * This function may cause the internal text representation to be rebuilt.
 *
 * @param text the Text to modify.
 * @param font the font to use, may be nullptr.
 * @returns false if the text pointer is null; otherwise, true. call
 *          GetError() for more information.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Text.GetFont
 */
inline bool SetTextFont(TextParam text, FontParam font)
{
  return TTF_SetTextFont(text, font);
}

inline bool Text::SetFont(FontParam font)
{
  return SDL::SetTextFont(m_resource, font);
}

/**
 * Get the font used by a text object.
 *
 * @param text the Text to query.
 * @returns the Font used by the text on success.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Text.SetFont
 */
inline FontRef GetTextFont(TextParam text)
{
  return {CheckError(TTF_GetTextFont(text))};
}

inline FontRef Text::GetFont() const { return SDL::GetTextFont(m_resource); }

/**
 * Set the direction to be used for text shaping a text object.
 *
 * This function only supports left-to-right text shaping if SDL_ttf was not
 * built with HarfBuzz support.
 *
 * @param text the text to modify.
 * @param direction the new direction for text to flow.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline void SetTextDirection(TextParam text, Direction direction)
{
  CheckError(TTF_SetTextDirection(text, direction));
}

inline void Text::SetDirection(Direction direction)
{
  SDL::SetTextDirection(m_resource, direction);
}

/**
 * Get the direction to be used for text shaping a text object.
 *
 * This defaults to the direction of the font used by the text object.
 *
 * @param text the text to query.
 * @returns the direction to be used for text shaping.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline Direction GetTextDirection(TextParam text)
{
  return TTF_GetTextDirection(text);
}

inline Direction Text::GetDirection() const
{
  return SDL::GetTextDirection(m_resource);
}

/**
 * Set the script to be used for text shaping a text object.
 *
 * This returns false if SDL_ttf isn't built with HarfBuzz support.
 *
 * @param text the text to modify.
 * @param script an
 *               [ISO 15924
 * code](https://unicode.org/iso15924/iso15924-codes.html)
 *               .
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa StringToTag
 */
inline void SetTextScript(TextParam text, Uint32 script)
{
  CheckError(TTF_SetTextScript(text, script));
}

inline void Text::SetScript(Uint32 script)
{
  SDL::SetTextScript(m_resource, script);
}

/**
 * Get the script used for text shaping a text object.
 *
 * This defaults to the script of the font used by the text object.
 *
 * @param text the text to query.
 * @returns an
 *          [ISO 15924 code](https://unicode.org/iso15924/iso15924-codes.html)
 *          or 0 if a script hasn't been set on either the text object or the
 *          font.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa TagToString
 */
inline Uint32 GetTextScript(TextParam text) { return TTF_GetTextScript(text); }

inline Uint32 Text::GetScript() const { return SDL::GetTextScript(m_resource); }

/**
 * Set the color of a text object.
 *
 * The default text color is white (255, 255, 255, 255).
 *
 * @param text the Text to modify.
 * @param r the red color value in the range of 0-255.
 * @param g the green color value in the range of 0-255.
 * @param b the blue color value in the range of 0-255.
 * @param a the alpha value in the range of 0-255.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Text.GetColor
 * @sa Text.SetColorFloat
 */
inline void SetTextColor(TextParam text, Color c)
{
  CheckError(TTF_SetTextColor(text, c.r, c.g, c.b, c.a));
}

inline void Text::SetColor(Color c) { SDL::SetTextColor(m_resource, c); }

/**
 * Set the color of a text object.
 *
 * The default text color is white (1.0f, 1.0f, 1.0f, 1.0f).
 *
 * @param text the Text to modify.
 * @param r the red color value, normally in the range of 0-1.
 * @param g the green color value, normally in the range of 0-1.
 * @param b the blue color value, normally in the range of 0-1.
 * @param a the alpha value in the range of 0-1.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Text.GetColorFloat
 * @sa Text.SetColor
 */
inline void SetTextColorFloat(TextParam text, FColor c)
{
  CheckError(TTF_SetTextColorFloat(text, c.r, c.g, c.b, c.a));
}

inline void Text::SetColorFloat(FColor c)
{
  SDL::SetTextColorFloat(m_resource, c);
}

/**
 * Get the color of a text object.
 *
 * @param text the Text to query.
 * @param r a pointer filled in with the red color value in the range of
 *          0-255, may be nullptr.
 * @param g a pointer filled in with the green color value in the range of
 *          0-255, may be nullptr.
 * @param b a pointer filled in with the blue color value in the range of
 *          0-255, may be nullptr.
 * @param a a pointer filled in with the alpha value in the range of 0-255,
 *          may be nullptr.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Text.GetColorFloat
 * @sa Text.SetColor
 */
inline void GetTextColor(TextParam text, Uint8* r, Uint8* g, Uint8* b, Uint8* a)
{
  CheckError(TTF_GetTextColor(text, r, g, b, a));
}

/**
 * Get the color of a text object.
 *
 * @param text the Text to query.
 * @return The color in the range of 0-255 on success.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Text.GetColorFloat
 * @sa Text.SetColor
 */
inline Color GetTextColor(TextParam text)
{
  Color c;
  GetTextColor(text, &c.r, &c.g, &c.b, &c.a);
  return c;
}

inline void Text::GetColor(Uint8* r, Uint8* g, Uint8* b, Uint8* a) const
{
  SDL::GetTextColor(m_resource, r, g, b, a);
}

inline Color Text::GetColor() const { return SDL::GetTextColor(m_resource); }

/**
 * Get the color of a text object.
 *
 * @param text the Text to query.
 * @param r a pointer filled in with the red color value, normally in the
 *          range of 0-1, may be nullptr.
 * @param g a pointer filled in with the green color value, normally in the
 *          range of 0-1, may be nullptr.
 * @param b a pointer filled in with the blue color value, normally in the
 *          range of 0-1, may be nullptr.
 * @param a a pointer filled in with the alpha value in the range of 0-1, may
 *          be nullptr.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Text.GetColor
 * @sa Text.SetColorFloat
 */
inline void GetTextColorFloat(TextParam text,
                              float* r,
                              float* g,
                              float* b,
                              float* a)
{
  CheckError(TTF_GetTextColorFloat(text, r, g, b, a));
}

/**
 * Get the color of a text object.
 *
 * @param text the Text to query.
 * @return The color in the range of 0-1 on success.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Text.GetColor
 * @sa Text.SetColorFloat
 */
inline FColor GetTextColorFloat(TextParam text)
{
  FColor c;
  GetTextColorFloat(text, &c.r, &c.g, &c.b, &c.a);
  return c;
}

inline void Text::GetColorFloat(float* r, float* g, float* b, float* a) const
{
  SDL::GetTextColorFloat(m_resource, r, g, b, a);
}

inline FColor Text::GetColorFloat() const
{
  return SDL::GetTextColorFloat(m_resource);
}

/**
 * Set the position of a text object.
 *
 * This can be used to position multiple text objects within a single wrapping
 * text area.
 *
 * This function may cause the internal text representation to be rebuilt.
 *
 * @param text the Text to modify.
 * @param p the x, y offset of the upper left corner of this text in pixels.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Text.GetPosition
 */
inline bool SetTextPosition(TextParam text, Point p)
{
  return TTF_SetTextPosition(text, p.x, p.y);
}

inline bool Text::SetPosition(Point p)
{
  return SDL::SetTextPosition(m_resource, p);
}

/**
 * Get the position of a text object.
 *
 * @param text the Text to query.
 * @param x a pointer filled in with the x offset of the upper left corner of
 *          this text in pixels, may be nullptr.
 * @param y a pointer filled in with the y offset of the upper left corner of
 *          this text in pixels, may be nullptr.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Text.SetPosition
 */
inline bool GetTextPosition(TextParam text, int* x, int* y)
{
  return TTF_GetTextPosition(text, x, y);
}

/**
 * Get the position of a text object.
 *
 * @param text the Text to query.
 * @returns a Point with the offset of the upper left corner of this text in
 *          pixels on success.
 * @throws Error on failure.
 *
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Text.SetPosition
 */
inline Point GetTextPosition(TextParam text)
{
  Point p;
  CheckError(GetTextPosition(text, &p.x, &p.y));
  return p;
}

inline bool Text::GetPosition(int* x, int* y) const
{
  return SDL::GetTextPosition(m_resource, x, y);
}

inline Point Text::GetPosition() const
{
  return SDL::GetTextPosition(m_resource);
}

/**
 * Set whether wrapping is enabled on a text object.
 *
 * This function may cause the internal text representation to be rebuilt.
 *
 * @param text the Text to modify.
 * @param wrap_width the maximum width in pixels, 0 to wrap on newline
 *                   characters.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Text.GetWrapWidth
 */
inline void SetTextWrapWidth(TextParam text, int wrap_width)
{
  CheckError(TTF_SetTextWrapWidth(text, wrap_width));
}

inline void Text::SetWrapWidth(int wrap_width)
{
  SDL::SetTextWrapWidth(m_resource, wrap_width);
}

/**
 * Get whether wrapping is enabled on a text object.
 *
 * @param text the Text to query.
 * @param wrap_width a pointer filled in with the maximum width in pixels or 0
 *                   if the text is being wrapped on newline characters.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Text.SetWrapWidth
 */
inline int GetTextWrapWidth(TextParam text)
{
  int w;
  CheckError(TTF_GetTextWrapWidth(text, &w));
  return w;
}

inline int Text::GetWrapWidth() const
{
  return SDL::GetTextWrapWidth(m_resource);
}

/**
 * Set whether whitespace should be visible when wrapping a text object.
 *
 * If the whitespace is visible, it will take up space for purposes of
 * alignment and wrapping. This is good for editing, but looks better when
 * centered or aligned if whitespace around line wrapping is hidden. This
 * defaults false.
 *
 * This function may cause the internal text representation to be rebuilt.
 *
 * @param text the Text to modify.
 * @param visible true to show whitespace when wrapping text, false to hide
 *                it.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Text.IsWrapWhitespaceVisible
 */
inline void SetTextWrapWhitespaceVisible(TextParam text, bool visible)
{
  CheckError(TTF_SetTextWrapWhitespaceVisible(text, visible));
}

inline void Text::SetWrapWhitespaceVisible(bool visible)
{
  SDL::SetTextWrapWhitespaceVisible(m_resource, visible);
}

/**
 * Return whether whitespace is shown when wrapping a text object.
 *
 * @param text the Text to query.
 * @returns true if whitespace is shown when wrapping text, or false
 *          otherwise.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Text.SetWrapWhitespaceVisible
 */
inline bool TextWrapWhitespaceVisible(TextParam text)
{
  return TTF_TextWrapWhitespaceVisible(text);
}

inline bool Text::IsWrapWhitespaceVisible() const
{
  return SDL::TextWrapWhitespaceVisible(m_resource);
}

/**
 * Set the UTF-8 text used by a text object.
 *
 * This function may cause the internal text representation to be rebuilt.
 *
 * @param text the Text to modify.
 * @param string the UTF-8 text to use, may be nullptr.
 * @param length the length of the text, in bytes, or 0 for null terminated
 *               text.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Text.AppendString
 * @sa Text.DeleteString
 * @sa Text.InsertString
 */
inline void SetTextString(TextParam text, std::string_view string)
{
  CheckError(TTF_SetTextString(text, string.data(), string.size()));
}

inline void Text::SetString(std::string_view string)
{
  SDL::SetTextString(m_resource, string);
}

/**
 * Insert UTF-8 text into a text object.
 *
 * This function may cause the internal text representation to be rebuilt.
 *
 * @param text the Text to modify.
 * @param offset the offset, in bytes, from the beginning of the string if >=
 *               0, the offset from the end of the string if < 0. Note that
 *               this does not do UTF-8 validation, so you should only insert
 *               at UTF-8 sequence boundaries.
 * @param string the UTF-8 text to insert.
 * @param length the length of the text, in bytes, or 0 for null terminated
 *               text.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Text.AppendString
 * @sa Text.DeleteString
 * @sa Text.SetString
 */
inline void InsertTextString(TextParam text,
                             int offset,
                             std::string_view string)
{
  CheckError(TTF_InsertTextString(text, offset, string.data(), string.size()));
}

inline void Text::InsertString(int offset, std::string_view string)
{
  SDL::InsertTextString(m_resource, offset, string);
}

/**
 * Append UTF-8 text to a text object.
 *
 * This function may cause the internal text representation to be rebuilt.
 *
 * @param text the Text to modify.
 * @param string the UTF-8 text to insert.
 * @param length the length of the text, in bytes, or 0 for null terminated
 *               text.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Text.DeleteString
 * @sa Text.InsertString
 * @sa Text.SetString
 */
inline void AppendTextString(TextParam text, std::string_view string)
{
  CheckError(TTF_AppendTextString(text, string.data(), string.size()));
}

inline void Text::AppendString(std::string_view string)
{
  SDL::AppendTextString(m_resource, string);
}

/**
 * Delete UTF-8 text from a text object.
 *
 * This function may cause the internal text representation to be rebuilt.
 *
 * @param text the Text to modify.
 * @param offset the offset, in bytes, from the beginning of the string if >=
 *               0, the offset from the end of the string if < 0. Note that
 *               this does not do UTF-8 validation, so you should only delete
 *               at UTF-8 sequence boundaries.
 * @param length the length of text to delete, in bytes, or -1 for the
 *               remainder of the string.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Text.AppendString
 * @sa Text.InsertString
 * @sa Text.SetString
 */
inline void DeleteTextString(TextParam text, int offset, int length)
{
  CheckError(TTF_DeleteTextString(text, offset, length));
}

inline void Text::DeleteString(int offset, int length)
{
  SDL::DeleteTextString(m_resource, offset, length);
}

/**
 * Get the size of a text object.
 *
 * The size of the text may change when the font or font style and size
 * change.
 *
 * @param text the Text to query.
 * @param w a pointer filled in with the width of the text, in pixels, may be
 *          nullptr.
 * @param h a pointer filled in with the height of the text, in pixels, may be
 *          nullptr.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline void GetTextSize(TextParam text, int* w, int* h)
{
  CheckError(TTF_GetTextSize(text, w, h));
}

/**
 * Get the size of a text object.
 *
 * The size of the text may change when the font or font style and size
 * change.
 *
 * @param text the Text to query.
 * @returns Point containing the size on x and y axis on success or
 *          std::nullopt on failure; call GetError() for more information.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline Point GetTextSize(TextParam text)
{
  Point p;
  GetTextSize(text, &p.x, &p.y);
  return p;
}

inline void Text::GetSize(int* w, int* h) const
{
  SDL::GetTextSize(m_resource, w, h);
}

inline Point Text::GetSize() const { return SDL::GetTextSize(m_resource); }

/**
 * Get the substring of a text object that surrounds a text offset.
 *
 * If `offset` is less than 0, this will return a zero length substring at the
 * beginning of the text with the SUBSTRING_TEXT_START flag set. If
 * `offset` is greater than or equal to the length of the text string, this
 * will return a zero length substring at the end of the text with the
 * SUBSTRING_TEXT_END flag set.
 *
 * @param text the Text to query.
 * @param offset a byte offset into the text string.
 * @param substring a pointer filled in with the substring containing the
 *                  offset.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline void GetTextSubString(TextParam text, int offset, SubString* substring)
{
  CheckError(TTF_GetTextSubString(text, offset, substring));
}

inline void Text::GetSubString(int offset, SubString* substring) const
{
  SDL::GetTextSubString(m_resource, offset, substring);
}

/**
 * Get the substring of a text object that contains the given line.
 *
 * If `line` is less than 0, this will return a zero length substring at the
 * beginning of the text with the SUBSTRING_TEXT_START flag set. If `line`
 * is greater than or equal to `text->num_lines` this will return a zero
 * length substring at the end of the text with the SUBSTRING_TEXT_END
 * flag set.
 *
 * @param text the Text to query.
 * @param line a zero-based line index, in the range [0 .. text->num_lines-1].
 * @param substring a pointer filled in with the substring containing the
 *                  offset.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline void GetTextSubStringForLine(TextParam text,
                                    int line,
                                    SubString* substring)
{
  CheckError(TTF_GetTextSubStringForLine(text, line, substring));
}

inline void Text::GetSubStringForLine(int line, SubString* substring) const
{
  SDL::GetTextSubStringForLine(m_resource, line, substring);
}

/**
 * Get the substrings of a text object that contain a range of text.
 *
 * @param text the Text to query.
 * @param offset a byte offset into the text string.
 * @param length the length of the range being queried, in bytes, or -1 for
 *               the remainder of the string.
 * @returns a nullptr terminated array of substring pointers or nullptr on
 * failure; call GetError() for more information. This is a single allocation
 * that should be freed with free() when it is no longer needed.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline OwnArray<SubString*> GetTextSubStringsForRange(TextParam text,
                                                      int offset,
                                                      int length)
{
  int count = 0;
  auto data = TTF_GetTextSubStringsForRange(text, offset, length, &count);
  return OwnArray<SubString*>{data, size_t(count)};
}

inline OwnArray<SubString*> Text::GetSubStringsForRange(int offset,
                                                        int length) const
{
  return SDL::GetTextSubStringsForRange(m_resource, offset, length);
}

/**
 * Get the portion of a text string that is closest to a point.
 *
 * This will return the closest substring of text to the given point.
 *
 * @param text the Text to query.
 * @param p the coordinates relative to the top-left side of the text, may be
 *          outside the bounds of the text area.
 * @param substring a pointer filled in with the closest substring of text to
 *                  the given point.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline void GetTextSubStringForPoint(TextParam text,
                                     Point p,
                                     SubString* substring)
{
  CheckError(TTF_GetTextSubStringForPoint(text, p.x, p.y, substring));
}

inline void Text::GetSubStringForPoint(Point p, SubString* substring) const
{
  SDL::GetTextSubStringForPoint(m_resource, p, substring);
}

/**
 * Get the previous substring in a text object
 *
 * If called at the start of the text, this will return a zero length
 * substring with the SUBSTRING_TEXT_START flag set.
 *
 * @param text the Text to query.
 * @param substring the SubString to query.
 * @param previous a pointer filled in with the previous substring in the text
 *                 object.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline void GetPreviousTextSubString(TextParam text,
                                     const SubString& substring,
                                     SubString* previous)
{
  CheckError(TTF_GetPreviousTextSubString(text, &substring, previous));
}

inline void Text::GetPreviousSubString(const SubString& substring,
                                       SubString* previous) const
{
  SDL::GetPreviousTextSubString(m_resource, substring, previous);
}

/**
 * Get the next substring in a text object
 *
 * If called at the end of the text, this will return a zero length substring
 * with the SUBSTRING_TEXT_END flag set.
 *
 * @param text the Text to query.
 * @param substring the SubString to query.
 * @param next a pointer filled in with the next substring.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline void GetNextTextSubString(TextParam text,
                                 const SubString& substring,
                                 SubString* next)
{
  CheckError(TTF_GetNextTextSubString(text, &substring, next));
}

inline void Text::GetNextSubString(const SubString& substring,
                                   SubString* next) const
{
  SDL::GetNextTextSubString(m_resource, substring, next);
}

/**
 * Update the layout of a text object.
 *
 * This is automatically done when the layout is requested or the text is
 * rendered, but you can call this if you need more control over the timing of
 * when the layout and text engine representation are updated.
 *
 * @param text the Text to update.
 * @throws Error on failure.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 */
inline void UpdateText(TextParam text) { CheckError(TTF_UpdateText(text)); }

inline void Text::Update() { SDL::UpdateText(m_resource); }

/**
 * Destroy a text object created by a text engine.
 *
 * @param text the text to destroy.
 *
 * @threadsafety This function should be called on the thread that created the
 *               text.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa RendererTextEngine.RendererTextEngine
 */
inline void DestroyText(TextRaw text) { TTF_DestroyText(text); }

inline void Text::Destroy()
{
  TTF_DestroyText(m_resource);
  m_resource = nullptr;
}

/**
 * Dispose of a previously-created font.
 *
 * Call this when done with a font. This function will free any resources
 * associated with it. It is safe to call this function on nullptr, for example
 * on the result of a failed call to Font.Font().
 *
 * The font is not valid after being passed to this function. String pointers
 * from functions that return information on this font, such as
 * Font.GetFamilyName() and Font.GetStyleName(), are no longer valid
 * after this call, as well.
 *
 * @param font the font to dispose of.
 *
 * @threadsafety This function should not be called while any other thread is
 *               using the font.
 *
 * @since This function is available since SDL_ttf 3.0.0.
 *
 * @sa Font.Font
 * @sa Font.Font
 */
inline void CloseFont(FontRaw font) { TTF_CloseFont(font); }

inline void Font::Close()
{
  TTF_CloseFont(m_resource);
  m_resource = nullptr;
}

/// @}

} // namespace SDL

#endif // defined(SDL3PP_ENABLE_TTF) || defined(SDL3PP_DOC)

#endif // SDL3PP_H_
