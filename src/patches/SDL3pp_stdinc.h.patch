16c16
<  * @defgroup CategoryStdinc Category Stdinc
---
>  * @defgroup CategoryStdinc Standard Library Functionality
72c72
< using IConvRaw = SDL_iconv_t*;
---
> using IConvRaw = SDL_iconv_t;
96a97,98
> #ifdef SDL3PP_DOC
> 
130a133,134
> #endif // SDL3PP_DOC
> 
137,141c141
<  * This macro looks like it double-evaluates the argument, but it does so
<  * inside of `sizeof`, so there are no side-effects here, as expressions do
<  * not actually run any code in these cases.
<  *
<  * @since This macro is available since SDL 3.2.0.
---
>  * @since This function is available since SDL 3.2.0.
146c146
<   return SDL_arraysize((&array)[N]);
---
>   return SDL_arraysize(array);
148a149,150
> #ifdef SDL3PP_DOC
> 
164a167,168
> #endif // SDL3PP_DOC
> 
168,171c172,175
<  * @param A the first ASCII character.
<  * @param B the second ASCII character.
<  * @param C the third ASCII character.
<  * @param D the fourth ASCII character.
---
>  * @param a the first ASCII character.
>  * @param b the second ASCII character.
>  * @param c the third ASCII character.
>  * @param d the fourth ASCII character.
177c181
<  * @since This macro is available since SDL 3.2.0.
---
>  * @since This function is available since SDL 3.2.0.
183a188,189
> #ifdef SDL3PP_DOC
> 
216a223,224
> #endif // SDL3PP_DOC
> 
220a229,230
> #ifdef SDL3PP_DOC
> 
227a238,239
> #endif // SDL3PP_DOC
> 
231a244,245
> #ifdef SDL3PP_DOC
> 
238a253,254
> #endif // SDL3PP_DOC
> 
242a259,260
> #ifdef SDL3PP_DOC
> 
249a268,269
> #endif // SDL3PP_DOC
> 
253a274,275
> #ifdef SDL3PP_DOC
> 
260a283,284
> #endif // SDL3PP_DOC
> 
264a289,290
> #ifdef SDL3PP_DOC
> 
271a298,299
> #endif // SDL3PP_DOC
> 
275a304,305
> #ifdef SDL3PP_DOC
> 
284a315,316
> #endif // SDL3PP_DOC
> 
288a321,322
> #ifdef SDL3PP_DOC
> 
297a332,333
> #endif // SDL3PP_DOC
> 
315,318c351
< constexpr float ToSeconds(Seconds duration)
< {
<   static_assert(false, "Not implemented");
< }
---
> constexpr float ToSeconds(Seconds duration) { return duration.count(); }
323,326c356
< constexpr Seconds FromSeconds(float duration)
< {
<   static_assert(false, "Not implemented");
< }
---
> constexpr Seconds FromSeconds(float duration) { return Seconds(duration); }
329c359
<  * Converts a time duration to seconds (float).
---
>  * Converts a time duration to nanoseconds (Sint64);
333c363
<   static_assert(false, "Not implemented");
---
>   return duration.count();
337c367
<  * Converts a float to seconds representation.
---
>  * Converts a Sint64 to nanoseconds representation.
339,342c369
< constexpr Nanoseconds FromNS(Sint64 duration)
< {
<   static_assert(false, "Not implemented");
< }
---
> constexpr Nanoseconds FromNS(Sint64 duration) { return Nanoseconds{duration}; }
352c379
<  * @since This macro is available since SDL 3.2.0.
---
>  * @since This type is available since SDL 3.2.0.
357c384
< struct Time
---
> class Time
361,363c388,389
<   constexpr Time() {}
< 
<   constexpr Time(std::chrono::nanoseconds time) {}
---
> public:
>   constexpr Time() = default;
365c391,395
<   constexpr explicit Time(SDL_Time time) {}
---
>   /// Constructs from a nanoseconds period.
>   constexpr Time(std::chrono::nanoseconds time)
>     : m_value(time)
>   {
>   }
367c397,399
<   constexpr explicit operator bool() const
---
>   /// Constructs from SDL_Time
>   constexpr explicit Time(SDL_Time time)
>     : m_value(FromNS(time))
369d400
<     static_assert(false, "Not implemented");
372c403,404
<   constexpr operator std::chrono::nanoseconds() const
---
>   /// True if not zero
>   constexpr explicit operator bool() const
374c406
<     static_assert(false, "Not implemented");
---
>     return m_value != std::chrono::nanoseconds{};
377c409,412
< #error "Current (undefined)"
---
>   /// Converts to nanoseconds period
>   constexpr operator std::chrono::nanoseconds() const { return m_value; }
> 
>   static Time Current();
378a414
>   /// Create from a nanoseconds Sint64.
381c417
<     static_assert(false, "Not implemented");
---
>     return Time{std::chrono::nanoseconds{time}};
384c420,421
<   constexpr Sint64 ToNS() const { static_assert(false, "Not implemented"); }
---
>   /// Converts to nanoseconds Sint64
>   constexpr Sint64 ToNS() const { return m_value.count(); }
390c427
< #error "FromWindows (undefined)"
---
>   static Time FromWindows(Uint32 dwLowDateTime, Uint32 dwHighDateTime);
392c429
< #error "ToWindows (undefined)"
---
>   void ToWindows(Uint32* dwLowDateTime, Uint32* dwHighDateTime) const;
397c434
<   constexpr float ToSeconds() const { static_assert(false, "Not implemented"); }
---
>   constexpr float ToSeconds() const { return Seconds(m_value).count(); }
402c439
<   static constexpr Time Time.FromSeconds(float interval)
---
>   static constexpr Time FromSeconds(float interval)
404c441,442
<     static_assert(false, "Not implemented");
---
>     return std::chrono::duration_cast<std::chrono::nanoseconds>(
>       Seconds(interval));
406a445
>   /// Increment time
409c448,449
<     static_assert(false, "Not implemented");
---
>     m_value += interval;
>     return *this;
411a452
>   /// Decrement
414c455,456
<     static_assert(false, "Not implemented");
---
>     m_value -= interval;
>     return *this;
418c460,462
< constexpr Time MAX_TIME = SDL_MAX_TIME;
---
> constexpr Time MAX_TIME = Time::FromNS(SDL_MAX_TIME);
> 
> constexpr Time MIN_TIME = Time::FromNS(SDL_MIN_TIME);
420c464
< constexpr Time MIN_TIME = SDL_MIN_TIME;
---
> #ifdef SDL3PP_DOC
440c484
<  * ```c
---
>  * ```cpp
454c498
<  * ```c
---
>  * ```cpp
475a520,521
> #endif // SDL3PP_DOC
> 
817a864,865
>  * @cat resource
>  *
825,826d872
<  *
<  * @cat resource
940,942c986,989
<    *          the form "variable=value" or nullptr on failure; call GetError()
<    *          for more information. This is a single allocation that should be
<    *          freed with free() when it is no longer needed.
---
>    *          the form "variable=value" on success. This is wrapped to be
>    *          auto-deleted, use FreeWrapper.release() if you want to manage
>    *          manually.
>    * @throws Error on failure
956c1003
<     return SDL_GetEnvironmentVariables(m_resource);
---
>     return OwnArray<char*>{CheckError(SDL_GetEnvironmentVariables(m_resource))};
959c1006,1018
<   Uint64 GetVariableCount() { static_assert(false, "Not implemented"); }
---
>   /**
>    * Get the Variables count.
>    *
>    * @return the number of existing environment variables
>    *
>    * This might be slow.
>    */
>   Uint64 GetVariableCount()
>   {
>     Uint64 count = 0;
>     for (auto& var : GetVariables()) count += 1;
>     return count;
>   }
1139c1198
<   return SDL_GetEnvironmentVariables(env);
---
>   return OwnArray<char*>{CheckError(SDL_GetEnvironmentVariables(env))};
1168c1227
<   CheckError(SDL_SetEnvironmentVariable(env, name, value, overwrite));
---
>   return CheckError(SDL_SetEnvironmentVariable(env, name, value, overwrite));
1191c1250
<   CheckError(SDL_UnsetEnvironmentVariable(env, name));
---
>   return CheckError(SDL_UnsetEnvironmentVariable(env, name));
1255,1256c1314
<  * @returns 0 on success.
<  * @throws Error on failure.
---
>  * @returns 0 on success, -1 on error.
1267c1325
<   return CheckError(SDL_setenv_unsafe(name, value, overwrite));
---
>   return SDL_setenv_unsafe(name, value, overwrite);
1274,1275c1332
<  * @returns 0 on success.
<  * @throws Error on failure.
---
>  * @returns 0 on success, -1 on error.
1286c1343
<   return CheckError(SDL_unsetenv_unsafe(name));
---
>   return SDL_unsetenv_unsafe(name);
1435d1491
<  * @param userdata the `userdata` pointer passed to the sort function.
1554d1609
<  * @param userdata a pointer to pass to the compare function.
1565c1620,1628
<   static_assert(false, "Not implemented");
---
>   return qsort_r(
>     base,
>     nmemb,
>     size,
>     [](void* userdata, const void* a, const void* b) {
>       auto& cb = *static_cast<CompareCB*>(userdata);
>       return cb(a, b);
>     },
>     &compare);
1681d1743
<  * @param userdata a pointer to pass to the compare function.
1698c1760,1769
<   static_assert(false, "Not implemented");
---
>   return bsearch_r(
>     key,
>     base,
>     nmemb,
>     size,
>     [](void* userdata, const void* a, const void* b) {
>       auto& cb = *static_cast<CompareCB*>(userdata);
>       return cb(a, b);
>     },
>     &compare);
1767c1838
<  * @threadsafety It is safe to call this macro from any thread.
---
>  * @threadsafety It is safe to call this function from any thread.
1769c1840
<  * @since This macro is available since SDL 3.2.0.
---
>  * @since This function is available since SDL 3.2.0.
1780c1851
<  * This is a helper macro that might be more clear than writing out the
---
>  * This is a helper function that might be more clear than writing out the
1789c1860
<  * @threadsafety It is safe to call this macro from any thread.
---
>  * @threadsafety It is safe to call this function from any thread.
1791c1862
<  * @since This macro is available since SDL 3.2.0.
---
>  * @since This function is available since SDL 3.2.0.
1805c1876
<  * This macro will produce incorrect results if `b` is less than `a`.
---
>  * This function will produce incorrect results if `b` is less than `a`.
1807c1878
<  * This is a helper macro that might be more clear than writing out the
---
>  * This is a helper function that might be more clear than writing out the
1817c1888
<  * @threadsafety It is safe to call this macro from any thread.
---
>  * @threadsafety It is safe to call this function from any thread.
1819c1890
<  * @since This macro is available since SDL 3.2.0.
---
>  * @since This function is available since SDL 3.2.0.
2159a2231
> #ifdef SDL_SLOW_MEMCPY
2160a2233,2235
> #else
>   return ::memcpy(dst, src, len);
> #endif // SDL_SLOW_MEMCPY
2162a2238,2239
> #ifdef SDL3PP_DOC
> 
2192a2270,2271
> #endif // SDL3PP_DOC
> 
2211a2291
> #ifdef SDL_SLOW_MEMMOVE
2212a2293,2295
> #else
>   return ::memmove(dst, src, len);
> #endif // SDL_SLOW_MEMMOVE
2234a2318
> #ifdef SDL_SLOW_MEMSET
2235a2320,2322
> #else
>   return ::memset(dst, c, len);
> #endif // SDL_SLOW_MEMSET
2317c2404
<  * @threadsafety It is safe to call this macro from any thread.
---
>  * @threadsafety It is safe to call this function from any thread.
2319c2406
<  * @since This macro is available since SDL 3.2.0.
---
>  * @since This function is available since SDL 3.2.0.
2327c2414
<   SDL_zeroa((&x)[N]);
---
>   SDL_zeroa(x);
3744c3831,3836
<   return SDL_sscanf(text, fmt, ...);
---
>   int rc;
>   va_list ap;
>   va_start(ap, fmt);
>   rc = SDL_vsscanf(text, fmt, ap);
>   va_end(ap);
>   return rc;
3807c3899,3906
<   return SDL_snprintf(text, maxlen, fmt, ...);
---
>   va_list ap;
>   int result;
> 
>   va_start(ap, fmt);
>   result = SDL_vsnprintf(text, maxlen, fmt, ap);
>   va_end(ap);
> 
>   return result;
3847c3946,3953
<   return SDL_swprintf(text, maxlen, fmt, ...);
---
>   va_list ap;
>   int result;
> 
>   va_start(ap, fmt);
>   result = SDL_vswprintf(text, maxlen, fmt, ap);
>   va_end(ap);
> 
>   return result;
3932c4038,4045
<   return SDL_asprintf(strp, fmt, ...);
---
>   va_list ap;
>   int result;
> 
>   va_start(ap, fmt);
>   result = SDL_vasprintf(strp, fmt, ap);
>   va_end(ap);
> 
>   return result;
4039c4152
<  * You likely want to use rand() to get a psuedo-random number instead.
---
>  * You likely want to use rand() to get a pseudo-random number instead.
4059c4172,4182
< struct Random
---
> /**
>  * A independent pseudo random state
>  *
>  * This can be instantiated in any thread and as long as it is not shared with
>  * another thread all members are safe to call.
>  *
>  * @cat wrap-state
>  *
>  * @sa wrap-state
>  */
> class Random
4063c4186,4190
<   constexpr Random() {}
---
> public:
>   constexpr Random()
>     : m_state(0)
>   {
>   }
4065c4192,4198
<   constexpr explicit Random(Uint64 state) {}
---
>   /**
>    * Init state with the given value
>    */
>   constexpr explicit Random(Uint64 state)
>     : m_state(state)
>   {
>   }
4067c4200,4201
<   constexpr operator Uint64() { static_assert(false, "Not implemented"); }
---
>   /// Convert to the underlying type
>   constexpr operator Uint64() { return m_state; }
4076c4210
<    * Example: to simulate a d6 use `Random.rand(state, 6) + 1` The +1 converts
---
>    * Example: to simulate a d6 use `state.rand(6) + 1` The +1 converts
4080c4214
<    * you should use: (Sint32)Random.rand_bits(state)
---
>    * you should use: (Sint32)state.rand_bits()
4088,4089d4221
<    * @param state a pointer to the current random number state, this may not be
<    *              nullptr.
4093c4225
<    * @threadsafety This function is thread-safe, as long as the state pointer
---
>    * @threadsafety This function is thread-safe, as long as this object
4102c4234
<   Sint32 rand(Sint32 n) { return SDL_rand_r(n); }
---
>   Sint32 rand(Sint32 n) { return SDL_rand_r(&m_state, n); }
4116,4117d4247
<    * @param state a pointer to the current random number state, this may not be
<    *              nullptr.
4120c4250
<    * @threadsafety This function is thread-safe, as long as the state pointer
---
>    * @threadsafety This function is thread-safe, as long as this object
4129c4259
<   float randf() { return SDL_randf_r(); }
---
>   float randf() { return SDL_randf_r(&m_state); }
4134c4264
<    * You likely want to use Random.rand() to get a psuedo-random number instead.
---
>    * You likely want to use Random.rand() to get a pseudo-random number instead.
4142,4143d4271
<    * @param state a pointer to the current random number state, this may not be
<    *              nullptr.
4146c4274
<    * @threadsafety This function is thread-safe, as long as the state pointer
---
>    * @threadsafety This function is thread-safe, as long as this object
4154c4282
<   Uint32 rand_bits() { return SDL_rand_bits_r(); }
---
>   Uint32 rand_bits() { return SDL_rand_bits_r(&m_state); }
4476d4603
<  * @sa atan2
5538,5539d5664
<  * @sa IConv.open
<  *
5540a5666,5668
>  *
>  * @sa IConv.open
>  * @sa IConv
5587c5715,5716
<   static IConv open(StringParam tocode, StringParam fromcode)
---
>   IConv(StringParam tocode, StringParam fromcode)
>     : m_resource(SDL_iconv_open(tocode, fromcode))
5589d5717
<     return IConv(SDL_iconv_open(tocode, fromcode));
5644d5771
<    *           IConv.open().
5680c5807
<   static void close(SDL_iconv_t cd)
---
>   void close()
5779c5906
< inline size_t iconv(IConv cd,
---
> inline size_t iconv(IConvRaw cd,
5787a5915,5916
> #ifdef SDL3PP_DOC
> 
5791c5920
< #define SDL_ICONV_ERROR (size_t) - 1
---
> #define SDL_ICONV_ERROR (size_t)-1
5796c5925
< #define SDL_ICONV_E2BIG (size_t) - 2
---
> #define SDL_ICONV_E2BIG (size_t)-2
5801c5930
< #define SDL_ICONV_EILSEQ (size_t) - 3
---
> #define SDL_ICONV_EILSEQ (size_t)-3
5806c5935,5937
< #define SDL_ICONV_EINVAL (size_t) - 4
---
> #define SDL_ICONV_EINVAL (size_t)-4
> 
> #endif // SDL3PP_DOC
5817,5819d5947
<  * The returned string is owned by the caller, and should be passed to
<  * free when no longer needed.
<  *
5838c5966
<   return SDL_iconv_string(tocode, fromcode, inbuf, inbytesleft);
---
>   return OwnPtr<char>{SDL_iconv_string(tocode, fromcode, inbuf, inbytesleft)};
5840a5969,5970
> #ifdef SDL3PP_DOC
> 
5901a6032,6033
> #endif // SDL3PP_DOC
> 
5963a6096,6097
> 
> inline void PtrDeleter::operator()(void* ptr) const { SDL_free(ptr); }
