--- src/generated/SDL3pp_stdinc.h
+++ include/SDL3pp/SDL3pp_stdinc.h
@@ -13,7 +13,7 @@
 namespace SDL {
 
 /**
- * @defgroup CategoryStdinc Category Stdinc
+ * @defgroup CategoryStdinc Standard Library Functionality
  *
  * SDL provides its own implementation of some of the most important C runtime
  * functions.
@@ -83,7 +83,7 @@
 struct IConv;
 
 /// Alias to raw representation for IConv.
-using IConvRaw = SDL_iconv_t*;
+using IConvRaw = SDL_iconv_t;
 
 // Forward decl
 struct IConvRef;
@@ -115,6 +115,8 @@
   constexpr operator IConvRaw() const { return value; }
 };
 
+#ifdef SDL3PP_DOC
+
 /**
  * Don't let SDL use "long long" C types.
  *
@@ -182,24 +184,24 @@
  */
 #define SDL_COMPILE_TIME_ASSERT(name, x) FailToCompileIf_x_IsFalse(x)
 
+#endif // SDL3PP_DOC
+
 /**
  * The number of elements in a static array.
  *
  * This will compile but return incorrect results for a pointer to an array; it
  * has to be an array the compiler knows the size of.
  *
- * This macro looks like it double-evaluates the argument, but it does so inside
- * of `sizeof`, so there are no side-effects here, as expressions do not
- * actually run any code in these cases.
- *
  * @since This function is available since SDL 3.2.0.
  */
 template<class T, std::size_t N>
 constexpr std::size_t arraysize(const T (&array)[N])
 {
-  return SDL_arraysize((&array)[N]);
+  return SDL_arraysize(array);
 }
 
+#ifdef SDL3PP_DOC
+
 /**
  * Macro useful for building other macros with strings in them.
  *
@@ -216,13 +218,15 @@
  */
 #define SDL_STRINGIFY_ARG(arg) #arg
 
+#endif // SDL3PP_DOC
+
 /**
  * Define a four character code as a Uint32.
  *
- * @param A the first ASCII character.
- * @param B the second ASCII character.
- * @param C the third ASCII character.
- * @param D the fourth ASCII character.
+ * @param a the first ASCII character.
+ * @param b the second ASCII character.
+ * @param c the third ASCII character.
+ * @param d the fourth ASCII character.
  * @returns the four characters converted into a Uint32, one character per-byte.
  *
  * @threadsafety It is safe to call this function from any thread.
@@ -234,6 +238,8 @@
   return SDL_FOURCC(a, b, c, d);
 }
 
+#ifdef SDL3PP_DOC
+
 /**
  * Append the 64 bit integer suffix to a signed integer literal.
  *
@@ -260,6 +266,8 @@
  */
 #define SDL_UINT64_C(c) c##ULL /* or whatever the current compiler uses. */
 
+#endif // SDL3PP_DOC
+
 /**
  * A signed 8-bit integer type.
  *
@@ -267,8 +275,10 @@
  */
 using Sint8 = ::Sint8;
 
+/// Max representable value
 constexpr Sint8 MAX_SINT8 = SDL_MAX_SINT8;
 
+/// Min representable value
 constexpr Sint8 MIN_SINT8 = SDL_MIN_SINT8;
 
 /**
@@ -278,8 +288,10 @@
  */
 using Uint8 = ::Uint8;
 
+/// Max representable value
 constexpr Uint8 MAX_UINT8 = SDL_MAX_UINT8;
 
+/// Min representable value
 constexpr Uint8 MIN_UINT8 = SDL_MIN_UINT8;
 
 /**
@@ -289,8 +301,10 @@
  */
 using Sint16 = ::Sint16;
 
+/// Max representable value
 constexpr Sint16 MAX_SINT16 = SDL_MAX_SINT16;
 
+/// Min representable value
 constexpr Sint16 MIN_SINT16 = SDL_MIN_SINT16;
 
 /**
@@ -300,8 +314,10 @@
  */
 using Uint16 = ::Uint16;
 
+/// Max representable value
 constexpr Uint16 MAX_UINT16 = SDL_MAX_UINT16;
 
+/// Min representable value
 constexpr Uint16 MIN_UINT16 = SDL_MIN_UINT16;
 
 /**
@@ -311,8 +327,10 @@
  */
 using Sint32 = ::Sint32;
 
+/// Max representable value
 constexpr Sint32 MAX_SINT32 = SDL_MAX_SINT32;
 
+/// Min representable value
 constexpr Sint32 MIN_SINT32 = SDL_MIN_SINT32;
 
 /**
@@ -322,8 +340,10 @@
  */
 using Uint32 = ::Uint32;
 
+/// Max representable value
 constexpr Uint32 MAX_UINT32 = SDL_MAX_UINT32;
 
+/// Min representable value
 constexpr Uint8 MIN_UINT32 = SDL_MIN_UINT32;
 
 /**
@@ -335,8 +355,10 @@
  */
 using Sint64 = ::Sint64;
 
+/// Max representable value
 constexpr Sint64 MAX_SINT64 = SDL_MAX_SINT64;
 
+/// Min representable value
 constexpr Sint64 MIN_SINT64 = SDL_MIN_SINT64;
 
 /**
@@ -348,8 +370,10 @@
  */
 using Uint64 = ::Uint64;
 
+/// Max representable value
 constexpr Uint64 MAX_UINT64 = SDL_MAX_UINT64;
 
+/// Min representable value
 constexpr Uint8 MIN_UINT64 = SDL_MIN_UINT64;
 
 /// Duration in seconds (float).
@@ -362,28 +386,16 @@
 using Milliseconds = std::chrono::milliseconds;
 
 /// Converts a time duration to seconds (float).
-constexpr float ToSeconds(Seconds duration)
-{
-  static_assert(false, "Not implemented");
-}
+constexpr float ToSeconds(Seconds duration) { return duration.count(); }
 
 /// Converts a float to seconds representation.
-constexpr Seconds FromSeconds(float duration)
-{
-  static_assert(false, "Not implemented");
-}
+constexpr Seconds FromSeconds(float duration) { return Seconds(duration); }
 
-/// Converts a time duration to seconds (float).
-constexpr Sint64 ToNS(std::chrono::nanoseconds duration)
-{
-  static_assert(false, "Not implemented");
-}
+/// Converts a time duration to nanoseconds (Sint64);
+constexpr Sint64 ToNS(Nanoseconds duration) { return duration.count(); }
 
-/// Converts a float to seconds representation.
-constexpr Nanoseconds FromNS(Sint64 duration)
-{
-  static_assert(false, "Not implemented");
-}
+/// Converts a Sint64 to nanoseconds representation.
+constexpr Nanoseconds FromNS(Sint64 duration) { return Nanoseconds{duration}; }
 
 /**
  * SDL times are signed, 64-bit integers representing nanoseconds since the Unix
@@ -393,22 +405,24 @@
  * Time.FromPosix(), and between Windows FILETIME values with Time.ToWindows()
  * and Time.FromWindows().
  *
- * @since This macro is available since SDL 3.2.0.
+ * @since This type is available since SDL 3.2.0.
  *
  * @sa MAX_SINT64
  * @sa MIN_SINT64
  */
 class Time
 {
-  TimeRaw m_time;
+  Nanoseconds m_time;
 
 public:
+  constexpr Time() = default;
+
   /**
    * Wraps Time.
    *
    * @param time the value to be wrapped
    */
-  constexpr Time(TimeRaw time = {})
+  constexpr explicit Time(TimeRaw time)
     : m_time(time)
   {
   }
@@ -418,20 +432,20 @@
    *
    * @param time the value to be wrapped
    */
-  constexpr Time(std::chrono::nanoseconds time) {}
-
-  /**
-   * Unwraps to the underlying Time.
-   *
-   * @returns the underlying TimeRaw.
-   */
-  constexpr operator TimeRaw() const { return m_time; }
+  constexpr Time(std::chrono::nanoseconds time)
+    : m_time(time)
+  {
+  }
 
-  constexpr operator std::chrono::nanoseconds() const
+  /// True if not zero
+  constexpr explicit operator bool() const
   {
-    static_assert(false, "Not implemented");
+    return m_time != std::chrono::nanoseconds{};
   }
 
+  /// Converts to nanoseconds period
+  constexpr operator std::chrono::nanoseconds() const { return m_time; }
+
   /**
    * Gets the current value of the system realtime clock in nanoseconds since
    * Jan 1, 1970 in Universal Coordinated Time (UTC).
@@ -440,22 +454,24 @@
    *
    * @since This function is available since SDL 3.2.0.
    */
-  Time Current();
+  static Time Current();
 
+  /// Create from a nanoseconds Sint64.
   static constexpr Time FromNS(Sint64 time)
   {
-    static_assert(false, "Not implemented");
+    return Time{std::chrono::nanoseconds{time}};
   }
 
-  constexpr Sint64 ToNS() const { static_assert(false, "Not implemented"); }
+  /// Converts to nanoseconds Sint64
+  constexpr Sint64 ToNS() const { return m_time.count(); }
 
   /**
    * Convert seconds to nanoseconds.
    *
    * This only converts whole numbers, not fractional seconds.
    *
-   * @param S the number of seconds to convert.
-   * @returns S, expressed in nanoseconds.
+   * @param time the number of seconds to convert.
+   * @returns the converted Time.
    *
    * @threadsafety It is safe to call this function from any thread.
    *
@@ -466,11 +482,9 @@
   /**
    * Convert nanoseconds to seconds.
    *
-   * This performs a division, so the results can be dramatically different if
-   * `NS` is an integer or floating point value.
+   * This only converts whole numbers, not fractional seconds.
    *
-   * @param NS the number of nanoseconds to convert.
-   * @returns NS, expressed in seconds.
+   * @returns Posix time (in seconds).
    *
    * @threadsafety It is safe to call this function from any thread.
    *
@@ -509,28 +523,35 @@
   void ToWindows(Uint32* dwLowDateTime, Uint32* dwHighDateTime) const;
 
   /// Converts a time to seconds (float) since epoch.
-  constexpr float ToSeconds() const { static_assert(false, "Not implemented"); }
+  constexpr float ToSeconds() const { return Seconds(m_time).count(); }
 
   /// Converts a time to seconds (float) since epoch.
-  static constexpr Time Time.FromSeconds(float interval)
+  static constexpr Time FromSeconds(float interval)
   {
-    static_assert(false, "Not implemented");
+    return std::chrono::duration_cast<std::chrono::nanoseconds>(
+      Seconds(interval));
   }
 
+  /// Increment time
   constexpr Time& operator+=(std::chrono::nanoseconds interval)
   {
-    static_assert(false, "Not implemented");
+    m_time += interval;
+    return *this;
   }
 
+  /// Decrement
   constexpr Time& operator-=(std::chrono::nanoseconds interval)
   {
-    static_assert(false, "Not implemented");
+    m_time -= interval;
+    return *this;
   }
 };
 
-constexpr Time MAX_TIME = SDL_MAX_TIME;
+/// Max allowed time representation
+constexpr Time MAX_TIME = Time::FromNS(SDL_MAX_TIME);
 
-constexpr Time MIN_TIME = SDL_MIN_TIME;
+/// Min allowed time representation
+constexpr Time MIN_TIME = Time::FromNS(SDL_MIN_TIME);
 
 /**
  * Epsilon constant, used for comparing floating-point numbers.
@@ -543,6 +564,14 @@
 constexpr float FLT_EPSILON = SDL_FLT_EPSILON;
 
 /**
+ * Concept of interface
+ *
+ * @tparam I the interface type
+ */
+template<class I>
+concept Interface = requires(I* iface) { (iface)->version = sizeof(I); };
+
+/**
  * A macro to initialize an SDL interface.
  *
  * This macro will initialize an SDL interface structure and should be called
@@ -550,7 +579,7 @@
  *
  * You can use it like this:
  *
- * ```c
+ * ```cpp
  * IOStreamInterface iface;
  *
  * InitInterface(&iface);
@@ -564,7 +593,7 @@
  * If you are using designated initializers, you can use the size of the
  * interface as the version, e.g.
  *
- * ```c
+ * ```cpp
  * IOStreamInterface iface = {
  *     .version = sizeof(iface),
  *     .seek = ...
@@ -924,6 +953,8 @@
  *
  * @since This struct is available since SDL 3.2.0.
  *
+ * @cat resource
+ *
  * @sa GetEnvironment
  * @sa Environment.Environment
  * @sa Environment.GetVariable
@@ -931,8 +962,6 @@
  * @sa Environment.SetVariable
  * @sa Environment.UnsetVariable
  * @sa Environment.Destroy
- *
- * @cat resource
  */
 class Environment
 {
@@ -1069,9 +1098,10 @@
    * Get all variables in the environment.
    *
    * @returns a nullptr terminated array of pointers to environment variables in
-   *          the form "variable=value" or nullptr on failure; call GetError()
-   *          for more information. This is a single allocation that should be
-   *          freed with free() when it is no longer needed.
+   *          the form "variable=value" on success. This is wrapped to be
+   *          auto-deleted, use FreeWrapper.release() if you want to manage
+   *          manually.
+   * @throws Error on failure
    *
    * @threadsafety It is safe to call this function from any thread.
    *
@@ -1085,7 +1115,19 @@
    */
   OwnArray<char*> GetVariables();
 
-  Uint64 GetVariableCount() { static_assert(false, "Not implemented"); }
+  /**
+   * Get the Variables count.
+   *
+   * @return the number of existing environment variables
+   *
+   * This might be slow.
+   */
+  Uint64 GetVariableCount()
+  {
+    Uint64 count = 0;
+    for (auto& var : GetVariables()) count += 1;
+    return count;
+  }
 
   /**
    * Set the value of a variable in the environment.
@@ -1266,7 +1308,7 @@
  */
 inline OwnArray<char*> GetEnvironmentVariables(EnvironmentParam env)
 {
-  return SDL_GetEnvironmentVariables(env);
+  return OwnArray<char*>{CheckError(SDL_GetEnvironmentVariables(env))};
 }
 
 inline OwnArray<char*> Environment::GetVariables()
@@ -1401,8 +1443,7 @@
  * @param value the value of the variable to set.
  * @param overwrite 1 to overwrite the variable if it exists, 0 to return
  *                  success without setting the variable if it already exists.
- * @returns 0 on success.
- * @throws Error on failure.
+ * @returns 0 on success, -1 on error.
  *
  * @threadsafety This function is not thread safe, consider using
  *               Environment.SetVariable() instead.
@@ -1413,15 +1454,14 @@
  */
 inline int setenv_unsafe(StringParam name, StringParam value, int overwrite)
 {
-  return CheckError(SDL_setenv_unsafe(name, value, overwrite));
+  return SDL_setenv_unsafe(name, value, overwrite);
 }
 
 /**
  * Clear a variable from the environment.
  *
  * @param name the name of the variable to unset.
- * @returns 0 on success.
- * @throws Error on failure.
+ * @returns 0 on success, -1 on error.
  *
  * @threadsafety This function is not thread safe, consider using
  *               Environment.UnsetVariable() instead.
@@ -1432,7 +1472,7 @@
  */
 inline int unsetenv_unsafe(StringParam name)
 {
-  return CheckError(SDL_unsetenv_unsafe(name));
+  return SDL_unsetenv_unsafe(name);
 }
 
 /**
@@ -1701,7 +1741,6 @@
  * @param nmemb the number of elements in the array.
  * @param size the size of the elements in the array.
  * @param compare a function used to compare elements in the array.
- * @param userdata a pointer to pass to the compare function.
  *
  * @threadsafety It is safe to call this function from any thread.
  *
@@ -1712,7 +1751,15 @@
  */
 inline void qsort_r(void* base, size_t nmemb, size_t size, CompareCB compare)
 {
-  static_assert(false, "Not implemented");
+  return qsort_r(
+    base,
+    nmemb,
+    size,
+    [](void* userdata, const void* a, const void* b) {
+      auto& cb = *static_cast<CompareCB*>(userdata);
+      return cb(a, b);
+    },
+    &compare);
 }
 
 /**
@@ -1828,7 +1875,6 @@
  * @param nmemb the number of elements in the array.
  * @param size the size of the elements in the array.
  * @param compare a function used to compare elements in the array.
- * @param userdata a pointer to pass to the compare function.
  * @returns a pointer to the matching element in the array, or nullptr if not
  *          found.
  *
@@ -1845,7 +1891,16 @@
                        size_t size,
                        CompareCB compare)
 {
-  static_assert(false, "Not implemented");
+  return bsearch_r(
+    key,
+    base,
+    nmemb,
+    size,
+    [](void* userdata, const void* a, const void* b) {
+      auto& cb = *static_cast<CompareCB*>(userdata);
+      return cb(a, b);
+    },
+    &compare);
 }
 
 /**
@@ -1952,9 +2007,9 @@
  * If `x` is outside the range a values between `a` and `b`, the returned value
  * will be `a` or `b` as appropriate. Otherwise, `x` is returned.
  *
- * This macro will produce incorrect results if `b` is less than `a`.
+ * This function will produce incorrect results if `b` is less than `a`.
  *
- * This is a helper macro that might be more clear than writing out the
+ * This is a helper function that might be more clear than writing out the
  * comparisons directly, and works with any type that can be compared with the
  * `<` and `>` operators. However, it double-evaluates all its parameters, so do
  * not use expressions with side-effects here.
@@ -2307,7 +2362,11 @@
  */
 inline void* memcpy(void* dst, const void* src, size_t len)
 {
+#ifdef SDL_SLOW_MEMCPY
   return SDL_memcpy(dst, src, len);
+#else
+  return ::memcpy(dst, src, len);
+#endif // SDL_SLOW_MEMCPY
 }
 
 /**
@@ -2337,7 +2396,8 @@
 template<typename T, typename U>
 constexpr T* copyp(T* dst, const U* src)
 {
-  return SDL_copyp(dst, src);
+  SDL_copyp(dst, src);
+  return dst;
 }
 
 /**
@@ -2359,7 +2419,11 @@
  */
 inline void* memmove(void* dst, const void* src, size_t len)
 {
+#ifdef SDL_SLOW_MEMMOVE
   return SDL_memmove(dst, src, len);
+#else
+  return ::memmove(dst, src, len);
+#endif // SDL_SLOW_MEMMOVE
 }
 
 /**
@@ -2382,7 +2446,11 @@
  */
 inline void* memset(void* dst, int c, size_t len)
 {
+#ifdef SDL_SLOW_MEMSET
   return SDL_memset(dst, c, len);
+#else
+  return ::memset(dst, c, len);
+#endif // SDL_SLOW_MEMSET
 }
 
 /**
@@ -2474,7 +2542,7 @@
 template<class T, std::size_t N>
 inline void zeroa(T (&x)[N])
 {
-  SDL_zeroa((&x)[N]);
+  SDL_zeroa(x);
 }
 
 /**
@@ -3421,6 +3489,8 @@
   return SDL_ultoa(value, str, radix);
 }
 
+#ifndef SDL_NOLONGLONG
+
 /**
  * Convert a long long integer into a string.
  *
@@ -3481,6 +3551,8 @@
   return SDL_ulltoa(value, str, radix);
 }
 
+#endif // SDL_NOLONGLONG
+
 /**
  * Parse an `int` from a string.
  *
@@ -3596,6 +3668,8 @@
   return SDL_strtoul(str, endp, base);
 }
 
+#ifndef SDL_NOLONGLONG
+
 /**
  * Parse a `long long` from a string.
  *
@@ -3666,6 +3740,8 @@
   return SDL_strtoull(str, endp, base);
 }
 
+#endif // SDL_NOLONGLONG
+
 /**
  * Parse a `double` from a string.
  *
@@ -3988,7 +4064,12 @@
                   SDL_SCANF_FORMAT_STRING const char* fmt,
                   ...)
 {
-  return SDL_sscanf(text, fmt, ...);
+  int rc;
+  va_list ap;
+  va_start(ap, fmt);
+  rc = SDL_vsscanf(text, fmt, ap);
+  va_end(ap);
+  return rc;
 }
 
 /**
@@ -4049,7 +4130,14 @@
                     SDL_PRINTF_FORMAT_STRING const char* fmt,
                     ...)
 {
-  return SDL_snprintf(text, maxlen, fmt, ...);
+  va_list ap;
+  int result;
+
+  va_start(ap, fmt);
+  result = SDL_vsnprintf(text, maxlen, fmt, ap);
+  va_end(ap);
+
+  return result;
 }
 
 /**
@@ -4088,7 +4176,14 @@
                     SDL_PRINTF_FORMAT_STRING const wchar_t* fmt,
                     ...)
 {
-  return SDL_swprintf(text, maxlen, fmt, ...);
+  va_list ap;
+  int result;
+
+  va_start(ap, fmt);
+  result = SDL_vswprintf(text, maxlen, fmt, ap);
+  va_end(ap);
+
+  return result;
 }
 
 /**
@@ -4172,7 +4267,14 @@
  */
 inline int asprintf(char** strp, SDL_PRINTF_FORMAT_STRING const char* fmt, ...)
 {
-  return SDL_asprintf(strp, fmt, ...);
+  va_list ap;
+  int result;
+
+  va_start(ap, fmt);
+  result = SDL_vasprintf(strp, fmt, ap);
+  va_end(ap);
+
+  return result;
 }
 
 /**
@@ -4275,7 +4377,7 @@
 /**
  * Generate 32 pseudo-random bits.
  *
- * You likely want to use rand() to get a psuedo-random number instead.
+ * You likely want to use rand() to get a pseudo-random number instead.
  *
  * There are no guarantees as to the quality of the random sequence produced,
  * and this should not be used for security (cryptography, passwords) or where
@@ -4295,15 +4397,36 @@
  */
 inline Uint32 rand_bits() { return SDL_rand_bits(); }
 
-struct Random
+/**
+ * A independent pseudo random state
+ *
+ * This can be instantiated in any thread and as long as it is not shared with
+ * another thread all members are safe to call.
+ *
+ * @cat wrap-state
+ *
+ * @sa wrap-state
+ */
+class Random
 {
   Uint64 m_state;
 
-  constexpr Random() {}
+public:
+  constexpr Random()
+    : m_state(0)
+  {
+  }
 
-  constexpr explicit Random(Uint64 state) {}
+  /**
+   * Init state with the given value
+   */
+  constexpr explicit Random(Uint64 state)
+    : m_state(state)
+  {
+  }
 
-  constexpr operator Uint64() { static_assert(false, "Not implemented"); }
+  /// Convert to the underlying type
+  constexpr operator Uint64() { return m_state; }
 
   /**
    * Generate a pseudo-random number less than n for positive n
@@ -4312,11 +4435,11 @@
    * roughly 99.9% even for n = 1 million. Evenness is better for smaller n, and
    * much worse as n gets bigger.
    *
-   * Example: to simulate a d6 use `Random.rand(state, 6) + 1` The +1 converts
+   * Example: to simulate a d6 use `state.rand(6) + 1` The +1 converts
    * 0..5 to 1..6
    *
    * If you want to generate a pseudo-random number in the full range of Sint32,
-   * you should use: (Sint32)Random.rand_bits(state)
+   * you should use: (Sint32)state.rand_bits()
    *
    * There are no guarantees as to the quality of the random sequence produced,
    * and this should not be used for security (cryptography, passwords) or where
@@ -4324,12 +4447,10 @@
    * libraries available with different characteristics and you should pick one
    * of those to meet any serious needs.
    *
-   * @param state a pointer to the current random number state, this may not be
-   *              nullptr.
    * @param n the number of possible outcomes. n must be positive.
    * @returns a random value in the range of [0 .. n-1].
    *
-   * @threadsafety This function is thread-safe, as long as the state pointer
+   * @threadsafety This function is thread-safe, as long as this object
    *               isn't shared between threads.
    *
    * @since This function is available since SDL 3.2.0.
@@ -4338,7 +4459,7 @@
    * @sa Random.rand_bits
    * @sa Random.randf
    */
-  Sint32 rand(Sint32 n);
+  Sint32 rand(Sint32 n) { return SDL_rand_r(&m_state, n); }
 
   /**
    * Generate a uniform pseudo-random floating point number less than 1.0
@@ -4351,11 +4472,9 @@
    * libraries available with different characteristics and you should pick one
    * of those to meet any serious needs.
    *
-   * @param state a pointer to the current random number state, this may not be
-   *              nullptr.
    * @returns a random value in the range of [0.0, 1.0).
    *
-   * @threadsafety This function is thread-safe, as long as the state pointer
+   * @threadsafety This function is thread-safe, as long as this object
    *               isn't shared between threads.
    *
    * @since This function is available since SDL 3.2.0.
@@ -4364,12 +4483,12 @@
    * @sa Random.rand
    * @sa randf
    */
-  float randf();
+  float randf() { return SDL_randf_r(&m_state); }
 
   /**
    * Generate 32 pseudo-random bits.
    *
-   * You likely want to use Random.rand() to get a psuedo-random number instead.
+   * You likely want to use Random.rand() to get a pseudo-random number instead.
    *
    * There are no guarantees as to the quality of the random sequence produced,
    * and this should not be used for security (cryptography, passwords) or where
@@ -4377,11 +4496,9 @@
    * libraries available with different characteristics and you should pick one
    * of those to meet any serious needs.
    *
-   * @param state a pointer to the current random number state, this may not be
-   *              nullptr.
    * @returns a random value in the range of [0-MAX_UINT32].
    *
-   * @threadsafety This function is thread-safe, as long as the state pointer
+   * @threadsafety This function is thread-safe, as long as this object
    *               isn't shared between threads.
    *
    * @since This function is available since SDL 3.2.0.
@@ -4389,7 +4506,7 @@
    * @sa Random.rand
    * @sa Random.randf
    */
-  Uint32 rand_bits();
+  Uint32 rand_bits() { return SDL_rand_bits_r(&m_state); }
 };
 
 /**
@@ -4427,8 +4544,6 @@
  */
 inline Sint32 rand_r(Uint64* state, Sint32 n) { return SDL_rand_r(state, n); }
 
-inline Sint32 Random::rand(Sint32 n) { return SDL::rand_r(n); }
-
 /**
  * Generate a uniform pseudo-random floating point number less than 1.0
  *
@@ -4455,8 +4570,6 @@
  */
 inline float randf_r(Uint64* state) { return SDL_randf_r(state); }
 
-inline float Random::randf() { return SDL::randf_r(); }
-
 /**
  * Generate 32 pseudo-random bits.
  *
@@ -4482,8 +4595,6 @@
  */
 inline Uint32 rand_bits_r(Uint64* state) { return SDL_rand_bits_r(state); }
 
-inline Uint32 Random::rand_bits() { return SDL::rand_bits_r(); }
-
 /**
  * The value of Pi, as a double-precision floating point literal.
  *
@@ -4709,7 +4820,6 @@
  *
  * @since This function is available since SDL 3.2.0.
  *
- * @sa atan2
  * @sa atan
  * @sa tan
  */
@@ -5750,9 +5860,9 @@
  *
  * @since This datatype is available since SDL 3.2.0.
  *
- * @sa IConv.IConv
- *
  * @cat resource
+ *
+ * @sa IConv.IConv
  */
 class IConv
 {
@@ -5793,8 +5903,7 @@
    *
    * @param tocode The target character encoding, must not be nullptr.
    * @param fromcode The source character encoding, must not be nullptr.
-   * @post a handle that must be freed with IConv.close, or ICONV_ERROR on
-   *       failure.
+   * @post a valid handle or falsy on failure.
    *
    * @since This function is available since SDL 3.2.0.
    *
@@ -5844,7 +5953,10 @@
   constexpr bool operator==(std::nullptr_t _) const { return !m_resource; }
 
   /// Converts to bool
-  constexpr explicit operator bool() const { return !!m_resource; }
+  constexpr explicit operator bool() const
+  {
+    return m_resource != IConvRaw(SDL_ICONV_ERROR);
+  }
 
   /// Converts to IConvParam
   constexpr operator IConvParam() const { return {m_resource}; }
@@ -5852,7 +5964,6 @@
   /**
    * This function frees a context used for character set conversion.
    *
-   * @param cd The character set conversion handle.
    * @returns 0 on success, or -1 on failure.
    *
    * @since This function is available since SDL 3.2.0.
@@ -6012,7 +6123,7 @@
  * @sa IConv.close
  * @sa iconv_string
  */
-inline size_t iconv(IConv cd,
+inline size_t iconv(IConvRaw cd,
                     const char** inbuf,
                     size_t* inbytesleft,
                     char** outbuf,
@@ -6050,14 +6161,10 @@
  * the number of bytes specified in `inbytesleft` whether there is a nullptr
  * character anywhere in the buffer.
  *
- * The returned string is owned by the caller, and should be passed to free when
- * no longer needed.
- *
  * @param tocode the character encoding of the output string. Examples are
  *               "UTF-8", "UCS-4", etc.
  * @param fromcode the character encoding of data in `inbuf`.
  * @param inbuf the string to convert to a different encoding.
- * @param inbytesleft the size of the input string _in bytes_.
  * @returns a new string, converted to the new encoding, or nullptr on error.
  *
  * @since This function is available since SDL 3.2.0.
@@ -6070,7 +6177,8 @@
                                    StringParam fromcode,
                                    SourceBytes inbuf)
 {
-  return SDL_iconv_string(tocode, fromcode, inbuf.data(), inbuf.size_bytes());
+  return OwnArray<char>{
+    SDL_iconv_string(tocode, fromcode, inbuf.data(), inbuf.size_bytes())};
 }
 
 /**
@@ -6087,7 +6195,7 @@
  */
 inline OwnArray<char> iconv_utf8_locale(std::string_view S)
 {
-  return SDL_iconv_utf8_locale(S);
+  return iconv_string("", "UTF-8", S);
 }
 
 /**
@@ -6104,7 +6212,8 @@
  */
 inline OwnArray<Uint16> iconv_utf8_ucs2(std::string_view S)
 {
-  return SDL_iconv_utf8_ucs2(S);
+  auto data = SDL_iconv_string("UCS-2", "UTF-8", S.data(), S.size());
+  return OwnArray<Uint16>(reinterpret_cast<Uint16*>(data));
 }
 
 /**
@@ -6121,7 +6230,8 @@
  */
 inline OwnArray<Uint32> iconv_utf8_ucs4(std::string_view S)
 {
-  return SDL_iconv_utf8_ucs4(S);
+  auto data = SDL_iconv_string("UCS-4", "UTF-8", S.data(), S.size());
+  return OwnArray<Uint32>(reinterpret_cast<Uint32*>(data));
 }
 
 /**
@@ -6138,7 +6248,7 @@
  */
 inline OwnArray<char> iconv_wchar_utf8(std::wstring_view S)
 {
-  return SDL_iconv_wchar_utf8(S);
+  return iconv_string("UTF-8", "WCHAR_T", S);
 }
 
 /**
@@ -6200,10 +6310,12 @@
  *
  * @since This datatype is available since SDL 3.2.0.
  */
-using FunctionPointer = void(SDLCALL*)();
+using FunctionPointer = SDL_FunctionPointer;
 
 /// @}
 
+inline void PtrDeleter::operator()(void* ptr) const { SDL_free(ptr); }
+
 } // namespace SDL
 
 #endif /* SDL3PP_STDINC_H_ */
