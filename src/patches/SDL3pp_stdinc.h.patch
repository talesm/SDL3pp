16c16
<  * @defgroup CategoryStdinc Category Stdinc
---
>  * @defgroup CategoryStdinc Standard Library Functionality
86c86
< using IConvRaw = SDL_iconv_t*;
---
> using IConvRaw = SDL_iconv_t;
118,136c118
< using int8_t = ::int8_t;
< 
< using uint8_t = ::uint8_t;
< 
< using int16_t = ::int16_t;
< 
< using uint16_t = ::uint16_t;
< 
< using int32_t = ::int32_t;
< 
< using uint32_t = ::uint32_t;
< 
< using int64_t = ::int64_t;
< 
< using uint64_t = ::uint64_t;
< 
< using intptr_t = ::intptr_t;
< 
< using uintptr_t = ::uintptr_t;
---
> #ifdef SDL3PP_DOC
204a187,188
> #endif // SDL3PP_DOC
> 
211,214d194
<  * This macro looks like it double-evaluates the argument, but it does so inside
<  * of `sizeof`, so there are no side-effects here, as expressions do not
<  * actually run any code in these cases.
<  *
220c200
<   return SDL_arraysize((&array)[N]);
---
>   return SDL_arraysize(array);
222a203,204
> #ifdef SDL3PP_DOC
> 
238a221,222
> #endif // SDL3PP_DOC
> 
242,245c226,229
<  * @param A the first ASCII character.
<  * @param B the second ASCII character.
<  * @param C the third ASCII character.
<  * @param D the fourth ASCII character.
---
>  * @param a the first ASCII character.
>  * @param b the second ASCII character.
>  * @param c the third ASCII character.
>  * @param d the fourth ASCII character.
256a241,242
> #ifdef SDL3PP_DOC
> 
282a269,270
> #endif // SDL3PP_DOC
> 
289a278
> /// Max representable value
291a281
> /// Min representable value
300a291
> /// Max representable value
302a294
> /// Min representable value
311a304
> /// Max representable value
313a307
> /// Min representable value
322a317
> /// Max representable value
324a320
> /// Min representable value
333a330
> /// Max representable value
335a333
> /// Min representable value
344a343
> /// Max representable value
346a346
> /// Min representable value
357a358
> /// Max representable value
359a361
> /// Min representable value
370a373
> /// Max representable value
372a376
> /// Min representable value
385,388c389
< constexpr float ToSeconds(Seconds duration)
< {
<   static_assert(false, "Not implemented");
< }
---
> constexpr float ToSeconds(Seconds duration) { return duration.count(); }
391,394c392
< constexpr Seconds FromSeconds(float duration)
< {
<   static_assert(false, "Not implemented");
< }
---
> constexpr Seconds FromSeconds(float duration) { return Seconds(duration); }
396,400c394,395
< /// Converts a time duration to seconds (float).
< constexpr Sint64 ToNS(std::chrono::nanoseconds duration)
< {
<   static_assert(false, "Not implemented");
< }
---
> /// Converts a time duration to nanoseconds (Sint64);
> constexpr Sint64 ToNS(Nanoseconds duration) { return duration.count(); }
402,406c397,398
< /// Converts a float to seconds representation.
< constexpr Nanoseconds FromNS(Sint64 duration)
< {
<   static_assert(false, "Not implemented");
< }
---
> /// Converts a Sint64 to nanoseconds representation.
> constexpr Nanoseconds FromNS(Sint64 duration) { return Nanoseconds{duration}; }
423c415
<   TimeRaw m_time;
---
>   Nanoseconds m_time;
425a418,419
>   constexpr Time() = default;
> 
431c425
<   constexpr Time(TimeRaw time = {})
---
>   constexpr explicit Time(TimeRaw time)
441,448c435,438
<   constexpr Time(std::chrono::nanoseconds time) {}
< 
<   /**
<    * Unwraps to the underlying Time.
<    *
<    * @returns the underlying TimeRaw.
<    */
<   constexpr operator TimeRaw() const { return m_time; }
---
>   constexpr Time(std::chrono::nanoseconds time)
>     : m_time(time)
>   {
>   }
450c440,441
<   constexpr operator std::chrono::nanoseconds() const
---
>   /// True if not zero
>   constexpr explicit operator bool() const
452c443
<     static_assert(false, "Not implemented");
---
>     return m_time != std::chrono::nanoseconds{};
454a446,448
>   /// Converts to nanoseconds period
>   constexpr operator std::chrono::nanoseconds() const { return m_time; }
> 
463c457
<   Time Current();
---
>   static Time Current();
464a459
>   /// Create from a nanoseconds Sint64.
467c462
<     static_assert(false, "Not implemented");
---
>     return Time{std::chrono::nanoseconds{time}};
470c465,466
<   constexpr Sint64 ToNS() const { static_assert(false, "Not implemented"); }
---
>   /// Converts to nanoseconds Sint64
>   constexpr Sint64 ToNS() const { return m_time.count(); }
477,478c473,474
<    * @param S the number of seconds to convert.
<    * @returns S, expressed in nanoseconds.
---
>    * @param time the number of seconds to convert.
>    * @returns the converted Time.
489,490c485
<    * This performs a division, so the results can be dramatically different if
<    * `NS` is an integer or floating point value.
---
>    * This only converts whole numbers, not fractional seconds.
492,493c487
<    * @param NS the number of nanoseconds to convert.
<    * @returns NS, expressed in seconds.
---
>    * @returns Posix time (in seconds).
532c526
<   constexpr float ToSeconds() const { static_assert(false, "Not implemented"); }
---
>   constexpr float ToSeconds() const { return Seconds(m_time).count(); }
535c529
<   static constexpr Time Time.FromSeconds(float interval)
---
>   static constexpr Time FromSeconds(float interval)
537c531,532
<     static_assert(false, "Not implemented");
---
>     return std::chrono::duration_cast<std::chrono::nanoseconds>(
>       Seconds(interval));
539a535
>   /// Increment time
542c538,539
<     static_assert(false, "Not implemented");
---
>     m_time += interval;
>     return *this;
544a542
>   /// Decrement
547c545,546
<     static_assert(false, "Not implemented");
---
>     m_time -= interval;
>     return *this;
551c550,551
< constexpr Time MAX_TIME = SDL_MAX_TIME;
---
> /// Max allowed time representation
> constexpr Time MAX_TIME = Time::FromNS(SDL_MAX_TIME);
553c553,554
< constexpr Time MIN_TIME = SDL_MIN_TIME;
---
> /// Min allowed time representation
> constexpr Time MIN_TIME = Time::FromNS(SDL_MIN_TIME);
565a567,574
>  * Concept of interface
>  *
>  * @tparam I the interface type
>  */
> template<class I>
> concept Interface = requires(I* iface) { (iface)->version = sizeof(I); };
> 
> /**
573c582
<  * ```c
---
>  * ```cpp
587c596
<  * ```c
---
>  * ```cpp
946a956,957
>  * @cat resource
>  *
954,955d964
<  *
<  * @cat resource
1083,1085c1092,1095
<    *          the form "variable=value" or nullptr on failure; call GetError()
<    *          for more information. This is a single allocation that should be
<    *          freed with free() when it is no longer needed.
---
>    *          the form "variable=value" on success. This is wrapped to be
>    *          auto-deleted, use FreeWrapper.release() if you want to manage
>    *          manually.
>    * @throws Error on failure
1099c1109,1121
<   Uint64 GetVariableCount() { static_assert(false, "Not implemented"); }
---
>   /**
>    * Get the Variables count.
>    *
>    * @return the number of existing environment variables
>    *
>    * This might be slow.
>    */
>   Uint64 GetVariableCount()
>   {
>     Uint64 count = 0;
>     for (auto& var : GetVariables()) count += 1;
>     return count;
>   }
1266c1288
<   return SDL_GetEnvironmentVariables(env);
---
>   return OwnArray<char*>{CheckError(SDL_GetEnvironmentVariables(env))};
1401,1402c1423
<  * @returns 0 on success.
<  * @throws Error on failure.
---
>  * @returns 0 on success, -1 on error.
1413c1434
<   return CheckError(SDL_setenv_unsafe(name, value, overwrite));
---
>   return SDL_setenv_unsafe(name, value, overwrite);
1420,1421c1441
<  * @returns 0 on success.
<  * @throws Error on failure.
---
>  * @returns 0 on success, -1 on error.
1432c1452
<   return CheckError(SDL_unsetenv_unsafe(name));
---
>   return SDL_unsetenv_unsafe(name);
1699d1718
<  * @param userdata a pointer to pass to the compare function.
1710c1729,1737
<   static_assert(false, "Not implemented");
---
>   return qsort_r(
>     base,
>     nmemb,
>     size,
>     [](void* userdata, const void* a, const void* b) {
>       auto& cb = *static_cast<CompareCB*>(userdata);
>       return cb(a, b);
>     },
>     &compare);
1826d1852
<  * @param userdata a pointer to pass to the compare function.
1843c1869,1878
<   static_assert(false, "Not implemented");
---
>   return bsearch_r(
>     key,
>     base,
>     nmemb,
>     size,
>     [](void* userdata, const void* a, const void* b) {
>       auto& cb = *static_cast<CompareCB*>(userdata);
>       return cb(a, b);
>     },
>     &compare);
1950c1985
<  * This macro will produce incorrect results if `b` is less than `a`.
---
>  * This function will produce incorrect results if `b` is less than `a`.
1952c1987
<  * This is a helper macro that might be more clear than writing out the
---
>  * This is a helper function that might be more clear than writing out the
2304a2340
> #ifdef SDL_SLOW_MEMCPY
2305a2342,2344
> #else
>   return ::memcpy(dst, src, len);
> #endif // SDL_SLOW_MEMCPY
2335c2374,2375
<   return SDL_copyp(dst, src);
---
>   SDL_copyp(dst, src);
>   return dst;
2356a2397
> #ifdef SDL_SLOW_MEMMOVE
2357a2399,2401
> #else
>   return ::memmove(dst, src, len);
> #endif // SDL_SLOW_MEMMOVE
2379a2424
> #ifdef SDL_SLOW_MEMSET
2380a2426,2428
> #else
>   return ::memset(dst, c, len);
> #endif // SDL_SLOW_MEMSET
2472c2520
<   SDL_zeroa((&x)[N]);
---
>   SDL_zeroa(x);
3418a3467,3468
> #ifndef SDL_NOLONGLONG
> 
3478a3529,3530
> #endif // SDL_NOLONGLONG
> 
3593a3646,3647
> #ifndef SDL_NOLONGLONG
> 
3663a3718,3719
> #endif // SDL_NOLONGLONG
> 
3986c4042,4047
<   return SDL_sscanf(text, fmt, ...);
---
>   int rc;
>   va_list ap;
>   va_start(ap, fmt);
>   rc = SDL_vsscanf(text, fmt, ap);
>   va_end(ap);
>   return rc;
4047c4108,4115
<   return SDL_snprintf(text, maxlen, fmt, ...);
---
>   va_list ap;
>   int result;
> 
>   va_start(ap, fmt);
>   result = SDL_vsnprintf(text, maxlen, fmt, ap);
>   va_end(ap);
> 
>   return result;
4086c4154,4161
<   return SDL_swprintf(text, maxlen, fmt, ...);
---
>   va_list ap;
>   int result;
> 
>   va_start(ap, fmt);
>   result = SDL_vswprintf(text, maxlen, fmt, ap);
>   va_end(ap);
> 
>   return result;
4170c4245,4252
<   return SDL_asprintf(strp, fmt, ...);
---
>   va_list ap;
>   int result;
> 
>   va_start(ap, fmt);
>   result = SDL_vasprintf(strp, fmt, ap);
>   va_end(ap);
> 
>   return result;
4273c4355
<  * You likely want to use rand() to get a psuedo-random number instead.
---
>  * You likely want to use rand() to get a pseudo-random number instead.
4293c4375,4385
< struct Random
---
> /**
>  * A independent pseudo random state
>  *
>  * This can be instantiated in any thread and as long as it is not shared with
>  * another thread all members are safe to call.
>  *
>  * @cat wrap-state
>  *
>  * @sa wrap-state
>  */
> class Random
4297c4389,4393
<   constexpr Random() {}
---
> public:
>   constexpr Random()
>     : m_state(0)
>   {
>   }
4299c4395,4401
<   constexpr explicit Random(Uint64 state) {}
---
>   /**
>    * Init state with the given value
>    */
>   constexpr explicit Random(Uint64 state)
>     : m_state(state)
>   {
>   }
4301c4403,4404
<   constexpr operator Uint64() { static_assert(false, "Not implemented"); }
---
>   /// Convert to the underlying type
>   constexpr operator Uint64() { return m_state; }
4310c4413
<    * Example: to simulate a d6 use `Random.rand(state, 6) + 1` The +1 converts
---
>    * Example: to simulate a d6 use `state.rand(6) + 1` The +1 converts
4314c4417
<    * you should use: (Sint32)Random.rand_bits(state)
---
>    * you should use: (Sint32)state.rand_bits()
4322,4323d4424
<    * @param state a pointer to the current random number state, this may not be
<    *              nullptr.
4327c4428
<    * @threadsafety This function is thread-safe, as long as the state pointer
---
>    * @threadsafety This function is thread-safe, as long as this object
4336c4437
<   Sint32 rand(Sint32 n);
---
>   Sint32 rand(Sint32 n) { return SDL_rand_r(&m_state, n); }
4349,4350d4449
<    * @param state a pointer to the current random number state, this may not be
<    *              nullptr.
4353,4354c4452,4453
<    * @threadsafety This function is thread-safe, as long as the state pointer
<    *               isn't shared between threads.
---
>    * @threadsafety This function is thread-safe, as long as this object isn't
>    *               shared between threads.
4362c4461
<   float randf();
---
>   float randf() { return SDL_randf_r(&m_state); }
4367c4466
<    * You likely want to use Random.rand() to get a psuedo-random number instead.
---
>    * You likely want to use Random.rand() to get a pseudo-random number instead.
4375,4376d4473
<    * @param state a pointer to the current random number state, this may not be
<    *              nullptr.
4379,4380c4476,4477
<    * @threadsafety This function is thread-safe, as long as the state pointer
<    *               isn't shared between threads.
---
>    * @threadsafety This function is thread-safe, as long as this object isn't
>    *               shared between threads.
4387c4484
<   Uint32 rand_bits();
---
>   Uint32 rand_bits() { return SDL_rand_bits_r(&m_state); }
4425,4426d4521
< inline Sint32 Random::rand(Sint32 n) { return SDL::rand_r(n); }
< 
4453,4454d4547
< inline float Random::randf() { return SDL::randf_r(); }
< 
4480,4481d4572
< inline Uint32 Random::rand_bits() { return SDL::rand_bits_r(); }
< 
4707d4797
<  * @sa atan2
5748,5749d5837
<  * @sa IConv.IConv
<  *
5750a5839,5840
>  *
>  * @sa IConv.IConv
5791,5792c5881
<    * @post a handle that must be freed with IConv.close, or ICONV_ERROR on
<    *       failure.
---
>    * @post a valid handle or falsy on failure.
5833c5922,5925
<   constexpr explicit operator bool() const { return !!m_resource; }
---
>   constexpr explicit operator bool() const
>   {
>     return m_resource != IConvRaw(SDL_ICONV_ERROR);
>   }
5841d5932
<    * @param cd The character set conversion handle.
5987c6078
< inline size_t iconv(IConv cd,
---
> inline size_t iconv(IConvRaw cd,
6025,6027d6115
<  * The returned string is owned by the caller, and should be passed to free when
<  * no longer needed.
<  *
6032d6119
<  * @param inbytesleft the size of the input string _in bytes_.
6045c6132,6133
<   return SDL_iconv_string(tocode, fromcode, inbuf.data(), inbuf.size_bytes());
---
>   return OwnArray<char>{
>     SDL_iconv_string(tocode, fromcode, inbuf.data(), inbuf.size_bytes())};
6062c6150
<   return SDL_iconv_utf8_locale(S);
---
>   return iconv_string("", "UTF-8", S);
6079c6167,6168
<   return SDL_iconv_utf8_ucs2(S);
---
>   auto data = SDL_iconv_string("UCS-2", "UTF-8", S.data(), S.size());
>   return OwnArray<Uint16>(reinterpret_cast<Uint16*>(data));
6096c6185,6186
<   return SDL_iconv_utf8_ucs4(S);
---
>   auto data = SDL_iconv_string("UCS-4", "UTF-8", S.data(), S.size());
>   return OwnArray<Uint32>(reinterpret_cast<Uint32*>(data));
6113c6203
<   return SDL_iconv_wchar_utf8(S);
---
>   return iconv_string("UTF-8", "WCHAR_T", S);
6177a6268,6269
> 
> inline void PtrDeleter::operator()(void* ptr) const { SDL_free(ptr); }
