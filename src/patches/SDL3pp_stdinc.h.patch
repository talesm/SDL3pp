--- src/generated/SDL3pp_stdinc.h
+++ include/SDL3pp/SDL3pp_stdinc.h
@@ -13,7 +13,7 @@
 namespace SDL {
 
 /**
- * @defgroup CategoryStdinc Category Stdinc
+ * @defgroup CategoryStdinc Standard Library Functionality
  *
  * SDL provides its own implementation of some of the most important C runtime
  * functions.
@@ -83,7 +83,7 @@
 struct IConv;
 
 /// Alias to raw representation for IConv.
-using IConvRaw = SDL_iconv_t*;
+using IConvRaw = SDL_iconv_t;
 
 // Forward decl
 struct IConvRef;
@@ -115,25 +115,7 @@
   constexpr operator IConvRaw() const { return value; }
 };
 
-using int8_t = ::int8_t;
-
-using uint8_t = ::uint8_t;
-
-using int16_t = ::int16_t;
-
-using uint16_t = ::uint16_t;
-
-using int32_t = ::int32_t;
-
-using uint32_t = ::uint32_t;
-
-using int64_t = ::int64_t;
-
-using uint64_t = ::uint64_t;
-
-using intptr_t = ::intptr_t;
-
-using uintptr_t = ::uintptr_t;
+#ifdef SDL3PP_DOC
 
 /**
  * Don't let SDL use "long long" C types.
@@ -202,24 +184,24 @@
  */
 #define SDL_COMPILE_TIME_ASSERT(name, x) FailToCompileIf_x_IsFalse(x)
 
+#endif // SDL3PP_DOC
+
 /**
  * The number of elements in a static array.
  *
  * This will compile but return incorrect results for a pointer to an array; it
  * has to be an array the compiler knows the size of.
  *
- * This macro looks like it double-evaluates the argument, but it does so inside
- * of `sizeof`, so there are no side-effects here, as expressions do not
- * actually run any code in these cases.
- *
  * @since This function is available since SDL 3.2.0.
  */
 template<class T, std::size_t N>
 constexpr std::size_t arraysize(const T (&array)[N])
 {
-  return SDL_arraysize((&array)[N]);
+  return SDL_arraysize(array);
 }
 
+#ifdef SDL3PP_DOC
+
 /**
  * Macro useful for building other macros with strings in them.
  *
@@ -236,13 +218,15 @@
  */
 #define SDL_STRINGIFY_ARG(arg) #arg
 
+#endif // SDL3PP_DOC
+
 /**
  * Define a four character code as a Uint32.
  *
- * @param A the first ASCII character.
- * @param B the second ASCII character.
- * @param C the third ASCII character.
- * @param D the fourth ASCII character.
+ * @param a the first ASCII character.
+ * @param b the second ASCII character.
+ * @param c the third ASCII character.
+ * @param d the fourth ASCII character.
  * @returns the four characters converted into a Uint32, one character per-byte.
  *
  * @threadsafety It is safe to call this function from any thread.
@@ -254,6 +238,8 @@
   return SDL_FOURCC(a, b, c, d);
 }
 
+#ifdef SDL3PP_DOC
+
 /**
  * Append the 64 bit integer suffix to a signed integer literal.
  *
@@ -280,6 +266,8 @@
  */
 #define SDL_UINT64_C(c) c##ULL /* or whatever the current compiler uses. */
 
+#endif // SDL3PP_DOC
+
 /**
  * A signed 8-bit integer type.
  *
@@ -287,8 +275,10 @@
  */
 using Sint8 = ::Sint8;
 
+/// Max representable value
 constexpr Sint8 MAX_SINT8 = SDL_MAX_SINT8;
 
+/// Min representable value
 constexpr Sint8 MIN_SINT8 = SDL_MIN_SINT8;
 
 /**
@@ -298,8 +288,10 @@
  */
 using Uint8 = ::Uint8;
 
+/// Max representable value
 constexpr Uint8 MAX_UINT8 = SDL_MAX_UINT8;
 
+/// Min representable value
 constexpr Uint8 MIN_UINT8 = SDL_MIN_UINT8;
 
 /**
@@ -309,8 +301,10 @@
  */
 using Sint16 = ::Sint16;
 
+/// Max representable value
 constexpr Sint16 MAX_SINT16 = SDL_MAX_SINT16;
 
+/// Min representable value
 constexpr Sint16 MIN_SINT16 = SDL_MIN_SINT16;
 
 /**
@@ -320,8 +314,10 @@
  */
 using Uint16 = ::Uint16;
 
+/// Max representable value
 constexpr Uint16 MAX_UINT16 = SDL_MAX_UINT16;
 
+/// Min representable value
 constexpr Uint16 MIN_UINT16 = SDL_MIN_UINT16;
 
 /**
@@ -331,8 +327,10 @@
  */
 using Sint32 = ::Sint32;
 
+/// Max representable value
 constexpr Sint32 MAX_SINT32 = SDL_MAX_SINT32;
 
+/// Min representable value
 constexpr Sint32 MIN_SINT32 = SDL_MIN_SINT32;
 
 /**
@@ -342,8 +340,10 @@
  */
 using Uint32 = ::Uint32;
 
+/// Max representable value
 constexpr Uint32 MAX_UINT32 = SDL_MAX_UINT32;
 
+/// Min representable value
 constexpr Uint8 MIN_UINT32 = SDL_MIN_UINT32;
 
 /**
@@ -355,8 +355,10 @@
  */
 using Sint64 = ::Sint64;
 
+/// Max representable value
 constexpr Sint64 MAX_SINT64 = SDL_MAX_SINT64;
 
+/// Min representable value
 constexpr Sint64 MIN_SINT64 = SDL_MIN_SINT64;
 
 /**
@@ -368,8 +370,10 @@
  */
 using Uint64 = ::Uint64;
 
+/// Max representable value
 constexpr Uint64 MAX_UINT64 = SDL_MAX_UINT64;
 
+/// Min representable value
 constexpr Uint8 MIN_UINT64 = SDL_MIN_UINT64;
 
 /// Duration in seconds (float).
@@ -382,28 +386,16 @@
 using Milliseconds = std::chrono::milliseconds;
 
 /// Converts a time duration to seconds (float).
-constexpr float ToSeconds(Seconds duration)
-{
-  static_assert(false, "Not implemented");
-}
+constexpr float ToSeconds(Seconds duration) { return duration.count(); }
 
 /// Converts a float to seconds representation.
-constexpr Seconds FromSeconds(float duration)
-{
-  static_assert(false, "Not implemented");
-}
+constexpr Seconds FromSeconds(float duration) { return Seconds(duration); }
 
-/// Converts a time duration to seconds (float).
-constexpr Sint64 ToNS(std::chrono::nanoseconds duration)
-{
-  static_assert(false, "Not implemented");
-}
+/// Converts a time duration to nanoseconds (Sint64);
+constexpr Sint64 ToNS(Nanoseconds duration) { return duration.count(); }
 
-/// Converts a float to seconds representation.
-constexpr Nanoseconds FromNS(Sint64 duration)
-{
-  static_assert(false, "Not implemented");
-}
+/// Converts a Sint64 to nanoseconds representation.
+constexpr Nanoseconds FromNS(Sint64 duration) { return Nanoseconds{duration}; }
 
 /**
  * SDL times are signed, 64-bit integers representing nanoseconds since the Unix
@@ -420,15 +412,17 @@
  */
 class Time
 {
-  TimeRaw m_time;
+  Nanoseconds m_time;
 
 public:
+  constexpr Time() = default;
+
   /**
    * Wraps Time.
    *
    * @param time the value to be wrapped
    */
-  constexpr Time(TimeRaw time = {}) noexcept
+  constexpr explicit Time(TimeRaw time) noexcept
     : m_time(time)
   {
   }
@@ -438,20 +432,20 @@
    *
    * @param time the value to be wrapped
    */
-  constexpr Time(std::chrono::nanoseconds time) {}
-
-  /**
-   * Unwraps to the underlying Time.
-   *
-   * @returns the underlying TimeRaw.
-   */
-  constexpr operator TimeRaw() const noexcept { return m_time; }
+  constexpr Time(std::chrono::nanoseconds time) noexcept
+    : m_time(time)
+  {
+  }
 
-  constexpr operator std::chrono::nanoseconds() const
+  /// True if not zero
+  constexpr explicit operator bool() const
   {
-    static_assert(false, "Not implemented");
+    return m_time != std::chrono::nanoseconds{};
   }
 
+  /// Converts to nanoseconds period
+  constexpr operator std::chrono::nanoseconds() const { return m_time; }
+
   /**
    * Gets the current value of the system realtime clock in nanoseconds since
    * Jan 1, 1970 in Universal Coordinated Time (UTC).
@@ -460,22 +454,24 @@
    *
    * @since This function is available since SDL 3.2.0.
    */
-  Time Current();
+  static Time Current();
 
+  /// Create from a nanoseconds Sint64.
   static constexpr Time FromNS(Sint64 time)
   {
-    static_assert(false, "Not implemented");
+    return Time{std::chrono::nanoseconds{time}};
   }
 
-  constexpr Sint64 ToNS() const { static_assert(false, "Not implemented"); }
+  /// Converts to nanoseconds Sint64
+  constexpr Sint64 ToNS() const { return m_time.count(); }
 
   /**
    * Convert seconds to nanoseconds.
    *
    * This only converts whole numbers, not fractional seconds.
    *
-   * @param S the number of seconds to convert.
-   * @returns S, expressed in nanoseconds.
+   * @param time the number of seconds to convert.
+   * @returns the converted Time.
    *
    * @threadsafety It is safe to call this function from any thread.
    *
@@ -486,11 +482,9 @@
   /**
    * Convert nanoseconds to seconds.
    *
-   * This performs a division, so the results can be dramatically different if
-   * `NS` is an integer or floating point value.
+   * This only converts whole numbers, not fractional seconds.
    *
-   * @param NS the number of nanoseconds to convert.
-   * @returns NS, expressed in seconds.
+   * @returns Posix time (in seconds).
    *
    * @threadsafety It is safe to call this function from any thread.
    *
@@ -529,28 +523,35 @@
   void ToWindows(Uint32* dwLowDateTime, Uint32* dwHighDateTime) const;
 
   /// Converts a time to seconds (float) since epoch.
-  constexpr float ToSeconds() const { static_assert(false, "Not implemented"); }
+  constexpr float ToSeconds() const { return Seconds(m_time).count(); }
 
   /// Converts a time to seconds (float) since epoch.
-  static constexpr Time Time.FromSeconds(float interval)
+  static constexpr Time FromSeconds(float interval)
   {
-    static_assert(false, "Not implemented");
+    return std::chrono::duration_cast<std::chrono::nanoseconds>(
+      Seconds(interval));
   }
 
+  /// Increment time
   constexpr Time& operator+=(std::chrono::nanoseconds interval)
   {
-    static_assert(false, "Not implemented");
+    m_time += interval;
+    return *this;
   }
 
+  /// Decrement
   constexpr Time& operator-=(std::chrono::nanoseconds interval)
   {
-    static_assert(false, "Not implemented");
+    m_time -= interval;
+    return *this;
   }
 };
 
-constexpr Time MAX_TIME = SDL_MAX_TIME;
+/// Max allowed time representation
+constexpr Time MAX_TIME = Time::FromNS(SDL_MAX_TIME);
 
-constexpr Time MIN_TIME = SDL_MIN_TIME;
+/// Min allowed time representation
+constexpr Time MIN_TIME = Time::FromNS(SDL_MIN_TIME);
 
 /**
  * Epsilon constant, used for comparing floating-point numbers.
@@ -563,6 +564,14 @@
 constexpr float FLT_EPSILON = SDL_FLT_EPSILON;
 
 /**
+ * Concept of interface
+ *
+ * @tparam I the interface type
+ */
+template<class I>
+concept Interface = requires(I* iface) { (iface)->version = sizeof(I); };
+
+/**
  * A macro to initialize an SDL interface.
  *
  * This macro will initialize an SDL interface structure and should be called
@@ -570,7 +579,7 @@
  *
  * You can use it like this:
  *
- * ```c
+ * ```cpp
  * IOStreamInterface iface;
  *
  * InitInterface(&iface);
@@ -584,7 +593,7 @@
  * If you are using designated initializers, you can use the size of the
  * interface as the version, e.g.
  *
- * ```c
+ * ```cpp
  * IOStreamInterface iface = {
  *     .version = sizeof(iface),
  *     .seek = ...
@@ -944,6 +953,8 @@
  *
  * @since This struct is available since SDL 3.2.0.
  *
+ * @cat resource
+ *
  * @sa GetEnvironment
  * @sa Environment.Environment
  * @sa Environment.GetVariable
@@ -951,8 +962,6 @@
  * @sa Environment.SetVariable
  * @sa Environment.UnsetVariable
  * @sa Environment.Destroy
- *
- * @cat resource
  */
 class Environment
 {
@@ -1085,9 +1094,10 @@
    * Get all variables in the environment.
    *
    * @returns a nullptr terminated array of pointers to environment variables in
-   *          the form "variable=value" or nullptr on failure; call GetError()
-   *          for more information. This is a single allocation that should be
-   *          freed with free() when it is no longer needed.
+   *          the form "variable=value" on success. This is wrapped to be
+   *          auto-deleted, use FreeWrapper.release() if you want to manage
+   *          manually.
+   * @throws Error on failure
    *
    * @threadsafety It is safe to call this function from any thread.
    *
@@ -1101,7 +1111,19 @@
    */
   OwnArray<char*> GetVariables();
 
-  Uint64 GetVariableCount() { static_assert(false, "Not implemented"); }
+  /**
+   * Get the Variables count.
+   *
+   * @return the number of existing environment variables
+   *
+   * This might be slow.
+   */
+  Uint64 GetVariableCount()
+  {
+    Uint64 count = 0;
+    for (auto& var : GetVariables()) count += 1;
+    return count;
+  }
 
   /**
    * Set the value of a variable in the environment.
@@ -1282,7 +1304,7 @@
  */
 inline OwnArray<char*> GetEnvironmentVariables(EnvironmentParam env)
 {
-  return SDL_GetEnvironmentVariables(env);
+  return OwnArray<char*>{CheckError(SDL_GetEnvironmentVariables(env))};
 }
 
 inline OwnArray<char*> Environment::GetVariables()
@@ -1417,8 +1439,7 @@
  * @param value the value of the variable to set.
  * @param overwrite 1 to overwrite the variable if it exists, 0 to return
  *                  success without setting the variable if it already exists.
- * @returns 0 on success.
- * @throws Error on failure.
+ * @returns 0 on success, -1 on error.
  *
  * @threadsafety This function is not thread safe, consider using
  *               Environment.SetVariable() instead.
@@ -1429,15 +1450,14 @@
  */
 inline int setenv_unsafe(StringParam name, StringParam value, int overwrite)
 {
-  return CheckError(SDL_setenv_unsafe(name, value, overwrite));
+  return SDL_setenv_unsafe(name, value, overwrite);
 }
 
 /**
  * Clear a variable from the environment.
  *
  * @param name the name of the variable to unset.
- * @returns 0 on success.
- * @throws Error on failure.
+ * @returns 0 on success, -1 on error.
  *
  * @threadsafety This function is not thread safe, consider using
  *               Environment.UnsetVariable() instead.
@@ -1448,7 +1468,7 @@
  */
 inline int unsetenv_unsafe(StringParam name)
 {
-  return CheckError(SDL_unsetenv_unsafe(name));
+  return SDL_unsetenv_unsafe(name);
 }
 
 /**
@@ -1717,7 +1737,6 @@
  * @param nmemb the number of elements in the array.
  * @param size the size of the elements in the array.
  * @param compare a function used to compare elements in the array.
- * @param userdata a pointer to pass to the compare function.
  *
  * @threadsafety It is safe to call this function from any thread.
  *
@@ -1728,7 +1747,15 @@
  */
 inline void qsort_r(void* base, size_t nmemb, size_t size, CompareCB compare)
 {
-  static_assert(false, "Not implemented");
+  return qsort_r(
+    base,
+    nmemb,
+    size,
+    [](void* userdata, const void* a, const void* b) {
+      auto& cb = *static_cast<CompareCB*>(userdata);
+      return cb(a, b);
+    },
+    &compare);
 }
 
 /**
@@ -1844,7 +1871,6 @@
  * @param nmemb the number of elements in the array.
  * @param size the size of the elements in the array.
  * @param compare a function used to compare elements in the array.
- * @param userdata a pointer to pass to the compare function.
  * @returns a pointer to the matching element in the array, or nullptr if not
  *          found.
  *
@@ -1861,7 +1887,16 @@
                        size_t size,
                        CompareCB compare)
 {
-  static_assert(false, "Not implemented");
+  return bsearch_r(
+    key,
+    base,
+    nmemb,
+    size,
+    [](void* userdata, const void* a, const void* b) {
+      auto& cb = *static_cast<CompareCB*>(userdata);
+      return cb(a, b);
+    },
+    &compare);
 }
 
 /**
@@ -1968,9 +2003,9 @@
  * If `x` is outside the range a values between `a` and `b`, the returned value
  * will be `a` or `b` as appropriate. Otherwise, `x` is returned.
  *
- * This macro will produce incorrect results if `b` is less than `a`.
+ * This function will produce incorrect results if `b` is less than `a`.
  *
- * This is a helper macro that might be more clear than writing out the
+ * This is a helper function that might be more clear than writing out the
  * comparisons directly, and works with any type that can be compared with the
  * `<` and `>` operators. However, it double-evaluates all its parameters, so do
  * not use expressions with side-effects here.
@@ -2323,7 +2358,11 @@
  */
 inline void* memcpy(void* dst, const void* src, size_t len)
 {
+#ifdef SDL_SLOW_MEMCPY
   return SDL_memcpy(dst, src, len);
+#else
+  return ::memcpy(dst, src, len);
+#endif // SDL_SLOW_MEMCPY
 }
 
 /**
@@ -2353,7 +2392,8 @@
 template<typename T, typename U>
 constexpr T* copyp(T* dst, const U* src)
 {
-  return SDL_copyp(dst, src);
+  SDL_copyp(dst, src);
+  return dst;
 }
 
 /**
@@ -2375,7 +2415,11 @@
  */
 inline void* memmove(void* dst, const void* src, size_t len)
 {
+#ifdef SDL_SLOW_MEMMOVE
   return SDL_memmove(dst, src, len);
+#else
+  return ::memmove(dst, src, len);
+#endif // SDL_SLOW_MEMMOVE
 }
 
 /**
@@ -2398,7 +2442,11 @@
  */
 inline void* memset(void* dst, int c, size_t len)
 {
+#ifdef SDL_SLOW_MEMSET
   return SDL_memset(dst, c, len);
+#else
+  return ::memset(dst, c, len);
+#endif // SDL_SLOW_MEMSET
 }
 
 /**
@@ -2490,7 +2538,7 @@
 template<class T, std::size_t N>
 inline void zeroa(T (&x)[N])
 {
-  SDL_zeroa((&x)[N]);
+  SDL_zeroa(x);
 }
 
 /**
@@ -3437,6 +3485,8 @@
   return SDL_ultoa(value, str, radix);
 }
 
+#ifndef SDL_NOLONGLONG
+
 /**
  * Convert a long long integer into a string.
  *
@@ -3497,6 +3547,8 @@
   return SDL_ulltoa(value, str, radix);
 }
 
+#endif // SDL_NOLONGLONG
+
 /**
  * Parse an `int` from a string.
  *
@@ -3612,6 +3664,8 @@
   return SDL_strtoul(str, endp, base);
 }
 
+#ifndef SDL_NOLONGLONG
+
 /**
  * Parse a `long long` from a string.
  *
@@ -3682,6 +3736,8 @@
   return SDL_strtoull(str, endp, base);
 }
 
+#endif // SDL_NOLONGLONG
+
 /**
  * Parse a `double` from a string.
  *
@@ -4004,7 +4060,12 @@
                   SDL_SCANF_FORMAT_STRING const char* fmt,
                   ...)
 {
-  return SDL_sscanf(text, fmt, ...);
+  int rc;
+  va_list ap;
+  va_start(ap, fmt);
+  rc = SDL_vsscanf(text, fmt, ap);
+  va_end(ap);
+  return rc;
 }
 
 /**
@@ -4065,7 +4126,14 @@
                     SDL_PRINTF_FORMAT_STRING const char* fmt,
                     ...)
 {
-  return SDL_snprintf(text, maxlen, fmt, ...);
+  va_list ap;
+  int result;
+
+  va_start(ap, fmt);
+  result = SDL_vsnprintf(text, maxlen, fmt, ap);
+  va_end(ap);
+
+  return result;
 }
 
 /**
@@ -4104,7 +4172,14 @@
                     SDL_PRINTF_FORMAT_STRING const wchar_t* fmt,
                     ...)
 {
-  return SDL_swprintf(text, maxlen, fmt, ...);
+  va_list ap;
+  int result;
+
+  va_start(ap, fmt);
+  result = SDL_vswprintf(text, maxlen, fmt, ap);
+  va_end(ap);
+
+  return result;
 }
 
 /**
@@ -4188,7 +4263,14 @@
  */
 inline int asprintf(char** strp, SDL_PRINTF_FORMAT_STRING const char* fmt, ...)
 {
-  return SDL_asprintf(strp, fmt, ...);
+  va_list ap;
+  int result;
+
+  va_start(ap, fmt);
+  result = SDL_vasprintf(strp, fmt, ap);
+  va_end(ap);
+
+  return result;
 }
 
 /**
@@ -4234,27 +4316,114 @@
  */
 inline void srand(Uint64 seed) { SDL_srand(seed); }
 
+/**
+ * A independent pseudo random state
+ *
+ * This can be instantiated in any thread and as long as it is not shared with
+ * another thread all members are safe to call.
+ *
+ * @cat wrap-state
+ *
+ * @sa wrap-state
+ */
 class Random
 {
   Uint64 m_state;
 
 public:
+  /// Default constructor initializes state to zero
   constexpr Random()
     : m_state(0)
   {
   }
 
+  /// Init state with the given value
   constexpr explicit Random(Uint64 state)
     : m_state(state)
   {
   }
 
+  /// Convert to the underlying type
   constexpr operator Uint64() const { return m_state; }
 
+  /**
+   * Generate a pseudo-random number less than n for positive n
+   *
+   * The method used is faster and of better quality than `rand() % n`. Odds are
+   * roughly 99.9% even for n = 1 million. Evenness is better for smaller n, and
+   * much worse as n gets bigger.
+   *
+   * Example: to simulate a d6 use `rand(state, 6) + 1` The +1 converts 0..5 to
+   * 1..6
+   *
+   * If you want to generate a pseudo-random number in the full range of Sint32,
+   * you should use: (Sint32)rand_bits(state)
+   *
+   * There are no guarantees as to the quality of the random sequence produced,
+   * and this should not be used for security (cryptography, passwords) or where
+   * money is on the line (loot-boxes, casinos). There are many random number
+   * libraries available with different characteristics and you should pick one
+   * of those to meet any serious needs.
+   *
+   * @param n the number of possible outcomes. n must be positive.
+   * @returns a random value in the range of [0 .. n-1].
+   *
+   * @threadsafety This function is thread-safe, as long as the state pointer
+   *               isn't shared between threads.
+   *
+   * @since This function is available since SDL 3.2.0.
+   *
+   * @sa rand
+   * @sa rand_bits
+   * @sa randf
+   */
   Sint32 rand(Sint32 n) { return SDL_rand_r(&m_state, n); }
 
+  /**
+   * Generate a uniform pseudo-random floating point number less than 1.0
+   *
+   * If you want reproducible output, be sure to initialize with srand() first.
+   *
+   * There are no guarantees as to the quality of the random sequence produced,
+   * and this should not be used for security (cryptography, passwords) or where
+   * money is on the line (loot-boxes, casinos). There are many random number
+   * libraries available with different characteristics and you should pick one
+   * of those to meet any serious needs.
+   *
+   * @returns a random value in the range of [0.0, 1.0).
+   *
+   * @threadsafety This function is thread-safe, as long as the state pointer
+   *               isn't shared between threads.
+   *
+   * @since This function is available since SDL 3.2.0.
+   *
+   * @sa rand_bits
+   * @sa rand
+   * @sa randf
+   */
   float randf() { return SDL_randf_r(&m_state); }
 
+  /**
+   * Generate 32 pseudo-random bits.
+   *
+   * You likely want to use rand() to get a pseudo-random number instead.
+   *
+   * There are no guarantees as to the quality of the random sequence produced,
+   * and this should not be used for security (cryptography, passwords) or where
+   * money is on the line (loot-boxes, casinos). There are many random number
+   * libraries available with different characteristics and you should pick one
+   * of those to meet any serious needs.
+   *
+   * @returns a random value in the range of [0-MAX_UINT32].
+   *
+   * @threadsafety This function is thread-safe, as long as the state pointer
+   *               isn't shared between threads.
+   *
+   * @since This function is available since SDL 3.2.0.
+   *
+   * @sa rand
+   * @sa randf
+   */
   Uint32 rand_bits() { return SDL_rand_bits_r(&m_state); }
 };
 
@@ -4332,12 +4501,11 @@
  * roughly 99.9% even for n = 1 million. Evenness is better for smaller n, and
  * much worse as n gets bigger.
  *
- * Example: to simulate a d6 use `rand(6) + 1` The +1 converts 0..5 to 1..6
+ * Example: to simulate a d6 use `rand(state, 6) + 1` The +1 converts 0..5 to
+ * 1..6
  *
  * If you want to generate a pseudo-random number in the full range of Sint32,
- * you should use: (Sint32)rand_bits()
- *
- * If you want reproducible output, be sure to initialize with srand() first.
+ * you should use: (Sint32)rand_bits(state)
  *
  * There are no guarantees as to the quality of the random sequence produced,
  * and this should not be used for security (cryptography, passwords) or where
@@ -4345,14 +4513,18 @@
  * libraries available with different characteristics and you should pick one of
  * those to meet any serious needs.
  *
+ * @param state a pointer to the current random number state, this may not be
+ *              nullptr.
  * @param n the number of possible outcomes. n must be positive.
  * @returns a random value in the range of [0 .. n-1].
  *
- * @threadsafety All calls should be made from a single thread
+ * @threadsafety This function is thread-safe, as long as the state pointer
+ *               isn't shared between threads.
  *
  * @since This function is available since SDL 3.2.0.
  *
- * @sa srand
+ * @sa rand
+ * @sa rand_bits
  * @sa randf
  */
 inline Sint32 rand(Random& state, Sint32 n) { return state.rand(n); }
@@ -4416,21 +4588,25 @@
  * libraries available with different characteristics and you should pick one of
  * those to meet any serious needs.
  *
+ * @param state a pointer to the current random number state, this may not be
+ *              nullptr.
  * @returns a random value in the range of [0.0, 1.0).
  *
- * @threadsafety All calls should be made from a single thread
+ * @threadsafety This function is thread-safe, as long as the state pointer
+ *               isn't shared between threads.
  *
  * @since This function is available since SDL 3.2.0.
  *
- * @sa srand
+ * @sa rand_bits
  * @sa rand
+ * @sa randf
  */
 inline float randf(Random& state) { return state.randf(); }
 
 /**
  * Generate 32 pseudo-random bits.
  *
- * You likely want to use rand() to get a psuedo-random number instead.
+ * You likely want to use rand() to get a pseudo-random number instead.
  *
  * There are no guarantees as to the quality of the random sequence produced,
  * and this should not be used for security (cryptography, passwords) or where
@@ -4453,7 +4629,7 @@
 /**
  * Generate 32 pseudo-random bits.
  *
- * You likely want to use rand() to get a psuedo-random number instead.
+ * You likely want to use rand() to get a pseudo-random number instead.
  *
  * There are no guarantees as to the quality of the random sequence produced,
  * and this should not be used for security (cryptography, passwords) or where
@@ -4478,7 +4654,7 @@
 /**
  * Generate 32 pseudo-random bits.
  *
- * You likely want to use rand() to get a psuedo-random number instead.
+ * You likely want to use rand() to get a pseudo-random number instead.
  *
  * There are no guarantees as to the quality of the random sequence produced,
  * and this should not be used for security (cryptography, passwords) or where
@@ -4486,15 +4662,17 @@
  * libraries available with different characteristics and you should pick one of
  * those to meet any serious needs.
  *
+ * @param state a pointer to the current random number state, this may not be
+ *              nullptr.
  * @returns a random value in the range of [0-MAX_UINT32].
  *
- * @threadsafety All calls should be made from a single thread
+ * @threadsafety This function is thread-safe, as long as the state pointer
+ *               isn't shared between threads.
  *
  * @since This function is available since SDL 3.2.0.
  *
  * @sa rand
  * @sa randf
- * @sa srand
  */
 inline Uint32 rand_bits(Random& state) { return state.rand_bits(); }
 
@@ -4723,7 +4901,6 @@
  *
  * @since This function is available since SDL 3.2.0.
  *
- * @sa atan2
  * @sa atan
  * @sa tan
  */
@@ -5764,9 +5941,9 @@
  *
  * @since This datatype is available since SDL 3.2.0.
  *
- * @sa IConv.IConv
- *
  * @cat resource
+ *
+ * @sa IConv.IConv
  */
 class IConv
 {
@@ -5775,7 +5952,7 @@
 public:
   /// Default ctor
   constexpr IConv(std::nullptr_t = nullptr) noexcept
-    : m_resource(0)
+    : m_resource(reinterpret_cast<IConvRaw>(SDL_ICONV_ERROR))
   {
   }
 
@@ -5810,8 +5987,7 @@
    *
    * @param tocode The target character encoding, must not be nullptr.
    * @param fromcode The source character encoding, must not be nullptr.
-   * @post a handle that must be freed with IConv.close, or ICONV_ERROR on
-   *       failure.
+   * @post a valid handle or falsy on failure.
    *
    * @since This function is available since SDL 3.2.0.
    *
@@ -5854,7 +6030,10 @@
   constexpr auto operator<=>(const IConv& other) const noexcept = default;
 
   /// Converts to bool
-  constexpr explicit operator bool() const noexcept { return !!m_resource; }
+  constexpr explicit operator bool() const noexcept
+  {
+    return size_t(m_resource) != SDL_ICONV_ERROR;
+  }
 
   /// Converts to IConvParam
   constexpr operator IConvParam() const noexcept { return {m_resource}; }
@@ -5862,7 +6041,6 @@
   /**
    * This function frees a context used for character set conversion.
    *
-   * @param cd The character set conversion handle.
    * @returns 0 on success, or -1 on failure.
    *
    * @since This function is available since SDL 3.2.0.
@@ -6022,7 +6200,7 @@
  * @sa IConv.close
  * @sa iconv_string
  */
-inline size_t iconv(IConv cd,
+inline size_t iconv(IConvRaw cd,
                     const char** inbuf,
                     size_t* inbytesleft,
                     char** outbuf,
@@ -6060,14 +6238,10 @@
  * the number of bytes specified in `inbytesleft` whether there is a nullptr
  * character anywhere in the buffer.
  *
- * The returned string is owned by the caller, and should be passed to free when
- * no longer needed.
- *
  * @param tocode the character encoding of the output string. Examples are
  *               "UTF-8", "UCS-4", etc.
  * @param fromcode the character encoding of data in `inbuf`.
  * @param inbuf the string to convert to a different encoding.
- * @param inbytesleft the size of the input string _in bytes_.
  * @returns a new string, converted to the new encoding, or nullptr on error.
  *
  * @since This function is available since SDL 3.2.0.
@@ -6080,7 +6254,8 @@
                                    StringParam fromcode,
                                    SourceBytes inbuf)
 {
-  return SDL_iconv_string(tocode, fromcode, inbuf.data(), inbuf.size_bytes());
+  return OwnArray<char>{
+    SDL_iconv_string(tocode, fromcode, inbuf.data(), inbuf.size_bytes())};
 }
 
 /**
@@ -6097,7 +6272,7 @@
  */
 inline OwnArray<char> iconv_utf8_locale(std::string_view S)
 {
-  return SDL_iconv_utf8_locale(S);
+  return iconv_string("", "UTF-8", S);
 }
 
 /**
@@ -6114,7 +6289,8 @@
  */
 inline OwnArray<Uint16> iconv_utf8_ucs2(std::string_view S)
 {
-  return SDL_iconv_utf8_ucs2(S);
+  auto data = SDL_iconv_string("UCS-2", "UTF-8", S.data(), S.size());
+  return OwnArray<Uint16>(reinterpret_cast<Uint16*>(data));
 }
 
 /**
@@ -6131,7 +6307,8 @@
  */
 inline OwnArray<Uint32> iconv_utf8_ucs4(std::string_view S)
 {
-  return SDL_iconv_utf8_ucs4(S);
+  auto data = SDL_iconv_string("UCS-4", "UTF-8", S.data(), S.size());
+  return OwnArray<Uint32>(reinterpret_cast<Uint32*>(data));
 }
 
 /**
@@ -6148,7 +6325,7 @@
  */
 inline OwnArray<char> iconv_wchar_utf8(std::wstring_view S)
 {
-  return SDL_iconv_wchar_utf8(S);
+  return iconv_string("UTF-8", "WCHAR_T", S);
 }
 
 /**
@@ -6214,6 +6391,8 @@
 
 /// @}
 
+inline void PtrDeleter::operator()(void* ptr) const { SDL_free(ptr); }
+
 } // namespace SDL
 
 #endif /* SDL3PP_STDINC_H_ */
