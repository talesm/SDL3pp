--- src/generated/SDL3pp_surface.h
+++ include/SDL3pp/SDL3pp_surface.h
@@ -16,7 +16,7 @@
 namespace SDL {
 
 /**
- * @defgroup CategorySurface Category Surface
+ * @defgroup CategorySurface Surface Creation and Simple Drawing
  *
  * SDL surfaces are buffers of pixels in system RAM. These are useful for
  * passing around and manipulating images that are not stored in GPU memory.
@@ -76,7 +76,7 @@
 {
   const SurfaceRaw value; ///< parameter's const SurfaceRaw
 
-  /// Constructs from const SurfaceRaw
+  /// Constructs from SurfaceRaw
   constexpr SurfaceConstParam(const SurfaceRaw value)
     : value(value)
   {
@@ -133,7 +133,7 @@
  *
  * @since This function is available since SDL 3.2.0.
  */
-constexpr bool MustLock(SurfaceConstParam S) const { return SDL_MUSTLOCK(S); }
+constexpr bool MustLock(SurfaceConstParam S) { return SDL_MUSTLOCK((S.value)); }
 
 /**
  * The scaling mode.
@@ -192,10 +192,10 @@
  *
  * @since This struct is available since SDL 3.2.0.
  *
+ * @cat resource
+ *
  * @sa Surface.Surface
  * @sa Surface.Destroy
- *
- * @cat resource
  */
 class Surface
 {
@@ -234,11 +234,9 @@
    *
    * The pixels of the new surface are initialized to zero.
    *
-   * @param width the width of the surface.
-   * @param height the height of the surface.
+   * @param size the width and height of the surface.
    * @param format the PixelFormat for the new surface's pixel format.
-   * @post the new Surface structure that is created or nullptr on failure; call
-   *       GetError() for more information.
+   * @throws Error on failure.
    *
    * @threadsafety It is safe to call this function from any thread.
    *
@@ -248,7 +246,7 @@
    * @sa Surface.Destroy
    */
   Surface(const PointRaw& size, PixelFormat format)
-    : m_resource(SDL_CreateSurface(size, format))
+    : m_resource(CheckError(SDL_CreateSurface(size.x, size.y, format)))
   {
   }
 
@@ -265,13 +263,11 @@
    * You may pass nullptr for pixels and 0 for pitch to create a surface that
    * you will fill in with valid values later.
    *
-   * @param width the width of the surface.
-   * @param height the height of the surface.
+   * @param size the width and height of the surface.
    * @param format the PixelFormat for the new surface's pixel format.
    * @param pixels a pointer to existing pixel data.
    * @param pitch the number of bytes between each row, including padding.
-   * @post the new Surface structure that is created or nullptr on failure; call
-   *       GetError() for more information.
+   * @throws Error on failure.
    *
    * @threadsafety It is safe to call this function from any thread.
    *
@@ -281,7 +277,8 @@
    * @sa Surface.Destroy
    */
   Surface(const PointRaw& size, PixelFormat format, void* pixels, int pitch)
-    : m_resource(SDL_CreateSurfaceFrom(size, format, pixels, pitch))
+    : m_resource(CheckError(
+        SDL_CreateSurfaceFrom(size.x, size.y, format, pixels, pitch)))
   {
   }
 
@@ -313,9 +310,6 @@
    * load images directly into an Texture for use by the GPU without using a
    * software surface: call Texture.Texture() instead.
    *
-   * When done with the returned surface, the app should dispose of it with a
-   * call to [Surface.Destroy](https://wiki.libsdl.org/SDL3/Surface.Destroy) ().
-   *
    * @param file a path on the filesystem to load an image from.
    * @post a new SDL surface, or nullptr on error.
    *
@@ -364,9 +358,6 @@
    * load images directly into an Texture for use by the GPU without using a
    * software surface: call Texture.Texture() instead.
    *
-   * When done with the returned surface, the app should dispose of it with a
-   * call to Surface.Destroy().
-   *
    * @param src an IOStream that data will be read from.
    * @param closeio true to close/free the IOStream before returning, false to
    *                leave it open.
@@ -378,7 +369,7 @@
    * @sa LoadSurfaceTyped
    * @sa Surface.Destroy
    */
-  Surface(IOStreamParam src, bool closeio);
+  Surface(IOStreamParam src, bool closeio = false);
 
   /**
    * Safely borrows the from SurfaceParam.
@@ -537,7 +528,7 @@
    * Setting the colorspace doesn't change the pixels, only how they are
    * interpreted in color operations.
    *
-   * @param colorspace an Colorspace value describing the surface colorspace.
+   * @param colorspace a Colorspace value describing the surface colorspace.
    * @throws Error on failure.
    *
    * @threadsafety This function is not thread safe.
@@ -636,8 +627,7 @@
    * This function adds a reference to the alternate version, so you should call
    * Surface.Destroy() on the image after this call.
    *
-   * @param image a pointer to an alternate Surface to associate with this
-   *              surface.
+   * @param image an alternate Surface to associate with this surface.
    * @throws Error on failure.
    *
    * @threadsafety This function is not thread safe.
@@ -671,15 +661,8 @@
    * This returns all versions of a surface, with the surface being queried as
    * the first element in the returned array.
    *
-   * Freeing the array of surfaces does not affect the surfaces in the array.
-   * They are still referenced by the surface being queried and will be cleaned
-   * up normally.
-   *
-   * @param count a pointer filled in with the number of surface pointers
-   *              returned, may be nullptr.
    * @returns a nullptr terminated array of Surface pointers or nullptr on
-   *          failure; call GetError() for more information. This should be
-   *          freed with free() when it is no longer needed.
+   *          failure; call GetError() for more information.
    *
    * @threadsafety This function is not thread safe.
    *
@@ -715,9 +698,9 @@
    * `surface->format`. Once you are done accessing the surface, you should use
    * Surface.Unlock() to release it.
    *
-   * Not all surfaces require locking. If `Surface.MustLock(surface)` evaluates
-   * to 0, then you can read and write to the surface at any time, and the pixel
-   * format of the surface will not change.
+   * Not all surfaces require locking. If `Surface.MustLock()` evaluates to
+   * false, then you can read and write to the surface at any time, and the
+   * pixel format of the surface will not change.
    *
    * @throws Error on failure.
    *
@@ -832,8 +815,7 @@
    *
    * It is a pixel of the format used by the surface, as generated by MapRGB().
    *
-   * @param enabled true to enable color key, false to disable color key.
-   * @param key the transparent pixel.
+   * @param key the transparent pixel or std::nullopt to disable it.
    * @throws Error on failure.
    *
    * @threadsafety This function is not thread safe.
@@ -846,13 +828,20 @@
    */
   void SetColorKey(std::optional<Uint32> key);
 
+  /**
+   * Unset the color key (transparent pixel) in a surface.
+   *
+   * The color key defines a pixel value that will be treated as transparent in
+   * a blit. For example, one can use this to specify that cyan pixels should be
+   * considered transparent, and therefore not rendered.
+   *
+   * @throws Error on failure.
+   */
   void ClearColorKey();
 
   /**
    * Returns whether the surface has a color key.
    *
-   * It is safe to pass a nullptr `surface` here; it will return false.
-   *
    * @returns true if the surface has a color key, false otherwise.
    *
    * @threadsafety It is safe to call this function from any thread.
@@ -872,7 +861,7 @@
    *
    * If the surface doesn't have color key enabled this function returns false.
    *
-   * @param key a pointer filled in with the transparent pixel.
+   * @returns the transparent pixel or nullopt if none.
    * @throws Error on failure.
    *
    * @threadsafety It is safe to call this function from any thread.
@@ -947,7 +936,6 @@
   /**
    * Get the additional alpha value used in blit operations.
    *
-   * @param alpha a pointer filled in with the current alpha value.
    * @throws Error on failure.
    *
    * @threadsafety It is safe to call this function from any thread.
@@ -959,8 +947,29 @@
    */
   Uint8 GetAlphaMod() const;
 
+  /**
+   * Set an additional color and alpha value multiplied into blit
+   * operations.
+   *
+   * When this surface is blitted, during the blit operation each source color
+   * channel is modulated by the appropriate color value according to the
+   * following formula:
+   *
+   * `srcC = srcC * (color / 255)`
+   * `srcA = srcA * (alpha / 255)`
+   *
+   * @param color the color to be multiplied in blit operations
+   * @throws Error on failure.
+   */
   void SetMod(Color color);
 
+  /**
+   * Get the additional color and alpha value multiplied into blit
+   * operations.
+   *
+   * @returns a Color containing RGBA value on success or std::nullopt on
+   * failure; call GetError() for more information.
+   */
   Color GetMod() const;
 
   /**
@@ -984,7 +993,7 @@
   /**
    * Get the blend mode used for blit operations.
    *
-   * @param blendMode a pointer filled in with the current BlendMode.
+   * @returns the current BlendMode.
    * @throws Error on failure.
    *
    * @threadsafety It is safe to call this function from any thread.
@@ -1013,10 +1022,16 @@
    *
    * @since This function is available since SDL 3.2.0.
    *
+   * @sa Surface.ResetClipRect()
    * @sa Surface.GetClipRect
    */
   bool SetClipRect(OptionalRef<const RectRaw> rect);
 
+  /**
+   * Disable the clipping rectangle for a surface.
+   *
+   * @sa SetClipRect()
+   */
   void ResetClipRect();
 
   /**
@@ -1025,8 +1040,8 @@
    * When `surface` is the destination of a blit, only the area within the clip
    * rectangle is drawn into.
    *
-   * @param rect an Rect structure filled in with the clipping rectangle for the
-   *             surface.
+   * @returns the Rect structure filled in with the clipping rectangle for the
+   *          surface on success.
    * @throws Error on failure.
    *
    * @threadsafety This function is not thread safe.
@@ -1055,8 +1070,6 @@
    * If the original surface has alternate images, the new surface will have a
    * reference to them as well.
    *
-   * The returned surface should be freed with Surface.Destroy().
-   *
    * @returns a copy of the surface or nullptr on failure; call GetError() for
    *          more information.
    *
@@ -1072,10 +1085,7 @@
    * Creates a new surface identical to the existing surface, scaled to the
    * desired size.
    *
-   * The returned surface should be freed with Surface.Destroy().
-   *
-   * @param width the width of the new surface.
-   * @param height the height of the new surface.
+   * @param size the width and height of the new surface.
    * @param scaleMode the ScaleMode to be used.
    * @returns a copy of the surface or nullptr on failure; call GetError() for
    *          more information.
@@ -1167,12 +1177,9 @@
    * This function handles all surface formats, and ignores any clip rectangle.
    *
    * If the surface is YUV, the color is assumed to be in the sRGB colorspace,
-   * otherwise the color is assumed to be in the colorspace of the suface.
+   * otherwise the color is assumed to be in the colorspace of the surface.
    *
-   * @param r the red component of the pixel, normally in the range 0-1.
-   * @param g the green component of the pixel, normally in the range 0-1.
-   * @param b the blue component of the pixel, normally in the range 0-1.
-   * @param a the alpha component of the pixel, normally in the range 0-1.
+   * @param c the color components of the pixel, normally in the range 0-1.
    * @throws Error on failure.
    *
    * @threadsafety This function is not thread safe.
@@ -1206,6 +1213,16 @@
    */
   void FillRect(OptionalRef<const RectRaw> rect, Uint32 color);
 
+  /**
+   * Perform a fast fill of a rectangle with a specific color.
+   *
+   * If there is a clip rectangle set on the destination (set via
+   * Surface.SetClipRect()), then this function will fill based on the
+   * intersection of the clip rectangle and `rect`.
+   *
+   * @param color the color to fill with.
+   * @throws Error on failure.
+   */
   void Fill(Uint32 color);
 
   /**
@@ -1221,7 +1238,6 @@
    * intersection of the clip rectangle and `rect`.
    *
    * @param rects an array of SDL_Rects representing the rectangles to fill.
-   * @param count the number of rectangles in the array.
    * @param color the color to fill with.
    * @throws Error on failure.
    *
@@ -1285,9 +1301,9 @@
    *       source color key.
    * ```
    *
+   * @param src the SurfaceRaw structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be copied,
    *                or nullptr to copy the entire surface.
-   * @param dst the Surface structure that is the blit target.
    * @param dstrect the Rect structure representing the x and y position in the
    *                destination surface, or nullptr for (0,0). The width and
    *                height are ignored, and are copied from `srcrect`. If you
@@ -1306,6 +1322,76 @@
             OptionalRef<const RectRaw> srcrect,
             OptionalRef<const RectRaw> dstrect);
 
+  /**
+   * Performs a fast blit from the source surface to the destination surface
+   * with clipping.
+   *
+   * If either `srcrect` or `dstrect` are nullptr, the entire surface (`src` or
+   * `dst`) is copied while ensuring clipping to `dst->clip_rect`.
+   *
+   * The blit function should not be called on a locked surface.
+   *
+   * The blit semantics for surfaces with and without blending and colorkey are
+   * defined as follows:
+   *
+   * ```
+   *    RGBA->RGB:
+   *      Source surface blend mode set to BLENDMODE_BLEND:
+   *       alpha-blend (using the source alpha-channel and per-surface alpha)
+   *       SDL_SRCCOLORKEY ignored.
+   *     Source surface blend mode set to BLENDMODE_NONE:
+   *       copy RGB.
+   *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+   *       RGB values of the source color key, ignoring alpha in the
+   *       comparison.
+   *
+   *   RGB->RGBA:
+   *     Source surface blend mode set to BLENDMODE_BLEND:
+   *       alpha-blend (using the source per-surface alpha)
+   *     Source surface blend mode set to BLENDMODE_NONE:
+   *       copy RGB, set destination alpha to source per-surface alpha value.
+   *     both:
+   *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+   *       source color key.
+   *
+   *   RGBA->RGBA:
+   *     Source surface blend mode set to BLENDMODE_BLEND:
+   *       alpha-blend (using the source alpha-channel and per-surface alpha)
+   *       SDL_SRCCOLORKEY ignored.
+   *     Source surface blend mode set to BLENDMODE_NONE:
+   *       copy all of RGBA to the destination.
+   *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+   *       RGB values of the source color key, ignoring alpha in the
+   *       comparison.
+   *
+   *   RGB->RGB:
+   *     Source surface blend mode set to BLENDMODE_BLEND:
+   *       alpha-blend (using the source per-surface alpha)
+   *     Source surface blend mode set to BLENDMODE_NONE:
+   *       copy RGB.
+   *     both:
+   *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+   *       source color key.
+   * ```
+   *
+   * @param src the SurfaceRaw structure to be copied from.
+   * @param srcrect the Rect structure representing the rectangle to be
+   *                copied, or nullptr to copy the entire surface.
+   * @param dstpos the Point structure representing the x and y position in
+   *                the destination surface, or nullptr for (0,0). The width and
+   *                height are ignored, and are copied from `srcrect`. If you
+   *                want a specific width and height, you should use
+   *                Surface.BlitScaled().
+   * @throws Error on failure.
+   *
+   * @threadsafety Only one thread should be using the `src` and `dst` surfaces
+   *               at any given time.
+   *
+   * @since This function is available since SDL 3.2.0.
+   *
+   * @sa Surface.Blit
+   * @sa Surface.BlitScaled
+   */
   void BlitAt(SurfaceParam src,
               OptionalRef<const RectRaw> srcrect,
               const PointRaw& dstpos);
@@ -1316,9 +1402,9 @@
    * This is a semi-private blit function and it performs low-level surface
    * blitting, assuming the input rectangles have already been clipped.
    *
+   * @param src the Surface structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be copied,
    *                may not be nullptr.
-   * @param dst the Surface structure that is the blit target.
    * @param dstrect the Rect structure representing the target rectangle in the
    *                destination surface, may not be nullptr.
    * @throws Error on failure.
@@ -1338,9 +1424,9 @@
    * Perform a scaled blit to a destination surface, which may be of a different
    * format.
    *
+   * @param src the Surface structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be copied,
    *                or nullptr to copy the entire surface.
-   * @param dst the Surface structure that is the blit target.
    * @param dstrect the Rect structure representing the target rectangle in the
    *                destination surface, or nullptr to fill the entire
    *                destination surface.
@@ -1365,9 +1451,9 @@
    * This is a semi-private function and it performs low-level surface blitting,
    * assuming the input rectangles have already been clipped.
    *
+   * @param src the Surface structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be copied,
    *                may not be nullptr.
-   * @param dst the Surface structure that is the blit target.
    * @param dstrect the Rect structure representing the target rectangle in the
    *                destination surface, may not be nullptr.
    * @param scaleMode the ScaleMode to be used.
@@ -1390,9 +1476,9 @@
   /**
    * Perform a stretched pixel copy from one surface to another.
    *
+   * @param src the Surface structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be copied,
    *                or nullptr to copy the entire surface.
-   * @param dst the Surface structure that is the blit target.
    * @param dstrect the Rect structure representing the target rectangle in the
    *                destination surface, or nullptr to fill the entire
    *                destination surface.
@@ -1420,9 +1506,9 @@
    * The pixels in `srcrect` will be repeated as many times as needed to
    * completely fill `dstrect`.
    *
+   * @param src the SDL_Surface structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be copied,
    *                or nullptr to copy the entire surface.
-   * @param dst the Surface structure that is the blit target.
    * @param dstrect the Rect structure representing the target rectangle in the
    *                destination surface, or nullptr to fill the entire surface.
    * @throws Error on failure.
@@ -1445,13 +1531,13 @@
    * The pixels in `srcrect` will be scaled and repeated as many times as needed
    * to completely fill `dstrect`.
    *
+   * @param src the SDL_Surface structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be copied,
    *                or nullptr to copy the entire surface.
    * @param scale the scale used to transform srcrect into the destination
    *              rectangle, e.g. a 32x32 texture with a scale of 2 would fill
    *              64x64 tiles.
    * @param scaleMode scale algorithm to be used.
-   * @param dst the Surface structure that is the blit target.
    * @param dstrect the Rect structure representing the target rectangle in the
    *                destination surface, or nullptr to fill the entire surface.
    * @throws Error on failure.
@@ -1479,6 +1565,7 @@
    * into the corners of the destination rectangle. The sides and center are
    * then stretched into place to cover the remaining destination rectangle.
    *
+   * @param src the SDL_Surface structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be used for
    *                the 9-grid, or nullptr to use the entire surface.
    * @param left_width the width, in pixels, of the left corners in `srcrect`.
@@ -1486,12 +1573,11 @@
    * @param top_height the height, in pixels, of the top corners in `srcrect`.
    * @param bottom_height the height, in pixels, of the bottom corners in
    *                      `srcrect`.
+   * @param dstrect the Rect structure representing the target rectangle in the
+   *                destination surface, or nullptr to fill the entire surface.
    * @param scale the scale used to transform the corner of `srcrect` into the
    *              corner of `dstrect`, or 0.0f for an unscaled blit.
    * @param scaleMode scale algorithm to be used.
-   * @param dst the Surface structure that is the blit target.
-   * @param dstrect the Rect structure representing the target rectangle in the
-   *                destination surface, or nullptr to fill the entire surface.
    * @throws Error on failure.
    *
    * @threadsafety Only one thread should be using the `src` and `dst` surfaces
@@ -1560,10 +1646,7 @@
    * format the return value can be assigned to a Uint16, and similarly a Uint8
    * for an 8-bpp format).
    *
-   * @param r the red component of the pixel in the range 0-255.
-   * @param g the green component of the pixel in the range 0-255.
-   * @param b the blue component of the pixel in the range 0-255.
-   * @param a the alpha component of the pixel in the range 0-255.
+   * @param c the color components of the pixel in the range 0-255.
    * @returns a pixel value.
    *
    * @threadsafety It is safe to call this function from any thread.
@@ -1583,8 +1666,7 @@
    * Like GetRGBA, this uses the entire 0..255 range when converting color
    * components from pixel formats with less than 8 bits per RGB component.
    *
-   * @param x the horizontal coordinate, 0 <= x < width.
-   * @param y the vertical coordinate, 0 <= y < height.
+   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
    * @param r a pointer filled in with the red channel, 0-255, or nullptr to
    *          ignore this channel.
    * @param g a pointer filled in with the green channel, 0-255, or nullptr to
@@ -1611,19 +1693,8 @@
    * This function prioritizes correctness over speed: it is suitable for unit
    * tests, but is not intended for use in a game engine.
    *
-   * Like GetRGBA, this uses the entire 0..255 range when converting color
-   * components from pixel formats with less than 8 bits per RGB component.
-   *
-   * @param x the horizontal coordinate, 0 <= x < width.
-   * @param y the vertical coordinate, 0 <= y < height.
-   * @param r a pointer filled in with the red channel, 0-255, or nullptr to
-   *          ignore this channel.
-   * @param g a pointer filled in with the green channel, 0-255, or nullptr to
-   *          ignore this channel.
-   * @param b a pointer filled in with the blue channel, 0-255, or nullptr to
-   *          ignore this channel.
-   * @param a a pointer filled in with the alpha channel, 0-255, or nullptr to
-   *          ignore this channel.
+   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
+   * @returns color on success.
    * @throws Error on failure.
    *
    * @threadsafety This function is not thread safe.
@@ -1638,8 +1709,7 @@
    * This function prioritizes correctness over speed: it is suitable for unit
    * tests, but is not intended for use in a game engine.
    *
-   * @param x the horizontal coordinate, 0 <= x < width.
-   * @param y the vertical coordinate, 0 <= y < height.
+   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
    * @param r a pointer filled in with the red channel, normally in the range
    *          0-1, or nullptr to ignore this channel.
    * @param g a pointer filled in with the green channel, normally in the range
@@ -1666,16 +1736,8 @@
    * This function prioritizes correctness over speed: it is suitable for unit
    * tests, but is not intended for use in a game engine.
    *
-   * @param x the horizontal coordinate, 0 <= x < width.
-   * @param y the vertical coordinate, 0 <= y < height.
-   * @param r a pointer filled in with the red channel, normally in the range
-   *          0-1, or nullptr to ignore this channel.
-   * @param g a pointer filled in with the green channel, normally in the range
-   *          0-1, or nullptr to ignore this channel.
-   * @param b a pointer filled in with the blue channel, normally in the range
-   *          0-1, or nullptr to ignore this channel.
-   * @param a a pointer filled in with the alpha channel, normally in the range
-   *          0-1, or nullptr to ignore this channel.
+   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
+   * @returns color on success.
    * @throws Error on failure.
    *
    * @threadsafety This function is not thread safe.
@@ -1693,12 +1755,8 @@
    * Like MapColor, this uses the entire 0..255 range when converting color
    * components from pixel formats with less than 8 bits per RGB component.
    *
-   * @param x the horizontal coordinate, 0 <= x < width.
-   * @param y the vertical coordinate, 0 <= y < height.
-   * @param r the red channel value, 0-255.
-   * @param g the green channel value, 0-255.
-   * @param b the blue channel value, 0-255.
-   * @param a the alpha channel value, 0-255.
+   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
+   * @param c the color values, 0-255.
    * @throws Error on failure.
    *
    * @threadsafety This function is not thread safe.
@@ -1713,12 +1771,8 @@
    * This function prioritizes correctness over speed: it is suitable for unit
    * tests, but is not intended for use in a game engine.
    *
-   * @param x the horizontal coordinate, 0 <= x < width.
-   * @param y the vertical coordinate, 0 <= y < height.
-   * @param r the red channel value, normally in the range 0-1.
-   * @param g the green channel value, normally in the range 0-1.
-   * @param b the blue channel value, normally in the range 0-1.
-   * @param a the alpha channel value, normally in the range 0-1.
+   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
+   * @param c the color values, normally in the range 0-1.
    * @throws Error on failure.
    *
    * @threadsafety This function is not thread safe.
@@ -1727,16 +1781,34 @@
    */
   void WritePixelFloat(const PointRaw& p, const FColorRaw& c);
 
+  /**
+   * Get the width in pixels.
+   */
   constexpr int GetWidth() const;
 
+  /**
+   * Get the height in pixels.
+   */
   constexpr int GetHeight() const;
 
+  /**
+   * Get the size in pixels.
+   */
   constexpr Point GetSize() const;
 
+  /**
+   * Get pitch in bytes.
+   */
   constexpr int GetPitch() const;
 
+  /**
+   * Get the pixel format.
+   */
   constexpr PixelFormat GetFormat() const;
 
+  /**
+   * Get the pixels.
+   */
   constexpr void* GetPixels() const;
 };
 
@@ -1745,8 +1817,7 @@
  *
  * The pixels of the new surface are initialized to zero.
  *
- * @param width the width of the surface.
- * @param height the height of the surface.
+ * @param size the width and height of the surface.
  * @param format the PixelFormat for the new surface's pixel format.
  * @returns the new Surface structure that is created or nullptr on failure;
  *          call GetError() for more information.
@@ -1775,8 +1846,7 @@
  * You may pass nullptr for pixels and 0 for pitch to create a surface that you
  * will fill in with valid values later.
  *
- * @param width the width of the surface.
- * @param height the height of the surface.
+ * @param size the width and height of the surface.
  * @param format the PixelFormat for the new surface's pixel format.
  * @param pixels a pointer to existing pixel data.
  * @param pitch the number of bytes between each row, including padding.
@@ -1849,7 +1919,7 @@
  */
 inline PropertiesRef GetSurfaceProperties(SurfaceConstParam surface)
 {
-  return CheckError(SDL_GetSurfaceProperties(surface));
+  return {CheckError(SDL_GetSurfaceProperties(surface))};
 }
 
 inline PropertiesRef Surface::GetProperties() const
@@ -1870,10 +1940,6 @@
 
 constexpr auto HOTSPOT_X_NUMBER = SDL_PROP_SURFACE_HOTSPOT_X_NUMBER;
 
-#endif // SDL_VERSION_ATLEAST(3, 2, 6)
-
-#if SDL_VERSION_ATLEAST(3, 2, 6)
-
 constexpr auto HOTSPOT_Y_NUMBER = SDL_PROP_SURFACE_HOTSPOT_Y_NUMBER;
 
 #endif // SDL_VERSION_ATLEAST(3, 2, 6)
@@ -1961,7 +2027,7 @@
  */
 inline Palette CreateSurfacePalette(SurfaceParam surface)
 {
-  return CheckError(SDL_CreateSurfacePalette(surface));
+  return Palette::Borrow(CheckError(SDL_CreateSurfacePalette(surface)));
 }
 
 inline Palette Surface::CreatePalette()
@@ -2010,7 +2076,7 @@
  */
 inline Palette GetSurfacePalette(SurfaceConstParam surface)
 {
-  return SDL_GetSurfacePalette(surface);
+  return Palette::Borrow(SDL_GetSurfacePalette(surface));
 }
 
 inline Palette Surface::GetPalette() const
@@ -2087,11 +2153,8 @@
  * normally.
  *
  * @param surface the Surface structure to query.
- * @param count a pointer filled in with the number of surface pointers
- *              returned, may be nullptr.
  * @returns a nullptr terminated array of Surface pointers or nullptr on
- *          failure; call GetError() for more information. This should be freed
- *          with free() when it is no longer needed.
+ *          failure; call GetError() for more information.
  *
  * @threadsafety This function is not thread safe.
  *
@@ -2103,7 +2166,9 @@
  */
 inline OwnArray<SurfaceRaw> GetSurfaceImages(SurfaceConstParam surface)
 {
-  return SDL_GetSurfaceImages(surface);
+  int count = 0;
+  auto data = SDL_GetSurfaceImages(surface, &count);
+  return OwnArray<SurfaceRaw>(CheckError(data), count);
 }
 
 inline OwnArray<SurfaceRaw> Surface::GetImages() const
@@ -2145,7 +2210,7 @@
  * Once you are done accessing the surface, you should use Surface.Unlock() to
  * release it.
  *
- * Not all surfaces require locking. If `Surface.MustLock(surface)` evaluates to
+ * Not all surfaces require locking. If `Surface.MustLock()` evaluates to
  * 0, then you can read and write to the surface at any time, and the pixel
  * format of the surface will not change.
  *
@@ -2363,8 +2428,7 @@
  * It is a pixel of the format used by the surface, as generated by MapRGB().
  *
  * @param surface the Surface structure to update.
- * @param enabled true to enable color key, false to disable color key.
- * @param key the transparent pixel.
+ * @param key the transparent pixel or std::nullopt to disable it.
  * @throws Error on failure.
  *
  * @threadsafety This function is not thread safe.
@@ -2377,7 +2441,7 @@
  */
 inline void SetSurfaceColorKey(SurfaceParam surface, std::optional<Uint32> key)
 {
-  CheckError(SDL_SetSurfaceColorKey(surface, key));
+  CheckError(SDL_SetSurfaceColorKey(surface, key.has_value(), key.value_or(0)));
 }
 
 inline void Surface::SetColorKey(std::optional<Uint32> key)
@@ -2385,9 +2449,19 @@
   SDL::SetSurfaceColorKey(m_resource, key);
 }
 
+/**
+ * Unset the color key (transparent pixel) in a surface.
+ *
+ * The color key defines a pixel value that will be treated as transparent in
+ * a blit. For example, one can use this to specify that cyan pixels should be
+ * considered transparent, and therefore not rendered.
+ *
+ * @param surface the Surface structure to update.
+ * @throws Error on failure.
+ */
 inline void ClearSurfaceColorKey(SurfaceParam surface)
 {
-  static_assert(false, "Not implemented");
+  SetSurfaceColorKey(surface, std::nullopt);
 }
 
 inline void Surface::ClearColorKey() { SDL::ClearSurfaceColorKey(m_resource); }
@@ -2426,7 +2500,7 @@
  * If the surface doesn't have color key enabled this function returns false.
  *
  * @param surface the Surface structure to query.
- * @param key a pointer filled in with the transparent pixel.
+ * @returns the transparent pixel or nullopt if none.
  * @throws Error on failure.
  *
  * @threadsafety It is safe to call this function from any thread.
@@ -2438,7 +2512,8 @@
  */
 inline std::optional<Uint32> GetSurfaceColorKey(SurfaceConstParam surface)
 {
-  return CheckError(SDL_GetSurfaceColorKey(surface));
+  if (Uint32 key; SDL_GetSurfaceColorKey(surface, &key)) return key;
+  return std::nullopt;
 }
 
 inline std::optional<Uint32> Surface::GetColorKey() const
@@ -2540,7 +2615,7 @@
  * Get the additional alpha value used in blit operations.
  *
  * @param surface the Surface structure to query.
- * @param alpha a pointer filled in with the current alpha value.
+ * @returns the current alpha value.
  * @throws Error on failure.
  *
  * @threadsafety It is safe to call this function from any thread.
@@ -2552,7 +2627,9 @@
  */
 inline Uint8 GetSurfaceAlphaMod(SurfaceConstParam surface)
 {
-  return CheckError(SDL_GetSurfaceAlphaMod(surface));
+  Uint8 alpha;
+  CheckError(SDL_GetSurfaceAlphaMod(surface, &alpha));
+  return alpha;
 }
 
 inline Uint8 Surface::GetAlphaMod() const
@@ -2560,19 +2637,43 @@
   return SDL::GetSurfaceAlphaMod(m_resource);
 }
 
+/**
+ * Set an additional color and alpha value multiplied into blit
+ * operations.
+ *
+ * When this surface is blitted, during the blit operation each source color
+ * channel is modulated by the appropriate color value according to the
+ * following formula:
+ *
+ * `srcC = srcC * (color / 255)`
+ * `srcA = srcA * (alpha / 255)`
+ *
+ * @param surface the Surface structure to query.
+ * @param color the color to be multiplied in blit operations
+ * @throws Error on failure.
+ */
 inline void SetSurfaceMod(SurfaceParam surface, Color color)
 {
-  static_assert(false, "Not implemented");
+  SetSurfaceColorMod(surface, color.r, color.g, color.b);
+  SetSurfaceAlphaMod(surface, color.a);
 }
 
-inline void Surface::SetMod(Color color)
-{
-  SDL::SetSurfaceMod(m_resource, color);
-}
+inline void Surface::SetMod(Color color) { SetSurfaceMod(m_resource, color); }
 
+/**
+ * Get the additional color and alpha value multiplied into blit
+ * operations.
+ *
+ * @param surface the Surface structure to query.
+ * @returns a Color containing RGBA value on success or std::nullopt on
+ * failure; call GetError() for more information.
+ */
 inline Color GetSurfaceMod(SurfaceConstParam surface)
 {
-  static_assert(false, "Not implemented");
+  Color c;
+  GetSurfaceColorMod(surface, &c.r, &c.g, &c.b);
+  c.a = GetSurfaceAlphaMod(surface);
+  return c;
 }
 
 inline Color Surface::GetMod() const { return SDL::GetSurfaceMod(m_resource); }
@@ -2608,7 +2709,7 @@
  * Get the blend mode used for blit operations.
  *
  * @param surface the Surface structure to query.
- * @param blendMode a pointer filled in with the current BlendMode.
+ * @returns the current BlendMode.
  * @throws Error on failure.
  *
  * @threadsafety It is safe to call this function from any thread.
@@ -2619,7 +2720,9 @@
  */
 inline BlendMode GetSurfaceBlendMode(SurfaceConstParam surface)
 {
-  return CheckError(SDL_GetSurfaceBlendMode(surface));
+  BlendMode blendmode;
+  CheckError(SDL_GetSurfaceBlendMode(surface, &blendmode));
+  return blendmode;
 }
 
 inline BlendMode Surface::GetBlendMode() const
@@ -2659,9 +2762,14 @@
   return SDL::SetSurfaceClipRect(m_resource, rect);
 }
 
+/**
+ * Disable the clipping rectangle for a surface.
+ *
+ * @sa SetSurfaceClipRect()
+ */
 inline void ResetSurfaceClipRect(SurfaceParam surface)
 {
-  static_assert(false, "Not implemented");
+  SetSurfaceClipRect(surface, std::nullopt);
 }
 
 inline void Surface::ResetClipRect() { SDL::ResetSurfaceClipRect(m_resource); }
@@ -2673,8 +2781,8 @@
  * rectangle is drawn into.
  *
  * @param surface the Surface structure representing the surface to be clipped.
- * @param rect an Rect structure filled in with the clipping rectangle for the
- *             surface.
+ * @returns the Rect structure filled in with the clipping rectangle for the
+ *          surface.
  * @throws Error on failure.
  *
  * @threadsafety This function is not thread safe.
@@ -2685,7 +2793,9 @@
  */
 inline Rect GetSurfaceClipRect(SurfaceConstParam surface)
 {
-  return CheckError(SDL_GetSurfaceClipRect(surface));
+  Rect r;
+  CheckError(SDL_GetSurfaceClipRect(surface, &r));
+  return r;
 }
 
 inline Rect Surface::GetClipRect() const
@@ -2731,7 +2841,7 @@
  */
 inline Surface DuplicateSurface(SurfaceConstParam surface)
 {
-  return SDL_DuplicateSurface(surface);
+  return Surface(SDL_DuplicateSurface(surface));
 }
 
 inline Surface Surface::Duplicate() const
@@ -2746,8 +2856,7 @@
  * The returned surface should be freed with Surface.Destroy().
  *
  * @param surface the surface to duplicate and scale.
- * @param width the width of the new surface.
- * @param height the height of the new surface.
+ * @param size the width and height of the surface.
  * @param scaleMode the ScaleMode to be used.
  * @returns a copy of the surface or nullptr on failure; call GetError() for
  *          more information.
@@ -2762,7 +2871,7 @@
                             const PointRaw& size,
                             ScaleMode scaleMode)
 {
-  return SDL_ScaleSurface(surface, size, scaleMode);
+  return Surface(SDL_ScaleSurface(surface, size.x, size.y, scaleMode));
 }
 
 inline Surface Surface::Scale(const PointRaw& size, ScaleMode scaleMode) const
@@ -2798,7 +2907,7 @@
  */
 inline Surface ConvertSurface(SurfaceConstParam surface, PixelFormat format)
 {
-  return SDL_ConvertSurface(surface, format);
+  return Surface(SDL_ConvertSurface(surface, format));
 }
 
 inline Surface Surface::Convert(PixelFormat format) const
@@ -2806,15 +2915,6 @@
   return SDL::ConvertSurface(m_resource, format);
 }
 
-inline Surface Surface::Convert(PixelFormat format,
-                                PaletteParam palette,
-                                Colorspace colorspace,
-                                PropertiesParam props) const
-{
-  return SDL::ConvertSurfaceAndColorspace(
-    m_resource, format, palette, colorspace, props);
-}
-
 /**
  * Copy an existing surface to a new surface of the specified format and
  * colorspace.
@@ -2848,15 +2948,23 @@
                                            Colorspace colorspace,
                                            PropertiesParam props)
 {
-  return SDL_ConvertSurfaceAndColorspace(
-    surface, format, palette, colorspace, props);
+  return Surface{SDL_ConvertSurfaceAndColorspace(
+    surface, format, palette, colorspace, props)};
+}
+
+inline Surface Surface::Convert(PixelFormat format,
+                                PaletteParam palette,
+                                Colorspace colorspace,
+                                PropertiesParam props) const
+{
+  return SDL::ConvertSurfaceAndColorspace(
+    m_resource, format, palette, colorspace, props);
 }
 
 /**
  * Copy a block of pixels of one format to another format.
  *
- * @param width the width of the block to copy, in pixels.
- * @param height the height of the block to copy, in pixels.
+ * @param size the width and height of the surface.
  * @param src_format an PixelFormat value of the `src` pixels format.
  * @param src a pointer to the source pixels.
  * @param src_pitch the pitch of the source pixels, in bytes.
@@ -2882,15 +2990,14 @@
                           int dst_pitch)
 {
   CheckError(SDL_ConvertPixels(
-    size, src_format, src, src_pitch, dst_format, dst, dst_pitch));
+    size.x, size.y, src_format, src, src_pitch, dst_format, dst, dst_pitch));
 }
 
 /**
  * Copy a block of pixels of one format and colorspace to another format and
  * colorspace.
  *
- * @param width the width of the block to copy, in pixels.
- * @param height the height of the block to copy, in pixels.
+ * @param size the width and height  of the block to copy, in pixels.
  * @param src_format an PixelFormat value of the `src` pixels format.
  * @param src_colorspace an Colorspace value describing the colorspace of the
  *                       `src` pixels.
@@ -2927,7 +3034,8 @@
                                        void* dst,
                                        int dst_pitch)
 {
-  CheckError(SDL_ConvertPixelsAndColorspace(size,
+  CheckError(SDL_ConvertPixelsAndColorspace(size.x,
+                                            size.y,
                                             src_format,
                                             src_colorspace,
                                             src_properties,
@@ -2945,8 +3053,7 @@
  *
  * This is safe to use with src == dst, but not for other overlapping areas.
  *
- * @param width the width of the block to convert, in pixels.
- * @param height the height of the block to convert, in pixels.
+ * @param size the width and height of the surface.
  * @param src_format an PixelFormat value of the `src` pixels format.
  * @param src a pointer to the source pixels.
  * @param src_pitch the pitch of the source pixels, in bytes.
@@ -2972,8 +3079,15 @@
                              int dst_pitch,
                              bool linear)
 {
-  CheckError(SDL_PremultiplyAlpha(
-    size, src_format, src, src_pitch, dst_format, dst, dst_pitch, linear));
+  CheckError(SDL_PremultiplyAlpha(size.x,
+                                  size.y,
+                                  src_format,
+                                  src,
+                                  src_pitch,
+                                  dst_format,
+                                  dst,
+                                  dst_pitch,
+                                  linear));
 }
 
 /**
@@ -3009,10 +3123,7 @@
  * otherwise the color is assumed to be in the colorspace of the suface.
  *
  * @param surface the Surface to clear.
- * @param r the red component of the pixel, normally in the range 0-1.
- * @param g the green component of the pixel, normally in the range 0-1.
- * @param b the blue component of the pixel, normally in the range 0-1.
- * @param a the alpha component of the pixel, normally in the range 0-1.
+ * @param c the color components of the pixel, normally in the range 0-1.
  * @throws Error on failure.
  *
  * @threadsafety This function is not thread safe.
@@ -3021,7 +3132,7 @@
  */
 inline void ClearSurface(SurfaceParam surface, const FColorRaw& c)
 {
-  CheckError(SDL_ClearSurface(surface, c));
+  CheckError(SDL_ClearSurface(surface, c.r, c.g, c.b, c.a));
 }
 
 inline void Surface::Clear(const FColorRaw& c)
@@ -3065,9 +3176,20 @@
   SDL::FillSurfaceRect(m_resource, rect, color);
 }
 
+/**
+ * Perform a fast fill of a rectangle with a specific color.
+ *
+ * If there is a clip rectangle set on the destination (set via
+ * Surface.SetClipRect()), then this function will fill based on the
+ * intersection of the clip rectangle and `rect`.
+ *
+ * @param dst the Surface structure that is the drawing target.
+ * @param color the color to fill with.
+ * @throws Error on failure.
+ */
 inline void FillSurface(SurfaceParam dst, Uint32 color)
 {
-  static_assert(false, "Not implemented");
+  FillSurfaceRect(dst, std::nullopt, color);
 }
 
 inline void Surface::Fill(Uint32 color) { SDL::FillSurface(m_resource, color); }
@@ -3086,7 +3208,6 @@
  *
  * @param dst the Surface structure that is the drawing target.
  * @param rects an array of SDL_Rects representing the rectangles to fill.
- * @param count the number of rectangles in the array.
  * @param color the color to fill with.
  * @throws Error on failure.
  *
@@ -3100,7 +3221,7 @@
                              SpanRef<const RectRaw> rects,
                              Uint32 color)
 {
-  CheckError(SDL_FillSurfaceRects(dst, rects, color));
+  CheckError(SDL_FillSurfaceRects(dst, rects.data(), rects.size(), color));
 }
 
 inline void Surface::FillRects(SpanRef<const RectRaw> rects, Uint32 color)
@@ -3190,22 +3311,89 @@
                           OptionalRef<const RectRaw> srcrect,
                           OptionalRef<const RectRaw> dstrect)
 {
-  SDL::BlitSurface(m_resource, src, srcrect, dstrect);
+  SDL::BlitSurface(src, srcrect, m_resource, dstrect);
 }
 
 inline void Surface::BlitAt(SurfaceParam src,
                             OptionalRef<const RectRaw> srcrect,
                             const PointRaw& dstpos)
 {
-  static_assert(false, "Not implemented");
+  Blit(src, srcrect, Rect{dstpos, {}});
 }
 
+/**
+ * Performs a fast blit from the source surface to the destination surface
+ * with clipping.
+ *
+ * If either `srcrect` or `dstrect` are nullptr, the entire surface (`src` or
+ * `dst`) is copied while ensuring clipping to `dst->clip_rect`.
+ *
+ * The blit function should not be called on a locked surface.
+ *
+ * The blit semantics for surfaces with and without blending and colorkey are
+ * defined as follows:
+ *
+ * ```
+ *    RGBA->RGB:
+ *      Source surface blend mode set to BLENDMODE_BLEND:
+ *       alpha-blend (using the source alpha-channel and per-surface alpha)
+ *       SDL_SRCCOLORKEY ignored.
+ *     Source surface blend mode set to BLENDMODE_NONE:
+ *       copy RGB.
+ *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+ *       RGB values of the source color key, ignoring alpha in the
+ *       comparison.
+ *
+ *   RGB->RGBA:
+ *     Source surface blend mode set to BLENDMODE_BLEND:
+ *       alpha-blend (using the source per-surface alpha)
+ *     Source surface blend mode set to BLENDMODE_NONE:
+ *       copy RGB, set destination alpha to source per-surface alpha value.
+ *     both:
+ *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+ *       source color key.
+ *
+ *   RGBA->RGBA:
+ *     Source surface blend mode set to BLENDMODE_BLEND:
+ *       alpha-blend (using the source alpha-channel and per-surface alpha)
+ *       SDL_SRCCOLORKEY ignored.
+ *     Source surface blend mode set to BLENDMODE_NONE:
+ *       copy all of RGBA to the destination.
+ *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+ *       RGB values of the source color key, ignoring alpha in the
+ *       comparison.
+ *
+ *   RGB->RGB:
+ *     Source surface blend mode set to BLENDMODE_BLEND:
+ *       alpha-blend (using the source per-surface alpha)
+ *     Source surface blend mode set to BLENDMODE_NONE:
+ *       copy RGB.
+ *     both:
+ *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+ *       source color key.
+ * ```
+ *
+ * @param src the Surface structure to be copied from.
+ * @param srcrect the Rect structure representing the rectangle to be
+ *                copied, or nullptr to copy the entire surface.
+ * @param dst the Surface structure that is the blit target.
+ * @param dstpos the Point structure representing the x and y position in
+ *                the destination surface.
+ * @throws Error on failure.
+ *
+ * @threadsafety Only one thread should be using the `src` and `dst` surfaces
+ *               at any given time.
+ *
+ * @since This function is available since SDL 3.2.0.
+ *
+ * @sa Surface.BlitSurface
+ */
 inline void BlitSurfaceAt(SurfaceParam src,
                           OptionalRef<const RectRaw> srcrect,
                           SurfaceParam dst,
                           const PointRaw& dstpos)
 {
-  static_assert(false, "Not implemented");
+  BlitSurface(src, srcrect, dst, SDL_Rect{dstpos.x, dstpos.y});
 }
 
 /**
@@ -3234,14 +3422,14 @@
                                  SurfaceParam dst,
                                  const RectRaw& dstrect)
 {
-  CheckError(SDL_BlitSurfaceUnchecked(src, srcrect, dst, dstrect));
+  CheckError(SDL_BlitSurfaceUnchecked(src, &srcrect, dst, &dstrect));
 }
 
 inline void Surface::BlitUnchecked(SurfaceParam src,
                                    const RectRaw& srcrect,
                                    const RectRaw& dstrect)
 {
-  SDL::BlitSurfaceUnchecked(m_resource, src, srcrect, dstrect);
+  SDL::BlitSurfaceUnchecked(src, srcrect, m_resource, dstrect);
 }
 
 /**
@@ -3279,7 +3467,7 @@
                                 OptionalRef<const RectRaw> dstrect,
                                 ScaleMode scaleMode)
 {
-  SDL::BlitSurfaceScaled(m_resource, src, srcrect, dstrect, scaleMode);
+  SDL::BlitSurfaceScaled(src, srcrect, m_resource, dstrect, scaleMode);
 }
 
 /**
@@ -3311,7 +3499,7 @@
                                        ScaleMode scaleMode)
 {
   CheckError(
-    SDL_BlitSurfaceUncheckedScaled(src, srcrect, dst, dstrect, scaleMode));
+    SDL_BlitSurfaceUncheckedScaled(src, &srcrect, dst, &dstrect, scaleMode));
 }
 
 inline void Surface::BlitUncheckedScaled(SurfaceParam src,
@@ -3319,7 +3507,7 @@
                                          const RectRaw& dstrect,
                                          ScaleMode scaleMode)
 {
-  SDL::BlitSurfaceUncheckedScaled(m_resource, src, srcrect, dstrect, scaleMode);
+  SDL::BlitSurfaceUncheckedScaled(src, srcrect, m_resource, dstrect, scaleMode);
 }
 
 #if SDL_VERSION_ATLEAST(3, 4, 0)
@@ -3353,16 +3541,12 @@
   CheckError(SDL_StretchSurface(src, srcrect, dst, dstrect, scaleMode));
 }
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
 inline void Surface::Stretch(SurfaceParam src,
                              OptionalRef<RectRaw> srcrect,
                              OptionalRef<RectRaw> dstrect,
                              ScaleMode scaleMode)
 {
-  SDL::StretchSurface(m_resource, src, srcrect, dstrect, scaleMode);
+  SDL::StretchSurface(src, srcrect, m_resource, dstrect, scaleMode);
 }
 
 #endif // SDL_VERSION_ATLEAST(3, 4, 0)
@@ -3401,7 +3585,7 @@
                                OptionalRef<const RectRaw> srcrect,
                                OptionalRef<const RectRaw> dstrect)
 {
-  SDL::BlitSurfaceTiled(m_resource, src, srcrect, dstrect);
+  SDL::BlitSurfaceTiled(src, srcrect, m_resource, dstrect);
 }
 
 /**
@@ -3448,7 +3632,7 @@
                                         OptionalRef<const RectRaw> dstrect)
 {
   SDL::BlitSurfaceTiledWithScale(
-    m_resource, src, srcrect, scale, scaleMode, dstrect);
+    src, srcrect, scale, scaleMode, m_resource, dstrect);
 }
 
 /**
@@ -3469,12 +3653,12 @@
  * @param top_height the height, in pixels, of the top corners in `srcrect`.
  * @param bottom_height the height, in pixels, of the bottom corners in
  *                      `srcrect`.
- * @param scale the scale used to transform the corner of `srcrect` into the
- *              corner of `dstrect`, or 0.0f for an unscaled blit.
- * @param scaleMode scale algorithm to be used.
  * @param dst the Surface structure that is the blit target.
  * @param dstrect the Rect structure representing the target rectangle in the
  *                destination surface, or nullptr to fill the entire surface.
+ * @param scale the scale used to transform the corner of `srcrect` into the
+ *              corner of `dstrect`, or 0.0f for an unscaled blit.
+ * @param scaleMode scale algorithm to be used.
  * @throws Error on failure.
  *
  * @threadsafety Only one thread should be using the `src` and `dst` surfaces at
@@ -3501,10 +3685,10 @@
                                   right_width,
                                   top_height,
                                   bottom_height,
-                                  dst,
-                                  dstrect,
                                   scale,
-                                  scaleMode));
+                                  scaleMode,
+                                  dst,
+                                  dstrect));
 }
 
 inline void Surface::Blit9Grid(SurfaceParam src,
@@ -3517,13 +3701,13 @@
                                float scale,
                                SDL_ScaleMode scaleMode)
 {
-  SDL::BlitSurface9Grid(m_resource,
-                        src,
+  SDL::BlitSurface9Grid(src,
                         srcrect,
                         left_width,
                         right_width,
                         top_height,
                         bottom_height,
+                        m_resource,
                         dstrect,
                         scale,
                         scaleMode);
@@ -3591,10 +3775,7 @@
  * for an 8-bpp format).
  *
  * @param surface the surface to use for the pixel format and palette.
- * @param r the red component of the pixel in the range 0-255.
- * @param g the green component of the pixel in the range 0-255.
- * @param b the blue component of the pixel in the range 0-255.
- * @param a the alpha component of the pixel in the range 0-255.
+ * @param c the color components of the pixel in the range 0-255.
  * @returns a pixel value.
  *
  * @threadsafety It is safe to call this function from any thread.
@@ -3605,7 +3786,7 @@
  */
 inline Uint32 MapSurfaceRGBA(SurfaceConstParam surface, ColorRaw c)
 {
-  return SDL_MapSurfaceRGBA(surface, c);
+  return SDL_MapSurfaceRGBA(surface, c.r, c.g, c.b, c.a);
 }
 
 inline Uint32 Surface::MapRGBA(ColorRaw c) const
@@ -3623,8 +3804,7 @@
  * components from pixel formats with less than 8 bits per RGB component.
  *
  * @param surface the surface to read.
- * @param x the horizontal coordinate, 0 <= x < width.
- * @param y the vertical coordinate, 0 <= y < height.
+ * @param p the coordinates, 0 <= x < width and 0 <= y < height.
  * @param r a pointer filled in with the red channel, 0-255, or nullptr to
  *          ignore this channel.
  * @param g a pointer filled in with the green channel, 0-255, or nullptr to
@@ -3646,7 +3826,7 @@
                              Uint8* b,
                              Uint8* a)
 {
-  CheckError(SDL_ReadSurfacePixel(surface, p, r, g, b, a));
+  CheckError(SDL_ReadSurfacePixel(surface, p.x, p.y, r, g, b, a));
 }
 
 /**
@@ -3659,16 +3839,8 @@
  * components from pixel formats with less than 8 bits per RGB component.
  *
  * @param surface the surface to read.
- * @param x the horizontal coordinate, 0 <= x < width.
- * @param y the vertical coordinate, 0 <= y < height.
- * @param r a pointer filled in with the red channel, 0-255, or nullptr to
- *          ignore this channel.
- * @param g a pointer filled in with the green channel, 0-255, or nullptr to
- *          ignore this channel.
- * @param b a pointer filled in with the blue channel, 0-255, or nullptr to
- *          ignore this channel.
- * @param a a pointer filled in with the alpha channel, 0-255, or nullptr to
- *          ignore this channel.
+ * @param p the coordinates, 0 <= x < width and 0 <= y < height.
+ * @returns color on success.
  * @throws Error on failure.
  *
  * @threadsafety This function is not thread safe.
@@ -3677,7 +3849,9 @@
  */
 inline Color ReadSurfacePixel(SurfaceConstParam surface, const PointRaw& p)
 {
-  static_assert(false, "Not implemented");
+  Color c;
+  ReadSurfacePixel(surface, p, &c.r, &c.g, &c.b, &c.a);
+  return c;
 }
 
 inline void Surface::ReadPixel(const PointRaw& p,
@@ -3701,8 +3875,7 @@
  * tests, but is not intended for use in a game engine.
  *
  * @param surface the surface to read.
- * @param x the horizontal coordinate, 0 <= x < width.
- * @param y the vertical coordinate, 0 <= y < height.
+ * @param p the coordinates, 0 <= x < width and 0 <= y < height.
  * @param r a pointer filled in with the red channel, normally in the range 0-1,
  *          or nullptr to ignore this channel.
  * @param g a pointer filled in with the green channel, normally in the range
@@ -3724,7 +3897,7 @@
                                   float* b,
                                   float* a)
 {
-  CheckError(SDL_ReadSurfacePixelFloat(surface, p, r, g, b, a));
+  CheckError(SDL_ReadSurfacePixelFloat(surface, p.x, p.y, r, g, b, a));
 }
 
 /**
@@ -3734,16 +3907,8 @@
  * tests, but is not intended for use in a game engine.
  *
  * @param surface the surface to read.
- * @param x the horizontal coordinate, 0 <= x < width.
- * @param y the vertical coordinate, 0 <= y < height.
- * @param r a pointer filled in with the red channel, normally in the range 0-1,
- *          or nullptr to ignore this channel.
- * @param g a pointer filled in with the green channel, normally in the range
- *          0-1, or nullptr to ignore this channel.
- * @param b a pointer filled in with the blue channel, normally in the range
- *          0-1, or nullptr to ignore this channel.
- * @param a a pointer filled in with the alpha channel, normally in the range
- *          0-1, or nullptr to ignore this channel.
+ * @param p the coordinates, 0 <= x < width and 0 <= y < height.
+ * @returns color on success.
  * @throws Error on failure.
  *
  * @threadsafety This function is not thread safe.
@@ -3753,7 +3918,9 @@
 inline FColor ReadSurfacePixelFloat(SurfaceConstParam surface,
                                     const PointRaw& p)
 {
-  static_assert(false, "Not implemented");
+  FColor c;
+  ReadSurfacePixelFloat(surface, p, &c.r, &c.g, &c.b, &c.a);
+  return c;
 }
 
 inline void Surface::ReadPixelFloat(const PointRaw& p,
@@ -3780,12 +3947,8 @@
  * components from pixel formats with less than 8 bits per RGB component.
  *
  * @param surface the surface to write.
- * @param x the horizontal coordinate, 0 <= x < width.
- * @param y the vertical coordinate, 0 <= y < height.
- * @param r the red channel value, 0-255.
- * @param g the green channel value, 0-255.
- * @param b the blue channel value, 0-255.
- * @param a the alpha channel value, 0-255.
+ * @param p the coordinates, 0 <= x < width, 0 <= y < height.
+ * @param c the color channels value, 0-255.
  * @throws Error on failure.
  *
  * @threadsafety This function is not thread safe.
@@ -3796,7 +3959,7 @@
                               const PointRaw& p,
                               ColorRaw c)
 {
-  CheckError(SDL_WriteSurfacePixel(surface, p, c));
+  CheckError(SDL_WriteSurfacePixel(surface, p.x, p.y, c.r, c.g, c.b, c.a));
 }
 
 inline void Surface::WritePixel(const PointRaw& p, ColorRaw c)
@@ -3811,12 +3974,8 @@
  * tests, but is not intended for use in a game engine.
  *
  * @param surface the surface to write.
- * @param x the horizontal coordinate, 0 <= x < width.
- * @param y the vertical coordinate, 0 <= y < height.
- * @param r the red channel value, normally in the range 0-1.
- * @param g the green channel value, normally in the range 0-1.
- * @param b the blue channel value, normally in the range 0-1.
- * @param a the alpha channel value, normally in the range 0-1.
+ * @param p the coordinates, 0 <= x < width, 0 <= y < height.
+ * @param c the color channels values, normally in the range 0-1.
  * @throws Error on failure.
  *
  * @threadsafety This function is not thread safe.
@@ -3827,7 +3986,7 @@
                                    const PointRaw& p,
                                    const FColorRaw& c)
 {
-  CheckError(SDL_WriteSurfacePixelFloat(surface, p, c));
+  CheckError(SDL_WriteSurfacePixelFloat(surface, p.x, p.y, c.r, c.g, c.b, c.a));
 }
 
 inline void Surface::WritePixelFloat(const PointRaw& p, const FColorRaw& c)
@@ -3835,29 +3994,32 @@
   SDL::WriteSurfacePixelFloat(m_resource, p, c);
 }
 
-constexpr int GetSurfaceWidth(SurfaceConstParam surface)
-{
-  static_assert(false, "Not implemented");
-}
+/**
+ * Get the width in pixels.
+ */
+constexpr int GetSurfaceWidth(SurfaceConstParam surface) { return surface->w; }
 
 constexpr int Surface::GetWidth() const
 {
   return SDL::GetSurfaceWidth(m_resource);
 }
 
-constexpr int GetSurfaceHeight(SurfaceConstParam surface)
-{
-  static_assert(false, "Not implemented");
-}
+/**
+ * Get the height in pixels.
+ */
+constexpr int GetSurfaceHeight(SurfaceConstParam surface) { return surface->h; }
 
 constexpr int Surface::GetHeight() const
 {
   return SDL::GetSurfaceHeight(m_resource);
 }
 
+/**
+ * Get the size in pixels.
+ */
 constexpr Point GetSurfaceSize(SurfaceConstParam surface)
 {
-  static_assert(false, "Not implemented");
+  return Point(surface->w, surface->h);
 }
 
 constexpr Point Surface::GetSize() const
@@ -3865,9 +4027,12 @@
   return SDL::GetSurfaceSize(m_resource);
 }
 
+/**
+ * Get pitch in bytes.
+ */
 constexpr int GetSurfacePitch(SurfaceConstParam surface)
 {
-  static_assert(false, "Not implemented");
+  return surface->pitch;
 }
 
 constexpr int Surface::GetPitch() const
@@ -3875,9 +4040,12 @@
   return SDL::GetSurfacePitch(m_resource);
 }
 
+/**
+ * Get the pixel format.
+ */
 constexpr PixelFormat GetSurfaceFormat(SurfaceConstParam surface)
 {
-  static_assert(false, "Not implemented");
+  return surface->format;
 }
 
 constexpr PixelFormat Surface::GetFormat() const
@@ -3885,9 +4053,12 @@
   return SDL::GetSurfaceFormat(m_resource);
 }
 
+/**
+ * Get the pixels.
+ */
 constexpr void* GetSurfacePixels(SurfaceConstParam surface)
 {
-  static_assert(false, "Not implemented");
+  return surface->pixels;
 }
 
 constexpr void* Surface::GetPixels() const
