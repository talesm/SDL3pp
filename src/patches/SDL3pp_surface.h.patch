--- src/generated/SDL3pp_surface.h
+++ include/SDL3pp/SDL3pp_surface.h
@@ -16,7 +16,7 @@
 namespace SDL {
 
 /**
- * @defgroup CategorySurface Category Surface
+ * @defgroup CategorySurface Surface Creation and Simple Drawing
  *
  * SDL surfaces are buffers of pixels in system RAM. These are useful for
  * passing around and manipulating images that are not stored in GPU memory.
@@ -29,7 +29,8 @@
  * loader, Surface.LoadPNG(). SDL itself does not provide loaders for other file
  * formats, but there are several excellent external libraries that do,
  * including its own satellite library,
- * [SDL_image](https://wiki.libsdl.org/SDL3_image) .
+ * [SDL_image](https://wiki.libsdl.org/SDL3_image).
+ *
  *
  * In general these functions are thread-safe in that they can be called on
  * different threads with different surfaces. You should not try to modify any
@@ -82,7 +83,7 @@
 {
   const SurfaceRaw value; ///< parameter's const SurfaceRaw
 
-  /// Constructs from const SurfaceRaw
+  /// Constructs from SurfaceRaw
   constexpr SurfaceConstParam(const SurfaceRaw value)
     : value(value)
   {
@@ -139,7 +140,7 @@
  *
  * @since This function is available since SDL 3.2.0.
  */
-constexpr bool MustLock(SurfaceConstParam S) const { return SDL_MUSTLOCK(S); }
+constexpr bool MustLock(SurfaceConstParam S) { return SDL_MUSTLOCK((S.value)); }
 
 /**
  * The scaling mode.
@@ -218,8 +219,6 @@
  *
  * @sa Surface.Surface
  * @sa Surface.Destroy
- *
- * @cat resource
  */
 class Surface
 {
@@ -262,11 +261,9 @@
    *
    * The pixels of the new surface are initialized to zero.
    *
-   * @param width the width of the surface.
-   * @param height the height of the surface.
+   * @param size the width and height of the surface.
    * @param format the PixelFormat for the new surface's pixel format.
-   * @post the new Surface structure that is created or nullptr on failure; call
-   *       GetError() for more information.
+   * @throws Error on failure.
    *
    * @threadsafety It is safe to call this function from any thread.
    *
@@ -276,7 +273,7 @@
    * @sa Surface.Destroy
    */
   Surface(const PointRaw& size, PixelFormat format)
-    : m_resource(SDL_CreateSurface(size, format))
+    : m_resource(CheckError(SDL_CreateSurface(size.x, size.y, format)))
   {
   }
 
@@ -293,13 +290,11 @@
    * You may pass nullptr for pixels and 0 for pitch to create a surface that
    * you will fill in with valid values later.
    *
-   * @param width the width of the surface.
-   * @param height the height of the surface.
+   * @param size the width and height of the surface.
    * @param format the PixelFormat for the new surface's pixel format.
    * @param pixels a pointer to existing pixel data.
    * @param pitch the number of bytes between each row, including padding.
-   * @post the new Surface structure that is created or nullptr on failure; call
-   *       GetError() for more information.
+   * @throws Error on failure.
    *
    * @threadsafety It is safe to call this function from any thread.
    *
@@ -309,7 +304,8 @@
    * @sa Surface.Destroy
    */
   Surface(const PointRaw& size, PixelFormat format, void* pixels, int pitch)
-    : m_resource(SDL_CreateSurfaceFrom(size, format, pixels, pitch))
+    : m_resource(CheckError(
+        SDL_CreateSurfaceFrom(size.x, size.y, format, pixels, pitch)))
   {
   }
 
@@ -341,9 +337,6 @@
    * load images directly into an Texture for use by the GPU without using a
    * software surface: call Texture.Texture() instead.
    *
-   * When done with the returned surface, the app should dispose of it with a
-   * call to [Surface.Destroy](https://wiki.libsdl.org/SDL3/Surface.Destroy) ().
-   *
    * @param file a path on the filesystem to load an image from.
    * @post a new SDL surface, or nullptr on error.
    *
@@ -392,9 +385,6 @@
    * load images directly into an Texture for use by the GPU without using a
    * software surface: call Texture.Texture() instead.
    *
-   * When done with the returned surface, the app should dispose of it with a
-   * call to Surface.Destroy().
-   *
    * @param src an IOStream that data will be read from.
    * @param closeio true to close/free the IOStream before returning, false to
    *                leave it open.
@@ -406,7 +396,7 @@
    * @sa LoadSurfaceTyped
    * @sa Surface.Destroy
    */
-  Surface(IOStreamParam src, bool closeio);
+  Surface(IOStreamParam src, bool closeio = false);
 
   /**
    * Safely borrows the from SurfaceParam.
@@ -475,9 +465,6 @@
    * sources. If you want to load arbitrary images you should use libpng or
    * another image loading library designed with security in mind.
    *
-   * The new surface should be freed with Surface.Destroy(). Not doing so will
-   * result in a memory leak.
-   *
    * @param src the data stream for the surface.
    * @param closeio if true, calls IOStream.Close() on `src` before returning,
    *                even in the case of an error.
@@ -494,10 +481,6 @@
    */
   static Surface LoadPNG(IOStreamParam src, bool closeio = false);
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
   /**
    * Load a PNG image from a file.
    *
@@ -629,7 +612,7 @@
    * Setting the colorspace doesn't change the pixels, only how they are
    * interpreted in color operations.
    *
-   * @param colorspace an Colorspace value describing the surface colorspace.
+   * @param colorspace a Colorspace value describing the surface colorspace.
    * @throws Error on failure.
    *
    * @threadsafety This function can be called on different threads with
@@ -735,8 +718,7 @@
    * This function adds a reference to the alternate version, so you should call
    * Surface.Destroy() on the image after this call.
    *
-   * @param image a pointer to an alternate Surface to associate with this
-   *              surface.
+   * @param image an alternate Surface to associate with this surface.
    * @throws Error on failure.
    *
    * @threadsafety This function can be called on different threads with
@@ -771,15 +753,8 @@
    * This returns all versions of a surface, with the surface being queried as
    * the first element in the returned array.
    *
-   * Freeing the array of surfaces does not affect the surfaces in the array.
-   * They are still referenced by the surface being queried and will be cleaned
-   * up normally.
-   *
-   * @param count a pointer filled in with the number of surface pointers
-   *              returned, may be nullptr.
    * @returns a nullptr terminated array of Surface pointers or nullptr on
-   *          failure; call GetError() for more information. This should be
-   *          freed with free() when it is no longer needed.
+   *          failure; call GetError() for more information.
    *
    * @threadsafety This function can be called on different threads with
    *               different surfaces.
@@ -914,10 +889,6 @@
    */
   void SavePNG(IOStreamParam dst, bool closeio = false) const;
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
   /**
    * Save a surface to a file in PNG format.
    *
@@ -980,8 +951,7 @@
    *
    * It is a pixel of the format used by the surface, as generated by MapRGB().
    *
-   * @param enabled true to enable color key, false to disable color key.
-   * @param key the transparent pixel.
+   * @param key the transparent pixel or std::nullopt to disable it.
    * @throws Error on failure.
    *
    * @threadsafety This function can be called on different threads with
@@ -995,13 +965,20 @@
    */
   void SetColorKey(std::optional<Uint32> key);
 
+  /**
+   * Unset the color key (transparent pixel) in a surface.
+   *
+   * The color key defines a pixel value that will be treated as transparent in
+   * a blit. For example, one can use this to specify that cyan pixels should be
+   * considered transparent, and therefore not rendered.
+   *
+   * @throws Error on failure.
+   */
   void ClearColorKey();
 
   /**
    * Returns whether the surface has a color key.
    *
-   * It is safe to pass a nullptr `surface` here; it will return false.
-   *
    * @returns true if the surface has a color key, false otherwise.
    *
    * @threadsafety It is safe to call this function from any thread.
@@ -1021,7 +998,7 @@
    *
    * If the surface doesn't have color key enabled this function returns false.
    *
-   * @param key a pointer filled in with the transparent pixel.
+   * @returns the transparent pixel or nullopt if none.
    * @throws Error on failure.
    *
    * @threadsafety It is safe to call this function from any thread.
@@ -1099,7 +1076,6 @@
   /**
    * Get the additional alpha value used in blit operations.
    *
-   * @param alpha a pointer filled in with the current alpha value.
    * @throws Error on failure.
    *
    * @threadsafety It is safe to call this function from any thread.
@@ -1111,8 +1087,29 @@
    */
   Uint8 GetAlphaMod() const;
 
+  /**
+   * Set an additional color and alpha value multiplied into blit
+   * operations.
+   *
+   * When this surface is blitted, during the blit operation each source color
+   * channel is modulated by the appropriate color value according to the
+   * following formula:
+   *
+   * `srcC = srcC * (color / 255)`
+   * `srcA = srcA * (alpha / 255)`
+   *
+   * @param color the color to be multiplied in blit operations
+   * @throws Error on failure.
+   */
   void SetMod(Color color);
 
+  /**
+   * Get the additional color and alpha value multiplied into blit
+   * operations.
+   *
+   * @returns a Color containing RGBA value on success or std::nullopt on
+   * failure; call GetError() for more information.
+   */
   Color GetMod() const;
 
   /**
@@ -1137,7 +1134,7 @@
   /**
    * Get the blend mode used for blit operations.
    *
-   * @param blendMode a pointer filled in with the current BlendMode.
+   * @returns the current BlendMode.
    * @throws Error on failure.
    *
    * @threadsafety It is safe to call this function from any thread.
@@ -1167,10 +1164,16 @@
    *
    * @since This function is available since SDL 3.2.0.
    *
+   * @sa Surface.ResetClipRect()
    * @sa Surface.GetClipRect
    */
   bool SetClipRect(OptionalRef<const RectRaw> rect);
 
+  /**
+   * Disable the clipping rectangle for a surface.
+   *
+   * @sa SetClipRect()
+   */
   void ResetClipRect();
 
   /**
@@ -1179,8 +1182,8 @@
    * When `surface` is the destination of a blit, only the area within the clip
    * rectangle is drawn into.
    *
-   * @param rect an Rect structure filled in with the clipping rectangle for the
-   *             surface.
+   * @returns the Rect structure filled in with the clipping rectangle for the
+   *          surface on success.
    * @throws Error on failure.
    *
    * @threadsafety This function can be called on different threads with
@@ -1243,8 +1246,6 @@
    * If the original surface has alternate images, the new surface will have a
    * reference to them as well.
    *
-   * The returned surface should be freed with Surface.Destroy().
-   *
    * @returns a copy of the surface or nullptr on failure; call GetError() for
    *          more information.
    *
@@ -1261,10 +1262,7 @@
    * Creates a new surface identical to the existing surface, scaled to the
    * desired size.
    *
-   * The returned surface should be freed with Surface.Destroy().
-   *
-   * @param width the width of the new surface.
-   * @param height the height of the new surface.
+   * @param size the width and height of the new surface.
    * @param scaleMode the ScaleMode to be used.
    * @returns a copy of the surface or nullptr on failure; call GetError() for
    *          more information.
@@ -1362,10 +1360,7 @@
    * If the surface is YUV, the color is assumed to be in the sRGB colorspace,
    * otherwise the color is assumed to be in the colorspace of the surface.
    *
-   * @param r the red component of the pixel, normally in the range 0-1.
-   * @param g the green component of the pixel, normally in the range 0-1.
-   * @param b the blue component of the pixel, normally in the range 0-1.
-   * @param a the alpha component of the pixel, normally in the range 0-1.
+   * @param c the color components of the pixel, normally in the range 0-1.
    * @throws Error on failure.
    *
    * @threadsafety This function can be called on different threads with
@@ -1401,6 +1396,16 @@
    */
   void FillRect(OptionalRef<const RectRaw> rect, Uint32 color);
 
+  /**
+   * Perform a fast fill of a rectangle with a specific color.
+   *
+   * If there is a clip rectangle set on the destination (set via
+   * Surface.SetClipRect()), then this function will fill based on the
+   * intersection of the clip rectangle and `rect`.
+   *
+   * @param color the color to fill with.
+   * @throws Error on failure.
+   */
   void Fill(Uint32 color);
 
   /**
@@ -1416,7 +1421,6 @@
    * intersection of the clip rectangle and `rect`.
    *
    * @param rects an array of SDL_Rects representing the rectangles to fill.
-   * @param count the number of rectangles in the array.
    * @param color the color to fill with.
    * @throws Error on failure.
    *
@@ -1481,9 +1485,9 @@
    *       source color key.
    * ```
    *
+   * @param src the SurfaceRaw structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be copied,
    *                or nullptr to copy the entire surface.
-   * @param dst the Surface structure that is the blit target.
    * @param dstrect the Rect structure representing the x and y position in the
    *                destination surface, or nullptr for (0,0). The width and
    *                height are ignored, and are copied from `srcrect`. If you
@@ -1502,6 +1506,76 @@
             OptionalRef<const RectRaw> srcrect,
             OptionalRef<const RectRaw> dstrect);
 
+  /**
+   * Performs a fast blit from the source surface to the destination surface
+   * with clipping.
+   *
+   * If either `srcrect` or `dstrect` are nullptr, the entire surface (`src` or
+   * `dst`) is copied while ensuring clipping to `dst->clip_rect`.
+   *
+   * The blit function should not be called on a locked surface.
+   *
+   * The blit semantics for surfaces with and without blending and colorkey are
+   * defined as follows:
+   *
+   * ```
+   *    RGBA->RGB:
+   *      Source surface blend mode set to BLENDMODE_BLEND:
+   *       alpha-blend (using the source alpha-channel and per-surface alpha)
+   *       SDL_SRCCOLORKEY ignored.
+   *     Source surface blend mode set to BLENDMODE_NONE:
+   *       copy RGB.
+   *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+   *       RGB values of the source color key, ignoring alpha in the
+   *       comparison.
+   *
+   *   RGB->RGBA:
+   *     Source surface blend mode set to BLENDMODE_BLEND:
+   *       alpha-blend (using the source per-surface alpha)
+   *     Source surface blend mode set to BLENDMODE_NONE:
+   *       copy RGB, set destination alpha to source per-surface alpha value.
+   *     both:
+   *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+   *       source color key.
+   *
+   *   RGBA->RGBA:
+   *     Source surface blend mode set to BLENDMODE_BLEND:
+   *       alpha-blend (using the source alpha-channel and per-surface alpha)
+   *       SDL_SRCCOLORKEY ignored.
+   *     Source surface blend mode set to BLENDMODE_NONE:
+   *       copy all of RGBA to the destination.
+   *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+   *       RGB values of the source color key, ignoring alpha in the
+   *       comparison.
+   *
+   *   RGB->RGB:
+   *     Source surface blend mode set to BLENDMODE_BLEND:
+   *       alpha-blend (using the source per-surface alpha)
+   *     Source surface blend mode set to BLENDMODE_NONE:
+   *       copy RGB.
+   *     both:
+   *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+   *       source color key.
+   * ```
+   *
+   * @param src the SurfaceRaw structure to be copied from.
+   * @param srcrect the Rect structure representing the rectangle to be
+   *                copied, or nullptr to copy the entire surface.
+   * @param dstpos the Point structure representing the x and y position in
+   *                the destination surface, or nullptr for (0,0). The width and
+   *                height are ignored, and are copied from `srcrect`. If you
+   *                want a specific width and height, you should use
+   *                Surface.BlitScaled().
+   * @throws Error on failure.
+   *
+   * @threadsafety Only one thread should be using the `src` and `dst` surfaces
+   *               at any given time.
+   *
+   * @since This function is available since SDL 3.2.0.
+   *
+   * @sa Surface.Blit
+   * @sa Surface.BlitScaled
+   */
   void BlitAt(SurfaceParam src,
               OptionalRef<const RectRaw> srcrect,
               const PointRaw& dstpos);
@@ -1512,9 +1586,9 @@
    * This is a semi-private blit function and it performs low-level surface
    * blitting, assuming the input rectangles have already been clipped.
    *
+   * @param src the Surface structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be copied,
    *                may not be nullptr.
-   * @param dst the Surface structure that is the blit target.
    * @param dstrect the Rect structure representing the target rectangle in the
    *                destination surface, may not be nullptr.
    * @throws Error on failure.
@@ -1534,9 +1608,9 @@
    * Perform a scaled blit to a destination surface, which may be of a different
    * format.
    *
+   * @param src the Surface structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be copied,
    *                or nullptr to copy the entire surface.
-   * @param dst the Surface structure that is the blit target.
    * @param dstrect the Rect structure representing the target rectangle in the
    *                destination surface, or nullptr to fill the entire
    *                destination surface.
@@ -1561,9 +1635,9 @@
    * This is a semi-private function and it performs low-level surface blitting,
    * assuming the input rectangles have already been clipped.
    *
+   * @param src the Surface structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be copied,
    *                may not be nullptr.
-   * @param dst the Surface structure that is the blit target.
    * @param dstrect the Rect structure representing the target rectangle in the
    *                destination surface, may not be nullptr.
    * @param scaleMode the ScaleMode to be used.
@@ -1586,9 +1660,9 @@
   /**
    * Perform a stretched pixel copy from one surface to another.
    *
+   * @param src the Surface structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be copied,
    *                or nullptr to copy the entire surface.
-   * @param dst the Surface structure that is the blit target.
    * @param dstrect the Rect structure representing the target rectangle in the
    *                destination surface, or nullptr to fill the entire
    *                destination surface.
@@ -1616,9 +1690,9 @@
    * The pixels in `srcrect` will be repeated as many times as needed to
    * completely fill `dstrect`.
    *
+   * @param src the SDL_Surface structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be copied,
    *                or nullptr to copy the entire surface.
-   * @param dst the Surface structure that is the blit target.
    * @param dstrect the Rect structure representing the target rectangle in the
    *                destination surface, or nullptr to fill the entire surface.
    * @throws Error on failure.
@@ -1641,13 +1715,13 @@
    * The pixels in `srcrect` will be scaled and repeated as many times as needed
    * to completely fill `dstrect`.
    *
+   * @param src the SDL_Surface structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be copied,
    *                or nullptr to copy the entire surface.
    * @param scale the scale used to transform srcrect into the destination
    *              rectangle, e.g. a 32x32 texture with a scale of 2 would fill
    *              64x64 tiles.
    * @param scaleMode scale algorithm to be used.
-   * @param dst the Surface structure that is the blit target.
    * @param dstrect the Rect structure representing the target rectangle in the
    *                destination surface, or nullptr to fill the entire surface.
    * @throws Error on failure.
@@ -1675,6 +1749,7 @@
    * into the corners of the destination rectangle. The sides and center are
    * then stretched into place to cover the remaining destination rectangle.
    *
+   * @param src the SDL_Surface structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be used for
    *                the 9-grid, or nullptr to use the entire surface.
    * @param left_width the width, in pixels, of the left corners in `srcrect`.
@@ -1682,12 +1757,11 @@
    * @param top_height the height, in pixels, of the top corners in `srcrect`.
    * @param bottom_height the height, in pixels, of the bottom corners in
    *                      `srcrect`.
+   * @param dstrect the Rect structure representing the target rectangle in the
+   *                destination surface, or nullptr to fill the entire surface.
    * @param scale the scale used to transform the corner of `srcrect` into the
    *              corner of `dstrect`, or 0.0f for an unscaled blit.
    * @param scaleMode scale algorithm to be used.
-   * @param dst the Surface structure that is the blit target.
-   * @param dstrect the Rect structure representing the target rectangle in the
-   *                destination surface, or nullptr to fill the entire surface.
    * @throws Error on failure.
    *
    * @threadsafety Only one thread should be using the `src` and `dst` surfaces
@@ -1757,10 +1831,7 @@
    * format the return value can be assigned to a Uint16, and similarly a Uint8
    * for an 8-bpp format).
    *
-   * @param r the red component of the pixel in the range 0-255.
-   * @param g the green component of the pixel in the range 0-255.
-   * @param b the blue component of the pixel in the range 0-255.
-   * @param a the alpha component of the pixel in the range 0-255.
+   * @param c the color components of the pixel in the range 0-255.
    * @returns a pixel value.
    *
    * @threadsafety This function can be called on different threads with
@@ -1781,8 +1852,7 @@
    * Like GetRGBA, this uses the entire 0..255 range when converting color
    * components from pixel formats with less than 8 bits per RGB component.
    *
-   * @param x the horizontal coordinate, 0 <= x < width.
-   * @param y the vertical coordinate, 0 <= y < height.
+   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
    * @param r a pointer filled in with the red channel, 0-255, or nullptr to
    *          ignore this channel.
    * @param g a pointer filled in with the green channel, 0-255, or nullptr to
@@ -1810,19 +1880,8 @@
    * This function prioritizes correctness over speed: it is suitable for unit
    * tests, but is not intended for use in a game engine.
    *
-   * Like GetRGBA, this uses the entire 0..255 range when converting color
-   * components from pixel formats with less than 8 bits per RGB component.
-   *
-   * @param x the horizontal coordinate, 0 <= x < width.
-   * @param y the vertical coordinate, 0 <= y < height.
-   * @param r a pointer filled in with the red channel, 0-255, or nullptr to
-   *          ignore this channel.
-   * @param g a pointer filled in with the green channel, 0-255, or nullptr to
-   *          ignore this channel.
-   * @param b a pointer filled in with the blue channel, 0-255, or nullptr to
-   *          ignore this channel.
-   * @param a a pointer filled in with the alpha channel, 0-255, or nullptr to
-   *          ignore this channel.
+   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
+   * @returns color on success.
    * @throws Error on failure.
    *
    * @threadsafety This function can be called on different threads with
@@ -1838,8 +1897,7 @@
    * This function prioritizes correctness over speed: it is suitable for unit
    * tests, but is not intended for use in a game engine.
    *
-   * @param x the horizontal coordinate, 0 <= x < width.
-   * @param y the vertical coordinate, 0 <= y < height.
+   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
    * @param r a pointer filled in with the red channel, normally in the range
    *          0-1, or nullptr to ignore this channel.
    * @param g a pointer filled in with the green channel, normally in the range
@@ -1867,16 +1925,8 @@
    * This function prioritizes correctness over speed: it is suitable for unit
    * tests, but is not intended for use in a game engine.
    *
-   * @param x the horizontal coordinate, 0 <= x < width.
-   * @param y the vertical coordinate, 0 <= y < height.
-   * @param r a pointer filled in with the red channel, normally in the range
-   *          0-1, or nullptr to ignore this channel.
-   * @param g a pointer filled in with the green channel, normally in the range
-   *          0-1, or nullptr to ignore this channel.
-   * @param b a pointer filled in with the blue channel, normally in the range
-   *          0-1, or nullptr to ignore this channel.
-   * @param a a pointer filled in with the alpha channel, normally in the range
-   *          0-1, or nullptr to ignore this channel.
+   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
+   * @returns color on success.
    * @throws Error on failure.
    *
    * @threadsafety This function can be called on different threads with
@@ -1895,12 +1945,8 @@
    * Like MapColor, this uses the entire 0..255 range when converting color
    * components from pixel formats with less than 8 bits per RGB component.
    *
-   * @param x the horizontal coordinate, 0 <= x < width.
-   * @param y the vertical coordinate, 0 <= y < height.
-   * @param r the red channel value, 0-255.
-   * @param g the green channel value, 0-255.
-   * @param b the blue channel value, 0-255.
-   * @param a the alpha channel value, 0-255.
+   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
+   * @param c the color values, 0-255.
    * @throws Error on failure.
    *
    * @threadsafety This function can be called on different threads with
@@ -1916,12 +1962,8 @@
    * This function prioritizes correctness over speed: it is suitable for unit
    * tests, but is not intended for use in a game engine.
    *
-   * @param x the horizontal coordinate, 0 <= x < width.
-   * @param y the vertical coordinate, 0 <= y < height.
-   * @param r the red channel value, normally in the range 0-1.
-   * @param g the green channel value, normally in the range 0-1.
-   * @param b the blue channel value, normally in the range 0-1.
-   * @param a the alpha channel value, normally in the range 0-1.
+   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
+   * @param c the color values, normally in the range 0-1.
    * @throws Error on failure.
    *
    * @threadsafety This function can be called on different threads with
@@ -1931,16 +1973,22 @@
    */
   void WritePixelFloat(const PointRaw& p, const FColorRaw& c);
 
+  /// Get the width in pixels.
   constexpr int GetWidth() const;
 
+  /// Get the height in pixels.
   constexpr int GetHeight() const;
 
+  /// Get the size in pixels.
   constexpr Point GetSize() const;
 
+  /// Get pitch in bytes.
   constexpr int GetPitch() const;
 
+  /// Get the pixel format.
   constexpr PixelFormat GetFormat() const;
 
+  /// Get the pixels.
   constexpr void* GetPixels() const;
 };
 
@@ -1967,8 +2015,7 @@
  *
  * The pixels of the new surface are initialized to zero.
  *
- * @param width the width of the surface.
- * @param height the height of the surface.
+ * @param size the width and height of the surface.
  * @param format the PixelFormat for the new surface's pixel format.
  * @returns the new Surface structure that is created or nullptr on failure;
  *          call GetError() for more information.
@@ -1997,8 +2044,7 @@
  * You may pass nullptr for pixels and 0 for pitch to create a surface that you
  * will fill in with valid values later.
  *
- * @param width the width of the surface.
- * @param height the height of the surface.
+ * @param size the width and height of the surface.
  * @param format the PixelFormat for the new surface's pixel format.
  * @param pixels a pointer to existing pixel data.
  * @param pitch the number of bytes between each row, including padding.
@@ -2077,7 +2123,7 @@
  */
 inline PropertiesRef GetSurfaceProperties(SurfaceConstParam surface)
 {
-  return CheckError(SDL_GetSurfaceProperties(surface));
+  return {CheckError(SDL_GetSurfaceProperties(surface))};
 }
 
 inline PropertiesRef Surface::GetProperties() const
@@ -2098,10 +2144,6 @@
 
 constexpr auto HOTSPOT_X_NUMBER = SDL_PROP_SURFACE_HOTSPOT_X_NUMBER;
 
-#endif // SDL_VERSION_ATLEAST(3, 2, 6)
-
-#if SDL_VERSION_ATLEAST(3, 2, 6)
-
 constexpr auto HOTSPOT_Y_NUMBER = SDL_PROP_SURFACE_HOTSPOT_Y_NUMBER;
 
 #endif // SDL_VERSION_ATLEAST(3, 2, 6)
@@ -2198,7 +2240,7 @@
  */
 inline Palette CreateSurfacePalette(SurfaceParam surface)
 {
-  return CheckError(SDL_CreateSurfacePalette(surface));
+  return Palette::Borrow(CheckError(SDL_CreateSurfacePalette(surface)));
 }
 
 inline Palette Surface::CreatePalette()
@@ -2251,7 +2293,7 @@
  */
 inline Palette GetSurfacePalette(SurfaceConstParam surface)
 {
-  return SDL_GetSurfacePalette(surface);
+  return Palette::Borrow(SDL_GetSurfacePalette(surface));
 }
 
 inline Palette Surface::GetPalette() const
@@ -2329,11 +2371,8 @@
  * normally.
  *
  * @param surface the Surface structure to query.
- * @param count a pointer filled in with the number of surface pointers
- *              returned, may be nullptr.
  * @returns a nullptr terminated array of Surface pointers or nullptr on
- *          failure; call GetError() for more information. This should be freed
- *          with free() when it is no longer needed.
+ *          failure; call GetError() for more information.
  *
  * @threadsafety This function can be called on different threads with different
  *               surfaces.
@@ -2346,7 +2385,9 @@
  */
 inline OwnArray<SurfaceRaw> GetSurfaceImages(SurfaceConstParam surface)
 {
-  return SDL_GetSurfaceImages(surface);
+  int count = 0;
+  auto data = SDL_GetSurfaceImages(surface, &count);
+  return OwnArray<SurfaceRaw>(CheckError(data), count);
 }
 
 inline OwnArray<SurfaceRaw> Surface::GetImages() const
@@ -2389,7 +2430,7 @@
  * Once you are done accessing the surface, you should use Surface.Unlock() to
  * release it.
  *
- * Not all surfaces require locking. If `Surface.MustLock(surface)` evaluates to
+ * Not all surfaces require locking. If `Surface.MustLock()` evaluates to
  * 0, then you can read and write to the surface at any time, and the pixel
  * format of the surface will not change.
  *
@@ -2430,6 +2471,7 @@
 
 inline void Surface::Unlock() { SDL::UnlockSurface(m_resource); }
 
+#ifndef SDL3PP_ENABLE_IMAGE
 #if SDL_VERSION_ATLEAST(3, 4, 0)
 
 /**
@@ -2453,13 +2495,9 @@
  */
 inline Surface LoadSurface(IOStreamParam src, bool closeio = false)
 {
-  return SDL_LoadSurface_IO(src, closeio);
+  return Surface{SDL_LoadSurface_IO(src, closeio)};
 }
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
 /**
  * Load a BMP or PNG image from a file.
  *
@@ -2477,9 +2515,12 @@
  * @sa Surface.Destroy
  * @sa LoadSurface
  */
-inline Surface LoadSurface(StringParam file) { return SDL_LoadSurface(file); }
-
+inline Surface LoadSurface(StringParam file)
+{
+  return Surface{SDL_LoadSurface(file)};
+}
 #endif // SDL_VERSION_ATLEAST(3, 4, 0)
+#endif // SDL3PP_ENABLE_IMAGE
 
 /**
  * Load a BMP image from a seekable SDL data stream.
@@ -2633,10 +2674,6 @@
   return Surface(SDL_LoadPNG_IO(src, closeio));
 }
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
 /**
  * Load a PNG image from a file.
  *
@@ -2661,28 +2698,16 @@
  */
 inline Surface LoadPNG(StringParam file) { return Surface(SDL_LoadPNG(file)); }
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
 inline Surface Surface::LoadPNG(IOStreamParam src, bool closeio)
 {
   return SDL::LoadPNG(src, closeio);
 }
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
 inline Surface Surface::LoadPNG(StringParam file)
 {
   return SDL::LoadPNG(std::move(file));
 }
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
 /**
  * Save a surface to a seekable SDL data stream in PNG format.
  *
@@ -2707,10 +2732,6 @@
   CheckError(SDL_SavePNG_IO(surface, dst, closeio));
 }
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
 /**
  * Save a surface to a file in PNG format.
  *
@@ -2731,19 +2752,11 @@
   CheckError(SDL_SavePNG(surface, file));
 }
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
 inline void Surface::SavePNG(IOStreamParam dst, bool closeio) const
 {
   SDL::SavePNG(m_resource, dst, closeio);
 }
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
 inline void Surface::SavePNG(StringParam file) const
 {
   SDL::SavePNG(m_resource, std::move(file));
@@ -2811,8 +2824,7 @@
  * It is a pixel of the format used by the surface, as generated by MapRGB().
  *
  * @param surface the Surface structure to update.
- * @param enabled true to enable color key, false to disable color key.
- * @param key the transparent pixel.
+ * @param key the transparent pixel or std::nullopt to disable it.
  * @throws Error on failure.
  *
  * @threadsafety This function can be called on different threads with different
@@ -2826,7 +2838,7 @@
  */
 inline void SetSurfaceColorKey(SurfaceParam surface, std::optional<Uint32> key)
 {
-  CheckError(SDL_SetSurfaceColorKey(surface, key));
+  CheckError(SDL_SetSurfaceColorKey(surface, key.has_value(), key.value_or(0)));
 }
 
 inline void Surface::SetColorKey(std::optional<Uint32> key)
@@ -2834,9 +2846,19 @@
   SDL::SetSurfaceColorKey(m_resource, key);
 }
 
+/**
+ * Unset the color key (transparent pixel) in a surface.
+ *
+ * The color key defines a pixel value that will be treated as transparent in
+ * a blit. For example, one can use this to specify that cyan pixels should be
+ * considered transparent, and therefore not rendered.
+ *
+ * @param surface the Surface structure to update.
+ * @throws Error on failure.
+ */
 inline void ClearSurfaceColorKey(SurfaceParam surface)
 {
-  static_assert(false, "Not implemented");
+  SetSurfaceColorKey(surface, std::nullopt);
 }
 
 inline void Surface::ClearColorKey() { SDL::ClearSurfaceColorKey(m_resource); }
@@ -2875,7 +2897,7 @@
  * If the surface doesn't have color key enabled this function returns false.
  *
  * @param surface the Surface structure to query.
- * @param key a pointer filled in with the transparent pixel.
+ * @returns the transparent pixel or nullopt if none.
  * @throws Error on failure.
  *
  * @threadsafety It is safe to call this function from any thread.
@@ -2887,7 +2909,8 @@
  */
 inline std::optional<Uint32> GetSurfaceColorKey(SurfaceConstParam surface)
 {
-  return CheckError(SDL_GetSurfaceColorKey(surface));
+  if (Uint32 key; SDL_GetSurfaceColorKey(surface, &key)) return key;
+  return std::nullopt;
 }
 
 inline std::optional<Uint32> Surface::GetColorKey() const
@@ -2992,7 +3015,7 @@
  * Get the additional alpha value used in blit operations.
  *
  * @param surface the Surface structure to query.
- * @param alpha a pointer filled in with the current alpha value.
+ * @returns the current alpha value.
  * @throws Error on failure.
  *
  * @threadsafety It is safe to call this function from any thread.
@@ -3004,7 +3027,9 @@
  */
 inline Uint8 GetSurfaceAlphaMod(SurfaceConstParam surface)
 {
-  return CheckError(SDL_GetSurfaceAlphaMod(surface));
+  Uint8 alpha;
+  CheckError(SDL_GetSurfaceAlphaMod(surface, &alpha));
+  return alpha;
 }
 
 inline Uint8 Surface::GetAlphaMod() const
@@ -3012,19 +3037,43 @@
   return SDL::GetSurfaceAlphaMod(m_resource);
 }
 
+/**
+ * Set an additional color and alpha value multiplied into blit
+ * operations.
+ *
+ * When this surface is blitted, during the blit operation each source color
+ * channel is modulated by the appropriate color value according to the
+ * following formula:
+ *
+ * `srcC = srcC * (color / 255)`
+ * `srcA = srcA * (alpha / 255)`
+ *
+ * @param surface the Surface structure to query.
+ * @param color the color to be multiplied in blit operations
+ * @throws Error on failure.
+ */
 inline void SetSurfaceMod(SurfaceParam surface, Color color)
 {
-  static_assert(false, "Not implemented");
+  SetSurfaceColorMod(surface, color.r, color.g, color.b);
+  SetSurfaceAlphaMod(surface, color.a);
 }
 
-inline void Surface::SetMod(Color color)
-{
-  SDL::SetSurfaceMod(m_resource, color);
-}
+inline void Surface::SetMod(Color color) { SetSurfaceMod(m_resource, color); }
 
+/**
+ * Get the additional color and alpha value multiplied into blit
+ * operations.
+ *
+ * @param surface the Surface structure to query.
+ * @returns a Color containing RGBA value on success or std::nullopt on
+ * failure; call GetError() for more information.
+ */
 inline Color GetSurfaceMod(SurfaceConstParam surface)
 {
-  static_assert(false, "Not implemented");
+  Color c;
+  GetSurfaceColorMod(surface, &c.r, &c.g, &c.b);
+  c.a = GetSurfaceAlphaMod(surface);
+  return c;
 }
 
 inline Color Surface::GetMod() const { return SDL::GetSurfaceMod(m_resource); }
@@ -3061,7 +3110,7 @@
  * Get the blend mode used for blit operations.
  *
  * @param surface the Surface structure to query.
- * @param blendMode a pointer filled in with the current BlendMode.
+ * @returns the current BlendMode.
  * @throws Error on failure.
  *
  * @threadsafety It is safe to call this function from any thread.
@@ -3072,7 +3121,9 @@
  */
 inline BlendMode GetSurfaceBlendMode(SurfaceConstParam surface)
 {
-  return CheckError(SDL_GetSurfaceBlendMode(surface));
+  BlendMode blendmode;
+  CheckError(SDL_GetSurfaceBlendMode(surface, &blendmode));
+  return blendmode;
 }
 
 inline BlendMode Surface::GetBlendMode() const
@@ -3113,9 +3164,14 @@
   return SDL::SetSurfaceClipRect(m_resource, rect);
 }
 
+/**
+ * Disable the clipping rectangle for a surface.
+ *
+ * @sa SetSurfaceClipRect()
+ */
 inline void ResetSurfaceClipRect(SurfaceParam surface)
 {
-  static_assert(false, "Not implemented");
+  SetSurfaceClipRect(surface, std::nullopt);
 }
 
 inline void Surface::ResetClipRect() { SDL::ResetSurfaceClipRect(m_resource); }
@@ -3127,8 +3183,8 @@
  * rectangle is drawn into.
  *
  * @param surface the Surface structure representing the surface to be clipped.
- * @param rect an Rect structure filled in with the clipping rectangle for the
- *             surface.
+ * @returns the Rect structure filled in with the clipping rectangle for the
+ *          surface.
  * @throws Error on failure.
  *
  * @threadsafety This function can be called on different threads with different
@@ -3140,7 +3196,9 @@
  */
 inline Rect GetSurfaceClipRect(SurfaceConstParam surface)
 {
-  return CheckError(SDL_GetSurfaceClipRect(surface));
+  Rect r;
+  CheckError(SDL_GetSurfaceClipRect(surface, &r));
+  return r;
 }
 
 inline Rect Surface::GetClipRect() const
@@ -3198,13 +3256,9 @@
  */
 inline Surface RotateSurface(SurfaceParam surface, float angle)
 {
-  return SDL_RotateSurface(surface, angle);
+  return Surface{SDL_RotateSurface(surface, angle)};
 }
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
 inline Surface Surface::Rotate(float angle)
 {
   return SDL::RotateSurface(m_resource, angle);
@@ -3233,7 +3287,7 @@
  */
 inline Surface DuplicateSurface(SurfaceConstParam surface)
 {
-  return SDL_DuplicateSurface(surface);
+  return Surface(SDL_DuplicateSurface(surface));
 }
 
 inline Surface Surface::Duplicate() const
@@ -3248,8 +3302,7 @@
  * The returned surface should be freed with Surface.Destroy().
  *
  * @param surface the surface to duplicate and scale.
- * @param width the width of the new surface.
- * @param height the height of the new surface.
+ * @param size the width and height of the surface.
  * @param scaleMode the ScaleMode to be used.
  * @returns a copy of the surface or nullptr on failure; call GetError() for
  *          more information.
@@ -3265,7 +3318,7 @@
                             const PointRaw& size,
                             ScaleMode scaleMode)
 {
-  return SDL_ScaleSurface(surface, size, scaleMode);
+  return Surface(SDL_ScaleSurface(surface, size.x, size.y, scaleMode));
 }
 
 inline Surface Surface::Scale(const PointRaw& size, ScaleMode scaleMode) const
@@ -3302,7 +3355,7 @@
  */
 inline Surface ConvertSurface(SurfaceConstParam surface, PixelFormat format)
 {
-  return SDL_ConvertSurface(surface, format);
+  return Surface(SDL_ConvertSurface(surface, format));
 }
 
 inline Surface Surface::Convert(PixelFormat format) const
@@ -3310,15 +3363,6 @@
   return SDL::ConvertSurface(m_resource, format);
 }
 
-inline Surface Surface::Convert(PixelFormat format,
-                                PaletteParam palette,
-                                Colorspace colorspace,
-                                PropertiesParam props) const
-{
-  return SDL::ConvertSurfaceAndColorspace(
-    m_resource, format, palette, colorspace, props);
-}
-
 /**
  * Copy an existing surface to a new surface of the specified format and
  * colorspace.
@@ -3353,15 +3397,23 @@
                                            Colorspace colorspace,
                                            PropertiesParam props)
 {
-  return SDL_ConvertSurfaceAndColorspace(
-    surface, format, palette, colorspace, props);
+  return Surface{SDL_ConvertSurfaceAndColorspace(
+    surface, format, palette, colorspace, props)};
+}
+
+inline Surface Surface::Convert(PixelFormat format,
+                                PaletteParam palette,
+                                Colorspace colorspace,
+                                PropertiesParam props) const
+{
+  return SDL::ConvertSurfaceAndColorspace(
+    m_resource, format, palette, colorspace, props);
 }
 
 /**
  * Copy a block of pixels of one format to another format.
  *
- * @param width the width of the block to copy, in pixels.
- * @param height the height of the block to copy, in pixels.
+ * @param size the width and height of the surface.
  * @param src_format an PixelFormat value of the `src` pixels format.
  * @param src a pointer to the source pixels.
  * @param src_pitch the pitch of the source pixels, in bytes.
@@ -3387,15 +3439,14 @@
                           int dst_pitch)
 {
   CheckError(SDL_ConvertPixels(
-    size, src_format, src, src_pitch, dst_format, dst, dst_pitch));
+    size.x, size.y, src_format, src, src_pitch, dst_format, dst, dst_pitch));
 }
 
 /**
  * Copy a block of pixels of one format and colorspace to another format and
  * colorspace.
  *
- * @param width the width of the block to copy, in pixels.
- * @param height the height of the block to copy, in pixels.
+ * @param size the width and height  of the block to copy, in pixels.
  * @param src_format an PixelFormat value of the `src` pixels format.
  * @param src_colorspace an Colorspace value describing the colorspace of the
  *                       `src` pixels.
@@ -3432,7 +3483,8 @@
                                        void* dst,
                                        int dst_pitch)
 {
-  CheckError(SDL_ConvertPixelsAndColorspace(size,
+  CheckError(SDL_ConvertPixelsAndColorspace(size.x,
+                                            size.y,
                                             src_format,
                                             src_colorspace,
                                             src_properties,
@@ -3450,8 +3502,7 @@
  *
  * This is safe to use with src == dst, but not for other overlapping areas.
  *
- * @param width the width of the block to convert, in pixels.
- * @param height the height of the block to convert, in pixels.
+ * @param size the width and height of the surface.
  * @param src_format an PixelFormat value of the `src` pixels format.
  * @param src a pointer to the source pixels.
  * @param src_pitch the pitch of the source pixels, in bytes.
@@ -3477,8 +3528,15 @@
                              int dst_pitch,
                              bool linear)
 {
-  CheckError(SDL_PremultiplyAlpha(
-    size, src_format, src, src_pitch, dst_format, dst, dst_pitch, linear));
+  CheckError(SDL_PremultiplyAlpha(size.x,
+                                  size.y,
+                                  src_format,
+                                  src,
+                                  src_pitch,
+                                  dst_format,
+                                  dst,
+                                  dst_pitch,
+                                  linear));
 }
 
 /**
@@ -3515,10 +3573,7 @@
  * otherwise the color is assumed to be in the colorspace of the surface.
  *
  * @param surface the Surface to clear.
- * @param r the red component of the pixel, normally in the range 0-1.
- * @param g the green component of the pixel, normally in the range 0-1.
- * @param b the blue component of the pixel, normally in the range 0-1.
- * @param a the alpha component of the pixel, normally in the range 0-1.
+ * @param c the color components of the pixel, normally in the range 0-1.
  * @throws Error on failure.
  *
  * @threadsafety This function can be called on different threads with different
@@ -3528,7 +3583,7 @@
  */
 inline void ClearSurface(SurfaceParam surface, const FColorRaw& c)
 {
-  CheckError(SDL_ClearSurface(surface, c));
+  CheckError(SDL_ClearSurface(surface, c.r, c.g, c.b, c.a));
 }
 
 inline void Surface::Clear(const FColorRaw& c)
@@ -3573,9 +3628,20 @@
   SDL::FillSurfaceRect(m_resource, rect, color);
 }
 
+/**
+ * Perform a fast fill of a rectangle with a specific color.
+ *
+ * If there is a clip rectangle set on the destination (set via
+ * Surface.SetClipRect()), then this function will fill based on the
+ * intersection of the clip rectangle and `rect`.
+ *
+ * @param dst the Surface structure that is the drawing target.
+ * @param color the color to fill with.
+ * @throws Error on failure.
+ */
 inline void FillSurface(SurfaceParam dst, Uint32 color)
 {
-  static_assert(false, "Not implemented");
+  FillSurfaceRect(dst, std::nullopt, color);
 }
 
 inline void Surface::Fill(Uint32 color) { SDL::FillSurface(m_resource, color); }
@@ -3594,7 +3660,6 @@
  *
  * @param dst the Surface structure that is the drawing target.
  * @param rects an array of SDL_Rects representing the rectangles to fill.
- * @param count the number of rectangles in the array.
  * @param color the color to fill with.
  * @throws Error on failure.
  *
@@ -3609,7 +3674,7 @@
                              SpanRef<const RectRaw> rects,
                              Uint32 color)
 {
-  CheckError(SDL_FillSurfaceRects(dst, rects, color));
+  CheckError(SDL_FillSurfaceRects(dst, rects.data(), rects.size(), color));
 }
 
 inline void Surface::FillRects(SpanRef<const RectRaw> rects, Uint32 color)
@@ -3699,22 +3764,89 @@
                           OptionalRef<const RectRaw> srcrect,
                           OptionalRef<const RectRaw> dstrect)
 {
-  SDL::BlitSurface(m_resource, src, srcrect, dstrect);
+  SDL::BlitSurface(src, srcrect, m_resource, dstrect);
 }
 
 inline void Surface::BlitAt(SurfaceParam src,
                             OptionalRef<const RectRaw> srcrect,
                             const PointRaw& dstpos)
 {
-  static_assert(false, "Not implemented");
+  Blit(src, srcrect, Rect{dstpos, {}});
 }
 
+/**
+ * Performs a fast blit from the source surface to the destination surface
+ * with clipping.
+ *
+ * If either `srcrect` or `dstrect` are nullptr, the entire surface (`src` or
+ * `dst`) is copied while ensuring clipping to `dst->clip_rect`.
+ *
+ * The blit function should not be called on a locked surface.
+ *
+ * The blit semantics for surfaces with and without blending and colorkey are
+ * defined as follows:
+ *
+ * ```
+ *    RGBA->RGB:
+ *      Source surface blend mode set to BLENDMODE_BLEND:
+ *       alpha-blend (using the source alpha-channel and per-surface alpha)
+ *       SDL_SRCCOLORKEY ignored.
+ *     Source surface blend mode set to BLENDMODE_NONE:
+ *       copy RGB.
+ *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+ *       RGB values of the source color key, ignoring alpha in the
+ *       comparison.
+ *
+ *   RGB->RGBA:
+ *     Source surface blend mode set to BLENDMODE_BLEND:
+ *       alpha-blend (using the source per-surface alpha)
+ *     Source surface blend mode set to BLENDMODE_NONE:
+ *       copy RGB, set destination alpha to source per-surface alpha value.
+ *     both:
+ *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+ *       source color key.
+ *
+ *   RGBA->RGBA:
+ *     Source surface blend mode set to BLENDMODE_BLEND:
+ *       alpha-blend (using the source alpha-channel and per-surface alpha)
+ *       SDL_SRCCOLORKEY ignored.
+ *     Source surface blend mode set to BLENDMODE_NONE:
+ *       copy all of RGBA to the destination.
+ *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+ *       RGB values of the source color key, ignoring alpha in the
+ *       comparison.
+ *
+ *   RGB->RGB:
+ *     Source surface blend mode set to BLENDMODE_BLEND:
+ *       alpha-blend (using the source per-surface alpha)
+ *     Source surface blend mode set to BLENDMODE_NONE:
+ *       copy RGB.
+ *     both:
+ *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+ *       source color key.
+ * ```
+ *
+ * @param src the Surface structure to be copied from.
+ * @param srcrect the Rect structure representing the rectangle to be
+ *                copied, or nullptr to copy the entire surface.
+ * @param dst the Surface structure that is the blit target.
+ * @param dstpos the Point structure representing the x and y position in
+ *                the destination surface.
+ * @throws Error on failure.
+ *
+ * @threadsafety Only one thread should be using the `src` and `dst` surfaces
+ *               at any given time.
+ *
+ * @since This function is available since SDL 3.2.0.
+ *
+ * @sa Surface.BlitSurface
+ */
 inline void BlitSurfaceAt(SurfaceParam src,
                           OptionalRef<const RectRaw> srcrect,
                           SurfaceParam dst,
                           const PointRaw& dstpos)
 {
-  static_assert(false, "Not implemented");
+  BlitSurface(src, srcrect, dst, SDL_Rect{dstpos.x, dstpos.y});
 }
 
 /**
@@ -3743,14 +3875,14 @@
                                  SurfaceParam dst,
                                  const RectRaw& dstrect)
 {
-  CheckError(SDL_BlitSurfaceUnchecked(src, srcrect, dst, dstrect));
+  CheckError(SDL_BlitSurfaceUnchecked(src, &srcrect, dst, &dstrect));
 }
 
 inline void Surface::BlitUnchecked(SurfaceParam src,
                                    const RectRaw& srcrect,
                                    const RectRaw& dstrect)
 {
-  SDL::BlitSurfaceUnchecked(m_resource, src, srcrect, dstrect);
+  SDL::BlitSurfaceUnchecked(src, srcrect, m_resource, dstrect);
 }
 
 /**
@@ -3788,7 +3920,7 @@
                                 OptionalRef<const RectRaw> dstrect,
                                 ScaleMode scaleMode)
 {
-  SDL::BlitSurfaceScaled(m_resource, src, srcrect, dstrect, scaleMode);
+  SDL::BlitSurfaceScaled(src, srcrect, m_resource, dstrect, scaleMode);
 }
 
 /**
@@ -3820,7 +3952,7 @@
                                        ScaleMode scaleMode)
 {
   CheckError(
-    SDL_BlitSurfaceUncheckedScaled(src, srcrect, dst, dstrect, scaleMode));
+    SDL_BlitSurfaceUncheckedScaled(src, &srcrect, dst, &dstrect, scaleMode));
 }
 
 inline void Surface::BlitUncheckedScaled(SurfaceParam src,
@@ -3828,7 +3960,7 @@
                                          const RectRaw& dstrect,
                                          ScaleMode scaleMode)
 {
-  SDL::BlitSurfaceUncheckedScaled(m_resource, src, srcrect, dstrect, scaleMode);
+  SDL::BlitSurfaceUncheckedScaled(src, srcrect, m_resource, dstrect, scaleMode);
 }
 
 #if SDL_VERSION_ATLEAST(3, 4, 0)
@@ -3862,16 +3994,12 @@
   CheckError(SDL_StretchSurface(src, srcrect, dst, dstrect, scaleMode));
 }
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
 inline void Surface::Stretch(SurfaceParam src,
                              OptionalRef<RectRaw> srcrect,
                              OptionalRef<RectRaw> dstrect,
                              ScaleMode scaleMode)
 {
-  SDL::StretchSurface(m_resource, src, srcrect, dstrect, scaleMode);
+  SDL::StretchSurface(src, srcrect, m_resource, dstrect, scaleMode);
 }
 
 #endif // SDL_VERSION_ATLEAST(3, 4, 0)
@@ -3910,7 +4038,7 @@
                                OptionalRef<const RectRaw> srcrect,
                                OptionalRef<const RectRaw> dstrect)
 {
-  SDL::BlitSurfaceTiled(m_resource, src, srcrect, dstrect);
+  SDL::BlitSurfaceTiled(src, srcrect, m_resource, dstrect);
 }
 
 /**
@@ -3957,7 +4085,7 @@
                                         OptionalRef<const RectRaw> dstrect)
 {
   SDL::BlitSurfaceTiledWithScale(
-    m_resource, src, srcrect, scale, scaleMode, dstrect);
+    src, srcrect, scale, scaleMode, m_resource, dstrect);
 }
 
 /**
@@ -3978,12 +4106,12 @@
  * @param top_height the height, in pixels, of the top corners in `srcrect`.
  * @param bottom_height the height, in pixels, of the bottom corners in
  *                      `srcrect`.
- * @param scale the scale used to transform the corner of `srcrect` into the
- *              corner of `dstrect`, or 0.0f for an unscaled blit.
- * @param scaleMode scale algorithm to be used.
  * @param dst the Surface structure that is the blit target.
  * @param dstrect the Rect structure representing the target rectangle in the
  *                destination surface, or nullptr to fill the entire surface.
+ * @param scale the scale used to transform the corner of `srcrect` into the
+ *              corner of `dstrect`, or 0.0f for an unscaled blit.
+ * @param scaleMode scale algorithm to be used.
  * @throws Error on failure.
  *
  * @threadsafety Only one thread should be using the `src` and `dst` surfaces at
@@ -4010,10 +4138,10 @@
                                   right_width,
                                   top_height,
                                   bottom_height,
-                                  dst,
-                                  dstrect,
                                   scale,
-                                  scaleMode));
+                                  scaleMode,
+                                  dst,
+                                  dstrect));
 }
 
 inline void Surface::Blit9Grid(SurfaceParam src,
@@ -4026,13 +4154,13 @@
                                float scale,
                                ScaleMode scaleMode)
 {
-  SDL::BlitSurface9Grid(m_resource,
-                        src,
+  SDL::BlitSurface9Grid(src,
                         srcrect,
                         left_width,
                         right_width,
                         top_height,
                         bottom_height,
+                        m_resource,
                         dstrect,
                         scale,
                         scaleMode);
@@ -4101,10 +4229,7 @@
  * for an 8-bpp format).
  *
  * @param surface the surface to use for the pixel format and palette.
- * @param r the red component of the pixel in the range 0-255.
- * @param g the green component of the pixel in the range 0-255.
- * @param b the blue component of the pixel in the range 0-255.
- * @param a the alpha component of the pixel in the range 0-255.
+ * @param c the color components of the pixel in the range 0-255.
  * @returns a pixel value.
  *
  * @threadsafety This function can be called on different threads with different
@@ -4116,7 +4241,7 @@
  */
 inline Uint32 MapSurfaceRGBA(SurfaceConstParam surface, ColorRaw c)
 {
-  return SDL_MapSurfaceRGBA(surface, c);
+  return SDL_MapSurfaceRGBA(surface, c.r, c.g, c.b, c.a);
 }
 
 inline Uint32 Surface::MapRGBA(ColorRaw c) const
@@ -4134,8 +4259,7 @@
  * components from pixel formats with less than 8 bits per RGB component.
  *
  * @param surface the surface to read.
- * @param x the horizontal coordinate, 0 <= x < width.
- * @param y the vertical coordinate, 0 <= y < height.
+ * @param p the coordinates, 0 <= x < width and 0 <= y < height.
  * @param r a pointer filled in with the red channel, 0-255, or nullptr to
  *          ignore this channel.
  * @param g a pointer filled in with the green channel, 0-255, or nullptr to
@@ -4158,7 +4282,7 @@
                              Uint8* b,
                              Uint8* a)
 {
-  CheckError(SDL_ReadSurfacePixel(surface, p, r, g, b, a));
+  CheckError(SDL_ReadSurfacePixel(surface, p.x, p.y, r, g, b, a));
 }
 
 /**
@@ -4171,16 +4295,8 @@
  * components from pixel formats with less than 8 bits per RGB component.
  *
  * @param surface the surface to read.
- * @param x the horizontal coordinate, 0 <= x < width.
- * @param y the vertical coordinate, 0 <= y < height.
- * @param r a pointer filled in with the red channel, 0-255, or nullptr to
- *          ignore this channel.
- * @param g a pointer filled in with the green channel, 0-255, or nullptr to
- *          ignore this channel.
- * @param b a pointer filled in with the blue channel, 0-255, or nullptr to
- *          ignore this channel.
- * @param a a pointer filled in with the alpha channel, 0-255, or nullptr to
- *          ignore this channel.
+ * @param p the coordinates, 0 <= x < width and 0 <= y < height.
+ * @returns color on success.
  * @throws Error on failure.
  *
  * @threadsafety This function can be called on different threads with different
@@ -4190,7 +4306,9 @@
  */
 inline Color ReadSurfacePixel(SurfaceConstParam surface, const PointRaw& p)
 {
-  static_assert(false, "Not implemented");
+  Color c;
+  ReadSurfacePixel(surface, p, &c.r, &c.g, &c.b, &c.a);
+  return c;
 }
 
 inline void Surface::ReadPixel(const PointRaw& p,
@@ -4214,8 +4332,7 @@
  * tests, but is not intended for use in a game engine.
  *
  * @param surface the surface to read.
- * @param x the horizontal coordinate, 0 <= x < width.
- * @param y the vertical coordinate, 0 <= y < height.
+ * @param p the coordinates, 0 <= x < width and 0 <= y < height.
  * @param r a pointer filled in with the red channel, normally in the range 0-1,
  *          or nullptr to ignore this channel.
  * @param g a pointer filled in with the green channel, normally in the range
@@ -4238,7 +4355,7 @@
                                   float* b,
                                   float* a)
 {
-  CheckError(SDL_ReadSurfacePixelFloat(surface, p, r, g, b, a));
+  CheckError(SDL_ReadSurfacePixelFloat(surface, p.x, p.y, r, g, b, a));
 }
 
 /**
@@ -4248,16 +4365,8 @@
  * tests, but is not intended for use in a game engine.
  *
  * @param surface the surface to read.
- * @param x the horizontal coordinate, 0 <= x < width.
- * @param y the vertical coordinate, 0 <= y < height.
- * @param r a pointer filled in with the red channel, normally in the range 0-1,
- *          or nullptr to ignore this channel.
- * @param g a pointer filled in with the green channel, normally in the range
- *          0-1, or nullptr to ignore this channel.
- * @param b a pointer filled in with the blue channel, normally in the range
- *          0-1, or nullptr to ignore this channel.
- * @param a a pointer filled in with the alpha channel, normally in the range
- *          0-1, or nullptr to ignore this channel.
+ * @param p the coordinates, 0 <= x < width and 0 <= y < height.
+ * @returns color on success.
  * @throws Error on failure.
  *
  * @threadsafety This function can be called on different threads with different
@@ -4268,7 +4377,9 @@
 inline FColor ReadSurfacePixelFloat(SurfaceConstParam surface,
                                     const PointRaw& p)
 {
-  static_assert(false, "Not implemented");
+  FColor c;
+  ReadSurfacePixelFloat(surface, p, &c.r, &c.g, &c.b, &c.a);
+  return c;
 }
 
 inline void Surface::ReadPixelFloat(const PointRaw& p,
@@ -4295,12 +4406,8 @@
  * components from pixel formats with less than 8 bits per RGB component.
  *
  * @param surface the surface to write.
- * @param x the horizontal coordinate, 0 <= x < width.
- * @param y the vertical coordinate, 0 <= y < height.
- * @param r the red channel value, 0-255.
- * @param g the green channel value, 0-255.
- * @param b the blue channel value, 0-255.
- * @param a the alpha channel value, 0-255.
+ * @param p the coordinates, 0 <= x < width, 0 <= y < height.
+ * @param c the color channels value, 0-255.
  * @throws Error on failure.
  *
  * @threadsafety This function can be called on different threads with different
@@ -4312,7 +4419,7 @@
                               const PointRaw& p,
                               ColorRaw c)
 {
-  CheckError(SDL_WriteSurfacePixel(surface, p, c));
+  CheckError(SDL_WriteSurfacePixel(surface, p.x, p.y, c.r, c.g, c.b, c.a));
 }
 
 inline void Surface::WritePixel(const PointRaw& p, ColorRaw c)
@@ -4327,12 +4434,8 @@
  * tests, but is not intended for use in a game engine.
  *
  * @param surface the surface to write.
- * @param x the horizontal coordinate, 0 <= x < width.
- * @param y the vertical coordinate, 0 <= y < height.
- * @param r the red channel value, normally in the range 0-1.
- * @param g the green channel value, normally in the range 0-1.
- * @param b the blue channel value, normally in the range 0-1.
- * @param a the alpha channel value, normally in the range 0-1.
+ * @param p the coordinates, 0 <= x < width, 0 <= y < height.
+ * @param c the color channels values, normally in the range 0-1.
  * @throws Error on failure.
  *
  * @threadsafety This function can be called on different threads with different
@@ -4344,7 +4447,7 @@
                                    const PointRaw& p,
                                    const FColorRaw& c)
 {
-  CheckError(SDL_WriteSurfacePixelFloat(surface, p, c));
+  CheckError(SDL_WriteSurfacePixelFloat(surface, p.x, p.y, c.r, c.g, c.b, c.a));
 }
 
 inline void Surface::WritePixelFloat(const PointRaw& p, const FColorRaw& c)
@@ -4352,29 +4455,32 @@
   SDL::WriteSurfacePixelFloat(m_resource, p, c);
 }
 
-constexpr int GetSurfaceWidth(SurfaceConstParam surface)
-{
-  static_assert(false, "Not implemented");
-}
+/**
+ * Get the width in pixels.
+ */
+constexpr int GetSurfaceWidth(SurfaceConstParam surface) { return surface->w; }
 
 constexpr int Surface::GetWidth() const
 {
   return SDL::GetSurfaceWidth(m_resource);
 }
 
-constexpr int GetSurfaceHeight(SurfaceConstParam surface)
-{
-  static_assert(false, "Not implemented");
-}
+/**
+ * Get the height in pixels.
+ */
+constexpr int GetSurfaceHeight(SurfaceConstParam surface) { return surface->h; }
 
 constexpr int Surface::GetHeight() const
 {
   return SDL::GetSurfaceHeight(m_resource);
 }
 
+/**
+ * Get the size in pixels.
+ */
 constexpr Point GetSurfaceSize(SurfaceConstParam surface)
 {
-  static_assert(false, "Not implemented");
+  return Point(surface->w, surface->h);
 }
 
 constexpr Point Surface::GetSize() const
@@ -4382,9 +4488,12 @@
   return SDL::GetSurfaceSize(m_resource);
 }
 
+/**
+ * Get pitch in bytes.
+ */
 constexpr int GetSurfacePitch(SurfaceConstParam surface)
 {
-  static_assert(false, "Not implemented");
+  return surface->pitch;
 }
 
 constexpr int Surface::GetPitch() const
@@ -4392,9 +4501,12 @@
   return SDL::GetSurfacePitch(m_resource);
 }
 
+/**
+ * Get the pixel format.
+ */
 constexpr PixelFormat GetSurfaceFormat(SurfaceConstParam surface)
 {
-  static_assert(false, "Not implemented");
+  return surface->format;
 }
 
 constexpr PixelFormat Surface::GetFormat() const
@@ -4402,9 +4514,12 @@
   return SDL::GetSurfaceFormat(m_resource);
 }
 
+/**
+ * Get the pixels.
+ */
 constexpr void* GetSurfacePixels(SurfaceConstParam surface)
 {
-  static_assert(false, "Not implemented");
+  return surface->pixels;
 }
 
 constexpr void* Surface::GetPixels() const
