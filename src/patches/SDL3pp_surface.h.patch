19c19
<  * @defgroup CategorySurface Category Surface
---
>  * @defgroup CategorySurface Surface Creation and Simple Drawing
32,33c32,33
<  * [SDL_image](https://wiki.libsdl.org/SDL3_image)
<  * .
---
>  * [SDL_image](https://wiki.libsdl.org/SDL3_image).
>  *
83c83
<   /// Constructs from const SurfaceRaw
---
>   /// Constructs from SurfaceRaw
140c140
< constexpr bool MustLock(SurfaceConstParam S) const { return SDL_MUSTLOCK(S); }
---
> constexpr bool MustLock(SurfaceConstParam S) { return SDL_MUSTLOCK((S.value)); }
219,220d218
<  *
<  * @cat resource
256,257c254
<    * @param width the width of the surface.
<    * @param height the height of the surface.
---
>    * @param size the width and height of the surface.
259,260c256
<    * @post the new Surface structure that is created or nullptr on failure;
<    *          call GetError() for more information.
---
>    * @throws Error on failure.
270c266
<     : m_resource(SDL_CreateSurface(size, format))
---
>     : m_resource(CheckError(SDL_CreateSurface(size.x, size.y, format)))
287,288c283
<    * @param width the width of the surface.
<    * @param height the height of the surface.
---
>    * @param size the width and height of the surface.
292,293c287
<    * @post the new Surface structure that is created or nullptr on failure;
<    *          call GetError() for more information.
---
>    * @throws Error on failure.
303c297,298
<     : m_resource(SDL_CreateSurfaceFrom(size, format, pixels, pitch))
---
>     : m_resource(CheckError(
>         SDL_CreateSurfaceFrom(size.x, size.y, format, pixels, pitch)))
336,340d330
<    * When done with the returned surface, the app should dispose of it with a
<    * call to
<    * [Surface.Destroy](https://wiki.libsdl.org/SDL3/Surface.Destroy)
<    * ().
<    *
390,392d379
<    * When done with the returned surface, the app should dispose of it with a
<    * call to Surface.Destroy().
<    *
404c391
<   Surface(IOStreamParam src, bool closeio);
---
>   Surface(IOStreamParam src, bool closeio = false);
488,491d474
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
614,615c597
<    * @param colorspace an Colorspace value describing the surface
<    *                   colorspace.
---
>    * @param colorspace a Colorspace value describing the surface colorspace.
721,722c703
<    * @param image a pointer to an alternate Surface to associate with this
<    *              surface.
---
>    * @param image an alternate Surface to associate with this surface.
757,762d737
<    * Freeing the array of surfaces does not affect the surfaces in the array.
<    * They are still referenced by the surface being queried and will be cleaned
<    * up normally.
<    *
<    * @param count a pointer filled in with the number of surface pointers
<    *              returned, may be nullptr.
764,765c739
<    *          failure; call GetError() for more information. This should be
<    *          freed with free() when it is no longer needed.
---
>    *          failure; call GetError() for more information.
804,806c778,780
<    * Not all surfaces require locking. If `Surface.MustLock(surface)` evaluates
<    * to 0, then you can read and write to the surface at any time, and the pixel
<    * format of the surface will not change.
---
>    * Not all surfaces require locking. If `Surface.MustLock()` evaluates to
>    * false, then you can read and write to the surface at any time, and the
>    * pixel format of the surface will not change.
902,905d875
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
969,970c939
<    * @param enabled true to enable color key, false to disable color key.
<    * @param key the transparent pixel.
---
>    * @param key the transparent pixel or std::nullopt to disable it.
983a953,961
>   /**
>    * Unset the color key (transparent pixel) in a surface.
>    *
>    * The color key defines a pixel value that will be treated as transparent in
>    * a blit. For example, one can use this to specify that cyan pixels should be
>    * considered transparent, and therefore not rendered.
>    *
>    * @throws Error on failure.
>    */
989,990d966
<    * It is safe to pass a nullptr `surface` here; it will return false.
<    *
1010c986
<    * @param key a pointer filled in with the transparent pixel.
---
>    * @returns the transparent pixel or nullopt if none.
1088d1063
<    * @param alpha a pointer filled in with the current alpha value.
1099a1075,1088
>   /**
>    * Set an additional color and alpha value multiplied into blit
>    * operations.
>    *
>    * When this surface is blitted, during the blit operation each source color
>    * channel is modulated by the appropriate color value according to the
>    * following formula:
>    *
>    * `srcC = srcC * (color / 255)`
>    * `srcA = srcA * (alpha / 255)`
>    *
>    * @param color the color to be multiplied in blit operations
>    * @throws Error on failure.
>    */
1101a1091,1097
>   /**
>    * Get the additional color and alpha value multiplied into blit
>    * operations.
>    *
>    * @returns a Color containing RGBA value on success or std::nullopt on
>    * failure; call GetError() for more information.
>    */
1126c1122
<    * @param blendMode a pointer filled in with the current BlendMode.
---
>    * @returns the current BlendMode.
1155a1152
>    * @sa Surface.ResetClipRect()
1159a1157,1161
>   /**
>    * Disable the clipping rectangle for a surface.
>    *
>    * @sa SetClipRect()
>    */
1168,1170c1170,1171
<    *                clipped.
<    * @param rect an Rect structure filled in with the clipping rectangle for
<    *             the surface.
---
>    * @returns the Rect structure filled in with the clipping rectangle for the
>    *          surface on success.
1225,1226d1225
<    * The returned surface should be freed with Surface.Destroy().
<    *
1243,1246c1242
<    * The returned surface should be freed with Surface.Destroy().
<    *
<    * @param width the width of the new surface.
<    * @param height the height of the new surface.
---
>    * @param size the width and height of the new surface.
1342c1338
<    * otherwise the color is assumed to be in the colorspace of the suface.
---
>    * otherwise the color is assumed to be in the colorspace of the surface.
1344,1347c1340
<    * @param r the red component of the pixel, normally in the range 0-1.
<    * @param g the green component of the pixel, normally in the range 0-1.
<    * @param b the blue component of the pixel, normally in the range 0-1.
<    * @param a the alpha component of the pixel, normally in the range 0-1.
---
>    * @param c the color components of the pixel, normally in the range 0-1.
1361c1354
<    * generated by MapRGB() or MapColor(). If the color value contains an
---
>    * generated by MapColor(). If the color value contains an
1382a1376,1385
>   /**
>    * Perform a fast fill of a rectangle with a specific color.
>    *
>    * If there is a clip rectangle set on the destination (set via
>    * Surface.SetClipRect()), then this function will fill based on the
>    * intersection of the clip rectangle and `rect`.
>    *
>    * @param color the color to fill with.
>    * @throws Error on failure.
>    */
1389c1392
<    * generated by MapRGB() or MapColor(). If the color value contains an
---
>    * generated by MapColor(). If the color value contains an
1398d1400
<    * @param count the number of rectangles in the array.
1462a1465
>    * @param src the SurfaceRaw structure to be copied from.
1465d1467
<    * @param dst the Surface structure that is the blit target.
1483a1486,1555
>   /**
>    * Performs a fast blit from the source surface to the destination surface
>    * with clipping.
>    *
>    * If either `srcrect` or `dstrect` are nullptr, the entire surface (`src` or
>    * `dst`) is copied while ensuring clipping to `dst->clip_rect`.
>    *
>    * The blit function should not be called on a locked surface.
>    *
>    * The blit semantics for surfaces with and without blending and colorkey are
>    * defined as follows:
>    *
>    * ```
>    *    RGBA->RGB:
>    *      Source surface blend mode set to BLENDMODE_BLEND:
>    *       alpha-blend (using the source alpha-channel and per-surface alpha)
>    *       SDL_SRCCOLORKEY ignored.
>    *     Source surface blend mode set to BLENDMODE_NONE:
>    *       copy RGB.
>    *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
>    *       RGB values of the source color key, ignoring alpha in the
>    *       comparison.
>    *
>    *   RGB->RGBA:
>    *     Source surface blend mode set to BLENDMODE_BLEND:
>    *       alpha-blend (using the source per-surface alpha)
>    *     Source surface blend mode set to BLENDMODE_NONE:
>    *       copy RGB, set destination alpha to source per-surface alpha value.
>    *     both:
>    *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
>    *       source color key.
>    *
>    *   RGBA->RGBA:
>    *     Source surface blend mode set to BLENDMODE_BLEND:
>    *       alpha-blend (using the source alpha-channel and per-surface alpha)
>    *       SDL_SRCCOLORKEY ignored.
>    *     Source surface blend mode set to BLENDMODE_NONE:
>    *       copy all of RGBA to the destination.
>    *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
>    *       RGB values of the source color key, ignoring alpha in the
>    *       comparison.
>    *
>    *   RGB->RGB:
>    *     Source surface blend mode set to BLENDMODE_BLEND:
>    *       alpha-blend (using the source per-surface alpha)
>    *     Source surface blend mode set to BLENDMODE_NONE:
>    *       copy RGB.
>    *     both:
>    *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
>    *       source color key.
>    * ```
>    *
>    * @param src the SurfaceRaw structure to be copied from.
>    * @param srcrect the Rect structure representing the rectangle to be
>    *                copied, or nullptr to copy the entire surface.
>    * @param dstpos the Point structure representing the x and y position in
>    *                the destination surface, or nullptr for (0,0). The width and
>    *                height are ignored, and are copied from `srcrect`. If you
>    *                want a specific width and height, you should use
>    *                Surface.BlitScaled().
>    * @throws Error on failure.
>    *
>    * @threadsafety Only one thread should be using the `src` and `dst` surfaces
>    *               at any given time.
>    *
>    * @since This function is available since SDL 3.2.0.
>    *
>    * @sa Surface.Blit
>    * @sa Surface.BlitScaled
>    */
1493a1566
>    * @param src the Surface structure to be copied from.
1496d1568
<    * @param dst the Surface structure that is the blit target.
1515a1588
>    * @param src the Surface structure to be copied from.
1518d1590
<    * @param dst the Surface structure that is the blit target.
1542a1615
>    * @param src the Surface structure to be copied from.
1545d1617
<    * @param dst the Surface structure that is the blit target.
1567a1640
>    * @param src the Surface structure to be copied from.
1570d1642
<    * @param dst the Surface structure that is the blit target.
1597a1670
>    * @param src the SDL_Surface structure to be copied from.
1600d1672
<    * @param dst the Surface structure that is the blit target.
1623a1696
>    * @param src the SDL_Surface structure to be copied from.
1630d1702
<    * @param dst the Surface structure that is the blit target.
1658a1731
>    * @param src the SDL_Surface structure to be copied from.
1665a1739,1741
>    * @param dstrect the Rect structure representing the target rectangle in
>    *                the destination surface, or nullptr to fill the entire
>    *                surface.
1669,1672d1744
<    * @param dst the Surface structure that is the blit target.
<    * @param dstrect the Rect structure representing the target rectangle in
<    *                the destination surface, or nullptr to fill the entire
<    * surface.
1742,1745c1814
<    * @param r the red component of the pixel in the range 0-255.
<    * @param g the green component of the pixel in the range 0-255.
<    * @param b the blue component of the pixel in the range 0-255.
<    * @param a the alpha component of the pixel in the range 0-255.
---
>    * @param c the color components of the pixel in the range 0-255.
1766,1767c1835
<    * @param x the horizontal coordinate, 0 <= x < width.
<    * @param y the vertical coordinate, 0 <= y < height.
---
>    * @param p the coordinates, 0 <= x < width and 0 <= y < height.
1795,1807c1863,1864
<    * Like GetRGBA, this uses the entire 0..255 range when converting color
<    * components from pixel formats with less than 8 bits per RGB component.
<    *
<    * @param x the horizontal coordinate, 0 <= x < width.
<    * @param y the vertical coordinate, 0 <= y < height.
<    * @param r a pointer filled in with the red channel, 0-255, or nullptr to
<    * ignore this channel.
<    * @param g a pointer filled in with the green channel, 0-255, or nullptr to
<    *          ignore this channel.
<    * @param b a pointer filled in with the blue channel, 0-255, or nullptr to
<    *          ignore this channel.
<    * @param a a pointer filled in with the alpha channel, 0-255, or nullptr to
<    *          ignore this channel.
---
>    * @param p the coordinates, 0 <= x < width and 0 <= y < height.
>    * @returns color on success.
1823,1824c1880
<    * @param x the horizontal coordinate, 0 <= x < width.
<    * @param y the vertical coordinate, 0 <= y < height.
---
>    * @param p the coordinates, 0 <= x < width and 0 <= y < height.
1852,1861c1908,1909
<    * @param x the horizontal coordinate, 0 <= x < width.
<    * @param y the vertical coordinate, 0 <= y < height.
<    * @param r a pointer filled in with the red channel, normally in the range
<    *          0-1, or nullptr to ignore this channel.
<    * @param g a pointer filled in with the green channel, normally in the range
<    *          0-1, or nullptr to ignore this channel.
<    * @param b a pointer filled in with the blue channel, normally in the range
<    *          0-1, or nullptr to ignore this channel.
<    * @param a a pointer filled in with the alpha channel, normally in the range
<    *          0-1, or nullptr to ignore this channel.
---
>    * @param p the coordinates, 0 <= x < width and 0 <= y < height.
>    * @returns color on success.
1880,1885c1928,1929
<    * @param x the horizontal coordinate, 0 <= x < width.
<    * @param y the vertical coordinate, 0 <= y < height.
<    * @param r the red channel value, 0-255.
<    * @param g the green channel value, 0-255.
<    * @param b the blue channel value, 0-255.
<    * @param a the alpha channel value, 0-255.
---
>    * @param p the coordinates, 0 <= x < width and 0 <= y < height.
>    * @param c the color values, 0-255.
1901,1906c1945,1946
<    * @param x the horizontal coordinate, 0 <= x < width.
<    * @param y the vertical coordinate, 0 <= y < height.
<    * @param r the red channel value, normally in the range 0-1.
<    * @param g the green channel value, normally in the range 0-1.
<    * @param b the blue channel value, normally in the range 0-1.
<    * @param a the alpha channel value, normally in the range 0-1.
---
>    * @param p the coordinates, 0 <= x < width and 0 <= y < height.
>    * @param c the color values, normally in the range 0-1.
1915a1956,1958
>   /**
>    * Get the width in pixels.
>    */
1917a1961,1963
>   /**
>    * Get the height in pixels.
>    */
1919a1966,1968
>   /**
>    * Get the size in pixels.
>    */
1921a1971,1973
>   /**
>    * Get pitch in bytes.
>    */
1923a1976,1978
>   /**
>    * Get the pixel format.
>    */
1925a1981,1983
>   /**
>    * Get the pixels.
>    */
1934,1935c1992
<  * @param width the width of the surface.
<  * @param height the height of the surface.
---
>  * @param size the width and height of the surface.
1965,1966c2022
<  * @param width the width of the surface.
<  * @param height the height of the surface.
---
>  * @param size the width and height of the surface.
2040c2096
<   return CheckError(SDL_GetSurfaceProperties(surface));
---
>   return {CheckError(SDL_GetSurfaceProperties(surface))};
2061,2064d2116
< #endif // SDL_VERSION_ATLEAST(3, 2, 6)
< 
< #if SDL_VERSION_ATLEAST(3, 2, 6)
< 
2157c2209
<   return CheckError(SDL_CreateSurfacePalette(surface));
---
>   return Palette::Borrow(CheckError(SDL_CreateSurfacePalette(surface)));
2210c2262
<   return SDL_GetSurfacePalette(surface);
---
>   return Palette::Borrow(SDL_GetSurfacePalette(surface));
2288,2289d2339
<  * @param count a pointer filled in with the number of surface pointers
<  *              returned, may be nullptr.
2291,2292c2341
<  *          failure; call GetError() for more information. This should be
<  *          freed with free() when it is no longer needed.
---
>  *          failure; call GetError() for more information.
2305c2354,2356
<   return SDL_GetSurfaceImages(surface);
---
>   int count = 0;
>   auto data = SDL_GetSurfaceImages(surface, &count);
>   return OwnArray<SurfaceRaw>(CheckError(data), count);
2348c2399
<  * Not all surfaces require locking. If `Surface.MustLock(surface)` evaluates to
---
>  * Not all surfaces require locking. If `Surface.MustLock()` evaluates to
2537,2540d2587
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
2561,2564d2607
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
2570,2573d2612
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
2579,2582d2617
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
2607,2610d2641
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
2631,2634d2661
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
2640,2643d2666
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
2712,2713c2735
<  * @param enabled true to enable color key, false to disable color key.
<  * @param key the transparent pixel.
---
>  * @param key the transparent pixel or std::nullopt to disable it.
2727c2749
<   CheckError(SDL_SetSurfaceColorKey(surface, key));
---
>   CheckError(SDL_SetSurfaceColorKey(surface, key.has_value(), key.value_or(0)));
2734a2757,2766
> /**
>  * Unset the color key (transparent pixel) in a surface.
>  *
>  * The color key defines a pixel value that will be treated as transparent in
>  * a blit. For example, one can use this to specify that cyan pixels should be
>  * considered transparent, and therefore not rendered.
>  *
>  * @param surface the Surface structure to update.
>  * @throws Error on failure.
>  */
2737c2769
<   static_assert(false, "Not implemented");
---
>   SetSurfaceColorKey(surface, std::nullopt);
2776c2808
<  * @param key a pointer filled in with the transparent pixel.
---
>  * @returns the transparent pixel or nullopt if none.
2788c2820,2821
<   return CheckError(SDL_GetSurfaceColorKey(surface));
---
>   if (Uint32 key; SDL_GetSurfaceColorKey(surface, &key)) return key;
>   return std::nullopt;
2893c2926
<  * @param alpha a pointer filled in with the current alpha value.
---
>  * @returns the current alpha value.
2905c2938,2940
<   return CheckError(SDL_GetSurfaceAlphaMod(surface));
---
>   Uint8 alpha;
>   CheckError(SDL_GetSurfaceAlphaMod(surface, &alpha));
>   return alpha;
2912a2948,2962
> /**
>  * Set an additional color and alpha value multiplied into blit
>  * operations.
>  *
>  * When this surface is blitted, during the blit operation each source color
>  * channel is modulated by the appropriate color value according to the
>  * following formula:
>  *
>  * `srcC = srcC * (color / 255)`
>  * `srcA = srcA * (alpha / 255)`
>  *
>  * @param surface the Surface structure to query.
>  * @param color the color to be multiplied in blit operations
>  * @throws Error on failure.
>  */
2915c2965,2966
<   static_assert(false, "Not implemented");
---
>   SetSurfaceColorMod(surface, color.r, color.g, color.b);
>   SetSurfaceAlphaMod(surface, color.a);
2918,2921c2969
< inline void Surface::SetMod(Color color)
< {
<   SDL::SetSurfaceMod(m_resource, color);
< }
---
> inline void Surface::SetMod(Color color) { SetSurfaceMod(m_resource, color); }
2922a2971,2978
> /**
>  * Get the additional color and alpha value multiplied into blit
>  * operations.
>  *
>  * @param surface the Surface structure to query.
>  * @returns a Color containing RGBA value on success or std::nullopt on
>  * failure; call GetError() for more information.
>  */
2925c2981,2984
<   static_assert(false, "Not implemented");
---
>   Color c;
>   GetSurfaceColorMod(surface, &c.r, &c.g, &c.b);
>   c.a = GetSurfaceAlphaMod(surface);
>   return c;
2962c3021
<  * @param blendMode a pointer filled in with the current BlendMode.
---
>  * @returns the current BlendMode.
2973c3032,3034
<   return CheckError(SDL_GetSurfaceBlendMode(surface));
---
>   BlendMode blendmode;
>   CheckError(SDL_GetSurfaceBlendMode(surface, &blendmode));
>   return blendmode;
3013a3075,3079
> /**
>  * Disable the clipping rectangle for a surface.
>  *
>  * @sa SetSurfaceClipRect()
>  */
3016c3082
<   static_assert(false, "Not implemented");
---
>   SetSurfaceClipRect(surface, std::nullopt);
3029,3030c3095,3096
<  * @param rect an Rect structure filled in with the clipping rectangle for
<  *             the surface.
---
>  * @returns the Rect structure filled in with the clipping rectangle for the
>  *          surface.
3042c3108,3110
<   return CheckError(SDL_GetSurfaceClipRect(surface));
---
>   Rect r;
>   CheckError(SDL_GetSurfaceClipRect(surface, &r));
>   return r;
3095,3098d3162
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
3127c3191
<   return SDL_DuplicateSurface(surface);
---
>   return Surface(SDL_DuplicateSurface(surface));
3142,3143c3206
<  * @param width the width of the new surface.
<  * @param height the height of the new surface.
---
>  * @param size the width and height of the surface.
3159c3222
<   return SDL_ScaleSurface(surface, size, scaleMode);
---
>   return Surface(SDL_ScaleSurface(surface, size.x, size.y, scaleMode));
3196c3259
<   return SDL_ConvertSurface(surface, format);
---
>   return Surface(SDL_ConvertSurface(surface, format));
3204,3212d3266
< inline Surface Surface::Convert(PixelFormat format,
<                                 PaletteParam palette,
<                                 Colorspace colorspace,
<                                 PropertiesParam props) const
< {
<   return SDL::ConvertSurfaceAndColorspace(
<     m_resource, format, palette, colorspace, props);
< }
< 
3247,3248c3301,3311
<   return SDL_ConvertSurfaceAndColorspace(
<     surface, format, palette, colorspace, props);
---
>   return Surface{SDL_ConvertSurfaceAndColorspace(
>     surface, format, palette, colorspace, props)};
> }
> 
> inline Surface Surface::Convert(PixelFormat format,
>                                 PaletteParam palette,
>                                 Colorspace colorspace,
>                                 PropertiesParam props) const
> {
>   return SDL::ConvertSurfaceAndColorspace(
>     m_resource, format, palette, colorspace, props);
3254,3255c3317
<  * @param width the width of the block to copy, in pixels.
<  * @param height the height of the block to copy, in pixels.
---
>  * @param size the width and height of the surface.
3281c3343
<     size, src_format, src, src_pitch, dst_format, dst, dst_pitch));
---
>     size.x, size.y, src_format, src, src_pitch, dst_format, dst, dst_pitch));
3288,3289c3350
<  * @param width the width of the block to copy, in pixels.
<  * @param height the height of the block to copy, in pixels.
---
>  * @param size the width and height  of the block to copy, in pixels.
3326c3387,3388
<   CheckError(SDL_ConvertPixelsAndColorspace(size,
---
>   CheckError(SDL_ConvertPixelsAndColorspace(size.x,
>                                             size.y,
3344,3345c3406
<  * @param width the width of the block to convert, in pixels.
<  * @param height the height of the block to convert, in pixels.
---
>  * @param size the width and height of the surface.
3371,3372c3432,3440
<   CheckError(SDL_PremultiplyAlpha(
<     size, src_format, src, src_pitch, dst_format, dst, dst_pitch, linear));
---
>   CheckError(SDL_PremultiplyAlpha(size.x,
>                                   size.y,
>                                   src_format,
>                                   src,
>                                   src_pitch,
>                                   dst_format,
>                                   dst,
>                                   dst_pitch,
>                                   linear));
3409,3412c3477
<  * @param r the red component of the pixel, normally in the range 0-1.
<  * @param g the green component of the pixel, normally in the range 0-1.
<  * @param b the blue component of the pixel, normally in the range 0-1.
<  * @param a the alpha component of the pixel, normally in the range 0-1.
---
>  * @param c the color components of the pixel, normally in the range 0-1.
3422c3487
<   CheckError(SDL_ClearSurface(surface, c));
---
>   CheckError(SDL_ClearSurface(surface, c.r, c.g, c.b, c.a));
3434c3499
<  * generated by MapRGB() or MapColor(). If the color value contains an
---
>  * generated by MapColor(). If the color value contains an
3466a3532,3542
> /**
>  * Perform a fast fill of a rectangle with a specific color.
>  *
>  * If there is a clip rectangle set on the destination (set via
>  * Surface.SetClipRect()), then this function will fill based on the
>  * intersection of the clip rectangle and `rect`.
>  *
>  * @param dst the Surface structure that is the drawing target.
>  * @param color the color to fill with.
>  * @throws Error on failure.
>  */
3469c3545
<   static_assert(false, "Not implemented");
---
>   FillSurfaceRect(dst, std::nullopt, color);
3478c3554
<  * generated by MapRGB() or MapColor(). If the color value contains an
---
>  * generated by MapColor(). If the color value contains an
3488d3563
<  * @param count the number of rectangles in the array.
3503c3578
<   CheckError(SDL_FillSurfaceRects(dst, rects, color));
---
>   CheckError(SDL_FillSurfaceRects(dst, rects.data(), rects.size(), color));
3593c3668
<   SDL::BlitSurface(m_resource, src, srcrect, dstrect);
---
>   SDL::BlitSurface(src, srcrect, m_resource, dstrect);
3600c3675
<   static_assert(false, "Not implemented");
---
>   Blit(src, srcrect, Rect{dstpos, {}});
3602a3678,3744
> /**
>  * Performs a fast blit from the source surface to the destination surface
>  * with clipping.
>  *
>  * If either `srcrect` or `dstrect` are nullptr, the entire surface (`src` or
>  * `dst`) is copied while ensuring clipping to `dst->clip_rect`.
>  *
>  * The blit function should not be called on a locked surface.
>  *
>  * The blit semantics for surfaces with and without blending and colorkey are
>  * defined as follows:
>  *
>  * ```
>  *    RGBA->RGB:
>  *      Source surface blend mode set to BLENDMODE_BLEND:
>  *       alpha-blend (using the source alpha-channel and per-surface alpha)
>  *       SDL_SRCCOLORKEY ignored.
>  *     Source surface blend mode set to BLENDMODE_NONE:
>  *       copy RGB.
>  *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
>  *       RGB values of the source color key, ignoring alpha in the
>  *       comparison.
>  *
>  *   RGB->RGBA:
>  *     Source surface blend mode set to BLENDMODE_BLEND:
>  *       alpha-blend (using the source per-surface alpha)
>  *     Source surface blend mode set to BLENDMODE_NONE:
>  *       copy RGB, set destination alpha to source per-surface alpha value.
>  *     both:
>  *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
>  *       source color key.
>  *
>  *   RGBA->RGBA:
>  *     Source surface blend mode set to BLENDMODE_BLEND:
>  *       alpha-blend (using the source alpha-channel and per-surface alpha)
>  *       SDL_SRCCOLORKEY ignored.
>  *     Source surface blend mode set to BLENDMODE_NONE:
>  *       copy all of RGBA to the destination.
>  *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
>  *       RGB values of the source color key, ignoring alpha in the
>  *       comparison.
>  *
>  *   RGB->RGB:
>  *     Source surface blend mode set to BLENDMODE_BLEND:
>  *       alpha-blend (using the source per-surface alpha)
>  *     Source surface blend mode set to BLENDMODE_NONE:
>  *       copy RGB.
>  *     both:
>  *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
>  *       source color key.
>  * ```
>  *
>  * @param src the Surface structure to be copied from.
>  * @param srcrect the Rect structure representing the rectangle to be
>  *                copied, or nullptr to copy the entire surface.
>  * @param dst the Surface structure that is the blit target.
>  * @param dstpos the Point structure representing the x and y position in
>  *                the destination surface.
>  * @throws Error on failure.
>  *
>  * @threadsafety Only one thread should be using the `src` and `dst` surfaces
>  *               at any given time.
>  *
>  * @since This function is available since SDL 3.2.0.
>  *
>  * @sa Surface.BlitSurface
>  */
3608c3750
<   static_assert(false, "Not implemented");
---
>   BlitSurface(src, srcrect, dst, SDL_Rect{dstpos.x, dstpos.y});
3637c3779
<   CheckError(SDL_BlitSurfaceUnchecked(src, srcrect, dst, dstrect));
---
>   CheckError(SDL_BlitSurfaceUnchecked(src, &srcrect, dst, &dstrect));
3644c3786
<   SDL::BlitSurfaceUnchecked(m_resource, src, srcrect, dstrect);
---
>   SDL::BlitSurfaceUnchecked(src, srcrect, m_resource, dstrect);
3682c3824
<   SDL::BlitSurfaceScaled(m_resource, src, srcrect, dstrect, scaleMode);
---
>   SDL::BlitSurfaceScaled(src, srcrect, m_resource, dstrect, scaleMode);
3714c3856
<     SDL_BlitSurfaceUncheckedScaled(src, srcrect, dst, dstrect, scaleMode));
---
>     SDL_BlitSurfaceUncheckedScaled(src, &srcrect, dst, &dstrect, scaleMode));
3722c3864
<   SDL::BlitSurfaceUncheckedScaled(m_resource, src, srcrect, dstrect, scaleMode);
---
>   SDL::BlitSurfaceUncheckedScaled(src, srcrect, m_resource, dstrect, scaleMode);
3756,3759d3897
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
3765c3903
<   SDL::StretchSurface(m_resource, src, srcrect, dstrect, scaleMode);
---
>   SDL::StretchSurface(src, srcrect, m_resource, dstrect, scaleMode);
3805c3943
<   SDL::BlitSurfaceTiled(m_resource, src, srcrect, dstrect);
---
>   SDL::BlitSurfaceTiled(src, srcrect, m_resource, dstrect);
3853c3991
<     m_resource, src, srcrect, scale, scaleMode, dstrect);
---
>     src, srcrect, scale, scaleMode, m_resource, dstrect);
3874,3876d4011
<  * @param scale the scale used to transform the corner of `srcrect` into the
<  *              corner of `dstrect`, or 0.0f for an unscaled blit.
<  * @param scaleMode scale algorithm to be used.
3880c4015,4018
<  * surface.
---
>  *                surface.
>  * @param scale the scale used to transform the corner of `srcrect` into the
>  *              corner of `dstrect`, or 0.0f for an unscaled blit.
>  * @param scaleMode scale algorithm to be used.
3907,3908d4044
<                                   dst,
<                                   dstrect,
3910c4046,4048
<                                   scaleMode));
---
>                                   scaleMode,
>                                   dst,
>                                   dstrect));
3923,3924c4061
<   SDL::BlitSurface9Grid(m_resource,
<                         src,
---
>   SDL::BlitSurface9Grid(src,
3929a4067
>                         m_resource,
3998,4001c4136
<  * @param r the red component of the pixel in the range 0-255.
<  * @param g the green component of the pixel in the range 0-255.
<  * @param b the blue component of the pixel in the range 0-255.
<  * @param a the alpha component of the pixel in the range 0-255.
---
>  * @param c the color components of the pixel in the range 0-255.
4013c4148
<   return SDL_MapSurfaceRGBA(surface, c);
---
>   return SDL_MapSurfaceRGBA(surface, c.r, c.g, c.b, c.a);
4031,4032c4166
<  * @param x the horizontal coordinate, 0 <= x < width.
<  * @param y the vertical coordinate, 0 <= y < height.
---
>  * @param p the coordinates, 0 <= x < width and 0 <= y < height.
4055c4189
<   CheckError(SDL_ReadSurfacePixel(surface, p, r, g, b, a));
---
>   CheckError(SDL_ReadSurfacePixel(surface, p.x, p.y, r, g, b, a));
4068,4077c4202,4203
<  * @param x the horizontal coordinate, 0 <= x < width.
<  * @param y the vertical coordinate, 0 <= y < height.
<  * @param r a pointer filled in with the red channel, 0-255, or nullptr to
<  * ignore this channel.
<  * @param g a pointer filled in with the green channel, 0-255, or nullptr to
<  *          ignore this channel.
<  * @param b a pointer filled in with the blue channel, 0-255, or nullptr to
<  *          ignore this channel.
<  * @param a a pointer filled in with the alpha channel, 0-255, or nullptr to
<  *          ignore this channel.
---
>  * @param p the coordinates, 0 <= x < width and 0 <= y < height.
>  * @returns color on success.
4087c4213,4215
<   static_assert(false, "Not implemented");
---
>   Color c;
>   ReadSurfacePixel(surface, p, &c.r, &c.g, &c.b, &c.a);
>   return c;
4111,4112c4239
<  * @param x the horizontal coordinate, 0 <= x < width.
<  * @param y the vertical coordinate, 0 <= y < height.
---
>  * @param p the coordinates, 0 <= x < width and 0 <= y < height.
4135c4262
<   CheckError(SDL_ReadSurfacePixelFloat(surface, p, r, g, b, a));
---
>   CheckError(SDL_ReadSurfacePixelFloat(surface, p.x, p.y, r, g, b, a));
4145,4154c4272,4273
<  * @param x the horizontal coordinate, 0 <= x < width.
<  * @param y the vertical coordinate, 0 <= y < height.
<  * @param r a pointer filled in with the red channel, normally in the range
<  *          0-1, or nullptr to ignore this channel.
<  * @param g a pointer filled in with the green channel, normally in the range
<  *          0-1, or nullptr to ignore this channel.
<  * @param b a pointer filled in with the blue channel, normally in the range
<  *          0-1, or nullptr to ignore this channel.
<  * @param a a pointer filled in with the alpha channel, normally in the range
<  *          0-1, or nullptr to ignore this channel.
---
>  * @param p the coordinates, 0 <= x < width and 0 <= y < height.
>  * @returns color on success.
4165c4284,4286
<   static_assert(false, "Not implemented");
---
>   FColor c;
>   ReadSurfacePixelFloat(surface, p, &c.r, &c.g, &c.b, &c.a);
>   return c;
4192,4197c4313,4314
<  * @param x the horizontal coordinate, 0 <= x < width.
<  * @param y the vertical coordinate, 0 <= y < height.
<  * @param r the red channel value, 0-255.
<  * @param g the green channel value, 0-255.
<  * @param b the blue channel value, 0-255.
<  * @param a the alpha channel value, 0-255.
---
>  * @param p the coordinates, 0 <= x < width, 0 <= y < height.
>  * @param c the color channels value, 0-255.
4209c4326
<   CheckError(SDL_WriteSurfacePixel(surface, p, c));
---
>   CheckError(SDL_WriteSurfacePixel(surface, p.x, p.y, c.r, c.g, c.b, c.a));
4224,4229c4341,4342
<  * @param x the horizontal coordinate, 0 <= x < width.
<  * @param y the vertical coordinate, 0 <= y < height.
<  * @param r the red channel value, normally in the range 0-1.
<  * @param g the green channel value, normally in the range 0-1.
<  * @param b the blue channel value, normally in the range 0-1.
<  * @param a the alpha channel value, normally in the range 0-1.
---
>  * @param p the coordinates, 0 <= x < width, 0 <= y < height.
>  * @param c the color channels values, normally in the range 0-1.
4241c4354
<   CheckError(SDL_WriteSurfacePixelFloat(surface, p, c));
---
>   CheckError(SDL_WriteSurfacePixelFloat(surface, p.x, p.y, c.r, c.g, c.b, c.a));
4249,4252c4362,4365
< constexpr int GetSurfaceWidth(SurfaceConstParam surface)
< {
<   static_assert(false, "Not implemented");
< }
---
> /**
>  * Get the width in pixels.
>  */
> constexpr int GetSurfaceWidth(SurfaceConstParam surface) { return surface->w; }
4259,4262c4372,4375
< constexpr int GetSurfaceHeight(SurfaceConstParam surface)
< {
<   static_assert(false, "Not implemented");
< }
---
> /**
>  * Get the height in pixels.
>  */
> constexpr int GetSurfaceHeight(SurfaceConstParam surface) { return surface->h; }
4268a4382,4384
> /**
>  * Get the size in pixels.
>  */
4271c4387
<   static_assert(false, "Not implemented");
---
>   return Point(surface->w, surface->h);
4278a4395,4397
> /**
>  * Get pitch in bytes.
>  */
4281c4400
<   static_assert(false, "Not implemented");
---
>   return surface->pitch;
4288a4408,4410
> /**
>  * Get the pixel format.
>  */
4291c4413
<   static_assert(false, "Not implemented");
---
>   return surface->format;
4298a4421,4423
> /**
>  * Get the pixels.
>  */
4301c4426
<   static_assert(false, "Not implemented");
---
>   return surface->pixels;
