19c19
<  * @defgroup CategorySurface Category Surface
---
>  * @defgroup CategorySurface Surface Creation and Simple Drawing
69d68
<   /// Constructs from const SurfaceRaw
117c116
< constexpr bool MUSTLOCK(SurfaceConstParam S) { return SDL_MUSTLOCK(S); }
---
> constexpr bool MUSTLOCK(SurfaceConstParam S) { return SDL_MUSTLOCK((S.value)); }
175a175,176
>  * @cat resource
>  *
178,179d178
<  *
<  * @cat resource
215,216c214
<    * @param width the width of the surface.
<    * @param height the height of the surface.
---
>    * @param size the width and height of the surface.
229c227
<     : m_resource(SDL_CreateSurface(size, format))
---
>     : m_resource(SDL_CreateSurface(size.x, size.y, format))
246,247c244
<    * @param width the width of the surface.
<    * @param height the height of the surface.
---
>    * @param size the width and height of the surface.
262c259
<     : m_resource(SDL_CreateSurfaceFrom(size, format, pixels, pitch))
---
>     : m_resource(SDL_CreateSurfaceFrom(size.x, size.y, format, pixels, pitch))
403c400
<     return CheckError(SDL_GetSurfaceProperties(m_resource));
---
>     return {CheckError(SDL_GetSurfaceProperties(m_resource))};
412,413c409
<    * @param colorspace an Colorspace value describing the surface
<    *                   colorspace.
---
>    * @param colorspace a Colorspace value describing the surface colorspace.
476c472
<     return CheckError(SDL_CreateSurfacePalette(m_resource));
---
>     return Palette::Borrow(CheckError(SDL_CreateSurfacePalette(m_resource)));
511c507,512
<   Palette GetPalette() const { return SDL_GetSurfacePalette(m_resource); }
---
>   Palette GetPalette() const
>   {
>     auto p = SDL_GetSurfacePalette(m_resource);
>     if (!p) return {};
>     return Palette::Borrow(p);
>   }
524,525c525
<    * @param image a pointer to an alternate Surface to associate with this
<    *              surface.
---
>    * @param image an alternate Surface to associate with this surface.
565,571d564
<    * Freeing the array of surfaces does not affect the surfaces in the array.
<    * They are still referenced by the surface being queried and will be cleaned
<    * up normally.
<    *
<    * @param surface the Surface structure to query.
<    * @param count a pointer filled in with the number of surface pointers
<    *              returned, may be nullptr.
573,574c566
<    *          failure; call GetError() for more information. This should be
<    *          freed with free() when it is no longer needed.
---
>    *          failure; call GetError() for more information.
586c578,580
<     return SDL_GetSurfaceImages(m_resource);
---
>     int count = 0;
>     auto data = SDL_GetSurfaceImages(m_resource, &count);
>     return OwnArray<SurfaceRaw>(CheckError(data), count);
609c603
<    * @since This macro is available since SDL 3.2.0.
---
>    * @since This function is available since SDL 3.2.0.
621,623c615,617
<    * Not all surfaces require locking. If `Surface.MustLock(surface)` evaluates
<    * to 0, then you can read and write to the surface at any time, and the pixel
<    * format of the surface will not change.
---
>    * Not all surfaces require locking. If `Surface.MustLock()` evaluates to
>    * false, then you can read and write to the surface at any time, and the
>    * pixel format of the surface will not change.
749,750c743
<    * @param enabled true to enable color key, false to disable color key.
<    * @param key the transparent pixel.
---
>    * @param key the transparent pixel or std::nullopt to disable it.
763c756,757
<     CheckError(SDL_SetSurfaceColorKey(m_resource, key));
---
>     CheckError(
>       SDL_SetSurfaceColorKey(m_resource, key.has_value(), key.value_or(0)));
766c760,769
<   void ClearColorKey() { static_assert(false, "Not implemented"); }
---
>   /**
>    * Unset the color key (transparent pixel) in a surface.
>    *
>    * The color key defines a pixel value that will be treated as transparent in
>    * a blit. For example, one can use this to specify that cyan pixels should be
>    * considered transparent, and therefore not rendered.
>    *
>    * @throws Error on failure.
>    */
>   void ClearColorKey() { SetColorKey(std::nullopt); }
771,772d773
<    * It is safe to pass a nullptr `surface` here; it will return false.
<    *
804c805,806
<     return CheckError(SDL_GetSurfaceColorKey(m_resource));
---
>     if (Uint32 key; SDL_GetSurfaceColorKey(m_resource, &key)) return key;
>     return std::nullopt;
879d880
<    * @param alpha a pointer filled in with the current alpha value.
891c892,894
<     return CheckError(SDL_GetSurfaceAlphaMod(m_resource));
---
>     Uint8 alpha;
>     CheckError(SDL_GetSurfaceAlphaMod(m_resource, &alpha));
>     return alpha;
894c897,915
<   void SetMod(Color color) { static_assert(false, "Not implemented"); }
---
>   /**
>    * Set an additional color and alpha value multiplied into blit
>    * operations.
>    *
>    * When this surface is blitted, during the blit operation each source color
>    * channel is modulated by the appropriate color value according to the
>    * following formula:
>    *
>    * `srcC = srcC * (color / 255)`
>    * `srcA = srcA * (alpha / 255)`
>    *
>    * @param color the color to be multiplied in blit operations
>    * @throws Error on failure.
>    */
>   void SetMod(Color color)
>   {
>     SetColorMod(color.r, color.g, color.b);
>     SetAlphaMod(color.a);
>   }
896c917,930
<   Color GetMod() const { static_assert(false, "Not implemented"); }
---
>   /**
>    * Get the additional color and alpha value multiplied into blit
>    * operations.
>    *
>    * @returns a Color containing RGBA value on success or std::nullopt on
>    * failure; call GetError() for more information.
>    */
>   Color GetMod() const
>   {
>     Color c;
>     GetColorMod(&c.r, &c.g, &c.b);
>     c.a = GetAlphaMod();
>     return c;
>   }
933c967,969
<     return CheckError(SDL_GetSurfaceBlendMode(m_resource));
---
>     BlendMode blendmode;
>     CheckError(SDL_GetSurfaceBlendMode(m_resource, &blendmode));
>     return blendmode;
953a990
>    * @sa Surface.ResetClipRect()
961c998,1003
<   void ResetClipRect() { static_assert(false, "Not implemented"); }
---
>   /**
>    * Disable the clipping rectangle for a surface.
>    *
>    * @sa SetClipRect()
>    */
>   void ResetClipRect() { SDL_SetSurfaceClipRect(m_resource, nullptr); }
969,971c1011,1012
<    *                clipped.
<    * @param rect an Rect structure filled in with the clipping rectangle for
<    *             the surface.
---
>    * @returns the Rect structure filled in with the clipping rectangle for the
>    *          surface on success.
982c1023,1025
<     return CheckError(SDL_GetSurfaceClipRect(m_resource));
---
>     Rect r;
>     CheckError(SDL_GetSurfaceClipRect(m_resource, &r));
>     return r;
1003,1004d1045
<    * The returned surface should be freed with Surface.Destroy().
<    *
1014c1055,1058
<   Surface Duplicate() const { return SDL_DuplicateSurface(m_resource); }
---
>   Surface Duplicate() const
>   {
>     return Surface{SDL_DuplicateSurface(m_resource)};
>   }
1020,1023c1064
<    * The returned surface should be freed with Surface.Destroy().
<    *
<    * @param width the width of the new surface.
<    * @param height the height of the new surface.
---
>    * @param size the width and height of the new surface.
1036c1077
<     return SDL_ScaleSurface(m_resource, size, scaleMode);
---
>     return Surface{SDL_ScaleSurface(m_resource, size.x, size.y, scaleMode)};
1066c1107
<     return SDL_ConvertSurface(m_resource, format);
---
>     return Surface(SDL_ConvertSurface(m_resource, format));
1100,1101c1141,1142
<     return SDL_ConvertSurfaceAndColorspace(
<       m_resource, format, palette, colorspace, props);
---
>     return Surface(SDL_ConvertSurfaceAndColorspace(
>       m_resource, format, palette, colorspace, props));
1128c1169
<    * otherwise the color is assumed to be in the colorspace of the suface.
---
>    * otherwise the color is assumed to be in the colorspace of the surface.
1130,1133c1171
<    * @param r the red component of the pixel, normally in the range 0-1.
<    * @param g the green component of the pixel, normally in the range 0-1.
<    * @param b the blue component of the pixel, normally in the range 0-1.
<    * @param a the alpha component of the pixel, normally in the range 0-1.
---
>    * @param c the color components of the pixel, normally in the range 0-1.
1142c1180,1181
<     CheckError(SDL_ClearSurface(m_resource, color));
---
>     CheckError(
>       SDL_ClearSurface(m_resource, color.r, color.g, color.b, color.a));
1145c1184,1194
<   void Fill(Uint32 color) { static_assert(false, "Not implemented"); }
---
>   /**
>    * Perform a fast fill of a rectangle with a specific color.
>    *
>    * If there is a clip rectangle set on the destination (set via
>    * Surface.SetClipRect()), then this function will fill based on the
>    * intersection of the clip rectangle and `rect`.
>    *
>    * @param color the color to fill with.
>    * @throws Error on failure.
>    */
>   void Fill(Uint32 color) { FillRect({}, color); }
1188d1236
<    * @param count the number of rectangles in the array.
1200c1248,1249
<     CheckError(SDL_FillSurfaceRects(m_resource, rects, color));
---
>     CheckError(
>       SDL_FillSurfaceRects(m_resource, rects.data(), rects.size(), color));
1254a1304
>    * @param src the SurfaceRaw structure to be copied from.
1257d1306
<    * @param dst the Surface structure that is the blit target.
1276c1325
<     CheckError(SDL_BlitSurface(m_resource, src, srcrect, dstrect));
---
>     CheckError(SDL_BlitSurface(src, srcrect, m_resource, dstrect));
1278a1328,1397
>   /**
>    * Performs a fast blit from the source surface to the destination surface
>    * with clipping.
>    *
>    * If either `srcrect` or `dstrect` are nullptr, the entire surface (`src` or
>    * `dst`) is copied while ensuring clipping to `dst->clip_rect`.
>    *
>    * The blit function should not be called on a locked surface.
>    *
>    * The blit semantics for surfaces with and without blending and colorkey are
>    * defined as follows:
>    *
>    * ```
>    *    RGBA->RGB:
>    *      Source surface blend mode set to BLENDMODE_BLEND:
>    *       alpha-blend (using the source alpha-channel and per-surface alpha)
>    *       SDL_SRCCOLORKEY ignored.
>    *     Source surface blend mode set to BLENDMODE_NONE:
>    *       copy RGB.
>    *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
>    *       RGB values of the source color key, ignoring alpha in the
>    *       comparison.
>    *
>    *   RGB->RGBA:
>    *     Source surface blend mode set to BLENDMODE_BLEND:
>    *       alpha-blend (using the source per-surface alpha)
>    *     Source surface blend mode set to BLENDMODE_NONE:
>    *       copy RGB, set destination alpha to source per-surface alpha value.
>    *     both:
>    *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
>    *       source color key.
>    *
>    *   RGBA->RGBA:
>    *     Source surface blend mode set to BLENDMODE_BLEND:
>    *       alpha-blend (using the source alpha-channel and per-surface alpha)
>    *       SDL_SRCCOLORKEY ignored.
>    *     Source surface blend mode set to BLENDMODE_NONE:
>    *       copy all of RGBA to the destination.
>    *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
>    *       RGB values of the source color key, ignoring alpha in the
>    *       comparison.
>    *
>    *   RGB->RGB:
>    *     Source surface blend mode set to BLENDMODE_BLEND:
>    *       alpha-blend (using the source per-surface alpha)
>    *     Source surface blend mode set to BLENDMODE_NONE:
>    *       copy RGB.
>    *     both:
>    *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
>    *       source color key.
>    * ```
>    *
>    * @param src the SurfaceRaw structure to be copied from.
>    * @param srcrect the Rect structure representing the rectangle to be
>    *                copied, or nullptr to copy the entire surface.
>    * @param dstpos the Point structure representing the x and y position in
>    *                the destination surface, or nullptr for (0,0). The width and
>    *                height are ignored, and are copied from `srcrect`. If you
>    *                want a specific width and height, you should use
>    *                Surface.BlitScaled().
>    * @throws Error on failure.
>    *
>    * @threadsafety Only one thread should be using the `src` and `dst` surfaces
>    *               at any given time.
>    *
>    * @since This function is available since SDL 3.2.0.
>    *
>    * @sa Surface.Blit
>    * @sa Surface.BlitScaled
>    */
1283c1402
<     static_assert(false, "Not implemented");
---
>     Blit(src, srcrect, Rect{dstpos, {}});
1291a1411
>    * @param src the Surface structure to be copied from.
1294d1413
<    * @param dst the Surface structure that is the blit target.
1310c1429
<     CheckError(SDL_BlitSurfaceUnchecked(m_resource, src, srcrect, dstrect));
---
>     CheckError(SDL_BlitSurfaceUnchecked(src, &srcrect, m_resource, &dstrect));
1316a1436
>    * @param src the Surface structure to be copied from.
1319d1438
<    * @param dst the Surface structure that is the blit target.
1339c1458
<       SDL_BlitSurfaceScaled(m_resource, src, srcrect, dstrect, scaleMode));
---
>       SDL_BlitSurfaceScaled(src, srcrect, m_resource, dstrect, scaleMode));
1347a1467
>    * @param src the Surface structure to be copied from.
1350d1469
<    * @param dst the Surface structure that is the blit target.
1368,1369c1487,1488
<     CheckError(SDL_BlitSurfaceUncheckedScaled(
<       m_resource, src, srcrect, dstrect, scaleMode));
---
>     CheckError(
>       SDL_BlitSurfaceScaled(src, &srcrect, m_resource, &dstrect, scaleMode));
1376a1496
>    * @param src the Surface structure to be copied from.
1379d1498
<    * @param dst the Surface structure that is the blit target.
1389c1508
<    * @since This function is available since SDL 3.4.0.
---
>    * @since This function is available since SDL 3.2.4.
1399c1518
<       SDL_StretchSurface(m_resource, src, srcrect, dstrect, scaleMode));
---
>       SDL_StretchSurface(src, srcrect, m_resource, dstrect, scaleMode));
1410a1530
>    * @param src the SDL_Surface structure to be copied from.
1413d1532
<    * @param dst the Surface structure that is the blit target.
1430c1549
<     CheckError(SDL_BlitSurfaceTiled(m_resource, src, srcrect, dstrect));
---
>     CheckError(SDL_BlitSurfaceTiled(src, srcrect, m_resource, dstrect));
1439a1559
>    * @param src the SDL_Surface structure to be copied from.
1446d1565
<    * @param dst the Surface structure that is the blit target.
1466c1585
<       m_resource, src, srcrect, scale, scaleMode, dstrect));
---
>       src, srcrect, scale, scaleMode, m_resource, dstrect));
1468a1588,1617
>   /**
>    * Perform a scaled blit using the 9-grid algorithm to a destination surface,
>    * which may be of a different format.
>    *
>    * The pixels in the source surface are split into a 3x3 grid, using the
>    * different corner sizes for each corner, and the sides and center making up
>    * the remaining pixels. The corners are then scaled using `scale` and fit
>    * into the corners of the destination rectangle. The sides and center are
>    * then stretched into place to cover the remaining destination rectangle.
>    *
>    * @param src the SDL_Surface structure to be copied from.
>    * @param srcrect the Rect structure representing the rectangle to be used
>    *                for the 9-grid, or nullptr to use the entire surface.
>    * @param left_width the width, in pixels, of the left corners in `srcrect`.
>    * @param right_width the width, in pixels, of the right corners in `srcrect`.
>    * @param top_height the height, in pixels, of the top corners in `srcrect`.
>    * @param bottom_height the height, in pixels, of the bottom corners in
>    *                      `srcrect`.
>    * @param dstrect the Rect structure representing the target rectangle in
>    *                the destination surface, or nullptr to fill the entire
>    * surface.
>    * @throws Error on failure.
>    *
>    * @threadsafety Only one thread should be using the `src` and `dst` surfaces
>    *               at any given time.
>    *
>    * @since This function is available since SDL 3.2.0.
>    *
>    * @sa Surface.Blit
>    */
1477c1626,1634
<     static_assert(false, "Not implemented");
---
>     Blit9GridWithScale(src,
>                        srcrect,
>                        left_width,
>                        right_width,
>                        top_height,
>                        bottom_height,
>                        0.0,
>                        SDL_SCALEMODE_NEAREST,
>                        dstrect);
1489a1647
>    * @param src the SDL_Surface structure to be copied from.
1500d1657
<    * @param dst the Surface structure that is the blit target.
1523,1524c1680
<     CheckError(SDL_BlitSurface9Grid(m_resource,
<                                     src,
---
>     CheckError(SDL_BlitSurface9Grid(src,
1531a1688
>                                     m_resource,
1587,1590c1744
<    * @param r the red component of the pixel in the range 0-255.
<    * @param g the green component of the pixel in the range 0-255.
<    * @param b the blue component of the pixel in the range 0-255.
<    * @param a the alpha component of the pixel in the range 0-255.
---
>    * @param c the color components of the pixel in the range 0-255.
1599c1753,1756
<   Uint32 MapRGBA(ColorRaw c) const { return SDL_MapSurfaceRGBA(m_resource, c); }
---
>   Uint32 MapRGBA(ColorRaw c) const
>   {
>     return SDL_MapSurfaceRGBA(m_resource, c.r, c.g, c.b, c.a);
>   }
1600a1758,1770
>   /**
>    * This function prioritizes correctness over speed: it is suitable for
>    * unit tests, but is not intended for use in a game engine.
>    *
>    * Like SDL_GetRGBA, this uses the entire 0..255 range when converting color
>    * components from pixel formats with less than 8 bits per RGB component.
>    *
>    * @param p the coordinates, 0 <= x < width and 0 <= y < height.
>    * @returns color on success.
>    * @throws Error on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    */
1603c1773,1775
<     static_assert(false, "Not implemented");
---
>     Color c;
>     ReadPixel(p, &c.r, &c.g, &c.b, &c.a);
>     return c;
1615,1616c1787
<    * @param x the horizontal coordinate, 0 <= x < width.
<    * @param y the vertical coordinate, 0 <= y < height.
---
>    * @param p the coordinates, 0 <= x < width and 0 <= y < height.
1637c1808
<     CheckError(SDL_ReadSurfacePixel(m_resource, p, r, g, b, a));
---
>     CheckError(SDL_ReadSurfacePixel(m_resource, p.x, p.y, r, g, b, a));
1639a1811,1822
>   /**
>    * Retrieves a single pixel from a surface.
>    *
>    * This function prioritizes correctness over speed: it is suitable for unit
>    * tests, but is not intended for use in a game engine.
>    *
>    * @param p the coordinates, 0 <= x < width and 0 <= y < height.
>    * @returns color on success.
>    * @throws Error on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    */
1642c1825,1827
<     static_assert(false, "Not implemented");
---
>     FColor c;
>     ReadPixelFloat(p, &c.r, &c.g, &c.b, &c.a);
>     return c;
1651,1652c1836
<    * @param x the horizontal coordinate, 0 <= x < width.
<    * @param y the vertical coordinate, 0 <= y < height.
---
>    * @param p the coordinates, 0 <= x < width and 0 <= y < height.
1673c1857
<     CheckError(SDL_ReadSurfacePixelFloat(m_resource, p, r, g, b, a));
---
>     CheckError(SDL_ReadSurfacePixelFloat(m_resource, p.x, p.y, r, g, b, a));
1685,1690c1869,1870
<    * @param x the horizontal coordinate, 0 <= x < width.
<    * @param y the vertical coordinate, 0 <= y < height.
<    * @param r the red channel value, 0-255.
<    * @param g the green channel value, 0-255.
<    * @param b the blue channel value, 0-255.
<    * @param a the alpha channel value, 0-255.
---
>    * @param p the coordinates, 0 <= x < width and 0 <= y < height.
>    * @param c the color values, 0-255.
1699c1879
<     CheckError(SDL_WriteSurfacePixel(m_resource, p, c));
---
>     CheckError(SDL_WriteSurfacePixel(m_resource, p.x, p.y, c.r, c.g, c.b, c.a));
1708,1713c1888,1889
<    * @param x the horizontal coordinate, 0 <= x < width.
<    * @param y the vertical coordinate, 0 <= y < height.
<    * @param r the red channel value, normally in the range 0-1.
<    * @param g the green channel value, normally in the range 0-1.
<    * @param b the blue channel value, normally in the range 0-1.
<    * @param a the alpha channel value, normally in the range 0-1.
---
>    * @param p the coordinates, 0 <= x < width and 0 <= y < height.
>    * @param c the color values, normally in the range 0-1.
1722c1898,1899
<     CheckError(SDL_WriteSurfacePixelFloat(m_resource, p, c));
---
>     CheckError(
>       SDL_WriteSurfacePixelFloat(m_resource, p.x, p.y, c.r, c.g, c.b, c.a));
1725c1902,1905
<   int GetWidth() const { static_assert(false, "Not implemented"); }
---
>   /**
>    * Get the width in pixels.
>    */
>   constexpr int GetWidth() const { return m_resource->w; }
1727c1907,1910
<   int GetHeight() const { static_assert(false, "Not implemented"); }
---
>   /**
>    * Get the height in pixels.
>    */
>   constexpr int GetHeight() const { return m_resource->h; }
1729c1912,1915
<   Point GetSize() const { static_assert(false, "Not implemented"); }
---
>   /**
>    * Get the size in pixels.
>    */
>   constexpr Point GetSize() const { return Point(GetWidth(), GetHeight()); }
1731c1917,1920
<   int GetPitch() const { static_assert(false, "Not implemented"); }
---
>   /**
>    * Get pitch in bytes.
>    */
>   constexpr int GetPitch() const { return m_resource->pitch; }
1733c1922,1925
<   PixelFormat GetFormat() const { static_assert(false, "Not implemented"); }
---
>   /**
>    * Get the pixel format.
>    */
>   constexpr PixelFormat GetFormat() const { return m_resource->format; }
1735c1927,1930
<   void* GetPixels() const { static_assert(false, "Not implemented"); }
---
>   /**
>    * Get the pixels.
>    */
>   constexpr void* GetPixels() const { return m_resource->pixels; }
1743,1744c1938
<  * @param width the width of the surface.
<  * @param height the height of the surface.
---
>  * @param size the width and height of the surface.
1758c1952
<   return Surface(SDL_CreateSurface(size, format));
---
>   return Surface(SDL_CreateSurface(size.x, size.y, format));
1774,1775c1968
<  * @param width the width of the surface.
<  * @param height the height of the surface.
---
>  * @param size the width and height of the surface.
1794c1987
<   return Surface(SDL_CreateSurfaceFrom(size, format, pixels, pitch));
---
>   return Surface(SDL_CreateSurfaceFrom(size.x, size.y, format, pixels, pitch));
1847c2040
<   return CheckError(SDL_GetSurfaceProperties(surface));
---
>   return {CheckError(SDL_GetSurfaceProperties(surface))};
1863,1866d2055
< #endif // SDL_VERSION_ATLEAST(3, 2, 6)
< 
< #if SDL_VERSION_ATLEAST(3, 2, 6)
< 
1946c2135
<   return CheckError(SDL_CreateSurfacePalette(surface));
---
>   return Palette::Borrow(CheckError(SDL_CreateSurfacePalette(surface)));
1985c2174
<   return SDL_GetSurfacePalette(surface);
---
>   return Palette::Borrow(SDL_GetSurfacePalette(surface));
2063c2252,2254
<   return SDL_GetSurfaceImages(surface);
---
>   int count = 0;
>   auto data = SDL_GetSurfaceImages(surface, &count);
>   return OwnArray<SurfaceRaw>(CheckError(data), count);
2095c2286
<  * Not all surfaces require locking. If `Surface.MustLock(surface)` evaluates to
---
>  * Not all surfaces require locking. If `Surface.MustLock()` evaluates to
2297c2488
<   CheckError(SDL_SetSurfaceColorKey(surface, key));
---
>   CheckError(SDL_SetSurfaceColorKey(surface, key.has_value(), key.value_or(0)));
2341c2532,2533
<   return CheckError(SDL_GetSurfaceColorKey(surface));
---
>   if (Uint32 key; SDL_GetSurfaceColorKey(surface, &key)) return key;
>   return std::nullopt;
2435c2627,2629
<   return CheckError(SDL_GetSurfaceAlphaMod(surface));
---
>   Uint8 alpha;
>   CheckError(SDL_GetSurfaceAlphaMod(surface, &alpha));
>   return alpha;
2475c2669,2671
<   return CheckError(SDL_GetSurfaceBlendMode(surface));
---
>   BlendMode blendmode;
>   CheckError(SDL_GetSurfaceBlendMode(surface, &blendmode));
>   return blendmode;
2525c2721,2723
<   return CheckError(SDL_GetSurfaceClipRect(surface));
---
>   Rect r;
>   CheckError(SDL_GetSurfaceClipRect(surface, &r));
>   return r;
2564c2762
<   return SDL_DuplicateSurface(surface);
---
>   return Surface(SDL_DuplicateSurface(surface));
2574,2575c2772
<  * @param width the width of the new surface.
<  * @param height the height of the new surface.
---
>  * @param size the width and height of the surface.
2590c2787
<   return SDL_ScaleSurface(surface, size, scaleMode);
---
>   return Surface(SDL_ScaleSurface(surface, size.x, size.y, scaleMode));
2621c2818
<   return SDL_ConvertSurface(surface, format);
---
>   return Surface(SDL_ConvertSurface(surface, format));
2657,2658c2854,2855
<   return SDL_ConvertSurfaceAndColorspace(
<     surface, format, palette, colorspace, props);
---
>   return Surface{SDL_ConvertSurfaceAndColorspace(
>     surface, format, palette, colorspace, props)};
2664,2665c2861
<  * @param width the width of the block to copy, in pixels.
<  * @param height the height of the block to copy, in pixels.
---
>  * @param size the width and height of the surface.
2691c2887
<     size, src_format, src, src_pitch, dst_format, dst, dst_pitch));
---
>     size.x, size.y, src_format, src, src_pitch, dst_format, dst, dst_pitch));
2698,2699c2894
<  * @param width the width of the block to copy, in pixels.
<  * @param height the height of the block to copy, in pixels.
---
>  * @param size the width and height  of the block to copy, in pixels.
2736c2931,2932
<   CheckError(SDL_ConvertPixelsAndColorspace(size,
---
>   CheckError(SDL_ConvertPixelsAndColorspace(size.x,
>                                             size.y,
2754,2755c2950
<  * @param width the width of the block to convert, in pixels.
<  * @param height the height of the block to convert, in pixels.
---
>  * @param size the width and height of the surface.
2781,2782c2976,2984
<   CheckError(SDL_PremultiplyAlpha(
<     size, src_format, src, src_pitch, dst_format, dst, dst_pitch, linear));
---
>   CheckError(SDL_PremultiplyAlpha(size.x,
>                                   size.y,
>                                   src_format,
>                                   src,
>                                   src_pitch,
>                                   dst_format,
>                                   dst,
>                                   dst_pitch,
>                                   linear));
2813,2816c3015
<  * @param r the red component of the pixel, normally in the range 0-1.
<  * @param g the green component of the pixel, normally in the range 0-1.
<  * @param b the blue component of the pixel, normally in the range 0-1.
<  * @param a the alpha component of the pixel, normally in the range 0-1.
---
>  * @param c the color components of the pixel, normally in the range 0-1.
2825c3024
<   CheckError(SDL_ClearSurface(surface, color));
---
>   CheckError(SDL_ClearSurface(surface, color.r, color.g, color.b, color.a));
2887c3086
<   CheckError(SDL_FillSurfaceRects(dst, rects, color));
---
>   CheckError(SDL_FillSurfaceRects(dst, rects.data(), rects.size(), color));
2967a3167,3233
> /**
>  * Performs a fast blit from the source surface to the destination surface
>  * with clipping.
>  *
>  * If either `srcrect` or `dstrect` are nullptr, the entire surface (`src` or
>  * `dst`) is copied while ensuring clipping to `dst->clip_rect`.
>  *
>  * The blit function should not be called on a locked surface.
>  *
>  * The blit semantics for surfaces with and without blending and colorkey are
>  * defined as follows:
>  *
>  * ```
>  *    RGBA->RGB:
>  *      Source surface blend mode set to BLENDMODE_BLEND:
>  *       alpha-blend (using the source alpha-channel and per-surface alpha)
>  *       SDL_SRCCOLORKEY ignored.
>  *     Source surface blend mode set to BLENDMODE_NONE:
>  *       copy RGB.
>  *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
>  *       RGB values of the source color key, ignoring alpha in the
>  *       comparison.
>  *
>  *   RGB->RGBA:
>  *     Source surface blend mode set to BLENDMODE_BLEND:
>  *       alpha-blend (using the source per-surface alpha)
>  *     Source surface blend mode set to BLENDMODE_NONE:
>  *       copy RGB, set destination alpha to source per-surface alpha value.
>  *     both:
>  *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
>  *       source color key.
>  *
>  *   RGBA->RGBA:
>  *     Source surface blend mode set to BLENDMODE_BLEND:
>  *       alpha-blend (using the source alpha-channel and per-surface alpha)
>  *       SDL_SRCCOLORKEY ignored.
>  *     Source surface blend mode set to BLENDMODE_NONE:
>  *       copy all of RGBA to the destination.
>  *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
>  *       RGB values of the source color key, ignoring alpha in the
>  *       comparison.
>  *
>  *   RGB->RGB:
>  *     Source surface blend mode set to BLENDMODE_BLEND:
>  *       alpha-blend (using the source per-surface alpha)
>  *     Source surface blend mode set to BLENDMODE_NONE:
>  *       copy RGB.
>  *     both:
>  *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
>  *       source color key.
>  * ```
>  *
>  * @param src the Surface structure to be copied from.
>  * @param srcrect the Rect structure representing the rectangle to be
>  *                copied, or nullptr to copy the entire surface.
>  * @param dst the Surface structure that is the blit target.
>  * @param dstpos the Point structure representing the x and y position in
>  *                the destination surface.
>  * @throws Error on failure.
>  *
>  * @threadsafety Only one thread should be using the `src` and `dst` surfaces
>  *               at any given time.
>  *
>  * @since This function is available since SDL 3.2.0.
>  *
>  * @sa Surface.BlitSurface
>  */
2973c3239
<   static_assert(false, "Not implemented");
---
>   BlitSurface(src, srcrect, dst, SDL_Rect{dstpos.x, dstpos.y});
3002c3268
<   CheckError(SDL_BlitSurfaceUnchecked(src, srcrect, dst, dstrect));
---
>   CheckError(SDL_BlitSurfaceUnchecked(src, &srcrect, dst, &dstrect));
3064c3330
<     SDL_BlitSurfaceUncheckedScaled(src, srcrect, dst, dstrect, scaleMode));
---
>     SDL_BlitSurfaceUncheckedScaled(src, &srcrect, dst, &dstrect, scaleMode));
3269c3535,3544
<   static_assert(false, "Not implemented");
---
>   BlitSurface9Grid(src,
>                    srcrect,
>                    left_width,
>                    right_width,
>                    top_height,
>                    bottom_height,
>                    0.0,
>                    SDL_SCALEMODE_NEAREST,
>                    dst,
>                    dstrect);
3343c3618
<   return SDL_MapSurfaceRGBA(surface, c);
---
>   return SDL_MapSurfaceRGBA(surface, c.r, c.g, c.b, c.a);
3379c3654
<   CheckError(SDL_ReadSurfacePixel(surface, p, r, g, b, a));
---
>   CheckError(SDL_ReadSurfacePixel(surface, p.x, p.y, r, g, b, a));
3412c3687
<   CheckError(SDL_ReadSurfacePixelFloat(surface, p, r, g, b, a));
---
>   CheckError(SDL_ReadSurfacePixelFloat(surface, p.x, p.y, r, g, b, a));
3425,3430c3700,3701
<  * @param x the horizontal coordinate, 0 <= x < width.
<  * @param y the vertical coordinate, 0 <= y < height.
<  * @param r the red channel value, 0-255.
<  * @param g the green channel value, 0-255.
<  * @param b the blue channel value, 0-255.
<  * @param a the alpha channel value, 0-255.
---
>  * @param p the coordinates, 0 <= x < width, 0 <= y < height.
>  * @param c the color channels value, 0-255.
3441c3712
<   CheckError(SDL_WriteSurfacePixel(surface, p, c));
---
>   CheckError(SDL_WriteSurfacePixel(surface, p.x, p.y, c.r, c.g, c.b, c.a));
3451,3456c3722,3723
<  * @param x the horizontal coordinate, 0 <= x < width.
<  * @param y the vertical coordinate, 0 <= y < height.
<  * @param r the red channel value, normally in the range 0-1.
<  * @param g the green channel value, normally in the range 0-1.
<  * @param b the blue channel value, normally in the range 0-1.
<  * @param a the alpha channel value, normally in the range 0-1.
---
>  * @param p the coordinates, 0 <= x < width, 0 <= y < height.
>  * @param c the color channels values, normally in the range 0-1.
3467c3734
<   CheckError(SDL_WriteSurfacePixelFloat(surface, p, c));
---
>   CheckError(SDL_WriteSurfacePixelFloat(surface, p.x, p.y, c.r, c.g, c.b, c.a));
