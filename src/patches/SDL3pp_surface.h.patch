--- src/generated/SDL3pp_surface.h
+++ include/SDL3pp/SDL3pp_surface.h
@@ -16,7 +16,7 @@
 namespace SDL {
 
 /**
- * @defgroup CategorySurface Category Surface
+ * @defgroup CategorySurface Surface Creation and Simple Drawing
  *
  * SDL surfaces are buffers of pixels in system RAM. These are useful for
  * passing around and manipulating images that are not stored in GPU memory.
@@ -29,7 +29,8 @@
  * loader, Surface.LoadPNG(). SDL itself does not provide loaders for other file
  * formats, but there are several excellent external libraries that do,
  * including its own satellite library,
- * [SDL_image](https://wiki.libsdl.org/SDL3_image) .
+ * [SDL_image](https://wiki.libsdl.org/SDL3_image).
+ *
  *
  * In general these functions are thread-safe in that they can be called on
  * different threads with different surfaces. You should not try to modify any
@@ -82,7 +83,7 @@
 {
   const SurfaceRaw value; ///< parameter's const SurfaceRaw
 
-  /// Constructs from const SurfaceRaw
+  /// Constructs from SurfaceRaw
   constexpr SurfaceConstParam(const SurfaceRaw value)
     : value(value)
   {
@@ -142,7 +143,7 @@
  *
  * @since This function is available since SDL 3.2.0.
  */
-constexpr bool MustLock(SurfaceConstParam S) const { return SDL_MUSTLOCK(S); }
+constexpr bool MustLock(SurfaceConstParam S) { return SDL_MUSTLOCK((S.value)); }
 
 /**
  * The scaling mode.
@@ -221,8 +222,6 @@
  *
  * @sa Surface.Surface
  * @sa Surface.Destroy
- *
- * @cat resource
  */
 class Surface
 {
@@ -265,11 +264,9 @@
    *
    * The pixels of the new surface are initialized to zero.
    *
-   * @param width the width of the surface.
-   * @param height the height of the surface.
+   * @param size the width and height of the surface.
    * @param format the PixelFormat for the new surface's pixel format.
-   * @post the new Surface structure that is created or nullptr on failure; call
-   *       GetError() for more information.
+   * @throws Error on failure.
    *
    * @threadsafety It is safe to call this function from any thread.
    *
@@ -279,7 +276,7 @@
    * @sa Surface.Destroy
    */
   Surface(const PointRaw& size, PixelFormat format)
-    : m_resource(SDL_CreateSurface(size, format))
+    : m_resource(CheckError(SDL_CreateSurface(size.x, size.y, format)))
   {
   }
 
@@ -296,13 +293,11 @@
    * You may pass nullptr for pixels and 0 for pitch to create a surface that
    * you will fill in with valid values later.
    *
-   * @param width the width of the surface.
-   * @param height the height of the surface.
+   * @param size the width and height of the surface.
    * @param format the PixelFormat for the new surface's pixel format.
    * @param pixels a pointer to existing pixel data.
    * @param pitch the number of bytes between each row, including padding.
-   * @post the new Surface structure that is created or nullptr on failure; call
-   *       GetError() for more information.
+   * @throws Error on failure.
    *
    * @threadsafety It is safe to call this function from any thread.
    *
@@ -312,7 +307,8 @@
    * @sa Surface.Destroy
    */
   Surface(const PointRaw& size, PixelFormat format, void* pixels, int pitch)
-    : m_resource(SDL_CreateSurfaceFrom(size, format, pixels, pitch))
+    : m_resource(CheckError(
+        SDL_CreateSurfaceFrom(size.x, size.y, format, pixels, pitch)))
   {
   }
 
@@ -344,9 +340,6 @@
    * load images directly into an Texture for use by the GPU without using a
    * software surface: call Texture.Texture() instead.
    *
-   * When done with the returned surface, the app should dispose of it with a
-   * call to [Surface.Destroy](https://wiki.libsdl.org/SDL3/Surface.Destroy) ().
-   *
    * @param file a path on the filesystem to load an image from.
    * @post a new SDL surface, or nullptr on error.
    *
@@ -395,9 +388,6 @@
    * load images directly into an Texture for use by the GPU without using a
    * software surface: call Texture.Texture() instead.
    *
-   * When done with the returned surface, the app should dispose of it with a
-   * call to Surface.Destroy().
-   *
    * @param src an IOStream that data will be read from.
    * @param closeio true to close/free the IOStream before returning, false to
    *                leave it open.
@@ -409,7 +399,7 @@
    * @sa LoadSurfaceTyped
    * @sa Surface.Destroy
    */
-  Surface(IOStreamParam src, bool closeio);
+  Surface(IOStreamParam src, bool closeio = false);
 
   /**
    * Safely borrows the from SurfaceParam.
@@ -478,9 +468,6 @@
    * sources. If you want to load arbitrary images you should use libpng or
    * another image loading library designed with security in mind.
    *
-   * The new surface should be freed with Surface.Destroy(). Not doing so will
-   * result in a memory leak.
-   *
    * @param src the data stream for the surface.
    * @param closeio if true, calls IOStream.Close() on `src` before returning,
    *                even in the case of an error.
@@ -497,10 +484,6 @@
    */
   static Surface LoadPNG(IOStreamParam src, bool closeio = false);
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
   /**
    * Load a PNG image from a file.
    *
@@ -632,7 +615,7 @@
    * Setting the colorspace doesn't change the pixels, only how they are
    * interpreted in color operations.
    *
-   * @param colorspace an Colorspace value describing the surface colorspace.
+   * @param colorspace a Colorspace value describing the surface colorspace.
    * @throws Error on failure.
    *
    * @threadsafety This function can be called on different threads with
@@ -738,8 +721,7 @@
    * This function adds a reference to the alternate version, so you should call
    * Surface.Destroy() on the image after this call.
    *
-   * @param image a pointer to an alternate Surface to associate with this
-   *              surface.
+   * @param image an alternate Surface to associate with this surface.
    * @throws Error on failure.
    *
    * @threadsafety This function can be called on different threads with
@@ -774,15 +756,8 @@
    * This returns all versions of a surface, with the surface being queried as
    * the first element in the returned array.
    *
-   * Freeing the array of surfaces does not affect the surfaces in the array.
-   * They are still referenced by the surface being queried and will be cleaned
-   * up normally.
-   *
-   * @param count a pointer filled in with the number of surface pointers
-   *              returned, may be nullptr.
    * @returns a nullptr terminated array of Surface pointers or nullptr on
-   *          failure; call GetError() for more information. This should be
-   *          freed with free() when it is no longer needed.
+   *          failure; call GetError() for more information.
    *
    * @threadsafety This function can be called on different threads with
    *               different surfaces.
@@ -917,10 +892,6 @@
    */
   void SavePNG(IOStreamParam dst, bool closeio = false) const;
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
   /**
    * Save a surface to a file in PNG format.
    *
@@ -983,8 +954,7 @@
    *
    * It is a pixel of the format used by the surface, as generated by MapRGB().
    *
-   * @param enabled true to enable color key, false to disable color key.
-   * @param key the transparent pixel.
+   * @param key the transparent pixel or std::nullopt to disable it.
    * @throws Error on failure.
    *
    * @threadsafety This function can be called on different threads with
@@ -998,13 +968,20 @@
    */
   void SetColorKey(std::optional<Uint32> key);
 
+  /**
+   * Unset the color key (transparent pixel) in a surface.
+   *
+   * The color key defines a pixel value that will be treated as transparent in
+   * a blit. For example, one can use this to specify that cyan pixels should be
+   * considered transparent, and therefore not rendered.
+   *
+   * @throws Error on failure.
+   */
   void ClearColorKey();
 
   /**
    * Returns whether the surface has a color key.
    *
-   * It is safe to pass a nullptr `surface` here; it will return false.
-   *
    * @returns true if the surface has a color key, false otherwise.
    *
    * @threadsafety It is safe to call this function from any thread.
@@ -1024,7 +1001,7 @@
    *
    * If the surface doesn't have color key enabled this function returns false.
    *
-   * @param key a pointer filled in with the transparent pixel.
+   * @returns the transparent pixel or nullopt if none.
    * @throws Error on failure.
    *
    * @threadsafety It is safe to call this function from any thread.
@@ -1102,7 +1079,6 @@
   /**
    * Get the additional alpha value used in blit operations.
    *
-   * @param alpha a pointer filled in with the current alpha value.
    * @throws Error on failure.
    *
    * @threadsafety It is safe to call this function from any thread.
@@ -1114,8 +1090,29 @@
    */
   Uint8 GetAlphaMod() const;
 
+  /**
+   * Set an additional color and alpha value multiplied into blit
+   * operations.
+   *
+   * When this surface is blitted, during the blit operation each source color
+   * channel is modulated by the appropriate color value according to the
+   * following formula:
+   *
+   * `srcC = srcC * (color / 255)`
+   * `srcA = srcA * (alpha / 255)`
+   *
+   * @param color the color to be multiplied in blit operations
+   * @throws Error on failure.
+   */
   void SetMod(Color color);
 
+  /**
+   * Get the additional color and alpha value multiplied into blit
+   * operations.
+   *
+   * @returns a Color containing RGBA value on success or std::nullopt on
+   * failure; call GetError() for more information.
+   */
   Color GetMod() const;
 
   /**
@@ -1140,7 +1137,7 @@
   /**
    * Get the blend mode used for blit operations.
    *
-   * @param blendMode a pointer filled in with the current BlendMode.
+   * @returns the current BlendMode.
    * @throws Error on failure.
    *
    * @threadsafety It is safe to call this function from any thread.
@@ -1170,10 +1167,16 @@
    *
    * @since This function is available since SDL 3.2.0.
    *
+   * @sa Surface.ResetClipRect()
    * @sa Surface.GetClipRect
    */
   bool SetClipRect(OptionalRef<const RectRaw> rect);
 
+  /**
+   * Disable the clipping rectangle for a surface.
+   *
+   * @sa SetClipRect()
+   */
   void ResetClipRect();
 
   /**
@@ -1182,8 +1185,8 @@
    * When `surface` is the destination of a blit, only the area within the clip
    * rectangle is drawn into.
    *
-   * @param rect an Rect structure filled in with the clipping rectangle for the
-   *             surface.
+   * @returns the Rect structure filled in with the clipping rectangle for the
+   *          surface on success.
    * @throws Error on failure.
    *
    * @threadsafety This function can be called on different threads with
@@ -1246,8 +1249,6 @@
    * If the original surface has alternate images, the new surface will have a
    * reference to them as well.
    *
-   * The returned surface should be freed with Surface.Destroy().
-   *
    * @returns a copy of the surface or nullptr on failure; call GetError() for
    *          more information.
    *
@@ -1264,10 +1265,7 @@
    * Creates a new surface identical to the existing surface, scaled to the
    * desired size.
    *
-   * The returned surface should be freed with Surface.Destroy().
-   *
-   * @param width the width of the new surface.
-   * @param height the height of the new surface.
+   * @param size the width and height of the new surface.
    * @param scaleMode the ScaleMode to be used.
    * @returns a copy of the surface or nullptr on failure; call GetError() for
    *          more information.
@@ -1365,10 +1363,7 @@
    * If the surface is YUV, the color is assumed to be in the sRGB colorspace,
    * otherwise the color is assumed to be in the colorspace of the surface.
    *
-   * @param r the red component of the pixel, normally in the range 0-1.
-   * @param g the green component of the pixel, normally in the range 0-1.
-   * @param b the blue component of the pixel, normally in the range 0-1.
-   * @param a the alpha component of the pixel, normally in the range 0-1.
+   * @param c the color components of the pixel, normally in the range 0-1.
    * @throws Error on failure.
    *
    * @threadsafety This function can be called on different threads with
@@ -1404,6 +1399,16 @@
    */
   void FillRect(OptionalRef<const RectRaw> rect, Uint32 color);
 
+  /**
+   * Perform a fast fill of a rectangle with a specific color.
+   *
+   * If there is a clip rectangle set on the destination (set via
+   * Surface.SetClipRect()), then this function will fill based on the
+   * intersection of the clip rectangle and `rect`.
+   *
+   * @param color the color to fill with.
+   * @throws Error on failure.
+   */
   void Fill(Uint32 color);
 
   /**
@@ -1419,7 +1424,6 @@
    * intersection of the clip rectangle and `rect`.
    *
    * @param rects an array of SDL_Rects representing the rectangles to fill.
-   * @param count the number of rectangles in the array.
    * @param color the color to fill with.
    * @throws Error on failure.
    *
@@ -1484,9 +1488,9 @@
    *       source color key.
    * ```
    *
+   * @param src the SurfaceRaw structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be copied,
    *                or nullptr to copy the entire surface.
-   * @param dst the Surface structure that is the blit target.
    * @param dstrect the Rect structure representing the x and y position in the
    *                destination surface, or nullptr for (0,0). The width and
    *                height are ignored, and are copied from `srcrect`. If you
@@ -1505,6 +1509,76 @@
             OptionalRef<const RectRaw> srcrect,
             OptionalRef<const RectRaw> dstrect);
 
+  /**
+   * Performs a fast blit from the source surface to the destination surface
+   * with clipping.
+   *
+   * If either `srcrect` or `dstrect` are nullptr, the entire surface (`src` or
+   * `dst`) is copied while ensuring clipping to `dst->clip_rect`.
+   *
+   * The blit function should not be called on a locked surface.
+   *
+   * The blit semantics for surfaces with and without blending and colorkey are
+   * defined as follows:
+   *
+   * ```
+   *    RGBA->RGB:
+   *      Source surface blend mode set to BLENDMODE_BLEND:
+   *       alpha-blend (using the source alpha-channel and per-surface alpha)
+   *       SDL_SRCCOLORKEY ignored.
+   *     Source surface blend mode set to BLENDMODE_NONE:
+   *       copy RGB.
+   *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+   *       RGB values of the source color key, ignoring alpha in the
+   *       comparison.
+   *
+   *   RGB->RGBA:
+   *     Source surface blend mode set to BLENDMODE_BLEND:
+   *       alpha-blend (using the source per-surface alpha)
+   *     Source surface blend mode set to BLENDMODE_NONE:
+   *       copy RGB, set destination alpha to source per-surface alpha value.
+   *     both:
+   *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+   *       source color key.
+   *
+   *   RGBA->RGBA:
+   *     Source surface blend mode set to BLENDMODE_BLEND:
+   *       alpha-blend (using the source alpha-channel and per-surface alpha)
+   *       SDL_SRCCOLORKEY ignored.
+   *     Source surface blend mode set to BLENDMODE_NONE:
+   *       copy all of RGBA to the destination.
+   *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+   *       RGB values of the source color key, ignoring alpha in the
+   *       comparison.
+   *
+   *   RGB->RGB:
+   *     Source surface blend mode set to BLENDMODE_BLEND:
+   *       alpha-blend (using the source per-surface alpha)
+   *     Source surface blend mode set to BLENDMODE_NONE:
+   *       copy RGB.
+   *     both:
+   *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+   *       source color key.
+   * ```
+   *
+   * @param src the SurfaceRaw structure to be copied from.
+   * @param srcrect the Rect structure representing the rectangle to be
+   *                copied, or nullptr to copy the entire surface.
+   * @param dstpos the Point structure representing the x and y position in
+   *                the destination surface, or nullptr for (0,0). The width and
+   *                height are ignored, and are copied from `srcrect`. If you
+   *                want a specific width and height, you should use
+   *                Surface.BlitScaled().
+   * @throws Error on failure.
+   *
+   * @threadsafety Only one thread should be using the `src` and `dst` surfaces
+   *               at any given time.
+   *
+   * @since This function is available since SDL 3.2.0.
+   *
+   * @sa Surface.Blit
+   * @sa Surface.BlitScaled
+   */
   void BlitAt(SurfaceParam src,
               OptionalRef<const RectRaw> srcrect,
               const PointRaw& dstpos);
@@ -1515,9 +1589,9 @@
    * This is a semi-private blit function and it performs low-level surface
    * blitting, assuming the input rectangles have already been clipped.
    *
+   * @param src the Surface structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be copied,
    *                may not be nullptr.
-   * @param dst the Surface structure that is the blit target.
    * @param dstrect the Rect structure representing the target rectangle in the
    *                destination surface, may not be nullptr.
    * @throws Error on failure.
@@ -1537,9 +1611,9 @@
    * Perform a scaled blit to a destination surface, which may be of a different
    * format.
    *
+   * @param src the Surface structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be copied,
    *                or nullptr to copy the entire surface.
-   * @param dst the Surface structure that is the blit target.
    * @param dstrect the Rect structure representing the target rectangle in the
    *                destination surface, or nullptr to fill the entire
    *                destination surface.
@@ -1564,9 +1638,9 @@
    * This is a semi-private function and it performs low-level surface blitting,
    * assuming the input rectangles have already been clipped.
    *
+   * @param src the Surface structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be copied,
    *                may not be nullptr.
-   * @param dst the Surface structure that is the blit target.
    * @param dstrect the Rect structure representing the target rectangle in the
    *                destination surface, may not be nullptr.
    * @param scaleMode the ScaleMode to be used.
@@ -1589,9 +1663,9 @@
   /**
    * Perform a stretched pixel copy from one surface to another.
    *
+   * @param src the Surface structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be copied,
    *                or nullptr to copy the entire surface.
-   * @param dst the Surface structure that is the blit target.
    * @param dstrect the Rect structure representing the target rectangle in the
    *                destination surface, or nullptr to fill the entire
    *                destination surface.
@@ -1619,9 +1693,9 @@
    * The pixels in `srcrect` will be repeated as many times as needed to
    * completely fill `dstrect`.
    *
+   * @param src the SDL_Surface structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be copied,
    *                or nullptr to copy the entire surface.
-   * @param dst the Surface structure that is the blit target.
    * @param dstrect the Rect structure representing the target rectangle in the
    *                destination surface, or nullptr to fill the entire surface.
    * @throws Error on failure.
@@ -1644,13 +1718,13 @@
    * The pixels in `srcrect` will be scaled and repeated as many times as needed
    * to completely fill `dstrect`.
    *
+   * @param src the SDL_Surface structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be copied,
    *                or nullptr to copy the entire surface.
    * @param scale the scale used to transform srcrect into the destination
    *              rectangle, e.g. a 32x32 texture with a scale of 2 would fill
    *              64x64 tiles.
    * @param scaleMode scale algorithm to be used.
-   * @param dst the Surface structure that is the blit target.
    * @param dstrect the Rect structure representing the target rectangle in the
    *                destination surface, or nullptr to fill the entire surface.
    * @throws Error on failure.
@@ -1678,6 +1752,7 @@
    * into the corners of the destination rectangle. The sides and center are
    * then stretched into place to cover the remaining destination rectangle.
    *
+   * @param src the SDL_Surface structure to be copied from.
    * @param srcrect the Rect structure representing the rectangle to be used for
    *                the 9-grid, or nullptr to use the entire surface.
    * @param left_width the width, in pixels, of the left corners in `srcrect`.
@@ -1685,12 +1760,11 @@
    * @param top_height the height, in pixels, of the top corners in `srcrect`.
    * @param bottom_height the height, in pixels, of the bottom corners in
    *                      `srcrect`.
+   * @param dstrect the Rect structure representing the target rectangle in the
+   *                destination surface, or nullptr to fill the entire surface.
    * @param scale the scale used to transform the corner of `srcrect` into the
    *              corner of `dstrect`, or 0.0f for an unscaled blit.
    * @param scaleMode scale algorithm to be used.
-   * @param dst the Surface structure that is the blit target.
-   * @param dstrect the Rect structure representing the target rectangle in the
-   *                destination surface, or nullptr to fill the entire surface.
    * @throws Error on failure.
    *
    * @threadsafety Only one thread should be using the `src` and `dst` surfaces
@@ -1760,10 +1834,7 @@
    * format the return value can be assigned to a Uint16, and similarly a Uint8
    * for an 8-bpp format).
    *
-   * @param r the red component of the pixel in the range 0-255.
-   * @param g the green component of the pixel in the range 0-255.
-   * @param b the blue component of the pixel in the range 0-255.
-   * @param a the alpha component of the pixel in the range 0-255.
+   * @param c the color components of the pixel in the range 0-255.
    * @returns a pixel value.
    *
    * @threadsafety This function can be called on different threads with
@@ -1784,8 +1855,7 @@
    * Like GetRGBA, this uses the entire 0..255 range when converting color
    * components from pixel formats with less than 8 bits per RGB component.
    *
-   * @param x the horizontal coordinate, 0 <= x < width.
-   * @param y the vertical coordinate, 0 <= y < height.
+   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
    * @param r a pointer filled in with the red channel, 0-255, or nullptr to
    *          ignore this channel.
    * @param g a pointer filled in with the green channel, 0-255, or nullptr to
@@ -1813,19 +1883,8 @@
    * This function prioritizes correctness over speed: it is suitable for unit
    * tests, but is not intended for use in a game engine.
    *
-   * Like GetRGBA, this uses the entire 0..255 range when converting color
-   * components from pixel formats with less than 8 bits per RGB component.
-   *
-   * @param x the horizontal coordinate, 0 <= x < width.
-   * @param y the vertical coordinate, 0 <= y < height.
-   * @param r a pointer filled in with the red channel, 0-255, or nullptr to
-   *          ignore this channel.
-   * @param g a pointer filled in with the green channel, 0-255, or nullptr to
-   *          ignore this channel.
-   * @param b a pointer filled in with the blue channel, 0-255, or nullptr to
-   *          ignore this channel.
-   * @param a a pointer filled in with the alpha channel, 0-255, or nullptr to
-   *          ignore this channel.
+   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
+   * @returns color on success.
    * @throws Error on failure.
    *
    * @threadsafety This function can be called on different threads with
@@ -1841,8 +1900,7 @@
    * This function prioritizes correctness over speed: it is suitable for unit
    * tests, but is not intended for use in a game engine.
    *
-   * @param x the horizontal coordinate, 0 <= x < width.
-   * @param y the vertical coordinate, 0 <= y < height.
+   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
    * @param r a pointer filled in with the red channel, normally in the range
    *          0-1, or nullptr to ignore this channel.
    * @param g a pointer filled in with the green channel, normally in the range
@@ -1870,16 +1928,8 @@
    * This function prioritizes correctness over speed: it is suitable for unit
    * tests, but is not intended for use in a game engine.
    *
-   * @param x the horizontal coordinate, 0 <= x < width.
-   * @param y the vertical coordinate, 0 <= y < height.
-   * @param r a pointer filled in with the red channel, normally in the range
-   *          0-1, or nullptr to ignore this channel.
-   * @param g a pointer filled in with the green channel, normally in the range
-   *          0-1, or nullptr to ignore this channel.
-   * @param b a pointer filled in with the blue channel, normally in the range
-   *          0-1, or nullptr to ignore this channel.
-   * @param a a pointer filled in with the alpha channel, normally in the range
-   *          0-1, or nullptr to ignore this channel.
+   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
+   * @returns color on success.
    * @throws Error on failure.
    *
    * @threadsafety This function can be called on different threads with
@@ -1898,12 +1948,8 @@
    * Like MapColor, this uses the entire 0..255 range when converting color
    * components from pixel formats with less than 8 bits per RGB component.
    *
-   * @param x the horizontal coordinate, 0 <= x < width.
-   * @param y the vertical coordinate, 0 <= y < height.
-   * @param r the red channel value, 0-255.
-   * @param g the green channel value, 0-255.
-   * @param b the blue channel value, 0-255.
-   * @param a the alpha channel value, 0-255.
+   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
+   * @param c the color values, 0-255.
    * @throws Error on failure.
    *
    * @threadsafety This function can be called on different threads with
@@ -1919,12 +1965,8 @@
    * This function prioritizes correctness over speed: it is suitable for unit
    * tests, but is not intended for use in a game engine.
    *
-   * @param x the horizontal coordinate, 0 <= x < width.
-   * @param y the vertical coordinate, 0 <= y < height.
-   * @param r the red channel value, normally in the range 0-1.
-   * @param g the green channel value, normally in the range 0-1.
-   * @param b the blue channel value, normally in the range 0-1.
-   * @param a the alpha channel value, normally in the range 0-1.
+   * @param p the coordinates, 0 <= x < width and 0 <= y < height.
+   * @param c the color values, normally in the range 0-1.
    * @throws Error on failure.
    *
    * @threadsafety This function can be called on different threads with
@@ -1989,15 +2031,6 @@
  * 0, then you can read and write to the surface at any time, and the pixel
  * format of the surface will not change.
  *
- * @param surface the Surface structure to be locked.
- * @returns true on success or false on failure; call GetError() for more
- *          information.
- *
- * @threadsafety This function can be called on different threads with different
- *               surfaces. The locking referred to by this function is making
- *               the pixels available for direct access, not thread-safe
- *               locking.
- *
  * @since This function is available since SDL 3.2.0.
  *
  * @sa Surface.MustLock
@@ -2143,8 +2176,7 @@
  *
  * The pixels of the new surface are initialized to zero.
  *
- * @param width the width of the surface.
- * @param height the height of the surface.
+ * @param size the width and height of the surface.
  * @param format the PixelFormat for the new surface's pixel format.
  * @returns the new Surface structure that is created or nullptr on failure;
  *          call GetError() for more information.
@@ -2173,8 +2205,7 @@
  * You may pass nullptr for pixels and 0 for pitch to create a surface that you
  * will fill in with valid values later.
  *
- * @param width the width of the surface.
- * @param height the height of the surface.
+ * @param size the width and height of the surface.
  * @param format the PixelFormat for the new surface's pixel format.
  * @param pixels a pointer to existing pixel data.
  * @param pitch the number of bytes between each row, including padding.
@@ -2253,7 +2284,7 @@
  */
 inline PropertiesRef GetSurfaceProperties(SurfaceConstParam surface)
 {
-  return CheckError(SDL_GetSurfaceProperties(surface));
+  return {CheckError(SDL_GetSurfaceProperties(surface))};
 }
 
 inline PropertiesRef Surface::GetProperties() const
@@ -2274,10 +2305,6 @@
 
 constexpr auto HOTSPOT_X_NUMBER = SDL_PROP_SURFACE_HOTSPOT_X_NUMBER;
 
-#endif // SDL_VERSION_ATLEAST(3, 2, 6)
-
-#if SDL_VERSION_ATLEAST(3, 2, 6)
-
 constexpr auto HOTSPOT_Y_NUMBER = SDL_PROP_SURFACE_HOTSPOT_Y_NUMBER;
 
 #endif // SDL_VERSION_ATLEAST(3, 2, 6)
@@ -2374,7 +2401,7 @@
  */
 inline Palette CreateSurfacePalette(SurfaceParam surface)
 {
-  return CheckError(SDL_CreateSurfacePalette(surface));
+  return Palette::Borrow(CheckError(SDL_CreateSurfacePalette(surface)));
 }
 
 inline Palette Surface::CreatePalette()
@@ -2427,7 +2454,7 @@
  */
 inline Palette GetSurfacePalette(SurfaceConstParam surface)
 {
-  return SDL_GetSurfacePalette(surface);
+  return Palette::Borrow(SDL_GetSurfacePalette(surface));
 }
 
 inline Palette Surface::GetPalette() const
@@ -2505,11 +2532,8 @@
  * normally.
  *
  * @param surface the Surface structure to query.
- * @param count a pointer filled in with the number of surface pointers
- *              returned, may be nullptr.
  * @returns a nullptr terminated array of Surface pointers or nullptr on
- *          failure; call GetError() for more information. This should be freed
- *          with free() when it is no longer needed.
+ *          failure; call GetError() for more information.
  *
  * @threadsafety This function can be called on different threads with different
  *               surfaces.
@@ -2522,7 +2546,9 @@
  */
 inline OwnArray<SurfaceRaw> GetSurfaceImages(SurfaceConstParam surface)
 {
-  return SDL_GetSurfaceImages(surface);
+  int count = 0;
+  auto data = SDL_GetSurfaceImages(surface, &count);
+  return OwnArray<SurfaceRaw>(CheckError(data), count);
 }
 
 inline OwnArray<SurfaceRaw> Surface::GetImages() const
@@ -2565,7 +2591,7 @@
  * Once you are done accessing the surface, you should use Surface.Unlock() to
  * release it.
  *
- * Not all surfaces require locking. If `Surface.MustLock(surface)` evaluates to
+ * Not all surfaces require locking. If `Surface.MustLock()` evaluates to
  * 0, then you can read and write to the surface at any time, and the pixel
  * format of the surface will not change.
  *
@@ -2623,6 +2649,7 @@
   m_lock = {};
 }
 
+#ifndef SDL3PP_ENABLE_IMAGE
 #if SDL_VERSION_ATLEAST(3, 4, 0)
 
 /**
@@ -2646,13 +2673,9 @@
  */
 inline Surface LoadSurface(IOStreamParam src, bool closeio = false)
 {
-  return SDL_LoadSurface_IO(src, closeio);
+  return Surface{SDL_LoadSurface_IO(src, closeio)};
 }
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
 /**
  * Load a BMP or PNG image from a file.
  *
@@ -2670,9 +2693,12 @@
  * @sa Surface.Destroy
  * @sa LoadSurface
  */
-inline Surface LoadSurface(StringParam file) { return SDL_LoadSurface(file); }
-
+inline Surface LoadSurface(StringParam file)
+{
+  return Surface{SDL_LoadSurface(file)};
+}
 #endif // SDL_VERSION_ATLEAST(3, 4, 0)
+#endif // SDL3PP_ENABLE_IMAGE
 
 /**
  * Load a BMP image from a seekable SDL data stream.
@@ -2826,10 +2852,6 @@
   return Surface(SDL_LoadPNG_IO(src, closeio));
 }
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
 /**
  * Load a PNG image from a file.
  *
@@ -2854,28 +2876,16 @@
  */
 inline Surface LoadPNG(StringParam file) { return Surface(SDL_LoadPNG(file)); }
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
 inline Surface Surface::LoadPNG(IOStreamParam src, bool closeio)
 {
   return SDL::LoadPNG(src, closeio);
 }
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
 inline Surface Surface::LoadPNG(StringParam file)
 {
   return SDL::LoadPNG(std::move(file));
 }
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
 /**
  * Save a surface to a seekable SDL data stream in PNG format.
  *
@@ -2900,10 +2910,6 @@
   CheckError(SDL_SavePNG_IO(surface, dst, closeio));
 }
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
 /**
  * Save a surface to a file in PNG format.
  *
@@ -2924,19 +2930,11 @@
   CheckError(SDL_SavePNG(surface, file));
 }
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
 inline void Surface::SavePNG(IOStreamParam dst, bool closeio) const
 {
   SDL::SavePNG(m_resource, dst, closeio);
 }
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
 inline void Surface::SavePNG(StringParam file) const
 {
   SDL::SavePNG(m_resource, std::move(file));
@@ -3004,8 +3002,7 @@
  * It is a pixel of the format used by the surface, as generated by MapRGB().
  *
  * @param surface the Surface structure to update.
- * @param enabled true to enable color key, false to disable color key.
- * @param key the transparent pixel.
+ * @param key the transparent pixel or std::nullopt to disable it.
  * @throws Error on failure.
  *
  * @threadsafety This function can be called on different threads with different
@@ -3019,7 +3016,7 @@
  */
 inline void SetSurfaceColorKey(SurfaceParam surface, std::optional<Uint32> key)
 {
-  CheckError(SDL_SetSurfaceColorKey(surface, key));
+  CheckError(SDL_SetSurfaceColorKey(surface, key.has_value(), key.value_or(0)));
 }
 
 inline void Surface::SetColorKey(std::optional<Uint32> key)
@@ -3027,9 +3024,19 @@
   SDL::SetSurfaceColorKey(m_resource, key);
 }
 
+/**
+ * Unset the color key (transparent pixel) in a surface.
+ *
+ * The color key defines a pixel value that will be treated as transparent in
+ * a blit. For example, one can use this to specify that cyan pixels should be
+ * considered transparent, and therefore not rendered.
+ *
+ * @param surface the Surface structure to update.
+ * @throws Error on failure.
+ */
 inline void ClearSurfaceColorKey(SurfaceParam surface)
 {
-  static_assert(false, "Not implemented");
+  SetSurfaceColorKey(surface, std::nullopt);
 }
 
 inline void Surface::ClearColorKey() { SDL::ClearSurfaceColorKey(m_resource); }
@@ -3068,7 +3075,7 @@
  * If the surface doesn't have color key enabled this function returns false.
  *
  * @param surface the Surface structure to query.
- * @param key a pointer filled in with the transparent pixel.
+ * @returns the transparent pixel or nullopt if none.
  * @throws Error on failure.
  *
  * @threadsafety It is safe to call this function from any thread.
@@ -3080,7 +3087,8 @@
  */
 inline std::optional<Uint32> GetSurfaceColorKey(SurfaceConstParam surface)
 {
-  return CheckError(SDL_GetSurfaceColorKey(surface));
+  if (Uint32 key; SDL_GetSurfaceColorKey(surface, &key)) return key;
+  return std::nullopt;
 }
 
 inline std::optional<Uint32> Surface::GetColorKey() const
@@ -3185,7 +3193,7 @@
  * Get the additional alpha value used in blit operations.
  *
  * @param surface the Surface structure to query.
- * @param alpha a pointer filled in with the current alpha value.
+ * @returns the current alpha value.
  * @throws Error on failure.
  *
  * @threadsafety It is safe to call this function from any thread.
@@ -3197,7 +3205,9 @@
  */
 inline Uint8 GetSurfaceAlphaMod(SurfaceConstParam surface)
 {
-  return CheckError(SDL_GetSurfaceAlphaMod(surface));
+  Uint8 alpha;
+  CheckError(SDL_GetSurfaceAlphaMod(surface, &alpha));
+  return alpha;
 }
 
 inline Uint8 Surface::GetAlphaMod() const
@@ -3205,19 +3215,43 @@
   return SDL::GetSurfaceAlphaMod(m_resource);
 }
 
+/**
+ * Set an additional color and alpha value multiplied into blit
+ * operations.
+ *
+ * When this surface is blitted, during the blit operation each source color
+ * channel is modulated by the appropriate color value according to the
+ * following formula:
+ *
+ * `srcC = srcC * (color / 255)`
+ * `srcA = srcA * (alpha / 255)`
+ *
+ * @param surface the Surface structure to query.
+ * @param color the color to be multiplied in blit operations
+ * @throws Error on failure.
+ */
 inline void SetSurfaceMod(SurfaceParam surface, Color color)
 {
-  static_assert(false, "Not implemented");
+  SetSurfaceColorMod(surface, color.r, color.g, color.b);
+  SetSurfaceAlphaMod(surface, color.a);
 }
 
-inline void Surface::SetMod(Color color)
-{
-  SDL::SetSurfaceMod(m_resource, color);
-}
+inline void Surface::SetMod(Color color) { SetSurfaceMod(m_resource, color); }
 
+/**
+ * Get the additional color and alpha value multiplied into blit
+ * operations.
+ *
+ * @param surface the Surface structure to query.
+ * @returns a Color containing RGBA value on success or std::nullopt on
+ * failure; call GetError() for more information.
+ */
 inline Color GetSurfaceMod(SurfaceConstParam surface)
 {
-  static_assert(false, "Not implemented");
+  Color c;
+  GetSurfaceColorMod(surface, &c.r, &c.g, &c.b);
+  c.a = GetSurfaceAlphaMod(surface);
+  return c;
 }
 
 inline Color Surface::GetMod() const { return SDL::GetSurfaceMod(m_resource); }
@@ -3254,7 +3288,7 @@
  * Get the blend mode used for blit operations.
  *
  * @param surface the Surface structure to query.
- * @param blendMode a pointer filled in with the current BlendMode.
+ * @returns the current BlendMode.
  * @throws Error on failure.
  *
  * @threadsafety It is safe to call this function from any thread.
@@ -3265,7 +3299,9 @@
  */
 inline BlendMode GetSurfaceBlendMode(SurfaceConstParam surface)
 {
-  return CheckError(SDL_GetSurfaceBlendMode(surface));
+  BlendMode blendmode;
+  CheckError(SDL_GetSurfaceBlendMode(surface, &blendmode));
+  return blendmode;
 }
 
 inline BlendMode Surface::GetBlendMode() const
@@ -3306,9 +3342,14 @@
   return SDL::SetSurfaceClipRect(m_resource, rect);
 }
 
+/**
+ * Disable the clipping rectangle for a surface.
+ *
+ * @sa SetSurfaceClipRect()
+ */
 inline void ResetSurfaceClipRect(SurfaceParam surface)
 {
-  static_assert(false, "Not implemented");
+  SetSurfaceClipRect(surface, std::nullopt);
 }
 
 inline void Surface::ResetClipRect() { SDL::ResetSurfaceClipRect(m_resource); }
@@ -3320,8 +3361,8 @@
  * rectangle is drawn into.
  *
  * @param surface the Surface structure representing the surface to be clipped.
- * @param rect an Rect structure filled in with the clipping rectangle for the
- *             surface.
+ * @returns the Rect structure filled in with the clipping rectangle for the
+ *          surface.
  * @throws Error on failure.
  *
  * @threadsafety This function can be called on different threads with different
@@ -3333,7 +3374,9 @@
  */
 inline Rect GetSurfaceClipRect(SurfaceConstParam surface)
 {
-  return CheckError(SDL_GetSurfaceClipRect(surface));
+  Rect r;
+  CheckError(SDL_GetSurfaceClipRect(surface, &r));
+  return r;
 }
 
 inline Rect Surface::GetClipRect() const
@@ -3391,13 +3434,9 @@
  */
 inline Surface RotateSurface(SurfaceParam surface, float angle)
 {
-  return SDL_RotateSurface(surface, angle);
+  return Surface{SDL_RotateSurface(surface, angle)};
 }
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
 inline Surface Surface::Rotate(float angle)
 {
   return SDL::RotateSurface(m_resource, angle);
@@ -3426,7 +3465,7 @@
  */
 inline Surface DuplicateSurface(SurfaceConstParam surface)
 {
-  return SDL_DuplicateSurface(surface);
+  return Surface(SDL_DuplicateSurface(surface));
 }
 
 inline Surface Surface::Duplicate() const
@@ -3441,8 +3480,7 @@
  * The returned surface should be freed with Surface.Destroy().
  *
  * @param surface the surface to duplicate and scale.
- * @param width the width of the new surface.
- * @param height the height of the new surface.
+ * @param size the width and height of the surface.
  * @param scaleMode the ScaleMode to be used.
  * @returns a copy of the surface or nullptr on failure; call GetError() for
  *          more information.
@@ -3458,7 +3496,7 @@
                             const PointRaw& size,
                             ScaleMode scaleMode)
 {
-  return SDL_ScaleSurface(surface, size, scaleMode);
+  return Surface(SDL_ScaleSurface(surface, size.x, size.y, scaleMode));
 }
 
 inline Surface Surface::Scale(const PointRaw& size, ScaleMode scaleMode) const
@@ -3495,7 +3533,7 @@
  */
 inline Surface ConvertSurface(SurfaceConstParam surface, PixelFormat format)
 {
-  return SDL_ConvertSurface(surface, format);
+  return Surface(SDL_ConvertSurface(surface, format));
 }
 
 inline Surface Surface::Convert(PixelFormat format) const
@@ -3503,15 +3541,6 @@
   return SDL::ConvertSurface(m_resource, format);
 }
 
-inline Surface Surface::Convert(PixelFormat format,
-                                PaletteParam palette,
-                                Colorspace colorspace,
-                                PropertiesParam props) const
-{
-  return SDL::ConvertSurfaceAndColorspace(
-    m_resource, format, palette, colorspace, props);
-}
-
 /**
  * Copy an existing surface to a new surface of the specified format and
  * colorspace.
@@ -3546,15 +3575,23 @@
                                            Colorspace colorspace,
                                            PropertiesParam props)
 {
-  return SDL_ConvertSurfaceAndColorspace(
-    surface, format, palette, colorspace, props);
+  return Surface{SDL_ConvertSurfaceAndColorspace(
+    surface, format, palette, colorspace, props)};
+}
+
+inline Surface Surface::Convert(PixelFormat format,
+                                PaletteParam palette,
+                                Colorspace colorspace,
+                                PropertiesParam props) const
+{
+  return SDL::ConvertSurfaceAndColorspace(
+    m_resource, format, palette, colorspace, props);
 }
 
 /**
  * Copy a block of pixels of one format to another format.
  *
- * @param width the width of the block to copy, in pixels.
- * @param height the height of the block to copy, in pixels.
+ * @param size the width and height of the surface.
  * @param src_format an PixelFormat value of the `src` pixels format.
  * @param src a pointer to the source pixels.
  * @param src_pitch the pitch of the source pixels, in bytes.
@@ -3580,15 +3617,14 @@
                           int dst_pitch)
 {
   CheckError(SDL_ConvertPixels(
-    size, src_format, src, src_pitch, dst_format, dst, dst_pitch));
+    size.x, size.y, src_format, src, src_pitch, dst_format, dst, dst_pitch));
 }
 
 /**
  * Copy a block of pixels of one format and colorspace to another format and
  * colorspace.
  *
- * @param width the width of the block to copy, in pixels.
- * @param height the height of the block to copy, in pixels.
+ * @param size the width and height  of the block to copy, in pixels.
  * @param src_format an PixelFormat value of the `src` pixels format.
  * @param src_colorspace an Colorspace value describing the colorspace of the
  *                       `src` pixels.
@@ -3625,7 +3661,8 @@
                                        void* dst,
                                        int dst_pitch)
 {
-  CheckError(SDL_ConvertPixelsAndColorspace(size,
+  CheckError(SDL_ConvertPixelsAndColorspace(size.x,
+                                            size.y,
                                             src_format,
                                             src_colorspace,
                                             src_properties,
@@ -3643,8 +3680,7 @@
  *
  * This is safe to use with src == dst, but not for other overlapping areas.
  *
- * @param width the width of the block to convert, in pixels.
- * @param height the height of the block to convert, in pixels.
+ * @param size the width and height of the surface.
  * @param src_format an PixelFormat value of the `src` pixels format.
  * @param src a pointer to the source pixels.
  * @param src_pitch the pitch of the source pixels, in bytes.
@@ -3670,8 +3706,15 @@
                              int dst_pitch,
                              bool linear)
 {
-  CheckError(SDL_PremultiplyAlpha(
-    size, src_format, src, src_pitch, dst_format, dst, dst_pitch, linear));
+  CheckError(SDL_PremultiplyAlpha(size.x,
+                                  size.y,
+                                  src_format,
+                                  src,
+                                  src_pitch,
+                                  dst_format,
+                                  dst,
+                                  dst_pitch,
+                                  linear));
 }
 
 /**
@@ -3708,10 +3751,7 @@
  * otherwise the color is assumed to be in the colorspace of the surface.
  *
  * @param surface the Surface to clear.
- * @param r the red component of the pixel, normally in the range 0-1.
- * @param g the green component of the pixel, normally in the range 0-1.
- * @param b the blue component of the pixel, normally in the range 0-1.
- * @param a the alpha component of the pixel, normally in the range 0-1.
+ * @param c the color components of the pixel, normally in the range 0-1.
  * @throws Error on failure.
  *
  * @threadsafety This function can be called on different threads with different
@@ -3721,7 +3761,7 @@
  */
 inline void ClearSurface(SurfaceParam surface, const FColorRaw& c)
 {
-  CheckError(SDL_ClearSurface(surface, c));
+  CheckError(SDL_ClearSurface(surface, c.r, c.g, c.b, c.a));
 }
 
 inline void Surface::Clear(const FColorRaw& c)
@@ -3766,9 +3806,20 @@
   SDL::FillSurfaceRect(m_resource, rect, color);
 }
 
+/**
+ * Perform a fast fill of a rectangle with a specific color.
+ *
+ * If there is a clip rectangle set on the destination (set via
+ * Surface.SetClipRect()), then this function will fill based on the
+ * intersection of the clip rectangle and `rect`.
+ *
+ * @param dst the Surface structure that is the drawing target.
+ * @param color the color to fill with.
+ * @throws Error on failure.
+ */
 inline void FillSurface(SurfaceParam dst, Uint32 color)
 {
-  static_assert(false, "Not implemented");
+  FillSurfaceRect(dst, std::nullopt, color);
 }
 
 inline void Surface::Fill(Uint32 color) { SDL::FillSurface(m_resource, color); }
@@ -3787,7 +3838,6 @@
  *
  * @param dst the Surface structure that is the drawing target.
  * @param rects an array of SDL_Rects representing the rectangles to fill.
- * @param count the number of rectangles in the array.
  * @param color the color to fill with.
  * @throws Error on failure.
  *
@@ -3802,7 +3852,7 @@
                              SpanRef<const RectRaw> rects,
                              Uint32 color)
 {
-  CheckError(SDL_FillSurfaceRects(dst, rects, color));
+  CheckError(SDL_FillSurfaceRects(dst, rects.data(), rects.size(), color));
 }
 
 inline void Surface::FillRects(SpanRef<const RectRaw> rects, Uint32 color)
@@ -3892,22 +3942,89 @@
                           OptionalRef<const RectRaw> srcrect,
                           OptionalRef<const RectRaw> dstrect)
 {
-  SDL::BlitSurface(m_resource, src, srcrect, dstrect);
+  SDL::BlitSurface(src, srcrect, m_resource, dstrect);
 }
 
 inline void Surface::BlitAt(SurfaceParam src,
                             OptionalRef<const RectRaw> srcrect,
                             const PointRaw& dstpos)
 {
-  static_assert(false, "Not implemented");
+  Blit(src, srcrect, Rect{dstpos, {}});
 }
 
+/**
+ * Performs a fast blit from the source surface to the destination surface
+ * with clipping.
+ *
+ * If either `srcrect` or `dstrect` are nullptr, the entire surface (`src` or
+ * `dst`) is copied while ensuring clipping to `dst->clip_rect`.
+ *
+ * The blit function should not be called on a locked surface.
+ *
+ * The blit semantics for surfaces with and without blending and colorkey are
+ * defined as follows:
+ *
+ * ```
+ *    RGBA->RGB:
+ *      Source surface blend mode set to BLENDMODE_BLEND:
+ *       alpha-blend (using the source alpha-channel and per-surface alpha)
+ *       SDL_SRCCOLORKEY ignored.
+ *     Source surface blend mode set to BLENDMODE_NONE:
+ *       copy RGB.
+ *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+ *       RGB values of the source color key, ignoring alpha in the
+ *       comparison.
+ *
+ *   RGB->RGBA:
+ *     Source surface blend mode set to BLENDMODE_BLEND:
+ *       alpha-blend (using the source per-surface alpha)
+ *     Source surface blend mode set to BLENDMODE_NONE:
+ *       copy RGB, set destination alpha to source per-surface alpha value.
+ *     both:
+ *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+ *       source color key.
+ *
+ *   RGBA->RGBA:
+ *     Source surface blend mode set to BLENDMODE_BLEND:
+ *       alpha-blend (using the source alpha-channel and per-surface alpha)
+ *       SDL_SRCCOLORKEY ignored.
+ *     Source surface blend mode set to BLENDMODE_NONE:
+ *       copy all of RGBA to the destination.
+ *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+ *       RGB values of the source color key, ignoring alpha in the
+ *       comparison.
+ *
+ *   RGB->RGB:
+ *     Source surface blend mode set to BLENDMODE_BLEND:
+ *       alpha-blend (using the source per-surface alpha)
+ *     Source surface blend mode set to BLENDMODE_NONE:
+ *       copy RGB.
+ *     both:
+ *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
+ *       source color key.
+ * ```
+ *
+ * @param src the Surface structure to be copied from.
+ * @param srcrect the Rect structure representing the rectangle to be
+ *                copied, or nullptr to copy the entire surface.
+ * @param dst the Surface structure that is the blit target.
+ * @param dstpos the Point structure representing the x and y position in
+ *                the destination surface.
+ * @throws Error on failure.
+ *
+ * @threadsafety Only one thread should be using the `src` and `dst` surfaces
+ *               at any given time.
+ *
+ * @since This function is available since SDL 3.2.0.
+ *
+ * @sa Surface.BlitSurface
+ */
 inline void BlitSurfaceAt(SurfaceParam src,
                           OptionalRef<const RectRaw> srcrect,
                           SurfaceParam dst,
                           const PointRaw& dstpos)
 {
-  static_assert(false, "Not implemented");
+  BlitSurface(src, srcrect, dst, SDL_Rect{dstpos.x, dstpos.y});
 }
 
 /**
@@ -3936,14 +4053,14 @@
                                  SurfaceParam dst,
                                  const RectRaw& dstrect)
 {
-  CheckError(SDL_BlitSurfaceUnchecked(src, srcrect, dst, dstrect));
+  CheckError(SDL_BlitSurfaceUnchecked(src, &srcrect, dst, &dstrect));
 }
 
 inline void Surface::BlitUnchecked(SurfaceParam src,
                                    const RectRaw& srcrect,
                                    const RectRaw& dstrect)
 {
-  SDL::BlitSurfaceUnchecked(m_resource, src, srcrect, dstrect);
+  SDL::BlitSurfaceUnchecked(src, srcrect, m_resource, dstrect);
 }
 
 /**
@@ -3981,7 +4098,7 @@
                                 OptionalRef<const RectRaw> dstrect,
                                 ScaleMode scaleMode)
 {
-  SDL::BlitSurfaceScaled(m_resource, src, srcrect, dstrect, scaleMode);
+  SDL::BlitSurfaceScaled(src, srcrect, m_resource, dstrect, scaleMode);
 }
 
 /**
@@ -4013,7 +4130,7 @@
                                        ScaleMode scaleMode)
 {
   CheckError(
-    SDL_BlitSurfaceUncheckedScaled(src, srcrect, dst, dstrect, scaleMode));
+    SDL_BlitSurfaceUncheckedScaled(src, &srcrect, dst, &dstrect, scaleMode));
 }
 
 inline void Surface::BlitUncheckedScaled(SurfaceParam src,
@@ -4021,7 +4138,7 @@
                                          const RectRaw& dstrect,
                                          ScaleMode scaleMode)
 {
-  SDL::BlitSurfaceUncheckedScaled(m_resource, src, srcrect, dstrect, scaleMode);
+  SDL::BlitSurfaceUncheckedScaled(src, srcrect, m_resource, dstrect, scaleMode);
 }
 
 #if SDL_VERSION_ATLEAST(3, 4, 0)
@@ -4055,16 +4172,12 @@
   CheckError(SDL_StretchSurface(src, srcrect, dst, dstrect, scaleMode));
 }
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
 inline void Surface::Stretch(SurfaceParam src,
                              OptionalRef<RectRaw> srcrect,
                              OptionalRef<RectRaw> dstrect,
                              ScaleMode scaleMode)
 {
-  SDL::StretchSurface(m_resource, src, srcrect, dstrect, scaleMode);
+  SDL::StretchSurface(src, srcrect, m_resource, dstrect, scaleMode);
 }
 
 #endif // SDL_VERSION_ATLEAST(3, 4, 0)
@@ -4103,7 +4216,7 @@
                                OptionalRef<const RectRaw> srcrect,
                                OptionalRef<const RectRaw> dstrect)
 {
-  SDL::BlitSurfaceTiled(m_resource, src, srcrect, dstrect);
+  SDL::BlitSurfaceTiled(src, srcrect, m_resource, dstrect);
 }
 
 /**
@@ -4150,7 +4263,7 @@
                                         OptionalRef<const RectRaw> dstrect)
 {
   SDL::BlitSurfaceTiledWithScale(
-    m_resource, src, srcrect, scale, scaleMode, dstrect);
+    src, srcrect, scale, scaleMode, m_resource, dstrect);
 }
 
 /**
@@ -4171,12 +4284,12 @@
  * @param top_height the height, in pixels, of the top corners in `srcrect`.
  * @param bottom_height the height, in pixels, of the bottom corners in
  *                      `srcrect`.
- * @param scale the scale used to transform the corner of `srcrect` into the
- *              corner of `dstrect`, or 0.0f for an unscaled blit.
- * @param scaleMode scale algorithm to be used.
  * @param dst the Surface structure that is the blit target.
  * @param dstrect the Rect structure representing the target rectangle in the
  *                destination surface, or nullptr to fill the entire surface.
+ * @param scale the scale used to transform the corner of `srcrect` into the
+ *              corner of `dstrect`, or 0.0f for an unscaled blit.
+ * @param scaleMode scale algorithm to be used.
  * @throws Error on failure.
  *
  * @threadsafety Only one thread should be using the `src` and `dst` surfaces at
@@ -4203,10 +4316,10 @@
                                   right_width,
                                   top_height,
                                   bottom_height,
-                                  dst,
-                                  dstrect,
                                   scale,
-                                  scaleMode));
+                                  scaleMode,
+                                  dst,
+                                  dstrect));
 }
 
 inline void Surface::Blit9Grid(SurfaceParam src,
@@ -4219,13 +4332,13 @@
                                float scale,
                                ScaleMode scaleMode)
 {
-  SDL::BlitSurface9Grid(m_resource,
-                        src,
+  SDL::BlitSurface9Grid(src,
                         srcrect,
                         left_width,
                         right_width,
                         top_height,
                         bottom_height,
+                        m_resource,
                         dstrect,
                         scale,
                         scaleMode);
@@ -4294,10 +4407,7 @@
  * for an 8-bpp format).
  *
  * @param surface the surface to use for the pixel format and palette.
- * @param r the red component of the pixel in the range 0-255.
- * @param g the green component of the pixel in the range 0-255.
- * @param b the blue component of the pixel in the range 0-255.
- * @param a the alpha component of the pixel in the range 0-255.
+ * @param c the color components of the pixel in the range 0-255.
  * @returns a pixel value.
  *
  * @threadsafety This function can be called on different threads with different
@@ -4309,7 +4419,7 @@
  */
 inline Uint32 MapSurfaceRGBA(SurfaceConstParam surface, ColorRaw c)
 {
-  return SDL_MapSurfaceRGBA(surface, c);
+  return SDL_MapSurfaceRGBA(surface, c.r, c.g, c.b, c.a);
 }
 
 inline Uint32 Surface::MapRGBA(ColorRaw c) const
@@ -4327,8 +4437,7 @@
  * components from pixel formats with less than 8 bits per RGB component.
  *
  * @param surface the surface to read.
- * @param x the horizontal coordinate, 0 <= x < width.
- * @param y the vertical coordinate, 0 <= y < height.
+ * @param p the coordinates, 0 <= x < width and 0 <= y < height.
  * @param r a pointer filled in with the red channel, 0-255, or nullptr to
  *          ignore this channel.
  * @param g a pointer filled in with the green channel, 0-255, or nullptr to
@@ -4351,7 +4460,7 @@
                              Uint8* b,
                              Uint8* a)
 {
-  CheckError(SDL_ReadSurfacePixel(surface, p, r, g, b, a));
+  CheckError(SDL_ReadSurfacePixel(surface, p.x, p.y, r, g, b, a));
 }
 
 /**
@@ -4364,16 +4473,8 @@
  * components from pixel formats with less than 8 bits per RGB component.
  *
  * @param surface the surface to read.
- * @param x the horizontal coordinate, 0 <= x < width.
- * @param y the vertical coordinate, 0 <= y < height.
- * @param r a pointer filled in with the red channel, 0-255, or nullptr to
- *          ignore this channel.
- * @param g a pointer filled in with the green channel, 0-255, or nullptr to
- *          ignore this channel.
- * @param b a pointer filled in with the blue channel, 0-255, or nullptr to
- *          ignore this channel.
- * @param a a pointer filled in with the alpha channel, 0-255, or nullptr to
- *          ignore this channel.
+ * @param p the coordinates, 0 <= x < width and 0 <= y < height.
+ * @returns color on success.
  * @throws Error on failure.
  *
  * @threadsafety This function can be called on different threads with different
@@ -4383,7 +4484,9 @@
  */
 inline Color ReadSurfacePixel(SurfaceConstParam surface, const PointRaw& p)
 {
-  static_assert(false, "Not implemented");
+  Color c;
+  ReadSurfacePixel(surface, p, &c.r, &c.g, &c.b, &c.a);
+  return c;
 }
 
 inline void Surface::ReadPixel(const PointRaw& p,
@@ -4407,8 +4510,7 @@
  * tests, but is not intended for use in a game engine.
  *
  * @param surface the surface to read.
- * @param x the horizontal coordinate, 0 <= x < width.
- * @param y the vertical coordinate, 0 <= y < height.
+ * @param p the coordinates, 0 <= x < width and 0 <= y < height.
  * @param r a pointer filled in with the red channel, normally in the range 0-1,
  *          or nullptr to ignore this channel.
  * @param g a pointer filled in with the green channel, normally in the range
@@ -4431,7 +4533,7 @@
                                   float* b,
                                   float* a)
 {
-  CheckError(SDL_ReadSurfacePixelFloat(surface, p, r, g, b, a));
+  CheckError(SDL_ReadSurfacePixelFloat(surface, p.x, p.y, r, g, b, a));
 }
 
 /**
@@ -4441,16 +4543,8 @@
  * tests, but is not intended for use in a game engine.
  *
  * @param surface the surface to read.
- * @param x the horizontal coordinate, 0 <= x < width.
- * @param y the vertical coordinate, 0 <= y < height.
- * @param r a pointer filled in with the red channel, normally in the range 0-1,
- *          or nullptr to ignore this channel.
- * @param g a pointer filled in with the green channel, normally in the range
- *          0-1, or nullptr to ignore this channel.
- * @param b a pointer filled in with the blue channel, normally in the range
- *          0-1, or nullptr to ignore this channel.
- * @param a a pointer filled in with the alpha channel, normally in the range
- *          0-1, or nullptr to ignore this channel.
+ * @param p the coordinates, 0 <= x < width and 0 <= y < height.
+ * @returns color on success.
  * @throws Error on failure.
  *
  * @threadsafety This function can be called on different threads with different
@@ -4461,7 +4555,9 @@
 inline FColor ReadSurfacePixelFloat(SurfaceConstParam surface,
                                     const PointRaw& p)
 {
-  static_assert(false, "Not implemented");
+  FColor c;
+  ReadSurfacePixelFloat(surface, p, &c.r, &c.g, &c.b, &c.a);
+  return c;
 }
 
 inline void Surface::ReadPixelFloat(const PointRaw& p,
@@ -4488,12 +4584,8 @@
  * components from pixel formats with less than 8 bits per RGB component.
  *
  * @param surface the surface to write.
- * @param x the horizontal coordinate, 0 <= x < width.
- * @param y the vertical coordinate, 0 <= y < height.
- * @param r the red channel value, 0-255.
- * @param g the green channel value, 0-255.
- * @param b the blue channel value, 0-255.
- * @param a the alpha channel value, 0-255.
+ * @param p the coordinates, 0 <= x < width, 0 <= y < height.
+ * @param c the color channels value, 0-255.
  * @throws Error on failure.
  *
  * @threadsafety This function can be called on different threads with different
@@ -4505,7 +4597,7 @@
                               const PointRaw& p,
                               ColorRaw c)
 {
-  CheckError(SDL_WriteSurfacePixel(surface, p, c));
+  CheckError(SDL_WriteSurfacePixel(surface, p.x, p.y, c.r, c.g, c.b, c.a));
 }
 
 inline void Surface::WritePixel(const PointRaw& p, ColorRaw c)
@@ -4520,12 +4612,8 @@
  * tests, but is not intended for use in a game engine.
  *
  * @param surface the surface to write.
- * @param x the horizontal coordinate, 0 <= x < width.
- * @param y the vertical coordinate, 0 <= y < height.
- * @param r the red channel value, normally in the range 0-1.
- * @param g the green channel value, normally in the range 0-1.
- * @param b the blue channel value, normally in the range 0-1.
- * @param a the alpha channel value, normally in the range 0-1.
+ * @param p the coordinates, 0 <= x < width, 0 <= y < height.
+ * @param c the color channels values, normally in the range 0-1.
  * @throws Error on failure.
  *
  * @threadsafety This function can be called on different threads with different
@@ -4537,7 +4625,7 @@
                                    const PointRaw& p,
                                    const FColorRaw& c)
 {
-  CheckError(SDL_WriteSurfacePixelFloat(surface, p, c));
+  CheckError(SDL_WriteSurfacePixelFloat(surface, p.x, p.y, c.r, c.g, c.b, c.a));
 }
 
 inline void Surface::WritePixelFloat(const PointRaw& p, const FColorRaw& c)
@@ -4546,10 +4634,7 @@
 }
 
 /// Get the width in pixels.
-constexpr int GetSurfaceWidth(SurfaceConstParam surface)
-{
-  static_assert(false, "Not implemented");
-}
+constexpr int GetSurfaceWidth(SurfaceConstParam surface) { return surface->w; }
 
 /// Get the width in pixels.
 constexpr int GetSurfaceWidth(const SurfaceLock& lock)
@@ -4563,10 +4648,7 @@
 }
 
 /// Get the height in pixels.
-constexpr int GetSurfaceHeight(SurfaceConstParam surface)
-{
-  static_assert(false, "Not implemented");
-}
+constexpr int GetSurfaceHeight(SurfaceConstParam surface) { return surface->h; }
 
 /// Get the height in pixels.
 constexpr int GetSurfaceHeight(const SurfaceLock& lock)
@@ -4582,7 +4664,7 @@
 /// Get the size in pixels.
 constexpr Point GetSurfaceSize(SurfaceConstParam surface)
 {
-  static_assert(false, "Not implemented");
+  return Point(surface->w, surface->h);
 }
 
 /// Get the size in pixels.
@@ -4599,7 +4681,7 @@
 /// Get pitch in bytes.
 constexpr int GetSurfacePitch(SurfaceConstParam surface)
 {
-  static_assert(false, "Not implemented");
+  return surface->pitch;
 }
 
 /// Get pitch in bytes.
@@ -4616,7 +4698,7 @@
 /// Get the pixel format.
 constexpr PixelFormat GetSurfaceFormat(SurfaceConstParam surface)
 {
-  static_assert(false, "Not implemented");
+  return surface->format;
 }
 
 /// Get the pixel format.
@@ -4633,7 +4715,7 @@
 /// Get the pixels.
 constexpr void* GetSurfacePixels(SurfaceConstParam surface)
 {
-  static_assert(false, "Not implemented");
+  return surface->pixels;
 }
 
 /// Get the pixels.
