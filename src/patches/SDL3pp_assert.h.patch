diff --git a/include/SDL3pp/SDL3pp_assert.h b/include/SDL3pp/SDL3pp_assert.h
index 3bedf8ff..a32c4c0f 100644
--- a/include/SDL3pp/SDL3pp_assert.h
+++ b/include/SDL3pp/SDL3pp_assert.h
@@ -1,10 +1,13 @@
 #ifndef SDL3PP_ASSERT_H_
 #define SDL3PP_ASSERT_H_
 
+#include <SDL3/SDL_assert.h>
+#include "SDL3pp_stdinc.h"
+
 namespace SDL {
 
 /**
- * @defgroup CategoryAssert Category Assert
+ * @defgroup CategoryAssert Assertions
  *
  * A helpful assertion macro!
  *
@@ -47,6 +50,8 @@ namespace SDL {
  * @{
  */
 
+#ifdef SDL3PP_DOC
+
 /**
  * The level of assertion aggressiveness.
  *
@@ -122,7 +127,7 @@ namespace SDL {
  * To use:
  *
  * ```c
- * do { SomethingOnce(); } while (SDL_nullptr_WHILE_LOOP_CONDITION (0));
+ * do { SomethingOnce(); } while (SDL_NULL_WHILE_LOOP_CONDITION (0));
  * ```
  *
  * @since This macro is available since SDL 3.2.0.
@@ -148,6 +153,8 @@ namespace SDL {
     (void)sizeof((condition));                                                 \
   } while (SDL_NULL_WHILE_LOOP_CONDITION)
 
+#endif // SDL3PP_DOC
+
 /**
  * Possible outcomes from a triggered assertion.
  *
@@ -209,9 +216,11 @@ inline AssertState ReportAssertion(AssertData* data,
                                    StringParam file,
                                    int line)
 {
-  return SDL_ReportAssertion(, data, func, file, line);
+  return SDL_ReportAssertion(data, func, file, line);
 }
 
+#ifdef SDL3PP_DOC
+
 /**
  * The macro used when an assertion triggers a breakpoint.
  *
@@ -243,7 +252,21 @@ inline AssertState ReportAssertion(AssertData* data,
  *
  * @since This macro is available since SDL 3.2.0.
  */
-#define SDL_enabled_assert(condition) [object Object]
+#define SDL_enabled_assert(condition)                                          \
+  do {                                                                         \
+    while (!(condition)) {                                                     \
+      static struct SDL_AssertData sdl_assert_data = {                         \
+        0, 0, #condition, 0, 0, 0, 0};                                         \
+      const SDL_AssertState sdl_assert_state = SDL_ReportAssertion(            \
+        &sdl_assert_data, SDL_FUNCTION, SDL_FILE, SDL_LINE);                   \
+      if (sdl_assert_state == SDL_ASSERTION_RETRY) {                           \
+        continue; /* go again. */                                              \
+      } else if (sdl_assert_state == SDL_ASSERTION_BREAK) {                    \
+        SDL_AssertBreakpoint();                                                \
+      }                                                                        \
+      break; /* not retrying. */                                               \
+    }                                                                          \
+  } while (SDL_NULL_WHILE_LOOP_CONDITION)
 
 /**
  * An assertion test that is normally performed only in debug builds.
@@ -363,8 +386,10 @@ inline AssertState ReportAssertion(AssertData* data,
  */
 #define SDL_assert_always(condition) SDL_enabled_assert(condition)
 
+#endif // SDL3PP_DOC
+
 /**
- * A callback that fires when an SDL assertion fails.
+ * A @ref callback that fires when an SDL assertion fails.
  *
  * @param data a pointer to the AssertData structure corresponding to the
  *             current assertion.
@@ -383,7 +408,6 @@ using AssertionHandler = SDL_AssertionHandler;
  *
  * @param data a pointer to the AssertData structure corresponding to the
  *             current assertion.
- * @param userdata what was passed as `userdata` to SetAssertionHandler().
  * @returns an AssertState value indicating how to handle the failure.
  *
  * @threadsafety This callback may be called from any thread that triggers an
@@ -420,7 +444,8 @@ using AssertionHandlerCB =
  */
 inline void SetAssertionHandler(AssertionHandler handler, void* userdata)
 {
-  SDL_SetAssertionHandler(, handler, userdata);
+  UniqueCallbackWrapper<AssertionHandlerCB>::erase();
+  return SDL_SetAssertionHandler(handler, userdata);
 }
 
 /**
@@ -434,11 +459,10 @@ inline void SetAssertionHandler(AssertionHandler handler, void* userdata)
  * This callback may fire from any thread, but it runs wrapped in a mutex, so
  * it will only fire from one thread at a time.
  *
- * This callback is NOT reset to SDL's internal handler upon Quit()!
+ * This callback is NOT reset to SDL's internal handler upon SDL_Quit()!
  *
- * @param handler the AssertionHandler function to call when an assertion
- *                fails or nullptr for the default handler.
- * @param userdata a pointer that is passed to `handler`.
+ * @param handler the SDL_AssertionHandler function to call when an assertion
+ *                fails.
  *
  * @threadsafety It is safe to call this function from any thread.
  *
@@ -448,9 +472,10 @@ inline void SetAssertionHandler(AssertionHandler handler, void* userdata)
  */
 inline void SetAssertionHandler(AssertionHandlerCB handler)
 {
-  static_assert(false, "Not implemented");
+  using Wrapper = UniqueCallbackWrapper<AssertionHandlerCB>;
+  SetAssertionHandler(&Wrapper::CallSuffixed,
+                      Wrapper::Wrap(std::move(handler)));
 }
-
 /**
  * Get the default assertion handler.
  *
@@ -459,8 +484,7 @@ inline void SetAssertionHandler(AssertionHandlerCB handler)
  * is used for assertions when SetAssertionHandler() hasn't been used to
  * provide a different function.
  *
- * @returns the default AssertionHandler that is called when an assert
- *          triggers.
+ * @returns the default AssertionHandler that is called when an assert triggers.
  *
  * @threadsafety It is safe to call this function from any thread.
  *
@@ -477,9 +501,9 @@ inline AssertionHandler GetDefaultAssertionHandler()
  * Get the current assertion handler.
  *
  * This returns the function pointer that is called when an assertion is
- * triggered. This is either the value last passed to
- * SetAssertionHandler(), or if no application-specified function is set,
- * is equivalent to calling GetDefaultAssertionHandler().
+ * triggered. This is either the value last passed to SetAssertionHandler(), or
+ * if no application-specified function is set, is equivalent to calling
+ * GetDefaultAssertionHandler().
  *
  * The parameter `puserdata` is a pointer to a void*, which will store the
  * "userdata" pointer that was passed to SetAssertionHandler(). This value
@@ -498,7 +522,7 @@ inline AssertionHandler GetDefaultAssertionHandler()
  */
 inline AssertionHandler GetAssertionHandler(void** puserdata)
 {
-  return SDL_GetAssertionHandler(, puserdata);
+  return SDL_GetAssertionHandler(puserdata);
 }
 
 /**
@@ -506,17 +530,15 @@ inline AssertionHandler GetAssertionHandler(void** puserdata)
  *
  * This returns the function pointer that is called when an assertion is
  * triggered. This is either the value last passed to
- * SetAssertionHandler(), or if no application-specified function is set,
- * is equivalent to calling GetDefaultAssertionHandler().
+ * SDL_SetAssertionHandler(), or if no application-specified function is set,
+ * is equivalent to calling SDL_GetDefaultAssertionHandler().
  *
  * The parameter `puserdata` is a pointer to a void*, which will store the
- * "userdata" pointer that was passed to SetAssertionHandler(). This value
+ * "userdata" pointer that was passed to SDL_SetAssertionHandler(). This value
  * will always be nullptr for the default handler. If you don't care about this
  * data, it is safe to pass a nullptr pointer to this function to ignore it.
  *
- * @param puserdata pointer which is filled with the "userdata" pointer that
- *                  was passed to SetAssertionHandler().
- * @returns the AssertionHandler that is called when an assert triggers.
+ * @returns the AssertionHandlerCB that is called when an assert triggers.
  *
  * @threadsafety It is safe to call this function from any thread.
  *
@@ -526,7 +548,11 @@ inline AssertionHandler GetAssertionHandler(void** puserdata)
  */
 inline AssertionHandlerCB GetAssertionHandler()
 {
-  static_assert(false, "Not implemented");
+  using Wrapper = UniqueCallbackWrapper<AssertionHandlerCB>;
+  void* userdata = nullptr;
+  auto cb = GetAssertionHandler(&userdata);
+  if (Wrapper::contains(userdata)) return Wrapper::Unwrap(userdata);
+  return [cb, userdata](const AssertData* data) { return cb(data, userdata); };
 }
 
 /**
@@ -537,7 +563,7 @@ inline AssertionHandlerCB GetAssertionHandler()
  *
  * The proper way to examine this data looks something like this:
  *
- * ```c
+ * ```cpp
  * const AssertData *item = GetAssertionReport();
  * while (item) {
  *    printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\@n",
