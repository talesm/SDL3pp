--- src/generated/SDL3pp_assert.h
+++ include/SDL3pp/SDL3pp_assert.h
@@ -8,7 +8,7 @@
 namespace SDL {
 
 /**
- * @defgroup CategoryAssert Category Assert
+ * @defgroup CategoryAssert Assertions
  *
  * A helpful assertion macro!
  *
@@ -50,6 +50,8 @@
  * @{
  */
 
+#ifdef SDL3PP_DOC
+
 /**
  * The level of assertion aggressiveness.
  *
@@ -124,7 +126,7 @@
  * To use:
  *
  * ```c
- * do { SomethingOnce(); } while (SDL_nullptr_WHILE_LOOP_CONDITION (0));
+ * do { SomethingOnce(); } while (SDL_NULL_WHILE_LOOP_CONDITION (0));
  * ```
  *
  * @since This macro is available since SDL 3.2.0.
@@ -150,6 +152,8 @@
     (void)sizeof((condition));                                                 \
   } while (SDL_NULL_WHILE_LOOP_CONDITION)
 
+#endif // SDL3PP_DOC
+
 /**
  * Possible outcomes from a triggered assertion.
  *
@@ -214,6 +218,8 @@
   return SDL_ReportAssertion(data, func, file, line);
 }
 
+#ifdef SDL3PP_DOC
+
 /**
  * The macro used when an assertion triggers a breakpoint.
  *
@@ -315,7 +321,7 @@
  * requires GUI interfaces to happen on the main thread but you're debugging an
  * assertion in a background thread, it might be desirable to set this to
  * "break" so that your debugger takes control as soon as assert is triggered,
- * instead of risking a bad UI interaction (deadlock, etc) in the application. *
+ * instead of risking a bad UI interaction (deadlock, etc) in the application.
  *
  * @param condition boolean value to test.
  *
@@ -377,8 +383,10 @@
  */
 #define SDL_assert_always(condition) SDL_enabled_assert(condition)
 
+#endif // SDL3PP_DOC
+
 /**
- * A callback that fires when an SDL assertion fails.
+ * A @ref callback that fires when an SDL assertion fails.
  *
  * @param data a pointer to the AssertData structure corresponding to the
  *             current assertion.
@@ -393,7 +401,7 @@
 using AssertionHandler = SDL_AssertionHandler;
 
 /**
- * A callback that fires when an SDL assertion fails.
+ * A @ref callback that fires when an SDL assertion fails.
  *
  * @param data a pointer to the AssertData structure corresponding to the
  *             current assertion.
@@ -434,7 +442,8 @@
  */
 inline void SetAssertionHandler(AssertionHandler handler, void* userdata)
 {
-  SDL_SetAssertionHandler(handler, userdata);
+  UniqueCallbackWrapper<AssertionHandlerCB>::erase();
+  return SDL_SetAssertionHandler(handler, userdata);
 }
 
 /**
@@ -450,9 +459,7 @@
  *
  * This callback is NOT reset to SDL's internal handler upon Quit()!
  *
- * @param handler the AssertionHandler function to call when an assertion fails
- *                or nullptr for the default handler.
- * @param userdata a pointer that is passed to `handler`.
+ * @param handler the AssertionHandler function to call when an assertion fails.
  *
  * @threadsafety It is safe to call this function from any thread.
  *
@@ -462,9 +469,10 @@
  */
 inline void SetAssertionHandler(AssertionHandlerCB handler)
 {
-  static_assert(false, "Not implemented");
+  using Wrapper = UniqueCallbackWrapper<AssertionHandlerCB>;
+  SetAssertionHandler(&Wrapper::CallSuffixed,
+                      Wrapper::Wrap(std::move(handler)));
 }
-
 /**
  * Get the default assertion handler.
  *
@@ -527,9 +535,7 @@
  * always be nullptr for the default handler. If you don't care about this data,
  * it is safe to pass a nullptr pointer to this function to ignore it.
  *
- * @param puserdata pointer which is filled with the "userdata" pointer that was
- *                  passed to SetAssertionHandler().
- * @returns the AssertionHandler that is called when an assert triggers.
+ * @returns the AssertionHandlerCB that is called when an assert triggers.
  *
  * @threadsafety It is safe to call this function from any thread.
  *
@@ -539,7 +545,11 @@
  */
 inline AssertionHandlerCB GetAssertionHandler()
 {
-  static_assert(false, "Not implemented");
+  using Wrapper = UniqueCallbackWrapper<AssertionHandlerCB>;
+  void* userdata = nullptr;
+  auto cb = GetAssertionHandler(&userdata);
+  if (Wrapper::contains(userdata)) return Wrapper::Unwrap(userdata);
+  return [cb, userdata](const AssertData* data) { return cb(data, userdata); };
 }
 
 /**
@@ -550,7 +560,7 @@
  *
  * The proper way to examine this data looks something like this:
  *
- * ```c
+ * ```cpp
  * const AssertData *item = GetAssertionReport();
  * while (item) {
  *    printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\@n",
@@ -576,7 +586,7 @@
  */
 inline const AssertData& GetAssertionReport()
 {
-  return SDL_GetAssertionReport();
+  return *SDL_GetAssertionReport();
 }
 
 /**
