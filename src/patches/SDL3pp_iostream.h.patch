11c11
<  * @defgroup CategoryIOStream Category IOStream
---
>  * @defgroup CategoryIOStream I/O Streams
254,257c254,256
<    * @param mem a pointer to a buffer to feed an IOStream stream.
<    * @param size the buffer size, in bytes.
<    * @returns a pointer to a new IOStream structure or nullptr on failure; call
<    *          GetError() for more information.
---
>    * @param mem a buffer to feed an IOStream stream.
>    * @returns a valid IOStream on success.
>    * @throws Error on failure.
273c272
<     return IOStream(SDL_IOFromMem(mem));
---
>     return IOStream{CheckError(SDL_IOFromMem(mem.data, mem.size_bytes))};
300,303c299,301
<    * @param mem a pointer to a read-only buffer to feed an IOStream stream.
<    * @param size the buffer size, in bytes.
<    * @returns a pointer to a new IOStream structure or nullptr on failure; call
<    *          GetError() for more information.
---
>    * @param mem a read-only buffer to feed an IOStreamRef stream.
>    * @returns a valid IOStream on success.
>    * @throws Error on failure.
317c315
<     return IOStream(SDL_IOFromConstMem(mem));
---
>     return IOStream{CheckError(SDL_IOFromConstMem(mem.data, mem.size_bytes))};
335,336c333,334
<    * @returns a pointer to a new IOStream structure or nullptr on failure; call
<    *          GetError() for more information.
---
>    * @returns a valid IOStream on success.
>    * @throws Error on failure.
348c346,349
<   static IOStream FromDynamicMem() { return IOStream(SDL_IOFromDynamicMem()); }
---
>   static IOStream FromDynamicMem()
>   {
>     return IOStream{CheckError(SDL_IOFromDynamicMem())};
>   }
365c366
<    * @returns a pointer to the allocated memory on success.
---
>    * @returns a valid stream on success.
378c379
<   static IOStream Open(const IOStreamInterface* iface, void* userdata)
---
>   static IOStream Open(const IOStreamInterface& iface, void* userdata)
380c381
<     return IOStream(CheckError(SDL_OpenIO(iface, userdata)));
---
>     return IOStream(CheckError(SDL_OpenIO(&iface, userdata)));
423,424c424
<    * @returns true on success or false on failure; call GetError() for more
<    *          information.
---
>    * @throws Error on failure.
450c450
<     return CheckError(SDL_GetIOProperties(m_resource));
---
>     return {CheckError(SDL_GetIOProperties(m_resource))};
482c482,487
<   Sint64 GetSize() const { return CheckError(SDL_GetIOSize(m_resource)); }
---
>   Sint64 GetSize() const
>   {
>     auto size = SDL_GetIOSize(get());
>     if (size < 0) throw Error{};
>     return size;
>   }
522d526
<    *                current offset.
533a538,559
>   /**
>    * Read from a data source.
>    *
>    * This function reads up `size` bytes from the data source to the area
>    * pointed at by `ptr`. This function may read less bytes than requested.
>    *
>    * This function will return zero when the data stream is completely read, and
>    * IOStreamRef.GetStatus() will return IO_STATUS_EOF. If zero is returned and
>    * the stream is not at EOF, IOStreamRef.GetStatus() will return a different
>    * error value and GetError() will offer a human-readable message.
>    *
>    * @param size the number of bytes to read from the data source.
>    * @returns the bytes, or empty string on end of file or other failure;
>    *          call GetError() for more information.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    *
>    * @sa IOStream.Write
>    * @sa IOStream.GetStatus
>    */
536c562,574
<     static_assert(false, "Not implemented");
---
>     Sint64 pos = Tell();
>     auto curSize = SDL_GetIOSize(get());
>     if ((curSize < 0 || pos < 0)) {
>       if (size == size_t(-1)) return {};
>     } else if (curSize - pos <= 0) {
>       return {};
>     } else if (curSize - pos < size) {
>       size = curSize - pos;
>     }
>     std::string result(size, 0);
>     auto actualSize = Read(result);
>     if (actualSize < size) result.resize(actualSize);
>     return result;
550,551c588
<    * @param ptr a pointer to a buffer to read data into.
<    * @param size the number of bytes to read from the data source.
---
>    * @param buf the buffer to read data into.
562c599,602
<   size_t Read(TargetBytes buf) { return SDL_ReadIO(m_resource, buf); }
---
>   size_t Read(TargetBytes buf)
>   {
>     return SDL_ReadIO(m_resource, buf.data, buf.size_bytes);
>   }
578,579c618
<    * @param ptr a pointer to a buffer containing data to write.
<    * @param size the number of bytes to write.
---
>    * @param buf the bytes to write to
593c632,635
<   size_t Write(SourceBytes buf) { return SDL_WriteIO(m_resource, buf); }
---
>   size_t Write(SourceBytes buf)
>   {
>     return SDL_WriteIO(m_resource, buf.data, buf.size_bytes);
>   }
600c642
<     static_assert(false, "Not implemented");
---
>     return Write(std::vformat(fmt, std::make_format_args(args...)));
608c650,652
<     static_assert(false, "Not implemented");
---
>     std::string result =
>       std::vformat(fmt, std::make_format_args(args...)) + "\n";
>     return Write(result);
613a658,659
>    * @warning this is not typesafe! Prefer using print() and println()
>    *
631c677,684
<     return SDL_IOprintf(m_resource, fmt, ...);
---
>     va_list ap;
>     size_t result;
> 
>     va_start(ap, fmt);
>     result = vprintf(fmt, ap);
>     va_end(ap);
> 
>     return result;
636a690,691
>    * @warning this is not typesafe! Prefer using print() and println()
>    *
681,688c736,737
<    * The data should be freed with free().
<    *
<    * @param datasize a pointer filled in with the number of bytes read, may be
<    *                 nullptr.
<    * @param closeio if true, calls IOStream.Close() on `src` before returning,
<    * even in the case of an error.
<    * @returns the data or nullptr on failure; call GetError() for more
<    *          information.
---
>    * @returns the data in bytes
>    * @throws Error on failure.
697c746,751
<   StringResult LoadFile() { return SDL_LoadFile_IO(m_resource); }
---
>   StringResult LoadFile()
>   {
>     size_t datasize = 0;
>     auto data = static_cast<char*>(SDL_LoadFile_IO(get(), &datasize, false));
>     return StringResult{CheckError(data), datasize};
>   }
698a753,769
>   /**
>    * Load all the data from an SDL data stream.
>    *
>    * The data is allocated with a zero byte at the end (null terminated) for
>    * convenience. This extra byte is not included in the value reported via
>    * `datasize`.
>    *
>    * @returns the data in bytes
>    * @throws Error on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    *
>    * @sa LoadFile
>    * @sa IOStream.SaveFile
>    */
702c773,775
<     static_assert(false, "Not implemented");
---
>     size_t datasize = 0;
>     auto data = static_cast<T*>(SDL_LoadFile_IO(get(), &datasize, false));
>     return OwnArray<T>{CheckError(data), datasize / sizeof(T)};
710,712d782
<    * @param datasize the number of bytes to be written.
<    * @param closeio if true, calls IOStream.Close() on `src` before returning,
<    * even in the case of an error.
724c794
<     CheckError(SDL_SaveFile_IO(m_resource, data));
---
>     CheckError(SDL_SaveFile_IO(m_resource, data.data, data.size_bytes, false));
735,736c805
<    * @param src the IOStream to read from.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
743c812,817
<   Uint8 ReadU8() { return CheckError(SDL_ReadU8(m_resource)); }
---
>   Uint8 ReadU8()
>   {
>     Uint8 value;
>     CheckError(SDL_ReadU8(get(), &value));
>     return value;
>   }
753,754c827
<    * @param src the IOStream to read from.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
761c834,839
<   Sint8 ReadS8() { return CheckError(SDL_ReadS8(m_resource)); }
---
>   Sint8 ReadS8()
>   {
>     Sint8 value;
>     CheckError(SDL_ReadS8(get(), &value));
>     return value;
>   }
775,776c853
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
783c860,865
<   Uint16 ReadU16LE() { return CheckError(SDL_ReadU16LE(m_resource)); }
---
>   Uint16 ReadU16LE()
>   {
>     Uint16 value;
>     CheckError(SDL_ReadU16LE(get(), &value));
>     return value;
>   }
797,798c879
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
805c886,891
<   Sint16 ReadS16LE() { return CheckError(SDL_ReadS16LE(m_resource)); }
---
>   Sint16 ReadS16LE()
>   {
>     Sint16 value;
>     CheckError(SDL_ReadS16LE(get(), &value));
>     return value;
>   }
819,820c905
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
827c912,917
<   Uint16 ReadU16BE() { return CheckError(SDL_ReadU16BE(m_resource)); }
---
>   Uint16 ReadU16BE()
>   {
>     Uint16 value;
>     CheckError(SDL_ReadU16BE(get(), &value));
>     return value;
>   }
841,842c931
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
849c938,943
<   Sint16 ReadS16BE() { return CheckError(SDL_ReadS16BE(m_resource)); }
---
>   Sint16 ReadS16BE()
>   {
>     Sint16 value;
>     CheckError(SDL_ReadS16BE(get(), &value));
>     return value;
>   }
863,864c957
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
871c964,969
<   Uint32 ReadU32LE() { return CheckError(SDL_ReadU32LE(m_resource)); }
---
>   Uint32 ReadU32LE()
>   {
>     Uint32 value;
>     CheckError(SDL_ReadU32LE(get(), &value));
>     return value;
>   }
885,886c983
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
893c990,995
<   Sint32 ReadS32LE() { return CheckError(SDL_ReadS32LE(m_resource)); }
---
>   Sint32 ReadS32LE()
>   {
>     Sint32 value;
>     CheckError(SDL_ReadS32LE(get(), &value));
>     return value;
>   }
907,908c1009
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
915c1016,1021
<   Uint32 ReadU32BE() { return CheckError(SDL_ReadU32BE(m_resource)); }
---
>   Uint32 ReadU32BE()
>   {
>     Uint32 value;
>     CheckError(SDL_ReadU32BE(get(), &value));
>     return value;
>   }
929,930c1035
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
937c1042,1047
<   Sint32 ReadS32BE() { return CheckError(SDL_ReadS32BE(m_resource)); }
---
>   Sint32 ReadS32BE()
>   {
>     Sint32 value;
>     CheckError(SDL_ReadS32BE(get(), &value));
>     return value;
>   }
951,952c1061
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
959c1068,1073
<   Uint64 ReadU64LE() { return CheckError(SDL_ReadU64LE(m_resource)); }
---
>   Uint64 ReadU64LE()
>   {
>     Uint64 value;
>     CheckError(SDL_ReadU64LE(get(), &value));
>     return value;
>   }
973,974c1087
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
981c1094,1099
<   Sint64 ReadS64LE() { return CheckError(SDL_ReadS64LE(m_resource)); }
---
>   Sint64 ReadS64LE()
>   {
>     Sint64 value;
>     CheckError(SDL_ReadS64LE(get(), &value));
>     return value;
>   }
995,996c1113
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
1003c1120,1125
<   Uint64 ReadU64BE() { return CheckError(SDL_ReadU64BE(m_resource)); }
---
>   Uint64 ReadU64BE()
>   {
>     Uint64 value;
>     CheckError(SDL_ReadU64BE(get(), &value));
>     return value;
>   }
1017,1018c1139
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
1025c1146,1151
<   Sint64 ReadS64BE() { return CheckError(SDL_ReadS64BE(m_resource)); }
---
>   Sint64 ReadS64BE()
>   {
>     Sint64 value;
>     CheckError(SDL_ReadS64BE(get(), &value));
>     return value;
>   }
1027c1153,1171
<   std::optional<Uint8> TryReadU8() { static_assert(false, "Not implemented"); }
---
>   /**
>    * Use this function to read a byte from an IOStreamRef.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
>   std::optional<Uint8> TryReadU8()
>   {
>     if (Uint8 value; SDL_ReadU8(get(), &value)) return value;
>     return {};
>   }
1029c1173,1191
<   std::optional<Sint8> TryReadS8() { static_assert(false, "Not implemented"); }
---
>   /**
>    * Use this function to read a byte from an IOStreamRef.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
>   std::optional<Sint8> TryReadS8()
>   {
>     if (Sint8 value; SDL_ReadS8(get(), &value)) return value;
>     return {};
>   }
1030a1193,1210
>   /**
>    * Use this function to read 16 bits of little-endian data from an
>    * IOStreamRef and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1033c1213,1214
<     static_assert(false, "Not implemented");
---
>     if (Uint16 value; SDL_ReadU16LE(get(), &value)) return value;
>     return {};
1035a1217,1234
>   /**
>    * Use this function to read 16 bits of little-endian data from an
>    * IOStreamRef and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1038c1237,1238
<     static_assert(false, "Not implemented");
---
>     if (Sint16 value; SDL_ReadS16LE(get(), &value)) return value;
>     return {};
1040a1241,1258
>   /**
>    * Use this function to read 16 bits of big-endian data from an IOStreamRef
>    * and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1043c1261,1262
<     static_assert(false, "Not implemented");
---
>     if (Uint16 value; SDL_ReadU16BE(get(), &value)) return value;
>     return {};
1045a1265,1282
>   /**
>    * Use this function to read 16 bits of big-endian data from an IOStreamRef
>    * and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1048c1285,1286
<     static_assert(false, "Not implemented");
---
>     if (Sint16 value; SDL_ReadS16BE(get(), &value)) return value;
>     return {};
1050a1289,1306
>   /**
>    * Use this function to read 32 bits of little-endian data from an
>    * IOStreamRef and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1053c1309,1310
<     static_assert(false, "Not implemented");
---
>     if (Uint32 value; SDL_ReadU32LE(get(), &value)) return value;
>     return {};
1055a1313,1330
>   /**
>    * Use this function to read 32 bits of little-endian data from an
>    * IOStreamRef and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1058c1333,1334
<     static_assert(false, "Not implemented");
---
>     if (Sint32 value; SDL_ReadS32LE(get(), &value)) return value;
>     return {};
1060a1337,1354
>   /**
>    * Use this function to read 32 bits of big-endian data from an IOStreamRef
>    * and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1063c1357,1358
<     static_assert(false, "Not implemented");
---
>     if (Uint32 value; SDL_ReadU32BE(get(), &value)) return value;
>     return {};
1065a1361,1378
>   /**
>    * Use this function to read 32 bits of big-endian data from an IOStreamRef
>    * and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1068c1381,1382
<     static_assert(false, "Not implemented");
---
>     if (Sint32 value; SDL_ReadS32BE(get(), &value)) return value;
>     return {};
1070a1385,1402
>   /**
>    * Use this function to read 64 bits of little-endian data from an
>    * IOStreamRef and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1073c1405,1406
<     static_assert(false, "Not implemented");
---
>     if (Uint64 value; SDL_ReadU64LE(get(), &value)) return value;
>     return {};
1075a1409,1426
>   /**
>    * Use this function to read 64 bits of little-endian data from an
>    * IOStreamRef and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1078c1429,1430
<     static_assert(false, "Not implemented");
---
>     if (Sint64 value; SDL_ReadS64LE(get(), &value)) return value;
>     return {};
1080a1433,1450
>   /**
>    * Use this function to read 64 bits of big-endian data from an IOStreamRef
>    * and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1083c1453,1454
<     static_assert(false, "Not implemented");
---
>     if (Uint64 value; SDL_ReadU64BE(get(), &value)) return value;
>     return {};
1085a1457,1474
>   /**
>    * Use this function to read 64 bits of big-endian data from an IOStreamRef
>    * and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1088c1477,1478
<     static_assert(false, "Not implemented");
---
>     if (Sint64 value; SDL_ReadS64BE(get(), &value)) return value;
>     return {};
1670c2060
<   return CheckError(SDL_GetIOProperties(context));
---
>   return {CheckError(SDL_GetIOProperties(context))};
1830a2221,2222
>  * @warning this is not typesafe! Prefer using print() and println()
>  *
1851c2243,2250
<   return SDL_IOprintf(context, fmt, ...);
---
>   va_list ap;
>   size_t result;
> 
>   va_start(ap, fmt);
>   result = SDL_IOvprintf(context, fmt, ap);
>   va_end(ap);
> 
>   return result;
1934,1935d2332
<  * The data should be freed with free().
<  *
1937,1939c2334,2335
<  * @param datasize if not nullptr, will store the number of bytes read.
<  * @returns the data or nullptr on failure; call GetError() for more
<  *          information.
---
>  * @returns the data.
>  * @throws Error on failure.
1948c2344,2349
< inline StringResult LoadFile(StringParam file) { return SDL_LoadFile(file); }
---
> inline StringResult LoadFile(StringParam file)
> {
>   size_t datasize = 0;
>   auto data = static_cast<char*>(SDL_LoadFile(file, &datasize));
>   return StringResult{CheckError(data), datasize};
> }
1949a2351,2368
> /**
>  * Load all the data from a file path.
>  *
>  * The data is allocated with a zero byte at the end (null terminated) for
>  * convenience. This extra byte is not included in the value reported via
>  * `datasize`.
>  *
>  * @param file the path to read all available data from.
>  * @returns the data.
>  * @throws Error on failure.
>  *
>  * @threadsafety This function is not thread safe.
>  *
>  * @since This function is available since SDL 3.2.0.
>  *
>  * @sa IOStream.LoadFile
>  * @sa SaveFile
>  */
1953c2372,2374
<   static_assert(false, "Not implemented");
---
>   size_t datasize = 0;
>   auto data = static_cast<T*>(SDL_LoadFile(file, &datasize));
>   return OwnArray<T>{CheckError(data), datasize / sizeof(T)};
1988d2408
<  * @param datasize the number of bytes to be written.
2000c2420
<   CheckError(SDL_SaveFile(file, data));
---
>   CheckError(SDL_SaveFile(file, data.data, data.size_bytes));
2019c2439,2444
< inline Uint8 ReadU8(IOStreamParam src) { return CheckError(SDL_ReadU8(src)); }
---
> inline Uint8 ReadU8(IOStreamParam src)
> {
>   Uint8 value;
>   CheckError(SDL_ReadU8(src, &value));
>   return value;
> }
2037c2462,2467
< inline Sint8 ReadS8(IOStreamParam src) { return CheckError(SDL_ReadS8(src)); }
---
> inline Sint8 ReadS8(IOStreamParam src)
> {
>   Sint8 value;
>   CheckError(SDL_ReadS8(src, &value));
>   return value;
> }
2061c2491,2493
<   return CheckError(SDL_ReadU16LE(src));
---
>   Uint16 value;
>   CheckError(SDL_ReadU16LE(src, &value));
>   return value;
2086c2518,2520
<   return CheckError(SDL_ReadS16LE(src));
---
>   Sint16 value;
>   CheckError(SDL_ReadS16LE(src, &value));
>   return value;
2111c2545,2547
<   return CheckError(SDL_ReadU16BE(src));
---
>   Uint16 value;
>   CheckError(SDL_ReadU16BE(src, &value));
>   return value;
2136c2572,2574
<   return CheckError(SDL_ReadS16BE(src));
---
>   Sint16 value;
>   CheckError(SDL_ReadS16BE(src, &value));
>   return value;
2161c2599,2601
<   return CheckError(SDL_ReadU32LE(src));
---
>   Uint32 value;
>   CheckError(SDL_ReadU32LE(src, &value));
>   return value;
2186c2626,2628
<   return CheckError(SDL_ReadS32LE(src));
---
>   Sint32 value;
>   CheckError(SDL_ReadS32LE(src, &value));
>   return value;
2211c2653,2655
<   return CheckError(SDL_ReadU32BE(src));
---
>   Uint32 value;
>   CheckError(SDL_ReadU32BE(src, &value));
>   return value;
2236c2680,2682
<   return CheckError(SDL_ReadS32BE(src));
---
>   Sint32 value;
>   CheckError(SDL_ReadS32BE(src, &value));
>   return value;
2261c2707,2709
<   return CheckError(SDL_ReadU64LE(src));
---
>   Uint64 value;
>   CheckError(SDL_ReadU64LE(src, &value));
>   return value;
2286c2734,2736
<   return CheckError(SDL_ReadS64LE(src));
---
>   Sint64 value;
>   CheckError(SDL_ReadS64LE(src, &value));
>   return value;
2311c2761,2763
<   return CheckError(SDL_ReadU64BE(src));
---
>   Uint64 value;
>   CheckError(SDL_ReadU64BE(src, &value));
>   return value;
2336c2788,2790
<   return CheckError(SDL_ReadS64BE(src));
---
>   Sint64 value;
>   CheckError(SDL_ReadS64BE(src, &value));
>   return value;
