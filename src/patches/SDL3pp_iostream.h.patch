11c11
<  * @defgroup CategoryIOStream Category IOStream
---
>  * @defgroup CategoryIOStream I/O Streams
262,265c262,264
<    * @param mem a pointer to a buffer to feed an IOStream stream.
<    * @param size the buffer size, in bytes.
<    * @returns a pointer to a new IOStream structure or nullptr on failure; call
<    *          GetError() for more information.
---
>    * @param mem a buffer to feed an IOStream stream.
>    * @returns a valid IOStream on success.
>    * @throws Error on failure.
305,308c304,306
<    * @param mem a pointer to a read-only buffer to feed an IOStream stream.
<    * @param size the buffer size, in bytes.
<    * @returns a pointer to a new IOStream structure or nullptr on failure; call
<    *          GetError() for more information.
---
>    * @param mem a read-only buffer to feed an IOStreamRef stream.
>    * @returns a valid IOStream on success.
>    * @throws Error on failure.
337,338c335,336
<    * @returns a pointer to a new IOStream structure or nullptr on failure; call
<    *          GetError() for more information.
---
>    * @returns a valid IOStream on success.
>    * @throws Error on failure.
367c365
<    * @returns a pointer to the allocated memory on success.
---
>    * @returns a valid stream on success.
427,428c425
<    * @returns true on success or false on failure; call GetError() for more
<    *          information.
---
>    * @throws Error on failure.
516d512
<    *                current offset.
527a524,545
>   /**
>    * Read from a data source.
>    *
>    * This function reads up `size` bytes from the data source to the area
>    * pointed at by `ptr`. This function may read less bytes than requested.
>    *
>    * This function will return zero when the data stream is completely read, and
>    * IOStreamRef.GetStatus() will return IO_STATUS_EOF. If zero is returned and
>    * the stream is not at EOF, IOStreamRef.GetStatus() will return a different
>    * error value and GetError() will offer a human-readable message.
>    *
>    * @param size the number of bytes to read from the data source.
>    * @returns the bytes, or empty string on end of file or other failure;
>    *          call GetError() for more information.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    *
>    * @sa IOStream.Write
>    * @sa IOStream.GetStatus
>    */
530c548,560
<     static_assert(false, "Not implemented");
---
>     Sint64 pos = Tell();
>     auto curSize = SDL_GetIOSize(get());
>     if ((curSize < 0 || pos < 0)) {
>       if (size == size_t(-1)) return {};
>     } else if (curSize - pos <= 0) {
>       return {};
>     } else if (curSize - pos < size) {
>       size = curSize - pos;
>     }
>     std::string result(size, 0);
>     auto actualSize = Read(result);
>     if (actualSize < size) result.resize(actualSize);
>     return result;
572,573c602
<    * @param ptr a pointer to a buffer containing data to write.
<    * @param size the number of bytes to write.
---
>    * @param buf the bytes to write to
589c618,624
<   ///@cat formatted-string
---
>   /**
>    * Prints formatted string.
>    *
>    * @param fmt a std::format like format string
>    * @param args... the arguments to be formatted
>    * @cat formatted-string
>    */
592c627
<     static_assert(false, "Not implemented");
---
>     return Write(std::vformat(fmt, std::make_format_args(args...)));
595c630,636
<   ///@cat formatted-string
---
>   /**
>    * Prints formatted string.
>    *
>    * @param fmt a std::format like format string
>    * @param args... the arguments to be formatted
>    * @cat formatted-string
>    */
598c639,641
<     static_assert(false, "Not implemented");
---
>     std::string result =
>       std::vformat(fmt, std::make_format_args(args...)) + "\n";
>     return Write(result);
603a647,648
>    * @warning this is not typesafe! Prefer using print() and println()
>    *
621c666,673
<     return SDL_IOprintf(m_resource, fmt, ...);
---
>     va_list ap;
>     size_t result;
> 
>     va_start(ap, fmt);
>     result = vprintf(fmt, ap);
>     va_end(ap);
> 
>     return result;
626a679,680
>    * @warning this is not typesafe! Prefer using print() and println()
>    *
668,675c722,723
<    * The data should be freed with free().
<    *
<    * @param datasize a pointer filled in with the number of bytes read, may be
<    *                 nullptr.
<    * @param closeio if true, calls IOStream.Close() on `src` before returning,
<    * even in the case of an error.
<    * @returns the data or nullptr on failure; call GetError() for more
<    *          information.
---
>    * @returns the data in bytes
>    * @throws Error on failure.
685a734,750
>   /**
>    * Load all the data from an SDL data stream.
>    *
>    * The data is allocated with a zero byte at the end (null terminated) for
>    * convenience. This extra byte is not included in the value reported via
>    * `datasize`.
>    *
>    * @returns the data in bytes
>    * @throws Error on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    *
>    * @sa LoadFile
>    * @sa IOStream.SaveFile
>    */
689c754,756
<     static_assert(false, "Not implemented");
---
>     size_t datasize = 0;
>     auto data = static_cast<T*>(SDL_LoadFile_IO(get(), &datasize, false));
>     return OwnArray<T>{CheckError(data), datasize / sizeof(T)};
697,699d763
<    * @param datasize the number of bytes to be written.
<    * @param closeio if true, calls IOStream.Close() on `src` before returning,
<    * even in the case of an error.
719,720c783
<    * @param src the IOStream to read from.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
737,738c800
<    * @param src the IOStream to read from.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
759,760c821
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
781,782c842
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
803,804c863
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
825,826c884
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
847,848c905
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
869,870c926
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
891,892c947
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
913,914c968
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
935,936c989
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
957,958c1010
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
979,980c1031
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
1001,1002c1052
<    * @param src the stream from which to read data.
<    * @param value a pointer filled in with the data read.
---
>    * @returns the data read on success.
1011c1061,1079
<   std::optional<Uint8> TryReadU8() { static_assert(false, "Not implemented"); }
---
>   /**
>    * Use this function to read a byte from an IOStreamRef.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
>   std::optional<Uint8> TryReadU8()
>   {
>     if (Uint8 value; SDL_ReadU8(get(), &value)) return value;
>     return {};
>   }
1013c1081,1099
<   std::optional<Sint8> TryReadS8() { static_assert(false, "Not implemented"); }
---
>   /**
>    * Use this function to read a byte from an IOStreamRef.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
>   std::optional<Sint8> TryReadS8()
>   {
>     if (Sint8 value; SDL_ReadS8(get(), &value)) return value;
>     return {};
>   }
1014a1101,1118
>   /**
>    * Use this function to read 16 bits of little-endian data from an
>    * IOStreamRef and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1017c1121,1122
<     static_assert(false, "Not implemented");
---
>     if (Uint16 value; SDL_ReadU16LE(get(), &value)) return value;
>     return {};
1019a1125,1142
>   /**
>    * Use this function to read 16 bits of little-endian data from an
>    * IOStreamRef and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1022c1145,1146
<     static_assert(false, "Not implemented");
---
>     if (Sint16 value; SDL_ReadS16LE(get(), &value)) return value;
>     return {};
1024a1149,1166
>   /**
>    * Use this function to read 16 bits of big-endian data from an IOStreamRef
>    * and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1027c1169,1170
<     static_assert(false, "Not implemented");
---
>     if (Uint16 value; SDL_ReadU16BE(get(), &value)) return value;
>     return {};
1029a1173,1190
>   /**
>    * Use this function to read 16 bits of big-endian data from an IOStreamRef
>    * and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1032c1193,1194
<     static_assert(false, "Not implemented");
---
>     if (Sint16 value; SDL_ReadS16BE(get(), &value)) return value;
>     return {};
1034a1197,1214
>   /**
>    * Use this function to read 32 bits of little-endian data from an
>    * IOStreamRef and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1037c1217,1218
<     static_assert(false, "Not implemented");
---
>     if (Uint32 value; SDL_ReadU32LE(get(), &value)) return value;
>     return {};
1039a1221,1238
>   /**
>    * Use this function to read 32 bits of little-endian data from an
>    * IOStreamRef and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1042c1241,1242
<     static_assert(false, "Not implemented");
---
>     if (Sint32 value; SDL_ReadS32LE(get(), &value)) return value;
>     return {};
1044a1245,1262
>   /**
>    * Use this function to read 32 bits of big-endian data from an IOStreamRef
>    * and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1047c1265,1266
<     static_assert(false, "Not implemented");
---
>     if (Uint32 value; SDL_ReadU32BE(get(), &value)) return value;
>     return {};
1049a1269,1286
>   /**
>    * Use this function to read 32 bits of big-endian data from an IOStreamRef
>    * and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1052c1289,1290
<     static_assert(false, "Not implemented");
---
>     if (Sint32 value; SDL_ReadS32BE(get(), &value)) return value;
>     return {};
1054a1293,1310
>   /**
>    * Use this function to read 64 bits of little-endian data from an
>    * IOStreamRef and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1057c1313,1314
<     static_assert(false, "Not implemented");
---
>     if (Uint64 value; SDL_ReadU64LE(get(), &value)) return value;
>     return {};
1059a1317,1334
>   /**
>    * Use this function to read 64 bits of little-endian data from an
>    * IOStreamRef and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1062c1337,1338
<     static_assert(false, "Not implemented");
---
>     if (Sint64 value; SDL_ReadS64LE(get(), &value)) return value;
>     return {};
1064a1341,1358
>   /**
>    * Use this function to read 64 bits of big-endian data from an IOStreamRef
>    * and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1067c1361,1362
<     static_assert(false, "Not implemented");
---
>     if (Uint64 value; SDL_ReadU64BE(get(), &value)) return value;
>     return {};
1069a1365,1382
>   /**
>    * Use this function to read 64 bits of big-endian data from an IOStreamRef
>    * and return in native format.
>    *
>    * SDL byteswaps the data only if necessary, so the data returned will be in
>    * the native byte order.
>    *
>    * This function will return false when the data stream is completely read,
>    * and IOStreamRef.GetStatus() will return IO_STATUS_EOF. If false is
>    * returned and the stream is not at EOF, IOStreamRef.GetStatus() will return
>    * a different error value and GetError() will offer a human-readable message.
>    *
>    * @returns the data read on success, std::nullopt on failure.
>    *
>    * @threadsafety This function is not thread safe.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
1072c1385,1386
<     static_assert(false, "Not implemented");
---
>     if (Sint64 value; SDL_ReadS64BE(get(), &value)) return value;
>     return {};
1480c1794
<   return SDL::IOFromMem(mem);
---
>   return SDL::IOFromMem(mem.data, mem.size_bytes);
1529c1843
<   return SDL::IOFromConstMem(mem);
---
>   return SDL::IOFromConstMem(mem.data, mem.size_bytes);
1652c1966
<   return CheckError(SDL_GetIOProperties(context));
---
>   return {CheckError(SDL_GetIOProperties(context))};
1791c2105
<   return SDL_ReadIO(context, buf);
---
>   return SDL_ReadIO(context, buf.data, buf.size_bytes);
1796c2110
<   return SDL::ReadIO(m_resource, buf);
---
>   return SDL::ReadIO(m_resource, std::move(buf));
1831c2145
<   return SDL_WriteIO(context, buf);
---
>   return SDL_WriteIO(context, buf.data, buf.size_bytes);
1841a2156,2157
>  * @warning this is not typesafe! Prefer using print() and println()
>  *
1862c2178,2185
<   return SDL_IOprintf(context, fmt, ...);
---
>   va_list ap;
>   size_t result;
> 
>   va_start(ap, fmt);
>   result = SDL_IOvprintf(context, fmt, ap);
>   va_end(ap);
> 
>   return result;
1943c2266,2268
<   return SDL_LoadFile_IO(src);
---
>   size_t datasize = 0;
>   auto data = static_cast<char*>(SDL_LoadFile_IO(src, &datasize, false));
>   return StringResult{CheckError(data), datasize};
1958,1959d2282
<  * The data should be freed with free().
<  *
1961,1963c2284,2285
<  * @param datasize if not nullptr, will store the number of bytes read.
<  * @returns the data or nullptr on failure; call GetError() for more
<  *          information.
---
>  * @returns the data.
>  * @throws Error on failure.
1972c2294,2299
< inline StringResult LoadFile(StringParam file) { return SDL_LoadFile(file); }
---
> inline StringResult LoadFile(StringParam file)
> {
>   size_t datasize = 0;
>   auto data = static_cast<char*>(SDL_LoadFile(file, &datasize));
>   return StringResult{CheckError(data), datasize};
> }
1973a2301,2318
> /**
>  * Load all the data from a file path.
>  *
>  * The data is allocated with a zero byte at the end (null terminated) for
>  * convenience. This extra byte is not included in the value reported via
>  * `datasize`.
>  *
>  * @param file the path to read all available data from.
>  * @returns the data.
>  * @throws Error on failure.
>  *
>  * @threadsafety This function is not thread safe.
>  *
>  * @since This function is available since SDL 3.2.0.
>  *
>  * @sa IOStream.LoadFile
>  * @sa SaveFile
>  */
1977c2322,2324
<   static_assert(false, "Not implemented");
---
>   size_t datasize = 0;
>   auto data = static_cast<T*>(SDL_LoadFile(file, &datasize));
>   return OwnArray<T>{CheckError(data), datasize / sizeof(T)};
2000c2347
<   CheckError(SDL_SaveFile_IO(src, data));
---
>   CheckError(SDL_SaveFile_IO(src, data.data, data.size_bytes, false));
2014d2360
<  * @param datasize the number of bytes to be written.
2026c2372
<   CheckError(SDL_SaveFile(file, data));
---
>   CheckError(SDL_SaveFile(file, data.data, data.size_bytes));
2045,2047c2391,2396
< inline Uint8 ReadU8(IOStreamParam src) { return CheckError(SDL_ReadU8(src)); }
< 
< inline Uint8 IOStream::ReadU8() { return SDL::ReadU8(m_resource); }
---
> inline Uint8 ReadU8(IOStreamParam src)
> {
>   Uint8 value;
>   CheckError(SDL_ReadU8(src, &value));
>   return value;
> }
2065,2067c2414,2419
< inline Sint8 ReadS8(IOStreamParam src) { return CheckError(SDL_ReadS8(src)); }
< 
< inline Sint8 IOStream::ReadS8() { return SDL::ReadS8(m_resource); }
---
> inline Sint8 ReadS8(IOStreamParam src)
> {
>   Sint8 value;
>   CheckError(SDL_ReadS8(src, &value));
>   return value;
> }
2091c2443,2445
<   return CheckError(SDL_ReadU16LE(src));
---
>   Uint16 value;
>   CheckError(SDL_ReadU16LE(src, &value));
>   return value;
2118c2472,2474
<   return CheckError(SDL_ReadS16LE(src));
---
>   Sint16 value;
>   CheckError(SDL_ReadS16LE(src, &value));
>   return value;
2145c2501,2503
<   return CheckError(SDL_ReadU16BE(src));
---
>   Uint16 value;
>   CheckError(SDL_ReadU16BE(src, &value));
>   return value;
2172c2530,2532
<   return CheckError(SDL_ReadS16BE(src));
---
>   Sint16 value;
>   CheckError(SDL_ReadS16BE(src, &value));
>   return value;
2199c2559,2561
<   return CheckError(SDL_ReadU32LE(src));
---
>   Uint32 value;
>   CheckError(SDL_ReadU32LE(src, &value));
>   return value;
2226c2588,2590
<   return CheckError(SDL_ReadS32LE(src));
---
>   Sint32 value;
>   CheckError(SDL_ReadS32LE(src, &value));
>   return value;
2253c2617,2619
<   return CheckError(SDL_ReadU32BE(src));
---
>   Uint32 value;
>   CheckError(SDL_ReadU32BE(src, &value));
>   return value;
2280c2646,2648
<   return CheckError(SDL_ReadS32BE(src));
---
>   Sint32 value;
>   CheckError(SDL_ReadS32BE(src, &value));
>   return value;
2307c2675,2677
<   return CheckError(SDL_ReadU64LE(src));
---
>   Uint64 value;
>   CheckError(SDL_ReadU64LE(src, &value));
>   return value;
2334c2704,2706
<   return CheckError(SDL_ReadS64LE(src));
---
>   Sint64 value;
>   CheckError(SDL_ReadS64LE(src, &value));
>   return value;
2361c2733,2735
<   return CheckError(SDL_ReadU64BE(src));
---
>   Uint64 value;
>   CheckError(SDL_ReadU64BE(src, &value));
>   return value;
2388c2762,2764
<   return CheckError(SDL_ReadS64BE(src));
---
>   Sint64 value;
>   CheckError(SDL_ReadS64BE(src, &value));
>   return value;
