13c13
<  * @defgroup CategoryRender Category Render
---
>  * @defgroup CategoryRender 2D Accelerated Rendering
149a150,151
> #if SDL_VERSION_ATLEAST(3, 4, 0)
> 
185a188,189
> #endif // SDL_VERSION_ATLEAST(3, 4, 0)
> 
242,245d245
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
249,252d248
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
259,262d254
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
266,269d257
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
363,364c351,385
<   /// Default ctor
<   Renderer(WindowParam window) {}
---
>   /**
>    * Create a 2D rendering context for a window.
>    *
>    * If you want a specific renderer, you can specify its name here. A list of
>    * available renderers can be obtained by calling GetRenderDriver()
>    * multiple times, with indices from 0 to GetNumRenderDrivers()-1. If you
>    * don't need a specific renderer, specify nullptr and SDL will attempt to
>    * choose the best option for you, based on what is available on the user's
>    * system.
>    *
>    * If `name` is a comma-separated list, SDL will try each name, in the order
>    * listed, until one succeeds or all of them fail.
>    *
>    * By default the rendering size matches the window size in pixels, but you
>    * can call Renderer.SetLogicalPresentation() to change the content size and
>    * scaling options.
>    *
>    * @param window the window where rendering is displayed.
>    * @throws Error on failure.
>    *
>    * @threadsafety This function should only be called on the main thread.
>    *
>    * @since This function is available since SDL 3.2.0.
>    *
>    * @sa Renderer.Renderer
>    * @sa Renderer.Renderer
>    * @sa Renderer.Destroy
>    * @sa GetNumRenderDrivers
>    * @sa GetRenderDriver
>    * @sa Renderer.GetName
>    */
>   Renderer(WindowParam window)
>     : m_resource(CheckError(SDL_CreateRenderer(window, nullptr)))
>   {
>   }
386,387c407
<    * @post a valid rendering context or nullptr if there was an error; call
<    *          GetError() for more information.
---
>    * @throws Error on failure.
401c421
<     : m_resource(SDL_CreateRenderer(window, name))
---
>     : m_resource(CheckError(SDL_CreateRenderer(window, name)))
454,455c474
<    * @post a valid rendering context or nullptr if there was an error; call
<    *          GetError() for more information.
---
>    * @throws Error on failure.
468c487
<     : m_resource(SDL_CreateRendererWithProperties(props))
---
>     : m_resource(CheckError(SDL_CreateRendererWithProperties(props)))
482,483c501
<    * @post a valid rendering context or nullptr if there was an error; call
<    *          GetError() for more information.
---
>    * @throws Error on failure.
492c510
<     : m_resource(SDL_CreateSoftwareRenderer(surface))
---
>     : m_resource(CheckError(SDL_CreateSoftwareRenderer(surface)))
583d600
<    * @sa Renderer.Renderer
704,706c721
<    * @param renderer the rendering context.
<    * @param w a pointer filled in with the width in pixels.
<    * @param h a pointer filled in with the height in pixels.
---
>    * @returns Point on success.
709,710d723
<    * @threadsafety This function should only be called on the main thread.
<    *
747,749c760
<    * @param renderer the rendering context.
<    * @param w a pointer filled in with the current width.
<    * @param h a pointer filled in with the current height.
---
>    * @returns the size on success.
767,768c778
<    * @param w the width of the texture in pixels.
<    * @param h the height of the texture in pixels.
---
>    * @param size the width and height of the texture in pixels.
965a976,989
>   /**
>    * Set target texture back to window
>    *
>    * This is equivalent to SetTarget(nullptr)
>    *
>    * @throws Error on failure.
>    *
>    * @threadsafety This function should only be called on the main thread.
>    *
>    * @since This function is available since SDL 3.2.0.
>    *
>    * @sa SetTarget(nullptr)
>    * @sa GetTarget()
>    */
1011a1036,1043
>    * For the renderer's window, letterboxing is drawn into the framebuffer if
>    * logical presentation is enabled during Renderer.Present; be sure to
>    * reenable it before presenting if you were toggling it, otherwise the
>    * letterbox areas might have artifacts from previous frames (or artifacts
>    * from external overlays, etc). Letterboxing is never drawn into texture
>    * render targets; be sure to call Renderer.RenderClear() before drawing into
>    * the texture so the letterboxing areas are cleared, if appropriate.
>    *
1015,1016c1047
<    * @param w the width of the logical resolution.
<    * @param h the height of the logical resolution.
---
>    * @param size the width and height of the logical resolution.
1065,1066c1096
<    * @param w an int filled with the logical presentation width.
<    * @param h an int filled with the logical presentation height.
---
>    * @param size a Point to be filled with the width and height.
1091,1092c1121
<    * @param rect a pointer filled in with the final presentation rectangle, may
<    *             be nullptr.
---
>    * @returns the final presentation rectangle.
1113,1116c1142,1143
<    * @param window_x the x coordinate in window coordinates.
<    * @param window_y the y coordinate in window coordinates.
<    * @param x a pointer filled with the x coordinate in render coordinates.
<    * @param y a pointer filled with the y coordinate in render coordinates.
---
>    * @param window_coord the x, y coordinate in window coordinates.
>    * @returns a FPoint containing ther render coordinates on success.
1134,1136c1161,1163
<    * - The logical presentation settings (Renderer.SetLogicalPresentation)
<    * - The scale (Renderer.SetScale)
<    * - The viewport (Renderer.SetViewport)
---
>    * - The logical presentation settings (RendererRef.SetLogicalPresentation)
>    * - The scale (RendererRef.SetScale)
>    * - The viewport (RendererRef.SetViewport)
1138,1143c1165,1166
<    * @param x the x coordinate in render coordinates.
<    * @param y the y coordinate in render coordinates.
<    * @param window_x a pointer filled with the x coordinate in window
<    *                 coordinates.
<    * @param window_y a pointer filled with the y coordinate in window
<    *                 coordinates.
---
>    * @param coord the x, y coordinate in render coordinates.
>    * @returns a FPoint filled with window coordinates on success.
1211c1234
<    * @sa Renderer.ViewportSet
---
>    * @sa Renderer.IsViewportSet
1214a1238,1252
>   /**
>    * Reset the drawing area for rendering to the entire target
>    *
>    * This is equivalent to `SetViewport(std::nullopt)`
>    *
>    * @throws Error on failure.
>    *
>    * @threadsafety This function should only be called on the main thread.
>    *
>    * @since This function is available since SDL 3.2.0.
>    *
>    * @sa GetViewport()
>    * @sa SetViewport()
>    * @sa ViewportSet()
>    */
1223c1261
<    * @param rect an Rect structure filled in with the current drawing area.
---
>    * @returns an Rect with the current drawing area.
1230c1268
<    * @sa Renderer.ViewportSet
---
>    * @sa Renderer.IsViewportSet
1266,1267c1304
<    * @param rect a pointer filled in with the area that is safe for interactive
<    *             content.
---
>    * @returns the rect filled the area that is safe for interactive content.
1290a1328
>    * @sa Renderer.ResetClipRect()
1294a1333,1347
>   /**
>    * Reset the clip rectangle for rendering to the entire render target
>    *
>    * This is equivalent to `SetClipRect(std::nullopt)`
>    *
>    * @throws Error on failure.
>    *
>    * @threadsafety This function should only be called on the main thread.
>    *
>    * @since This function is available since SDL 3.2.0.
>    *
>    * @sa GetClipRect()
>    * @sa SetClipRect()
>    * @sa ClipEnabled()
>    */
1303,1304c1356,1357
<    * @param rect an Rect structure filled in with the current clipping area
<    *             or an empty rectangle if clipping is disabled.
---
>    * @returns a Rect structure filled in with the current clipping area or an
>    *          empty rectangle if clipping is disabled.
1348,1349c1401
<    * @param scaleX the horizontal scaling factor.
<    * @param scaleY the vertical scaling factor.
---
>    * @param scale the x, y scaling factors.
1384,1386c1436
<    * @param renderer the rendering context.
<    * @param scaleX a pointer filled in with the horizontal scaling factor.
<    * @param scaleY a pointer filled in with the vertical scaling factor.
---
>    * @returns the scaling factors on success.
1403,1408c1453
<    * @param r the red value used to draw on the rendering target.
<    * @param g the green value used to draw on the rendering target.
<    * @param b the blue value used to draw on the rendering target.
<    * @param a the alpha value used to draw on the rendering target; usually
<    *          `ALPHA_OPAQUE` (255). Use Renderer.SetDrawBlendMode to
<    *          specify how the alpha channel is used.
---
>    * @param c the color value used to draw on the rendering target.
1426,1431c1471
<    * @param r the red value used to draw on the rendering target.
<    * @param g the green value used to draw on the rendering target.
<    * @param b the blue value used to draw on the rendering target.
<    * @param a the alpha value used to draw on the rendering target. Use
<    *          Renderer.SetDrawBlendMode to specify how the alpha channel is
<    *          used.
---
>    * @param c the RGBA values used to draw on the rendering target.
1468,1476c1508
<    * @param renderer the rendering context.
<    * @param r a pointer filled in with the red value used to draw on the
<    *          rendering target.
<    * @param g a pointer filled in with the green value used to draw on the
<    *          rendering target.
<    * @param b a pointer filled in with the blue value used to draw on the
<    *          rendering target.
<    * @param a a pointer filled in with the alpha value used to draw on the
<    *          rendering target; usually `ALPHA_OPAQUE` (255).
---
>    * @returns the color channel values used to draw on the rendering target.
1483,1484c1515,1516
<    * @sa Renderer.GetDrawColorFloat
<    * @sa Renderer.SetDrawColor
---
>    * @sa GetDrawColor(SDL_FColor*)
>    * @sa SetDrawColor()
1513,1521c1545
<    * @param renderer the rendering context.
<    * @param r a pointer filled in with the red value used to draw on the
<    *          rendering target.
<    * @param g a pointer filled in with the green value used to draw on the
<    *          rendering target.
<    * @param b a pointer filled in with the blue value used to draw on the
<    *          rendering target.
<    * @param a a pointer filled in with the alpha value used to draw on the
<    *          rendering target.
---
>    * @returns the color on success.
1528,1529c1552,1553
<    * @sa Renderer.SetDrawColorFloat
<    * @sa Renderer.GetDrawColor
---
>    * @sa GetDrawColor(SDL_FColor*)
>    * @sa SetDrawColor()
1558c1582
<    * @param scale a pointer filled in with the current color scale value.
---
>    * @returns a float representing the current color scale on success.
1588c1612
<    * @param blendMode a pointer filled in with the current BlendMode.
---
>    * @returns the current BlendMode on success.
1620,1621c1644
<    * @param x the x coordinate of the point.
<    * @param y the y coordinate of the point.
---
>    * @param p the x, y coordinates of the point.
1636d1658
<    * @param count the number of points to draw.
1650,1653c1672,1673
<    * @param x1 the x coordinate of the start point.
<    * @param y1 the y coordinate of the start point.
<    * @param x2 the x coordinate of the end point.
<    * @param y2 the y coordinate of the end point.
---
>    * @param p1 the x,y coordinate of the start point.
>    * @param p2 the x,y coordinate of the end point.
1669d1688
<    * @param count the number of points, drawing count-1 lines.
1683,1684c1702,1703
<    * @param rect a pointer to the destination rectangle, or nullptr to outline
<    * the entire rendering target.
---
>    * @param rect a pointer to the destination rectangle, or std::nullopt to
>    *             outline the entire rendering target.
1700d1718
<    * @param count the number of rectangles.
1715,1716c1733,1734
<    * @param rect a pointer to the destination rectangle, or nullptr for the
<    * entire rendering target.
---
>    * @param rect a pointer to the destination rectangle, or std::nullopt for the
>    *             entire rendering target.
1732d1749
<    * @param count the number of rectangles.
1794c1811
<                             FlipMode flip);
---
>                             FlipMode flip = FlipMode::SDL_FLIP_NONE);
1949d1965
<    * @param num_vertices number of vertices.
1952,1953c1968
<    * sequential order.
<    * @param num_indices number of indices.
---
>    *                sequential order.
1965c1980
<                       std::span<const int> indices);
---
>                       std::span<const int> indices = {});
2026,2029d2040
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
2249,2250c2260
<    * @param vsync an int filled with the current vertical refresh sync interval.
<    *              See Renderer.SetVSync() for the meaning of the value.
---
>    * @returns the current vertical refresh sync interval on success.
2286,2287c2296,2297
<    * @param x the x coordinate where the top-left corner of the text will draw.
<    * @param y the y coordinate where the top-left corner of the text will draw.
---
>    * @param p the x, y coordinates where the top-left corner of the text will
>    *          draw.
2303,2305c2313,2316
<    * This function will render a printf()-style format string to a renderer.
<    * Note that this is a convenience function for debugging, with severe
<    * limitations, and is not intended to be used for production apps and games.
---
>    * This function will render a std::format()-style format string to a
>    * renderer. Note that this is a convenience function for debugging, with
>    * severe limitations, and is not intended to be used for production apps and
>    * games.
2310,2311c2321,2322
<    * @param x the x coordinate where the top-left corner of the text will draw.
<    * @param y the y coordinate where the top-left corner of the text will draw.
---
>    * @param p the x, y coordinates where the top-left corner of the text will
>    *          draw.
2313,2314c2324,2325
<    * @param ... additional parameters matching % tokens in the `fmt` string, if
<    *            any.
---
>    * @param args additional parameters matching {} tokens in the `fmt` string,
>    *             if any.
2347,2350d2357
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
2367,2370d2373
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
2389,2392d2391
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
2487,2490c2486,2487
<    * @param w the width of the texture in pixels.
<    * @param h the height of the texture in pixels.
<    * @post the created texture or nullptr on failure; call GetError() for
<    *          more information.
---
>    * @param size the width and height of the texture in pixels.
>    * @throws Error on failure.
2506c2503,2504
<     : m_resource(SDL_CreateTexture(renderer, format, access, size))
---
>     : m_resource(
>         CheckError(SDL_CreateTexture(renderer, format, access, size.x, size.y)))
2525,2526c2523
<    * @post the created texture or nullptr on failure; call GetError() for
<    *          more information.
---
>    * @throws Error on failure.
2533d2529
<    * @sa Texture.Texture
2537c2533
<     : m_resource(SDL_CreateTextureFromSurface(renderer, surface))
---
>     : m_resource(CheckError(SDL_CreateTextureFromSurface(renderer, surface)))
2654,2655c2650
<    * @post the created texture or nullptr on failure; call GetError() for
<    *          more information.
---
>    * @throws Error on failure.
2669c2664
<     : m_resource(SDL_CreateTextureWithProperties(renderer, props))
---
>     : m_resource(CheckError(SDL_CreateTextureWithProperties(renderer, props)))
2694,2696d2688
<    * When done with the returned texture, the app should dispose of it with a
<    * call to Texture.Destroy().
<    *
2738,2740d2729
<    * When done with the returned texture, the app should dispose of it with a
<    * call to Texture.Destroy().
<    *
2753c2742
<   Texture(RendererParam renderer, IOStreamParam src, bool closeio);
---
>   Texture(RendererParam renderer, IOStreamParam src, bool closeio = false);
2951,2964c2940
<   /**
<    * Get the size of a texture, as floating point values.
<    *
<    * @param texture the texture to query.
<    * @param w a pointer filled in with the width of the texture in pixels. This
<    *          argument can be nullptr if you don't need this information.
<    * @param h a pointer filled in with the height of the texture in pixels. This
<    *          argument can be nullptr if you don't need this information.
<    * @throws Error on failure.
<    *
<    * @threadsafety This function should only be called on the main thread.
<    *
<    * @since This function is available since SDL 3.2.0.
<    */
---
>   /// Get the size of a texture.
2966a2943
>   /// Get the size of a texture, as floating point values.
2968a2946
>   /// Get the width in pixels.
2970a2949
>   /// Get the height in pixels.
2972a2952
>   /// Get the pixel format.
2997,3000d2976
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
3158c3134
<    * @param alpha a pointer filled in with the current alpha value.
---
>    * @returns the current alpha value.
3174c3150
<    * @param alpha a pointer filled in with the current alpha value.
---
>    * @returns the current alpha value.
3186a3163,3184
>   /**
>    * Set an additional color and alpha values multiplied into render copy
>    * operations.
>    *
>    * When this texture is rendered, during the copy operation each source color
>    * and alpha channels are modulated by the appropriate color value according
>    * to the following formula:
>    *
>    *      srcC = srcC * (color / 255)
>    *      srcA = srcA * (alpha / 255)
>    *
>    * Color and alpha modulation is not always supported by the renderer; it will
>    * return false if either modulation is not supported.
>    *
>    * @param c the color and alpha channel values multiplied into copy
>    *          operations.
>    * @throws Error on failure.
>    *
>    * @threadsafety This function should only be called on the main thread.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
3188a3187,3208
>   /**
>    * Set an additional color and alpha values multiplied into render copy
>    * operations.
>    *
>    * When this texture is rendered, during the copy operation each source color
>    * and alpha channels are modulated by the appropriate color value according
>    * to the following formula:
>    *
>    *      srcC = srcC * (color / 255)
>    *      srcA = srcA * (alpha / 255)
>    *
>    * Color and alpha modulation is not always supported by the renderer; it will
>    * return false if either modulation is not supported.
>    *
>    * @param c the color and alpha channel values multiplied into copy
>    *          operations.
>    * @throws Error on failure.
>    *
>    * @threadsafety This function should only be called on the main thread.
>    *
>    * @since This function is available since SDL 3.2.0.
>    */
3190a3211,3223
>   /**
>    * Get the additional color value multiplied into render copy operations.
>    *
>    * @returns the color channels (0-1) on success.
>    * @throws Error on failure.
>    *
>    * @threadsafety This function should only be called on the main thread.
>    *
>    * @since This function is available since SDL 3.2.0.
>    *
>    * @sa GetAlphaMod()
>    * @sa SetColorMod()
>    */
3192a3226,3238
>   /**
>    * Get the additional color value multiplied into render copy operations.
>    *
>    * @returns the color channels (0-1) on success.
>    * @throws Error on failure.
>    *
>    * @threadsafety This function should only be called on the main thread.
>    *
>    * @since This function is available since SDL 3.2.0.
>    *
>    * @sa GetAlphaMod()
>    * @sa SetColorMod()
>    */
3215c3261
<    * @param blendMode a pointer filled in with the current BlendMode.
---
>    * @returns the current SDL_BlendMode on success.
3247c3293
<    * @param scaleMode a pointer filled in with the current scale mode.
---
>    * @returns the current scale mode on success.
3304,3308c3350,3353
<    * @param rect an Rect structure representing the area to update, or nullptr
<    *             to update the entire texture.
<    * @param pixels the raw pixel data in the format of the texture.
<    * @param pitch the number of bytes in a row of pixel data, including padding
<    *              between lines.
---
>    * @param surface the surface containing pixel data in the format of the
>    *                texture.
>    * @param rect an Rect structure representing the area to update, or
>    *             std::nullopt to update the entire texture.
3439,3440c3484,3485
<    * @param surface a pointer to an SDL surface of size **rect**. Don't assume
<    *                any specific pixel content.
---
>    * @returns a surface of size **rect**. Don't assume any specific pixel
>    *          content.
3524,3525c3569
<  * @param width the width of the window.
<  * @param height the height of the window.
---
>  * @param size the width and height of the window.
3528,3529c3572
<  * @param window a pointer filled with the window, or nullptr on error.
<  * @param renderer a pointer filled with the renderer, or nullptr on error.
---
>  * @returns a pair with window and renderer.
3544c3587,3591
<   return CheckError(SDL_CreateWindowAndRenderer(title, size, window_flags));
---
>   SDL_Window* window = nullptr;
>   SDL_Renderer* renderer = nullptr;
>   CheckError(SDL_CreateWindowAndRenderer(
>     title, size.x, size.y, window_flags, &window, &renderer));
>   return {Window{window}, Renderer(renderer)};
3673,3676d3719
< #endif // SDL_VERSION_ATLEAST(3, 3, 2)
< 
< #if SDL_VERSION_ATLEAST(3, 3, 2)
< 
3680,3683d3722
< #endif // SDL_VERSION_ATLEAST(3, 3, 2)
< 
< #if SDL_VERSION_ATLEAST(3, 3, 2)
< 
3687,3690d3725
< #endif // SDL_VERSION_ATLEAST(3, 3, 2)
< 
< #if SDL_VERSION_ATLEAST(3, 3, 2)
< 
3821,3824d3855
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
3841,3844d3871
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
3878c3905
<   return CheckError(SDL_GetRenderer(m_resource));
---
>   return {CheckError(SDL_GetRenderer(m_resource))};
3894c3921
<   return CheckError(SDL_GetRenderWindow(renderer));
---
>   return {CheckError(SDL_GetRenderWindow(renderer))};
4014c4041
<   return CheckError(SDL_GetRendererProperties(renderer));
---
>   return {CheckError(SDL_GetRendererProperties(renderer))};
4057,4058c4084
<  * @param w a pointer filled in with the width in pixels.
<  * @param h a pointer filled in with the height in pixels.
---
>  * @returns the size on success.
4069c4095,4097
<   static_assert(false, "Not implemented");
---
>   Point p;
>   GetRenderOutputSize(renderer, &p.x, &p.y);
>   return p;
4117,4118c4145
<  * @param w a pointer filled in with the current width.
<  * @param h a pointer filled in with the current height.
---
>  * @returns the size on success.
4129c4156,4158
<   static_assert(false, "Not implemented");
---
>   Point p;
>   GetCurrentRenderOutputSize(renderer, &p.x, &p.y);
>   return p;
4150,4151c4179
<  * @param w the width of the texture in pixels.
<  * @param h the height of the texture in pixels.
---
>  * @param size the width and height of the texture in pixels.
4433,4436d4460
< #endif // SDL_VERSION_ATLEAST(3, 3, 2)
< 
< #if SDL_VERSION_ATLEAST(3, 3, 2)
< 
4440,4443d4463
< #endif // SDL_VERSION_ATLEAST(3, 3, 2)
< 
< #if SDL_VERSION_ATLEAST(3, 3, 2)
< 
4447,4450d4466
< #endif // SDL_VERSION_ATLEAST(3, 3, 2)
< 
< #if SDL_VERSION_ATLEAST(3, 3, 2)
< 
4525,4528d4540
< #endif // SDL_VERSION_ATLEAST(3, 3, 2)
< 
< #if SDL_VERSION_ATLEAST(3, 3, 2)
< 
4531,4534d4542
< #endif // SDL_VERSION_ATLEAST(3, 3, 2)
< 
< #if SDL_VERSION_ATLEAST(3, 3, 2)
< 
4537,4540d4544
< #endif // SDL_VERSION_ATLEAST(3, 3, 2)
< 
< #if SDL_VERSION_ATLEAST(3, 3, 2)
< 
4646c4650
<   return CheckError(SDL_GetTextureProperties(texture));
---
>   return {CheckError(SDL_GetTextureProperties(texture))};
4667c4671
<   return SDL_GetRendererFromTexture(texture);
---
>   return {SDL_GetRendererFromTexture(texture)};
4694,4707c4698
< /**
<  * Get the size of a texture, as floating point values.
<  *
<  * @param texture the texture to query.
<  * @param w a pointer filled in with the width of the texture in pixels. This
<  *          argument can be nullptr if you don't need this information.
<  * @param h a pointer filled in with the height of the texture in pixels. This
<  *          argument can be nullptr if you don't need this information.
<  * @throws Error on failure.
<  *
<  * @threadsafety This function should only be called on the main thread.
<  *
<  * @since This function is available since SDL 3.2.0.
<  */
---
> /// Get the size of a texture.
4710c4701
<   static_assert(false, "Not implemented");
---
>   return Point(texture->w, texture->h);
4722a4714
> /// Get the size of a texture, as floating point values.
4725c4717,4719
<   static_assert(false, "Not implemented");
---
>   FPoint p;
>   GetTextureSize(texture, &p.x, &p.y);
>   return p;
4733,4736c4727,4728
< inline int GetTextureWidth(TextureConstParam texture)
< {
<   static_assert(false, "Not implemented");
< }
---
> /// Get the width in pixels.
> inline int GetTextureWidth(TextureConstParam texture) { return texture->w; }
4743,4746c4735,4736
< inline int GetTextureHeight(TextureConstParam texture)
< {
<   static_assert(false, "Not implemented");
< }
---
> /// Get the height in pixels.
> inline int GetTextureHeight(TextureConstParam texture) { return texture->h; }
4752a4743
> /// Get the pixel format.
4755c4746
<   static_assert(false, "Not implemented");
---
>   return texture->format;
4789,4792d4779
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
4798,4801d4784
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
4820,4823d4802
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
5036c5015
<  * @param alpha a pointer filled in with the current alpha value.
---
>  * @returns the current alpha value.
5049c5028,5030
<   return CheckError(SDL_GetTextureAlphaMod(texture));
---
>   Uint8 alpha;
>   CheckError(SDL_GetTextureAlphaMod(texture, &alpha));
>   return alpha;
5061c5042
<  * @param alpha a pointer filled in with the current alpha value.
---
>  * @returns the current alpha value.
5074c5055,5057
<   return CheckError(SDL_GetTextureAlphaModFloat(texture));
---
>   float alpha;
>   CheckError(SDL_GetTextureAlphaModFloat(texture, &alpha));
>   return alpha;
5081a5065,5087
> /**
>  * Set an additional color and alpha values multiplied into render copy
>  * operations.
>  *
>  * When this texture is rendered, during the copy operation each source color
>  * and alpha channels are modulated by the appropriate color value according
>  * to the following formula:
>  *
>  *      srcC = srcC * (color / 255)
>  *      srcA = srcA * (alpha / 255)
>  *
>  * Color and alpha modulation is not always supported by the renderer; it will
>  * return false if either modulation is not supported.
>  *
>  * @param texture the texture to update.
>  * @param c the color and alpha channel values multiplied into copy
>  *          operations.
>  * @throws Error on failure.
>  *
>  * @threadsafety This function should only be called on the main thread.
>  *
>  * @since This function is available since SDL 3.2.0.
>  */
5084c5090,5091
<   static_assert(false, "Not implemented");
---
>   SetTextureColorMod(texture, c.r, c.g, c.b);
>   SetTextureAlphaMod(texture, c.a);
5088a5096,5118
> /**
>  * Set an additional color and alpha values multiplied into render copy
>  * operations.
>  *
>  * When this texture is rendered, during the copy operation each source color
>  * and alpha channels are modulated by the appropriate color value according
>  * to the following formula:
>  *
>  *      srcC = srcC * (color / 255)
>  *      srcA = srcA * (alpha / 255)
>  *
>  * Color and alpha modulation is not always supported by the renderer; it will
>  * return false if either modulation is not supported.
>  *
>  * @param texture the texture to update.
>  * @param c the color and alpha channel values multiplied into copy
>  *          operations.
>  * @throws Error on failure.
>  *
>  * @threadsafety This function should only be called on the main thread.
>  *
>  * @since This function is available since SDL 3.2.0.
>  */
5091c5121,5122
<   static_assert(false, "Not implemented");
---
>   SetTextureColorModFloat(texture, c.r, c.g, c.b);
>   SetTextureAlphaModFloat(texture, c.a);
5098a5130,5143
> /**
>  * Get the additional color value multiplied into render copy operations.
>  *
>  * @param texture the texture to query.
>  * @returns the color channels (0-1) on success.
>  * @throws Error on failure.
>  *
>  * @threadsafety This function should only be called on the main thread.
>  *
>  * @since This function is available since SDL 3.2.0.
>  *
>  * @sa GetAlphaMod()
>  * @sa SetColorMod()
>  */
5101c5146,5149
<   static_assert(false, "Not implemented");
---
>   Color c;
>   GetTextureColorMod(texture, &c.r, &c.g, &c.b);
>   c.a = GetTextureAlphaMod(texture);
>   return c;
5105a5154,5167
> /**
>  * Get the additional color value multiplied into render copy operations.
>  *
>  * @param texture the texture to query.
>  * @returns the color channels (0-1) on success.
>  * @throws Error on failure.
>  *
>  * @threadsafety This function should only be called on the main thread.
>  *
>  * @since This function is available since SDL 3.2.0.
>  *
>  * @sa GetAlphaMod()
>  * @sa SetColorMod()
>  */
5108c5170,5173
<   static_assert(false, "Not implemented");
---
>   FColor c;
>   GetTextureColorModFloat(texture, &c.r, &c.g, &c.b);
>   c.a = GetTextureAlphaModFloat(texture);
>   return c;
5146c5211
<  * @param blendMode a pointer filled in with the current BlendMode.
---
>  * @return the current BlendMode.
5157c5222,5224
<   return CheckError(SDL_GetTextureBlendMode(texture));
---
>   BlendMode blendMode;
>   CheckError(SDL_GetTextureBlendMode(texture, &blendMode));
>   return blendMode;
5196c5263
<  * @param scaleMode a pointer filled in with the current scale mode.
---
>  * @return the current scale mode.
5207c5274,5276
<   return CheckError(SDL_GetTextureScaleMode(texture));
---
>   ScaleMode scaleMode;
>   CheckError(SDL_GetTextureScaleMode(texture, &scaleMode));
>   return scaleMode;
5269,5273c5338,5341
<  * @param rect an Rect structure representing the area to update, or nullptr
<  *             to update the entire texture.
<  * @param pixels the raw pixel data in the format of the texture.
<  * @param pitch the number of bytes in a row of pixel data, including padding
<  *              between lines.
---
>  * @param surface the surface containing pixel data in the format of the
>  *                texture.
>  * @param rect an Rect structure representing the area to update, or
>  *             std::nullopt to update the entire texture.
5289c5357
<   static_assert(false, "Not implemented");
---
>   UpdateTexture(texture, rect, surface->pixels, surface->pitch);
5469,5470c5537
<  * @param surface a pointer to an SDL surface of size **rect**. Don't assume
<  *                any specific pixel content.
---
>  * @returns a surface of size **rect**. Don't assume any specific pixel content.
5484c5551,5553
<   return CheckError(SDL_LockTextureToSurface(texture, rect));
---
>   SurfaceRaw surface = nullptr;
>   CheckError(SDL_LockTextureToSurface(texture, rect, &surface));
>   return Surface::Borrow(surface);
5548a5618,5632
> /**
>  * Set target texture back to window
>  *
>  * This is equivalent to SetTarget(nullptr)
>  *
>  * @param renderer the rendering context.
>  * @throws Error on failure.
>  *
>  * @threadsafety This function should only be called on the main thread.
>  *
>  * @since This function is available since SDL 3.2.0.
>  *
>  * @sa SetTarget(nullptr)
>  * @sa GetTarget()
>  */
5551c5635
<   static_assert(false, "Not implemented");
---
>   SetRenderTarget(renderer, nullptr);
5573c5657,5659
<   return SDL_GetRenderTarget(renderer);
---
>   TextureRaw texture = SDL_GetRenderTarget(renderer);
>   if (texture) return Texture::Borrow(texture);
>   return {};
5612,5613c5698
<  * @param w the width of the logical resolution.
<  * @param h the height of the logical resolution.
---
>  * @param size the width and height of the logical resolution.
5629c5714
<   CheckError(SDL_SetRenderLogicalPresentation(renderer, size, mode));
---
>   CheckError(SDL_SetRenderLogicalPresentation(renderer, size.x, size.y, mode));
5678,5679c5763,5764
<  * @param w an int filled with the logical presentation width.
<  * @param h an int filled with the logical presentation height.
---
>  * @param size a Point to be filled  with the logical presentation width and
>  *             height.
5694c5779,5782
<   static_assert(false, "Not implemented");
---
>   if (size) {
>     return GetRenderLogicalPresentation(renderer, &size->x, &size->y, mode);
>   }
>   return GetRenderLogicalPresentation(renderer, nullptr, nullptr, mode);
5723,5724c5811
<  * @param rect a pointer filled in with the final presentation rectangle, may
<  *             be nullptr.
---
>  * @returns with the final presentation rectangle.
5735c5822,5824
<   return CheckError(SDL_GetRenderLogicalPresentationRect(renderer));
---
>   FRect rect;
>   CheckError(SDL_GetRenderLogicalPresentationRect(renderer, &rect));
>   return rect;
5754,5757c5843,5844
<  * @param window_x the x coordinate in window coordinates.
<  * @param window_y the y coordinate in window coordinates.
<  * @param x a pointer filled with the x coordinate in render coordinates.
<  * @param y a pointer filled with the y coordinate in render coordinates.
---
>  * @param window_coord the x, y coordinate in window coordinates.
>  * @returns the x, y coordinate in render coordinates.
5770c5857,5860
<   return CheckError(SDL_RenderCoordinatesFromWindow(renderer, window_coord));
---
>   FPoint p;
>   CheckError(SDL_RenderCoordinatesFromWindow(
>     renderer, window_coord.x, window_coord.y, &p.x, &p.y));
>   return p;
5790,5795c5880,5881
<  * @param x the x coordinate in render coordinates.
<  * @param y the y coordinate in render coordinates.
<  * @param window_x a pointer filled with the x coordinate in window
<  *                 coordinates.
<  * @param window_y a pointer filled with the y coordinate in window
<  *                 coordinates.
---
>  * @param coord the x, y coordinates in render coordinates.
>  * @returns x, y in window coordinates.
5809c5895,5898
<   return CheckError(SDL_RenderCoordinatesToWindow(renderer, coord));
---
>   FPoint p;
>   CheckError(
>     SDL_RenderCoordinatesToWindow(renderer, coord.x, coord.y, &p.x, &p.y));
>   return p;
5895a5985,6000
> /**
>  * Reset the drawing area for rendering to the entire target
>  *
>  * This is equivalent to `SetViewport(std::nullopt)`
>  *
>  * @param renderer the rendering context.
>  * @throws Error on failure.
>  *
>  * @threadsafety This function should only be called on the main thread.
>  *
>  * @since This function is available since SDL 3.2.0.
>  *
>  * @sa GetViewport()
>  * @sa SetViewport()
>  * @sa ViewportSet()
>  */
5898c6003
<   static_assert(false, "Not implemented");
---
>   SetRenderViewport(renderer, std::nullopt);
5910c6015
<  * @param rect an Rect structure filled in with the current drawing area.
---
>  * @returns an Rect structure filled in with the current drawing area.
5917c6022
<  * @sa Renderer.ViewportSet
---
>  * @sa Renderer.IsViewportSet
5922c6027,6029
<   return CheckError(SDL_GetRenderViewport(renderer));
---
>   Rect rect;
>   CheckError(SDL_GetRenderViewport(renderer, &rect));
>   return rect;
5971,5972c6078
<  * @param rect a pointer filled in with the area that is safe for interactive
<  *             content.
---
>  * @returns the area that is safe for interactive content.
5981c6087,6089
<   return CheckError(SDL_GetRenderSafeArea(renderer));
---
>   Rect rect;
>   CheckError(SDL_GetRenderSafeArea(renderer, &rect));
>   return rect;
6017a6126,6141
> /**
>  * Reset the clip rectangle for rendering to the entire render target
>  *
>  * This is equivalent to `SetClipRect(std::nullopt)`
>  *
>  * @param renderer the rendering context.
>  * @throws Error on failure.
>  *
>  * @threadsafety This function should only be called on the main thread.
>  *
>  * @since This function is available since SDL 3.2.0.
>  *
>  * @sa GetClipRect()
>  * @sa SetClipRect()
>  * @sa ClipEnabled()
>  */
6020c6144
<   static_assert(false, "Not implemented");
---
>   SetRenderClipRect(renderer, std::nullopt);
6032,6033c6156,6157
<  * @param rect an Rect structure filled in with the current clipping area
<  *             or an empty rectangle if clipping is disabled.
---
>  * @returns an Rect structure filled in with the current clipping area
>  *          or an empty rectangle if clipping is disabled.
6045c6169,6171
<   return CheckError(SDL_GetRenderClipRect(renderer));
---
>   Rect rect;
>   CheckError(SDL_GetRenderClipRect(renderer, &rect));
>   return rect;
6095,6096c6221
<  * @param scaleX the horizontal scaling factor.
<  * @param scaleY the vertical scaling factor.
---
>  * @param scale the horizontal and vertical scaling factors.
6107c6232
<   CheckError(SDL_SetRenderScale(renderer, scale));
---
>   CheckError(SDL_SetRenderScale(renderer, scale.x, scale.y));
6143,6145c6268
<  * @param renderer the rendering context.
<  * @param scaleX a pointer filled in with the horizontal scaling factor.
<  * @param scaleY a pointer filled in with the vertical scaling factor.
---
>  * @returns the scaling factors on success.
6156c6279,6281
<   static_assert(false, "Not implemented");
---
>   FPoint p;
>   GetRenderScale(renderer, &p.x, &p.y);
>   return p;
6176,6181c6301
<  * @param r the red value used to draw on the rendering target.
<  * @param g the green value used to draw on the rendering target.
<  * @param b the blue value used to draw on the rendering target.
<  * @param a the alpha value used to draw on the rendering target; usually
<  *          `ALPHA_OPAQUE` (255). Use Renderer.SetDrawBlendMode to
<  *          specify how the alpha channel is used.
---
>  * @param c the color used to draw on the rendering target.
6193c6313
<   CheckError(SDL_SetRenderDrawColor(renderer, c));
---
>   CheckError(SDL_SetRenderDrawColor(renderer, c.r, c.g, c.b, c.a));
6208,6213c6328
<  * @param r the red value used to draw on the rendering target.
<  * @param g the green value used to draw on the rendering target.
<  * @param b the blue value used to draw on the rendering target.
<  * @param a the alpha value used to draw on the rendering target. Use
<  *          Renderer.SetDrawBlendMode to specify how the alpha channel is
<  *          used.
---
>  * @param c the color used to draw on the rendering target.
6225c6340
<   CheckError(SDL_SetRenderDrawColorFloat(renderer, c));
---
>   CheckError(SDL_SetRenderDrawColorFloat(renderer, c.r, c.g, c.b, c.a));
6267,6274c6382
<  * @param r a pointer filled in with the red value used to draw on the
<  *          rendering target.
<  * @param g a pointer filled in with the green value used to draw on the
<  *          rendering target.
<  * @param b a pointer filled in with the blue value used to draw on the
<  *          rendering target.
<  * @param a a pointer filled in with the alpha value used to draw on the
<  *          rendering target; usually `ALPHA_OPAQUE` (255).
---
>  * @returns the color channel values used to draw on the rendering target.
6286c6394,6396
<   static_assert(false, "Not implemented");
---
>   Color c;
>   GetRenderDrawColor(renderer, &c.r, &c.g, &c.b, &c.a);
>   return c;
6333,6340c6443
<  * @param r a pointer filled in with the red value used to draw on the
<  *          rendering target.
<  * @param g a pointer filled in with the green value used to draw on the
<  *          rendering target.
<  * @param b a pointer filled in with the blue value used to draw on the
<  *          rendering target.
<  * @param a a pointer filled in with the alpha value used to draw on the
<  *          rendering target.
---
>  * @returns the color on success.
6352c6455,6457
<   static_assert(false, "Not implemented");
---
>   FColor c;
>   GetRenderDrawColorFloat(renderer, &c.r, &c.g, &c.b, &c.a);
>   return c;
6403c6508
<  * @param scale a pointer filled in with the current color scale value.
---
>  * @return the current color scale value.
6414c6519,6521
<   return CheckError(SDL_GetRenderColorScale(renderer));
---
>   float scale;
>   CheckError(SDL_GetRenderColorScale(renderer, &scale));
>   return scale;
6451c6558
<  * @param blendMode a pointer filled in with the current BlendMode.
---
>  * @return the current BlendMode.
6462c6569,6571
<   return CheckError(SDL_GetRenderDrawBlendMode(renderer));
---
>   BlendMode blendMode;
>   CheckError(SDL_GetRenderDrawBlendMode(renderer, &blendMode));
>   return blendMode;
6498,6499c6607
<  * @param x the x coordinate of the point.
<  * @param y the y coordinate of the point.
---
>  * @param p the x, y coordinate of the point.
6510c6618
<   CheckError(SDL_RenderPoint(renderer, p));
---
>   CheckError(SDL_RenderPoint(renderer, p.x, p.y));
6523d6630
<  * @param count the number of points to draw.
6535c6642
<   CheckError(SDL_RenderPoints(renderer, points));
---
>   CheckError(SDL_RenderPoints(renderer, points.data(), points.size()));
6547,6550c6654,6655
<  * @param x1 the x coordinate of the start point.
<  * @param y1 the y coordinate of the start point.
<  * @param x2 the x coordinate of the end point.
<  * @param y2 the y coordinate of the end point.
---
>  * @param p1 the x,y coordinates of the start point.
>  * @param p2 the x,y coordinates of the end point.
6563c6668
<   CheckError(SDL_RenderLine(renderer, p1, p2));
---
>   CheckError(SDL_RenderLine(renderer, p1.x, p1.y, p2.x, p2.y));
6577d6681
<  * @param count the number of points, drawing count-1 lines.
6588c6692
<   CheckError(SDL_RenderLines(renderer, points));
---
>   CheckError(SDL_RenderLines(renderer, points.data(), points.size()));
6626d6729
<  * @param count the number of rectangles.
6637c6740
<   CheckError(SDL_RenderRects(renderer, rects));
---
>   CheckError(SDL_RenderRects(renderer, rects.data(), rects.size()));
6677d6779
<  * @param count the number of rectangles.
6689c6791
<   CheckError(SDL_RenderFillRects(renderer, rects));
---
>   CheckError(SDL_RenderFillRects(renderer, rects.data(), rects.size()));
6762c6864
<                                  FlipMode flip)
---
>                                  FlipMode flip = FlipMode::SDL_FLIP_NONE)
6999,7002d7100
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
7035d7132
<  * @param num_vertices number of vertices.
7039d7135
<  * @param num_indices number of indices.
7052c7148
<                            std::span<const int> indices)
---
>                            std::span<const int> indices = {})
7054c7150,7155
<   CheckError(SDL_RenderGeometry(renderer, texture, vertices, indices));
---
>   CheckError(SDL_RenderGeometry(renderer,
>                                 texture,
>                                 vertices.data(),
>                                 vertices.size(),
>                                 indices.data(),
>                                 indices.size()));
7169,7172d7269
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
7179,7182d7275
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
7206,7209d7298
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
7246c7335
<   return CheckError(SDL_RenderReadPixels(renderer, rect));
---
>   return Surface{CheckError(SDL_RenderReadPixels(renderer, rect))};
7516a7606
> /// Constant for disabling renderer vsync
7518a7609
> /// Constant for enabling asaptive renderer vsync
7525,7526c7616,7617
<  * @param vsync an int filled with the current vertical refresh sync interval.
<  *              See Renderer.SetVSync() for the meaning of the value.
---
>  * @returns the current vertical refresh sync interval. See Renderer.SetVSync()
>  *          for the meaning of the value.
7537c7628,7630
<   return CheckError(SDL_GetRenderVSync(renderer));
---
>   int vsync;
>   CheckError(SDL_GetRenderVSync(renderer, &vsync));
>   return vsync;
7583,7584c7676
<  * @param x the x coordinate where the top-left corner of the text will draw.
<  * @param y the y coordinate where the top-left corner of the text will draw.
---
>  * @param p the x,y coordinates where the top-left corner of the text will draw.
7599c7691
<   CheckError(SDL_RenderDebugText(renderer, p, str));
---
>   CheckError(SDL_RenderDebugText(renderer, p.x, p.y, str));
7618,7619c7710
<  * @param x the x coordinate where the top-left corner of the text will draw.
<  * @param y the y coordinate where the top-left corner of the text will draw.
---
>  * @param p the x,y coordinate where the top-left corner of the text will draw.
7621c7712
<  * @param ... additional parameters matching % tokens in the `fmt` string, if
---
>  * @param args additional parameters matching % tokens in the `fmt` string, if
7638c7729,7730
<   CheckError(SDL_RenderDebugTextFormat(renderer, p, fmt, args));
---
>   RenderDebugText(
>     renderer, p, std::vformat(fmt, std::make_format_args(args...)));
7646c7738
<   SDL::RenderDebugTextFormat(m_resource, p, fmt, args);
---
>   SDL::RenderDebugTextFormat(m_resource, p, fmt, args...);
7672,7675d7763
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
7681,7684d7768
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
7706,7709d7789
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
7715,7718d7794
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
7764,7765d7839
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
7788,7789d7861
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
7823,7824d7894
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
7838,7841d7907
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
7859,7860d7924
< 
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
7863,7864d7926
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
7890,7891d7951
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
7915,7918d7974
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
7925,7928d7980
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
7955,7958d8006
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
7966,7969d8013
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
7991,7994d8034
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
8000,8003d8039
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
8020,8023d8055
< 
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
