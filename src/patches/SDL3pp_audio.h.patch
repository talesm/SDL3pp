12c12
<  * @defgroup CategoryAudio Category Audio
---
>  * @defgroup CategoryAudio Audio Playback, Recording, and Mixing
196a197,198
> #ifdef SDL3PP_DOC
> 
234a237,238
> #endif // SDL3PP_DOC
> 
286c290
<    * @param signed 1 for signed data, 0 for unsigned data.
---
>    * @param sign 1 for signed data, 0 for unsigned data.
297c301,302
<     : m_audioFormat(SDL_DEFINE_AUDIO_FORMAT(sign, bigendian, flt, size))
---
>     : m_audioFormat(
>         AudioFormatRaw(SDL_DEFINE_AUDIO_FORMAT(sign, bigendian, flt, size)))
313d317
<    * @param x an AudioFormat value.
316c320
<    * @threadsafety It is safe to call this macro from any thread.
---
>    * @threadsafety It is safe to call this function from any thread
318c322
<    * @since This macro is available since SDL 3.2.0.
---
>    * @since This function is available since SDL 3.2.0.
327d330
<    * @param x an AudioFormat value.
330c333
<    * @threadsafety It is safe to call this macro from any thread.
---
>    * @threadsafety It is safe to call this function from any thread.
332c335
<    * @since This macro is available since SDL 3.2.0.
---
>    * @since This function is available since SDL 3.2.0.
341d343
<    * @param x an AudioFormat value.
344c346
<    * @threadsafety It is safe to call this macro from any thread.
---
>    * @threadsafety It is safe to call this function from any thread.
346c348
<    * @since This macro is available since SDL 3.2.0.
---
>    * @since This function is available since SDL 3.2.0.
355d356
<    * @param x an AudioFormat value.
358c359
<    * @threadsafety It is safe to call this macro from any thread.
---
>    * @threadsafety It is safe to call this function from any thread.
360c361
<    * @since This macro is available since SDL 3.2.0.
---
>    * @since This function is available since SDL 3.2.0.
369d369
<    * @param x an AudioFormat value.
372c372
<    * @threadsafety It is safe to call this macro from any thread.
---
>    * @threadsafety It is safe to call this function from any thread.
374c374
<    * @since This macro is available since SDL 3.2.0.
---
>    * @since This function is available since SDL 3.2.0.
383d382
<    * @param x an AudioFormat value.
386c385
<    * @threadsafety It is safe to call this macro from any thread.
---
>    * @threadsafety It is safe to call this function from any thread.
388c387
<    * @since This macro is available since SDL 3.2.0.
---
>    * @since This function is available since SDL 3.2.0.
397d395
<    * @param x an AudioFormat value.
400c398
<    * @threadsafety It is safe to call this macro from any thread.
---
>    * @threadsafety It is safe to call this function from any thread.
402c400
<    * @since This macro is available since SDL 3.2.0.
---
>    * @since This function is available since SDL 3.2.0.
411d408
<    * @param x an AudioFormat value.
414c411
<    * @threadsafety It is safe to call this macro from any thread.
---
>    * @threadsafety It is safe to call this function from any thread.
416c413
<    * @since This macro is available since SDL 3.2.0.
---
>    * @since This function is available since SDL 3.2.0.
447a445,451
> // Unfortunate name clash with SDL_oldnames.h
> #undef AUDIO_U8
> #undef AUDIO_S8
> #undef AUDIO_S16
> #undef AUDIO_S32
> #undef AUDIO_F32
> 
490c494
<  * @param signed 1 for signed data, 0 for unsigned data.
---
>  * @param sign 1 for signed data, 0 for unsigned data.
731,732d734
<  * @param userdata a pointer provided by the app through
<  *                 AudioDevice.SetPostmixCallback, for its own use.
737d738
<  * @param buflen the size of `buffer` in bytes.
819,820d819
<  * @param userdata an opaque pointer provided by the app for their personal
<  *                 use.
1001,1002d999
<    *              AudioDevice.AudioDevice().
<    *
1011,1012d1007
<   constexpr auto operator<=>(AudioDeviceParam other) const = default;
< 
1016,1017c1011,1012
<    * @returns the name of the audio device, or nullptr on failure; call
<    *          GetError() for more information.
---
>    * @returns the name of the audio device on success.
>    * @throws Error on failure.
1050d1044
<    * @param spec on return, will be filled with device details.
1052a1047
>    * @returns the device format details on success.
1070,1071d1064
<    * @param count On output, set to number of channels in the map. Can be
<    * nullptr.
1073,1074c1066
<    *          the current output spec's channels, or nullptr if default. This
<    *          should be freed with free() when it is no longer needed.
---
>    *          the current output spec's channels, or nullptr if default
1277d1268
<    * @param num_streams number streams listed in the `streams` array.
1404d1394
<    * @param userdata app-controlled pointer passed to callback. Can be nullptr.
1451d1440
<    *              or AUDIO_DEVICE_DEFAULT_RECORDING.
1469,1471c1458,1460
<   AudioStreamRef OpenStream(const AudioSpec& spec,
<                             AudioStreamCallback callback,
<                             void* userdata);
---
>   AudioStream OpenStream(OptionalRef<const AudioSpec> spec,
>                          AudioStreamCallback callback,
>                          void* userdata);
1511d1499
<    *              or AUDIO_DEVICE_DEFAULT_RECORDING.
1514,1518c1502
<    *                 playback, or receive new data for recording. Can be
<    * nullptr, in which case the app will need to call AudioStream.PutData or
<    * AudioStream.GetData as necessary.
<    * @param userdata app-controlled pointer passed to callback. Can be nullptr.
<    *                 Ignored if callback is nullptr.
---
>    *                 playback, or receive new data for recording.
1567c1551
< constexpr AudioDeviceRaw AUDIO_DEVICE_DEFAULT_PLAYBACK =
---
> constexpr AudioDeviceID AUDIO_DEVICE_DEFAULT_PLAYBACK =
1579c1563
< constexpr AudioDeviceRaw AUDIO_DEVICE_DEFAULT_RECORDING =
---
> constexpr AudioDeviceID AUDIO_DEVICE_DEFAULT_RECORDING =
1597c1581
<   return SDL_AUDIO_FRAMESIZE(&x);
---
>   return SDL_AUDIO_FRAMESIZE(x);
1751c1735,1787
<   /// Default ctor
---
>   /**
>    * Convenience function for straightforward audio init for the common case.
>    *
>    * If all your app intends to do is provide a single source of PCM audio, this
>    * function allows you to do all your audio setup in a single call.
>    *
>    * This is also intended to be a clean means to migrate apps from SDL2.
>    *
>    * This function will open an audio device, create a stream and bind it.
>    * Unlike other methods of setup, the audio device will be closed when this
>    * stream is destroyed, so the app can treat the returned AudioStream as
>    * the only object needed to manage audio playback.
>    *
>    * Also unlike other functions, the audio device begins paused. This is to map
>    * more closely to SDL2-style behavior, since there is no extra step here to
>    * bind a stream to begin audio flowing. The audio device should be resumed
>    * with `AudioStream.ResumeDevice(stream);`
>    *
>    * This function works with both playback and recording devices.
>    *
>    * The `spec` parameter represents the app's side of the audio stream. That
>    * is, for recording audio, this will be the output format, and for playing
>    * audio, this will be the input format. If spec is nullptr, the system will
>    * choose the format, and the app can use AudioStream.GetFormat() to obtain
>    * this information later.
>    *
>    * If you don't care about opening a specific audio device, you can (and
>    * probably _should_), use AUDIO_DEVICE_DEFAULT_PLAYBACK for playback and
>    * AUDIO_DEVICE_DEFAULT_RECORDING for recording.
>    *
>    * One can optionally provide a callback function; if nullptr, the app is
>    * expected to queue audio data for playback (or unqueue audio data if
>    * capturing). Otherwise, the callback will begin to fire once the device is
>    * unpaused.
>    *
>    * Destroying the returned stream with AudioStream.Destroy will also close
>    * the audio device associated with this stream.
>    *
>    * @param devid an audio device to open, or AUDIO_DEVICE_DEFAULT_PLAYBACK
>    *              or AUDIO_DEVICE_DEFAULT_RECORDING.
>    * @param spec the audio stream's data format. Can be nullptr.
>    * @param callback a callback where the app will provide new data for
>    *                 playback, or receive new data for recording.
>    * @post an audio stream on success.
>    * @throws Error on failure.
>    *
>    * @threadsafety It is safe to call this function from any thread.
>    *
>    * @since This function is available since SDL 3.2.0.
>    *
>    * @sa AudioStream.GetDevice
>    * @sa AudioStream.ResumeDevice
>    */
1800d1835
<    *
1821c1856,1874
<   AudioSpec GetInputFormat() const { static_assert(false, "Not implemented"); }
---
>   /**
>    * Query the current input format of an audio stream.
>    *
>    * @returns the input audio format.
>    * @throws Error on failure.
>    *
>    * @threadsafety It is safe to call this function from any thread, as it holds
>    *               a stream-specific mutex while running.
>    *
>    * @since This function is available since SDL 3.2.0.
>    *
>    * @sa AudioStream.SetFormat
>    */
>   AudioSpec GetInputFormat() const
>   {
>     AudioSpec spec;
>     GetFormat(&spec, nullptr);
>     return spec;
>   }
1823c1876,1894
<   AudioSpec GetOutputFormat() const { static_assert(false, "Not implemented"); }
---
>   /**
>    * Query the current output format of an audio stream.
>    *
>    * @returns the output audio format.
>    * @throws Error on failure.
>    *
>    * @threadsafety It is safe to call this function from any thread, as it holds
>    *               a stream-specific mutex while running.
>    *
>    * @since This function is available since SDL 3.2.0.
>    *
>    * @sa AudioStream.SetFormat
>    */
>   AudioSpec GetOutputFormat() const
>   {
>     AudioSpec spec;
>     GetFormat(nullptr, &spec);
>     return spec;
>   }
1841,1844c1912,1942
<   void SetInputFormat(const AudioSpec& spec)
<   {
<     static_assert(false, "Not implemented");
<   }
---
>   /**
>    * Change the input format of an audio stream.
>    *
>    * Future calls to and AudioStreamRef.GetAvailable and
>    * AudioStreamRef.GetData will reflect the new format, and future calls to
>    * AudioStreamRef.PutData must provide data in the new input formats.
>    *
>    * Data that was previously queued in the stream will still be operated on in
>    * the format that was current when it was added, which is to say you can put
>    * the end of a sound file in one format to a stream, change formats for the
>    * next sound file, and start putting that new data while the previous sound
>    * file is still queued, and everything will still play back correctly.
>    *
>    * If a stream is bound to a device, then the format of the side of the stream
>    * bound to a device cannot be changed (src_spec for recording devices,
>    * dst_spec for playback devices). Attempts to make a change to this side will
>    * be ignored, but this will not report an error. The other side's format can
>    * be changed.
>    *
>    * @param spec the new format of the audio input.
>    * @throws Error on failure.
>    *
>    * @threadsafety It is safe to call this function from any thread, as it holds
>    *               a stream-specific mutex while running.
>    *
>    * @since This function is available since SDL 3.2.0.
>    *
>    * @sa AudioStream.GetFormat
>    * @sa AudioStream.SetFrequencyRatio
>    */
>   void SetInputFormat(const AudioSpec& spec) { SetFormat(spec, std::nullopt); }
1846,1849c1944,1974
<   void SetOutputFormat(const AudioSpec& spec)
<   {
<     static_assert(false, "Not implemented");
<   }
---
>   /**
>    * Change the output format of an audio stream.
>    *
>    * Future calls to and AudioStreamRef.GetAvailable and
>    * AudioStreamRef.GetData will reflect the new format, and future calls to
>    * AudioStreamRef.PutData must provide data in the new input formats.
>    *
>    * Data that was previously queued in the stream will still be operated on in
>    * the format that was current when it was added, which is to say you can put
>    * the end of a sound file in one format to a stream, change formats for the
>    * next sound file, and start putting that new data while the previous sound
>    * file is still queued, and everything will still play back correctly.
>    *
>    * If a stream is bound to a device, then the format of the side of the stream
>    * bound to a device cannot be changed (src_spec for recording devices,
>    * dst_spec for playback devices). Attempts to make a change to this side will
>    * be ignored, but this will not report an error. The other side's format can
>    * be changed.
>    *
>    * @param spec the new format of the audio output.
>    * @throws Error on failure.
>    *
>    * @threadsafety It is safe to call this function from any thread, as it holds
>    *               a stream-specific mutex while running.
>    *
>    * @since This function is available since SDL 3.2.0.
>    *
>    * @sa AudioStream.GetFormat
>    * @sa AudioStream.SetFrequencyRatio
>    */
>   void SetOutputFormat(const AudioSpec& spec) { SetFormat(std::nullopt, spec); }
1980,1981d2104
<    * @param count On output, set to number of channels in the map. Can be
<    * nullptr.
1983,1984c2106
<    *          the current output spec's channels, or nullptr if default. This
<    *          should be freed with free() when it is no longer needed.
---
>    *          the current output spec's channels, or nullptr if default.
2004,2005d2125
<    * @param count On output, set to number of channels in the map. Can be
<    * nullptr.
2007,2008c2127
<    *          the current output spec's channels, or nullptr if default. This
<    *          should be freed with free() when it is no longer needed.
---
>    *          the current output spec's channels, or nullptr if default.
2063d2181
<    * @param count The number of channels in the map.
2119d2236
<    * @param count The number of channels in the map.
2145d2261
<    * @param len the number of bytes to write to the stream.
2174d2289
<    * @param len the maximum number of bytes to fill.
2468,2469d2582
<    * @param userdata an opaque pointer provided to the callback for its own
<    *                 personal use.
2562,2563d2674
<    * @param userdata an opaque pointer provided to the callback for its own
<    *                 personal use.
2718,2722c2829,2830
<  * @param count a pointer filled in with the number of devices returned, may
<  *              be nullptr.
<  * @returns a 0 terminated array of device instance IDs or nullptr on error;
<  * call GetError() for more information. This should be freed with free() when
<  * it is no longer needed.
---
>  * @returns a 0 terminated array of device instance IDs on success.
>  * @throws Error on failure.
2733c2841,2844
<   return SDL_GetAudioPlaybackDevices();
---
>   int count;
>   auto data = CheckError(SDL_GetAudioPlaybackDevices(&count));
>   return OwnArray<AudioDeviceRef>{reinterpret_cast<AudioDeviceRef*>(data),
>                                   size_t(count)};
2750,2754c2861,2862
<  * @param count a pointer filled in with the number of devices returned, may
<  *              be nullptr.
<  * @returns a 0 terminated array of device instance IDs, or nullptr on failure;
<  *          call GetError() for more information. This should be freed
<  *          with free() when it is no longer needed.
---
>  * @returns a 0 terminated array of device instance IDs on success.
>  * @throws Error on failure.
2765c2873,2876
<   return SDL_GetAudioRecordingDevices();
---
>   int count;
>   auto data = CheckError(SDL_GetAudioRecordingDevices(&count));
>   return OwnArray<AudioDeviceRef>{reinterpret_cast<AudioDeviceRef*>(data),
>                                   size_t(count)};
2772,2773c2883,2884
<  * @returns the name of the audio device, or nullptr on failure; call
<  *          GetError() for more information.
---
>  * @returns the name of the audio device on success.
>  * @throws Error on failure.
2784c2895
<   return SDL_GetAudioDeviceName(devid);
---
>   return CheckError(SDL_GetAudioDeviceName(devid));
2815d2925
<  * @param spec on return, will be filled with device details.
2827c2937,2939
<   return CheckError(SDL_GetAudioDeviceFormat(devid, sample_frames));
---
>   AudioSpec spec;
>   CheckError(SDL_GetAudioDeviceFormat(devid, &spec, sample_frames));
>   return spec;
2845d2956
<  * @param count On output, set to number of channels in the map. Can be nullptr.
2847,2848c2958
<  *          the current output spec's channels, or nullptr if default. This
<  *          should be freed with free() when it is no longer needed.
---
>  *          the current output spec's channels, or nullptr if default
2858c2968,2970
<   return SDL_GetAudioDeviceChannelMap(devid);
---
>   int count;
>   auto data = SDL_GetAudioDeviceChannelMap(devid, &count);
>   return OwnArray<int>{data, size_t(count)};
2941c3053
<                                    const AudioSpec& spec)
---
>                                    OptionalRef<const AudioSpec> spec)
3223d3334
<  * @param num_streams number streams listed in the `streams` array.
3237c3348,3351
<   CheckError(SDL_BindAudioStreams(devid, streams));
---
>   CheckError(SDL_BindAudioStreams(
>     devid,
>     reinterpret_cast<SDL_AudioStream* const*>(streams.data()),
>     streams.size()));
3284d3397
<  * @param num_streams number streams listed in the `streams` array.
3294c3407,3408
<   SDL_UnbindAudioStreams(streams);
---
>   SDL_UnbindAudioStreams(
>     reinterpret_cast<SDL_AudioStream* const*>(streams.data()), streams.size());
3339c3453
<   return SDL_GetAudioStreamDevice(stream);
---
>   return {SDL_GetAudioStreamDevice(stream)};
3367,3368c3481,3482
< inline AudioStream CreateAudioStream(const AudioSpec& src_spec,
<                                      const AudioSpec& dst_spec)
---
> inline AudioStream CreateAudioStream(OptionalRef<const AudioSpec> src_spec,
>                                      OptionalRef<const AudioSpec> dst_spec)
3386c3500
<   return CheckError(SDL_GetAudioStreamProperties(stream));
---
>   return {CheckError(SDL_GetAudioStreamProperties(stream))};
3599d3712
<  * @param count On output, set to number of channels in the map. Can be nullptr.
3601,3602c3714
<  *          the current output spec's channels, or nullptr if default. This
<  *          should be freed with free() when it is no longer needed.
---
>  *          the current output spec's channels, or nullptr if default.
3613c3725,3728
<   return SDL_GetAudioStreamInputChannelMap(stream);
---
>   int count;
>   auto data = SDL_GetAudioStreamInputChannelMap(stream, &count);
>   if (!data) return {};
>   return OwnArray<int>{data, size_t(count)};
3631d3745
<  * @param count On output, set to number of channels in the map. Can be nullptr.
3633,3634c3747
<  *          the current output spec's channels, or nullptr if default. This
<  *          should be freed with free() when it is no longer needed.
---
>  *          the current output spec's channels, or nullptr if default.
3645c3758,3761
<   return SDL_GetAudioStreamOutputChannelMap(stream);
---
>   int count;
>   auto data = SDL_GetAudioStreamOutputChannelMap(stream, &count);
>   if (!data) return {};
>   return OwnArray<int>{data, size_t(count)};
3698d3813
<  * @param count The number of channels in the map.
3713c3828,3829
<   CheckError(SDL_SetAudioStreamInputChannelMap(stream, chmap));
---
>   CheckError(
>     SDL_SetAudioStreamInputChannelMap(stream, chmap.data(), chmap.size()));
3764d3879
<  * @param count The number of channels in the map.
3779c3894,3895
<   CheckError(SDL_SetAudioStreamOutputChannelMap(stream, chmap));
---
>   CheckError(
>     SDL_SetAudioStreamOutputChannelMap(stream, chmap.data(), chmap.size()));
3800d3915
<  * @param len the number of bytes to write to the stream.
3838d3952
<  * @param len the maximum number of bytes to fill.
4179a4294
>   KeyValueCallbackWrapper<SDL_AudioStream*, AudioStreamCB, 0>::release(stream);
4216,4217d4330
<  * @param userdata an opaque pointer provided to the callback for its own
<  *                 personal use.
4229c4342,4354
<   static_assert(false, "Not implemented");
---
>   using Wrapper = KeyValueCallbackWrapper<SDL_AudioStream*, AudioStreamCB, 0>;
>   if (!SDL_SetAudioStreamGetCallback(
>         stream,
>         [](void* userdata,
>            SDL_AudioStream* stream,
>            int additional_amount,
>            int total_amount) {
>           Wrapper::Call(userdata, {stream}, additional_amount, total_amount);
>         },
>         Wrapper::Wrap(stream, std::move(callback)))) {
>     Wrapper::release(stream);
>     throw Error{};
>   }
4292a4418
>   KeyValueCallbackWrapper<SDL_AudioStream*, AudioStreamCB, 1>::release(stream);
4332,4333d4457
<  * @param userdata an opaque pointer provided to the callback for its own
<  *                 personal use.
4345c4469,4481
<   static_assert(false, "Not implemented");
---
>   using Wrapper = KeyValueCallbackWrapper<SDL_AudioStream*, AudioStreamCB, 1>;
>   if (!SDL_SetAudioStreamPutCallback(
>         stream,
>         [](void* userdata,
>            SDL_AudioStream* stream,
>            int additional_amount,
>            int total_amount) {
>           Wrapper::Call(userdata, {stream}, additional_amount, total_amount);
>         },
>         Wrapper::Wrap(stream, std::move(callback)))) {
>     Wrapper::release(stream);
>     throw Error{};
>   }
4444,4446c4580,4582
<                                          const AudioSpec& spec,
<                                          AudioStreamCallback callback,
<                                          void* userdata)
---
>                                          OptionalRef<const AudioSpec> spec,
>                                          AudioStreamCallback callback = nullptr,
>                                          void* userdata = nullptr)
4493,4498c4629
<  *                 playback, or receive new data for recording. Can be nullptr,
<  *                 in which case the app will need to call
<  *                 AudioStream.PutData or AudioStream.GetData as
<  *                 necessary.
<  * @param userdata app-controlled pointer passed to callback. Can be nullptr.
<  *                 Ignored if callback is nullptr.
---
>  *                 playback, or receive new data for recording.
4516,4518c4647,4649
< inline AudioStreamRef AudioDevice::OpenStream(const AudioSpec& spec,
<                                               AudioStreamCallback callback,
<                                               void* userdata)
---
> inline AudioStream AudioDevice::OpenStream(OptionalRef<const AudioSpec> spec,
>                                            AudioStreamCallback callback,
>                                            void* userdata)
4526c4657
<   return SDL::OpenAudioDeviceStream(m_resource, spec, callback);
---
>   return AudioStream(m_resource, spec, callback);
4531a4663
>   : AudioStream(devid, spec)
4532a4665,4669
>   if (IsAudioDevicePlayback(devid)) {
>     SetGetCallback(std::move(callback));
>   } else {
>     SetPutCallback(std::move(callback));
>   }
4589a4727
>   KeyValueCallbackWrapper<AudioDeviceParam, AudioPostmixCB>::release(devid);
4637d4774
<  * @param userdata app-controlled pointer passed to callback. Can be nullptr.
4647c4784,4797
<   static_assert(false, "Not implemented");
---
>   using Wrapper = KeyValueCallbackWrapper<AudioDeviceParam, AudioPostmixCB>;
>   if (!SDL_SetAudioPostmixCallback(
>         devid,
>         [](void* userdata,
>            const SDL_AudioSpec* spec,
>            float* buffer,
>            int buflen) {
>           Wrapper::Call(
>             userdata, *spec, std::span<float>(buffer, size_t(buflen)));
>         },
>         Wrapper::Wrap(devid, std::move(callback)))) {
>     Wrapper::release(devid);
>     throw Error{};
>   }
4701,4702c4851,4852
<  * ```c
<  * LoadWAV(IOStream.FromFile("sample.wav", "rb"), true, &spec, &buf, &len);
---
>  * ```cpp
>  * LoadWAV(IOStream.FromFile("sample.wav", "rb"), spec);
4708,4709c4858,4859
<  * ```c
<  * LoadWAV("sample.wav", &spec, &buf, &len);
---
>  * ```cpp
>  * LoadWAV("sample.wav", &spec);
4713,4714d4862
<  * @param closeio if true, calls IOStream.Close() on `src` before returning,
<  * even in the case of an error.
4717,4720c4865,4866
<  * @param audio_buf a pointer filled with the audio data, allocated by the
<  *                  function.
<  * @param audio_len a pointer filled with the length of the audio data buffer
<  *                  in bytes.
---
>  * @param closeio if true, calls IOStream.Close() on `src` before returning,
>  *                even in the case of an error.
4723,4728c4869,4870
<  *          This function returns false if the .WAV file cannot be opened,
<  *          uses an unknown data format, or is corrupt; call GetError()
<  *          for more information.
<  *
<  *          When the application is done with the data returned in
<  *          `audio_buf`, it should call free() to dispose of it.
---
>  * This function throws if the .WAV file cannot be opened, uses an unknown data
>  * format, or is corrupt; call GetError() for more information.
4734d4875
<  * @sa free
4741c4882,4885
<   return CheckError(SDL_LoadWAV_IO(src, spec, closeio));
---
>   Uint8* buf;
>   Uint32 len;
>   if (!SDL_LoadWAV_IO(src, closeio, spec, &buf, &len)) return {};
>   return OwnArray<Uint8>{buf, size_t(len)};
4756,4759d4899
<  * @param audio_buf a pointer filled with the audio data, allocated by the
<  *                  function.
<  * @param audio_len a pointer filled with the length of the audio data buffer
<  *                  in bytes.
4762,4767c4902,4903
<  *          This function returns false if the .WAV file cannot be opened,
<  *          uses an unknown data format, or is corrupt; call GetError()
<  *          for more information.
<  *
<  *          When the application is done with the data returned in
<  *          `audio_buf`, it should call free() to dispose of it.
---
>  * This function throws if the .WAV file cannot be opened, uses an unknown data
>  * format, or is corrupt,
4773d4908
<  * @sa free
4778c4913,4916
<   return CheckError(SDL_LoadWAV(path, spec));
---
>   Uint8* buf;
>   Uint32 len;
>   if (!SDL_LoadWAV(path, spec, &buf, &len)) return {};
>   return OwnArray<Uint8>{buf, size_t(len)};
4805d4942
<  * @param len the length of the audio buffer in bytes.
4819c4956,4957
<   CheckError(SDL_MixAudio(dst, src.data(), src.size_bytes(), format, volume));
---
>   CheckError(
>     SDL_MixAudio(dst, src.data_as<Uint8>(), format, src.size_bytes(), volume));
4846d4983
<  * @param len the length of the audio buffer in bytes.
4860c4997,5003
<   static_assert(false, "Not implemented");
---
>   if (dst.size_bytes() < src.size_bytes()) {
>     MixAudio(dst.data_as<Uint8>(),
>              SourceBytes{src.data(), dst.size_bytes()},
>              format,
>              volume);
>   } else
>     MixAudio(dst.data_as<Uint8>(), src, format, volume);
4878d5020
<  * @param src_len the len of src_data.
4880,4883d5021
<  * @param dst_data will be filled with a pointer to converted audio data,
<  *                 which should be freed with free(). On error, it will be
<  *                 nullptr.
<  * @param dst_len will be filled with the len of dst_data.
4894,4895c5032,5040
<   return CheckError(SDL_ConvertAudioSamples(
<     &src_spec, src_data.data(), src_data.size_bytes(), &dst_spec));
---
>   Uint8* buf;
>   int len;
>   CheckError(SDL_ConvertAudioSamples(&src_spec,
>                                      src_data.data_as<Uint8>(),
>                                      src_data.size_bytes(),
>                                      &dst_spec,
>                                      &buf,
>                                      &len));
>   return OwnArray<Uint8>{buf, size_t(len)};
