--- src/generated/SDL3pp_events.h
+++ include/SDL3pp/SDL3pp_events.h
@@ -8,7 +8,7 @@
 namespace SDL {
 
 /**
- * @defgroup CategoryEvents Category Events
+ * @defgroup CategoryEvents Event Handling
  *
  * Event queue management.
  *
@@ -39,6 +39,13 @@
  */
 
 /**
+ * @defgroup EventTypes Event Types
+ *
+ * Event types for Event.
+ * @{
+ */
+
+/**
  * The types of events that can be delivered.
  *
  * @since This enum is available since SDL 3.2.0.
@@ -442,6 +449,8 @@
 constexpr EventType EVENT_ENUM_PADDING =
   SDL_EVENT_ENUM_PADDING; ///< ENUM_PADDING
 
+/// @}
+
 /**
  * Fields shared by every event
  *
@@ -811,6 +820,12 @@
 inline void PumpEvents() { SDL_PumpEvents(); }
 
 /**
+ * @name EventActions
+ * The type of action to request from PeepEvents().
+ * @{
+ */
+
+/**
  * The type of action to request from PeepEvents().
  *
  * @since This enum is available since SDL 3.2.0.
@@ -826,11 +841,15 @@
 /// Retrieve/remove events from the front of the queue.
 constexpr EventAction GETEVENT = SDL_GETEVENT;
 
+/// @}
+
 /**
  * Check the event queue for messages and optionally return them.
  *
  * `action` may be any of the following:
  *
+ * ## remarks
+ *
  * - `ADDEVENT`: up to `numevents` events will be added to the back of the event
  *   queue.
  * - `PEEKEVENT`: `numevents` events at the front of the event queue, within the
@@ -870,8 +889,8 @@
 inline int PeepEvents(Event* events,
                       int numevents,
                       EventAction action,
-                      Uint32 minType,
-                      Uint32 maxType)
+                      Uint32 minType = EVENT_FIRST,
+                      Uint32 maxType = EVENT_LAST)
 {
   return SDL_PeepEvents(events, numevents, action, minType, maxType);
 }
@@ -911,7 +930,7 @@
  *
  * @sa HasEvents
  */
-inline bool HasEvents(Uint32 minType, Uint32 maxType)
+inline bool HasEvents(Uint32 minType = EVENT_FIRST, Uint32 maxType = EVENT_LAST)
 {
   return SDL_HasEvents(minType, maxType);
 }
@@ -968,7 +987,8 @@
  *
  * @sa FlushEvent
  */
-inline void FlushEvents(Uint32 minType, Uint32 maxType)
+inline void FlushEvents(Uint32 minType = EVENT_FIRST,
+                        Uint32 maxType = EVENT_LAST)
 {
   SDL_FlushEvents(minType, maxType);
 }
@@ -994,10 +1014,10 @@
  * The common practice is to fully process the event queue once every frame,
  * usually as a first step before updating the game's state:
  *
- * ```c
+ * ```cpp
  * while (game_is_still_running) {
- *     Event event;
- *     while (PollEvent(&event)) {  // poll until all events are handled!
+ *     SDL::Event event;
+ *     while (SDL::PollEvent(&event)) {  // poll until all events are handled!
  *         // decide what to do with this event.
  *     }
  *
@@ -1022,13 +1042,7 @@
 /**
  * Poll for currently pending events.
  *
- * If `event` is not nullptr, the next event is removed from the queue and
- * stored in the Event structure pointed to by `event`. The 1 returned refers to
- * this event, immediately stored in the SDL Event structure -- not an event to
- * follow.
- *
- * If `event` is nullptr, it simply returns 1 if there is an event in the queue,
- * but will not remove it from the queue.
+ * The next event is removed from the queue and returned.
  *
  * As this function may implicitly call PumpEvents(), you can only call this
  * function in the thread that set the video mode.
@@ -1042,8 +1056,7 @@
  *
  * ```c
  * while (game_is_still_running) {
- *     Event event;
- *     while (PollEvent(&event)) {  // poll until all events are handled!
+ *     while (auto event = SDL::PollEvent()) {
  *         // decide what to do with this event.
  *     }
  *
@@ -1051,9 +1064,8 @@
  * }
  * ```
  *
- * @param event the Event structure to be filled with the next event from the
- *              queue, or nullptr.
- * @returns true if this got an event or false if there are none available.
+ * @returns Event if this got an event or std::nullopt if there are none
+ *          available.
  *
  * @threadsafety This function should only be called on the main thread.
  *
@@ -1065,7 +1077,8 @@
  */
 inline std::optional<Event> PollEvent()
 {
-  static_assert(false, "Not implemented");
+  if (Event event; PollEvent(&event)) return event;
+  return std::nullopt;
 }
 
 /**
@@ -1094,14 +1107,13 @@
 /**
  * Wait indefinitely for the next available event.
  *
- * If `event` is not nullptr, the next event is removed from the queue and
- * stored in the Event structure pointed to by `event`.
+ * The next event is removed from the queue and returned.
  *
  * As this function may implicitly call PumpEvents(), you can only call this
  * function in the thread that initialized the video subsystem.
  *
- * @param event the Event structure to be filled in with the next event from the
- *              queue, or nullptr.
+ * @returns Event on success.
+ *
  * @throws Error on failure.
  *
  * @threadsafety This function should only be called on the main thread.
@@ -1112,7 +1124,12 @@
  * @sa PushEvent
  * @sa WaitEventTimeout
  */
-inline Event WaitEvent() { static_assert(false, "Not implemented"); }
+inline Event WaitEvent()
+{
+  Event event;
+  WaitEvent(&event);
+  return event;
+}
 
 /**
  * Wait until the specified timeout (in milliseconds) for the next available
@@ -1151,21 +1168,16 @@
  * Wait until the specified timeout (in milliseconds) for the next available
  * event.
  *
- * If `event` is not nullptr, the next event is removed from the queue and
- * stored in the Event structure pointed to by `event`.
- *
  * As this function may implicitly call PumpEvents(), you can only call this
  * function in the thread that initialized the video subsystem.
  *
  * The timeout is not guaranteed, the actual wait time could be longer due to
  * system scheduling.
  *
- * @param event the Event structure to be filled in with the next event from the
- *              queue, or nullptr.
  * @param timeoutMS the maximum number of milliseconds to wait for the next
  *                  available event.
- * @returns true if this got an event or false if the timeout elapsed without
- *          any events available.
+ * @returns the Event if this got an event or std::nullopt if the timeout
+ * elapsed without any events available.
  *
  * @threadsafety This function should only be called on the main thread.
  *
@@ -1177,7 +1189,8 @@
  */
 inline std::optional<Event> WaitEventTimeout(Sint32 timeoutMS)
 {
-  static_assert(false, "Not implemented");
+  if (Event event; WaitEventTimeout(&event, timeoutMS)) return event;
+  return std::nullopt;
 }
 
 /**
@@ -1195,8 +1208,8 @@
  *
  * @param event the Event structure to be filled in with the next event from the
  *              queue, or nullptr.
- * @param timeoutMS the maximum number of milliseconds to wait for the next
- *                  available event.
+ * @param timeoutDuration the duration to wait for the next available event,
+ *                        with millisecond precision
  * @returns true if this got an event or false if the timeout elapsed without
  *          any events available.
  *
@@ -1211,15 +1224,12 @@
 inline bool WaitEventTimeout(Event* event,
                              std::chrono::milliseconds timeoutDuration)
 {
-  static_assert(false, "Not implemented");
+  return WaitEventTimeout(event, std::max(timeoutDuration.count(), 1l));
 }
 
 /**
- * Wait until the specified timeout (in milliseconds) for the next available
- * event.
- *
- * If `event` is not nullptr, the next event is removed from the queue and
- * stored in the Event structure pointed to by `event`.
+ * Wait until the specified timeout (with milliseconds precision) for the next
+ * available event.
  *
  * As this function may implicitly call PumpEvents(), you can only call this
  * function in the thread that initialized the video subsystem.
@@ -1227,12 +1237,10 @@
  * The timeout is not guaranteed, the actual wait time could be longer due to
  * system scheduling.
  *
- * @param event the Event structure to be filled in with the next event from the
- *              queue, or nullptr.
- * @param timeoutMS the maximum number of milliseconds to wait for the next
- *                  available event.
- * @returns true if this got an event or false if the timeout elapsed without
- *          any events available.
+ * @param timeoutDuration the duration to wait for the next available event,
+ *                        with millisecond precision.
+ * @returns the Event if this got an event or std::nullopt if the timeout
+ *          elapsed without any events available.
  *
  * @threadsafety This function should only be called on the main thread.
  *
@@ -1245,7 +1253,8 @@
 inline std::optional<Event> WaitEventTimeout(
   std::chrono::milliseconds timeoutDuration)
 {
-  static_assert(false, "Not implemented");
+  if (Event event; WaitEventTimeout(&event, timeoutDuration)) return event;
+  return std::nullopt;
 }
 
 /**
@@ -1312,7 +1321,7 @@
  */
 inline void PushEvent(const Event& event)
 {
-  static_assert(false, "Not implemented");
+  PushEvent(const_cast<Event*>(&event));
 }
 
 /**
@@ -1336,7 +1345,7 @@
 using EventFilter = SDL_EventFilter;
 
 /**
- * A function pointer used for callbacks that watch the event queue.
+ * A std::function used for callbacks that watch the event queue.
  *
  * @param event the event that triggered the callback.
  * @returns true to permit event to be added to the queue, and false to disallow
@@ -1348,13 +1357,21 @@
  *
  * @since This datatype is available since SDL 3.2.0.
  *
- * @sa SetEventFilter
- * @sa AddEventWatch
+ * @cat listener-callback
+ *
+ * @sa listener-callback
+ * @sa SetEventFilter()
+ * @sa AddEventWatch()
  * @sa EventFilter
  */
 using EventFilterCB = std::function<bool(const Event&)>;
 
-/// Handle returned by AddEventWatch()
+/**
+ * Handle returned by AddEventWatch(EventFilterCB)
+ *
+ * This can be used later to remove the event filter
+ * RemoveEventWatch(EventFilterHandle).
+ */
 struct EventWatchHandle : CallbackHandle
 {
   using CallbackHandle::CallbackHandle;
@@ -1400,7 +1417,8 @@
  */
 inline void SetEventFilter(EventFilter filter, void* userdata)
 {
-  SDL_SetEventFilter(filter, userdata);
+  UniqueCallbackWrapper<EventFilterCB>::erase();
+  return SDL_SetEventFilter(filter, userdata);
 }
 
 /**
@@ -1428,13 +1446,15 @@
  * Note: Events pushed onto the queue with PushEvent() get passed through the
  * event filter, but events pushed onto the queue with PeepEvents() do not.
  *
- * @param filter an EventFilter function to call when an event happens.
- * @param userdata a pointer that is passed to `filter`.
+ * @param filter an EventFilterCB function to call when an event happens.
  *
  * @threadsafety It is safe to call this function from any thread.
  *
  * @since This function is available since SDL 3.2.0.
  *
+ * @cat listener-callback
+ *
+ * @sa listener-callback
  * @sa AddEventWatch
  * @sa SetEventEnabled
  * @sa GetEventFilter
@@ -1443,7 +1463,12 @@
  */
 inline void SetEventFilter(EventFilterCB filter = {})
 {
-  static_assert(false, "Not implemented");
+  using Wrapper = UniqueCallbackWrapper<EventFilterCB>;
+  SDL_SetEventFilter(
+    [](void* userdata, SDL_Event* event) {
+      return Wrapper::Call(userdata, *event);
+    },
+    Wrapper::Wrap(std::move(filter)));
 }
 
 /**
@@ -1474,25 +1499,40 @@
  * This function can be used to "chain" filters, by saving the existing filter
  * before replacing it with a function that will call that saved filter.
  *
- * @param filter the current callback function will be stored here.
- * @param userdata the pointer that is passed to the current event filter will
- *                 be stored here.
- * @throws Error on failure.
+ * @returns EventFilterCB on success or false if there is no event filter
+ * set.
  *
  * @threadsafety It is safe to call this function from any thread.
  *
  * @since This function is available since SDL 3.2.0.
  *
+ * @cat listener-callback
+ *
+ * @sa listener-callback
  * @sa SetEventFilter
  */
 inline EventFilterCB GetEventFilter()
 {
-  static_assert(false, "Not implemented");
+  using Wrapper = UniqueCallbackWrapper<EventFilterCB>;
+
+  EventFilter filter;
+  void* userdata;
+  GetEventFilter(&filter, &userdata);
+  if (!userdata)
+    return [filter](const Event& event) {
+      return filter(nullptr, const_cast<Event*>(&event));
+    };
+  if (auto cb = Wrapper::at(userdata)) return cb;
+  return [filter, userdata](const Event& event) {
+    return filter(userdata, const_cast<Event*>(&event));
+  };
 }
 
+/// @private
 inline bool EventWatchAuxCallback(void* userdata, Event* event)
 {
-  static_assert(false, "Not implemented");
+  auto& f = *static_cast<EventFilterCB*>(userdata);
+  return f(*event);
 }
 
 /**
@@ -1547,20 +1587,30 @@
  * set with SetEventFilter(), nor for events posted by the user through
  * PeepEvents().
  *
- * @param filter an EventFilter function to call when an event happens.
- * @param userdata a pointer that is passed to `filter`.
+ * @param filter an EventFilterCB to call when an event happens.
+ * @returns a handle that can be used on RemoveEventWatch(EventFilterHandle) on
+ *          success.
  * @throws Error on failure.
  *
  * @threadsafety It is safe to call this function from any thread.
  *
  * @since This function is available since SDL 3.2.0.
  *
+ * @cat listener-callback
+ *
+ * @sa listener-callback
  * @sa RemoveEventWatch
  * @sa SetEventFilter
  */
 inline EventWatchHandle AddEventWatch(EventFilterCB filter)
 {
-  static_assert(false, "Not implemented");
+  using Wrapper = CallbackWrapper<EventFilterCB>;
+  auto cb = Wrapper::Wrap(std::move(filter));
+  if (!SDL_AddEventWatch(&EventWatchAuxCallback, &cb)) {
+    Wrapper::release(cb);
+    throw Error{};
+  }
+  return EventWatchHandle{cb};
 }
 
 /**
@@ -1586,21 +1636,21 @@
 /**
  * Remove an event watch callback added with AddEventWatch().
  *
- * This function takes the same input as AddEventWatch() to identify and delete
- * the corresponding callback.
- *
- * @param filter the function originally passed to AddEventWatch().
- * @param userdata the pointer originally passed to AddEventWatch().
+ * @param handle the handle returned by SDL_AddEventWatch(EventFilterCB).
  *
  * @threadsafety It is safe to call this function from any thread.
  *
  * @since This function is available since SDL 3.2.0.
  *
- * @sa AddEventWatch
+ * @cat listener-callback
+ *
+ * @sa listener-callback
+ * @sa AddEventWatch(EventFilterCB)
  */
 inline void RemoveEventWatch(EventWatchHandle handle)
 {
-  static_assert(false, "Not implemented");
+  using Wrapper = CallbackWrapper<EventFilterCB>;
+  Wrapper::release(handle);
 }
 
 /**
@@ -1635,18 +1685,25 @@
  * filter until this function returns.
  *
  * @param filter the EventFilter function to call when an event happens.
- * @param userdata a pointer that is passed to `filter`.
  *
  * @threadsafety It is safe to call this function from any thread.
  *
  * @since This function is available since SDL 3.2.0.
  *
+ * @cat immediate-callback
+ *
+ * @sa immediate-callback
  * @sa GetEventFilter
  * @sa SetEventFilter
  */
 inline void FilterEvents(EventFilterCB filter)
 {
-  static_assert(false, "Not implemented");
+  return FilterEvents(
+    [](void* userdata, SDL_Event* event) {
+      auto& f = *static_cast<EventFilterCB*>(userdata);
+      return f(*event);
+    },
+    &filter);
 }
 
 /**
@@ -1716,7 +1773,7 @@
  */
 inline WindowRef GetWindowFromEvent(const Event& event)
 {
-  return CheckError(SDL_GetWindowFromEvent(&event));
+  return {CheckError(SDL_GetWindowFromEvent(&event))};
 }
 
 /// @}
