11c11
<  * @defgroup CategoryEvents Category Events
---
>  * @defgroup CategoryEvents Event Handling
41a42,48
>  * @defgroup EventTypes Event Types
>  *
>  * Event types for Event.
>  * @{
>  */
> 
> /**
265,268d271
< #endif // SDL_VERSION_ATLEAST(3, 3, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 3, 0)
< 
371,374d373
< #endif // SDL_VERSION_ATLEAST(3, 3, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 3, 0)
< 
378,381d376
< #endif // SDL_VERSION_ATLEAST(3, 3, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 3, 0)
< 
488a484,485
> /// @}
> 
864a862,867
>  * @name EventActions
>  * The type of action to request from PeepEvents().
>  * @{
>  */
> 
> /**
879a883,884
> /// @}
> 
884a890,891
>  * ## remarks
>  *
1049c1056
<  * ```c
---
>  * ```cpp
1051,1052c1058,1059
<  *     Event event;
<  *     while (PollEvent(&event)) {  // poll until all events are handled!
---
>  *     SDL::Event event;
>  *     while (SDL::PollEvent(&event)) {  // poll until all events are handled!
1084,1090c1091
<  * If `event` is not nullptr, the next event is removed from the queue and
<  * stored in the Event structure pointed to by `event`. The 1 returned refers to
<  * this event, immediately stored in the SDL Event structure -- not an event to
<  * follow.
<  *
<  * If `event` is nullptr, it simply returns 1 if there is an event in the queue,
<  * but will not remove it from the queue.
---
>  * The next event is removed from the queue and returned.
1104,1105c1105
<  *     Event event;
<  *     while (PollEvent(&event)) {  // poll until all events are handled!
---
>  *     while (auto event = SDL::PollEvent()) {
1120,1122c1120,1121
<  * @param event the Event structure to be filled with the next event from the
<  *              queue, or nullptr.
<  * @returns true if this got an event or false if there are none available.
---
>  * @returns Event if this got an event or std::nullopt if there are none
>  *          available.
1134c1133,1134
<   static_assert(false, "Not implemented");
---
>   if (Event event; PollEvent(&event)) return event;
>   return std::nullopt;
1163,1164c1163
<  * If `event` is not nullptr, the next event is removed from the queue and
<  * stored in the Event structure pointed to by `event`.
---
>  * The next event is removed from the queue and returned.
1169,1170c1168,1169
<  * @param event the Event structure to be filled in with the next event from the
<  *              queue, or nullptr.
---
>  * @returns Event on success.
>  *
1181c1180,1185
< inline Event WaitEvent() { static_assert(false, "Not implemented"); }
---
> inline Event WaitEvent()
> {
>   Event event;
>   WaitEvent(&event);
>   return event;
> }
1220,1222d1223
<  * If `event` is not nullptr, the next event is removed from the queue and
<  * stored in the Event structure pointed to by `event`.
<  *
1229,1230d1229
<  * @param event the Event structure to be filled in with the next event from the
<  *              queue, or nullptr.
1233,1234c1232,1233
<  * @returns true if this got an event or false if the timeout elapsed without
<  *          any events available.
---
>  * @returns the Event if this got an event or std::nullopt if the timeout
>  * elapsed without any events available.
1246c1245,1246
<   static_assert(false, "Not implemented");
---
>   if (Event event; WaitEventTimeout(&event, timeoutMS)) return event;
>   return std::nullopt;
1264,1265c1264,1265
<  * @param timeoutMS the maximum number of milliseconds to wait for the next
<  *                  available event.
---
>  * @param timeoutDuration the duration to wait for the next available event,
>  *                        with millisecond precision
1280c1280
<   static_assert(false, "Not implemented");
---
>   return WaitEventTimeout(event, std::max(timeoutDuration.count(), 1l));
1287,1288c1287
<  * If `event` is not nullptr, the next event is removed from the queue and
<  * stored in the Event structure pointed to by `event`.
---
>  * The next event is removed from the queue and returned.
1296,1301c1295,1298
<  * @param event the Event structure to be filled in with the next event from the
<  *              queue, or nullptr.
<  * @param timeoutMS the maximum number of milliseconds to wait for the next
<  *                  available event.
<  * @returns true if this got an event or false if the timeout elapsed without
<  *          any events available.
---
>  * @param timeoutDuration the duration to wait for the next available event,
>  *                        with millisecond precision.
>  * @returns the Event if this got an event or std::nullopt if the timeout
>  *          elapsed without any events available.
1314c1311,1312
<   static_assert(false, "Not implemented");
---
>   if (Event event; WaitEventTimeout(&event, timeoutDuration)) return event;
>   return std::nullopt;
1381c1379
<   static_assert(false, "Not implemented");
---
>   PushEvent(const_cast<Event*>(&event));
1405c1403
<  * A function pointer used for callbacks that watch the event queue.
---
>  * A std::function used for callbacks that watch the event queue.
1416a1415,1416
>  * @cat listener-callback
>  *
1423c1423,1428
< /// Handle returned by AddEventWatch()
---
> /**
>  * Handle returned by AddEventWatch(EventFilterCB)
>  *
>  * This can be used later to remove the event filter
>  * RemoveEventWatch(EventFilterHandle).
>  */
1471c1476,1477
<   SDL_SetEventFilter(filter, userdata);
---
>   UniqueCallbackWrapper<EventFilterCB>::erase();
>   return SDL_SetEventFilter(filter, userdata);
1502d1507
<  * @param userdata a pointer that is passed to `filter`.
1507a1513,1514
>  * @cat listener-callback
>  *
1516c1523,1528
<   static_assert(false, "Not implemented");
---
>   using Wrapper = UniqueCallbackWrapper<EventFilterCB>;
>   SDL_SetEventFilter(
>     [](void* userdata, SDL_Event* event) {
>       return Wrapper::Call(userdata, *event);
>     },
>     Wrapper::Wrap(std::move(filter)));
1547,1549c1559
<  * @param filter the current callback function will be stored here.
<  * @param userdata the pointer that is passed to the current event filter will
<  *                 be stored here.
---
>  * @returns EventFilterCB on success or false if there is no event filter set.
1555a1566,1567
>  * @cat listener-callback
>  *
1560c1572,1584
<   static_assert(false, "Not implemented");
---
>   using Wrapper = UniqueCallbackWrapper<EventFilterCB>;
> 
>   EventFilter filter;
>   void* userdata;
>   GetEventFilter(&filter, &userdata);
>   if (!userdata)
>     return [filter](const Event& event) {
>       return filter(nullptr, const_cast<Event*>(&event));
>     };
>   if (auto cb = Wrapper::at(userdata)) return cb;
>   return [filter, userdata](const Event& event) {
>     return filter(userdata, const_cast<Event*>(&event));
>   };
1562a1587
> /// @private
1565c1590,1591
<   static_assert(false, "Not implemented");
---
>   auto& f = *static_cast<EventFilterCB*>(userdata);
>   return f(*event);
1620,1621c1646,1648
<  * @param filter an EventFilter function to call when an event happens.
<  * @param userdata a pointer that is passed to `filter`.
---
>  * @param filter an EventFilterCB to call when an event happens.
>  * @returns a handle that can be used on RemoveEventWatch(EventFilterHandle) on
>  *          success.
1627a1655,1656
>  * @cat listener-callback
>  *
1633c1662,1668
<   static_assert(false, "Not implemented");
---
>   using Wrapper = CallbackWrapper<EventFilterCB>;
>   auto cb = Wrapper::Wrap(std::move(filter));
>   if (!SDL_AddEventWatch(&EventWatchAuxCallback, &cb)) {
>     Wrapper::release(cb);
>     throw Error{};
>   }
>   return EventWatchHandle{cb};
1659,1663c1694
<  * This function takes the same input as AddEventWatch() to identify and delete
<  * the corresponding callback.
<  *
<  * @param filter the function originally passed to AddEventWatch().
<  * @param userdata the pointer originally passed to AddEventWatch().
---
>  * @param handle the handle returned by SDL_AddEventWatch(EventFilterCB).
1669c1700,1702
<  * @sa AddEventWatch
---
>  * @cat listener-callback
>  *
>  * @sa AddEventWatch(EventFilterCB)
1673c1706,1707
<   static_assert(false, "Not implemented");
---
>   using Wrapper = CallbackWrapper<EventFilterCB>;
>   Wrapper::release(handle);
1708d1741
<  * @param userdata a pointer that is passed to `filter`.
1713a1747,1748
>  * @cat immediate-callback
>  *
1719c1754,1759
<   static_assert(false, "Not implemented");
---
>   return FilterEvents(
>     [](void* userdata, SDL_Event* event) {
>       auto& f = *static_cast<EventFilterCB*>(userdata);
>       return f(*event);
>     },
>     &filter);
1789c1829
<   return CheckError(SDL_GetWindowFromEvent(&event));
---
>   return {CheckError(SDL_GetWindowFromEvent(&event))};
1797,1798c1837,1838
<  * This will fill `buf` with a null-terminated string that might look something
<  * like this:
---
>  * This will fill `buf` with a null-terminated string that might look
>  * something like this:
1805,1806c1845,1846
<  * The exact format of the string is not guaranteed; it is intended for logging
<  * purposes, to be read by a human, and not parsed by a computer.
---
>  * The exact format of the string is not guaranteed; it is intended for
>  * logging purposes, to be read by a human, and not parsed by a computer.
1808,1812c1848,1853
<  * The returned value follows the same rules as snprintf(): `buf` will always be
<  * nullptr-terminated (unless `buflen` is zero), and will be truncated if
<  * `buflen` is too small. The return code is the number of bytes needed for the
<  * complete string, not counting the nullptr-terminator, whether the string was
<  * truncated or not. Unlike snprintf(), though, this function never returns -1.
---
>  * The returned value follows the same rules as snprintf(): `buf` will
>  * always be nullptr-terminated (unless `buflen` is zero), and will be truncated
>  * if `buflen` is too small. The return code is the number of bytes needed for
>  * the complete string, not counting the nullptr-terminator, whether the string
>  * was truncated or not. Unlike snprintf(), though, this function never
>  * returns -1.
1814,1816c1855,1856
<  * @param event an event to describe. May be nullptr.
<  * @param buf the buffer to fill with the description string. May be nullptr.
<  * @param buflen the maximum bytes that can be written to `buf`.
---
>  * @param event an event to describe
>  * @param buf the buffer to fill with the description string. May be empty.
1825a1866
>   if (buf.size_bytes() == 0) return SDL_GetEventDescription(event, nullptr, 0);
1829,1832d1869
< #endif // SDL_VERSION_ATLEAST(3, 4, 0)
< 
< #if SDL_VERSION_ATLEAST(3, 4, 0)
< 
1853,1857c1890,1891
<  * @param event an event to describe. May be nullptr.
<  * @param buf the buffer to fill with the description string. May be nullptr.
<  * @param buflen the maximum bytes that can be written to `buf`.
<  * @returns number of bytes needed for the full string, not counting the
<  *          null-terminator byte.
---
>  * @param event an event to describe
>  * @returns a std::string containing the the description string
1865c1899,1903
<   static_assert(false, "Not implemented");
---
>   int sz = SDL_GetEventDescription(event, nullptr, 0);
>   std::string r;
>   r.reserve(sz);
>   GetEventDescription(event, r);
>   return r;
