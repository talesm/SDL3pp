11c11
<  * @defgroup CategoryEvents Category Events
---
>  * @defgroup CategoryEvents Event Handling
41a42,48
>  * @defgroup EventTypes Event Types
>  *
>  * Event types for Event.
>  * @{
>  */
> 
> /**
444a452,453
> /// @}
> 
813a823,828
>  * @name EventActions
>  * The type of action to request from PeepEvents().
>  * @{
>  */
> 
> /**
828a844,845
> /// @}
> 
833a851,852
>  * ## remarks
>  *
873,874c892,893
<                       Uint32 minType,
<                       Uint32 maxType)
---
>                       Uint32 minType = EVENT_FIRST,
>                       Uint32 maxType = EVENT_LAST)
914c933
< inline bool HasEvents(Uint32 minType, Uint32 maxType)
---
> inline bool HasEvents(Uint32 minType = EVENT_FIRST, Uint32 maxType = EVENT_LAST)
971c990,991
< inline void FlushEvents(Uint32 minType, Uint32 maxType)
---
> inline void FlushEvents(Uint32 minType = EVENT_FIRST,
>                         Uint32 maxType = EVENT_LAST)
997c1017
<  * ```c
---
>  * ```cpp
999,1000c1019,1020
<  *     Event event;
<  *     while (PollEvent(&event)) {  // poll until all events are handled!
---
>  *     SDL::Event event;
>  *     while (SDL::PollEvent(&event)) {  // poll until all events are handled!
1025,1031c1045
<  * If `event` is not nullptr, the next event is removed from the queue and
<  * stored in the Event structure pointed to by `event`. The 1 returned refers to
<  * this event, immediately stored in the SDL Event structure -- not an event to
<  * follow.
<  *
<  * If `event` is nullptr, it simply returns 1 if there is an event in the queue,
<  * but will not remove it from the queue.
---
>  * The next event is removed from the queue and returned.
1045,1046c1059
<  *     Event event;
<  *     while (PollEvent(&event)) {  // poll until all events are handled!
---
>  *     while (auto event = SDL::PollEvent()) {
1054,1056c1067,1068
<  * @param event the Event structure to be filled with the next event from the
<  *              queue, or nullptr.
<  * @returns true if this got an event or false if there are none available.
---
>  * @returns Event if this got an event or std::nullopt if there are none
>  *          available.
1068c1080,1081
<   static_assert(false, "Not implemented");
---
>   if (Event event; PollEvent(&event)) return event;
>   return std::nullopt;
1097,1098c1110
<  * If `event` is not nullptr, the next event is removed from the queue and
<  * stored in the Event structure pointed to by `event`.
---
>  * The next event is removed from the queue and returned.
1103,1104c1115,1116
<  * @param event the Event structure to be filled in with the next event from the
<  *              queue, or nullptr.
---
>  * @returns Event on success.
>  *
1115c1127,1132
< inline Event WaitEvent() { static_assert(false, "Not implemented"); }
---
> inline Event WaitEvent()
> {
>   Event event;
>   WaitEvent(&event);
>   return event;
> }
1154,1156d1170
<  * If `event` is not nullptr, the next event is removed from the queue and
<  * stored in the Event structure pointed to by `event`.
<  *
1163,1164d1176
<  * @param event the Event structure to be filled in with the next event from the
<  *              queue, or nullptr.
1167,1168c1179,1180
<  * @returns true if this got an event or false if the timeout elapsed without
<  *          any events available.
---
>  * @returns the Event if this got an event or std::nullopt if the timeout
>  * elapsed without any events available.
1180c1192,1193
<   static_assert(false, "Not implemented");
---
>   if (Event event; WaitEventTimeout(&event, timeoutMS)) return event;
>   return std::nullopt;
1198,1199c1211,1212
<  * @param timeoutMS the maximum number of milliseconds to wait for the next
<  *                  available event.
---
>  * @param timeoutDuration the duration to wait for the next available event,
>  *                        with millisecond precision
1214c1227
<   static_assert(false, "Not implemented");
---
>   return WaitEventTimeout(event, std::max(timeoutDuration.count(), 1l));
1218,1222c1231,1232
<  * Wait until the specified timeout (in milliseconds) for the next available
<  * event.
<  *
<  * If `event` is not nullptr, the next event is removed from the queue and
<  * stored in the Event structure pointed to by `event`.
---
>  * Wait until the specified timeout (with milliseconds precision) for the next
>  * available event.
1230,1235c1240,1243
<  * @param event the Event structure to be filled in with the next event from the
<  *              queue, or nullptr.
<  * @param timeoutMS the maximum number of milliseconds to wait for the next
<  *                  available event.
<  * @returns true if this got an event or false if the timeout elapsed without
<  *          any events available.
---
>  * @param timeoutDuration the duration to wait for the next available event,
>  *                        with millisecond precision.
>  * @returns the Event if this got an event or std::nullopt if the timeout
>  *          elapsed without any events available.
1248c1256,1257
<   static_assert(false, "Not implemented");
---
>   if (Event event; WaitEventTimeout(&event, timeoutDuration)) return event;
>   return std::nullopt;
1315c1324
<   static_assert(false, "Not implemented");
---
>   PushEvent(const_cast<Event*>(&event));
1339c1348
<  * A function pointer used for callbacks that watch the event queue.
---
>  * A std::function used for callbacks that watch the event queue.
1351,1352c1360,1364
<  * @sa SetEventFilter
<  * @sa AddEventWatch
---
>  * @cat listener-callback
>  *
>  * @sa listener-callback
>  * @sa SetEventFilter()
>  * @sa AddEventWatch()
1397c1409,1410
<   SDL_SetEventFilter(filter, userdata);
---
>   UniqueCallbackWrapper<EventFilterCB>::erase();
>   return SDL_SetEventFilter(filter, userdata);
1508d1520
<  * @param userdata a pointer that is passed to `filter`.
1513a1526,1528
>  * @cat immediate-callback
>  *
>  * @sa immediate-callback
1519c1534,1539
<   static_assert(false, "Not implemented");
---
>   return FilterEvents(
>     [](void* userdata, SDL_Event* event) {
>       auto& f = *static_cast<EventFilterCB*>(userdata);
>       return f(*event);
>     },
>     &filter);
1589c1609
<   return CheckError(SDL_GetWindowFromEvent(&event));
---
>   return {CheckError(SDL_GetWindowFromEvent(&event))};
