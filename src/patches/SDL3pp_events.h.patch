--- src/generated/SDL3pp_events.h
+++ include/SDL3pp/SDL3pp_events.h
@@ -8,7 +8,7 @@
 namespace SDL {
 
 /**
- * @defgroup CategoryEvents Category Events
+ * @defgroup CategoryEvents Event Handling
  *
  * Event queue management.
  *
@@ -39,6 +39,13 @@
  */
 
 /**
+ * @defgroup EventTypes Event Types
+ *
+ * Event types for Event.
+ * @{
+ */
+
+/**
  * The types of events that can be delivered.
  *
  * @since This enum is available since SDL 3.2.0.
@@ -262,10 +269,6 @@
 constexpr EventType EVENT_SCREEN_KEYBOARD_SHOWN =
   SDL_EVENT_SCREEN_KEYBOARD_SHOWN; ///< The on-screen keyboard has been shown
 
-#endif // SDL_VERSION_ATLEAST(3, 3, 0)
-
-#if SDL_VERSION_ATLEAST(3, 3, 0)
-
 constexpr EventType EVENT_SCREEN_KEYBOARD_HIDDEN =
   SDL_EVENT_SCREEN_KEYBOARD_HIDDEN; ///< The on-screen keyboard has been hidden
 
@@ -368,17 +371,9 @@
 constexpr EventType EVENT_PINCH_BEGIN =
   SDL_EVENT_PINCH_BEGIN; ///< Pinch gesture started
 
-#endif // SDL_VERSION_ATLEAST(3, 3, 0)
-
-#if SDL_VERSION_ATLEAST(3, 3, 0)
-
 constexpr EventType EVENT_PINCH_UPDATE =
   SDL_EVENT_PINCH_UPDATE; ///< Pinch gesture updated
 
-#endif // SDL_VERSION_ATLEAST(3, 3, 0)
-
-#if SDL_VERSION_ATLEAST(3, 3, 0)
-
 constexpr EventType EVENT_PINCH_END =
   SDL_EVENT_PINCH_END; ///< Pinch gesture ended
 
@@ -486,6 +481,8 @@
 constexpr EventType EVENT_ENUM_PADDING =
   SDL_EVENT_ENUM_PADDING; ///< ENUM_PADDING
 
+/// @}
+
 /**
  * Fields shared by every event
  *
@@ -862,6 +859,12 @@
 inline void PumpEvents() { SDL_PumpEvents(); }
 
 /**
+ * @name EventActions
+ * The type of action to request from PeepEvents().
+ * @{
+ */
+
+/**
  * The type of action to request from PeepEvents().
  *
  * @since This enum is available since SDL 3.2.0.
@@ -877,11 +880,15 @@
 /// Retrieve/remove events from the front of the queue.
 constexpr EventAction GETEVENT = SDL_GETEVENT;
 
+/// @}
+
 /**
  * Check the event queue for messages and optionally return them.
  *
  * `action` may be any of the following:
  *
+ * ## remarks
+ *
  * - `ADDEVENT`: up to `numevents` events will be added to the back of the event
  *   queue.
  * - `PEEKEVENT`: `numevents` events at the front of the event queue, within the
@@ -1046,10 +1053,10 @@
  * The common practice is to fully process the event queue once every frame,
  * usually as a first step before updating the game's state:
  *
- * ```c
+ * ```cpp
  * while (game_is_still_running) {
- *     Event event;
- *     while (PollEvent(&event)) {  // poll until all events are handled!
+ *     SDL::Event event;
+ *     while (SDL::PollEvent(&event)) {  // poll until all events are handled!
  *         // decide what to do with this event.
  *     }
  *
@@ -1081,13 +1088,7 @@
 /**
  * Poll for currently pending events.
  *
- * If `event` is not nullptr, the next event is removed from the queue and
- * stored in the Event structure pointed to by `event`. The 1 returned refers to
- * this event, immediately stored in the SDL Event structure -- not an event to
- * follow.
- *
- * If `event` is nullptr, it simply returns 1 if there is an event in the queue,
- * but will not remove it from the queue.
+ * The next event is removed from the queue and returned.
  *
  * As this function may implicitly call PumpEvents(), you can only call this
  * function in the thread that set the video mode.
@@ -1101,8 +1102,7 @@
  *
  * ```c
  * while (game_is_still_running) {
- *     Event event;
- *     while (PollEvent(&event)) {  // poll until all events are handled!
+ *     while (auto event = SDL::PollEvent()) {
  *         // decide what to do with this event.
  *     }
  *
@@ -1117,9 +1117,8 @@
  *
  * https://wiki.libsdl.org/SDL3/AppFreezeDuringDrag
  *
- * @param event the Event structure to be filled with the next event from the
- *              queue, or nullptr.
- * @returns true if this got an event or false if there are none available.
+ * @returns Event if this got an event or std::nullopt if there are none
+ *          available.
  *
  * @threadsafety This function should only be called on the main thread.
  *
@@ -1131,7 +1130,8 @@
  */
 inline std::optional<Event> PollEvent()
 {
-  static_assert(false, "Not implemented");
+  if (Event event; PollEvent(&event)) return event;
+  return std::nullopt;
 }
 
 /**
@@ -1160,14 +1160,13 @@
 /**
  * Wait indefinitely for the next available event.
  *
- * If `event` is not nullptr, the next event is removed from the queue and
- * stored in the Event structure pointed to by `event`.
+ * The next event is removed from the queue and returned.
  *
  * As this function may implicitly call PumpEvents(), you can only call this
  * function in the thread that initialized the video subsystem.
  *
- * @param event the Event structure to be filled in with the next event from the
- *              queue, or nullptr.
+ * @returns Event on success.
+ *
  * @throws Error on failure.
  *
  * @threadsafety This function should only be called on the main thread.
@@ -1178,7 +1177,12 @@
  * @sa PushEvent
  * @sa WaitEventTimeout
  */
-inline Event WaitEvent() { static_assert(false, "Not implemented"); }
+inline Event WaitEvent()
+{
+  Event event;
+  WaitEvent(&event);
+  return event;
+}
 
 /**
  * Wait until the specified timeout (in milliseconds) for the next available
@@ -1217,21 +1221,16 @@
  * Wait until the specified timeout (in milliseconds) for the next available
  * event.
  *
- * If `event` is not nullptr, the next event is removed from the queue and
- * stored in the Event structure pointed to by `event`.
- *
  * As this function may implicitly call PumpEvents(), you can only call this
  * function in the thread that initialized the video subsystem.
  *
  * The timeout is not guaranteed, the actual wait time could be longer due to
  * system scheduling.
  *
- * @param event the Event structure to be filled in with the next event from the
- *              queue, or nullptr.
  * @param timeoutMS the maximum number of milliseconds to wait for the next
  *                  available event.
- * @returns true if this got an event or false if the timeout elapsed without
- *          any events available.
+ * @returns the Event if this got an event or std::nullopt if the timeout
+ * elapsed without any events available.
  *
  * @threadsafety This function should only be called on the main thread.
  *
@@ -1243,7 +1242,8 @@
  */
 inline std::optional<Event> WaitEventTimeout(Sint32 timeoutMS)
 {
-  static_assert(false, "Not implemented");
+  if (Event event; WaitEventTimeout(&event, timeoutMS)) return event;
+  return std::nullopt;
 }
 
 /**
@@ -1261,8 +1261,8 @@
  *
  * @param event the Event structure to be filled in with the next event from the
  *              queue, or nullptr.
- * @param timeoutMS the maximum number of milliseconds to wait for the next
- *                  available event.
+ * @param timeoutDuration the duration to wait for the next available event,
+ *                        with millisecond precision
  * @returns true if this got an event or false if the timeout elapsed without
  *          any events available.
  *
@@ -1277,15 +1277,15 @@
 inline bool WaitEventTimeout(Event* event,
                              std::chrono::milliseconds timeoutDuration)
 {
-  static_assert(false, "Not implemented");
+  return WaitEventTimeout(event,
+                          Sint32(std::max(timeoutDuration.count(), Sint64(1))));
 }
 
 /**
  * Wait until the specified timeout (in milliseconds) for the next available
  * event.
  *
- * If `event` is not nullptr, the next event is removed from the queue and
- * stored in the Event structure pointed to by `event`.
+ * The next event is removed from the queue and returned.
  *
  * As this function may implicitly call PumpEvents(), you can only call this
  * function in the thread that initialized the video subsystem.
@@ -1293,12 +1293,10 @@
  * The timeout is not guaranteed, the actual wait time could be longer due to
  * system scheduling.
  *
- * @param event the Event structure to be filled in with the next event from the
- *              queue, or nullptr.
- * @param timeoutMS the maximum number of milliseconds to wait for the next
- *                  available event.
- * @returns true if this got an event or false if the timeout elapsed without
- *          any events available.
+ * @param timeoutDuration the duration to wait for the next available event,
+ *                        with millisecond precision.
+ * @returns the Event if this got an event or std::nullopt if the timeout
+ *          elapsed without any events available.
  *
  * @threadsafety This function should only be called on the main thread.
  *
@@ -1311,7 +1309,8 @@
 inline std::optional<Event> WaitEventTimeout(
   std::chrono::milliseconds timeoutDuration)
 {
-  static_assert(false, "Not implemented");
+  if (Event event; WaitEventTimeout(&event, timeoutDuration)) return event;
+  return std::nullopt;
 }
 
 /**
@@ -1378,7 +1377,7 @@
  */
 inline void PushEvent(const Event& event)
 {
-  static_assert(false, "Not implemented");
+  PushEvent(const_cast<Event*>(&event));
 }
 
 /**
@@ -1402,7 +1401,7 @@
 using EventFilter = bool(SDLCALL*)(void* userdata, Event* event);
 
 /**
- * A function pointer used for callbacks that watch the event queue.
+ * A std::function used for callbacks that watch the event queue.
  *
  * @param event the event that triggered the callback.
  * @returns true to permit event to be added to the queue, and false to disallow
@@ -1414,12 +1413,34 @@
  *
  * @since This datatype is available since SDL 3.2.0.
  *
+ * @cat listener-callback
+ *
  * @sa SetEventFilter
  * @sa AddEventWatch
  * @sa EventFilter
  */
 using EventFilterCB = std::function<bool(Event* event)>;
 
+/**
+ * A std::function used for callbacks that watch the event queue.
+ *
+ * @param event the event that triggered the callback.
+ * @returns true to permit event to be added to the queue, and false to disallow
+ *          it. When used with AddEventWatch, the return value is ignored.
+ *
+ * @threadsafety SDL may call this callback at any time from any thread; the
+ *               application is responsible for locking resources the callback
+ *               touches that need to be protected.
+ *
+ * @since This datatype is available since SDL 3.2.0.
+ *
+ * @cat listener-callback
+ *
+ * @sa listener-callback
+ * @sa SetEventFilter()
+ * @sa AddEventWatch()
+ * @sa EventFilter
+ */
 using EventWatcherCB = MakeFrontCallback<bool(Event* event)>;
 
 /**
@@ -1495,12 +1516,13 @@
  * event filter, but events pushed onto the queue with PeepEvents() do not.
  *
  * @param filter a function to call when an event happens.
- * @param userdata a pointer that is passed to `filter`.
  *
  * @threadsafety It is safe to call this function from any thread.
  *
  * @since This function is available since SDL 3.2.0.
  *
+ * @cat listener-callback
+ *
  * @sa AddEventWatch
  * @sa SetEventEnabled
  * @sa GetEventFilter
@@ -1509,7 +1531,10 @@
  */
 inline void SetEventFilter(EventFilterCB filter)
 {
-  static_assert(false, "Not implemented");
+  static EventFilterCB staticFilter;
+  staticFilter = filter;
+  SetEventFilter([](void*, Event* event) { return staticFilter(event); },
+                 nullptr);
 }
 
 /**
@@ -1587,19 +1612,20 @@
  * PeepEvents().
  *
  * @param filter an EventFilter function to call when an event happens.
- * @param userdata a pointer that is passed to `filter`.
  * @throws Error on failure.
  *
  * @threadsafety It is safe to call this function from any thread.
  *
  * @since This function is available since SDL 3.2.0.
  *
+ * @cat listener-callback
+ *
  * @sa RemoveEventWatch
  * @sa SetEventFilter
  */
 inline void AddEventWatch(EventWatcherCB filter)
 {
-  static_assert(false, "Not implemented");
+  AddEventWatch(filter.wrapper, filter.data);
 }
 
 /**
@@ -1654,18 +1680,24 @@
  * filter until this function returns.
  *
  * @param filter the EventFilter function to call when an event happens.
- * @param userdata a pointer that is passed to `filter`.
  *
  * @threadsafety It is safe to call this function from any thread.
  *
  * @since This function is available since SDL 3.2.0.
  *
+ * @cat immediate-callback
+ *
  * @sa GetEventFilter
  * @sa SetEventFilter
  */
 inline void FilterEvents(EventFilterCB filter)
 {
-  static_assert(false, "Not implemented");
+  return FilterEvents(
+    [](void* userdata, Event* event) {
+      const auto& f = *static_cast<EventFilterCB*>(userdata);
+      return f(event);
+    },
+    &filter);
 }
 
 /**
@@ -1735,7 +1767,7 @@
  */
 inline WindowRef GetWindowFromEvent(const Event& event)
 {
-  return CheckError(SDL_GetWindowFromEvent(&event));
+  return {CheckError(SDL_GetWindowFromEvent(&event))};
 }
 
 #if SDL_VERSION_ATLEAST(3, 4, 0)
@@ -1743,26 +1775,26 @@
 /**
  * Generate an English description of an event.
  *
- * This will fill `buf` with a null-terminated string that might look something
- * like this:
+ * This will fill `buf` with a null-terminated string that might look
+ * something like this:
  *
  * ```
  * EVENT_MOUSE_MOTION (timestamp=1140256324 windowid=2 which=0 state=0 x=492.99
  * y=139.09 xrel=52 yrel=6)
  * ```
  *
- * The exact format of the string is not guaranteed; it is intended for logging
- * purposes, to be read by a human, and not parsed by a computer.
+ * The exact format of the string is not guaranteed; it is intended for
+ * logging purposes, to be read by a human, and not parsed by a computer.
  *
- * The returned value follows the same rules as snprintf(): `buf` will always be
- * nullptr-terminated (unless `buflen` is zero), and will be truncated if
- * `buflen` is too small. The return code is the number of bytes needed for the
- * complete string, not counting the nullptr-terminator, whether the string was
- * truncated or not. Unlike snprintf(), though, this function never returns -1.
+ * The returned value follows the same rules as snprintf(): `buf` will
+ * always be nullptr-terminated (unless `buflen` is zero), and will be truncated
+ * if `buflen` is too small. The return code is the number of bytes needed for
+ * the complete string, not counting the nullptr-terminator, whether the string
+ * was truncated or not. Unlike snprintf(), though, this function never
+ * returns -1.
  *
- * @param event an event to describe. May be nullptr.
- * @param buf the buffer to fill with the description string. May be nullptr.
- * @param buflen the maximum bytes that can be written to `buf`.
+ * @param event an event to describe
+ * @param buf the buffer to fill with the description string. May be empty.
  * @returns number of bytes needed for the full string, not counting the
  *          null-terminator byte.
  *
@@ -1772,13 +1804,10 @@
  */
 inline int GetEventDescription(const Event& event, TargetBytes buf)
 {
+  if (buf.size_bytes() == 0) return SDL_GetEventDescription(event, nullptr, 0);
   return SDL_GetEventDescription(&event, buf.data(), buf.size_bytes());
 }
 
-#endif // SDL_VERSION_ATLEAST(3, 4, 0)
-
-#if SDL_VERSION_ATLEAST(3, 4, 0)
-
 /**
  * Generate an English description of an event.
  *
@@ -1799,11 +1828,8 @@
  * complete string, not counting the nullptr-terminator, whether the string was
  * truncated or not. Unlike snprintf(), though, this function never returns -1.
  *
- * @param event an event to describe. May be nullptr.
- * @param buf the buffer to fill with the description string. May be nullptr.
- * @param buflen the maximum bytes that can be written to `buf`.
- * @returns number of bytes needed for the full string, not counting the
- *          null-terminator byte.
+ * @param event an event to describe
+ * @returns a std::string containing the the description string
  *
  * @threadsafety It is safe to call this function from any thread.
  *
@@ -1811,7 +1837,11 @@
  */
 inline std::string GetEventDescription(const Event& event)
 {
-  static_assert(false, "Not implemented");
+  int sz = SDL_GetEventDescription(event, nullptr, 0);
+  std::string r;
+  r.reserve(sz);
+  GetEventDescription(event, r);
+  return r;
 }
 
 #endif // SDL_VERSION_ATLEAST(3, 4, 0)
