11c11
<  * @defgroup CategoryEvents Category Events
---
>  * @defgroup CategoryEvents Event Handling
42a43,49
>  * @defgroup EventTypes Event Types
>  *
>  * Event types for Event.
>  * @{
>  */
> 
> /**
93c100
<  *                                      Called on Android in onResume()
---
>  * Called on Android in onResume()
214c221
<  *                                              associated with it are invalid
---
>  * associated with it are invalid
237,239c244,245
<  * Keymap changed due to a system event such as an
<  *                                             input language or keyboard layout
<  * change.
---
>  * Keymap changed due to a system event such as an input language or keyboard
>  * layout change.
446a453,454
> /// @}
> 
818a827,832
>  * @name EventActions
>  * The type of action to request from PeepEvents().
>  * @{
>  */
> 
> /**
833a848,849
> /// @}
> 
838a855,856
>  * ## remarks
>  *
879,880c897,898
<                       Uint32 minType,
<                       Uint32 maxType)
---
>                       Uint32 minType = EVENT_FIRST,
>                       Uint32 maxType = EVENT_LAST)
921c939
< inline bool HasEvents(Uint32 minType, Uint32 maxType)
---
> inline bool HasEvents(Uint32 minType = EVENT_FIRST, Uint32 maxType = EVENT_LAST)
979c997,998
< inline void FlushEvents(Uint32 minType, Uint32 maxType)
---
> inline void FlushEvents(Uint32 minType = EVENT_FIRST,
>                         Uint32 maxType = EVENT_LAST)
1005c1024
<  * ```c
---
>  * ```cpp
1007,1008c1026,1027
<  *     Event event;
<  *     while (PollEvent(&event)) {  // poll until all events are handled!
---
>  *     SDL::Event event;
>  *     while (SDL::PollEvent(&event)) {  // poll until all events are handled!
1033,1039c1052
<  * If `event` is not nullptr, the next event is removed from the queue and
<  * stored in the Event structure pointed to by `event`. The 1 returned refers to
<  * this event, immediately stored in the SDL Event structure -- not an event
<  * to follow.
<  *
<  * If `event` is nullptr, it simply returns 1 if there is an event in the queue,
<  * but will not remove it from the queue.
---
>  * The next event is removed from the queue and returned.
1053,1054c1066
<  *     Event event;
<  *     while (PollEvent(&event)) {  // poll until all events are handled!
---
>  *     while (auto event = SDL::PollEvent()) {
1062,1064c1074,1075
<  * @param event the Event structure to be filled with the next event from
<  *              the queue, or nullptr.
<  * @returns true if this got an event or false if there are none available.
---
>  * @returns Event if this got an event or std::nullopt if there are none
>  * available.
1076c1087,1088
<   static_assert(false, "Not implemented");
---
>   if (Event event; PollEvent(&event)) return event;
>   return std::nullopt;
1105,1106c1117
<  * If `event` is not nullptr, the next event is removed from the queue and
<  * stored in the Event structure pointed to by `event`.
---
>  * The next event is removed from the queue and returned.
1111,1112c1122
<  * @param event the Event structure to be filled in with the next event
<  *              from the queue, or nullptr.
---
>  * @returns Event on success.
1123c1133,1138
< inline Event WaitEvent() { static_assert(false, "Not implemented"); }
---
> inline Event WaitEvent()
> {
>   Event event;
>   WaitEvent(&event);
>   return event;
> }
1162,1164d1176
<  * If `event` is not nullptr, the next event is removed from the queue and
<  * stored in the Event structure pointed to by `event`.
<  *
1171,1172d1182
<  * @param event the Event structure to be filled in with the next event
<  *              from the queue, or nullptr.
1175,1176c1185,1186
<  * @returns true if this got an event or false if the timeout elapsed without
<  *          any events available.
---
>  * @returns the Event if this got an event or std::nullopt if the timeout
>  * elapsed without any events available.
1188c1198,1199
<   static_assert(false, "Not implemented");
---
>   if (Event event; WaitEventTimeout(&event, timeoutMS)) return event;
>   return std::nullopt;
1206,1207c1217,1218
<  * @param timeoutMS the maximum number of milliseconds to wait for the next
<  *                  available event.
---
>  * @param timeoutDuration the duration to wait for the next available event,
>  *                        with millisecond precision
1222c1233
<   static_assert(false, "Not implemented");
---
>   return WaitEventTimeout(event, std::max(timeoutDuration.count(), 1l));
1226,1230c1237,1238
<  * Wait until the specified timeout (in milliseconds) for the next available
<  * event.
<  *
<  * If `event` is not nullptr, the next event is removed from the queue and
<  * stored in the Event structure pointed to by `event`.
---
>  * Wait until the specified timeout (with milliseconds precision) for the next
>  * available event.
1238,1243c1246,1249
<  * @param event the Event structure to be filled in with the next event
<  *              from the queue, or nullptr.
<  * @param timeoutMS the maximum number of milliseconds to wait for the next
<  *                  available event.
<  * @returns true if this got an event or false if the timeout elapsed without
<  *          any events available.
---
>  * @param timeoutDuration the duration to wait for the next available event,
>  *                        with millisecond precision.
>  * @returns the Event if this got an event or std::nullopt if the timeout
>  * elapsed without any events available.
1256c1262,1263
<   static_assert(false, "Not implemented");
---
>   if (Event event; WaitEventTimeout(&event, timeoutDuration)) return event;
>   return std::nullopt;
1323c1330
<   static_assert(false, "Not implemented");
---
>   PushEvent(const_cast<Event*>(&event));
1348c1355
<  * A function pointer used for callbacks that watch the event queue.
---
>  * A std::function used for callbacks that watch the event queue.
1350,1351d1356
<  * @param userdata what was passed as `userdata` to SetEventFilter() or
<  *                 AddEventWatch, etc.
1354c1359
<  *          disallow it. When used with AddEventWatch, the return value is
---
>  *          disallow it. When used with AddEventWatch(), the return value is
1363,1364c1368,1372
<  * @sa SetEventFilter
<  * @sa AddEventWatch
---
>  * @cat listener-callback
>  *
>  * @sa listener-callback
>  * @sa SetEventFilter()
>  * @sa AddEventWatch()
1369c1377,1382
< /// Handle returned by AddEventWatch()
---
> /**
>  * Handle returned by AddEventWatch(EventFilterCB)
>  *
>  * This can be used later to remove the event filter
>  * RemoveEventWatch(EventFilterHandle).
>  */
1416c1429,1430
<   SDL_SetEventFilter(filter, userdata);
---
>   UniqueCallbackWrapper<EventFilterCB>::erase();
>   return SDL_SetEventFilter(filter, userdata);
1445,1446c1459
<  * @param filter an EventFilter function to call when an event happens.
<  * @param userdata a pointer that is passed to `filter`.
---
>  * @param filter an EventFilterCB function to call when an event happens.
1451a1465,1467
>  * @cat listener-callback
>  *
>  * @sa listener-callback
1460c1476,1481
<   static_assert(false, "Not implemented");
---
>   using Wrapper = UniqueCallbackWrapper<EventFilterCB>;
>   SDL_SetEventFilter(
>     [](void* userdata, SDL_Event* event) {
>       return Wrapper::Call(userdata, *event);
>     },
>     Wrapper::Wrap(std::move(filter)));
1491,1494c1512,1513
<  * @param filter the current callback function will be stored here.
<  * @param userdata the pointer that is passed to the current event filter will
<  *                 be stored here.
<  * @throws Error on failure.
---
>  * @returns EventFilterCB on success or false if there is no event filter
>  * set.
1499a1519,1521
>  * @cat listener-callback
>  *
>  * @sa listener-callback
1504c1526,1538
<   static_assert(false, "Not implemented");
---
>   using Wrapper = UniqueCallbackWrapper<EventFilterCB>;
> 
>   EventFilter filter;
>   void* userdata;
>   GetEventFilter(&filter, &userdata);
>   if (!userdata)
>     return [filter](const Event& event) {
>       return filter(nullptr, const_cast<Event*>(&event));
>     };
>   if (auto cb = Wrapper::at(userdata)) return cb;
>   return [filter, userdata](const Event& event) {
>     return filter(userdata, const_cast<Event*>(&event));
>   };
1506a1541
> /// @private
1509c1544,1545
<   static_assert(false, "Not implemented");
---
>   auto& f = *static_cast<EventFilterCB*>(userdata);
>   return f(*event);
1564,1565c1600,1602
<  * @param filter an EventFilter function to call when an event happens.
<  * @param userdata a pointer that is passed to `filter`.
---
>  * @param filter an EventFilterCB to call when an event happens.
>  * @returns a handle that can be used on RemoveEventWatch(EventFilterHandle) on
>  *          success.
1571a1609,1611
>  * @cat listener-callback
>  *
>  * @sa listener-callback
1577c1617,1623
<   static_assert(false, "Not implemented");
---
>   using Wrapper = CallbackWrapper<EventFilterCB>;
>   auto cb = Wrapper::Wrap(std::move(filter));
>   if (!SDL_AddEventWatch(&EventWatchAuxCallback, &cb)) {
>     Wrapper::release(cb);
>     throw Error{};
>   }
>   return EventWatchHandle{cb};
1603,1607c1649
<  * This function takes the same input as AddEventWatch() to identify and
<  * delete the corresponding callback.
<  *
<  * @param filter the function originally passed to AddEventWatch().
<  * @param userdata the pointer originally passed to AddEventWatch().
---
>  * @param handle the handle returned by SDL_AddEventWatch(EventFilterCB).
1613c1655,1658
<  * @sa AddEventWatch
---
>  * @cat listener-callback
>  *
>  * @sa listener-callback
>  * @sa AddEventWatch(EventFilterCB)
1617c1662,1663
<   static_assert(false, "Not implemented");
---
>   using Wrapper = CallbackWrapper<EventFilterCB>;
>   Wrapper::release(handle);
1652d1697
<  * @param userdata a pointer that is passed to `filter`.
1657a1703,1705
>  * @cat immediate-callback
>  *
>  * @sa immediate-callback
1663c1711,1716
<   static_assert(false, "Not implemented");
---
>   return FilterEvents(
>     [](void* userdata, SDL_Event* event) {
>       auto& f = *static_cast<EventFilterCB*>(userdata);
>       return f(*event);
>     },
>     &filter);
1733c1786
<   return CheckError(SDL_GetWindowFromEvent(&event));
---
>   return {CheckError(SDL_GetWindowFromEvent(&event))};
