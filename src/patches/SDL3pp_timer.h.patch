10c10
<  * @defgroup CategoryTimer Category Timer
---
>  * @defgroup CategoryTimer Timer Support
16c16
<  * by [CategoryTime](CategoryTime).
---
>  * by [CategoryTime](#CategoryTime).
23,25d22
<  * There are also useful macros to convert between time units, like
<  * Time.FromPosix() and such.
<  *
29c26,29
< constexpr Time Time::FromPosix(Sint64 time) { return SDL_SECONDS_TO_NS(time); }
---
> constexpr Time Time::FromPosix(Sint64 time)
> {
>   return Time::FromNS(SDL_SECONDS_TO_NS(time));
> }
31c31,34
< constexpr Sint64 Time::ToPosix() const { return SDL_NS_TO_SECONDS(m_time); }
---
> constexpr Sint64 Time::ToPosix() const
> {
>   return SDL_NS_TO_SECONDS(m_time.count());
> }
34c37
<  * Get the number of nanoseconds since SDL library initialization.
---
>  * Get the time elapsed since SDL library initialization.
36,37c39,40
<  * @returns an unsigned 64-bit value representing the number of nanoseconds
<  *          since the SDL library initialized.
---
>  * @returns a std::chrono::nanoseconds value representing the number of
>  * nanoseconds since the SDL library initialized.
43c46,49
< inline std::chrono::nanoseconds GetTicks() { return SDL_GetTicksNS(); }
---
> inline std::chrono::nanoseconds GetTicks()
> {
>   return std::chrono::nanoseconds{SDL_GetTicksNS()};
> }
80c86
<  * Wait a specified number of milliseconds before returning.
---
>  * Wait a specified duration before returning.
82c88
<  * This function waits a specified number of milliseconds before returning. It
---
>  * This function waits a specified duration before returning. It
85c91
<  * @param ms the number of milliseconds to delay.
---
>  * @param duration the duration to delay, with max precision in ns.
91d96
<  * @sa SDL_DelayNS
94c99,102
< inline void Delay(std::chrono::nanoseconds duration) { SDL_Delay(duration); }
---
> inline void Delay(std::chrono::nanoseconds duration)
> {
>   SDL_DelayNS(duration.count());
> }
97c105
<  * Wait a specified number of nanoseconds before returning.
---
>  * Wait a specified duration before returning.
99c107
<  * This function waits a specified number of nanoseconds before returning. It
---
>  * This function waits a specified duration before returning. It
103c111
<  * @param ns the number of nanoseconds to delay.
---
>  * @param duration the duration to delay.
110d117
<  * @sa SDL_DelayNS
114c121
<   SDL_DelayPrecise(duration);
---
>   SDL_DelayPrecise(duration.count());
169a177,178
>  * @cat listener-callback
>  *
196,197c205,207
<  * @param interval the timer delay, in nanoseconds, passed to `callback`.
<  * @param callback the SDL_TimerCallback function to call when the specified
---
>  * @param interval the timer delay, in std::chrono::nanoseconds, passed to
>  *                 `callback`.
>  * @param callback the NSTimerCallback function to call when the specified
200c210,211
<  * @returns a timer ID or 0 on failure; call GetError() for more information.
---
>  * @returns a timer ID.
>  * @throws Error on failure.
206d216
<  * @sa SDL_AddTimer
213c223
<   return SDL_AddTimerNS(interval, callback, userdata);
---
>   return CheckError(SDL_AddTimerNS(interval.count(), callback, userdata));
235,236c245,247
<  * @param interval the timer delay, in nanoseconds, passed to `callback`.
<  * @param callback the SDL_TimerCallback function to call when the specified
---
>  * @param interval the timer delay, in std::chrono::nanoseconds, passed to
>  * `callback`.
>  * @param callback the TimerCB function to call when the specified
238,239c249,250
<  * @param userdata a pointer that is passed to `callback`.
<  * @returns a timer ID or 0 on failure; call GetError() for more information.
---
>  * @returns a timer ID.
>  * @throws Error on failure.
245,246c256,259
<  * @sa SDL_AddTimer
<  * @sa RemoveTimer
---
>  * @cat listener-callback
>  *
>  * @sa listener-callback
>  * @sa RemoveTimer()
250c263,282
<   static_assert(false, "Not implemented");
---
>   using Wrapper = CallbackWrapper<TimerCB>;
>   using Store = KeyValueWrapper<TimerID, TimerCB*>;
> 
>   auto cb = Wrapper::Wrap(std::move(callback));
> 
>   if (TimerID id = SDL_AddTimerNS(
>         interval.count(),
>         [](void* userdata, TimerID timerID, Uint64 interval) -> Uint64 {
>           auto& f = *static_cast<TimerCB*>(userdata);
>           auto next = f(timerID, std::chrono::nanoseconds(interval)).count();
>           // If ask to removal, then remove it
>           if (next == 0) delete Store::release(timerID);
>           return next;
>         },
>         cb)) {
>     Store::Wrap(id, std::move(cb));
>     return id;
>   }
>   delete cb;
>   throw Error{};
265c297,301
< inline void RemoveTimer(TimerID id) { CheckError(SDL_RemoveTimer(id)); }
---
> inline void RemoveTimer(TimerID id)
> {
>   delete KeyValueWrapper<TimerID, TimerCB*>::release(id);
>   CheckError(SDL_RemoveTimer(id));
> }
