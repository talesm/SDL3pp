10c10
<  * @defgroup CategoryTimer Category Timer
---
>  * @defgroup CategoryTimer Timer Support
16c16
<  * provided by [CategoryTime](CategoryTime).
---
>  * provided by [CategoryTime](#CategoryTime).
24,26d23
<  * There are also useful macros to convert between time units, like
<  * Time.FromPosix() and such.
<  *
35,36c32,33
<  * @param S the number of seconds to convert.
<  * @returns S, expressed in nanoseconds.
---
>  * @param time the number of seconds to convert.
>  * @returns the converted Time.
38c35
<  * @threadsafety It is safe to call this macro from any thread.
---
>  * @threadsafety It is safe to call this function from any thread.
40c37
<  * @since This macro is available since SDL 3.2.0.
---
>  * @since This function is available since SDL 3.2.0.
42c39,42
< constexpr Time Time::FromPosix(Sint64 time) { return SDL_SECONDS_TO_NS(time); }
---
> constexpr Time Time::FromPosix(Sint64 time)
> {
>   return Time::FromNS(SDL_SECONDS_TO_NS(time));
> }
47,48c47
<  * This performs a division, so the results can be dramatically different if
<  * `NS` is an integer or floating point value.
---
>  * This only converts whole numbers, not fractional seconds.
50,51c49
<  * @param NS the number of nanoseconds to convert.
<  * @returns NS, expressed in seconds.
---
>  * @returns Posix time (in seconds).
53c51
<  * @threadsafety It is safe to call this macro from any thread.
---
>  * @threadsafety It is safe to call this function from any thread.
55c53
<  * @since This macro is available since SDL 3.2.0.
---
>  * @since This function is available since SDL 3.2.0.
57c55,58
< constexpr Sint64 Time::ToPosix() const { return SDL_NS_TO_SECONDS(m_time); }
---
> constexpr Sint64 Time::ToPosix() const
> {
>   return SDL_NS_TO_SECONDS(m_time.count());
> }
60c61
<  * Get the number of nanoseconds since SDL library initialization.
---
>  * Get the time elapsed since SDL library initialization.
62,63c63,64
<  * @returns an unsigned 64-bit value representing the number of nanoseconds
<  *          since the SDL library initialized.
---
>  * @returns a std::chrono::nanoseconds value representing the number of
>  * nanoseconds since the SDL library initialized.
69c70,73
< inline std::chrono::nanoseconds GetTicks() { return SDL_GetTicksNS(); }
---
> inline std::chrono::nanoseconds GetTicks()
> {
>   return std::chrono::nanoseconds{SDL_GetTicksNS()};
> }
107c111
<  * Wait a specified number of milliseconds before returning.
---
>  * Wait a specified duration before returning.
109c113
<  * This function waits a specified number of milliseconds before returning. It
---
>  * This function waits a specified duration before returning. It
113c117
<  * @param ms the number of milliseconds to delay.
---
>  * @param duration the duration to delay, with max precision in ns.
119d122
<  * @sa SDL_DelayNS
122c125,128
< inline void Delay(std::chrono::nanoseconds duration) { SDL_Delay(duration); }
---
> inline void Delay(std::chrono::nanoseconds duration)
> {
>   SDL_DelayNS(duration.count());
> }
125c131
<  * Wait a specified number of nanoseconds before returning.
---
>  * Wait a specified duration before returning.
127c133
<  * This function waits a specified number of nanoseconds before returning. It
---
>  * This function waits a specified duration before returning. It
131c137
<  * @param ns the number of nanoseconds to delay.
---
>  * @param duration the duration to delay.
138d143
<  * @sa SDL_DelayNS
142c147
<   SDL_DelayPrecise(duration);
---
>   SDL_DelayPrecise(duration.count());
187,188d191
<  * @param userdata an arbitrary pointer provided by the app through
<  *                 SDL_AddTimer, for its own use.
199a203,204
>  * @cat listener-callback
>  *
226,227c231,233
<  * @param interval the timer delay, in nanoseconds, passed to `callback`.
<  * @param callback the SDL_TimerCallback function to call when the specified
---
>  * @param interval the timer delay, in std::chrono::nanoseconds, passed to
>  *                 `callback`.
>  * @param callback the NSTimerCallback function to call when the specified
230,231c236,237
<  * @returns a timer ID or 0 on failure; call GetError() for more
<  *          information.
---
>  * @returns a timer ID.
>  * @throws Error on failure.
237d242
<  * @sa SDL_AddTimer
244c249
<   return SDL_AddTimerNS(interval, callback, userdata);
---
>   return CheckError(SDL_AddTimerNS(interval.count(), callback, userdata));
267,268c272,274
<  * @param interval the timer delay, in nanoseconds, passed to `callback`.
<  * @param callback the SDL_TimerCallback function to call when the specified
---
>  * @param interval the timer delay, in std::chrono::nanoseconds, passed to
>  * `callback`.
>  * @param callback the TimerCB function to call when the specified
270,272c276,277
<  * @param userdata a pointer that is passed to `callback`.
<  * @returns a timer ID or 0 on failure; call GetError() for more
<  *          information.
---
>  * @returns a timer ID.
>  * @throws Error on failure.
278,279c283,286
<  * @sa SDL_AddTimer
<  * @sa RemoveTimer
---
>  * @cat listener-callback
>  *
>  * @sa listener-callback
>  * @sa RemoveTimer()
283c290,309
<   static_assert(false, "Not implemented");
---
>   using Wrapper = CallbackWrapper<TimerCB>;
>   using Store = KeyValueWrapper<TimerID, TimerCB*>;
> 
>   auto cb = Wrapper::Wrap(std::move(callback));
> 
>   if (TimerID id = SDL_AddTimerNS(
>         interval.count(),
>         [](void* userdata, TimerID timerID, Uint64 interval) -> Uint64 {
>           auto& f = *static_cast<TimerCB*>(userdata);
>           auto next = f(timerID, std::chrono::nanoseconds(interval)).count();
>           // If ask to removal, then remove it
>           if (next == 0) delete Store::release(timerID);
>           return next;
>         },
>         cb)) {
>     Store::Wrap(id, std::move(cb));
>     return id;
>   }
>   delete cb;
>   throw Error{};
298c324,328
< inline void RemoveTimer(TimerID id) { CheckError(SDL_RemoveTimer(id)); }
---
> inline void RemoveTimer(TimerID id)
> {
>   delete KeyValueWrapper<TimerID, TimerCB*>::release(id);
>   CheckError(SDL_RemoveTimer(id));
> }
