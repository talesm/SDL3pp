<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDL3pp: SDL::RWLockBase Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SDL3pp
   </div>
   <div id="projectbrief">A slim C++ wrapper for SDL3</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSDL.html">SDL</a></li><li class="navelem"><a class="el" href="structSDL_1_1RWLockBase.html">RWLockBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structSDL_1_1RWLockBase-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SDL::RWLockBase Struct Reference<div class="ingroups"><a class="el" href="group__Categories.html">Categories</a> &raquo; <a class="el" href="group__CategoriesThreads.html">Threads</a> &raquo; <a class="el" href="group__CategoryMutex.html">Thread Synchronization Primitives</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A mutex that allows read-only threads to run in parallel.  
 <a href="structSDL_1_1RWLockBase.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for SDL::RWLockBase:</div>
<div class="dyncontent">
<div class="center"><img src="structSDL_1_1RWLockBase__inherit__graph.png" border="0" usemap="#aSDL_1_1RWLockBase_inherit__map" alt="Inheritance graph"/></div>
<map name="aSDL_1_1RWLockBase_inherit__map" id="aSDL_1_1RWLockBase_inherit__map">
<area shape="rect" title="A mutex that allows read&#45;only threads to run in parallel." alt="" coords="13,93,152,119"/>
<area shape="rect" href="structSDL_1_1RWLockRef.html" title="Handle to a non owned rWLock." alt="" coords="18,167,147,192"/>
<area shape="poly" title=" " alt="" coords="85,132,85,167,80,167,80,132"/>
<area shape="rect" href="classSDL_1_1Resource.html" title=" " alt="" coords="5,5,160,45"/>
<area shape="poly" title=" " alt="" coords="85,59,85,93,80,93,80,59"/>
<area shape="rect" href="structSDL_1_1RWLock.html" title="Handle to an owned rWLock." alt="" coords="29,240,136,265"/>
<area shape="poly" title=" " alt="" coords="85,206,85,240,80,240,80,206"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for SDL::RWLockBase:</div>
<div class="dyncontent">
<div class="center"><img src="structSDL_1_1RWLockBase__coll__graph.png" border="0" usemap="#aSDL_1_1RWLockBase_coll__map" alt="Collaboration graph"/></div>
<map name="aSDL_1_1RWLockBase_coll__map" id="aSDL_1_1RWLockBase_coll__map">
<area shape="rect" title="A mutex that allows read&#45;only threads to run in parallel." alt="" coords="13,93,152,119"/>
<area shape="rect" href="classSDL_1_1Resource.html" title=" " alt="" coords="5,5,160,45"/>
<area shape="poly" title=" " alt="" coords="85,59,85,93,80,93,80,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa4729f3fad4524d92fc1b90372776c8d" id="r_aa4729f3fad4524d92fc1b90372776c8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RWLockBase.html#aa4729f3fad4524d92fc1b90372776c8d">RWLockBase</a> ()</td></tr>
<tr class="memdesc:aa4729f3fad4524d92fc1b90372776c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new read/write lock.  <br /></td></tr>
<tr class="separator:aa4729f3fad4524d92fc1b90372776c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac692280e73cd0224ce175c1adc7af2fe" id="r_ac692280e73cd0224ce175c1adc7af2fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RWLockBase.html#ac692280e73cd0224ce175c1adc7af2fe">LockForReading</a> ()</td></tr>
<tr class="memdesc:ac692280e73cd0224ce175c1adc7af2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the read/write lock for <em>read only</em> operations.  <br /></td></tr>
<tr class="separator:ac692280e73cd0224ce175c1adc7af2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39564e7e083f62e6cac9e5dcc551a7ec" id="r_a39564e7e083f62e6cac9e5dcc551a7ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RWLockBase.html#a39564e7e083f62e6cac9e5dcc551a7ec">LockForWriting</a> ()</td></tr>
<tr class="memdesc:a39564e7e083f62e6cac9e5dcc551a7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the read/write lock for <em>write</em> operations.  <br /></td></tr>
<tr class="separator:a39564e7e083f62e6cac9e5dcc551a7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8111d1e96fb6c4fcc205ab856f27b1d4" id="r_a8111d1e96fb6c4fcc205ab856f27b1d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RWLockBase.html#a8111d1e96fb6c4fcc205ab856f27b1d4">TryLockForReading</a> ()</td></tr>
<tr class="memdesc:a8111d1e96fb6c4fcc205ab856f27b1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock a read/write lock <em>for reading</em> without blocking.  <br /></td></tr>
<tr class="separator:a8111d1e96fb6c4fcc205ab856f27b1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2915498093b329332f47d9f754d35324" id="r_a2915498093b329332f47d9f754d35324"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RWLockBase.html#a2915498093b329332f47d9f754d35324">TryLockForWriting</a> ()</td></tr>
<tr class="memdesc:a2915498093b329332f47d9f754d35324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock a read/write lock <em>for writing</em> without blocking.  <br /></td></tr>
<tr class="separator:a2915498093b329332f47d9f754d35324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef2423424cae5987e373988b7245460" id="r_aeef2423424cae5987e373988b7245460"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RWLockBase.html#aeef2423424cae5987e373988b7245460">Unlock</a> ()</td></tr>
<tr class="memdesc:aeef2423424cae5987e373988b7245460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the read/write lock.  <br /></td></tr>
<tr class="separator:aeef2423424cae5987e373988b7245460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959604d891dcae230bf4c378c046a21d" id="r_a959604d891dcae230bf4c378c046a21d"><td class="memItemLeft" align="right" valign="top"><a id="a959604d891dcae230bf4c378c046a21d" name="a959604d891dcae230bf4c378c046a21d"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>Resource</b> (T resource={})</td></tr>
<tr class="memdesc:a959604d891dcae230bf4c378c046a21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the underlying resource. <br /></td></tr>
<tr class="separator:a959604d891dcae230bf4c378c046a21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988d47fefd6d7a5f623d3de9fce5ea59" id="r_a988d47fefd6d7a5f623d3de9fce5ea59"><td class="memItemLeft" align="right" valign="top"><a id="a988d47fefd6d7a5f623d3de9fce5ea59" name="a988d47fefd6d7a5f623d3de9fce5ea59"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>Resource</b> (std::nullptr_t)</td></tr>
<tr class="memdesc:a988d47fefd6d7a5f623d3de9fce5ea59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to default ctor. <br /></td></tr>
<tr class="separator:a988d47fefd6d7a5f623d3de9fce5ea59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb3168108af6a8bd0e23edc712b6a09" id="r_afbb3168108af6a8bd0e23edc712b6a09"><td class="memItemLeft" align="right" valign="top"><a id="afbb3168108af6a8bd0e23edc712b6a09" name="afbb3168108af6a8bd0e23edc712b6a09"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>Resource</b> (std::nullopt_t)</td></tr>
<tr class="memdesc:afbb3168108af6a8bd0e23edc712b6a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to default ctor. <br /></td></tr>
<tr class="separator:afbb3168108af6a8bd0e23edc712b6a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcdc46caa3c15a1b9c9a116a6e32382" id="r_afbcdc46caa3c15a1b9c9a116a6e32382"><td class="memItemLeft" align="right" valign="top"><a id="afbcdc46caa3c15a1b9c9a116a6e32382" name="afbcdc46caa3c15a1b9c9a116a6e32382"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Resource</b> (const <a class="el" href="classSDL_1_1Resource.html">Resource</a> &amp;other)=delete</td></tr>
<tr class="separator:afbcdc46caa3c15a1b9c9a116a6e32382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6035b9f529e0e8bdfd7174d0cb4f7cd6" id="r_a6035b9f529e0e8bdfd7174d0cb4f7cd6"><td class="memItemLeft" align="right" valign="top"><a id="a6035b9f529e0e8bdfd7174d0cb4f7cd6" name="a6035b9f529e0e8bdfd7174d0cb4f7cd6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Resource</b> (<a class="el" href="classSDL_1_1Resource.html">Resource</a> &amp;&amp;other)=delete</td></tr>
<tr class="separator:a6035b9f529e0e8bdfd7174d0cb4f7cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSDL_1_1Resource"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSDL_1_1Resource')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSDL_1_1Resource.html">SDL::Resource&lt; SDL_RWLock * &gt;</a></td></tr>
<tr class="memitem:a959604d891dcae230bf4c378c046a21d inherit pub_methods_classSDL_1_1Resource" id="r_a959604d891dcae230bf4c378c046a21d"><td class="memItemLeft" align="right" valign="top">
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>Resource</b> (SDL_RWLock * resource={})</td></tr>
<tr class="memdesc:a959604d891dcae230bf4c378c046a21d inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the underlying resource. <br /></td></tr>
<tr class="separator:a959604d891dcae230bf4c378c046a21d inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988d47fefd6d7a5f623d3de9fce5ea59 inherit pub_methods_classSDL_1_1Resource" id="r_a988d47fefd6d7a5f623d3de9fce5ea59"><td class="memItemLeft" align="right" valign="top">
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>Resource</b> (std::nullptr_t)</td></tr>
<tr class="memdesc:a988d47fefd6d7a5f623d3de9fce5ea59 inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to default ctor. <br /></td></tr>
<tr class="separator:a988d47fefd6d7a5f623d3de9fce5ea59 inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb3168108af6a8bd0e23edc712b6a09 inherit pub_methods_classSDL_1_1Resource" id="r_afbb3168108af6a8bd0e23edc712b6a09"><td class="memItemLeft" align="right" valign="top">
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>Resource</b> (std::nullopt_t)</td></tr>
<tr class="memdesc:afbb3168108af6a8bd0e23edc712b6a09 inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to default ctor. <br /></td></tr>
<tr class="separator:afbb3168108af6a8bd0e23edc712b6a09 inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcdc46caa3c15a1b9c9a116a6e32382 inherit pub_methods_classSDL_1_1Resource" id="r_afbcdc46caa3c15a1b9c9a116a6e32382"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Resource</b> (const <a class="el" href="classSDL_1_1Resource.html">Resource</a> &amp;other)=delete</td></tr>
<tr class="separator:afbcdc46caa3c15a1b9c9a116a6e32382 inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6035b9f529e0e8bdfd7174d0cb4f7cd6 inherit pub_methods_classSDL_1_1Resource" id="r_a6035b9f529e0e8bdfd7174d0cb4f7cd6"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Resource</b> (<a class="el" href="classSDL_1_1Resource.html">Resource</a> &amp;&amp;other)=delete</td></tr>
<tr class="separator:a6035b9f529e0e8bdfd7174d0cb4f7cd6 inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0c941509c77a00db1167982f4fe4c5 inherit pub_methods_classSDL_1_1Resource" id="r_a6c0c941509c77a00db1167982f4fe4c5"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classSDL_1_1Resource.html">Resource</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classSDL_1_1Resource.html">Resource</a> &amp;other)=delete</td></tr>
<tr class="separator:a6c0c941509c77a00db1167982f4fe4c5 inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261c48262a2a2cd5d535bdcd998d4fb6 inherit pub_methods_classSDL_1_1Resource" id="r_a261c48262a2a2cd5d535bdcd998d4fb6"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classSDL_1_1Resource.html">Resource</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classSDL_1_1Resource.html">Resource</a> &amp;&amp;other)=delete</td></tr>
<tr class="separator:a261c48262a2a2cd5d535bdcd998d4fb6 inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1e912fa44fa869f6db73e4ba7720a9 inherit pub_methods_classSDL_1_1Resource" id="r_a0c1e912fa44fa869f6db73e4ba7720a9"><td class="memItemLeft" align="right" valign="top">
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>operator bool</b> () const</td></tr>
<tr class="memdesc:a0c1e912fa44fa869f6db73e4ba7720a9 inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if contains a valid resource. <br /></td></tr>
<tr class="separator:a0c1e912fa44fa869f6db73e4ba7720a9 inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00783ea48f16c278f89467a3ade29b18 inherit pub_methods_classSDL_1_1Resource" id="r_a00783ea48f16c278f89467a3ade29b18"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classSDL_1_1Resource.html">Resource</a> &amp;other) const=default</td></tr>
<tr class="memdesc:a00783ea48f16c278f89467a3ade29b18 inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison. <br /></td></tr>
<tr class="separator:a00783ea48f16c278f89467a3ade29b18 inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a82bc79a7dae41ceb1a25647ae1c0d inherit pub_methods_classSDL_1_1Resource" id="r_ad2a82bc79a7dae41ceb1a25647ae1c0d"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (std::nullopt_t) const</td></tr>
<tr class="memdesc:ad2a82bc79a7dae41ceb1a25647ae1c0d inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison. <br /></td></tr>
<tr class="separator:ad2a82bc79a7dae41ceb1a25647ae1c0d inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab110e6568060a7ae58ab7b29ad68f7fc inherit pub_methods_classSDL_1_1Resource" id="r_ab110e6568060a7ae58ab7b29ad68f7fc"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (std::nullptr_t) const</td></tr>
<tr class="memdesc:ab110e6568060a7ae58ab7b29ad68f7fc inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison. <br /></td></tr>
<tr class="separator:ab110e6568060a7ae58ab7b29ad68f7fc inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab273a0a0285b8eed1f70f5d3759f4167 inherit pub_methods_classSDL_1_1Resource" id="r_ab273a0a0285b8eed1f70f5d3759f4167"><td class="memItemLeft" align="right" valign="top">
constexpr SDL_RWLock *&#160;</td><td class="memItemRight" valign="bottom"><b>get</b> () const</td></tr>
<tr class="memdesc:ab273a0a0285b8eed1f70f5d3759f4167 inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return contained resource;. <br /></td></tr>
<tr class="separator:ab273a0a0285b8eed1f70f5d3759f4167 inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795922875f43cc42165896b02af59d0c inherit pub_methods_classSDL_1_1Resource" id="r_a795922875f43cc42165896b02af59d0c"><td class="memItemLeft" align="right" valign="top">
constexpr SDL_RWLock *&#160;</td><td class="memItemRight" valign="bottom"><b>release</b> (SDL_RWLock * newResource={})</td></tr>
<tr class="memdesc:a795922875f43cc42165896b02af59d0c inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return contained resource and empties or replace value. <br /></td></tr>
<tr class="separator:a795922875f43cc42165896b02af59d0c inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21f6ed563dbdb86c0d6d21c2721c767 inherit pub_methods_classSDL_1_1Resource" id="r_aa21f6ed563dbdb86c0d6d21c2721c767"><td class="memItemLeft" align="right" valign="top">
constexpr const SDL_RWLock *&#160;</td><td class="memItemRight" valign="bottom"><b>operator-&gt;</b> () const</td></tr>
<tr class="memdesc:aa21f6ed563dbdb86c0d6d21c2721c767 inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to fields. <br /></td></tr>
<tr class="separator:aa21f6ed563dbdb86c0d6d21c2721c767 inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bac10eb8bfedf254b67081d767c1a68 inherit pub_methods_classSDL_1_1Resource" id="r_a1bac10eb8bfedf254b67081d767c1a68"><td class="memItemLeft" align="right" valign="top">
constexpr SDL_RWLock *&#160;</td><td class="memItemRight" valign="bottom"><b>operator-&gt;</b> ()</td></tr>
<tr class="memdesc:a1bac10eb8bfedf254b67081d767c1a68 inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to fields. <br /></td></tr>
<tr class="separator:a1bac10eb8bfedf254b67081d767c1a68 inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A rwlock is roughly the same concept as <a class="el" href="structSDL_1_1MutexBase.html" title="A means to serialize access to a resource between threads.">MutexBase</a>, but allows threads that request read-only access to all hold the lock at the same time. If a thread requests write access, it will block until all read-only threads have released the lock, and no one else can hold the thread (for reading or writing) at the same time as the writing thread.</p>
<p>This can be more efficient in cases where several threads need to access data frequently, but changes to that data are rare.</p>
<p>There are other rules that apply to rwlocks that don't apply to mutexes, about how threads are scheduled and when they can be recursively locked. These are documented in the other rwlock functions.</p>
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section user"><dt>Category:</dt><dd><a class="el" href="resource.html">Resource</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RWLock.html" title="Handle to an owned rWLock.">RWLock</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RWLockRef.html" title="Handle to a non owned rWLock.">RWLockRef</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa4729f3fad4524d92fc1b90372776c8d" name="aa4729f3fad4524d92fc1b90372776c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4729f3fad4524d92fc1b90372776c8d">&#9670;&#160;</a></span>RWLockBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SDL::RWLockBase::RWLockBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A read/write lock is useful for situations where you have multiple threads trying to access a resource that is rarely updated. All threads requesting a read-only lock will be allowed to run in parallel; if a thread requests a write lock, it will be provided exclusive access. This makes it safe for multiple threads to use a resource at the same time if they promise not to change it, and when it has to be changed, the rwlock will serve as a gateway to make sure those changes can be made safely.</p>
<p>In the right situation, a rwlock can be more efficient than a mutex, which only lets a single thread proceed at a time, even if it won't be modifying the data.</p>
<p>All newly-created read/write locks begin in the <em>unlocked</em> state.</p>
<p>Calls to <a class="el" href="structSDL_1_1RWLockBase.html#ac692280e73cd0224ce175c1adc7af2fe" title="Lock the read/write lock for read only operations.">RWLockBase.LockForReading()</a> and <a class="el" href="structSDL_1_1RWLockBase.html#a39564e7e083f62e6cac9e5dcc551a7ec" title="Lock the read/write lock for write operations.">RWLockBase.LockForWriting</a> will not return while the rwlock is locked <em>for writing</em> by another thread. See <a class="el" href="structSDL_1_1RWLockBase.html#a8111d1e96fb6c4fcc205ab856f27b1d4" title="Try to lock a read/write lock for reading without blocking.">RWLockBase.TryLockForReading()</a> and <a class="el" href="structSDL_1_1RWLockBase.html#a2915498093b329332f47d9f754d35324" title="Try to lock a read/write lock for writing without blocking.">RWLockBase.TryLockForWriting()</a> to attempt to lock without blocking.</p>
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> read/write locks are only recursive for read-only locks! They are not guaranteed to be fair, or provide access in a FIFO manner! They are not guaranteed to favor writers. You may not lock a rwlock for both read-only and write access at the same time from the same thread (so you can't promote your read-only lock to a write lock without unlocking first).</p>
<dl class="section post"><dt>Postcondition</dt><dd>the initialized and unlocked read/write lock or nullptr on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RWLockBase.html#ac692280e73cd0224ce175c1adc7af2fe" title="Lock the read/write lock for read only operations.">RWLockBase.LockForReading</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RWLockBase.html#a39564e7e083f62e6cac9e5dcc551a7ec" title="Lock the read/write lock for write operations.">RWLockBase.LockForWriting</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RWLockBase.html#a8111d1e96fb6c4fcc205ab856f27b1d4" title="Try to lock a read/write lock for reading without blocking.">RWLockBase.TryLockForReading</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RWLockBase.html#a2915498093b329332f47d9f754d35324" title="Try to lock a read/write lock for writing without blocking.">RWLockBase.TryLockForWriting</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RWLockBase.html#aeef2423424cae5987e373988b7245460" title="Unlock the read/write lock.">RWLockBase.Unlock</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac692280e73cd0224ce175c1adc7af2fe" name="ac692280e73cd0224ce175c1adc7af2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac692280e73cd0224ce175c1adc7af2fe">&#9670;&#160;</a></span>LockForReading()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::RWLockBase::LockForReading </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will block until the rwlock is available, which is to say it is not locked for writing by any other thread. Of all threads waiting to lock the rwlock, all may do so at the same time as long as they are requesting read-only access; if a thread wants to lock for writing, only one may do so at a time, and no other threads, read-only or not, may hold the lock at the same time.</p>
<p>It is legal for the owning thread to lock an already-locked rwlock for reading. It must unlock it the same number of times before it is actually made available for other threads in the system (this is known as a "recursive rwlock").</p>
<p>Note that locking for writing is not recursive (this is only available to read-only locks).</p>
<p>It is illegal to request a read-only lock from a thread that already holds the write lock. Doing so results in undefined behavior. Unlock the write lock before requesting a read-only lock. (But, of course, if you have the write lock, you don't need further locks to read in any case.)</p>
<p>This function does not fail; if rwlock is nullptr, it will return immediately having locked nothing. If the rwlock is valid, this function will always block until it can lock the mutex, and return with it locked.</p>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RWLockBase.html#a39564e7e083f62e6cac9e5dcc551a7ec" title="Lock the read/write lock for write operations.">RWLockBase.LockForWriting</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RWLockBase.html#a8111d1e96fb6c4fcc205ab856f27b1d4" title="Try to lock a read/write lock for reading without blocking.">RWLockBase.TryLockForReading</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RWLockBase.html#aeef2423424cae5987e373988b7245460" title="Unlock the read/write lock.">RWLockBase.Unlock</a> </dd></dl>

</div>
</div>
<a id="a39564e7e083f62e6cac9e5dcc551a7ec" name="a39564e7e083f62e6cac9e5dcc551a7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39564e7e083f62e6cac9e5dcc551a7ec">&#9670;&#160;</a></span>LockForWriting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::RWLockBase::LockForWriting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will block until the rwlock is available, which is to say it is not locked for reading or writing by any other thread. Only one thread may hold the lock when it requests write access; all other threads, whether they also want to write or only want read-only access, must wait until the writer thread has released the lock.</p>
<p>It is illegal for the owning thread to lock an already-locked rwlock for writing (read-only may be locked recursively, writing can not). Doing so results in undefined behavior.</p>
<p>It is illegal to request a write lock from a thread that already holds a read-only lock. Doing so results in undefined behavior. Unlock the read-only lock before requesting a write lock.</p>
<p>This function does not fail; if rwlock is nullptr, it will return immediately having locked nothing. If the rwlock is valid, this function will always block until it can lock the mutex, and return with it locked.</p>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RWLockBase.html#ac692280e73cd0224ce175c1adc7af2fe" title="Lock the read/write lock for read only operations.">RWLockBase.LockForReading</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RWLockBase.html#a2915498093b329332f47d9f754d35324" title="Try to lock a read/write lock for writing without blocking.">RWLockBase.TryLockForWriting</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RWLockBase.html#aeef2423424cae5987e373988b7245460" title="Unlock the read/write lock.">RWLockBase.Unlock</a> </dd></dl>

</div>
</div>
<a id="a8111d1e96fb6c4fcc205ab856f27b1d4" name="a8111d1e96fb6c4fcc205ab856f27b1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8111d1e96fb6c4fcc205ab856f27b1d4">&#9670;&#160;</a></span>TryLockForReading()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::RWLockBase::TryLockForReading </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This works just like <a class="el" href="structSDL_1_1RWLockBase.html#ac692280e73cd0224ce175c1adc7af2fe" title="Lock the read/write lock for read only operations.">RWLockBase.LockForReading()</a>, but if the rwlock is not available, then this function returns false immediately.</p>
<p>This technique is useful if you need access to a resource but don't want to wait for it, and will return to it to try again later.</p>
<p>Trying to lock for read-only access can succeed if other threads are holding read-only locks, as this won't prevent access.</p>
<p>This function returns true if passed a nullptr rwlock.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false if the lock would block.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RWLockBase.html#ac692280e73cd0224ce175c1adc7af2fe" title="Lock the read/write lock for read only operations.">RWLockBase.LockForReading</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RWLockBase.html#a2915498093b329332f47d9f754d35324" title="Try to lock a read/write lock for writing without blocking.">RWLockBase.TryLockForWriting</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RWLockBase.html#aeef2423424cae5987e373988b7245460" title="Unlock the read/write lock.">RWLockBase.Unlock</a> </dd></dl>

</div>
</div>
<a id="a2915498093b329332f47d9f754d35324" name="a2915498093b329332f47d9f754d35324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2915498093b329332f47d9f754d35324">&#9670;&#160;</a></span>TryLockForWriting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::RWLockBase::TryLockForWriting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This works just like <a class="el" href="structSDL_1_1RWLockBase.html#a39564e7e083f62e6cac9e5dcc551a7ec" title="Lock the read/write lock for write operations.">RWLockBase.LockForWriting()</a>, but if the rwlock is not available, then this function returns false immediately.</p>
<p>This technique is useful if you need exclusive access to a resource but don't want to wait for it, and will return to it to try again later.</p>
<p>It is illegal for the owning thread to lock an already-locked rwlock for writing (read-only may be locked recursively, writing can not). Doing so results in undefined behavior.</p>
<p>It is illegal to request a write lock from a thread that already holds a read-only lock. Doing so results in undefined behavior. Unlock the read-only lock before requesting a write lock.</p>
<p>This function returns true if passed a nullptr rwlock.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false if the lock would block.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RWLockBase.html#a39564e7e083f62e6cac9e5dcc551a7ec" title="Lock the read/write lock for write operations.">RWLockBase.LockForWriting</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RWLockBase.html#a8111d1e96fb6c4fcc205ab856f27b1d4" title="Try to lock a read/write lock for reading without blocking.">RWLockBase.TryLockForReading</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RWLockBase.html#aeef2423424cae5987e373988b7245460" title="Unlock the read/write lock.">RWLockBase.Unlock</a> </dd></dl>

</div>
</div>
<a id="aeef2423424cae5987e373988b7245460" name="aeef2423424cae5987e373988b7245460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef2423424cae5987e373988b7245460">&#9670;&#160;</a></span>Unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::RWLockBase::Unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use this function to unlock the rwlock, whether it was locked for read-only or write operations.</p>
<p>It is legal for the owning thread to lock an already-locked read-only lock. It must unlock it the same number of times before it is actually made available for other threads in the system (this is known as a "recursive
rwlock").</p>
<p>It is illegal to unlock a rwlock that has not been locked by the current thread, and doing so results in undefined behavior.</p>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RWLockBase.html#ac692280e73cd0224ce175c1adc7af2fe" title="Lock the read/write lock for read only operations.">RWLockBase.LockForReading</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RWLockBase.html#a39564e7e083f62e6cac9e5dcc551a7ec" title="Lock the read/write lock for write operations.">RWLockBase.LockForWriting</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RWLockBase.html#a8111d1e96fb6c4fcc205ab856f27b1d4" title="Try to lock a read/write lock for reading without blocking.">RWLockBase.TryLockForReading</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RWLockBase.html#a2915498093b329332f47d9f754d35324" title="Try to lock a read/write lock for writing without blocking.">RWLockBase.TryLockForWriting</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>SDL3pp/<a class="el" href="SDL3pp__mutex_8h_source.html">SDL3pp_mutex.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
