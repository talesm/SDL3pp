<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDL3pp: 3D Rendering and GPU Compute</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SDL3pp
   </div>
   <div id="projectbrief">A slim C++ wrapper for SDL3</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">3D Rendering and GPU Compute<div class="ingroups"><a class="el" href="group__Categories.html">Categories</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>The GPU API offers a cross-platform way for apps to talk to modern graphics hardware.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1GPUDeviceParam.html">SDL::GPUDeviceParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely wrap <a class="el" href="classSDL_1_1GPUDevice.html" title="An opaque handle representing the SDL_GPU context.">GPUDevice</a> for non owning parameters.  <a href="structSDL_1_1GPUDeviceParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1GPUBuffer.html">SDL::GPUBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque handle representing a buffer.  <a href="classSDL_1_1GPUBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1GPUTransferBuffer.html">SDL::GPUTransferBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque handle representing a transfer buffer.  <a href="classSDL_1_1GPUTransferBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1GPUTexture.html">SDL::GPUTexture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque handle representing a texture.  <a href="classSDL_1_1GPUTexture.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1GPUSampler.html">SDL::GPUSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque handle representing a sampler.  <a href="classSDL_1_1GPUSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1GPUShader.html">SDL::GPUShader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque handle representing a compiled shader object.  <a href="classSDL_1_1GPUShader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1GPUComputePipeline.html">SDL::GPUComputePipeline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque handle representing a compute pipeline.  <a href="classSDL_1_1GPUComputePipeline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html">SDL::GPUGraphicsPipeline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque handle representing a graphics pipeline.  <a href="classSDL_1_1GPUGraphicsPipeline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1GPURenderPass.html">SDL::GPURenderPass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque handle representing a render pass.  <a href="classSDL_1_1GPURenderPass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1GPUComputePass.html">SDL::GPUComputePass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque handle representing a compute pass.  <a href="classSDL_1_1GPUComputePass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1GPUCopyPass.html">SDL::GPUCopyPass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque handle representing a copy pass.  <a href="classSDL_1_1GPUCopyPass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1GPUCommandBuffer.html">SDL::GPUCommandBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque handle representing a command buffer.  <a href="classSDL_1_1GPUCommandBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1GPUDevice.html">SDL::GPUDevice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque handle representing the SDL_GPU context.  <a href="classSDL_1_1GPUDevice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1GPUDeviceRef.html">SDL::GPUDeviceRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semi-safe reference for <a class="el" href="classSDL_1_1GPUDevice.html" title="An opaque handle representing the SDL_GPU context.">GPUDevice</a>.  <a href="structSDL_1_1GPUDeviceRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac9a40e8e5a66e5269284c096f0908a74" id="r_gac9a40e8e5a66e5269284c096f0908a74"><td class="memItemLeft" align="right" valign="top"><a id="gac9a40e8e5a66e5269284c096f0908a74" name="gac9a40e8e5a66e5269284c096f0908a74"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::GPUDeviceRaw</b> = SDL_GPUDevice *</td></tr>
<tr class="memdesc:gac9a40e8e5a66e5269284c096f0908a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to raw representation for <a class="el" href="classSDL_1_1GPUDevice.html" title="An opaque handle representing the SDL_GPU context.">GPUDevice</a>. <br /></td></tr>
<tr class="separator:gac9a40e8e5a66e5269284c096f0908a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga729f924587e663dffcd630a594e14396" id="r_ga729f924587e663dffcd630a594e14396"><td class="memItemLeft" align="right" valign="top"><a id="ga729f924587e663dffcd630a594e14396" name="ga729f924587e663dffcd630a594e14396"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::GPUBufferRaw</b> = SDL_GPUBuffer *</td></tr>
<tr class="memdesc:ga729f924587e663dffcd630a594e14396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to raw representation for <a class="el" href="classSDL_1_1GPUBuffer.html" title="An opaque handle representing a buffer.">GPUBuffer</a>. <br /></td></tr>
<tr class="separator:ga729f924587e663dffcd630a594e14396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86547c0a595278b675012ce418d2b733" id="r_ga86547c0a595278b675012ce418d2b733"><td class="memItemLeft" align="right" valign="top"><a id="ga86547c0a595278b675012ce418d2b733" name="ga86547c0a595278b675012ce418d2b733"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::GPUTransferBufferRaw</b> = SDL_GPUTransferBuffer *</td></tr>
<tr class="memdesc:ga86547c0a595278b675012ce418d2b733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to raw representation for <a class="el" href="classSDL_1_1GPUTransferBuffer.html" title="An opaque handle representing a transfer buffer.">GPUTransferBuffer</a>. <br /></td></tr>
<tr class="separator:ga86547c0a595278b675012ce418d2b733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07bab3d86cb28ae9761a1c91b04c285f" id="r_ga07bab3d86cb28ae9761a1c91b04c285f"><td class="memItemLeft" align="right" valign="top"><a id="ga07bab3d86cb28ae9761a1c91b04c285f" name="ga07bab3d86cb28ae9761a1c91b04c285f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::GPUTextureRaw</b> = SDL_GPUTexture *</td></tr>
<tr class="memdesc:ga07bab3d86cb28ae9761a1c91b04c285f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to raw representation for <a class="el" href="classSDL_1_1GPUTexture.html" title="An opaque handle representing a texture.">GPUTexture</a>. <br /></td></tr>
<tr class="separator:ga07bab3d86cb28ae9761a1c91b04c285f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga366adc83efb04dcfb7e746a5cdfe6471" id="r_ga366adc83efb04dcfb7e746a5cdfe6471"><td class="memItemLeft" align="right" valign="top"><a id="ga366adc83efb04dcfb7e746a5cdfe6471" name="ga366adc83efb04dcfb7e746a5cdfe6471"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::GPUSamplerRaw</b> = SDL_GPUSampler *</td></tr>
<tr class="memdesc:ga366adc83efb04dcfb7e746a5cdfe6471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to raw representation for <a class="el" href="classSDL_1_1GPUSampler.html" title="An opaque handle representing a sampler.">GPUSampler</a>. <br /></td></tr>
<tr class="separator:ga366adc83efb04dcfb7e746a5cdfe6471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ff87d9f48743d56530ccc6d72145aae" id="r_ga6ff87d9f48743d56530ccc6d72145aae"><td class="memItemLeft" align="right" valign="top"><a id="ga6ff87d9f48743d56530ccc6d72145aae" name="ga6ff87d9f48743d56530ccc6d72145aae"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::GPUShaderRaw</b> = SDL_GPUShader *</td></tr>
<tr class="memdesc:ga6ff87d9f48743d56530ccc6d72145aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to raw representation for <a class="el" href="classSDL_1_1GPUShader.html" title="An opaque handle representing a compiled shader object.">GPUShader</a>. <br /></td></tr>
<tr class="separator:ga6ff87d9f48743d56530ccc6d72145aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf85ebfd104151bd637dc16dd6112a7c6" id="r_gaf85ebfd104151bd637dc16dd6112a7c6"><td class="memItemLeft" align="right" valign="top"><a id="gaf85ebfd104151bd637dc16dd6112a7c6" name="gaf85ebfd104151bd637dc16dd6112a7c6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::GPUComputePipelineRaw</b> = SDL_GPUComputePipeline *</td></tr>
<tr class="memdesc:gaf85ebfd104151bd637dc16dd6112a7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to raw representation for <a class="el" href="classSDL_1_1GPUComputePipeline.html" title="An opaque handle representing a compute pipeline.">GPUComputePipeline</a>. <br /></td></tr>
<tr class="separator:gaf85ebfd104151bd637dc16dd6112a7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3269b06a4978f6c12983f302f5f13804" id="r_ga3269b06a4978f6c12983f302f5f13804"><td class="memItemLeft" align="right" valign="top"><a id="ga3269b06a4978f6c12983f302f5f13804" name="ga3269b06a4978f6c12983f302f5f13804"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::GPUGraphicsPipelineRaw</b> = SDL_GPUGraphicsPipeline *</td></tr>
<tr class="memdesc:ga3269b06a4978f6c12983f302f5f13804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to raw representation for <a class="el" href="classSDL_1_1GPUGraphicsPipeline.html" title="An opaque handle representing a graphics pipeline.">GPUGraphicsPipeline</a>. <br /></td></tr>
<tr class="separator:ga3269b06a4978f6c12983f302f5f13804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26b1a5bd15ce876eda72579d8ed135a7" id="r_ga26b1a5bd15ce876eda72579d8ed135a7"><td class="memItemLeft" align="right" valign="top"><a id="ga26b1a5bd15ce876eda72579d8ed135a7" name="ga26b1a5bd15ce876eda72579d8ed135a7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::GPUCommandBufferRaw</b> = SDL_GPUCommandBuffer *</td></tr>
<tr class="memdesc:ga26b1a5bd15ce876eda72579d8ed135a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to raw representation for <a class="el" href="classSDL_1_1GPUCommandBuffer.html" title="An opaque handle representing a command buffer.">GPUCommandBuffer</a>. <br /></td></tr>
<tr class="separator:ga26b1a5bd15ce876eda72579d8ed135a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac06f2ed7f0c1bb91f3c7eb7c67256e9e" id="r_gac06f2ed7f0c1bb91f3c7eb7c67256e9e"><td class="memItemLeft" align="right" valign="top"><a id="gac06f2ed7f0c1bb91f3c7eb7c67256e9e" name="gac06f2ed7f0c1bb91f3c7eb7c67256e9e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::GPURenderPassRaw</b> = SDL_GPURenderPass *</td></tr>
<tr class="memdesc:gac06f2ed7f0c1bb91f3c7eb7c67256e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to raw representation for <a class="el" href="classSDL_1_1GPURenderPass.html" title="An opaque handle representing a render pass.">GPURenderPass</a>. <br /></td></tr>
<tr class="separator:gac06f2ed7f0c1bb91f3c7eb7c67256e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb89f0c3d9268cbde37dc6ea529d9f4c" id="r_gaeb89f0c3d9268cbde37dc6ea529d9f4c"><td class="memItemLeft" align="right" valign="top"><a id="gaeb89f0c3d9268cbde37dc6ea529d9f4c" name="gaeb89f0c3d9268cbde37dc6ea529d9f4c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::GPUComputePassRaw</b> = SDL_GPUComputePass *</td></tr>
<tr class="memdesc:gaeb89f0c3d9268cbde37dc6ea529d9f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to raw representation for <a class="el" href="classSDL_1_1GPUComputePass.html" title="An opaque handle representing a compute pass.">GPUComputePass</a>. <br /></td></tr>
<tr class="separator:gaeb89f0c3d9268cbde37dc6ea529d9f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b3a7fcd4b7ed9a5ae1d2da27520f87e" id="r_ga6b3a7fcd4b7ed9a5ae1d2da27520f87e"><td class="memItemLeft" align="right" valign="top"><a id="ga6b3a7fcd4b7ed9a5ae1d2da27520f87e" name="ga6b3a7fcd4b7ed9a5ae1d2da27520f87e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::GPUCopyPassRaw</b> = SDL_GPUCopyPass *</td></tr>
<tr class="memdesc:ga6b3a7fcd4b7ed9a5ae1d2da27520f87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to raw representation for <a class="el" href="classSDL_1_1GPUCopyPass.html" title="An opaque handle representing a copy pass.">GPUCopyPass</a>. <br /></td></tr>
<tr class="separator:ga6b3a7fcd4b7ed9a5ae1d2da27520f87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cb3830a3ade4303d47a017993de4fea" id="r_ga6cb3830a3ade4303d47a017993de4fea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga6cb3830a3ade4303d47a017993de4fea">SDL::GPUBufferCreateInfo</a> = SDL_GPUBufferCreateInfo</td></tr>
<tr class="memdesc:ga6cb3830a3ade4303d47a017993de4fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying the parameters of a buffer.  <br /></td></tr>
<tr class="separator:ga6cb3830a3ade4303d47a017993de4fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf392df5f8790bf73f828ca3e1f21bd5" id="r_gabf392df5f8790bf73f828ca3e1f21bd5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gabf392df5f8790bf73f828ca3e1f21bd5">SDL::GPUTransferBufferCreateInfo</a> = SDL_GPUTransferBufferCreateInfo</td></tr>
<tr class="memdesc:gabf392df5f8790bf73f828ca3e1f21bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying the parameters of a transfer buffer.  <br /></td></tr>
<tr class="separator:gabf392df5f8790bf73f828ca3e1f21bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87fcb53cd9c731a4a4f3c7c10a5edb6a" id="r_ga87fcb53cd9c731a4a4f3c7c10a5edb6a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga87fcb53cd9c731a4a4f3c7c10a5edb6a">SDL::GPUTextureCreateInfo</a> = SDL_GPUTextureCreateInfo</td></tr>
<tr class="memdesc:ga87fcb53cd9c731a4a4f3c7c10a5edb6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying the parameters of a texture.  <br /></td></tr>
<tr class="separator:ga87fcb53cd9c731a4a4f3c7c10a5edb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9905b04780e8798c8cd2bf18a29bff27" id="r_ga9905b04780e8798c8cd2bf18a29bff27"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga9905b04780e8798c8cd2bf18a29bff27">SDL::GPUSamplerCreateInfo</a> = SDL_GPUSamplerCreateInfo</td></tr>
<tr class="memdesc:ga9905b04780e8798c8cd2bf18a29bff27"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying the parameters of a sampler.  <br /></td></tr>
<tr class="separator:ga9905b04780e8798c8cd2bf18a29bff27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec6e01546fef70020c8f7b44da82be99" id="r_gaec6e01546fef70020c8f7b44da82be99"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaec6e01546fef70020c8f7b44da82be99">SDL::GPUShaderCreateInfo</a> = SDL_GPUShaderCreateInfo</td></tr>
<tr class="memdesc:gaec6e01546fef70020c8f7b44da82be99"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying code and metadata for creating a shader object.  <br /></td></tr>
<tr class="separator:gaec6e01546fef70020c8f7b44da82be99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9baa44a9f7478858ee1ac28037e0574f" id="r_ga9baa44a9f7478858ee1ac28037e0574f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga9baa44a9f7478858ee1ac28037e0574f">SDL::GPUComputePipelineCreateInfo</a> = SDL_GPUComputePipelineCreateInfo</td></tr>
<tr class="memdesc:ga9baa44a9f7478858ee1ac28037e0574f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying the parameters of a compute pipeline state.  <br /></td></tr>
<tr class="separator:ga9baa44a9f7478858ee1ac28037e0574f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60d171e0d2bee691d934e2275b2bf23b" id="r_ga60d171e0d2bee691d934e2275b2bf23b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga60d171e0d2bee691d934e2275b2bf23b">SDL::GPUGraphicsPipelineCreateInfo</a> = SDL_GPUGraphicsPipelineCreateInfo</td></tr>
<tr class="memdesc:ga60d171e0d2bee691d934e2275b2bf23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying the parameters of a graphics pipeline state.  <br /></td></tr>
<tr class="separator:ga60d171e0d2bee691d934e2275b2bf23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf80d3281c271f2f02de8d8e14648fe20" id="r_gaf80d3281c271f2f02de8d8e14648fe20"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf80d3281c271f2f02de8d8e14648fe20">SDL::GPUViewport</a> = SDL_GPUViewport</td></tr>
<tr class="memdesc:gaf80d3281c271f2f02de8d8e14648fe20"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying a viewport.  <br /></td></tr>
<tr class="separator:gaf80d3281c271f2f02de8d8e14648fe20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga698bbc29bd1e44bec1e2b87ce3a81dbb" id="r_ga698bbc29bd1e44bec1e2b87ce3a81dbb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga698bbc29bd1e44bec1e2b87ce3a81dbb">SDL::GPUBufferBinding</a> = SDL_GPUBufferBinding</td></tr>
<tr class="memdesc:ga698bbc29bd1e44bec1e2b87ce3a81dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying parameters in a buffer binding call.  <br /></td></tr>
<tr class="separator:ga698bbc29bd1e44bec1e2b87ce3a81dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec587594b432d13ab2ddd78ad77342a7" id="r_gaec587594b432d13ab2ddd78ad77342a7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaec587594b432d13ab2ddd78ad77342a7">SDL::GPUIndexElementSize</a> = SDL_GPUIndexElementSize</td></tr>
<tr class="memdesc:gaec587594b432d13ab2ddd78ad77342a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the size of elements in an index buffer.  <br /></td></tr>
<tr class="separator:gaec587594b432d13ab2ddd78ad77342a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86e968acd12b623cb7b5056c323285b3" id="r_ga86e968acd12b623cb7b5056c323285b3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga86e968acd12b623cb7b5056c323285b3">SDL::GPUTextureSamplerBinding</a> = SDL_GPUTextureSamplerBinding</td></tr>
<tr class="memdesc:ga86e968acd12b623cb7b5056c323285b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying parameters in a sampler binding call.  <br /></td></tr>
<tr class="separator:ga86e968acd12b623cb7b5056c323285b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3310186554cb88f7b1a1599171aabdf" id="r_gac3310186554cb88f7b1a1599171aabdf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gac3310186554cb88f7b1a1599171aabdf">SDL::GPUBufferRegion</a> = SDL_GPUBufferRegion</td></tr>
<tr class="memdesc:gac3310186554cb88f7b1a1599171aabdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying a region of a buffer.  <br /></td></tr>
<tr class="separator:gac3310186554cb88f7b1a1599171aabdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dac1b3fb8a5a1ba34f6d99b84e81792" id="r_ga5dac1b3fb8a5a1ba34f6d99b84e81792"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga5dac1b3fb8a5a1ba34f6d99b84e81792">SDL::GPUTextureLocation</a> = SDL_GPUTextureLocation</td></tr>
<tr class="memdesc:ga5dac1b3fb8a5a1ba34f6d99b84e81792"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying a location in a texture.  <br /></td></tr>
<tr class="separator:ga5dac1b3fb8a5a1ba34f6d99b84e81792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b24b7fc30f477db4a44bc2f1637bd35" id="r_ga6b24b7fc30f477db4a44bc2f1637bd35"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga6b24b7fc30f477db4a44bc2f1637bd35">SDL::GPUBufferLocation</a> = SDL_GPUBufferLocation</td></tr>
<tr class="memdesc:ga6b24b7fc30f477db4a44bc2f1637bd35"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying a location in a buffer.  <br /></td></tr>
<tr class="separator:ga6b24b7fc30f477db4a44bc2f1637bd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a4272ec9f67111e0956cfe1f999f903" id="r_ga0a4272ec9f67111e0956cfe1f999f903"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga0a4272ec9f67111e0956cfe1f999f903">SDL::GPUTextureRegion</a> = SDL_GPUTextureRegion</td></tr>
<tr class="memdesc:ga0a4272ec9f67111e0956cfe1f999f903"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying a region of a texture.  <br /></td></tr>
<tr class="separator:ga0a4272ec9f67111e0956cfe1f999f903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62c3161f89c494e71fef4b8bbd471167" id="r_ga62c3161f89c494e71fef4b8bbd471167"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga62c3161f89c494e71fef4b8bbd471167">SDL::GPUTextureTransferInfo</a> = SDL_GPUTextureTransferInfo</td></tr>
<tr class="memdesc:ga62c3161f89c494e71fef4b8bbd471167"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying parameters related to transferring data to or from a texture.  <br /></td></tr>
<tr class="separator:ga62c3161f89c494e71fef4b8bbd471167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9faa5600aabe5cabf35cbdf09851af6d" id="r_ga9faa5600aabe5cabf35cbdf09851af6d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga9faa5600aabe5cabf35cbdf09851af6d">SDL::GPUTransferBufferLocation</a> = SDL_GPUTransferBufferLocation</td></tr>
<tr class="memdesc:ga9faa5600aabe5cabf35cbdf09851af6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying a location in a transfer buffer.  <br /></td></tr>
<tr class="separator:ga9faa5600aabe5cabf35cbdf09851af6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26904510dffa9db5b09c79637b00edbc" id="r_ga26904510dffa9db5b09c79637b00edbc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga26904510dffa9db5b09c79637b00edbc">SDL::GPUColorTargetInfo</a> = SDL_GPUColorTargetInfo</td></tr>
<tr class="memdesc:ga26904510dffa9db5b09c79637b00edbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying the parameters of a color target used by a render pass.  <br /></td></tr>
<tr class="separator:ga26904510dffa9db5b09c79637b00edbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28e62eba4af4c55395ef3cecf7fc0ebc" id="r_ga28e62eba4af4c55395ef3cecf7fc0ebc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga28e62eba4af4c55395ef3cecf7fc0ebc">SDL::GPUDepthStencilTargetInfo</a> = SDL_GPUDepthStencilTargetInfo</td></tr>
<tr class="memdesc:ga28e62eba4af4c55395ef3cecf7fc0ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying the parameters of a depth-stencil target used by a render pass.  <br /></td></tr>
<tr class="separator:ga28e62eba4af4c55395ef3cecf7fc0ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4da71fb9f200b3a944c027d10c42675" id="r_gaa4da71fb9f200b3a944c027d10c42675"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa4da71fb9f200b3a944c027d10c42675">SDL::GPUStorageTextureReadWriteBinding</a> = SDL_GPUStorageTextureReadWriteBinding</td></tr>
<tr class="memdesc:gaa4da71fb9f200b3a944c027d10c42675"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying parameters related to binding textures in a compute pass.  <br /></td></tr>
<tr class="separator:gaa4da71fb9f200b3a944c027d10c42675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1bd097ca5ba900d062e99162e62ab2c" id="r_gad1bd097ca5ba900d062e99162e62ab2c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gad1bd097ca5ba900d062e99162e62ab2c">SDL::GPUStorageBufferReadWriteBinding</a> = SDL_GPUStorageBufferReadWriteBinding</td></tr>
<tr class="memdesc:gad1bd097ca5ba900d062e99162e62ab2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying parameters related to binding buffers in a compute pass.  <br /></td></tr>
<tr class="separator:gad1bd097ca5ba900d062e99162e62ab2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabb30629d61cc6f590279354030c3f73" id="r_gaabb30629d61cc6f590279354030c3f73"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaabb30629d61cc6f590279354030c3f73">SDL::GPUBlitInfo</a> = SDL_GPUBlitInfo</td></tr>
<tr class="memdesc:gaabb30629d61cc6f590279354030c3f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure containing parameters for a blit command.  <br /></td></tr>
<tr class="separator:gaabb30629d61cc6f590279354030c3f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb64f32b16e58d8fcfc1baf718975d3b" id="r_gaeb64f32b16e58d8fcfc1baf718975d3b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaeb64f32b16e58d8fcfc1baf718975d3b">SDL::GPUFence</a> = SDL_GPUFence</td></tr>
<tr class="memdesc:gaeb64f32b16e58d8fcfc1baf718975d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque handle representing a fence.  <br /></td></tr>
<tr class="separator:gaeb64f32b16e58d8fcfc1baf718975d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6257b71ec0a6c6cfa147db1ee7f0cc2c" id="r_ga6257b71ec0a6c6cfa147db1ee7f0cc2c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">SDL::GPUShaderFormat</a> = <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a></td></tr>
<tr class="memdesc:ga6257b71ec0a6c6cfa147db1ee7f0cc2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the format of shader code.  <br /></td></tr>
<tr class="separator:ga6257b71ec0a6c6cfa147db1ee7f0cc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa555f571dd4b1b9e5af82ee607a71fc5" id="r_gaa555f571dd4b1b9e5af82ee607a71fc5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa555f571dd4b1b9e5af82ee607a71fc5">SDL::GPUSwapchainComposition</a> = SDL_GPUSwapchainComposition</td></tr>
<tr class="memdesc:gaa555f571dd4b1b9e5af82ee607a71fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the texture format and colorspace of the swapchain textures.  <br /></td></tr>
<tr class="separator:gaa555f571dd4b1b9e5af82ee607a71fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga695f2e29e8b1cc9061a08a95ae9690e5" id="r_ga695f2e29e8b1cc9061a08a95ae9690e5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga695f2e29e8b1cc9061a08a95ae9690e5">SDL::GPUPresentMode</a> = SDL_GPUPresentMode</td></tr>
<tr class="memdesc:ga695f2e29e8b1cc9061a08a95ae9690e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the timing that will be used to present swapchain textures to the OS.  <br /></td></tr>
<tr class="separator:ga695f2e29e8b1cc9061a08a95ae9690e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac38f30d58087639f21fb55594e935cbc" id="r_gac38f30d58087639f21fb55594e935cbc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">SDL::GPUTextureFormat</a> = SDL_GPUTextureFormat</td></tr>
<tr class="memdesc:gac38f30d58087639f21fb55594e935cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the pixel format of a texture.  <br /></td></tr>
<tr class="separator:gac38f30d58087639f21fb55594e935cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga624b29173aac1a009aa85c14f46024a3" id="r_ga624b29173aac1a009aa85c14f46024a3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga624b29173aac1a009aa85c14f46024a3">SDL::GPUTextureType</a> = SDL_GPUTextureType</td></tr>
<tr class="memdesc:ga624b29173aac1a009aa85c14f46024a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the type of a texture.  <br /></td></tr>
<tr class="separator:ga624b29173aac1a009aa85c14f46024a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a847c301baaf527c8ba644f0f55a59e" id="r_ga5a847c301baaf527c8ba644f0f55a59e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga5a847c301baaf527c8ba644f0f55a59e">SDL::GPUTextureUsageFlags</a> = <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a></td></tr>
<tr class="memdesc:ga5a847c301baaf527c8ba644f0f55a59e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies how a texture is intended to be used by the client.  <br /></td></tr>
<tr class="separator:ga5a847c301baaf527c8ba644f0f55a59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5265d3385d1ddc106c614016bee759d9" id="r_ga5265d3385d1ddc106c614016bee759d9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga5265d3385d1ddc106c614016bee759d9">SDL::GPUSampleCount</a> = SDL_GPUSampleCount</td></tr>
<tr class="memdesc:ga5265d3385d1ddc106c614016bee759d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the sample count of a texture.  <br /></td></tr>
<tr class="separator:ga5265d3385d1ddc106c614016bee759d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa55e8850ba84241f691eec7b68c58bb3" id="r_gaa55e8850ba84241f691eec7b68c58bb3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa55e8850ba84241f691eec7b68c58bb3">SDL::GPUPrimitiveType</a> = SDL_GPUPrimitiveType</td></tr>
<tr class="memdesc:gaa55e8850ba84241f691eec7b68c58bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the primitive topology of a graphics pipeline.  <br /></td></tr>
<tr class="separator:gaa55e8850ba84241f691eec7b68c58bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5682b03e950adda302469fb07485f2a" id="r_gaf5682b03e950adda302469fb07485f2a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf5682b03e950adda302469fb07485f2a">SDL::GPULoadOp</a> = SDL_GPULoadOp</td></tr>
<tr class="memdesc:gaf5682b03e950adda302469fb07485f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies how the contents of a texture attached to a render pass are treated at the beginning of the render pass.  <br /></td></tr>
<tr class="separator:gaf5682b03e950adda302469fb07485f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaace1f8aa9176f849a325dee8d65046f4" id="r_gaace1f8aa9176f849a325dee8d65046f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaace1f8aa9176f849a325dee8d65046f4">SDL::GPUStoreOp</a> = SDL_GPUStoreOp</td></tr>
<tr class="memdesc:gaace1f8aa9176f849a325dee8d65046f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies how the contents of a texture attached to a render pass are treated at the end of the render pass.  <br /></td></tr>
<tr class="separator:gaace1f8aa9176f849a325dee8d65046f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9818c5cd42d048d0b4597bedd340ea7a" id="r_ga9818c5cd42d048d0b4597bedd340ea7a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga9818c5cd42d048d0b4597bedd340ea7a">SDL::GPUCubeMapFace</a> = SDL_GPUCubeMapFace</td></tr>
<tr class="memdesc:ga9818c5cd42d048d0b4597bedd340ea7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the face of a cube map.  <br /></td></tr>
<tr class="separator:ga9818c5cd42d048d0b4597bedd340ea7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga335d74d2f1cb0811156d8356904fb710" id="r_ga335d74d2f1cb0811156d8356904fb710"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga335d74d2f1cb0811156d8356904fb710">SDL::GPUBufferUsageFlags</a> = <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a></td></tr>
<tr class="memdesc:ga335d74d2f1cb0811156d8356904fb710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies how a buffer is intended to be used by the client.  <br /></td></tr>
<tr class="separator:ga335d74d2f1cb0811156d8356904fb710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa77f5c65445135e6df84bda3201c49db" id="r_gaa77f5c65445135e6df84bda3201c49db"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa77f5c65445135e6df84bda3201c49db">SDL::GPUTransferBufferUsage</a> = SDL_GPUTransferBufferUsage</td></tr>
<tr class="memdesc:gaa77f5c65445135e6df84bda3201c49db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies how a transfer buffer is intended to be used by the client.  <br /></td></tr>
<tr class="separator:gaa77f5c65445135e6df84bda3201c49db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dbe4dbc43d67929db39c145ccaa5e20" id="r_ga5dbe4dbc43d67929db39c145ccaa5e20"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga5dbe4dbc43d67929db39c145ccaa5e20">SDL::GPUShaderStage</a> = SDL_GPUShaderStage</td></tr>
<tr class="memdesc:ga5dbe4dbc43d67929db39c145ccaa5e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies which stage a shader program corresponds to.  <br /></td></tr>
<tr class="separator:ga5dbe4dbc43d67929db39c145ccaa5e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ee7085f0bec0d39da3df52edb34e29d" id="r_ga7ee7085f0bec0d39da3df52edb34e29d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">SDL::GPUVertexElementFormat</a> = SDL_GPUVertexElementFormat</td></tr>
<tr class="memdesc:ga7ee7085f0bec0d39da3df52edb34e29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the format of a vertex attribute.  <br /></td></tr>
<tr class="separator:ga7ee7085f0bec0d39da3df52edb34e29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0c935ed3eb7b0a1f180472c021a91e3" id="r_gaf0c935ed3eb7b0a1f180472c021a91e3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf0c935ed3eb7b0a1f180472c021a91e3">SDL::GPUVertexInputRate</a> = SDL_GPUVertexInputRate</td></tr>
<tr class="memdesc:gaf0c935ed3eb7b0a1f180472c021a91e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the rate at which vertex attributes are pulled from buffers.  <br /></td></tr>
<tr class="separator:gaf0c935ed3eb7b0a1f180472c021a91e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55ba5426913cb519b5a736f91e5a36c7" id="r_ga55ba5426913cb519b5a736f91e5a36c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga55ba5426913cb519b5a736f91e5a36c7">SDL::GPUFillMode</a> = SDL_GPUFillMode</td></tr>
<tr class="memdesc:ga55ba5426913cb519b5a736f91e5a36c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the fill mode of the graphics pipeline.  <br /></td></tr>
<tr class="separator:ga55ba5426913cb519b5a736f91e5a36c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga776730df3e6b57476ae9773d3848c62c" id="r_ga776730df3e6b57476ae9773d3848c62c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga776730df3e6b57476ae9773d3848c62c">SDL::GPUCullMode</a> = SDL_GPUCullMode</td></tr>
<tr class="memdesc:ga776730df3e6b57476ae9773d3848c62c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the facing direction in which triangle faces will be culled.  <br /></td></tr>
<tr class="separator:ga776730df3e6b57476ae9773d3848c62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae69a13df5715495d8e282f4ac2f1c2e0" id="r_gae69a13df5715495d8e282f4ac2f1c2e0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gae69a13df5715495d8e282f4ac2f1c2e0">SDL::GPUFrontFace</a> = SDL_GPUFrontFace</td></tr>
<tr class="memdesc:gae69a13df5715495d8e282f4ac2f1c2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the vertex winding that will cause a triangle to be determined to be front-facing.  <br /></td></tr>
<tr class="separator:gae69a13df5715495d8e282f4ac2f1c2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27b1a00730534d4ce7ac51f63874cfc7" id="r_ga27b1a00730534d4ce7ac51f63874cfc7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga27b1a00730534d4ce7ac51f63874cfc7">SDL::GPUCompareOp</a> = SDL_GPUCompareOp</td></tr>
<tr class="memdesc:ga27b1a00730534d4ce7ac51f63874cfc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a comparison operator for depth, stencil and sampler operations.  <br /></td></tr>
<tr class="separator:ga27b1a00730534d4ce7ac51f63874cfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaead0310f70b17c2bc2f92dab7646c96a" id="r_gaead0310f70b17c2bc2f92dab7646c96a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaead0310f70b17c2bc2f92dab7646c96a">SDL::GPUStencilOp</a> = SDL_GPUStencilOp</td></tr>
<tr class="memdesc:gaead0310f70b17c2bc2f92dab7646c96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies what happens to a stored stencil value if stencil tests fail or pass.  <br /></td></tr>
<tr class="separator:gaead0310f70b17c2bc2f92dab7646c96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a39f40ae7ce461c6ac1918873e4975c" id="r_ga2a39f40ae7ce461c6ac1918873e4975c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga2a39f40ae7ce461c6ac1918873e4975c">SDL::GPUBlendOp</a> = SDL_GPUBlendOp</td></tr>
<tr class="memdesc:ga2a39f40ae7ce461c6ac1918873e4975c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the operator to be used when pixels in a render target are blended with existing pixels in the texture.  <br /></td></tr>
<tr class="separator:ga2a39f40ae7ce461c6ac1918873e4975c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f1b5cc82a6f49a6cf0644b60bebff89" id="r_ga4f1b5cc82a6f49a6cf0644b60bebff89"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">SDL::GPUBlendFactor</a> = SDL_GPUBlendFactor</td></tr>
<tr class="memdesc:ga4f1b5cc82a6f49a6cf0644b60bebff89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a blending factor to be used when pixels in a render target are blended with existing pixels in the texture.  <br /></td></tr>
<tr class="separator:ga4f1b5cc82a6f49a6cf0644b60bebff89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62905cb8376e8611e4a5b2ac378966ea" id="r_ga62905cb8376e8611e4a5b2ac378966ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga62905cb8376e8611e4a5b2ac378966ea">SDL::GPUColorComponentFlags</a> = <a class="el" href="group__CategoryStdinc.html#gadeddb36a6d67c5bc92003dd7679b4b17">Uint8</a></td></tr>
<tr class="memdesc:ga62905cb8376e8611e4a5b2ac378966ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies which color components are written in a graphics pipeline.  <br /></td></tr>
<tr class="separator:ga62905cb8376e8611e4a5b2ac378966ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf59e313ae6b3da6531b643e8ab9a4c62" id="r_gaf59e313ae6b3da6531b643e8ab9a4c62"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf59e313ae6b3da6531b643e8ab9a4c62">SDL::GPUFilter</a> = SDL_GPUFilter</td></tr>
<tr class="memdesc:gaf59e313ae6b3da6531b643e8ab9a4c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a filter operation used by a sampler.  <br /></td></tr>
<tr class="separator:gaf59e313ae6b3da6531b643e8ab9a4c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f58e9e7f4f148b25f3e0f839081615f" id="r_ga5f58e9e7f4f148b25f3e0f839081615f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga5f58e9e7f4f148b25f3e0f839081615f">SDL::GPUSamplerMipmapMode</a> = SDL_GPUSamplerMipmapMode</td></tr>
<tr class="memdesc:ga5f58e9e7f4f148b25f3e0f839081615f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a mipmap mode used by a sampler.  <br /></td></tr>
<tr class="separator:ga5f58e9e7f4f148b25f3e0f839081615f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae26794f6b687f9799cba905967796a0a" id="r_gae26794f6b687f9799cba905967796a0a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gae26794f6b687f9799cba905967796a0a">SDL::GPUSamplerAddressMode</a> = SDL_GPUSamplerAddressMode</td></tr>
<tr class="memdesc:gae26794f6b687f9799cba905967796a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies behavior of texture sampling when the coordinates exceed the 0-1 range.  <br /></td></tr>
<tr class="separator:gae26794f6b687f9799cba905967796a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6925fa9fd549021a51eef2f7639204f" id="r_gaf6925fa9fd549021a51eef2f7639204f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf6925fa9fd549021a51eef2f7639204f">SDL::GPUBlitRegion</a> = SDL_GPUBlitRegion</td></tr>
<tr class="memdesc:gaf6925fa9fd549021a51eef2f7639204f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying a region of a texture used in the blit operation.  <br /></td></tr>
<tr class="separator:gaf6925fa9fd549021a51eef2f7639204f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf93a40deaafd77e9e29cee09c432c4c7" id="r_gaf93a40deaafd77e9e29cee09c432c4c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf93a40deaafd77e9e29cee09c432c4c7">SDL::GPUIndirectDrawCommand</a> = SDL_GPUIndirectDrawCommand</td></tr>
<tr class="memdesc:gaf93a40deaafd77e9e29cee09c432c4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying the parameters of an indirect draw command.  <br /></td></tr>
<tr class="separator:gaf93a40deaafd77e9e29cee09c432c4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4accdcc2c5e4049b181bbb65585e588b" id="r_ga4accdcc2c5e4049b181bbb65585e588b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga4accdcc2c5e4049b181bbb65585e588b">SDL::GPUIndexedIndirectDrawCommand</a> = SDL_GPUIndexedIndirectDrawCommand</td></tr>
<tr class="memdesc:ga4accdcc2c5e4049b181bbb65585e588b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying the parameters of an indexed indirect draw command.  <br /></td></tr>
<tr class="separator:ga4accdcc2c5e4049b181bbb65585e588b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e1ec8c5137a3d3142a5668ab76347a4" id="r_ga3e1ec8c5137a3d3142a5668ab76347a4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga3e1ec8c5137a3d3142a5668ab76347a4">SDL::GPUIndirectDispatchCommand</a> = SDL_GPUIndirectDispatchCommand</td></tr>
<tr class="memdesc:ga3e1ec8c5137a3d3142a5668ab76347a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying the parameters of an indexed dispatch command.  <br /></td></tr>
<tr class="separator:ga3e1ec8c5137a3d3142a5668ab76347a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga408662b71e44e86d3382fa1c1c9640bc" id="r_ga408662b71e44e86d3382fa1c1c9640bc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga408662b71e44e86d3382fa1c1c9640bc">SDL::GPUVertexBufferDescription</a> = SDL_GPUVertexBufferDescription</td></tr>
<tr class="memdesc:ga408662b71e44e86d3382fa1c1c9640bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying the parameters of vertex buffers used in a graphics pipeline.  <br /></td></tr>
<tr class="separator:ga408662b71e44e86d3382fa1c1c9640bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dec8e1717cdae085c3f74c9a17b66ef" id="r_ga0dec8e1717cdae085c3f74c9a17b66ef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga0dec8e1717cdae085c3f74c9a17b66ef">SDL::GPUVertexAttribute</a> = SDL_GPUVertexAttribute</td></tr>
<tr class="memdesc:ga0dec8e1717cdae085c3f74c9a17b66ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying a vertex attribute.  <br /></td></tr>
<tr class="separator:ga0dec8e1717cdae085c3f74c9a17b66ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef63c13e265391ab25cca015821d03de" id="r_gaef63c13e265391ab25cca015821d03de"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaef63c13e265391ab25cca015821d03de">SDL::GPUVertexInputState</a> = SDL_GPUVertexInputState</td></tr>
<tr class="memdesc:gaef63c13e265391ab25cca015821d03de"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying the parameters of a graphics pipeline vertex input state.  <br /></td></tr>
<tr class="separator:gaef63c13e265391ab25cca015821d03de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d73c0cd03157b033817c619ae2247a0" id="r_ga7d73c0cd03157b033817c619ae2247a0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga7d73c0cd03157b033817c619ae2247a0">SDL::GPUStencilOpState</a> = SDL_GPUStencilOpState</td></tr>
<tr class="memdesc:ga7d73c0cd03157b033817c619ae2247a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying the stencil operation state of a graphics pipeline.  <br /></td></tr>
<tr class="separator:ga7d73c0cd03157b033817c619ae2247a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga566840738382b6dbf0d307149756e408" id="r_ga566840738382b6dbf0d307149756e408"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga566840738382b6dbf0d307149756e408">SDL::GPUColorTargetBlendState</a> = SDL_GPUColorTargetBlendState</td></tr>
<tr class="memdesc:ga566840738382b6dbf0d307149756e408"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying the blend state of a color target.  <br /></td></tr>
<tr class="separator:ga566840738382b6dbf0d307149756e408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadca1f8e35005fd7af36b7aa84e8d57c4" id="r_gadca1f8e35005fd7af36b7aa84e8d57c4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gadca1f8e35005fd7af36b7aa84e8d57c4">SDL::GPURasterizerState</a> = SDL_GPURasterizerState</td></tr>
<tr class="memdesc:gadca1f8e35005fd7af36b7aa84e8d57c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying the parameters of the graphics pipeline rasterizer state.  <br /></td></tr>
<tr class="separator:gadca1f8e35005fd7af36b7aa84e8d57c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga496f5b66ed2275b37fff29458ce51cf1" id="r_ga496f5b66ed2275b37fff29458ce51cf1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga496f5b66ed2275b37fff29458ce51cf1">SDL::GPUMultisampleState</a> = SDL_GPUMultisampleState</td></tr>
<tr class="memdesc:ga496f5b66ed2275b37fff29458ce51cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying the parameters of the graphics pipeline multisample state.  <br /></td></tr>
<tr class="separator:ga496f5b66ed2275b37fff29458ce51cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga013a5670075cbdd8696a60b8339eacba" id="r_ga013a5670075cbdd8696a60b8339eacba"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga013a5670075cbdd8696a60b8339eacba">SDL::GPUDepthStencilState</a> = SDL_GPUDepthStencilState</td></tr>
<tr class="memdesc:ga013a5670075cbdd8696a60b8339eacba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying the parameters of the graphics pipeline depth stencil state.  <br /></td></tr>
<tr class="separator:ga013a5670075cbdd8696a60b8339eacba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37eabd1e9acff0106e7c203493274188" id="r_ga37eabd1e9acff0106e7c203493274188"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga37eabd1e9acff0106e7c203493274188">SDL::GPUColorTargetDescription</a> = SDL_GPUColorTargetDescription</td></tr>
<tr class="memdesc:ga37eabd1e9acff0106e7c203493274188"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying the parameters of color targets used in a graphics pipeline.  <br /></td></tr>
<tr class="separator:ga37eabd1e9acff0106e7c203493274188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e000919fb7eb2049a72472a253094f8" id="r_ga2e000919fb7eb2049a72472a253094f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga2e000919fb7eb2049a72472a253094f8">SDL::GPUGraphicsPipelineTargetInfo</a> = SDL_GPUGraphicsPipelineTargetInfo</td></tr>
<tr class="memdesc:ga2e000919fb7eb2049a72472a253094f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure specifying the descriptions of render targets used in a graphics pipeline.  <br /></td></tr>
<tr class="separator:ga2e000919fb7eb2049a72472a253094f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae97816ef9ed10b7e29d52a0bbeb929c6" id="r_gae97816ef9ed10b7e29d52a0bbeb929c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gae97816ef9ed10b7e29d52a0bbeb929c6">SDL::GPUSupportsShaderFormats</a> (<a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">GPUShaderFormat</a> format_flags, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> name)</td></tr>
<tr class="memdesc:gae97816ef9ed10b7e29d52a0bbeb929c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for GPU runtime support.  <br /></td></tr>
<tr class="separator:gae97816ef9ed10b7e29d52a0bbeb929c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd98f2a7bff0b2815bf2da41ddf4a1c7" id="r_gadd98f2a7bff0b2815bf2da41ddf4a1c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gadd98f2a7bff0b2815bf2da41ddf4a1c7">SDL::GPUSupportsProperties</a> (<a class="el" href="structSDL_1_1PropertiesParam.html">PropertiesParam</a> props)</td></tr>
<tr class="memdesc:gadd98f2a7bff0b2815bf2da41ddf4a1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for GPU runtime support.  <br /></td></tr>
<tr class="separator:gadd98f2a7bff0b2815bf2da41ddf4a1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd7a0adc1bbd7e1bd628f257c2f2f51d" id="r_gabd7a0adc1bbd7e1bd628f257c2f2f51d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUDevice.html">GPUDevice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gabd7a0adc1bbd7e1bd628f257c2f2f51d">SDL::CreateGPUDevice</a> (<a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">GPUShaderFormat</a> format_flags, bool debug_mode, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> name)</td></tr>
<tr class="memdesc:gabd7a0adc1bbd7e1bd628f257c2f2f51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a GPU context.  <br /></td></tr>
<tr class="separator:gabd7a0adc1bbd7e1bd628f257c2f2f51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga570cf45429ab2969bb5351037fba5919" id="r_ga570cf45429ab2969bb5351037fba5919"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUDevice.html">GPUDevice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga570cf45429ab2969bb5351037fba5919">SDL::CreateGPUDeviceWithProperties</a> (<a class="el" href="structSDL_1_1PropertiesParam.html">PropertiesParam</a> props)</td></tr>
<tr class="memdesc:ga570cf45429ab2969bb5351037fba5919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a GPU context.  <br /></td></tr>
<tr class="separator:ga570cf45429ab2969bb5351037fba5919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaac6e62e53451d12604898cec7addfee" id="r_gaaac6e62e53451d12604898cec7addfee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaaac6e62e53451d12604898cec7addfee">SDL::DestroyGPUDevice</a> (<a class="el" href="group__CategoryGPU.html#gac9a40e8e5a66e5269284c096f0908a74">GPUDeviceRaw</a> device)</td></tr>
<tr class="memdesc:gaaac6e62e53451d12604898cec7addfee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a GPU context previously returned by <a class="el" href="classSDL_1_1GPUDevice.html#a9fde3883d9146abd2533f4882d233906" title="Default ctor.">GPUDevice.GPUDevice</a>.  <br /></td></tr>
<tr class="separator:gaaac6e62e53451d12604898cec7addfee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga096a87a2e48b07cba15df9e0ba0f9780" id="r_ga096a87a2e48b07cba15df9e0ba0f9780"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga096a87a2e48b07cba15df9e0ba0f9780">SDL::GetNumGPUDrivers</a> ()</td></tr>
<tr class="memdesc:ga096a87a2e48b07cba15df9e0ba0f9780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of GPU drivers compiled into <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a>.  <br /></td></tr>
<tr class="separator:ga096a87a2e48b07cba15df9e0ba0f9780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac383aba530619d3c849e9801dc9a2f53" id="r_gac383aba530619d3c849e9801dc9a2f53"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gac383aba530619d3c849e9801dc9a2f53">SDL::GetGPUDriver</a> (int index)</td></tr>
<tr class="memdesc:gac383aba530619d3c849e9801dc9a2f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of a built in GPU driver.  <br /></td></tr>
<tr class="separator:gac383aba530619d3c849e9801dc9a2f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdd791b8144a50de53cea149befdba56" id="r_gacdd791b8144a50de53cea149befdba56"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gacdd791b8144a50de53cea149befdba56">SDL::GetGPUDeviceDriver</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device)</td></tr>
<tr class="memdesc:gacdd791b8144a50de53cea149befdba56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the backend used to create this GPU context.  <br /></td></tr>
<tr class="separator:gacdd791b8144a50de53cea149befdba56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga025bda7fe5d6157650ec1912b0f03107" id="r_ga025bda7fe5d6157650ec1912b0f03107"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">GPUShaderFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga025bda7fe5d6157650ec1912b0f03107">SDL::GetGPUShaderFormats</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device)</td></tr>
<tr class="memdesc:ga025bda7fe5d6157650ec1912b0f03107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the supported shader formats for this GPU context.  <br /></td></tr>
<tr class="separator:ga025bda7fe5d6157650ec1912b0f03107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa21891e9ebd97f17eda06d0e9fd2436b" id="r_gaa21891e9ebd97f17eda06d0e9fd2436b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUComputePipeline.html">GPUComputePipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa21891e9ebd97f17eda06d0e9fd2436b">SDL::CreateGPUComputePipeline</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, const <a class="el" href="group__CategoryGPU.html#ga9baa44a9f7478858ee1ac28037e0574f">GPUComputePipelineCreateInfo</a> &amp;createinfo)</td></tr>
<tr class="memdesc:gaa21891e9ebd97f17eda06d0e9fd2436b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pipeline object to be used in a compute workflow.  <br /></td></tr>
<tr class="separator:gaa21891e9ebd97f17eda06d0e9fd2436b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d5e158e09ece9950142df75d9212b9c" id="r_ga7d5e158e09ece9950142df75d9212b9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html">GPUGraphicsPipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga7d5e158e09ece9950142df75d9212b9c">SDL::CreateGPUGraphicsPipeline</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, const <a class="el" href="group__CategoryGPU.html#ga60d171e0d2bee691d934e2275b2bf23b">GPUGraphicsPipelineCreateInfo</a> &amp;createinfo)</td></tr>
<tr class="memdesc:ga7d5e158e09ece9950142df75d9212b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pipeline object to be used in a graphics workflow.  <br /></td></tr>
<tr class="separator:ga7d5e158e09ece9950142df75d9212b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe94feb1e693d65d092e72bd6d4cfdac" id="r_gafe94feb1e693d65d092e72bd6d4cfdac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUSampler.html">GPUSampler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gafe94feb1e693d65d092e72bd6d4cfdac">SDL::CreateGPUSampler</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, const <a class="el" href="group__CategoryGPU.html#ga9905b04780e8798c8cd2bf18a29bff27">GPUSamplerCreateInfo</a> &amp;createinfo)</td></tr>
<tr class="memdesc:gafe94feb1e693d65d092e72bd6d4cfdac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a sampler object to be used when binding textures in a graphics workflow.  <br /></td></tr>
<tr class="separator:gafe94feb1e693d65d092e72bd6d4cfdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa11cb7a06cff34927d31e120e90eb064" id="r_gaa11cb7a06cff34927d31e120e90eb064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUShader.html">GPUShader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa11cb7a06cff34927d31e120e90eb064">SDL::CreateGPUShader</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, const <a class="el" href="group__CategoryGPU.html#gaec6e01546fef70020c8f7b44da82be99">GPUShaderCreateInfo</a> &amp;createinfo)</td></tr>
<tr class="memdesc:gaa11cb7a06cff34927d31e120e90eb064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shader to be used when creating a graphics pipeline.  <br /></td></tr>
<tr class="separator:gaa11cb7a06cff34927d31e120e90eb064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c21cb9e36008832e5d982833c5ff581" id="r_ga9c21cb9e36008832e5d982833c5ff581"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga9c21cb9e36008832e5d982833c5ff581">SDL::CreateGPUTexture</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, const <a class="el" href="group__CategoryGPU.html#ga87fcb53cd9c731a4a4f3c7c10a5edb6a">GPUTextureCreateInfo</a> &amp;createinfo)</td></tr>
<tr class="memdesc:ga9c21cb9e36008832e5d982833c5ff581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a texture object to be used in graphics or compute workflows.  <br /></td></tr>
<tr class="separator:ga9c21cb9e36008832e5d982833c5ff581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8461578dfc858efa73dfd1e49295eed7" id="r_ga8461578dfc858efa73dfd1e49295eed7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga8461578dfc858efa73dfd1e49295eed7">SDL::CreateGPUBuffer</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, const <a class="el" href="group__CategoryGPU.html#ga6cb3830a3ade4303d47a017993de4fea">GPUBufferCreateInfo</a> &amp;createinfo)</td></tr>
<tr class="memdesc:ga8461578dfc858efa73dfd1e49295eed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a buffer object to be used in graphics or compute workflows.  <br /></td></tr>
<tr class="separator:ga8461578dfc858efa73dfd1e49295eed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0309af2a31bb393288d480bcc42edce2" id="r_ga0309af2a31bb393288d480bcc42edce2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUTransferBuffer.html">GPUTransferBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga0309af2a31bb393288d480bcc42edce2">SDL::CreateGPUTransferBuffer</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, const <a class="el" href="group__CategoryGPU.html#gabf392df5f8790bf73f828ca3e1f21bd5">GPUTransferBufferCreateInfo</a> &amp;createinfo)</td></tr>
<tr class="memdesc:ga0309af2a31bb393288d480bcc42edce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a transfer buffer to be used when uploading to or downloading from graphics resources.  <br /></td></tr>
<tr class="separator:ga0309af2a31bb393288d480bcc42edce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d086a0646edf1f73d758e2a350e6ce0" id="r_ga1d086a0646edf1f73d758e2a350e6ce0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga1d086a0646edf1f73d758e2a350e6ce0">SDL::SetGPUBufferName</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a> buffer, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> text)</td></tr>
<tr class="memdesc:ga1d086a0646edf1f73d758e2a350e6ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an arbitrary string constant to label a buffer.  <br /></td></tr>
<tr class="separator:ga1d086a0646edf1f73d758e2a350e6ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3701961d411ec57410c58c1e7e3512ab" id="r_ga3701961d411ec57410c58c1e7e3512ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga3701961d411ec57410c58c1e7e3512ab">SDL::SetGPUTextureName</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a> texture, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> text)</td></tr>
<tr class="memdesc:ga3701961d411ec57410c58c1e7e3512ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an arbitrary string constant to label a texture.  <br /></td></tr>
<tr class="separator:ga3701961d411ec57410c58c1e7e3512ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf1179d3f9d5290ebe54fb1837efb5be" id="r_gadf1179d3f9d5290ebe54fb1837efb5be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gadf1179d3f9d5290ebe54fb1837efb5be">SDL::InsertGPUDebugLabel</a> (<a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a> command_buffer, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> text)</td></tr>
<tr class="memdesc:gadf1179d3f9d5290ebe54fb1837efb5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an arbitrary string label into the command buffer callstream.  <br /></td></tr>
<tr class="separator:gadf1179d3f9d5290ebe54fb1837efb5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ca15527eab7b27fc215704a88363a1c" id="r_ga1ca15527eab7b27fc215704a88363a1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga1ca15527eab7b27fc215704a88363a1c">SDL::PushGPUDebugGroup</a> (<a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a> command_buffer, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> name)</td></tr>
<tr class="memdesc:ga1ca15527eab7b27fc215704a88363a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a debug group with an arbitrary name.  <br /></td></tr>
<tr class="separator:ga1ca15527eab7b27fc215704a88363a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb51e49130f6b17dc6ff82e7a2824ceb" id="r_gafb51e49130f6b17dc6ff82e7a2824ceb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gafb51e49130f6b17dc6ff82e7a2824ceb">SDL::PopGPUDebugGroup</a> (<a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a> command_buffer)</td></tr>
<tr class="memdesc:gafb51e49130f6b17dc6ff82e7a2824ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends the most-recently pushed debug group.  <br /></td></tr>
<tr class="separator:gafb51e49130f6b17dc6ff82e7a2824ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0a0743470c177313845bca7b6b5c70f" id="r_gaa0a0743470c177313845bca7b6b5c70f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa0a0743470c177313845bca7b6b5c70f">SDL::ReleaseGPUTexture</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a> texture)</td></tr>
<tr class="memdesc:gaa0a0743470c177313845bca7b6b5c70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the given texture as soon as it is safe to do so.  <br /></td></tr>
<tr class="separator:gaa0a0743470c177313845bca7b6b5c70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cc4888d0473c9fe59f287f633bc0a48" id="r_ga1cc4888d0473c9fe59f287f633bc0a48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga1cc4888d0473c9fe59f287f633bc0a48">SDL::ReleaseGPUSampler</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="classSDL_1_1GPUSampler.html">GPUSampler</a> sampler)</td></tr>
<tr class="memdesc:ga1cc4888d0473c9fe59f287f633bc0a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the given sampler as soon as it is safe to do so.  <br /></td></tr>
<tr class="separator:ga1cc4888d0473c9fe59f287f633bc0a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9e53b951df3be7cc4df709ab9292248" id="r_gaa9e53b951df3be7cc4df709ab9292248"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa9e53b951df3be7cc4df709ab9292248">SDL::ReleaseGPUBuffer</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a> buffer)</td></tr>
<tr class="memdesc:gaa9e53b951df3be7cc4df709ab9292248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the given buffer as soon as it is safe to do so.  <br /></td></tr>
<tr class="separator:gaa9e53b951df3be7cc4df709ab9292248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec1587e6b22a0ff93cd6b8887381507d" id="r_gaec1587e6b22a0ff93cd6b8887381507d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaec1587e6b22a0ff93cd6b8887381507d">SDL::ReleaseGPUTransferBuffer</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="classSDL_1_1GPUTransferBuffer.html">GPUTransferBuffer</a> transfer_buffer)</td></tr>
<tr class="memdesc:gaec1587e6b22a0ff93cd6b8887381507d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the given transfer buffer as soon as it is safe to do so.  <br /></td></tr>
<tr class="separator:gaec1587e6b22a0ff93cd6b8887381507d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40091a14557e718733af0c0e46fb8dca" id="r_ga40091a14557e718733af0c0e46fb8dca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga40091a14557e718733af0c0e46fb8dca">SDL::ReleaseGPUComputePipeline</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="classSDL_1_1GPUComputePipeline.html">GPUComputePipeline</a> compute_pipeline)</td></tr>
<tr class="memdesc:ga40091a14557e718733af0c0e46fb8dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the given compute pipeline as soon as it is safe to do so.  <br /></td></tr>
<tr class="separator:ga40091a14557e718733af0c0e46fb8dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7476f92df93eb6268e3bc7fee41a4dd" id="r_gab7476f92df93eb6268e3bc7fee41a4dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gab7476f92df93eb6268e3bc7fee41a4dd">SDL::ReleaseGPUShader</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="classSDL_1_1GPUShader.html">GPUShader</a> shader)</td></tr>
<tr class="memdesc:gab7476f92df93eb6268e3bc7fee41a4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the given shader as soon as it is safe to do so.  <br /></td></tr>
<tr class="separator:gab7476f92df93eb6268e3bc7fee41a4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8780f11c5723998ac9724abb17805a14" id="r_ga8780f11c5723998ac9724abb17805a14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga8780f11c5723998ac9724abb17805a14">SDL::ReleaseGPUGraphicsPipeline</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="classSDL_1_1GPUGraphicsPipeline.html">GPUGraphicsPipeline</a> graphics_pipeline)</td></tr>
<tr class="memdesc:ga8780f11c5723998ac9724abb17805a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the given graphics pipeline as soon as it is safe to do so.  <br /></td></tr>
<tr class="separator:ga8780f11c5723998ac9724abb17805a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b3a4de20ef99fcdac2269fca7b866ba" id="r_ga6b3a4de20ef99fcdac2269fca7b866ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga6b3a4de20ef99fcdac2269fca7b866ba">SDL::AcquireGPUCommandBuffer</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device)</td></tr>
<tr class="memdesc:ga6b3a4de20ef99fcdac2269fca7b866ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire a command buffer.  <br /></td></tr>
<tr class="separator:ga6b3a4de20ef99fcdac2269fca7b866ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c1354e8b92832a9e74b5c013e1781c5" id="r_ga9c1354e8b92832a9e74b5c013e1781c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga9c1354e8b92832a9e74b5c013e1781c5">SDL::PushGPUVertexUniformData</a> (<a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a> command_buffer, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> slot_index, <a class="el" href="classSDL_1_1SourceBytes.html">SourceBytes</a> data)</td></tr>
<tr class="memdesc:ga9c1354e8b92832a9e74b5c013e1781c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes data to a vertex uniform slot on the command buffer.  <br /></td></tr>
<tr class="separator:ga9c1354e8b92832a9e74b5c013e1781c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga097fb8be416be0911835d10cabf3d938" id="r_ga097fb8be416be0911835d10cabf3d938"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga097fb8be416be0911835d10cabf3d938">SDL::PushGPUFragmentUniformData</a> (<a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a> command_buffer, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> slot_index, <a class="el" href="classSDL_1_1SourceBytes.html">SourceBytes</a> data)</td></tr>
<tr class="memdesc:ga097fb8be416be0911835d10cabf3d938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes data to a fragment uniform slot on the command buffer.  <br /></td></tr>
<tr class="separator:ga097fb8be416be0911835d10cabf3d938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa39d284c1bb4c7c3615cbd3a09db921e" id="r_gaa39d284c1bb4c7c3615cbd3a09db921e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa39d284c1bb4c7c3615cbd3a09db921e">SDL::PushGPUComputeUniformData</a> (<a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a> command_buffer, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> slot_index, <a class="el" href="classSDL_1_1SourceBytes.html">SourceBytes</a> data)</td></tr>
<tr class="memdesc:gaa39d284c1bb4c7c3615cbd3a09db921e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes data to a uniform slot on the command buffer.  <br /></td></tr>
<tr class="separator:gaa39d284c1bb4c7c3615cbd3a09db921e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5564e25e15769a0ebe82cf21e45d46e3" id="r_ga5564e25e15769a0ebe82cf21e45d46e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga5564e25e15769a0ebe82cf21e45d46e3">SDL::BeginGPURenderPass</a> (<a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a> command_buffer, std::span&lt; const <a class="el" href="group__CategoryGPU.html#ga26904510dffa9db5b09c79637b00edbc">GPUColorTargetInfo</a> &gt; color_target_infos, <a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga28e62eba4af4c55395ef3cecf7fc0ebc">GPUDepthStencilTargetInfo</a> &gt; depth_stencil_target_info)</td></tr>
<tr class="memdesc:ga5564e25e15769a0ebe82cf21e45d46e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a render pass on a command buffer.  <br /></td></tr>
<tr class="separator:ga5564e25e15769a0ebe82cf21e45d46e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacf3e7f9e1b9d6fe6ab45defe29619db" id="r_gaacf3e7f9e1b9d6fe6ab45defe29619db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaacf3e7f9e1b9d6fe6ab45defe29619db">SDL::BindGPUGraphicsPipeline</a> (<a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a> render_pass, <a class="el" href="classSDL_1_1GPUGraphicsPipeline.html">GPUGraphicsPipeline</a> graphics_pipeline)</td></tr>
<tr class="memdesc:gaacf3e7f9e1b9d6fe6ab45defe29619db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a graphics pipeline on a render pass to be used in rendering.  <br /></td></tr>
<tr class="separator:gaacf3e7f9e1b9d6fe6ab45defe29619db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22bacd025df5958ae85ec37519de23a4" id="r_ga22bacd025df5958ae85ec37519de23a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga22bacd025df5958ae85ec37519de23a4">SDL::SetGPUViewport</a> (<a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a> render_pass, const <a class="el" href="group__CategoryGPU.html#gaf80d3281c271f2f02de8d8e14648fe20">GPUViewport</a> &amp;viewport)</td></tr>
<tr class="memdesc:ga22bacd025df5958ae85ec37519de23a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current viewport state on a command buffer.  <br /></td></tr>
<tr class="separator:ga22bacd025df5958ae85ec37519de23a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef421368adf50fa00376de4978643d31" id="r_gaef421368adf50fa00376de4978643d31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaef421368adf50fa00376de4978643d31">SDL::SetGPUScissor</a> (<a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a> render_pass, const <a class="el" href="group__CategoryRect.html#gadeb77054b31c63a38d6594652fb0b7f4">RectRaw</a> &amp;scissor)</td></tr>
<tr class="memdesc:gaef421368adf50fa00376de4978643d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current scissor state on a command buffer.  <br /></td></tr>
<tr class="separator:gaef421368adf50fa00376de4978643d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace75858cd83969cec098f543e6c26bf4" id="r_gace75858cd83969cec098f543e6c26bf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gace75858cd83969cec098f543e6c26bf4">SDL::SetGPUBlendConstants</a> (<a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a> render_pass, <a class="el" href="group__CategoryPixels.html#gadfaf5b77d5957860167740c745343e4e">FColorRaw</a> blend_constants)</td></tr>
<tr class="memdesc:gace75858cd83969cec098f543e6c26bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current blend constants on a command buffer.  <br /></td></tr>
<tr class="separator:gace75858cd83969cec098f543e6c26bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7839d651b14a4e9b7e338929dc1c49e3" id="r_ga7839d651b14a4e9b7e338929dc1c49e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga7839d651b14a4e9b7e338929dc1c49e3">SDL::SetGPUStencilReference</a> (<a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a> render_pass, <a class="el" href="group__CategoryStdinc.html#gadeddb36a6d67c5bc92003dd7679b4b17">Uint8</a> reference)</td></tr>
<tr class="memdesc:ga7839d651b14a4e9b7e338929dc1c49e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current stencil reference value on a command buffer.  <br /></td></tr>
<tr class="separator:ga7839d651b14a4e9b7e338929dc1c49e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed8a93e9dec0a2ed731fc3bcb7f2a990" id="r_gaed8a93e9dec0a2ed731fc3bcb7f2a990"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaed8a93e9dec0a2ed731fc3bcb7f2a990">SDL::BindGPUVertexBuffers</a> (<a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a> render_pass, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_slot, std::span&lt; const <a class="el" href="group__CategoryGPU.html#ga698bbc29bd1e44bec1e2b87ce3a81dbb">GPUBufferBinding</a> &gt; bindings)</td></tr>
<tr class="memdesc:gaed8a93e9dec0a2ed731fc3bcb7f2a990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds vertex buffers on a command buffer for use with subsequent draw calls.  <br /></td></tr>
<tr class="separator:gaed8a93e9dec0a2ed731fc3bcb7f2a990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3612a1d963792f05f3ce2385334b346f" id="r_ga3612a1d963792f05f3ce2385334b346f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga3612a1d963792f05f3ce2385334b346f">SDL::BindGPUIndexBuffer</a> (<a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a> render_pass, const <a class="el" href="group__CategoryGPU.html#ga698bbc29bd1e44bec1e2b87ce3a81dbb">GPUBufferBinding</a> &amp;binding, <a class="el" href="group__CategoryGPU.html#gaec587594b432d13ab2ddd78ad77342a7">GPUIndexElementSize</a> index_element_size)</td></tr>
<tr class="memdesc:ga3612a1d963792f05f3ce2385334b346f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds an index buffer on a command buffer for use with subsequent draw calls.  <br /></td></tr>
<tr class="separator:ga3612a1d963792f05f3ce2385334b346f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a7be902e8ed2be091f44004c97e76f8" id="r_ga5a7be902e8ed2be091f44004c97e76f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga5a7be902e8ed2be091f44004c97e76f8">SDL::BindGPUVertexSamplers</a> (<a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a> render_pass, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_slot, std::span&lt; const <a class="el" href="group__CategoryGPU.html#ga86e968acd12b623cb7b5056c323285b3">GPUTextureSamplerBinding</a> &gt; texture_sampler_bindings)</td></tr>
<tr class="memdesc:ga5a7be902e8ed2be091f44004c97e76f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds texture-sampler pairs for use on the vertex shader.  <br /></td></tr>
<tr class="separator:ga5a7be902e8ed2be091f44004c97e76f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ba65c65debea20e4b137379f47129d8" id="r_ga1ba65c65debea20e4b137379f47129d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga1ba65c65debea20e4b137379f47129d8">SDL::BindGPUVertexStorageTextures</a> (<a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a> render_pass, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_slot, <a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga07bab3d86cb28ae9761a1c91b04c285f">GPUTextureRaw</a> &gt; storage_textures)</td></tr>
<tr class="memdesc:ga1ba65c65debea20e4b137379f47129d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds storage textures for use on the vertex shader.  <br /></td></tr>
<tr class="separator:ga1ba65c65debea20e4b137379f47129d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga828298b19ad720a6c572b11eac29e9cf" id="r_ga828298b19ad720a6c572b11eac29e9cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga828298b19ad720a6c572b11eac29e9cf">SDL::BindGPUVertexStorageBuffers</a> (<a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a> render_pass, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_slot, <a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga729f924587e663dffcd630a594e14396">GPUBufferRaw</a> &gt; storage_buffers)</td></tr>
<tr class="memdesc:ga828298b19ad720a6c572b11eac29e9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds storage buffers for use on the vertex shader.  <br /></td></tr>
<tr class="separator:ga828298b19ad720a6c572b11eac29e9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c5cbf319a14dc8645cbb2f08a7b4e63" id="r_ga7c5cbf319a14dc8645cbb2f08a7b4e63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga7c5cbf319a14dc8645cbb2f08a7b4e63">SDL::BindGPUFragmentSamplers</a> (<a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a> render_pass, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_slot, std::span&lt; const <a class="el" href="group__CategoryGPU.html#ga86e968acd12b623cb7b5056c323285b3">GPUTextureSamplerBinding</a> &gt; texture_sampler_bindings)</td></tr>
<tr class="memdesc:ga7c5cbf319a14dc8645cbb2f08a7b4e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds texture-sampler pairs for use on the fragment shader.  <br /></td></tr>
<tr class="separator:ga7c5cbf319a14dc8645cbb2f08a7b4e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a54e6d56f4b59f954282b45cded7755" id="r_ga0a54e6d56f4b59f954282b45cded7755"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga0a54e6d56f4b59f954282b45cded7755">SDL::BindGPUFragmentStorageTextures</a> (<a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a> render_pass, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_slot, <a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga07bab3d86cb28ae9761a1c91b04c285f">GPUTextureRaw</a> &gt; storage_textures)</td></tr>
<tr class="memdesc:ga0a54e6d56f4b59f954282b45cded7755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds storage textures for use on the fragment shader.  <br /></td></tr>
<tr class="separator:ga0a54e6d56f4b59f954282b45cded7755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7848c8b3c8ef3a6a29a45e44b379a3e8" id="r_ga7848c8b3c8ef3a6a29a45e44b379a3e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga7848c8b3c8ef3a6a29a45e44b379a3e8">SDL::BindGPUFragmentStorageBuffers</a> (<a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a> render_pass, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_slot, <a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga729f924587e663dffcd630a594e14396">GPUBufferRaw</a> &gt; storage_buffers)</td></tr>
<tr class="memdesc:ga7848c8b3c8ef3a6a29a45e44b379a3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds storage buffers for use on the fragment shader.  <br /></td></tr>
<tr class="separator:ga7848c8b3c8ef3a6a29a45e44b379a3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga578daf1145105b76ff31a4a60feadab4" id="r_ga578daf1145105b76ff31a4a60feadab4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga578daf1145105b76ff31a4a60feadab4">SDL::DrawGPUIndexedPrimitives</a> (<a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a> render_pass, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> num_indices, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> num_instances, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_index, <a class="el" href="group__CategoryStdinc.html#ga52ae1b7d45c9c8e49e98cd479de3694b">Sint32</a> vertex_offset, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_instance)</td></tr>
<tr class="memdesc:ga578daf1145105b76ff31a4a60feadab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws data using bound graphics state with an index buffer and instancing enabled.  <br /></td></tr>
<tr class="separator:ga578daf1145105b76ff31a4a60feadab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3341d213cb8161e362fa2b749d4e1bee" id="r_ga3341d213cb8161e362fa2b749d4e1bee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga3341d213cb8161e362fa2b749d4e1bee">SDL::DrawGPUPrimitives</a> (<a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a> render_pass, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> num_vertices, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> num_instances, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_vertex, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_instance)</td></tr>
<tr class="memdesc:ga3341d213cb8161e362fa2b749d4e1bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws data using bound graphics state.  <br /></td></tr>
<tr class="separator:ga3341d213cb8161e362fa2b749d4e1bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf0a88c6a42f9c08a8f3abb610eeda94" id="r_gabf0a88c6a42f9c08a8f3abb610eeda94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gabf0a88c6a42f9c08a8f3abb610eeda94">SDL::DrawGPUPrimitivesIndirect</a> (<a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a> render_pass, <a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a> buffer, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> offset, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> draw_count)</td></tr>
<tr class="memdesc:gabf0a88c6a42f9c08a8f3abb610eeda94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws data using bound graphics state and with draw parameters set from a buffer.  <br /></td></tr>
<tr class="separator:gabf0a88c6a42f9c08a8f3abb610eeda94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0efcc5015ac05357634ac54b0b0764a3" id="r_ga0efcc5015ac05357634ac54b0b0764a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga0efcc5015ac05357634ac54b0b0764a3">SDL::DrawGPUIndexedPrimitivesIndirect</a> (<a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a> render_pass, <a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a> buffer, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> offset, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> draw_count)</td></tr>
<tr class="memdesc:ga0efcc5015ac05357634ac54b0b0764a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws data using bound graphics state with an index buffer enabled and with draw parameters set from a buffer.  <br /></td></tr>
<tr class="separator:ga0efcc5015ac05357634ac54b0b0764a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadadcc498dce398aba2c8d25329eeda38" id="r_gadadcc498dce398aba2c8d25329eeda38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gadadcc498dce398aba2c8d25329eeda38">SDL::EndGPURenderPass</a> (<a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a> render_pass)</td></tr>
<tr class="memdesc:gadadcc498dce398aba2c8d25329eeda38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends the given render pass.  <br /></td></tr>
<tr class="separator:gadadcc498dce398aba2c8d25329eeda38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c30db9796f7da21a958fecc86e14195" id="r_ga7c30db9796f7da21a958fecc86e14195"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUComputePass.html">GPUComputePass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga7c30db9796f7da21a958fecc86e14195">SDL::BeginGPUComputePass</a> (<a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a> command_buffer, std::span&lt; const <a class="el" href="group__CategoryGPU.html#gaa4da71fb9f200b3a944c027d10c42675">GPUStorageTextureReadWriteBinding</a> &gt; storage_texture_bindings, std::span&lt; const <a class="el" href="group__CategoryGPU.html#gad1bd097ca5ba900d062e99162e62ab2c">GPUStorageBufferReadWriteBinding</a> &gt; storage_buffer_bindings)</td></tr>
<tr class="memdesc:ga7c30db9796f7da21a958fecc86e14195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a compute pass on a command buffer.  <br /></td></tr>
<tr class="separator:ga7c30db9796f7da21a958fecc86e14195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga686025dc203b1513e19bb87f1054a342" id="r_ga686025dc203b1513e19bb87f1054a342"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga686025dc203b1513e19bb87f1054a342">SDL::BindGPUComputePipeline</a> (<a class="el" href="classSDL_1_1GPUComputePass.html">GPUComputePass</a> compute_pass, <a class="el" href="classSDL_1_1GPUComputePipeline.html">GPUComputePipeline</a> compute_pipeline)</td></tr>
<tr class="memdesc:ga686025dc203b1513e19bb87f1054a342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a compute pipeline on a command buffer for use in compute dispatch.  <br /></td></tr>
<tr class="separator:ga686025dc203b1513e19bb87f1054a342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2dc9da2b6bb45fafb44c8604325e111" id="r_gaf2dc9da2b6bb45fafb44c8604325e111"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf2dc9da2b6bb45fafb44c8604325e111">SDL::BindGPUComputeSamplers</a> (<a class="el" href="classSDL_1_1GPUComputePass.html">GPUComputePass</a> compute_pass, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_slot, std::span&lt; const <a class="el" href="group__CategoryGPU.html#ga86e968acd12b623cb7b5056c323285b3">GPUTextureSamplerBinding</a> &gt; texture_sampler_bindings)</td></tr>
<tr class="memdesc:gaf2dc9da2b6bb45fafb44c8604325e111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds texture-sampler pairs for use on the compute shader.  <br /></td></tr>
<tr class="separator:gaf2dc9da2b6bb45fafb44c8604325e111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3eed8795d584b16141e9f7cfc1bdb5b" id="r_gaf3eed8795d584b16141e9f7cfc1bdb5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf3eed8795d584b16141e9f7cfc1bdb5b">SDL::BindGPUComputeStorageTextures</a> (<a class="el" href="classSDL_1_1GPUComputePass.html">GPUComputePass</a> compute_pass, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_slot, <a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga07bab3d86cb28ae9761a1c91b04c285f">GPUTextureRaw</a> &gt; storage_textures)</td></tr>
<tr class="memdesc:gaf3eed8795d584b16141e9f7cfc1bdb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds storage textures as readonly for use on the compute pipeline.  <br /></td></tr>
<tr class="separator:gaf3eed8795d584b16141e9f7cfc1bdb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad82b45014282f06657afc76b7207f2c4" id="r_gad82b45014282f06657afc76b7207f2c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gad82b45014282f06657afc76b7207f2c4">SDL::BindGPUComputeStorageBuffers</a> (<a class="el" href="classSDL_1_1GPUComputePass.html">GPUComputePass</a> compute_pass, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_slot, <a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga729f924587e663dffcd630a594e14396">GPUBufferRaw</a> &gt; storage_buffers)</td></tr>
<tr class="memdesc:gad82b45014282f06657afc76b7207f2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds storage buffers as readonly for use on the compute pipeline.  <br /></td></tr>
<tr class="separator:gad82b45014282f06657afc76b7207f2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79b297bf14faed46960f3c4aa670ad02" id="r_ga79b297bf14faed46960f3c4aa670ad02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga79b297bf14faed46960f3c4aa670ad02">SDL::DispatchGPUCompute</a> (<a class="el" href="classSDL_1_1GPUComputePass.html">GPUComputePass</a> compute_pass, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> groupcount_x, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> groupcount_y, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> groupcount_z)</td></tr>
<tr class="memdesc:ga79b297bf14faed46960f3c4aa670ad02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches compute work.  <br /></td></tr>
<tr class="separator:ga79b297bf14faed46960f3c4aa670ad02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae26de86745cd7e4270f173b0b0dfdb88" id="r_gae26de86745cd7e4270f173b0b0dfdb88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gae26de86745cd7e4270f173b0b0dfdb88">SDL::DispatchGPUComputeIndirect</a> (<a class="el" href="classSDL_1_1GPUComputePass.html">GPUComputePass</a> compute_pass, <a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a> buffer, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> offset)</td></tr>
<tr class="memdesc:gae26de86745cd7e4270f173b0b0dfdb88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches compute work with parameters set from a buffer.  <br /></td></tr>
<tr class="separator:gae26de86745cd7e4270f173b0b0dfdb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafefae079a574d32c9eb4bada0bb8b0af" id="r_gafefae079a574d32c9eb4bada0bb8b0af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gafefae079a574d32c9eb4bada0bb8b0af">SDL::EndGPUComputePass</a> (<a class="el" href="classSDL_1_1GPUComputePass.html">GPUComputePass</a> compute_pass)</td></tr>
<tr class="memdesc:gafefae079a574d32c9eb4bada0bb8b0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends the current compute pass.  <br /></td></tr>
<tr class="separator:gafefae079a574d32c9eb4bada0bb8b0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdb58fe754b9754fc7767bfacd6853cb" id="r_gabdb58fe754b9754fc7767bfacd6853cb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gabdb58fe754b9754fc7767bfacd6853cb">SDL::MapGPUTransferBuffer</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="classSDL_1_1GPUTransferBuffer.html">GPUTransferBuffer</a> transfer_buffer, bool cycle)</td></tr>
<tr class="memdesc:gabdb58fe754b9754fc7767bfacd6853cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a transfer buffer into application address space.  <br /></td></tr>
<tr class="separator:gabdb58fe754b9754fc7767bfacd6853cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8365ac3dbab1c09786dfccf76573a4fd" id="r_ga8365ac3dbab1c09786dfccf76573a4fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga8365ac3dbab1c09786dfccf76573a4fd">SDL::UnmapGPUTransferBuffer</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="classSDL_1_1GPUTransferBuffer.html">GPUTransferBuffer</a> transfer_buffer)</td></tr>
<tr class="memdesc:ga8365ac3dbab1c09786dfccf76573a4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmaps a previously mapped transfer buffer.  <br /></td></tr>
<tr class="separator:ga8365ac3dbab1c09786dfccf76573a4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf47189596f9ce0a1bfb7cf232a92d670" id="r_gaf47189596f9ce0a1bfb7cf232a92d670"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUCopyPass.html">GPUCopyPass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf47189596f9ce0a1bfb7cf232a92d670">SDL::BeginGPUCopyPass</a> (<a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a> command_buffer)</td></tr>
<tr class="memdesc:gaf47189596f9ce0a1bfb7cf232a92d670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a copy pass on a command buffer.  <br /></td></tr>
<tr class="separator:gaf47189596f9ce0a1bfb7cf232a92d670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89ada8c30a3597bb6f0ebb6a1c2c669d" id="r_ga89ada8c30a3597bb6f0ebb6a1c2c669d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga89ada8c30a3597bb6f0ebb6a1c2c669d">SDL::UploadToGPUTexture</a> (<a class="el" href="classSDL_1_1GPUCopyPass.html">GPUCopyPass</a> copy_pass, const <a class="el" href="group__CategoryGPU.html#ga62c3161f89c494e71fef4b8bbd471167">GPUTextureTransferInfo</a> &amp;source, const <a class="el" href="group__CategoryGPU.html#ga0a4272ec9f67111e0956cfe1f999f903">GPUTextureRegion</a> &amp;destination, bool cycle)</td></tr>
<tr class="memdesc:ga89ada8c30a3597bb6f0ebb6a1c2c669d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads data from a transfer buffer to a texture.  <br /></td></tr>
<tr class="separator:ga89ada8c30a3597bb6f0ebb6a1c2c669d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa37913aaeb02cefd9a1bdf894a994765" id="r_gaa37913aaeb02cefd9a1bdf894a994765"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa37913aaeb02cefd9a1bdf894a994765">SDL::UploadToGPUBuffer</a> (<a class="el" href="classSDL_1_1GPUCopyPass.html">GPUCopyPass</a> copy_pass, const <a class="el" href="group__CategoryGPU.html#ga9faa5600aabe5cabf35cbdf09851af6d">GPUTransferBufferLocation</a> &amp;source, const <a class="el" href="group__CategoryGPU.html#gac3310186554cb88f7b1a1599171aabdf">GPUBufferRegion</a> &amp;destination, bool cycle)</td></tr>
<tr class="memdesc:gaa37913aaeb02cefd9a1bdf894a994765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads data from a transfer buffer to a buffer.  <br /></td></tr>
<tr class="separator:gaa37913aaeb02cefd9a1bdf894a994765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fbebbbcf601bcc0feab74edc95e37af" id="r_ga0fbebbbcf601bcc0feab74edc95e37af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga0fbebbbcf601bcc0feab74edc95e37af">SDL::CopyGPUTextureToTexture</a> (<a class="el" href="classSDL_1_1GPUCopyPass.html">GPUCopyPass</a> copy_pass, const <a class="el" href="group__CategoryGPU.html#ga5dac1b3fb8a5a1ba34f6d99b84e81792">GPUTextureLocation</a> &amp;source, const <a class="el" href="group__CategoryGPU.html#ga5dac1b3fb8a5a1ba34f6d99b84e81792">GPUTextureLocation</a> &amp;destination, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> w, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> h, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> d, bool cycle)</td></tr>
<tr class="memdesc:ga0fbebbbcf601bcc0feab74edc95e37af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a texture-to-texture copy.  <br /></td></tr>
<tr class="separator:ga0fbebbbcf601bcc0feab74edc95e37af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10c443a232ead5285455f1b57446530" id="r_gab10c443a232ead5285455f1b57446530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gab10c443a232ead5285455f1b57446530">SDL::CopyGPUBufferToBuffer</a> (<a class="el" href="classSDL_1_1GPUCopyPass.html">GPUCopyPass</a> copy_pass, const <a class="el" href="group__CategoryGPU.html#ga6b24b7fc30f477db4a44bc2f1637bd35">GPUBufferLocation</a> &amp;source, const <a class="el" href="group__CategoryGPU.html#ga6b24b7fc30f477db4a44bc2f1637bd35">GPUBufferLocation</a> &amp;destination, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> size, bool cycle)</td></tr>
<tr class="memdesc:gab10c443a232ead5285455f1b57446530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a buffer-to-buffer copy.  <br /></td></tr>
<tr class="separator:gab10c443a232ead5285455f1b57446530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9ff23e7e51356708dfc42549d4a5087" id="r_gad9ff23e7e51356708dfc42549d4a5087"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gad9ff23e7e51356708dfc42549d4a5087">SDL::DownloadFromGPUTexture</a> (<a class="el" href="classSDL_1_1GPUCopyPass.html">GPUCopyPass</a> copy_pass, const <a class="el" href="group__CategoryGPU.html#ga0a4272ec9f67111e0956cfe1f999f903">GPUTextureRegion</a> &amp;source, const <a class="el" href="group__CategoryGPU.html#ga62c3161f89c494e71fef4b8bbd471167">GPUTextureTransferInfo</a> &amp;destination)</td></tr>
<tr class="memdesc:gad9ff23e7e51356708dfc42549d4a5087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a texture to a transfer buffer on the GPU timeline.  <br /></td></tr>
<tr class="separator:gad9ff23e7e51356708dfc42549d4a5087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a58581a8c83f67fbc3546078a209b9d" id="r_ga8a58581a8c83f67fbc3546078a209b9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga8a58581a8c83f67fbc3546078a209b9d">SDL::DownloadFromGPUBuffer</a> (<a class="el" href="classSDL_1_1GPUCopyPass.html">GPUCopyPass</a> copy_pass, const <a class="el" href="group__CategoryGPU.html#gac3310186554cb88f7b1a1599171aabdf">GPUBufferRegion</a> &amp;source, const <a class="el" href="group__CategoryGPU.html#ga9faa5600aabe5cabf35cbdf09851af6d">GPUTransferBufferLocation</a> &amp;destination)</td></tr>
<tr class="memdesc:ga8a58581a8c83f67fbc3546078a209b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a buffer to a transfer buffer on the GPU timeline.  <br /></td></tr>
<tr class="separator:ga8a58581a8c83f67fbc3546078a209b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae173376011ce271f5b16c8e930f70278" id="r_gae173376011ce271f5b16c8e930f70278"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gae173376011ce271f5b16c8e930f70278">SDL::EndGPUCopyPass</a> (<a class="el" href="classSDL_1_1GPUCopyPass.html">GPUCopyPass</a> copy_pass)</td></tr>
<tr class="memdesc:gae173376011ce271f5b16c8e930f70278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends the current copy pass.  <br /></td></tr>
<tr class="separator:gae173376011ce271f5b16c8e930f70278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7e8c2e454131a5bf3fa6a52a862148f" id="r_gaa7e8c2e454131a5bf3fa6a52a862148f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa7e8c2e454131a5bf3fa6a52a862148f">SDL::GenerateMipmapsForGPUTexture</a> (<a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a> command_buffer, <a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a> texture)</td></tr>
<tr class="memdesc:gaa7e8c2e454131a5bf3fa6a52a862148f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates mipmaps for the given texture.  <br /></td></tr>
<tr class="separator:gaa7e8c2e454131a5bf3fa6a52a862148f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga123ea0dae77b7f646aee56c82fde1f69" id="r_ga123ea0dae77b7f646aee56c82fde1f69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga123ea0dae77b7f646aee56c82fde1f69">SDL::BlitGPUTexture</a> (<a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a> command_buffer, const <a class="el" href="group__CategoryGPU.html#gaabb30629d61cc6f590279354030c3f73">GPUBlitInfo</a> &amp;info)</td></tr>
<tr class="memdesc:ga123ea0dae77b7f646aee56c82fde1f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blits from a source texture region to a destination texture region.  <br /></td></tr>
<tr class="separator:ga123ea0dae77b7f646aee56c82fde1f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga904f586db6ff9081c77aa1dcdc4c7c03" id="r_ga904f586db6ff9081c77aa1dcdc4c7c03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga904f586db6ff9081c77aa1dcdc4c7c03">SDL::WindowSupportsGPUSwapchainComposition</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a> window, <a class="el" href="group__CategoryGPU.html#gaa555f571dd4b1b9e5af82ee607a71fc5">GPUSwapchainComposition</a> swapchain_composition)</td></tr>
<tr class="memdesc:ga904f586db6ff9081c77aa1dcdc4c7c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a swapchain composition is supported by the window.  <br /></td></tr>
<tr class="separator:ga904f586db6ff9081c77aa1dcdc4c7c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadacc63a189cf4d0bec8e06b4d6e6d00c" id="r_gadacc63a189cf4d0bec8e06b4d6e6d00c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gadacc63a189cf4d0bec8e06b4d6e6d00c">SDL::WindowSupportsGPUPresentMode</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a> window, <a class="el" href="group__CategoryGPU.html#ga695f2e29e8b1cc9061a08a95ae9690e5">GPUPresentMode</a> present_mode)</td></tr>
<tr class="memdesc:gadacc63a189cf4d0bec8e06b4d6e6d00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a presentation mode is supported by the window.  <br /></td></tr>
<tr class="separator:gadacc63a189cf4d0bec8e06b4d6e6d00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d1d6f5c1e4f0a1c097cbc1b40b86b78" id="r_ga3d1d6f5c1e4f0a1c097cbc1b40b86b78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga3d1d6f5c1e4f0a1c097cbc1b40b86b78">SDL::ClaimWindowForGPUDevice</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a> window)</td></tr>
<tr class="memdesc:ga3d1d6f5c1e4f0a1c097cbc1b40b86b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Claims a window, creating a swapchain structure for it.  <br /></td></tr>
<tr class="separator:ga3d1d6f5c1e4f0a1c097cbc1b40b86b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d8a04f7c1bbc5de4c5e62977c4777cb" id="r_ga4d8a04f7c1bbc5de4c5e62977c4777cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga4d8a04f7c1bbc5de4c5e62977c4777cb">SDL::ReleaseWindowFromGPUDevice</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a> window)</td></tr>
<tr class="memdesc:ga4d8a04f7c1bbc5de4c5e62977c4777cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unclaims a window, destroying its swapchain structure.  <br /></td></tr>
<tr class="separator:ga4d8a04f7c1bbc5de4c5e62977c4777cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6747a3be03c0833106ec543f63625176" id="r_ga6747a3be03c0833106ec543f63625176"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga6747a3be03c0833106ec543f63625176">SDL::SetGPUSwapchainParameters</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a> window, <a class="el" href="group__CategoryGPU.html#gaa555f571dd4b1b9e5af82ee607a71fc5">GPUSwapchainComposition</a> swapchain_composition, <a class="el" href="group__CategoryGPU.html#ga695f2e29e8b1cc9061a08a95ae9690e5">GPUPresentMode</a> present_mode)</td></tr>
<tr class="memdesc:ga6747a3be03c0833106ec543f63625176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the swapchain parameters for the given claimed window.  <br /></td></tr>
<tr class="separator:ga6747a3be03c0833106ec543f63625176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae33e829c160d187e5798e197c4329bca" id="r_gae33e829c160d187e5798e197c4329bca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gae33e829c160d187e5798e197c4329bca">SDL::SetGPUAllowedFramesInFlight</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> allowed_frames_in_flight)</td></tr>
<tr class="memdesc:gae33e829c160d187e5798e197c4329bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the maximum allowed number of frames in flight.  <br /></td></tr>
<tr class="separator:gae33e829c160d187e5798e197c4329bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1bb6fdbd568ea6168038e6499d8e632" id="r_gac1bb6fdbd568ea6168038e6499d8e632"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gac1bb6fdbd568ea6168038e6499d8e632">SDL::GetGPUSwapchainTextureFormat</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a> window)</td></tr>
<tr class="memdesc:gac1bb6fdbd568ea6168038e6499d8e632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the texture format of the swapchain for the given window.  <br /></td></tr>
<tr class="separator:gac1bb6fdbd568ea6168038e6499d8e632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e1aabbbf23f17368c09dfb4967ced9c" id="r_ga0e1aabbbf23f17368c09dfb4967ced9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga0e1aabbbf23f17368c09dfb4967ced9c">SDL::AcquireGPUSwapchainTexture</a> (<a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a> command_buffer, <a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a> window, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> *swapchain_texture_width=nullptr, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> *swapchain_texture_height=nullptr)</td></tr>
<tr class="memdesc:ga0e1aabbbf23f17368c09dfb4967ced9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire a texture to use in presentation.  <br /></td></tr>
<tr class="separator:ga0e1aabbbf23f17368c09dfb4967ced9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab29626a894a352577739da2930ac2756" id="r_gab29626a894a352577739da2930ac2756"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gab29626a894a352577739da2930ac2756">SDL::WaitForGPUSwapchain</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a> window)</td></tr>
<tr class="memdesc:gab29626a894a352577739da2930ac2756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the thread until a swapchain texture is available to be acquired.  <br /></td></tr>
<tr class="separator:gab29626a894a352577739da2930ac2756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0981f23794ee1e41ecece8727766e692" id="r_ga0981f23794ee1e41ecece8727766e692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga0981f23794ee1e41ecece8727766e692">SDL::WaitAndAcquireGPUSwapchainTexture</a> (<a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a> command_buffer, <a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a> window, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> *swapchain_texture_width=nullptr, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> *swapchain_texture_height=nullptr)</td></tr>
<tr class="memdesc:ga0981f23794ee1e41ecece8727766e692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the thread until a swapchain texture is available to be acquired, and then acquires it.  <br /></td></tr>
<tr class="separator:ga0981f23794ee1e41ecece8727766e692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf02465fef670ff039324bbcb7dff3ea9" id="r_gaf02465fef670ff039324bbcb7dff3ea9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf02465fef670ff039324bbcb7dff3ea9">SDL::SubmitGPUCommandBuffer</a> (<a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a> command_buffer)</td></tr>
<tr class="memdesc:gaf02465fef670ff039324bbcb7dff3ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a command buffer so its commands can be processed on the GPU.  <br /></td></tr>
<tr class="separator:gaf02465fef670ff039324bbcb7dff3ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12c61d85c573ea886f0abdef6c88a301" id="r_ga12c61d85c573ea886f0abdef6c88a301"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategoryGPU.html#gaeb64f32b16e58d8fcfc1baf718975d3b">GPUFence</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga12c61d85c573ea886f0abdef6c88a301">SDL::SubmitGPUCommandBufferAndAcquireFence</a> (<a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a> command_buffer)</td></tr>
<tr class="memdesc:ga12c61d85c573ea886f0abdef6c88a301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a command buffer so its commands can be processed on the GPU, and acquires a fence associated with the command buffer.  <br /></td></tr>
<tr class="separator:ga12c61d85c573ea886f0abdef6c88a301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27c79b73d90fd76f73b2df0a67054f22" id="r_ga27c79b73d90fd76f73b2df0a67054f22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga27c79b73d90fd76f73b2df0a67054f22">SDL::CancelGPUCommandBuffer</a> (<a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a> command_buffer)</td></tr>
<tr class="memdesc:ga27c79b73d90fd76f73b2df0a67054f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels a command buffer.  <br /></td></tr>
<tr class="separator:ga27c79b73d90fd76f73b2df0a67054f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcd0f36650628136d8a5ed3aa7cd47e0" id="r_gadcd0f36650628136d8a5ed3aa7cd47e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gadcd0f36650628136d8a5ed3aa7cd47e0">SDL::WaitForGPUIdle</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device)</td></tr>
<tr class="memdesc:gadcd0f36650628136d8a5ed3aa7cd47e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the thread until the GPU is completely idle.  <br /></td></tr>
<tr class="separator:gadcd0f36650628136d8a5ed3aa7cd47e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabef2c73881dead5403eb1ea024faa9ea" id="r_gabef2c73881dead5403eb1ea024faa9ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gabef2c73881dead5403eb1ea024faa9ea">SDL::WaitForGPUFences</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, bool wait_all, std::span&lt; <a class="el" href="group__CategoryGPU.html#gaeb64f32b16e58d8fcfc1baf718975d3b">GPUFence</a> *const &gt; fences)</td></tr>
<tr class="memdesc:gabef2c73881dead5403eb1ea024faa9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the thread until the given fences are signaled.  <br /></td></tr>
<tr class="separator:gabef2c73881dead5403eb1ea024faa9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga522264abe3e3fd6f0b86b656e5373a64" id="r_ga522264abe3e3fd6f0b86b656e5373a64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga522264abe3e3fd6f0b86b656e5373a64">SDL::QueryGPUFence</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="group__CategoryGPU.html#gaeb64f32b16e58d8fcfc1baf718975d3b">GPUFence</a> *fence)</td></tr>
<tr class="memdesc:ga522264abe3e3fd6f0b86b656e5373a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the status of a fence.  <br /></td></tr>
<tr class="separator:ga522264abe3e3fd6f0b86b656e5373a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38b295d480145fdff3b9033032b182c2" id="r_ga38b295d480145fdff3b9033032b182c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga38b295d480145fdff3b9033032b182c2">SDL::ReleaseGPUFence</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="group__CategoryGPU.html#gaeb64f32b16e58d8fcfc1baf718975d3b">GPUFence</a> *fence)</td></tr>
<tr class="memdesc:ga38b295d480145fdff3b9033032b182c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a fence obtained from <a class="el" href="group__CategoryGPU.html#gad610ad628240f1b49aaa7eaec0ccd271" title="Submits a command buffer so its commands can be processed on the GPU, and acquires a fence associated...">GPUCommandBuffer.SubmitAndAcquireFence</a>.  <br /></td></tr>
<tr class="separator:ga38b295d480145fdff3b9033032b182c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37d622cd71737704ced8c1217b1a4649" id="r_ga37d622cd71737704ced8c1217b1a4649"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga37d622cd71737704ced8c1217b1a4649">SDL::GPUTextureFormatTexelBlockSize</a> (<a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> format)</td></tr>
<tr class="memdesc:ga37d622cd71737704ced8c1217b1a4649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the texel block size for a texture format.  <br /></td></tr>
<tr class="separator:ga37d622cd71737704ced8c1217b1a4649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37105d1a38c1a2fa8f2b7b799e71ec11" id="r_ga37105d1a38c1a2fa8f2b7b799e71ec11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga37105d1a38c1a2fa8f2b7b799e71ec11">SDL::GPUTextureSupportsFormat</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> format, <a class="el" href="group__CategoryGPU.html#ga624b29173aac1a009aa85c14f46024a3">GPUTextureType</a> type, <a class="el" href="group__CategoryGPU.html#ga5a847c301baaf527c8ba644f0f55a59e">GPUTextureUsageFlags</a> usage)</td></tr>
<tr class="memdesc:ga37105d1a38c1a2fa8f2b7b799e71ec11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a texture format is supported for a given type and usage.  <br /></td></tr>
<tr class="separator:ga37105d1a38c1a2fa8f2b7b799e71ec11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ce3b9c81c56935f7be1ee15444f1165" id="r_ga1ce3b9c81c56935f7be1ee15444f1165"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga1ce3b9c81c56935f7be1ee15444f1165">SDL::GPUTextureSupportsSampleCount</a> (<a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a> device, <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> format, <a class="el" href="group__CategoryGPU.html#ga5265d3385d1ddc106c614016bee759d9">GPUSampleCount</a> sample_count)</td></tr>
<tr class="memdesc:ga1ce3b9c81c56935f7be1ee15444f1165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a sample count for a texture format is supported.  <br /></td></tr>
<tr class="separator:ga1ce3b9c81c56935f7be1ee15444f1165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa45ed13d924cada7cb53f5b094c0057a" id="r_gaa45ed13d924cada7cb53f5b094c0057a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa45ed13d924cada7cb53f5b094c0057a">SDL::CalculateGPUTextureFormatSize</a> (<a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> format, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> width, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> height, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> depth_or_layer_count)</td></tr>
<tr class="memdesc:gaa45ed13d924cada7cb53f5b094c0057a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the size in bytes of a texture format with dimensions.  <br /></td></tr>
<tr class="separator:gaa45ed13d924cada7cb53f5b094c0057a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga006c1144e0ac31c12c5184682709c3d3" id="r_ga006c1144e0ac31c12c5184682709c3d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga006c1144e0ac31c12c5184682709c3d3">SDL::GPUDevice::Destroy</a> ()</td></tr>
<tr class="memdesc:ga006c1144e0ac31c12c5184682709c3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a GPU context previously returned by <a class="el" href="classSDL_1_1GPUDevice.html#a9fde3883d9146abd2533f4882d233906" title="Default ctor.">GPUDevice.GPUDevice</a>.  <br /></td></tr>
<tr class="separator:ga006c1144e0ac31c12c5184682709c3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09208b4ab434b99ecd69c1640179fde6" id="r_ga09208b4ab434b99ecd69c1640179fde6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga09208b4ab434b99ecd69c1640179fde6">SDL::GPUDevice::GetDriver</a> ()</td></tr>
<tr class="memdesc:ga09208b4ab434b99ecd69c1640179fde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the backend used to create this GPU context.  <br /></td></tr>
<tr class="separator:ga09208b4ab434b99ecd69c1640179fde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf82030e566bd87483a83fac84210f0e0" id="r_gaf82030e566bd87483a83fac84210f0e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">GPUShaderFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf82030e566bd87483a83fac84210f0e0">SDL::GPUDevice::GetShaderFormats</a> ()</td></tr>
<tr class="memdesc:gaf82030e566bd87483a83fac84210f0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the supported shader formats for this GPU context.  <br /></td></tr>
<tr class="separator:gaf82030e566bd87483a83fac84210f0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24a308465055fd5b67fda9a5fe246daa" id="r_ga24a308465055fd5b67fda9a5fe246daa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUComputePipeline.html">GPUComputePipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga24a308465055fd5b67fda9a5fe246daa">SDL::GPUDevice::CreateComputePipeline</a> (const <a class="el" href="group__CategoryGPU.html#ga9baa44a9f7478858ee1ac28037e0574f">GPUComputePipelineCreateInfo</a> &amp;createinfo)</td></tr>
<tr class="memdesc:ga24a308465055fd5b67fda9a5fe246daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pipeline object to be used in a compute workflow.  <br /></td></tr>
<tr class="separator:ga24a308465055fd5b67fda9a5fe246daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65eea93722c98ad0ce8bc7009b3da562" id="r_ga65eea93722c98ad0ce8bc7009b3da562"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html">GPUGraphicsPipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga65eea93722c98ad0ce8bc7009b3da562">SDL::GPUDevice::CreateGraphicsPipeline</a> (const <a class="el" href="group__CategoryGPU.html#ga60d171e0d2bee691d934e2275b2bf23b">GPUGraphicsPipelineCreateInfo</a> &amp;createinfo)</td></tr>
<tr class="memdesc:ga65eea93722c98ad0ce8bc7009b3da562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pipeline object to be used in a graphics workflow.  <br /></td></tr>
<tr class="separator:ga65eea93722c98ad0ce8bc7009b3da562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c36338cbceee7ec433558e923cb275b" id="r_ga1c36338cbceee7ec433558e923cb275b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUSampler.html">GPUSampler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga1c36338cbceee7ec433558e923cb275b">SDL::GPUDevice::CreateSampler</a> (const <a class="el" href="group__CategoryGPU.html#ga9905b04780e8798c8cd2bf18a29bff27">GPUSamplerCreateInfo</a> &amp;createinfo)</td></tr>
<tr class="memdesc:ga1c36338cbceee7ec433558e923cb275b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a sampler object to be used when binding textures in a graphics workflow.  <br /></td></tr>
<tr class="separator:ga1c36338cbceee7ec433558e923cb275b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac338fa10a4d70148cd16d6d55d2a5dae" id="r_gac338fa10a4d70148cd16d6d55d2a5dae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUShader.html">GPUShader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gac338fa10a4d70148cd16d6d55d2a5dae">SDL::GPUDevice::CreateShader</a> (const <a class="el" href="group__CategoryGPU.html#gaec6e01546fef70020c8f7b44da82be99">GPUShaderCreateInfo</a> &amp;createinfo)</td></tr>
<tr class="memdesc:gac338fa10a4d70148cd16d6d55d2a5dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shader to be used when creating a graphics pipeline.  <br /></td></tr>
<tr class="separator:gac338fa10a4d70148cd16d6d55d2a5dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac61cedc2ed961eec0ae3c7a5a9800c43" id="r_gac61cedc2ed961eec0ae3c7a5a9800c43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gac61cedc2ed961eec0ae3c7a5a9800c43">SDL::GPUDevice::CreateTexture</a> (const <a class="el" href="group__CategoryGPU.html#ga87fcb53cd9c731a4a4f3c7c10a5edb6a">GPUTextureCreateInfo</a> &amp;createinfo)</td></tr>
<tr class="memdesc:gac61cedc2ed961eec0ae3c7a5a9800c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a texture object to be used in graphics or compute workflows.  <br /></td></tr>
<tr class="separator:gac61cedc2ed961eec0ae3c7a5a9800c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51df2106760ad17d238ec8a3d07e8b60" id="r_ga51df2106760ad17d238ec8a3d07e8b60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga51df2106760ad17d238ec8a3d07e8b60">SDL::GPUDevice::CreateBuffer</a> (const <a class="el" href="group__CategoryGPU.html#ga6cb3830a3ade4303d47a017993de4fea">GPUBufferCreateInfo</a> &amp;createinfo)</td></tr>
<tr class="memdesc:ga51df2106760ad17d238ec8a3d07e8b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a buffer object to be used in graphics or compute workflows.  <br /></td></tr>
<tr class="separator:ga51df2106760ad17d238ec8a3d07e8b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ecc2006d014d2a988fdbd2cc0af4d38" id="r_ga9ecc2006d014d2a988fdbd2cc0af4d38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUTransferBuffer.html">GPUTransferBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga9ecc2006d014d2a988fdbd2cc0af4d38">SDL::GPUDevice::CreateTransferBuffer</a> (const <a class="el" href="group__CategoryGPU.html#gabf392df5f8790bf73f828ca3e1f21bd5">GPUTransferBufferCreateInfo</a> &amp;createinfo)</td></tr>
<tr class="memdesc:ga9ecc2006d014d2a988fdbd2cc0af4d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a transfer buffer to be used when uploading to or downloading from graphics resources.  <br /></td></tr>
<tr class="separator:ga9ecc2006d014d2a988fdbd2cc0af4d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f2208b408ff8e8d01504687eb27ad9d" id="r_ga9f2208b408ff8e8d01504687eb27ad9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga9f2208b408ff8e8d01504687eb27ad9d">SDL::GPUDevice::SetBufferName</a> (<a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a> buffer, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> text)</td></tr>
<tr class="memdesc:ga9f2208b408ff8e8d01504687eb27ad9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an arbitrary string constant to label a buffer.  <br /></td></tr>
<tr class="separator:ga9f2208b408ff8e8d01504687eb27ad9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabce01d5f2ece06d59e630a721241dfe2" id="r_gabce01d5f2ece06d59e630a721241dfe2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gabce01d5f2ece06d59e630a721241dfe2">SDL::GPUDevice::SetTextureName</a> (<a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a> texture, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> text)</td></tr>
<tr class="memdesc:gabce01d5f2ece06d59e630a721241dfe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an arbitrary string constant to label a texture.  <br /></td></tr>
<tr class="separator:gabce01d5f2ece06d59e630a721241dfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5bf0e54cbed9dd35cfce8a28d834663" id="r_gac5bf0e54cbed9dd35cfce8a28d834663"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gac5bf0e54cbed9dd35cfce8a28d834663">SDL::GPUCommandBuffer::InsertDebugLabel</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> text)</td></tr>
<tr class="memdesc:gac5bf0e54cbed9dd35cfce8a28d834663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an arbitrary string label into the command buffer callstream.  <br /></td></tr>
<tr class="separator:gac5bf0e54cbed9dd35cfce8a28d834663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae97164be3b0fb5e9566f8db2d3d46015" id="r_gae97164be3b0fb5e9566f8db2d3d46015"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gae97164be3b0fb5e9566f8db2d3d46015">SDL::GPUCommandBuffer::PushDebugGroup</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> name)</td></tr>
<tr class="memdesc:gae97164be3b0fb5e9566f8db2d3d46015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a debug group with an arbitrary name.  <br /></td></tr>
<tr class="separator:gae97164be3b0fb5e9566f8db2d3d46015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5b665b341039657de084915adf4a720" id="r_gab5b665b341039657de084915adf4a720"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gab5b665b341039657de084915adf4a720">SDL::GPUCommandBuffer::PopDebugGroup</a> ()</td></tr>
<tr class="memdesc:gab5b665b341039657de084915adf4a720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends the most-recently pushed debug group.  <br /></td></tr>
<tr class="separator:gab5b665b341039657de084915adf4a720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95ea4befed403fa9c10298c547c9b95e" id="r_ga95ea4befed403fa9c10298c547c9b95e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga95ea4befed403fa9c10298c547c9b95e">SDL::GPUDevice::ReleaseTexture</a> (<a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a> texture)</td></tr>
<tr class="memdesc:ga95ea4befed403fa9c10298c547c9b95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the given texture as soon as it is safe to do so.  <br /></td></tr>
<tr class="separator:ga95ea4befed403fa9c10298c547c9b95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69f056178de21168997a6554cbc27c1e" id="r_ga69f056178de21168997a6554cbc27c1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga69f056178de21168997a6554cbc27c1e">SDL::GPUDevice::ReleaseSampler</a> (<a class="el" href="classSDL_1_1GPUSampler.html">GPUSampler</a> sampler)</td></tr>
<tr class="memdesc:ga69f056178de21168997a6554cbc27c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the given sampler as soon as it is safe to do so.  <br /></td></tr>
<tr class="separator:ga69f056178de21168997a6554cbc27c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5dc66c265218b99bb458030cac57723" id="r_gab5dc66c265218b99bb458030cac57723"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gab5dc66c265218b99bb458030cac57723">SDL::GPUDevice::ReleaseBuffer</a> (<a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a> buffer)</td></tr>
<tr class="memdesc:gab5dc66c265218b99bb458030cac57723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the given buffer as soon as it is safe to do so.  <br /></td></tr>
<tr class="separator:gab5dc66c265218b99bb458030cac57723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a709128809970cdde83691bb4a5b040" id="r_ga1a709128809970cdde83691bb4a5b040"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga1a709128809970cdde83691bb4a5b040">SDL::GPUDevice::ReleaseTransferBuffer</a> (<a class="el" href="classSDL_1_1GPUTransferBuffer.html">GPUTransferBuffer</a> transfer_buffer)</td></tr>
<tr class="memdesc:ga1a709128809970cdde83691bb4a5b040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the given transfer buffer as soon as it is safe to do so.  <br /></td></tr>
<tr class="separator:ga1a709128809970cdde83691bb4a5b040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c669ef6c9ab4c71b8ef7834e7a39975" id="r_ga4c669ef6c9ab4c71b8ef7834e7a39975"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga4c669ef6c9ab4c71b8ef7834e7a39975">SDL::GPUDevice::ReleaseComputePipeline</a> (<a class="el" href="classSDL_1_1GPUComputePipeline.html">GPUComputePipeline</a> compute_pipeline)</td></tr>
<tr class="memdesc:ga4c669ef6c9ab4c71b8ef7834e7a39975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the given compute pipeline as soon as it is safe to do so.  <br /></td></tr>
<tr class="separator:ga4c669ef6c9ab4c71b8ef7834e7a39975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a193a6c5e5396d8b09aeadaf537fdec" id="r_ga1a193a6c5e5396d8b09aeadaf537fdec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga1a193a6c5e5396d8b09aeadaf537fdec">SDL::GPUDevice::ReleaseShader</a> (<a class="el" href="classSDL_1_1GPUShader.html">GPUShader</a> shader)</td></tr>
<tr class="memdesc:ga1a193a6c5e5396d8b09aeadaf537fdec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the given shader as soon as it is safe to do so.  <br /></td></tr>
<tr class="separator:ga1a193a6c5e5396d8b09aeadaf537fdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3c154a75ac11895cf331e4d32796ea0" id="r_gad3c154a75ac11895cf331e4d32796ea0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gad3c154a75ac11895cf331e4d32796ea0">SDL::GPUDevice::ReleaseGraphicsPipeline</a> (<a class="el" href="classSDL_1_1GPUGraphicsPipeline.html">GPUGraphicsPipeline</a> graphics_pipeline)</td></tr>
<tr class="memdesc:gad3c154a75ac11895cf331e4d32796ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the given graphics pipeline as soon as it is safe to do so.  <br /></td></tr>
<tr class="separator:gad3c154a75ac11895cf331e4d32796ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3afecf456819388452c8af3797f84547" id="r_ga3afecf456819388452c8af3797f84547"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga3afecf456819388452c8af3797f84547">SDL::GPUDevice::AcquireCommandBuffer</a> ()</td></tr>
<tr class="memdesc:ga3afecf456819388452c8af3797f84547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire a command buffer.  <br /></td></tr>
<tr class="separator:ga3afecf456819388452c8af3797f84547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa57c6b82ad0455dbdcf7fe87e3a15199" id="r_gaa57c6b82ad0455dbdcf7fe87e3a15199"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa57c6b82ad0455dbdcf7fe87e3a15199">SDL::GPUCommandBuffer::PushVertexUniformData</a> (<a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> slot_index, <a class="el" href="classSDL_1_1SourceBytes.html">SourceBytes</a> data)</td></tr>
<tr class="memdesc:gaa57c6b82ad0455dbdcf7fe87e3a15199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes data to a vertex uniform slot on the command buffer.  <br /></td></tr>
<tr class="separator:gaa57c6b82ad0455dbdcf7fe87e3a15199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1376bc7dc6bf928fcba014e6de7f7e8" id="r_gaa1376bc7dc6bf928fcba014e6de7f7e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa1376bc7dc6bf928fcba014e6de7f7e8">SDL::GPUCommandBuffer::PushFragmentUniformData</a> (<a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> slot_index, <a class="el" href="classSDL_1_1SourceBytes.html">SourceBytes</a> data)</td></tr>
<tr class="memdesc:gaa1376bc7dc6bf928fcba014e6de7f7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes data to a fragment uniform slot on the command buffer.  <br /></td></tr>
<tr class="separator:gaa1376bc7dc6bf928fcba014e6de7f7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03d49babc2c6fcf28f0591bc31cc5d83" id="r_ga03d49babc2c6fcf28f0591bc31cc5d83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga03d49babc2c6fcf28f0591bc31cc5d83">SDL::GPUCommandBuffer::PushComputeUniformData</a> (<a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> slot_index, <a class="el" href="classSDL_1_1SourceBytes.html">SourceBytes</a> data)</td></tr>
<tr class="memdesc:ga03d49babc2c6fcf28f0591bc31cc5d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes data to a uniform slot on the command buffer.  <br /></td></tr>
<tr class="separator:ga03d49babc2c6fcf28f0591bc31cc5d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf954393ca11e67b26e5ab32b5c85a56e" id="r_gaf954393ca11e67b26e5ab32b5c85a56e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf954393ca11e67b26e5ab32b5c85a56e">SDL::GPUCommandBuffer::BeginRenderPass</a> (std::span&lt; const <a class="el" href="group__CategoryGPU.html#ga26904510dffa9db5b09c79637b00edbc">GPUColorTargetInfo</a> &gt; color_target_infos, <a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga28e62eba4af4c55395ef3cecf7fc0ebc">GPUDepthStencilTargetInfo</a> &gt; depth_stencil_target_info)</td></tr>
<tr class="memdesc:gaf954393ca11e67b26e5ab32b5c85a56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a render pass on a command buffer.  <br /></td></tr>
<tr class="separator:gaf954393ca11e67b26e5ab32b5c85a56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe7475370741dbc4a0b9ec8fbafd5c63" id="r_gabe7475370741dbc4a0b9ec8fbafd5c63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gabe7475370741dbc4a0b9ec8fbafd5c63">SDL::GPURenderPass::BindPipeline</a> (<a class="el" href="classSDL_1_1GPUGraphicsPipeline.html">GPUGraphicsPipeline</a> graphics_pipeline)</td></tr>
<tr class="memdesc:gabe7475370741dbc4a0b9ec8fbafd5c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a graphics pipeline on a render pass to be used in rendering.  <br /></td></tr>
<tr class="separator:gabe7475370741dbc4a0b9ec8fbafd5c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dca24a164e094b5a9959e3e96872be1" id="r_ga5dca24a164e094b5a9959e3e96872be1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga5dca24a164e094b5a9959e3e96872be1">SDL::GPURenderPass::SetViewport</a> (const <a class="el" href="group__CategoryGPU.html#gaf80d3281c271f2f02de8d8e14648fe20">GPUViewport</a> &amp;viewport)</td></tr>
<tr class="memdesc:ga5dca24a164e094b5a9959e3e96872be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current viewport state on a command buffer.  <br /></td></tr>
<tr class="separator:ga5dca24a164e094b5a9959e3e96872be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24da70f6b4278e527620189088a99a6c" id="r_ga24da70f6b4278e527620189088a99a6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga24da70f6b4278e527620189088a99a6c">SDL::GPURenderPass::SetScissor</a> (const <a class="el" href="group__CategoryRect.html#gadeb77054b31c63a38d6594652fb0b7f4">RectRaw</a> &amp;scissor)</td></tr>
<tr class="memdesc:ga24da70f6b4278e527620189088a99a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current scissor state on a command buffer.  <br /></td></tr>
<tr class="separator:ga24da70f6b4278e527620189088a99a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab98b11b475384dcc4f5a306583d819af" id="r_gab98b11b475384dcc4f5a306583d819af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gab98b11b475384dcc4f5a306583d819af">SDL::GPURenderPass::SetBlendConstants</a> (<a class="el" href="group__CategoryPixels.html#gadfaf5b77d5957860167740c745343e4e">FColorRaw</a> blend_constants)</td></tr>
<tr class="memdesc:gab98b11b475384dcc4f5a306583d819af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current blend constants on a command buffer.  <br /></td></tr>
<tr class="separator:gab98b11b475384dcc4f5a306583d819af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40077d8ac37cc564db0a696bd0c32b91" id="r_ga40077d8ac37cc564db0a696bd0c32b91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga40077d8ac37cc564db0a696bd0c32b91">SDL::GPURenderPass::SetStencilReference</a> (<a class="el" href="group__CategoryStdinc.html#gadeddb36a6d67c5bc92003dd7679b4b17">Uint8</a> reference)</td></tr>
<tr class="memdesc:ga40077d8ac37cc564db0a696bd0c32b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current stencil reference value on a command buffer.  <br /></td></tr>
<tr class="separator:ga40077d8ac37cc564db0a696bd0c32b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92908a319a7f02815bda65d27d1dcbfc" id="r_ga92908a319a7f02815bda65d27d1dcbfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga92908a319a7f02815bda65d27d1dcbfc">SDL::GPURenderPass::BindVertexBuffers</a> (<a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_slot, std::span&lt; const <a class="el" href="group__CategoryGPU.html#ga698bbc29bd1e44bec1e2b87ce3a81dbb">GPUBufferBinding</a> &gt; bindings)</td></tr>
<tr class="memdesc:ga92908a319a7f02815bda65d27d1dcbfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds vertex buffers on a command buffer for use with subsequent draw calls.  <br /></td></tr>
<tr class="separator:ga92908a319a7f02815bda65d27d1dcbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81998c754544c2c494ec36f5450e6318" id="r_ga81998c754544c2c494ec36f5450e6318"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga81998c754544c2c494ec36f5450e6318">SDL::GPURenderPass::BindIndexBuffer</a> (const <a class="el" href="group__CategoryGPU.html#ga698bbc29bd1e44bec1e2b87ce3a81dbb">GPUBufferBinding</a> &amp;binding, <a class="el" href="group__CategoryGPU.html#gaec587594b432d13ab2ddd78ad77342a7">GPUIndexElementSize</a> index_element_size)</td></tr>
<tr class="memdesc:ga81998c754544c2c494ec36f5450e6318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds an index buffer on a command buffer for use with subsequent draw calls.  <br /></td></tr>
<tr class="separator:ga81998c754544c2c494ec36f5450e6318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ca101f553e4044b77d14c04f50d96ff" id="r_ga4ca101f553e4044b77d14c04f50d96ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga4ca101f553e4044b77d14c04f50d96ff">SDL::GPURenderPass::BindVertexSamplers</a> (<a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_slot, std::span&lt; const <a class="el" href="group__CategoryGPU.html#ga86e968acd12b623cb7b5056c323285b3">GPUTextureSamplerBinding</a> &gt; texture_sampler_bindings)</td></tr>
<tr class="memdesc:ga4ca101f553e4044b77d14c04f50d96ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds texture-sampler pairs for use on the vertex shader.  <br /></td></tr>
<tr class="separator:ga4ca101f553e4044b77d14c04f50d96ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5679461b5fbc2a4c6604a5c5e35b2afb" id="r_ga5679461b5fbc2a4c6604a5c5e35b2afb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga5679461b5fbc2a4c6604a5c5e35b2afb">SDL::GPURenderPass::BindVertexStorageTextures</a> (<a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_slot, <a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga07bab3d86cb28ae9761a1c91b04c285f">GPUTextureRaw</a> &gt; storage_textures)</td></tr>
<tr class="memdesc:ga5679461b5fbc2a4c6604a5c5e35b2afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds storage textures for use on the vertex shader.  <br /></td></tr>
<tr class="separator:ga5679461b5fbc2a4c6604a5c5e35b2afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9487a0e6987e3d52ac8193bccc389bbf" id="r_ga9487a0e6987e3d52ac8193bccc389bbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga9487a0e6987e3d52ac8193bccc389bbf">SDL::GPURenderPass::BindVertexStorageBuffers</a> (<a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_slot, <a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga729f924587e663dffcd630a594e14396">GPUBufferRaw</a> &gt; storage_buffers)</td></tr>
<tr class="memdesc:ga9487a0e6987e3d52ac8193bccc389bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds storage buffers for use on the vertex shader.  <br /></td></tr>
<tr class="separator:ga9487a0e6987e3d52ac8193bccc389bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3566cec8f39f95f37f2f7c66653c4c55" id="r_ga3566cec8f39f95f37f2f7c66653c4c55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga3566cec8f39f95f37f2f7c66653c4c55">SDL::GPURenderPass::BindFragmentSamplers</a> (<a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_slot, std::span&lt; const <a class="el" href="group__CategoryGPU.html#ga86e968acd12b623cb7b5056c323285b3">GPUTextureSamplerBinding</a> &gt; texture_sampler_bindings)</td></tr>
<tr class="memdesc:ga3566cec8f39f95f37f2f7c66653c4c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds texture-sampler pairs for use on the fragment shader.  <br /></td></tr>
<tr class="separator:ga3566cec8f39f95f37f2f7c66653c4c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4842b7086c6105187135bdc9526266c9" id="r_ga4842b7086c6105187135bdc9526266c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga4842b7086c6105187135bdc9526266c9">SDL::GPURenderPass::BindFragmentStorageTextures</a> (<a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_slot, <a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga07bab3d86cb28ae9761a1c91b04c285f">GPUTextureRaw</a> &gt; storage_textures)</td></tr>
<tr class="memdesc:ga4842b7086c6105187135bdc9526266c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds storage textures for use on the fragment shader.  <br /></td></tr>
<tr class="separator:ga4842b7086c6105187135bdc9526266c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6908db6f33fe0605f2a4b9aa9bb23877" id="r_ga6908db6f33fe0605f2a4b9aa9bb23877"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga6908db6f33fe0605f2a4b9aa9bb23877">SDL::GPURenderPass::BindFragmentStorageBuffers</a> (<a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_slot, <a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga729f924587e663dffcd630a594e14396">GPUBufferRaw</a> &gt; storage_buffers)</td></tr>
<tr class="memdesc:ga6908db6f33fe0605f2a4b9aa9bb23877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds storage buffers for use on the fragment shader.  <br /></td></tr>
<tr class="separator:ga6908db6f33fe0605f2a4b9aa9bb23877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b313e7ad8440bc9c9f54dd6623862eb" id="r_ga1b313e7ad8440bc9c9f54dd6623862eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga1b313e7ad8440bc9c9f54dd6623862eb">SDL::GPURenderPass::DrawIndexedPrimitives</a> (<a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> num_indices, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> num_instances, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_index, <a class="el" href="group__CategoryStdinc.html#ga52ae1b7d45c9c8e49e98cd479de3694b">Sint32</a> vertex_offset, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_instance)</td></tr>
<tr class="memdesc:ga1b313e7ad8440bc9c9f54dd6623862eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws data using bound graphics state with an index buffer and instancing enabled.  <br /></td></tr>
<tr class="separator:ga1b313e7ad8440bc9c9f54dd6623862eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee46a464d450edc057c4a1fa60adf855" id="r_gaee46a464d450edc057c4a1fa60adf855"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaee46a464d450edc057c4a1fa60adf855">SDL::GPURenderPass::DrawPrimitives</a> (<a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> num_vertices, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> num_instances, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_vertex, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_instance)</td></tr>
<tr class="memdesc:gaee46a464d450edc057c4a1fa60adf855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws data using bound graphics state.  <br /></td></tr>
<tr class="separator:gaee46a464d450edc057c4a1fa60adf855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cad31422505ada85f19d81536dfe3d9" id="r_ga4cad31422505ada85f19d81536dfe3d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga4cad31422505ada85f19d81536dfe3d9">SDL::GPURenderPass::DrawPrimitivesIndirect</a> (<a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a> buffer, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> offset, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> draw_count)</td></tr>
<tr class="memdesc:ga4cad31422505ada85f19d81536dfe3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws data using bound graphics state and with draw parameters set from a buffer.  <br /></td></tr>
<tr class="separator:ga4cad31422505ada85f19d81536dfe3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafef162b6d49f6d172616026fbc1d5b37" id="r_gafef162b6d49f6d172616026fbc1d5b37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gafef162b6d49f6d172616026fbc1d5b37">SDL::GPURenderPass::DrawIndexedPrimitivesIndirect</a> (<a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a> buffer, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> offset, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> draw_count)</td></tr>
<tr class="memdesc:gafef162b6d49f6d172616026fbc1d5b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws data using bound graphics state with an index buffer enabled and with draw parameters set from a buffer.  <br /></td></tr>
<tr class="separator:gafef162b6d49f6d172616026fbc1d5b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93da9193744c70e7d6334440a676b787" id="r_ga93da9193744c70e7d6334440a676b787"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga93da9193744c70e7d6334440a676b787">SDL::GPURenderPass::End</a> ()</td></tr>
<tr class="memdesc:ga93da9193744c70e7d6334440a676b787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends the given render pass.  <br /></td></tr>
<tr class="separator:ga93da9193744c70e7d6334440a676b787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94a40eb89d9af8a06054a029bcc92dc7" id="r_ga94a40eb89d9af8a06054a029bcc92dc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUComputePass.html">GPUComputePass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga94a40eb89d9af8a06054a029bcc92dc7">SDL::GPUCommandBuffer::BeginComputePass</a> (std::span&lt; const <a class="el" href="group__CategoryGPU.html#gaa4da71fb9f200b3a944c027d10c42675">GPUStorageTextureReadWriteBinding</a> &gt; storage_texture_bindings, std::span&lt; const <a class="el" href="group__CategoryGPU.html#gad1bd097ca5ba900d062e99162e62ab2c">GPUStorageBufferReadWriteBinding</a> &gt; storage_buffer_bindings)</td></tr>
<tr class="memdesc:ga94a40eb89d9af8a06054a029bcc92dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a compute pass on a command buffer.  <br /></td></tr>
<tr class="separator:ga94a40eb89d9af8a06054a029bcc92dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac753bb4535cbb52be02c8aca142abea3" id="r_gac753bb4535cbb52be02c8aca142abea3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gac753bb4535cbb52be02c8aca142abea3">SDL::GPUComputePass::BindPipeline</a> (<a class="el" href="classSDL_1_1GPUComputePipeline.html">GPUComputePipeline</a> compute_pipeline)</td></tr>
<tr class="memdesc:gac753bb4535cbb52be02c8aca142abea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a compute pipeline on a command buffer for use in compute dispatch.  <br /></td></tr>
<tr class="separator:gac753bb4535cbb52be02c8aca142abea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga336fc1ded40e54a60d884f0d78a30b98" id="r_ga336fc1ded40e54a60d884f0d78a30b98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga336fc1ded40e54a60d884f0d78a30b98">SDL::GPUComputePass::BindSamplers</a> (<a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_slot, std::span&lt; const <a class="el" href="group__CategoryGPU.html#ga86e968acd12b623cb7b5056c323285b3">GPUTextureSamplerBinding</a> &gt; texture_sampler_bindings)</td></tr>
<tr class="memdesc:ga336fc1ded40e54a60d884f0d78a30b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds texture-sampler pairs for use on the compute shader.  <br /></td></tr>
<tr class="separator:ga336fc1ded40e54a60d884f0d78a30b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedb0e69f7d25a28e1230ab5e02aa18af" id="r_gaedb0e69f7d25a28e1230ab5e02aa18af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaedb0e69f7d25a28e1230ab5e02aa18af">SDL::GPUComputePass::BindStorageTextures</a> (<a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_slot, <a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga07bab3d86cb28ae9761a1c91b04c285f">GPUTextureRaw</a> &gt; storage_textures)</td></tr>
<tr class="memdesc:gaedb0e69f7d25a28e1230ab5e02aa18af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds storage textures as readonly for use on the compute pipeline.  <br /></td></tr>
<tr class="separator:gaedb0e69f7d25a28e1230ab5e02aa18af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3867eeb6d7a78593063877ae13c11085" id="r_ga3867eeb6d7a78593063877ae13c11085"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga3867eeb6d7a78593063877ae13c11085">SDL::GPUComputePass::BindStorageBuffers</a> (<a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> first_slot, <a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga729f924587e663dffcd630a594e14396">GPUBufferRaw</a> &gt; storage_buffers)</td></tr>
<tr class="memdesc:ga3867eeb6d7a78593063877ae13c11085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds storage buffers as readonly for use on the compute pipeline.  <br /></td></tr>
<tr class="separator:ga3867eeb6d7a78593063877ae13c11085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga035cf70f11f2a3fb5061495b7e4b1c97" id="r_ga035cf70f11f2a3fb5061495b7e4b1c97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga035cf70f11f2a3fb5061495b7e4b1c97">SDL::GPUComputePass::Dispatch</a> (<a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> groupcount_x, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> groupcount_y, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> groupcount_z)</td></tr>
<tr class="memdesc:ga035cf70f11f2a3fb5061495b7e4b1c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches compute work.  <br /></td></tr>
<tr class="separator:ga035cf70f11f2a3fb5061495b7e4b1c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bd535fc79d0e38398d97b34f3640dd2" id="r_ga5bd535fc79d0e38398d97b34f3640dd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga5bd535fc79d0e38398d97b34f3640dd2">SDL::GPUComputePass::DispatchIndirect</a> (<a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a> buffer, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> offset)</td></tr>
<tr class="memdesc:ga5bd535fc79d0e38398d97b34f3640dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches compute work with parameters set from a buffer.  <br /></td></tr>
<tr class="separator:ga5bd535fc79d0e38398d97b34f3640dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7419495ee08e074491b534155cee2daf" id="r_ga7419495ee08e074491b534155cee2daf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga7419495ee08e074491b534155cee2daf">SDL::GPUComputePass::End</a> ()</td></tr>
<tr class="memdesc:ga7419495ee08e074491b534155cee2daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends the current compute pass.  <br /></td></tr>
<tr class="separator:ga7419495ee08e074491b534155cee2daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cf97fcd43dd972f87051ba4b3d6ebec" id="r_ga1cf97fcd43dd972f87051ba4b3d6ebec"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga1cf97fcd43dd972f87051ba4b3d6ebec">SDL::GPUDevice::MapTransferBuffer</a> (<a class="el" href="classSDL_1_1GPUTransferBuffer.html">GPUTransferBuffer</a> transfer_buffer, bool cycle)</td></tr>
<tr class="memdesc:ga1cf97fcd43dd972f87051ba4b3d6ebec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a transfer buffer into application address space.  <br /></td></tr>
<tr class="separator:ga1cf97fcd43dd972f87051ba4b3d6ebec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69ee23a532fc7ab5ed15480500de6b0e" id="r_ga69ee23a532fc7ab5ed15480500de6b0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga69ee23a532fc7ab5ed15480500de6b0e">SDL::GPUDevice::UnmapTransferBuffer</a> (<a class="el" href="classSDL_1_1GPUTransferBuffer.html">GPUTransferBuffer</a> transfer_buffer)</td></tr>
<tr class="memdesc:ga69ee23a532fc7ab5ed15480500de6b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmaps a previously mapped transfer buffer.  <br /></td></tr>
<tr class="separator:ga69ee23a532fc7ab5ed15480500de6b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5260dd36b46eea0864c1dbd89c544df2" id="r_ga5260dd36b46eea0864c1dbd89c544df2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUCopyPass.html">GPUCopyPass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga5260dd36b46eea0864c1dbd89c544df2">SDL::GPUCommandBuffer::BeginCopyPass</a> ()</td></tr>
<tr class="memdesc:ga5260dd36b46eea0864c1dbd89c544df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a copy pass on a command buffer.  <br /></td></tr>
<tr class="separator:ga5260dd36b46eea0864c1dbd89c544df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5b7ed8fb63a9d190521a0618214b2c2" id="r_gab5b7ed8fb63a9d190521a0618214b2c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gab5b7ed8fb63a9d190521a0618214b2c2">SDL::GPUCopyPass::UploadToTexture</a> (const <a class="el" href="group__CategoryGPU.html#ga62c3161f89c494e71fef4b8bbd471167">GPUTextureTransferInfo</a> &amp;source, const <a class="el" href="group__CategoryGPU.html#ga0a4272ec9f67111e0956cfe1f999f903">GPUTextureRegion</a> &amp;destination, bool cycle)</td></tr>
<tr class="memdesc:gab5b7ed8fb63a9d190521a0618214b2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads data from a transfer buffer to a texture.  <br /></td></tr>
<tr class="separator:gab5b7ed8fb63a9d190521a0618214b2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49c5fe1ce14d954d818e0510c7ee875c" id="r_ga49c5fe1ce14d954d818e0510c7ee875c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga49c5fe1ce14d954d818e0510c7ee875c">SDL::GPUCopyPass::UploadToBuffer</a> (const <a class="el" href="group__CategoryGPU.html#ga9faa5600aabe5cabf35cbdf09851af6d">GPUTransferBufferLocation</a> &amp;source, const <a class="el" href="group__CategoryGPU.html#gac3310186554cb88f7b1a1599171aabdf">GPUBufferRegion</a> &amp;destination, bool cycle)</td></tr>
<tr class="memdesc:ga49c5fe1ce14d954d818e0510c7ee875c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads data from a transfer buffer to a buffer.  <br /></td></tr>
<tr class="separator:ga49c5fe1ce14d954d818e0510c7ee875c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c2b51e6d7a0d50b15a4a899f672b1cf" id="r_ga6c2b51e6d7a0d50b15a4a899f672b1cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga6c2b51e6d7a0d50b15a4a899f672b1cf">SDL::GPUCopyPass::CopyTextureToTexture</a> (const <a class="el" href="group__CategoryGPU.html#ga5dac1b3fb8a5a1ba34f6d99b84e81792">GPUTextureLocation</a> &amp;source, const <a class="el" href="group__CategoryGPU.html#ga5dac1b3fb8a5a1ba34f6d99b84e81792">GPUTextureLocation</a> &amp;destination, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> w, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> h, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> d, bool cycle)</td></tr>
<tr class="memdesc:ga6c2b51e6d7a0d50b15a4a899f672b1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a texture-to-texture copy.  <br /></td></tr>
<tr class="separator:ga6c2b51e6d7a0d50b15a4a899f672b1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa95f70236a503838592fd233846d49a8" id="r_gaa95f70236a503838592fd233846d49a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa95f70236a503838592fd233846d49a8">SDL::GPUCopyPass::CopyBufferToBuffer</a> (const <a class="el" href="group__CategoryGPU.html#ga6b24b7fc30f477db4a44bc2f1637bd35">GPUBufferLocation</a> &amp;source, const <a class="el" href="group__CategoryGPU.html#ga6b24b7fc30f477db4a44bc2f1637bd35">GPUBufferLocation</a> &amp;destination, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> size, bool cycle)</td></tr>
<tr class="memdesc:gaa95f70236a503838592fd233846d49a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a buffer-to-buffer copy.  <br /></td></tr>
<tr class="separator:gaa95f70236a503838592fd233846d49a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga350647db0f6c39ab4556bc767eb9da69" id="r_ga350647db0f6c39ab4556bc767eb9da69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga350647db0f6c39ab4556bc767eb9da69">SDL::GPUCopyPass::DownloadFromTexture</a> (const <a class="el" href="group__CategoryGPU.html#ga0a4272ec9f67111e0956cfe1f999f903">GPUTextureRegion</a> &amp;source, const <a class="el" href="group__CategoryGPU.html#ga62c3161f89c494e71fef4b8bbd471167">GPUTextureTransferInfo</a> &amp;destination)</td></tr>
<tr class="memdesc:ga350647db0f6c39ab4556bc767eb9da69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a texture to a transfer buffer on the GPU timeline.  <br /></td></tr>
<tr class="separator:ga350647db0f6c39ab4556bc767eb9da69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc93df1d338fafc2aedb4216f299a34e" id="r_gacc93df1d338fafc2aedb4216f299a34e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gacc93df1d338fafc2aedb4216f299a34e">SDL::GPUCopyPass::DownloadFromBuffer</a> (const <a class="el" href="group__CategoryGPU.html#gac3310186554cb88f7b1a1599171aabdf">GPUBufferRegion</a> &amp;source, const <a class="el" href="group__CategoryGPU.html#ga9faa5600aabe5cabf35cbdf09851af6d">GPUTransferBufferLocation</a> &amp;destination)</td></tr>
<tr class="memdesc:gacc93df1d338fafc2aedb4216f299a34e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a buffer to a transfer buffer on the GPU timeline.  <br /></td></tr>
<tr class="separator:gacc93df1d338fafc2aedb4216f299a34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad28427a5325d9cc29c8082e64266b439" id="r_gad28427a5325d9cc29c8082e64266b439"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gad28427a5325d9cc29c8082e64266b439">SDL::GPUCopyPass::End</a> ()</td></tr>
<tr class="memdesc:gad28427a5325d9cc29c8082e64266b439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends the current copy pass.  <br /></td></tr>
<tr class="separator:gad28427a5325d9cc29c8082e64266b439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga997464b8389a61a692d34b935ef2cf42" id="r_ga997464b8389a61a692d34b935ef2cf42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga997464b8389a61a692d34b935ef2cf42">SDL::GPUCommandBuffer::GenerateMipmapsForTexture</a> (<a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a> texture)</td></tr>
<tr class="memdesc:ga997464b8389a61a692d34b935ef2cf42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates mipmaps for the given texture.  <br /></td></tr>
<tr class="separator:ga997464b8389a61a692d34b935ef2cf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34fde09ad7856dc08b894c41fff9fc0f" id="r_ga34fde09ad7856dc08b894c41fff9fc0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga34fde09ad7856dc08b894c41fff9fc0f">SDL::GPUCommandBuffer::BlitTexture</a> (const <a class="el" href="group__CategoryGPU.html#gaabb30629d61cc6f590279354030c3f73">GPUBlitInfo</a> &amp;info)</td></tr>
<tr class="memdesc:ga34fde09ad7856dc08b894c41fff9fc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blits from a source texture region to a destination texture region.  <br /></td></tr>
<tr class="separator:ga34fde09ad7856dc08b894c41fff9fc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80eb2cbcd952006b3f129cbd6ebe44c7" id="r_ga80eb2cbcd952006b3f129cbd6ebe44c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga80eb2cbcd952006b3f129cbd6ebe44c7">SDL::GPUDevice::WindowSupportsSwapchainComposition</a> (<a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a> window, <a class="el" href="group__CategoryGPU.html#gaa555f571dd4b1b9e5af82ee607a71fc5">GPUSwapchainComposition</a> swapchain_composition)</td></tr>
<tr class="memdesc:ga80eb2cbcd952006b3f129cbd6ebe44c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a swapchain composition is supported by the window.  <br /></td></tr>
<tr class="separator:ga80eb2cbcd952006b3f129cbd6ebe44c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb189dcc6f70c6584763e72987ad1ec5" id="r_gaeb189dcc6f70c6584763e72987ad1ec5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaeb189dcc6f70c6584763e72987ad1ec5">SDL::GPUDevice::WindowSupportsPresentMode</a> (<a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a> window, <a class="el" href="group__CategoryGPU.html#ga695f2e29e8b1cc9061a08a95ae9690e5">GPUPresentMode</a> present_mode)</td></tr>
<tr class="memdesc:gaeb189dcc6f70c6584763e72987ad1ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a presentation mode is supported by the window.  <br /></td></tr>
<tr class="separator:gaeb189dcc6f70c6584763e72987ad1ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbc4104e7cefaaccaf221b4938dacdd9" id="r_gacbc4104e7cefaaccaf221b4938dacdd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gacbc4104e7cefaaccaf221b4938dacdd9">SDL::GPUDevice::ClaimWindow</a> (<a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a> window)</td></tr>
<tr class="memdesc:gacbc4104e7cefaaccaf221b4938dacdd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Claims a window, creating a swapchain structure for it.  <br /></td></tr>
<tr class="separator:gacbc4104e7cefaaccaf221b4938dacdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85c7fbccab856044a026f2fcdd157cad" id="r_ga85c7fbccab856044a026f2fcdd157cad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga85c7fbccab856044a026f2fcdd157cad">SDL::GPUDevice::ReleaseWindow</a> (<a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a> window)</td></tr>
<tr class="memdesc:ga85c7fbccab856044a026f2fcdd157cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unclaims a window, destroying its swapchain structure.  <br /></td></tr>
<tr class="separator:ga85c7fbccab856044a026f2fcdd157cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d862f6cb8aee49dcac4907349d9a186" id="r_ga8d862f6cb8aee49dcac4907349d9a186"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga8d862f6cb8aee49dcac4907349d9a186">SDL::GPUDevice::SetSwapchainParameters</a> (<a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a> window, <a class="el" href="group__CategoryGPU.html#gaa555f571dd4b1b9e5af82ee607a71fc5">GPUSwapchainComposition</a> swapchain_composition, <a class="el" href="group__CategoryGPU.html#ga695f2e29e8b1cc9061a08a95ae9690e5">GPUPresentMode</a> present_mode)</td></tr>
<tr class="memdesc:ga8d862f6cb8aee49dcac4907349d9a186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the swapchain parameters for the given claimed window.  <br /></td></tr>
<tr class="separator:ga8d862f6cb8aee49dcac4907349d9a186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18c2598a4f6a749a04b5505520b70a0c" id="r_ga18c2598a4f6a749a04b5505520b70a0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga18c2598a4f6a749a04b5505520b70a0c">SDL::GPUDevice::SetAllowedFramesInFlight</a> (<a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> allowed_frames_in_flight)</td></tr>
<tr class="memdesc:ga18c2598a4f6a749a04b5505520b70a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the maximum allowed number of frames in flight.  <br /></td></tr>
<tr class="separator:ga18c2598a4f6a749a04b5505520b70a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60fd2d6f6ed10654c13640b212c79e95" id="r_ga60fd2d6f6ed10654c13640b212c79e95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga60fd2d6f6ed10654c13640b212c79e95">SDL::GPUDevice::GetSwapchainTextureFormat</a> (<a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a> window)</td></tr>
<tr class="memdesc:ga60fd2d6f6ed10654c13640b212c79e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the texture format of the swapchain for the given window.  <br /></td></tr>
<tr class="separator:ga60fd2d6f6ed10654c13640b212c79e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9098e2e6b7139a3af4973e47b4f7d9e" id="r_gaa9098e2e6b7139a3af4973e47b4f7d9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa9098e2e6b7139a3af4973e47b4f7d9e">SDL::GPUCommandBuffer::AcquireSwapchainTexture</a> (<a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a> window, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> *swapchain_texture_width=nullptr, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> *swapchain_texture_height=nullptr)</td></tr>
<tr class="memdesc:gaa9098e2e6b7139a3af4973e47b4f7d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire a texture to use in presentation.  <br /></td></tr>
<tr class="separator:gaa9098e2e6b7139a3af4973e47b4f7d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga787c44fa9026ae09bf8a3d9deaebcde6" id="r_ga787c44fa9026ae09bf8a3d9deaebcde6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga787c44fa9026ae09bf8a3d9deaebcde6">SDL::GPUDevice::WaitForSwapchain</a> (<a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a> window)</td></tr>
<tr class="memdesc:ga787c44fa9026ae09bf8a3d9deaebcde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the thread until a swapchain texture is available to be acquired.  <br /></td></tr>
<tr class="separator:ga787c44fa9026ae09bf8a3d9deaebcde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4234ed0ab6264374493b9b6cb07c770" id="r_gae4234ed0ab6264374493b9b6cb07c770"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gae4234ed0ab6264374493b9b6cb07c770">SDL::GPUCommandBuffer::WaitAndAcquireSwapchainTexture</a> (<a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a> window, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> *swapchain_texture_width=nullptr, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> *swapchain_texture_height=nullptr)</td></tr>
<tr class="memdesc:gae4234ed0ab6264374493b9b6cb07c770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the thread until a swapchain texture is available to be acquired, and then acquires it.  <br /></td></tr>
<tr class="separator:gae4234ed0ab6264374493b9b6cb07c770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga673e4e3d3bdfe9596fa05693cbde73b2" id="r_ga673e4e3d3bdfe9596fa05693cbde73b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga673e4e3d3bdfe9596fa05693cbde73b2">SDL::GPUCommandBuffer::Submit</a> ()</td></tr>
<tr class="memdesc:ga673e4e3d3bdfe9596fa05693cbde73b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a command buffer so its commands can be processed on the GPU.  <br /></td></tr>
<tr class="separator:ga673e4e3d3bdfe9596fa05693cbde73b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad610ad628240f1b49aaa7eaec0ccd271" id="r_gad610ad628240f1b49aaa7eaec0ccd271"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategoryGPU.html#gaeb64f32b16e58d8fcfc1baf718975d3b">GPUFence</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gad610ad628240f1b49aaa7eaec0ccd271">SDL::GPUCommandBuffer::SubmitAndAcquireFence</a> ()</td></tr>
<tr class="memdesc:gad610ad628240f1b49aaa7eaec0ccd271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a command buffer so its commands can be processed on the GPU, and acquires a fence associated with the command buffer.  <br /></td></tr>
<tr class="separator:gad610ad628240f1b49aaa7eaec0ccd271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bfdeb35856182f070ef0a146a47997a" id="r_ga3bfdeb35856182f070ef0a146a47997a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga3bfdeb35856182f070ef0a146a47997a">SDL::GPUCommandBuffer::Cancel</a> ()</td></tr>
<tr class="memdesc:ga3bfdeb35856182f070ef0a146a47997a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels a command buffer.  <br /></td></tr>
<tr class="separator:ga3bfdeb35856182f070ef0a146a47997a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad76143dc3095e35133fb14f2229faac8" id="r_gad76143dc3095e35133fb14f2229faac8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gad76143dc3095e35133fb14f2229faac8">SDL::GPUDevice::WaitForIdle</a> ()</td></tr>
<tr class="memdesc:gad76143dc3095e35133fb14f2229faac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the thread until the GPU is completely idle.  <br /></td></tr>
<tr class="separator:gad76143dc3095e35133fb14f2229faac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f8ec966ab858d2d3ae91a1b6f61f420" id="r_ga0f8ec966ab858d2d3ae91a1b6f61f420"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga0f8ec966ab858d2d3ae91a1b6f61f420">SDL::GPUDevice::WaitForFences</a> (bool wait_all, std::span&lt; <a class="el" href="group__CategoryGPU.html#gaeb64f32b16e58d8fcfc1baf718975d3b">GPUFence</a> *const &gt; fences)</td></tr>
<tr class="memdesc:ga0f8ec966ab858d2d3ae91a1b6f61f420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the thread until the given fences are signaled.  <br /></td></tr>
<tr class="separator:ga0f8ec966ab858d2d3ae91a1b6f61f420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga498070ef88a1e82416556cb7f1ef0e67" id="r_ga498070ef88a1e82416556cb7f1ef0e67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga498070ef88a1e82416556cb7f1ef0e67">SDL::GPUDevice::QueryFence</a> (<a class="el" href="group__CategoryGPU.html#gaeb64f32b16e58d8fcfc1baf718975d3b">GPUFence</a> *fence)</td></tr>
<tr class="memdesc:ga498070ef88a1e82416556cb7f1ef0e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the status of a fence.  <br /></td></tr>
<tr class="separator:ga498070ef88a1e82416556cb7f1ef0e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63f199ccc1f91e8540c423b82555e186" id="r_ga63f199ccc1f91e8540c423b82555e186"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga63f199ccc1f91e8540c423b82555e186">SDL::GPUDevice::ReleaseFence</a> (<a class="el" href="group__CategoryGPU.html#gaeb64f32b16e58d8fcfc1baf718975d3b">GPUFence</a> *fence)</td></tr>
<tr class="memdesc:ga63f199ccc1f91e8540c423b82555e186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a fence obtained from <a class="el" href="group__CategoryGPU.html#gad610ad628240f1b49aaa7eaec0ccd271" title="Submits a command buffer so its commands can be processed on the GPU, and acquires a fence associated...">GPUCommandBuffer.SubmitAndAcquireFence</a>.  <br /></td></tr>
<tr class="separator:ga63f199ccc1f91e8540c423b82555e186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24dbdaadc509ba8acd1fb2689449c133" id="r_ga24dbdaadc509ba8acd1fb2689449c133"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga24dbdaadc509ba8acd1fb2689449c133">SDL::GPUDevice::TextureSupportsFormat</a> (<a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> format, <a class="el" href="group__CategoryGPU.html#ga624b29173aac1a009aa85c14f46024a3">GPUTextureType</a> type, <a class="el" href="group__CategoryGPU.html#ga5a847c301baaf527c8ba644f0f55a59e">GPUTextureUsageFlags</a> usage)</td></tr>
<tr class="memdesc:ga24dbdaadc509ba8acd1fb2689449c133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a texture format is supported for a given type and usage.  <br /></td></tr>
<tr class="separator:ga24dbdaadc509ba8acd1fb2689449c133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac85fa5adda9fa49df12b8a85f98e67a9" id="r_gac85fa5adda9fa49df12b8a85f98e67a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gac85fa5adda9fa49df12b8a85f98e67a9">SDL::GPUDevice::TextureSupportsSampleCount</a> (<a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> format, <a class="el" href="group__CategoryGPU.html#ga5265d3385d1ddc106c614016bee759d9">GPUSampleCount</a> sample_count)</td></tr>
<tr class="memdesc:gac85fa5adda9fa49df12b8a85f98e67a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a sample count for a texture format is supported.  <br /></td></tr>
<tr class="separator:gac85fa5adda9fa49df12b8a85f98e67a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga8fb9e1c18c517a2256f814d560567653" id="r_ga8fb9e1c18c517a2256f814d560567653"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaec587594b432d13ab2ddd78ad77342a7">GPUIndexElementSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga8fb9e1c18c517a2256f814d560567653">SDL::GPU_INDEXELEMENTSIZE_16BIT</a></td></tr>
<tr class="memdesc:ga8fb9e1c18c517a2256f814d560567653"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index elements are 16-bit.  <br /></td></tr>
<tr class="separator:ga8fb9e1c18c517a2256f814d560567653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09e421993abac1302f95386e4054436a" id="r_ga09e421993abac1302f95386e4054436a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaec587594b432d13ab2ddd78ad77342a7">GPUIndexElementSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga09e421993abac1302f95386e4054436a">SDL::GPU_INDEXELEMENTSIZE_32BIT</a></td></tr>
<tr class="memdesc:ga09e421993abac1302f95386e4054436a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index elements are 32-bit.  <br /></td></tr>
<tr class="separator:ga09e421993abac1302f95386e4054436a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad730725e9fea43bfb5b23d80a56b2d53" id="r_gad730725e9fea43bfb5b23d80a56b2d53"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">GPUShaderFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gad730725e9fea43bfb5b23d80a56b2d53">SDL::GPU_SHADERFORMAT_INVALID</a></td></tr>
<tr class="memdesc:gad730725e9fea43bfb5b23d80a56b2d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">INVALID.  <br /></td></tr>
<tr class="separator:gad730725e9fea43bfb5b23d80a56b2d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga079252fe778e9ee6a0f8ce385b811c28" id="r_ga079252fe778e9ee6a0f8ce385b811c28"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">GPUShaderFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga079252fe778e9ee6a0f8ce385b811c28">SDL::GPU_SHADERFORMAT_PRIVATE</a></td></tr>
<tr class="memdesc:ga079252fe778e9ee6a0f8ce385b811c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shaders for NDA'd platforms.  <br /></td></tr>
<tr class="separator:ga079252fe778e9ee6a0f8ce385b811c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea1c0902e8b14f52fa1f65972035246c" id="r_gaea1c0902e8b14f52fa1f65972035246c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">GPUShaderFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaea1c0902e8b14f52fa1f65972035246c">SDL::GPU_SHADERFORMAT_SPIRV</a></td></tr>
<tr class="memdesc:gaea1c0902e8b14f52fa1f65972035246c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPIR-V shaders for Vulkan.  <br /></td></tr>
<tr class="separator:gaea1c0902e8b14f52fa1f65972035246c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fe7e0d94c4f8b1a44d4297c7937fdd7" id="r_ga3fe7e0d94c4f8b1a44d4297c7937fdd7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">GPUShaderFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga3fe7e0d94c4f8b1a44d4297c7937fdd7">SDL::GPU_SHADERFORMAT_DXBC</a></td></tr>
<tr class="memdesc:ga3fe7e0d94c4f8b1a44d4297c7937fdd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">DXBC SM5_1 shaders for D3D12.  <br /></td></tr>
<tr class="separator:ga3fe7e0d94c4f8b1a44d4297c7937fdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02b670fd2ce72cb88fd985d82d87e66e" id="r_ga02b670fd2ce72cb88fd985d82d87e66e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">GPUShaderFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga02b670fd2ce72cb88fd985d82d87e66e">SDL::GPU_SHADERFORMAT_DXIL</a></td></tr>
<tr class="memdesc:ga02b670fd2ce72cb88fd985d82d87e66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">DXIL SM6_0 shaders for D3D12.  <br /></td></tr>
<tr class="separator:ga02b670fd2ce72cb88fd985d82d87e66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4c8591f06b0d9da5b836401ea53b540" id="r_gab4c8591f06b0d9da5b836401ea53b540"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">GPUShaderFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gab4c8591f06b0d9da5b836401ea53b540">SDL::GPU_SHADERFORMAT_MSL</a></td></tr>
<tr class="memdesc:gab4c8591f06b0d9da5b836401ea53b540"><td class="mdescLeft">&#160;</td><td class="mdescRight">MSL shaders for Metal.  <br /></td></tr>
<tr class="separator:gab4c8591f06b0d9da5b836401ea53b540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaedea166fac00b128410ab95c997dc87" id="r_gaaedea166fac00b128410ab95c997dc87"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">GPUShaderFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaaedea166fac00b128410ab95c997dc87">SDL::GPU_SHADERFORMAT_METALLIB</a></td></tr>
<tr class="memdesc:gaaedea166fac00b128410ab95c997dc87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precompiled metallib shaders for Metal.  <br /></td></tr>
<tr class="separator:gaaedea166fac00b128410ab95c997dc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc466f8d69ab9d7a048e477cbb696a92" id="r_gadc466f8d69ab9d7a048e477cbb696a92"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaa555f571dd4b1b9e5af82ee607a71fc5">GPUSwapchainComposition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gadc466f8d69ab9d7a048e477cbb696a92">SDL::GPU_SWAPCHAINCOMPOSITION_SDR</a></td></tr>
<tr class="memdesc:gadc466f8d69ab9d7a048e477cbb696a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_SWAPCHAINCOMPOSITION_SDR.  <br /></td></tr>
<tr class="separator:gadc466f8d69ab9d7a048e477cbb696a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f87cb8e2190a5252cfc5b4216d7fba7" id="r_ga5f87cb8e2190a5252cfc5b4216d7fba7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaa555f571dd4b1b9e5af82ee607a71fc5">GPUSwapchainComposition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga5f87cb8e2190a5252cfc5b4216d7fba7">SDL::GPU_SWAPCHAINCOMPOSITION_SDR_LINEAR</a></td></tr>
<tr class="memdesc:ga5f87cb8e2190a5252cfc5b4216d7fba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_SWAPCHAINCOMPOSITION_SDR_LINEAR.  <br /></td></tr>
<tr class="separator:ga5f87cb8e2190a5252cfc5b4216d7fba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55512d0adad0984db705504871f5324e" id="r_ga55512d0adad0984db705504871f5324e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaa555f571dd4b1b9e5af82ee607a71fc5">GPUSwapchainComposition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga55512d0adad0984db705504871f5324e">SDL::GPU_SWAPCHAINCOMPOSITION_HDR_EXTENDED_LINEAR</a></td></tr>
<tr class="memdesc:ga55512d0adad0984db705504871f5324e"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_SWAPCHAINCOMPOSITION_HDR_EXTENDED_LINEAR.  <br /></td></tr>
<tr class="separator:ga55512d0adad0984db705504871f5324e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0880e5af55d47e52b757b324d6cea484" id="r_ga0880e5af55d47e52b757b324d6cea484"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaa555f571dd4b1b9e5af82ee607a71fc5">GPUSwapchainComposition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga0880e5af55d47e52b757b324d6cea484">SDL::GPU_SWAPCHAINCOMPOSITION_HDR10_ST2084</a></td></tr>
<tr class="memdesc:ga0880e5af55d47e52b757b324d6cea484"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_SWAPCHAINCOMPOSITION_HDR10_ST2084.  <br /></td></tr>
<tr class="separator:ga0880e5af55d47e52b757b324d6cea484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fa16c0a220f131ceea8f3daf5af83ca" id="r_ga6fa16c0a220f131ceea8f3daf5af83ca"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga695f2e29e8b1cc9061a08a95ae9690e5">GPUPresentMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga6fa16c0a220f131ceea8f3daf5af83ca">SDL::GPU_PRESENTMODE_VSYNC</a></td></tr>
<tr class="memdesc:ga6fa16c0a220f131ceea8f3daf5af83ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_PRESENTMODE_VSYNC.  <br /></td></tr>
<tr class="separator:ga6fa16c0a220f131ceea8f3daf5af83ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5976299de3c88b51177915fd8b52bdab" id="r_ga5976299de3c88b51177915fd8b52bdab"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga695f2e29e8b1cc9061a08a95ae9690e5">GPUPresentMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga5976299de3c88b51177915fd8b52bdab">SDL::GPU_PRESENTMODE_IMMEDIATE</a></td></tr>
<tr class="memdesc:ga5976299de3c88b51177915fd8b52bdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_PRESENTMODE_IMMEDIATE.  <br /></td></tr>
<tr class="separator:ga5976299de3c88b51177915fd8b52bdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae72c327a3a48c8447df470e06078be11" id="r_gae72c327a3a48c8447df470e06078be11"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga695f2e29e8b1cc9061a08a95ae9690e5">GPUPresentMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gae72c327a3a48c8447df470e06078be11">SDL::GPU_PRESENTMODE_MAILBOX</a></td></tr>
<tr class="memdesc:gae72c327a3a48c8447df470e06078be11"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_PRESENTMODE_MAILBOX.  <br /></td></tr>
<tr class="separator:gae72c327a3a48c8447df470e06078be11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5e80ccde34cb873795c787b1323a85e" id="r_gaf5e80ccde34cb873795c787b1323a85e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf5e80ccde34cb873795c787b1323a85e">SDL::GPU_TEXTUREFORMAT_INVALID</a></td></tr>
<tr class="memdesc:gaf5e80ccde34cb873795c787b1323a85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_INVALID.  <br /></td></tr>
<tr class="separator:gaf5e80ccde34cb873795c787b1323a85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c826e8e7d6fbd05e50e920fc991dce3" id="r_ga2c826e8e7d6fbd05e50e920fc991dce3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga2c826e8e7d6fbd05e50e920fc991dce3">SDL::GPU_TEXTUREFORMAT_A8_UNORM</a></td></tr>
<tr class="memdesc:ga2c826e8e7d6fbd05e50e920fc991dce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_A8_UNORM.  <br /></td></tr>
<tr class="separator:ga2c826e8e7d6fbd05e50e920fc991dce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c509fbf45e1574ab9755fd0d6c6c7e8" id="r_ga0c509fbf45e1574ab9755fd0d6c6c7e8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga0c509fbf45e1574ab9755fd0d6c6c7e8">SDL::GPU_TEXTUREFORMAT_R8_UNORM</a></td></tr>
<tr class="memdesc:ga0c509fbf45e1574ab9755fd0d6c6c7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R8_UNORM.  <br /></td></tr>
<tr class="separator:ga0c509fbf45e1574ab9755fd0d6c6c7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaa0306ce056fb6485aa258959dc4315" id="r_gadaa0306ce056fb6485aa258959dc4315"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gadaa0306ce056fb6485aa258959dc4315">SDL::GPU_TEXTUREFORMAT_R8G8_UNORM</a></td></tr>
<tr class="memdesc:gadaa0306ce056fb6485aa258959dc4315"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R8G8_UNORM.  <br /></td></tr>
<tr class="separator:gadaa0306ce056fb6485aa258959dc4315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6abd2cc0590e5d74c005d387d0f22fac" id="r_ga6abd2cc0590e5d74c005d387d0f22fac"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga6abd2cc0590e5d74c005d387d0f22fac">SDL::GPU_TEXTUREFORMAT_R8G8B8A8_UNORM</a></td></tr>
<tr class="memdesc:ga6abd2cc0590e5d74c005d387d0f22fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R8G8B8A8_UNORM.  <br /></td></tr>
<tr class="separator:ga6abd2cc0590e5d74c005d387d0f22fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf53abf9acbc83bb078a8fbb049d2cc1" id="r_gadf53abf9acbc83bb078a8fbb049d2cc1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gadf53abf9acbc83bb078a8fbb049d2cc1">SDL::GPU_TEXTUREFORMAT_R16_UNORM</a></td></tr>
<tr class="memdesc:gadf53abf9acbc83bb078a8fbb049d2cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R16_UNORM.  <br /></td></tr>
<tr class="separator:gadf53abf9acbc83bb078a8fbb049d2cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga324065d084a6e4cbe15e31c2c9560d14" id="r_ga324065d084a6e4cbe15e31c2c9560d14"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga324065d084a6e4cbe15e31c2c9560d14">SDL::GPU_TEXTUREFORMAT_R16G16_UNORM</a></td></tr>
<tr class="memdesc:ga324065d084a6e4cbe15e31c2c9560d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R16G16_UNORM.  <br /></td></tr>
<tr class="separator:ga324065d084a6e4cbe15e31c2c9560d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2602909d34406366d3a25a80b9bcb1d0" id="r_ga2602909d34406366d3a25a80b9bcb1d0"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga2602909d34406366d3a25a80b9bcb1d0">SDL::GPU_TEXTUREFORMAT_R16G16B16A16_UNORM</a></td></tr>
<tr class="memdesc:ga2602909d34406366d3a25a80b9bcb1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R16G16B16A16_UNORM.  <br /></td></tr>
<tr class="separator:ga2602909d34406366d3a25a80b9bcb1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe268288eecb9fb7dbd0fb058160fba0" id="r_gabe268288eecb9fb7dbd0fb058160fba0"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gabe268288eecb9fb7dbd0fb058160fba0">SDL::GPU_TEXTUREFORMAT_R10G10B10A2_UNORM</a></td></tr>
<tr class="memdesc:gabe268288eecb9fb7dbd0fb058160fba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R10G10B10A2_UNORM.  <br /></td></tr>
<tr class="separator:gabe268288eecb9fb7dbd0fb058160fba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8e9d74a24be38d6369481c5306c696c" id="r_gad8e9d74a24be38d6369481c5306c696c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gad8e9d74a24be38d6369481c5306c696c">SDL::GPU_TEXTUREFORMAT_B5G6R5_UNORM</a></td></tr>
<tr class="memdesc:gad8e9d74a24be38d6369481c5306c696c"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_B5G6R5_UNORM.  <br /></td></tr>
<tr class="separator:gad8e9d74a24be38d6369481c5306c696c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64904728cf9da2ea8db618988ed3dfc8" id="r_ga64904728cf9da2ea8db618988ed3dfc8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga64904728cf9da2ea8db618988ed3dfc8">SDL::GPU_TEXTUREFORMAT_B5G5R5A1_UNORM</a></td></tr>
<tr class="memdesc:ga64904728cf9da2ea8db618988ed3dfc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_B5G5R5A1_UNORM.  <br /></td></tr>
<tr class="separator:ga64904728cf9da2ea8db618988ed3dfc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa1c425cbf635f4c45aaf4b91c076c15" id="r_gaaa1c425cbf635f4c45aaf4b91c076c15"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaaa1c425cbf635f4c45aaf4b91c076c15">SDL::GPU_TEXTUREFORMAT_B4G4R4A4_UNORM</a></td></tr>
<tr class="memdesc:gaaa1c425cbf635f4c45aaf4b91c076c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_B4G4R4A4_UNORM.  <br /></td></tr>
<tr class="separator:gaaa1c425cbf635f4c45aaf4b91c076c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeff90a6f6dff0b715f4bba54dbe9607" id="r_gabeff90a6f6dff0b715f4bba54dbe9607"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gabeff90a6f6dff0b715f4bba54dbe9607">SDL::GPU_TEXTUREFORMAT_B8G8R8A8_UNORM</a></td></tr>
<tr class="memdesc:gabeff90a6f6dff0b715f4bba54dbe9607"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_B8G8R8A8_UNORM.  <br /></td></tr>
<tr class="separator:gabeff90a6f6dff0b715f4bba54dbe9607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga347bb71b1e09e4deca421d0618304d1e" id="r_ga347bb71b1e09e4deca421d0618304d1e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga347bb71b1e09e4deca421d0618304d1e">SDL::GPU_TEXTUREFORMAT_BC1_RGBA_UNORM</a></td></tr>
<tr class="memdesc:ga347bb71b1e09e4deca421d0618304d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_BC1_RGBA_UNORM.  <br /></td></tr>
<tr class="separator:ga347bb71b1e09e4deca421d0618304d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa98d480975453eb6ee9970356b7f550d" id="r_gaa98d480975453eb6ee9970356b7f550d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa98d480975453eb6ee9970356b7f550d">SDL::GPU_TEXTUREFORMAT_BC2_RGBA_UNORM</a></td></tr>
<tr class="memdesc:gaa98d480975453eb6ee9970356b7f550d"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_BC2_RGBA_UNORM.  <br /></td></tr>
<tr class="separator:gaa98d480975453eb6ee9970356b7f550d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36adcc27d43d110e38f8a26538a7c266" id="r_ga36adcc27d43d110e38f8a26538a7c266"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga36adcc27d43d110e38f8a26538a7c266">SDL::GPU_TEXTUREFORMAT_BC3_RGBA_UNORM</a></td></tr>
<tr class="memdesc:ga36adcc27d43d110e38f8a26538a7c266"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_BC3_RGBA_UNORM.  <br /></td></tr>
<tr class="separator:ga36adcc27d43d110e38f8a26538a7c266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a6e3a2690a8c11d145279de08029abd" id="r_ga5a6e3a2690a8c11d145279de08029abd"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga5a6e3a2690a8c11d145279de08029abd">SDL::GPU_TEXTUREFORMAT_BC4_R_UNORM</a></td></tr>
<tr class="memdesc:ga5a6e3a2690a8c11d145279de08029abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_BC4_R_UNORM.  <br /></td></tr>
<tr class="separator:ga5a6e3a2690a8c11d145279de08029abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga805b844a0614f60962b4019fa06b5164" id="r_ga805b844a0614f60962b4019fa06b5164"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga805b844a0614f60962b4019fa06b5164">SDL::GPU_TEXTUREFORMAT_BC5_RG_UNORM</a></td></tr>
<tr class="memdesc:ga805b844a0614f60962b4019fa06b5164"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_BC5_RG_UNORM.  <br /></td></tr>
<tr class="separator:ga805b844a0614f60962b4019fa06b5164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c0dbb47c91725414be7c13106967c1a" id="r_ga7c0dbb47c91725414be7c13106967c1a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga7c0dbb47c91725414be7c13106967c1a">SDL::GPU_TEXTUREFORMAT_BC7_RGBA_UNORM</a></td></tr>
<tr class="memdesc:ga7c0dbb47c91725414be7c13106967c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_BC7_RGBA_UNORM.  <br /></td></tr>
<tr class="separator:ga7c0dbb47c91725414be7c13106967c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f2b40430e6aeeb7a0f4f4d532e290cd" id="r_ga7f2b40430e6aeeb7a0f4f4d532e290cd"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga7f2b40430e6aeeb7a0f4f4d532e290cd">SDL::GPU_TEXTUREFORMAT_BC6H_RGB_FLOAT</a></td></tr>
<tr class="memdesc:ga7f2b40430e6aeeb7a0f4f4d532e290cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_BC6H_RGB_FLOAT.  <br /></td></tr>
<tr class="separator:ga7f2b40430e6aeeb7a0f4f4d532e290cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e106af5c06cf672761cefdd86618100" id="r_ga8e106af5c06cf672761cefdd86618100"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga8e106af5c06cf672761cefdd86618100">SDL::GPU_TEXTUREFORMAT_BC6H_RGB_UFLOAT</a></td></tr>
<tr class="memdesc:ga8e106af5c06cf672761cefdd86618100"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_BC6H_RGB_UFLOAT.  <br /></td></tr>
<tr class="separator:ga8e106af5c06cf672761cefdd86618100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3905156c962c16762fed265f571bc823" id="r_ga3905156c962c16762fed265f571bc823"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga3905156c962c16762fed265f571bc823">SDL::GPU_TEXTUREFORMAT_R8_SNORM</a></td></tr>
<tr class="memdesc:ga3905156c962c16762fed265f571bc823"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R8_SNORM.  <br /></td></tr>
<tr class="separator:ga3905156c962c16762fed265f571bc823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0584ed3ec134ae9412039e0f35e44c0" id="r_gac0584ed3ec134ae9412039e0f35e44c0"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gac0584ed3ec134ae9412039e0f35e44c0">SDL::GPU_TEXTUREFORMAT_R8G8_SNORM</a></td></tr>
<tr class="memdesc:gac0584ed3ec134ae9412039e0f35e44c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R8G8_SNORM.  <br /></td></tr>
<tr class="separator:gac0584ed3ec134ae9412039e0f35e44c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0aba049fc0507881b186455f445b7a6" id="r_gaa0aba049fc0507881b186455f445b7a6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa0aba049fc0507881b186455f445b7a6">SDL::GPU_TEXTUREFORMAT_R8G8B8A8_SNORM</a></td></tr>
<tr class="memdesc:gaa0aba049fc0507881b186455f445b7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R8G8B8A8_SNORM.  <br /></td></tr>
<tr class="separator:gaa0aba049fc0507881b186455f445b7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f25887c17e66ac3b72565a48848d51f" id="r_ga6f25887c17e66ac3b72565a48848d51f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga6f25887c17e66ac3b72565a48848d51f">SDL::GPU_TEXTUREFORMAT_R16_SNORM</a></td></tr>
<tr class="memdesc:ga6f25887c17e66ac3b72565a48848d51f"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R16_SNORM.  <br /></td></tr>
<tr class="separator:ga6f25887c17e66ac3b72565a48848d51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab962aba40dec59204030a49a9acfe136" id="r_gab962aba40dec59204030a49a9acfe136"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gab962aba40dec59204030a49a9acfe136">SDL::GPU_TEXTUREFORMAT_R16G16_SNORM</a></td></tr>
<tr class="memdesc:gab962aba40dec59204030a49a9acfe136"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R16G16_SNORM.  <br /></td></tr>
<tr class="separator:gab962aba40dec59204030a49a9acfe136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cbf8097921bc2511b23cf2571d66799" id="r_ga8cbf8097921bc2511b23cf2571d66799"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga8cbf8097921bc2511b23cf2571d66799">SDL::GPU_TEXTUREFORMAT_R16G16B16A16_SNORM</a></td></tr>
<tr class="memdesc:ga8cbf8097921bc2511b23cf2571d66799"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R16G16B16A16_SNORM.  <br /></td></tr>
<tr class="separator:ga8cbf8097921bc2511b23cf2571d66799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98b4d734f6250735b02d9ef6ae28fadd" id="r_ga98b4d734f6250735b02d9ef6ae28fadd"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga98b4d734f6250735b02d9ef6ae28fadd">SDL::GPU_TEXTUREFORMAT_R16_FLOAT</a></td></tr>
<tr class="memdesc:ga98b4d734f6250735b02d9ef6ae28fadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R16_FLOAT.  <br /></td></tr>
<tr class="separator:ga98b4d734f6250735b02d9ef6ae28fadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga921f5ee7efc871d3c906dc3d70def99e" id="r_ga921f5ee7efc871d3c906dc3d70def99e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga921f5ee7efc871d3c906dc3d70def99e">SDL::GPU_TEXTUREFORMAT_R16G16_FLOAT</a></td></tr>
<tr class="memdesc:ga921f5ee7efc871d3c906dc3d70def99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R16G16_FLOAT.  <br /></td></tr>
<tr class="separator:ga921f5ee7efc871d3c906dc3d70def99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c005a44820eec554408f4dbd2450aad" id="r_ga4c005a44820eec554408f4dbd2450aad"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga4c005a44820eec554408f4dbd2450aad">SDL::GPU_TEXTUREFORMAT_R16G16B16A16_FLOAT</a></td></tr>
<tr class="memdesc:ga4c005a44820eec554408f4dbd2450aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R16G16B16A16_FLOAT.  <br /></td></tr>
<tr class="separator:ga4c005a44820eec554408f4dbd2450aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f7f0ad0cee4409330252a9c21cc2477" id="r_ga2f7f0ad0cee4409330252a9c21cc2477"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga2f7f0ad0cee4409330252a9c21cc2477">SDL::GPU_TEXTUREFORMAT_R32_FLOAT</a></td></tr>
<tr class="memdesc:ga2f7f0ad0cee4409330252a9c21cc2477"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R32_FLOAT.  <br /></td></tr>
<tr class="separator:ga2f7f0ad0cee4409330252a9c21cc2477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga105359992cfd837e1a5ce75fa7e0b69b" id="r_ga105359992cfd837e1a5ce75fa7e0b69b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga105359992cfd837e1a5ce75fa7e0b69b">SDL::GPU_TEXTUREFORMAT_R32G32_FLOAT</a></td></tr>
<tr class="memdesc:ga105359992cfd837e1a5ce75fa7e0b69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R32G32_FLOAT.  <br /></td></tr>
<tr class="separator:ga105359992cfd837e1a5ce75fa7e0b69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f046d1234f7740962e6083fb499187f" id="r_ga6f046d1234f7740962e6083fb499187f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga6f046d1234f7740962e6083fb499187f">SDL::GPU_TEXTUREFORMAT_R32G32B32A32_FLOAT</a></td></tr>
<tr class="memdesc:ga6f046d1234f7740962e6083fb499187f"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R32G32B32A32_FLOAT.  <br /></td></tr>
<tr class="separator:ga6f046d1234f7740962e6083fb499187f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga424474f383d0da50084eb7a529e53fe4" id="r_ga424474f383d0da50084eb7a529e53fe4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga424474f383d0da50084eb7a529e53fe4">SDL::GPU_TEXTUREFORMAT_R11G11B10_UFLOAT</a></td></tr>
<tr class="memdesc:ga424474f383d0da50084eb7a529e53fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R11G11B10_UFLOAT.  <br /></td></tr>
<tr class="separator:ga424474f383d0da50084eb7a529e53fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86452619cae3b6545b728d1f7b733646" id="r_ga86452619cae3b6545b728d1f7b733646"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga86452619cae3b6545b728d1f7b733646">SDL::GPU_TEXTUREFORMAT_R8_UINT</a></td></tr>
<tr class="memdesc:ga86452619cae3b6545b728d1f7b733646"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R8_UINT.  <br /></td></tr>
<tr class="separator:ga86452619cae3b6545b728d1f7b733646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffd8230a95ee0c35b257068da1dc95e6" id="r_gaffd8230a95ee0c35b257068da1dc95e6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaffd8230a95ee0c35b257068da1dc95e6">SDL::GPU_TEXTUREFORMAT_R8G8_UINT</a></td></tr>
<tr class="memdesc:gaffd8230a95ee0c35b257068da1dc95e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R8G8_UINT.  <br /></td></tr>
<tr class="separator:gaffd8230a95ee0c35b257068da1dc95e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a216c880d7f493a5733d15c5005188d" id="r_ga5a216c880d7f493a5733d15c5005188d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga5a216c880d7f493a5733d15c5005188d">SDL::GPU_TEXTUREFORMAT_R8G8B8A8_UINT</a></td></tr>
<tr class="memdesc:ga5a216c880d7f493a5733d15c5005188d"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R8G8B8A8_UINT.  <br /></td></tr>
<tr class="separator:ga5a216c880d7f493a5733d15c5005188d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90f774a2f5b89430e0751852e1762d27" id="r_ga90f774a2f5b89430e0751852e1762d27"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga90f774a2f5b89430e0751852e1762d27">SDL::GPU_TEXTUREFORMAT_R16_UINT</a></td></tr>
<tr class="memdesc:ga90f774a2f5b89430e0751852e1762d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R16_UINT.  <br /></td></tr>
<tr class="separator:ga90f774a2f5b89430e0751852e1762d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2758d8bbe9189c4458b088a43edc9e6d" id="r_ga2758d8bbe9189c4458b088a43edc9e6d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga2758d8bbe9189c4458b088a43edc9e6d">SDL::GPU_TEXTUREFORMAT_R16G16_UINT</a></td></tr>
<tr class="memdesc:ga2758d8bbe9189c4458b088a43edc9e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R16G16_UINT.  <br /></td></tr>
<tr class="separator:ga2758d8bbe9189c4458b088a43edc9e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacecfb8543995c7607f86fc1ebfa269fb" id="r_gacecfb8543995c7607f86fc1ebfa269fb"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gacecfb8543995c7607f86fc1ebfa269fb">SDL::GPU_TEXTUREFORMAT_R16G16B16A16_UINT</a></td></tr>
<tr class="memdesc:gacecfb8543995c7607f86fc1ebfa269fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R16G16B16A16_UINT.  <br /></td></tr>
<tr class="separator:gacecfb8543995c7607f86fc1ebfa269fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c823213ac9f780d708475e3deeeb332" id="r_ga1c823213ac9f780d708475e3deeeb332"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga1c823213ac9f780d708475e3deeeb332">SDL::GPU_TEXTUREFORMAT_R32_UINT</a></td></tr>
<tr class="memdesc:ga1c823213ac9f780d708475e3deeeb332"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R32_UINT.  <br /></td></tr>
<tr class="separator:ga1c823213ac9f780d708475e3deeeb332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3577869bf1c43d24fe9a895c7dd279e9" id="r_ga3577869bf1c43d24fe9a895c7dd279e9"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga3577869bf1c43d24fe9a895c7dd279e9">SDL::GPU_TEXTUREFORMAT_R32G32_UINT</a></td></tr>
<tr class="memdesc:ga3577869bf1c43d24fe9a895c7dd279e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R32G32_UINT.  <br /></td></tr>
<tr class="separator:ga3577869bf1c43d24fe9a895c7dd279e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae558bb9c7b2ebc2008d37ce2185746f2" id="r_gae558bb9c7b2ebc2008d37ce2185746f2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gae558bb9c7b2ebc2008d37ce2185746f2">SDL::GPU_TEXTUREFORMAT_R32G32B32A32_UINT</a></td></tr>
<tr class="memdesc:gae558bb9c7b2ebc2008d37ce2185746f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R32G32B32A32_UINT.  <br /></td></tr>
<tr class="separator:gae558bb9c7b2ebc2008d37ce2185746f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeba122447e6bdfc7c0be5c436bea010" id="r_gadeba122447e6bdfc7c0be5c436bea010"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gadeba122447e6bdfc7c0be5c436bea010">SDL::GPU_TEXTUREFORMAT_R8_INT</a></td></tr>
<tr class="memdesc:gadeba122447e6bdfc7c0be5c436bea010"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R8_INT.  <br /></td></tr>
<tr class="separator:gadeba122447e6bdfc7c0be5c436bea010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga108af664704454564eea48bbe26200d7" id="r_ga108af664704454564eea48bbe26200d7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga108af664704454564eea48bbe26200d7">SDL::GPU_TEXTUREFORMAT_R8G8_INT</a></td></tr>
<tr class="memdesc:ga108af664704454564eea48bbe26200d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R8G8_INT.  <br /></td></tr>
<tr class="separator:ga108af664704454564eea48bbe26200d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6be9f859b55a2d219c842d7b3ba8c064" id="r_ga6be9f859b55a2d219c842d7b3ba8c064"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga6be9f859b55a2d219c842d7b3ba8c064">SDL::GPU_TEXTUREFORMAT_R8G8B8A8_INT</a></td></tr>
<tr class="memdesc:ga6be9f859b55a2d219c842d7b3ba8c064"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R8G8B8A8_INT.  <br /></td></tr>
<tr class="separator:ga6be9f859b55a2d219c842d7b3ba8c064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47f16ebd215a5a6320f47dd874cb2c6e" id="r_ga47f16ebd215a5a6320f47dd874cb2c6e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga47f16ebd215a5a6320f47dd874cb2c6e">SDL::GPU_TEXTUREFORMAT_R16_INT</a></td></tr>
<tr class="memdesc:ga47f16ebd215a5a6320f47dd874cb2c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R16_INT.  <br /></td></tr>
<tr class="separator:ga47f16ebd215a5a6320f47dd874cb2c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac19f3aa8b2278220d5131aa78109f0e0" id="r_gac19f3aa8b2278220d5131aa78109f0e0"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gac19f3aa8b2278220d5131aa78109f0e0">SDL::GPU_TEXTUREFORMAT_R16G16_INT</a></td></tr>
<tr class="memdesc:gac19f3aa8b2278220d5131aa78109f0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R16G16_INT.  <br /></td></tr>
<tr class="separator:gac19f3aa8b2278220d5131aa78109f0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11df8a95a38cb885273830a7392c319d" id="r_ga11df8a95a38cb885273830a7392c319d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga11df8a95a38cb885273830a7392c319d">SDL::GPU_TEXTUREFORMAT_R16G16B16A16_INT</a></td></tr>
<tr class="memdesc:ga11df8a95a38cb885273830a7392c319d"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R16G16B16A16_INT.  <br /></td></tr>
<tr class="separator:ga11df8a95a38cb885273830a7392c319d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga885d542d6093e1e3e037cc65b5ca33e2" id="r_ga885d542d6093e1e3e037cc65b5ca33e2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga885d542d6093e1e3e037cc65b5ca33e2">SDL::GPU_TEXTUREFORMAT_R32_INT</a></td></tr>
<tr class="memdesc:ga885d542d6093e1e3e037cc65b5ca33e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R32_INT.  <br /></td></tr>
<tr class="separator:ga885d542d6093e1e3e037cc65b5ca33e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5411c74c137ae06997202171c1bb1dd8" id="r_ga5411c74c137ae06997202171c1bb1dd8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga5411c74c137ae06997202171c1bb1dd8">SDL::GPU_TEXTUREFORMAT_R32G32_INT</a></td></tr>
<tr class="memdesc:ga5411c74c137ae06997202171c1bb1dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R32G32_INT.  <br /></td></tr>
<tr class="separator:ga5411c74c137ae06997202171c1bb1dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0f351800f44f9e9ea7b95058685b617" id="r_gac0f351800f44f9e9ea7b95058685b617"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gac0f351800f44f9e9ea7b95058685b617">SDL::GPU_TEXTUREFORMAT_R32G32B32A32_INT</a></td></tr>
<tr class="memdesc:gac0f351800f44f9e9ea7b95058685b617"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R32G32B32A32_INT.  <br /></td></tr>
<tr class="separator:gac0f351800f44f9e9ea7b95058685b617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9fa30c3d23c4225f2ce858c2105ab3e" id="r_gaa9fa30c3d23c4225f2ce858c2105ab3e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa9fa30c3d23c4225f2ce858c2105ab3e">SDL::GPU_TEXTUREFORMAT_R8G8B8A8_UNORM_SRGB</a></td></tr>
<tr class="memdesc:gaa9fa30c3d23c4225f2ce858c2105ab3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_R8G8B8A8_UNORM_SRGB.  <br /></td></tr>
<tr class="separator:gaa9fa30c3d23c4225f2ce858c2105ab3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c5cc0c167d13197f72f9c6e6b75db39" id="r_ga8c5cc0c167d13197f72f9c6e6b75db39"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga8c5cc0c167d13197f72f9c6e6b75db39">SDL::GPU_TEXTUREFORMAT_B8G8R8A8_UNORM_SRGB</a></td></tr>
<tr class="memdesc:ga8c5cc0c167d13197f72f9c6e6b75db39"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_B8G8R8A8_UNORM_SRGB.  <br /></td></tr>
<tr class="separator:ga8c5cc0c167d13197f72f9c6e6b75db39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b65a1a4ae8bf8544f9f19e88d37c2b8" id="r_ga8b65a1a4ae8bf8544f9f19e88d37c2b8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga8b65a1a4ae8bf8544f9f19e88d37c2b8">SDL::GPU_TEXTUREFORMAT_BC1_RGBA_UNORM_SRGB</a></td></tr>
<tr class="memdesc:ga8b65a1a4ae8bf8544f9f19e88d37c2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_BC1_RGBA_UNORM_SRGB.  <br /></td></tr>
<tr class="separator:ga8b65a1a4ae8bf8544f9f19e88d37c2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5aaf1dbc0260633220eb376df34f0dd" id="r_gac5aaf1dbc0260633220eb376df34f0dd"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gac5aaf1dbc0260633220eb376df34f0dd">SDL::GPU_TEXTUREFORMAT_BC2_RGBA_UNORM_SRGB</a></td></tr>
<tr class="memdesc:gac5aaf1dbc0260633220eb376df34f0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_BC2_RGBA_UNORM_SRGB.  <br /></td></tr>
<tr class="separator:gac5aaf1dbc0260633220eb376df34f0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5d75629886f9e8eacd1c768c39a66be" id="r_gaf5d75629886f9e8eacd1c768c39a66be"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf5d75629886f9e8eacd1c768c39a66be">SDL::GPU_TEXTUREFORMAT_BC3_RGBA_UNORM_SRGB</a></td></tr>
<tr class="memdesc:gaf5d75629886f9e8eacd1c768c39a66be"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_BC3_RGBA_UNORM_SRGB.  <br /></td></tr>
<tr class="separator:gaf5d75629886f9e8eacd1c768c39a66be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5c1b3ef90b63e0f6df36debdf0c4edb" id="r_gac5c1b3ef90b63e0f6df36debdf0c4edb"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gac5c1b3ef90b63e0f6df36debdf0c4edb">SDL::GPU_TEXTUREFORMAT_BC7_RGBA_UNORM_SRGB</a></td></tr>
<tr class="memdesc:gac5c1b3ef90b63e0f6df36debdf0c4edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_BC7_RGBA_UNORM_SRGB.  <br /></td></tr>
<tr class="separator:gac5c1b3ef90b63e0f6df36debdf0c4edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef7e970324e922808d2dfea76a8cf86a" id="r_gaef7e970324e922808d2dfea76a8cf86a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaef7e970324e922808d2dfea76a8cf86a">SDL::GPU_TEXTUREFORMAT_D16_UNORM</a></td></tr>
<tr class="memdesc:gaef7e970324e922808d2dfea76a8cf86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_D16_UNORM.  <br /></td></tr>
<tr class="separator:gaef7e970324e922808d2dfea76a8cf86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7742bf18626ef4d35e77f937ed0e8961" id="r_ga7742bf18626ef4d35e77f937ed0e8961"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga7742bf18626ef4d35e77f937ed0e8961">SDL::GPU_TEXTUREFORMAT_D24_UNORM</a></td></tr>
<tr class="memdesc:ga7742bf18626ef4d35e77f937ed0e8961"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_D24_UNORM.  <br /></td></tr>
<tr class="separator:ga7742bf18626ef4d35e77f937ed0e8961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1621ff55592de0a2b5105852670faf8c" id="r_ga1621ff55592de0a2b5105852670faf8c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga1621ff55592de0a2b5105852670faf8c">SDL::GPU_TEXTUREFORMAT_D32_FLOAT</a></td></tr>
<tr class="memdesc:ga1621ff55592de0a2b5105852670faf8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_D32_FLOAT.  <br /></td></tr>
<tr class="separator:ga1621ff55592de0a2b5105852670faf8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga481c4182ad4cba44edc684bbc4e956b3" id="r_ga481c4182ad4cba44edc684bbc4e956b3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga481c4182ad4cba44edc684bbc4e956b3">SDL::GPU_TEXTUREFORMAT_D24_UNORM_S8_UINT</a></td></tr>
<tr class="memdesc:ga481c4182ad4cba44edc684bbc4e956b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_D24_UNORM_S8_UINT.  <br /></td></tr>
<tr class="separator:ga481c4182ad4cba44edc684bbc4e956b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7ba67799c8b10883f9188b78e5611d5" id="r_gaa7ba67799c8b10883f9188b78e5611d5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa7ba67799c8b10883f9188b78e5611d5">SDL::GPU_TEXTUREFORMAT_D32_FLOAT_S8_UINT</a></td></tr>
<tr class="memdesc:gaa7ba67799c8b10883f9188b78e5611d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_D32_FLOAT_S8_UINT.  <br /></td></tr>
<tr class="separator:gaa7ba67799c8b10883f9188b78e5611d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab253e388a6af61a09c8a2300be973f7f" id="r_gab253e388a6af61a09c8a2300be973f7f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gab253e388a6af61a09c8a2300be973f7f">SDL::GPU_TEXTUREFORMAT_ASTC_4x4_UNORM</a></td></tr>
<tr class="memdesc:gab253e388a6af61a09c8a2300be973f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_4x4_UNORM.  <br /></td></tr>
<tr class="separator:gab253e388a6af61a09c8a2300be973f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad20492ae7a70de23dbefb5b0263b5701" id="r_gad20492ae7a70de23dbefb5b0263b5701"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gad20492ae7a70de23dbefb5b0263b5701">SDL::GPU_TEXTUREFORMAT_ASTC_5x4_UNORM</a></td></tr>
<tr class="memdesc:gad20492ae7a70de23dbefb5b0263b5701"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_5x4_UNORM.  <br /></td></tr>
<tr class="separator:gad20492ae7a70de23dbefb5b0263b5701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf67d514e72a5b308d5776018faf707bc" id="r_gaf67d514e72a5b308d5776018faf707bc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf67d514e72a5b308d5776018faf707bc">SDL::GPU_TEXTUREFORMAT_ASTC_5x5_UNORM</a></td></tr>
<tr class="memdesc:gaf67d514e72a5b308d5776018faf707bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_5x5_UNORM.  <br /></td></tr>
<tr class="separator:gaf67d514e72a5b308d5776018faf707bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e17f2610c3534b4a9671f4880105be0" id="r_ga9e17f2610c3534b4a9671f4880105be0"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga9e17f2610c3534b4a9671f4880105be0">SDL::GPU_TEXTUREFORMAT_ASTC_6x5_UNORM</a></td></tr>
<tr class="memdesc:ga9e17f2610c3534b4a9671f4880105be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_6x5_UNORM.  <br /></td></tr>
<tr class="separator:ga9e17f2610c3534b4a9671f4880105be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10962582b1dd02246369897516f4afa7" id="r_ga10962582b1dd02246369897516f4afa7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga10962582b1dd02246369897516f4afa7">SDL::GPU_TEXTUREFORMAT_ASTC_6x6_UNORM</a></td></tr>
<tr class="memdesc:ga10962582b1dd02246369897516f4afa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_6x6_UNORM.  <br /></td></tr>
<tr class="separator:ga10962582b1dd02246369897516f4afa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94f519c24769021f3d1834215221af0d" id="r_ga94f519c24769021f3d1834215221af0d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga94f519c24769021f3d1834215221af0d">SDL::GPU_TEXTUREFORMAT_ASTC_8x5_UNORM</a></td></tr>
<tr class="memdesc:ga94f519c24769021f3d1834215221af0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_8x5_UNORM.  <br /></td></tr>
<tr class="separator:ga94f519c24769021f3d1834215221af0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e0d2582afbae3e305d3587677951e91" id="r_ga1e0d2582afbae3e305d3587677951e91"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga1e0d2582afbae3e305d3587677951e91">SDL::GPU_TEXTUREFORMAT_ASTC_8x6_UNORM</a></td></tr>
<tr class="memdesc:ga1e0d2582afbae3e305d3587677951e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_8x6_UNORM.  <br /></td></tr>
<tr class="separator:ga1e0d2582afbae3e305d3587677951e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7ff1e2f3723e557af64497e494bc0c5" id="r_gac7ff1e2f3723e557af64497e494bc0c5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gac7ff1e2f3723e557af64497e494bc0c5">SDL::GPU_TEXTUREFORMAT_ASTC_8x8_UNORM</a></td></tr>
<tr class="memdesc:gac7ff1e2f3723e557af64497e494bc0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_8x8_UNORM.  <br /></td></tr>
<tr class="separator:gac7ff1e2f3723e557af64497e494bc0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffb11c42816a9d5826441b3c715dc7a6" id="r_gaffb11c42816a9d5826441b3c715dc7a6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaffb11c42816a9d5826441b3c715dc7a6">SDL::GPU_TEXTUREFORMAT_ASTC_10x5_UNORM</a></td></tr>
<tr class="memdesc:gaffb11c42816a9d5826441b3c715dc7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_10x5_UNORM.  <br /></td></tr>
<tr class="separator:gaffb11c42816a9d5826441b3c715dc7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa01ba244c414f0a6cd37feea64467562" id="r_gaa01ba244c414f0a6cd37feea64467562"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa01ba244c414f0a6cd37feea64467562">SDL::GPU_TEXTUREFORMAT_ASTC_10x6_UNORM</a></td></tr>
<tr class="memdesc:gaa01ba244c414f0a6cd37feea64467562"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_10x6_UNORM.  <br /></td></tr>
<tr class="separator:gaa01ba244c414f0a6cd37feea64467562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ad6bc8e84b323619154489c91cdd1b4" id="r_ga2ad6bc8e84b323619154489c91cdd1b4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga2ad6bc8e84b323619154489c91cdd1b4">SDL::GPU_TEXTUREFORMAT_ASTC_10x8_UNORM</a></td></tr>
<tr class="memdesc:ga2ad6bc8e84b323619154489c91cdd1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_10x8_UNORM.  <br /></td></tr>
<tr class="separator:ga2ad6bc8e84b323619154489c91cdd1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabf8f403aedae85332337e554a45922d" id="r_gaabf8f403aedae85332337e554a45922d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaabf8f403aedae85332337e554a45922d">SDL::GPU_TEXTUREFORMAT_ASTC_10x10_UNORM</a></td></tr>
<tr class="memdesc:gaabf8f403aedae85332337e554a45922d"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_10x10_UNORM.  <br /></td></tr>
<tr class="separator:gaabf8f403aedae85332337e554a45922d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacf2335d2f269bb3cdb0e7c7ce95d220" id="r_gaacf2335d2f269bb3cdb0e7c7ce95d220"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaacf2335d2f269bb3cdb0e7c7ce95d220">SDL::GPU_TEXTUREFORMAT_ASTC_12x10_UNORM</a></td></tr>
<tr class="memdesc:gaacf2335d2f269bb3cdb0e7c7ce95d220"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_12x10_UNORM.  <br /></td></tr>
<tr class="separator:gaacf2335d2f269bb3cdb0e7c7ce95d220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1201d834e059badaa4f194879b64d4f2" id="r_ga1201d834e059badaa4f194879b64d4f2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga1201d834e059badaa4f194879b64d4f2">SDL::GPU_TEXTUREFORMAT_ASTC_12x12_UNORM</a></td></tr>
<tr class="memdesc:ga1201d834e059badaa4f194879b64d4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_12x12_UNORM.  <br /></td></tr>
<tr class="separator:ga1201d834e059badaa4f194879b64d4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b2d19ba99cbebfbd17be100d11c347c" id="r_ga5b2d19ba99cbebfbd17be100d11c347c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga5b2d19ba99cbebfbd17be100d11c347c">SDL::GPU_TEXTUREFORMAT_ASTC_4x4_UNORM_SRGB</a></td></tr>
<tr class="memdesc:ga5b2d19ba99cbebfbd17be100d11c347c"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_4x4_UNORM_SRGB.  <br /></td></tr>
<tr class="separator:ga5b2d19ba99cbebfbd17be100d11c347c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac2e98149cbbb37f01c49811db3ce355" id="r_gaac2e98149cbbb37f01c49811db3ce355"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaac2e98149cbbb37f01c49811db3ce355">SDL::GPU_TEXTUREFORMAT_ASTC_5x4_UNORM_SRGB</a></td></tr>
<tr class="memdesc:gaac2e98149cbbb37f01c49811db3ce355"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_5x4_UNORM_SRGB.  <br /></td></tr>
<tr class="separator:gaac2e98149cbbb37f01c49811db3ce355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae0b402bf7995d949a3ca208c172ab44" id="r_gaae0b402bf7995d949a3ca208c172ab44"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaae0b402bf7995d949a3ca208c172ab44">SDL::GPU_TEXTUREFORMAT_ASTC_5x5_UNORM_SRGB</a></td></tr>
<tr class="memdesc:gaae0b402bf7995d949a3ca208c172ab44"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_5x5_UNORM_SRGB.  <br /></td></tr>
<tr class="separator:gaae0b402bf7995d949a3ca208c172ab44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga516a1838360523b6c8c3733b4737aff1" id="r_ga516a1838360523b6c8c3733b4737aff1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga516a1838360523b6c8c3733b4737aff1">SDL::GPU_TEXTUREFORMAT_ASTC_6x5_UNORM_SRGB</a></td></tr>
<tr class="memdesc:ga516a1838360523b6c8c3733b4737aff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_6x5_UNORM_SRGB.  <br /></td></tr>
<tr class="separator:ga516a1838360523b6c8c3733b4737aff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabde02e7dc3b0428866756813b72a90c4" id="r_gabde02e7dc3b0428866756813b72a90c4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gabde02e7dc3b0428866756813b72a90c4">SDL::GPU_TEXTUREFORMAT_ASTC_6x6_UNORM_SRGB</a></td></tr>
<tr class="memdesc:gabde02e7dc3b0428866756813b72a90c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_6x6_UNORM_SRGB.  <br /></td></tr>
<tr class="separator:gabde02e7dc3b0428866756813b72a90c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb25d16573fa2c4ba833b27ae51f3479" id="r_gabb25d16573fa2c4ba833b27ae51f3479"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gabb25d16573fa2c4ba833b27ae51f3479">SDL::GPU_TEXTUREFORMAT_ASTC_8x5_UNORM_SRGB</a></td></tr>
<tr class="memdesc:gabb25d16573fa2c4ba833b27ae51f3479"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_8x5_UNORM_SRGB.  <br /></td></tr>
<tr class="separator:gabb25d16573fa2c4ba833b27ae51f3479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga336acf7f8cf9686f95e06a9014e735b7" id="r_ga336acf7f8cf9686f95e06a9014e735b7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga336acf7f8cf9686f95e06a9014e735b7">SDL::GPU_TEXTUREFORMAT_ASTC_8x6_UNORM_SRGB</a></td></tr>
<tr class="memdesc:ga336acf7f8cf9686f95e06a9014e735b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_8x6_UNORM_SRGB.  <br /></td></tr>
<tr class="separator:ga336acf7f8cf9686f95e06a9014e735b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8caa3bb414363a7fb3496b68b919333b" id="r_ga8caa3bb414363a7fb3496b68b919333b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga8caa3bb414363a7fb3496b68b919333b">SDL::GPU_TEXTUREFORMAT_ASTC_8x8_UNORM_SRGB</a></td></tr>
<tr class="memdesc:ga8caa3bb414363a7fb3496b68b919333b"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_8x8_UNORM_SRGB.  <br /></td></tr>
<tr class="separator:ga8caa3bb414363a7fb3496b68b919333b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdd9d56c5681cf7aa0cec7829553911b" id="r_gacdd9d56c5681cf7aa0cec7829553911b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gacdd9d56c5681cf7aa0cec7829553911b">SDL::GPU_TEXTUREFORMAT_ASTC_10x5_UNORM_SRGB</a></td></tr>
<tr class="memdesc:gacdd9d56c5681cf7aa0cec7829553911b"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_10x5_UNORM_SRGB.  <br /></td></tr>
<tr class="separator:gacdd9d56c5681cf7aa0cec7829553911b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf231fa83dd9609993e2b8c9a79ab1ae2" id="r_gaf231fa83dd9609993e2b8c9a79ab1ae2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf231fa83dd9609993e2b8c9a79ab1ae2">SDL::GPU_TEXTUREFORMAT_ASTC_10x6_UNORM_SRGB</a></td></tr>
<tr class="memdesc:gaf231fa83dd9609993e2b8c9a79ab1ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_10x6_UNORM_SRGB.  <br /></td></tr>
<tr class="separator:gaf231fa83dd9609993e2b8c9a79ab1ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b0748ca05c288819d435cfe1ac19ac5" id="r_ga3b0748ca05c288819d435cfe1ac19ac5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga3b0748ca05c288819d435cfe1ac19ac5">SDL::GPU_TEXTUREFORMAT_ASTC_10x8_UNORM_SRGB</a></td></tr>
<tr class="memdesc:ga3b0748ca05c288819d435cfe1ac19ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_10x8_UNORM_SRGB.  <br /></td></tr>
<tr class="separator:ga3b0748ca05c288819d435cfe1ac19ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf8dad3124443ee567b2c12f9528378b" id="r_gadf8dad3124443ee567b2c12f9528378b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gadf8dad3124443ee567b2c12f9528378b">SDL::GPU_TEXTUREFORMAT_ASTC_10x10_UNORM_SRGB</a></td></tr>
<tr class="memdesc:gadf8dad3124443ee567b2c12f9528378b"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_10x10_UNORM_SRGB.  <br /></td></tr>
<tr class="separator:gadf8dad3124443ee567b2c12f9528378b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa9b8b03d1a7548dc8c380aad0d9feae" id="r_gaaa9b8b03d1a7548dc8c380aad0d9feae"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaaa9b8b03d1a7548dc8c380aad0d9feae">SDL::GPU_TEXTUREFORMAT_ASTC_12x10_UNORM_SRGB</a></td></tr>
<tr class="memdesc:gaaa9b8b03d1a7548dc8c380aad0d9feae"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_12x10_UNORM_SRGB.  <br /></td></tr>
<tr class="separator:gaaa9b8b03d1a7548dc8c380aad0d9feae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga054df995978f69ec0588b2441baf7368" id="r_ga054df995978f69ec0588b2441baf7368"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga054df995978f69ec0588b2441baf7368">SDL::GPU_TEXTUREFORMAT_ASTC_12x12_UNORM_SRGB</a></td></tr>
<tr class="memdesc:ga054df995978f69ec0588b2441baf7368"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_12x12_UNORM_SRGB.  <br /></td></tr>
<tr class="separator:ga054df995978f69ec0588b2441baf7368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga135a086b6de0f928d3c3a46f34d030ff" id="r_ga135a086b6de0f928d3c3a46f34d030ff"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga135a086b6de0f928d3c3a46f34d030ff">SDL::GPU_TEXTUREFORMAT_ASTC_4x4_FLOAT</a></td></tr>
<tr class="memdesc:ga135a086b6de0f928d3c3a46f34d030ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_4x4_FLOAT.  <br /></td></tr>
<tr class="separator:ga135a086b6de0f928d3c3a46f34d030ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a7553ebb4b0650a4b13f1d2a50857a9" id="r_ga8a7553ebb4b0650a4b13f1d2a50857a9"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga8a7553ebb4b0650a4b13f1d2a50857a9">SDL::GPU_TEXTUREFORMAT_ASTC_5x4_FLOAT</a></td></tr>
<tr class="memdesc:ga8a7553ebb4b0650a4b13f1d2a50857a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_5x4_FLOAT.  <br /></td></tr>
<tr class="separator:ga8a7553ebb4b0650a4b13f1d2a50857a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f306dda0fdb8d5a0231de586ff597e8" id="r_ga2f306dda0fdb8d5a0231de586ff597e8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga2f306dda0fdb8d5a0231de586ff597e8">SDL::GPU_TEXTUREFORMAT_ASTC_5x5_FLOAT</a></td></tr>
<tr class="memdesc:ga2f306dda0fdb8d5a0231de586ff597e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_5x5_FLOAT.  <br /></td></tr>
<tr class="separator:ga2f306dda0fdb8d5a0231de586ff597e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33e396547d512d496dbb926e71578134" id="r_ga33e396547d512d496dbb926e71578134"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga33e396547d512d496dbb926e71578134">SDL::GPU_TEXTUREFORMAT_ASTC_6x5_FLOAT</a></td></tr>
<tr class="memdesc:ga33e396547d512d496dbb926e71578134"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_6x5_FLOAT.  <br /></td></tr>
<tr class="separator:ga33e396547d512d496dbb926e71578134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ad69f51ba7d853a769e9495fd438220" id="r_ga0ad69f51ba7d853a769e9495fd438220"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga0ad69f51ba7d853a769e9495fd438220">SDL::GPU_TEXTUREFORMAT_ASTC_6x6_FLOAT</a></td></tr>
<tr class="memdesc:ga0ad69f51ba7d853a769e9495fd438220"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_6x6_FLOAT.  <br /></td></tr>
<tr class="separator:ga0ad69f51ba7d853a769e9495fd438220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef035a8d1a509fa612661fa3acd17e41" id="r_gaef035a8d1a509fa612661fa3acd17e41"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaef035a8d1a509fa612661fa3acd17e41">SDL::GPU_TEXTUREFORMAT_ASTC_8x5_FLOAT</a></td></tr>
<tr class="memdesc:gaef035a8d1a509fa612661fa3acd17e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_8x5_FLOAT.  <br /></td></tr>
<tr class="separator:gaef035a8d1a509fa612661fa3acd17e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aaec5379de7864831fa784184d8137e" id="r_ga1aaec5379de7864831fa784184d8137e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga1aaec5379de7864831fa784184d8137e">SDL::GPU_TEXTUREFORMAT_ASTC_8x6_FLOAT</a></td></tr>
<tr class="memdesc:ga1aaec5379de7864831fa784184d8137e"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_8x6_FLOAT.  <br /></td></tr>
<tr class="separator:ga1aaec5379de7864831fa784184d8137e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacff96875795281fcd9b45661e29f8e7f" id="r_gacff96875795281fcd9b45661e29f8e7f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gacff96875795281fcd9b45661e29f8e7f">SDL::GPU_TEXTUREFORMAT_ASTC_8x8_FLOAT</a></td></tr>
<tr class="memdesc:gacff96875795281fcd9b45661e29f8e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_8x8_FLOAT.  <br /></td></tr>
<tr class="separator:gacff96875795281fcd9b45661e29f8e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c91910e9d0d78ec0a6d9a48329d3751" id="r_ga9c91910e9d0d78ec0a6d9a48329d3751"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga9c91910e9d0d78ec0a6d9a48329d3751">SDL::GPU_TEXTUREFORMAT_ASTC_10x5_FLOAT</a></td></tr>
<tr class="memdesc:ga9c91910e9d0d78ec0a6d9a48329d3751"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_10x5_FLOAT.  <br /></td></tr>
<tr class="separator:ga9c91910e9d0d78ec0a6d9a48329d3751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fed779dc2b0f9a7baf69ee60a681fed" id="r_ga3fed779dc2b0f9a7baf69ee60a681fed"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga3fed779dc2b0f9a7baf69ee60a681fed">SDL::GPU_TEXTUREFORMAT_ASTC_10x6_FLOAT</a></td></tr>
<tr class="memdesc:ga3fed779dc2b0f9a7baf69ee60a681fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_10x6_FLOAT.  <br /></td></tr>
<tr class="separator:ga3fed779dc2b0f9a7baf69ee60a681fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga531e94ad956b603d660f8ac3be92e2ad" id="r_ga531e94ad956b603d660f8ac3be92e2ad"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga531e94ad956b603d660f8ac3be92e2ad">SDL::GPU_TEXTUREFORMAT_ASTC_10x8_FLOAT</a></td></tr>
<tr class="memdesc:ga531e94ad956b603d660f8ac3be92e2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_10x8_FLOAT.  <br /></td></tr>
<tr class="separator:ga531e94ad956b603d660f8ac3be92e2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4de9171166fff58e7bd1546e1d84cb40" id="r_ga4de9171166fff58e7bd1546e1d84cb40"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga4de9171166fff58e7bd1546e1d84cb40">SDL::GPU_TEXTUREFORMAT_ASTC_10x10_FLOAT</a></td></tr>
<tr class="memdesc:ga4de9171166fff58e7bd1546e1d84cb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_10x10_FLOAT.  <br /></td></tr>
<tr class="separator:ga4de9171166fff58e7bd1546e1d84cb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c4dbedd3ad678bd63f56200436631d6" id="r_ga8c4dbedd3ad678bd63f56200436631d6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga8c4dbedd3ad678bd63f56200436631d6">SDL::GPU_TEXTUREFORMAT_ASTC_12x10_FLOAT</a></td></tr>
<tr class="memdesc:ga8c4dbedd3ad678bd63f56200436631d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_12x10_FLOAT.  <br /></td></tr>
<tr class="separator:ga8c4dbedd3ad678bd63f56200436631d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9933b29c18c095dc0a28339a464606c7" id="r_ga9933b29c18c095dc0a28339a464606c7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga9933b29c18c095dc0a28339a464606c7">SDL::GPU_TEXTUREFORMAT_ASTC_12x12_FLOAT</a></td></tr>
<tr class="memdesc:ga9933b29c18c095dc0a28339a464606c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TEXTUREFORMAT_ASTC_12x12_FLOAT.  <br /></td></tr>
<tr class="separator:ga9933b29c18c095dc0a28339a464606c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa83a4667024d1ef57f20614a39e7e80d" id="r_gaa83a4667024d1ef57f20614a39e7e80d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga624b29173aac1a009aa85c14f46024a3">GPUTextureType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa83a4667024d1ef57f20614a39e7e80d">SDL::GPU_TEXTURETYPE_2D</a></td></tr>
<tr class="memdesc:gaa83a4667024d1ef57f20614a39e7e80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The texture is a 2-dimensional image.  <br /></td></tr>
<tr class="separator:gaa83a4667024d1ef57f20614a39e7e80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae61e70b3c73250ee60abe4878fa72b75" id="r_gae61e70b3c73250ee60abe4878fa72b75"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga624b29173aac1a009aa85c14f46024a3">GPUTextureType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gae61e70b3c73250ee60abe4878fa72b75">SDL::GPU_TEXTURETYPE_2D_ARRAY</a></td></tr>
<tr class="memdesc:gae61e70b3c73250ee60abe4878fa72b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">The texture is a 2-dimensional array image.  <br /></td></tr>
<tr class="separator:gae61e70b3c73250ee60abe4878fa72b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d7f76222c6a79ae47b1d076b8f90d47" id="r_ga8d7f76222c6a79ae47b1d076b8f90d47"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga624b29173aac1a009aa85c14f46024a3">GPUTextureType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga8d7f76222c6a79ae47b1d076b8f90d47">SDL::GPU_TEXTURETYPE_3D</a></td></tr>
<tr class="memdesc:ga8d7f76222c6a79ae47b1d076b8f90d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">The texture is a 3-dimensional image.  <br /></td></tr>
<tr class="separator:ga8d7f76222c6a79ae47b1d076b8f90d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf56bdd99ec28ff221df851b2bf3ad624" id="r_gaf56bdd99ec28ff221df851b2bf3ad624"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga624b29173aac1a009aa85c14f46024a3">GPUTextureType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf56bdd99ec28ff221df851b2bf3ad624">SDL::GPU_TEXTURETYPE_CUBE</a></td></tr>
<tr class="memdesc:gaf56bdd99ec28ff221df851b2bf3ad624"><td class="mdescLeft">&#160;</td><td class="mdescRight">The texture is a cube image.  <br /></td></tr>
<tr class="separator:gaf56bdd99ec28ff221df851b2bf3ad624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87d9f7e1518b5a3a1b29936a13143776" id="r_ga87d9f7e1518b5a3a1b29936a13143776"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga624b29173aac1a009aa85c14f46024a3">GPUTextureType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga87d9f7e1518b5a3a1b29936a13143776">SDL::GPU_TEXTURETYPE_CUBE_ARRAY</a></td></tr>
<tr class="memdesc:ga87d9f7e1518b5a3a1b29936a13143776"><td class="mdescLeft">&#160;</td><td class="mdescRight">The texture is a cube array image.  <br /></td></tr>
<tr class="separator:ga87d9f7e1518b5a3a1b29936a13143776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ab5f1ebf543b13831d6b2fd5e34ab58" id="r_ga3ab5f1ebf543b13831d6b2fd5e34ab58"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga5a847c301baaf527c8ba644f0f55a59e">GPUTextureUsageFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga3ab5f1ebf543b13831d6b2fd5e34ab58">SDL::GPU_TEXTUREUSAGE_SAMPLER</a></td></tr>
<tr class="memdesc:ga3ab5f1ebf543b13831d6b2fd5e34ab58"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSDL_1_1Texture.html" title="An efficient driver-specific representation of pixel data.">Texture</a> supports sampling.  <br /></td></tr>
<tr class="separator:ga3ab5f1ebf543b13831d6b2fd5e34ab58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43673fe44405ff6c3b93701ccb014b08" id="r_ga43673fe44405ff6c3b93701ccb014b08"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga5a847c301baaf527c8ba644f0f55a59e">GPUTextureUsageFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga43673fe44405ff6c3b93701ccb014b08">SDL::GPU_TEXTUREUSAGE_COLOR_TARGET</a></td></tr>
<tr class="memdesc:ga43673fe44405ff6c3b93701ccb014b08"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSDL_1_1Texture.html" title="An efficient driver-specific representation of pixel data.">Texture</a> is a color render target.  <br /></td></tr>
<tr class="separator:ga43673fe44405ff6c3b93701ccb014b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga791d3bf7f12eed705aa3265fa5a4d9d5" id="r_ga791d3bf7f12eed705aa3265fa5a4d9d5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga5a847c301baaf527c8ba644f0f55a59e">GPUTextureUsageFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga791d3bf7f12eed705aa3265fa5a4d9d5">SDL::GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET</a></td></tr>
<tr class="memdesc:ga791d3bf7f12eed705aa3265fa5a4d9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSDL_1_1Texture.html" title="An efficient driver-specific representation of pixel data.">Texture</a> is a depth stencil target.  <br /></td></tr>
<tr class="separator:ga791d3bf7f12eed705aa3265fa5a4d9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga383bb5e680c67e7b0169ea46683e3b4d" id="r_ga383bb5e680c67e7b0169ea46683e3b4d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga5a847c301baaf527c8ba644f0f55a59e">GPUTextureUsageFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga383bb5e680c67e7b0169ea46683e3b4d">SDL::GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ</a></td></tr>
<tr class="memdesc:ga383bb5e680c67e7b0169ea46683e3b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSDL_1_1Texture.html" title="An efficient driver-specific representation of pixel data.">Texture</a> supports storage reads in graphics stages.  <br /></td></tr>
<tr class="separator:ga383bb5e680c67e7b0169ea46683e3b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadde64b9b6bd2b5e4a3bba572d8a79b6c" id="r_gadde64b9b6bd2b5e4a3bba572d8a79b6c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga5a847c301baaf527c8ba644f0f55a59e">GPUTextureUsageFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gadde64b9b6bd2b5e4a3bba572d8a79b6c">SDL::GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ</a></td></tr>
<tr class="memdesc:gadde64b9b6bd2b5e4a3bba572d8a79b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSDL_1_1Texture.html" title="An efficient driver-specific representation of pixel data.">Texture</a> supports storage reads in the compute stage.  <br /></td></tr>
<tr class="separator:gadde64b9b6bd2b5e4a3bba572d8a79b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92cd7e2ea4b7e284763017a916aee77f" id="r_ga92cd7e2ea4b7e284763017a916aee77f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga5a847c301baaf527c8ba644f0f55a59e">GPUTextureUsageFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga92cd7e2ea4b7e284763017a916aee77f">SDL::GPU_TEXTUREUSAGE_COMPUTE_STORAGE_WRITE</a></td></tr>
<tr class="memdesc:ga92cd7e2ea4b7e284763017a916aee77f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSDL_1_1Texture.html" title="An efficient driver-specific representation of pixel data.">Texture</a> supports storage writes in the compute stage.  <br /></td></tr>
<tr class="separator:ga92cd7e2ea4b7e284763017a916aee77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga105f825311d81d845d1c08f4022c699b" id="r_ga105f825311d81d845d1c08f4022c699b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga5a847c301baaf527c8ba644f0f55a59e">GPUTextureUsageFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga105f825311d81d845d1c08f4022c699b">SDL::GPU_TEXTUREUSAGE_COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE</a></td></tr>
<tr class="memdesc:ga105f825311d81d845d1c08f4022c699b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSDL_1_1Texture.html" title="An efficient driver-specific representation of pixel data.">Texture</a> supports reads and writes in the same compute shader.  <br /></td></tr>
<tr class="separator:ga105f825311d81d845d1c08f4022c699b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf912b12833fe79778324bc2979e5f8ed" id="r_gaf912b12833fe79778324bc2979e5f8ed"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga5265d3385d1ddc106c614016bee759d9">GPUSampleCount</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf912b12833fe79778324bc2979e5f8ed">SDL::GPU_SAMPLECOUNT_1</a></td></tr>
<tr class="memdesc:gaf912b12833fe79778324bc2979e5f8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">No multisampling.  <br /></td></tr>
<tr class="separator:gaf912b12833fe79778324bc2979e5f8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92c893b198c69ecada31bf0fe9b85f8e" id="r_ga92c893b198c69ecada31bf0fe9b85f8e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga5265d3385d1ddc106c614016bee759d9">GPUSampleCount</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga92c893b198c69ecada31bf0fe9b85f8e">SDL::GPU_SAMPLECOUNT_2</a></td></tr>
<tr class="memdesc:ga92c893b198c69ecada31bf0fe9b85f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">MSAA 2x.  <br /></td></tr>
<tr class="separator:ga92c893b198c69ecada31bf0fe9b85f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86b44bd29df86e5bfed30718b3875c7d" id="r_ga86b44bd29df86e5bfed30718b3875c7d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga5265d3385d1ddc106c614016bee759d9">GPUSampleCount</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga86b44bd29df86e5bfed30718b3875c7d">SDL::GPU_SAMPLECOUNT_4</a></td></tr>
<tr class="memdesc:ga86b44bd29df86e5bfed30718b3875c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">MSAA 4x.  <br /></td></tr>
<tr class="separator:ga86b44bd29df86e5bfed30718b3875c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d40543e044bf9b5d977388c1c554773" id="r_ga8d40543e044bf9b5d977388c1c554773"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga5265d3385d1ddc106c614016bee759d9">GPUSampleCount</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga8d40543e044bf9b5d977388c1c554773">SDL::GPU_SAMPLECOUNT_8</a></td></tr>
<tr class="memdesc:ga8d40543e044bf9b5d977388c1c554773"><td class="mdescLeft">&#160;</td><td class="mdescRight">MSAA 8x.  <br /></td></tr>
<tr class="separator:ga8d40543e044bf9b5d977388c1c554773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bd6d2d0b1bec78509ec227efe7e580d" id="r_ga2bd6d2d0b1bec78509ec227efe7e580d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaa55e8850ba84241f691eec7b68c58bb3">GPUPrimitiveType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga2bd6d2d0b1bec78509ec227efe7e580d">SDL::GPU_PRIMITIVETYPE_TRIANGLELIST</a></td></tr>
<tr class="memdesc:ga2bd6d2d0b1bec78509ec227efe7e580d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A series of separate triangles.  <br /></td></tr>
<tr class="separator:ga2bd6d2d0b1bec78509ec227efe7e580d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2a557d732dc19f651f693fd1adb3151" id="r_gab2a557d732dc19f651f693fd1adb3151"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaa55e8850ba84241f691eec7b68c58bb3">GPUPrimitiveType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gab2a557d732dc19f651f693fd1adb3151">SDL::GPU_PRIMITIVETYPE_TRIANGLESTRIP</a></td></tr>
<tr class="memdesc:gab2a557d732dc19f651f693fd1adb3151"><td class="mdescLeft">&#160;</td><td class="mdescRight">A series of connected triangles.  <br /></td></tr>
<tr class="separator:gab2a557d732dc19f651f693fd1adb3151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c26f2d8e9a5b78ffcd64b68bda2cbc9" id="r_ga1c26f2d8e9a5b78ffcd64b68bda2cbc9"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaa55e8850ba84241f691eec7b68c58bb3">GPUPrimitiveType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga1c26f2d8e9a5b78ffcd64b68bda2cbc9">SDL::GPU_PRIMITIVETYPE_LINELIST</a></td></tr>
<tr class="memdesc:ga1c26f2d8e9a5b78ffcd64b68bda2cbc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A series of separate lines.  <br /></td></tr>
<tr class="separator:ga1c26f2d8e9a5b78ffcd64b68bda2cbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84170253c13eedaece60c951532143f0" id="r_ga84170253c13eedaece60c951532143f0"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaa55e8850ba84241f691eec7b68c58bb3">GPUPrimitiveType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga84170253c13eedaece60c951532143f0">SDL::GPU_PRIMITIVETYPE_LINESTRIP</a></td></tr>
<tr class="memdesc:ga84170253c13eedaece60c951532143f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A series of connected lines.  <br /></td></tr>
<tr class="separator:ga84170253c13eedaece60c951532143f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b21a18c8157e657dd9aff8d40c8bfe4" id="r_ga7b21a18c8157e657dd9aff8d40c8bfe4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaa55e8850ba84241f691eec7b68c58bb3">GPUPrimitiveType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga7b21a18c8157e657dd9aff8d40c8bfe4">SDL::GPU_PRIMITIVETYPE_POINTLIST</a></td></tr>
<tr class="memdesc:ga7b21a18c8157e657dd9aff8d40c8bfe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A series of separate points.  <br /></td></tr>
<tr class="separator:ga7b21a18c8157e657dd9aff8d40c8bfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafccd48d86b6ec59a6faf8df9a4545943" id="r_gafccd48d86b6ec59a6faf8df9a4545943"><td class="memItemLeft" align="right" valign="top"><a id="gafccd48d86b6ec59a6faf8df9a4545943" name="gafccd48d86b6ec59a6faf8df9a4545943"></a>
constexpr <a class="el" href="group__CategoryGPU.html#gaf5682b03e950adda302469fb07485f2a">GPULoadOp</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::GPU_LOADOP_LOAD</b> = SDL_GPU_LOADOP_LOAD</td></tr>
<tr class="memdesc:gafccd48d86b6ec59a6faf8df9a4545943"><td class="mdescLeft">&#160;</td><td class="mdescRight">The previous contents of the texture will be preserved. <br /></td></tr>
<tr class="separator:gafccd48d86b6ec59a6faf8df9a4545943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3944365a8246de929437ba131375c7b" id="r_gae3944365a8246de929437ba131375c7b"><td class="memItemLeft" align="right" valign="top"><a id="gae3944365a8246de929437ba131375c7b" name="gae3944365a8246de929437ba131375c7b"></a>
constexpr <a class="el" href="group__CategoryGPU.html#gaf5682b03e950adda302469fb07485f2a">GPULoadOp</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::GPU_LOADOP_CLEAR</b> = SDL_GPU_LOADOP_CLEAR</td></tr>
<tr class="memdesc:gae3944365a8246de929437ba131375c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents of the texture will be cleared to a color. <br /></td></tr>
<tr class="separator:gae3944365a8246de929437ba131375c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf3ca9f7ea2091820fd7146d8dbedf02" id="r_gabf3ca9f7ea2091820fd7146d8dbedf02"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaf5682b03e950adda302469fb07485f2a">GPULoadOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gabf3ca9f7ea2091820fd7146d8dbedf02">SDL::GPU_LOADOP_DONT_CARE</a> = SDL_GPU_LOADOP_DONT_CARE</td></tr>
<tr class="memdesc:gabf3ca9f7ea2091820fd7146d8dbedf02"><td class="mdescLeft">&#160;</td><td class="mdescRight">The previous contents of the texture need not be preserved.  <br /></td></tr>
<tr class="separator:gabf3ca9f7ea2091820fd7146d8dbedf02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4e7113e20f964d1145f9294e171892d" id="r_gac4e7113e20f964d1145f9294e171892d"><td class="memItemLeft" align="right" valign="top"><a id="gac4e7113e20f964d1145f9294e171892d" name="gac4e7113e20f964d1145f9294e171892d"></a>
constexpr <a class="el" href="group__CategoryGPU.html#gaace1f8aa9176f849a325dee8d65046f4">GPUStoreOp</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::GPU_STOREOP_STORE</b> = SDL_GPU_STOREOP_STORE</td></tr>
<tr class="memdesc:gac4e7113e20f964d1145f9294e171892d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents generated during the render pass will be written to memory. <br /></td></tr>
<tr class="separator:gac4e7113e20f964d1145f9294e171892d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae34e33b560a98fe8662339871de6180f" id="r_gae34e33b560a98fe8662339871de6180f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaace1f8aa9176f849a325dee8d65046f4">GPUStoreOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gae34e33b560a98fe8662339871de6180f">SDL::GPU_STOREOP_DONT_CARE</a> = SDL_GPU_STOREOP_DONT_CARE</td></tr>
<tr class="memdesc:gae34e33b560a98fe8662339871de6180f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contents generated during the render pass are not needed and may be discarded.  <br /></td></tr>
<tr class="separator:gae34e33b560a98fe8662339871de6180f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f8d337ba5b30144f4398acadc27e558" id="r_ga2f8d337ba5b30144f4398acadc27e558"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaace1f8aa9176f849a325dee8d65046f4">GPUStoreOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga2f8d337ba5b30144f4398acadc27e558">SDL::GPU_STOREOP_RESOLVE</a> = SDL_GPU_STOREOP_RESOLVE</td></tr>
<tr class="memdesc:ga2f8d337ba5b30144f4398acadc27e558"><td class="mdescLeft">&#160;</td><td class="mdescRight">The multisample contents generated during the render pass will be resolved to a non-multisample texture.  <br /></td></tr>
<tr class="separator:ga2f8d337ba5b30144f4398acadc27e558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f0c71a6fbb618a73c80b5cb041a270e" id="r_ga6f0c71a6fbb618a73c80b5cb041a270e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaace1f8aa9176f849a325dee8d65046f4">GPUStoreOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga6f0c71a6fbb618a73c80b5cb041a270e">SDL::GPU_STOREOP_RESOLVE_AND_STORE</a></td></tr>
<tr class="memdesc:ga6f0c71a6fbb618a73c80b5cb041a270e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The multisample contents generated during the render pass will be resolved to a non-multisample texture.  <br /></td></tr>
<tr class="separator:ga6f0c71a6fbb618a73c80b5cb041a270e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2dbd057c6e46ed890d985b8bbb7baa9" id="r_gaf2dbd057c6e46ed890d985b8bbb7baa9"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga9818c5cd42d048d0b4597bedd340ea7a">GPUCubeMapFace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf2dbd057c6e46ed890d985b8bbb7baa9">SDL::GPU_CUBEMAPFACE_POSITIVEX</a></td></tr>
<tr class="memdesc:gaf2dbd057c6e46ed890d985b8bbb7baa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_CUBEMAPFACE_POSITIVEX.  <br /></td></tr>
<tr class="separator:gaf2dbd057c6e46ed890d985b8bbb7baa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73a88a09a55c8427ba745c6e14571766" id="r_ga73a88a09a55c8427ba745c6e14571766"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga9818c5cd42d048d0b4597bedd340ea7a">GPUCubeMapFace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga73a88a09a55c8427ba745c6e14571766">SDL::GPU_CUBEMAPFACE_NEGATIVEX</a></td></tr>
<tr class="memdesc:ga73a88a09a55c8427ba745c6e14571766"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_CUBEMAPFACE_NEGATIVEX.  <br /></td></tr>
<tr class="separator:ga73a88a09a55c8427ba745c6e14571766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga967b28b157fed64b317d0b1d28daad50" id="r_ga967b28b157fed64b317d0b1d28daad50"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga9818c5cd42d048d0b4597bedd340ea7a">GPUCubeMapFace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga967b28b157fed64b317d0b1d28daad50">SDL::GPU_CUBEMAPFACE_POSITIVEY</a></td></tr>
<tr class="memdesc:ga967b28b157fed64b317d0b1d28daad50"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_CUBEMAPFACE_POSITIVEY.  <br /></td></tr>
<tr class="separator:ga967b28b157fed64b317d0b1d28daad50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7d878ac053060caf1a3b568fbb28760" id="r_gae7d878ac053060caf1a3b568fbb28760"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga9818c5cd42d048d0b4597bedd340ea7a">GPUCubeMapFace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gae7d878ac053060caf1a3b568fbb28760">SDL::GPU_CUBEMAPFACE_NEGATIVEY</a></td></tr>
<tr class="memdesc:gae7d878ac053060caf1a3b568fbb28760"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_CUBEMAPFACE_NEGATIVEY.  <br /></td></tr>
<tr class="separator:gae7d878ac053060caf1a3b568fbb28760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b2563f031b147ce78c3e8bfc2324c96" id="r_ga5b2563f031b147ce78c3e8bfc2324c96"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga9818c5cd42d048d0b4597bedd340ea7a">GPUCubeMapFace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga5b2563f031b147ce78c3e8bfc2324c96">SDL::GPU_CUBEMAPFACE_POSITIVEZ</a></td></tr>
<tr class="memdesc:ga5b2563f031b147ce78c3e8bfc2324c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_CUBEMAPFACE_POSITIVEZ.  <br /></td></tr>
<tr class="separator:ga5b2563f031b147ce78c3e8bfc2324c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83774d36da4155e58135ef48fe82b27c" id="r_ga83774d36da4155e58135ef48fe82b27c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga9818c5cd42d048d0b4597bedd340ea7a">GPUCubeMapFace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga83774d36da4155e58135ef48fe82b27c">SDL::GPU_CUBEMAPFACE_NEGATIVEZ</a></td></tr>
<tr class="memdesc:ga83774d36da4155e58135ef48fe82b27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_CUBEMAPFACE_NEGATIVEZ.  <br /></td></tr>
<tr class="separator:ga83774d36da4155e58135ef48fe82b27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59a7a2c989380823746ea674e55c688f" id="r_ga59a7a2c989380823746ea674e55c688f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga335d74d2f1cb0811156d8356904fb710">GPUBufferUsageFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga59a7a2c989380823746ea674e55c688f">SDL::GPU_BUFFERUSAGE_VERTEX</a></td></tr>
<tr class="memdesc:ga59a7a2c989380823746ea674e55c688f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer is a vertex buffer.  <br /></td></tr>
<tr class="separator:ga59a7a2c989380823746ea674e55c688f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8df140c028b236e5ed49c9a1f911ea77" id="r_ga8df140c028b236e5ed49c9a1f911ea77"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga335d74d2f1cb0811156d8356904fb710">GPUBufferUsageFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga8df140c028b236e5ed49c9a1f911ea77">SDL::GPU_BUFFERUSAGE_INDEX</a></td></tr>
<tr class="memdesc:ga8df140c028b236e5ed49c9a1f911ea77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer is an index buffer.  <br /></td></tr>
<tr class="separator:ga8df140c028b236e5ed49c9a1f911ea77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc7e10ad41409bde1368bd925307a87f" id="r_gadc7e10ad41409bde1368bd925307a87f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga335d74d2f1cb0811156d8356904fb710">GPUBufferUsageFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gadc7e10ad41409bde1368bd925307a87f">SDL::GPU_BUFFERUSAGE_INDIRECT</a></td></tr>
<tr class="memdesc:gadc7e10ad41409bde1368bd925307a87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer is an indirect buffer.  <br /></td></tr>
<tr class="separator:gadc7e10ad41409bde1368bd925307a87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b1ff54b00464f0d7f51fa0dcf63645e" id="r_ga5b1ff54b00464f0d7f51fa0dcf63645e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga335d74d2f1cb0811156d8356904fb710">GPUBufferUsageFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga5b1ff54b00464f0d7f51fa0dcf63645e">SDL::GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ</a></td></tr>
<tr class="memdesc:ga5b1ff54b00464f0d7f51fa0dcf63645e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer supports storage reads in graphics stages.  <br /></td></tr>
<tr class="separator:ga5b1ff54b00464f0d7f51fa0dcf63645e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacafe8005b8033e20026179bcd0227e38" id="r_gacafe8005b8033e20026179bcd0227e38"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga335d74d2f1cb0811156d8356904fb710">GPUBufferUsageFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gacafe8005b8033e20026179bcd0227e38">SDL::GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ</a></td></tr>
<tr class="memdesc:gacafe8005b8033e20026179bcd0227e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer supports storage reads in the compute stage.  <br /></td></tr>
<tr class="separator:gacafe8005b8033e20026179bcd0227e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e6f9cef980c19a774bf0983f2048b80" id="r_ga3e6f9cef980c19a774bf0983f2048b80"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga335d74d2f1cb0811156d8356904fb710">GPUBufferUsageFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga3e6f9cef980c19a774bf0983f2048b80">SDL::GPU_BUFFERUSAGE_COMPUTE_STORAGE_WRITE</a></td></tr>
<tr class="memdesc:ga3e6f9cef980c19a774bf0983f2048b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer supports storage writes in the compute stage.  <br /></td></tr>
<tr class="separator:ga3e6f9cef980c19a774bf0983f2048b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c3f2d42d85ac17ebcb9607cc7ee1f30" id="r_ga6c3f2d42d85ac17ebcb9607cc7ee1f30"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaa77f5c65445135e6df84bda3201c49db">GPUTransferBufferUsage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga6c3f2d42d85ac17ebcb9607cc7ee1f30">SDL::GPU_TRANSFERBUFFERUSAGE_UPLOAD</a></td></tr>
<tr class="memdesc:ga6c3f2d42d85ac17ebcb9607cc7ee1f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TRANSFERBUFFERUSAGE_UPLOAD.  <br /></td></tr>
<tr class="separator:ga6c3f2d42d85ac17ebcb9607cc7ee1f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga872d33e90827aedd5b3e4ef2bc083c72" id="r_ga872d33e90827aedd5b3e4ef2bc083c72"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaa77f5c65445135e6df84bda3201c49db">GPUTransferBufferUsage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga872d33e90827aedd5b3e4ef2bc083c72">SDL::GPU_TRANSFERBUFFERUSAGE_DOWNLOAD</a></td></tr>
<tr class="memdesc:ga872d33e90827aedd5b3e4ef2bc083c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_TRANSFERBUFFERUSAGE_DOWNLOAD.  <br /></td></tr>
<tr class="separator:ga872d33e90827aedd5b3e4ef2bc083c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76fa51f8ac6f15ccd3e240a39593077b" id="r_ga76fa51f8ac6f15ccd3e240a39593077b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga5dbe4dbc43d67929db39c145ccaa5e20">GPUShaderStage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga76fa51f8ac6f15ccd3e240a39593077b">SDL::GPU_SHADERSTAGE_VERTEX</a></td></tr>
<tr class="memdesc:ga76fa51f8ac6f15ccd3e240a39593077b"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_SHADERSTAGE_VERTEX.  <br /></td></tr>
<tr class="separator:ga76fa51f8ac6f15ccd3e240a39593077b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fa14a6d77d3ffbae3e7db1490d49853" id="r_ga7fa14a6d77d3ffbae3e7db1490d49853"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga5dbe4dbc43d67929db39c145ccaa5e20">GPUShaderStage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga7fa14a6d77d3ffbae3e7db1490d49853">SDL::GPU_SHADERSTAGE_FRAGMENT</a></td></tr>
<tr class="memdesc:ga7fa14a6d77d3ffbae3e7db1490d49853"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_SHADERSTAGE_FRAGMENT.  <br /></td></tr>
<tr class="separator:ga7fa14a6d77d3ffbae3e7db1490d49853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4daefe54d723add7825b44244670cbc" id="r_gaa4daefe54d723add7825b44244670cbc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa4daefe54d723add7825b44244670cbc">SDL::GPU_VERTEXELEMENTFORMAT_INVALID</a></td></tr>
<tr class="memdesc:gaa4daefe54d723add7825b44244670cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_INVALID.  <br /></td></tr>
<tr class="separator:gaa4daefe54d723add7825b44244670cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43dc14f2c0c8a2e57bed77ac5d13de01" id="r_ga43dc14f2c0c8a2e57bed77ac5d13de01"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga43dc14f2c0c8a2e57bed77ac5d13de01">SDL::GPU_VERTEXELEMENTFORMAT_INT</a></td></tr>
<tr class="memdesc:ga43dc14f2c0c8a2e57bed77ac5d13de01"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_INT.  <br /></td></tr>
<tr class="separator:ga43dc14f2c0c8a2e57bed77ac5d13de01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79d861f1a78b7e2b8bc55ed5e36de9d4" id="r_ga79d861f1a78b7e2b8bc55ed5e36de9d4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga79d861f1a78b7e2b8bc55ed5e36de9d4">SDL::GPU_VERTEXELEMENTFORMAT_INT2</a></td></tr>
<tr class="memdesc:ga79d861f1a78b7e2b8bc55ed5e36de9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_INT2.  <br /></td></tr>
<tr class="separator:ga79d861f1a78b7e2b8bc55ed5e36de9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac90ef78df4ab934440d5d2ba1d5a5eb8" id="r_gac90ef78df4ab934440d5d2ba1d5a5eb8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gac90ef78df4ab934440d5d2ba1d5a5eb8">SDL::GPU_VERTEXELEMENTFORMAT_INT3</a></td></tr>
<tr class="memdesc:gac90ef78df4ab934440d5d2ba1d5a5eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_INT3.  <br /></td></tr>
<tr class="separator:gac90ef78df4ab934440d5d2ba1d5a5eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2db7bcb5b6bc120d950191ec58f7e526" id="r_ga2db7bcb5b6bc120d950191ec58f7e526"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga2db7bcb5b6bc120d950191ec58f7e526">SDL::GPU_VERTEXELEMENTFORMAT_INT4</a></td></tr>
<tr class="memdesc:ga2db7bcb5b6bc120d950191ec58f7e526"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_INT4.  <br /></td></tr>
<tr class="separator:ga2db7bcb5b6bc120d950191ec58f7e526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02ae52f352503654af8013f86bd4fe0f" id="r_ga02ae52f352503654af8013f86bd4fe0f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga02ae52f352503654af8013f86bd4fe0f">SDL::GPU_VERTEXELEMENTFORMAT_UINT</a></td></tr>
<tr class="memdesc:ga02ae52f352503654af8013f86bd4fe0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_UINT.  <br /></td></tr>
<tr class="separator:ga02ae52f352503654af8013f86bd4fe0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f2e70a24cc8c831119d0c56417d6eb0" id="r_ga9f2e70a24cc8c831119d0c56417d6eb0"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga9f2e70a24cc8c831119d0c56417d6eb0">SDL::GPU_VERTEXELEMENTFORMAT_UINT2</a></td></tr>
<tr class="memdesc:ga9f2e70a24cc8c831119d0c56417d6eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_UINT2.  <br /></td></tr>
<tr class="separator:ga9f2e70a24cc8c831119d0c56417d6eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7369a9343adf6ec2d451d80d83d6e469" id="r_ga7369a9343adf6ec2d451d80d83d6e469"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga7369a9343adf6ec2d451d80d83d6e469">SDL::GPU_VERTEXELEMENTFORMAT_UINT3</a></td></tr>
<tr class="memdesc:ga7369a9343adf6ec2d451d80d83d6e469"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_UINT3.  <br /></td></tr>
<tr class="separator:ga7369a9343adf6ec2d451d80d83d6e469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9095c7dfb1ebbb4e35e715a37f8a521e" id="r_ga9095c7dfb1ebbb4e35e715a37f8a521e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga9095c7dfb1ebbb4e35e715a37f8a521e">SDL::GPU_VERTEXELEMENTFORMAT_UINT4</a></td></tr>
<tr class="memdesc:ga9095c7dfb1ebbb4e35e715a37f8a521e"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_UINT4.  <br /></td></tr>
<tr class="separator:ga9095c7dfb1ebbb4e35e715a37f8a521e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8e9b6a43a2216abaa3b3a60a4b4b7da" id="r_gaf8e9b6a43a2216abaa3b3a60a4b4b7da"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf8e9b6a43a2216abaa3b3a60a4b4b7da">SDL::GPU_VERTEXELEMENTFORMAT_FLOAT</a></td></tr>
<tr class="memdesc:gaf8e9b6a43a2216abaa3b3a60a4b4b7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_FLOAT.  <br /></td></tr>
<tr class="separator:gaf8e9b6a43a2216abaa3b3a60a4b4b7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f1d3996988e5f7a00d10d21b074b712" id="r_ga0f1d3996988e5f7a00d10d21b074b712"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga0f1d3996988e5f7a00d10d21b074b712">SDL::GPU_VERTEXELEMENTFORMAT_FLOAT2</a></td></tr>
<tr class="memdesc:ga0f1d3996988e5f7a00d10d21b074b712"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_FLOAT2.  <br /></td></tr>
<tr class="separator:ga0f1d3996988e5f7a00d10d21b074b712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga191fdc13001a91c4655fa40dcdf39edc" id="r_ga191fdc13001a91c4655fa40dcdf39edc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga191fdc13001a91c4655fa40dcdf39edc">SDL::GPU_VERTEXELEMENTFORMAT_FLOAT3</a></td></tr>
<tr class="memdesc:ga191fdc13001a91c4655fa40dcdf39edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_FLOAT3.  <br /></td></tr>
<tr class="separator:ga191fdc13001a91c4655fa40dcdf39edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4de5653c1bdbd5813d14b2c7c34ac9c7" id="r_ga4de5653c1bdbd5813d14b2c7c34ac9c7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga4de5653c1bdbd5813d14b2c7c34ac9c7">SDL::GPU_VERTEXELEMENTFORMAT_FLOAT4</a></td></tr>
<tr class="memdesc:ga4de5653c1bdbd5813d14b2c7c34ac9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_FLOAT4.  <br /></td></tr>
<tr class="separator:ga4de5653c1bdbd5813d14b2c7c34ac9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7f4d8a8b2223a7f55f7a23531a7f586" id="r_gac7f4d8a8b2223a7f55f7a23531a7f586"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gac7f4d8a8b2223a7f55f7a23531a7f586">SDL::GPU_VERTEXELEMENTFORMAT_BYTE2</a></td></tr>
<tr class="memdesc:gac7f4d8a8b2223a7f55f7a23531a7f586"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_BYTE2.  <br /></td></tr>
<tr class="separator:gac7f4d8a8b2223a7f55f7a23531a7f586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ea47beffddbf11580f737948a39b28a" id="r_ga5ea47beffddbf11580f737948a39b28a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga5ea47beffddbf11580f737948a39b28a">SDL::GPU_VERTEXELEMENTFORMAT_BYTE4</a></td></tr>
<tr class="memdesc:ga5ea47beffddbf11580f737948a39b28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_BYTE4.  <br /></td></tr>
<tr class="separator:ga5ea47beffddbf11580f737948a39b28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b6ccb8666100d7504b48bf55d9770ed" id="r_ga1b6ccb8666100d7504b48bf55d9770ed"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga1b6ccb8666100d7504b48bf55d9770ed">SDL::GPU_VERTEXELEMENTFORMAT_UBYTE2</a></td></tr>
<tr class="memdesc:ga1b6ccb8666100d7504b48bf55d9770ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_UBYTE2.  <br /></td></tr>
<tr class="separator:ga1b6ccb8666100d7504b48bf55d9770ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0e9434a8d96b06533bed5765862f045" id="r_gaa0e9434a8d96b06533bed5765862f045"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa0e9434a8d96b06533bed5765862f045">SDL::GPU_VERTEXELEMENTFORMAT_UBYTE4</a></td></tr>
<tr class="memdesc:gaa0e9434a8d96b06533bed5765862f045"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_UBYTE4.  <br /></td></tr>
<tr class="separator:gaa0e9434a8d96b06533bed5765862f045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d15af14666ee751d81e1aec0f586364" id="r_ga9d15af14666ee751d81e1aec0f586364"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga9d15af14666ee751d81e1aec0f586364">SDL::GPU_VERTEXELEMENTFORMAT_BYTE2_NORM</a></td></tr>
<tr class="memdesc:ga9d15af14666ee751d81e1aec0f586364"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_BYTE2_NORM.  <br /></td></tr>
<tr class="separator:ga9d15af14666ee751d81e1aec0f586364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8d0ee8c1d43920bd4f8ea8a92591b5f" id="r_gaf8d0ee8c1d43920bd4f8ea8a92591b5f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf8d0ee8c1d43920bd4f8ea8a92591b5f">SDL::GPU_VERTEXELEMENTFORMAT_BYTE4_NORM</a></td></tr>
<tr class="memdesc:gaf8d0ee8c1d43920bd4f8ea8a92591b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_BYTE4_NORM.  <br /></td></tr>
<tr class="separator:gaf8d0ee8c1d43920bd4f8ea8a92591b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafae02251aa771780aac088534a3a2f0f" id="r_gafae02251aa771780aac088534a3a2f0f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gafae02251aa771780aac088534a3a2f0f">SDL::GPU_VERTEXELEMENTFORMAT_UBYTE2_NORM</a></td></tr>
<tr class="memdesc:gafae02251aa771780aac088534a3a2f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_UBYTE2_NORM.  <br /></td></tr>
<tr class="separator:gafae02251aa771780aac088534a3a2f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3bf247629f6cce54d71087c3755dcb9" id="r_gae3bf247629f6cce54d71087c3755dcb9"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gae3bf247629f6cce54d71087c3755dcb9">SDL::GPU_VERTEXELEMENTFORMAT_UBYTE4_NORM</a></td></tr>
<tr class="memdesc:gae3bf247629f6cce54d71087c3755dcb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_UBYTE4_NORM.  <br /></td></tr>
<tr class="separator:gae3bf247629f6cce54d71087c3755dcb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3891b9d546cf24d2432808958d554a68" id="r_ga3891b9d546cf24d2432808958d554a68"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga3891b9d546cf24d2432808958d554a68">SDL::GPU_VERTEXELEMENTFORMAT_SHORT2</a></td></tr>
<tr class="memdesc:ga3891b9d546cf24d2432808958d554a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_SHORT2.  <br /></td></tr>
<tr class="separator:ga3891b9d546cf24d2432808958d554a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb033b89b422d579a1c6492019ef3942" id="r_gafb033b89b422d579a1c6492019ef3942"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gafb033b89b422d579a1c6492019ef3942">SDL::GPU_VERTEXELEMENTFORMAT_SHORT4</a></td></tr>
<tr class="memdesc:gafb033b89b422d579a1c6492019ef3942"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_SHORT4.  <br /></td></tr>
<tr class="separator:gafb033b89b422d579a1c6492019ef3942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2576ebc7a6f0e83310a8c2eb0f537648" id="r_ga2576ebc7a6f0e83310a8c2eb0f537648"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga2576ebc7a6f0e83310a8c2eb0f537648">SDL::GPU_VERTEXELEMENTFORMAT_USHORT2</a></td></tr>
<tr class="memdesc:ga2576ebc7a6f0e83310a8c2eb0f537648"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_USHORT2.  <br /></td></tr>
<tr class="separator:ga2576ebc7a6f0e83310a8c2eb0f537648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad472148386d0cb34a7c0a9214cff4154" id="r_gad472148386d0cb34a7c0a9214cff4154"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gad472148386d0cb34a7c0a9214cff4154">SDL::GPU_VERTEXELEMENTFORMAT_USHORT4</a></td></tr>
<tr class="memdesc:gad472148386d0cb34a7c0a9214cff4154"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_USHORT4.  <br /></td></tr>
<tr class="separator:gad472148386d0cb34a7c0a9214cff4154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e517ab6c01b194ff44b38f20f448146" id="r_ga5e517ab6c01b194ff44b38f20f448146"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga5e517ab6c01b194ff44b38f20f448146">SDL::GPU_VERTEXELEMENTFORMAT_SHORT2_NORM</a></td></tr>
<tr class="memdesc:ga5e517ab6c01b194ff44b38f20f448146"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_SHORT2_NORM.  <br /></td></tr>
<tr class="separator:ga5e517ab6c01b194ff44b38f20f448146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7389c388cf6fb310d48c1a6707bf52e" id="r_gaa7389c388cf6fb310d48c1a6707bf52e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa7389c388cf6fb310d48c1a6707bf52e">SDL::GPU_VERTEXELEMENTFORMAT_SHORT4_NORM</a></td></tr>
<tr class="memdesc:gaa7389c388cf6fb310d48c1a6707bf52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_SHORT4_NORM.  <br /></td></tr>
<tr class="separator:gaa7389c388cf6fb310d48c1a6707bf52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga106ff338c6de59c39c5d5dd6fde73023" id="r_ga106ff338c6de59c39c5d5dd6fde73023"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga106ff338c6de59c39c5d5dd6fde73023">SDL::GPU_VERTEXELEMENTFORMAT_USHORT2_NORM</a></td></tr>
<tr class="memdesc:ga106ff338c6de59c39c5d5dd6fde73023"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_USHORT2_NORM.  <br /></td></tr>
<tr class="separator:ga106ff338c6de59c39c5d5dd6fde73023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c7c9d712cdec31df8d51813ee202687" id="r_ga1c7c9d712cdec31df8d51813ee202687"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga1c7c9d712cdec31df8d51813ee202687">SDL::GPU_VERTEXELEMENTFORMAT_USHORT4_NORM</a></td></tr>
<tr class="memdesc:ga1c7c9d712cdec31df8d51813ee202687"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_USHORT4_NORM.  <br /></td></tr>
<tr class="separator:ga1c7c9d712cdec31df8d51813ee202687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d4702172276daf56741758a11ef15e4" id="r_ga9d4702172276daf56741758a11ef15e4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga9d4702172276daf56741758a11ef15e4">SDL::GPU_VERTEXELEMENTFORMAT_HALF2</a></td></tr>
<tr class="memdesc:ga9d4702172276daf56741758a11ef15e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_HALF2.  <br /></td></tr>
<tr class="separator:ga9d4702172276daf56741758a11ef15e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72f101c67edaa524cbb96e8d6591bbcc" id="r_ga72f101c67edaa524cbb96e8d6591bbcc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga72f101c67edaa524cbb96e8d6591bbcc">SDL::GPU_VERTEXELEMENTFORMAT_HALF4</a></td></tr>
<tr class="memdesc:ga72f101c67edaa524cbb96e8d6591bbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_VERTEXELEMENTFORMAT_HALF4.  <br /></td></tr>
<tr class="separator:ga72f101c67edaa524cbb96e8d6591bbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6947b96b1a3e1bebfc56caf0d4ac5719" id="r_ga6947b96b1a3e1bebfc56caf0d4ac5719"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaf0c935ed3eb7b0a1f180472c021a91e3">GPUVertexInputRate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga6947b96b1a3e1bebfc56caf0d4ac5719">SDL::GPU_VERTEXINPUTRATE_VERTEX</a></td></tr>
<tr class="memdesc:ga6947b96b1a3e1bebfc56caf0d4ac5719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute addressing is a function of the vertex index.  <br /></td></tr>
<tr class="separator:ga6947b96b1a3e1bebfc56caf0d4ac5719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d60d95216a581841ce8bdc098488a8c" id="r_ga7d60d95216a581841ce8bdc098488a8c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaf0c935ed3eb7b0a1f180472c021a91e3">GPUVertexInputRate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga7d60d95216a581841ce8bdc098488a8c">SDL::GPU_VERTEXINPUTRATE_INSTANCE</a></td></tr>
<tr class="memdesc:ga7d60d95216a581841ce8bdc098488a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute addressing is a function of the instance index.  <br /></td></tr>
<tr class="separator:ga7d60d95216a581841ce8bdc098488a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05e8512e2dbc871e08483174460abf75" id="r_ga05e8512e2dbc871e08483174460abf75"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga55ba5426913cb519b5a736f91e5a36c7">GPUFillMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga05e8512e2dbc871e08483174460abf75">SDL::GPU_FILLMODE_FILL</a></td></tr>
<tr class="memdesc:ga05e8512e2dbc871e08483174460abf75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polygons will be rendered via rasterization.  <br /></td></tr>
<tr class="separator:ga05e8512e2dbc871e08483174460abf75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab021222d8ac759481a5c228dc74e6e94" id="r_gab021222d8ac759481a5c228dc74e6e94"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga55ba5426913cb519b5a736f91e5a36c7">GPUFillMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gab021222d8ac759481a5c228dc74e6e94">SDL::GPU_FILLMODE_LINE</a></td></tr>
<tr class="memdesc:gab021222d8ac759481a5c228dc74e6e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polygon edges will be drawn as line segments.  <br /></td></tr>
<tr class="separator:gab021222d8ac759481a5c228dc74e6e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe01ad4d6c1bd34e975ae59eaac89c9f" id="r_gafe01ad4d6c1bd34e975ae59eaac89c9f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga776730df3e6b57476ae9773d3848c62c">GPUCullMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gafe01ad4d6c1bd34e975ae59eaac89c9f">SDL::GPU_CULLMODE_NONE</a></td></tr>
<tr class="memdesc:gafe01ad4d6c1bd34e975ae59eaac89c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">No triangles are culled.  <br /></td></tr>
<tr class="separator:gafe01ad4d6c1bd34e975ae59eaac89c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga960494b2dc4b164b92d1e82c8e097142" id="r_ga960494b2dc4b164b92d1e82c8e097142"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga776730df3e6b57476ae9773d3848c62c">GPUCullMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga960494b2dc4b164b92d1e82c8e097142">SDL::GPU_CULLMODE_FRONT</a></td></tr>
<tr class="memdesc:ga960494b2dc4b164b92d1e82c8e097142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Front-facing triangles are culled.  <br /></td></tr>
<tr class="separator:ga960494b2dc4b164b92d1e82c8e097142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e7066c4df69d9f1b59f5c780e789b34" id="r_ga9e7066c4df69d9f1b59f5c780e789b34"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga776730df3e6b57476ae9773d3848c62c">GPUCullMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga9e7066c4df69d9f1b59f5c780e789b34">SDL::GPU_CULLMODE_BACK</a></td></tr>
<tr class="memdesc:ga9e7066c4df69d9f1b59f5c780e789b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-facing triangles are culled.  <br /></td></tr>
<tr class="separator:ga9e7066c4df69d9f1b59f5c780e789b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b821237ef733ae06c7355d181db02de" id="r_ga9b821237ef733ae06c7355d181db02de"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gae69a13df5715495d8e282f4ac2f1c2e0">GPUFrontFace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga9b821237ef733ae06c7355d181db02de">SDL::GPU_FRONTFACE_COUNTER_CLOCKWISE</a></td></tr>
<tr class="memdesc:ga9b821237ef733ae06c7355d181db02de"><td class="mdescLeft">&#160;</td><td class="mdescRight">A triangle with counter-clockwise vertex winding will be considered front-facing.  <br /></td></tr>
<tr class="separator:ga9b821237ef733ae06c7355d181db02de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1510c99dedd7e4464d174f401c0fd9ff" id="r_ga1510c99dedd7e4464d174f401c0fd9ff"><td class="memItemLeft" align="right" valign="top"><a id="ga1510c99dedd7e4464d174f401c0fd9ff" name="ga1510c99dedd7e4464d174f401c0fd9ff"></a>
constexpr <a class="el" href="group__CategoryGPU.html#gae69a13df5715495d8e282f4ac2f1c2e0">GPUFrontFace</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::GPU_FRONTFACE_CLOCKWISE</b> = SDL_GPU_FRONTFACE_CLOCKWISE</td></tr>
<tr class="memdesc:ga1510c99dedd7e4464d174f401c0fd9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">A triangle with clockwise vertex winding will be considered front-facing. <br /></td></tr>
<tr class="separator:ga1510c99dedd7e4464d174f401c0fd9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fd0fd56aa4aea8330efdff153b986fe" id="r_ga7fd0fd56aa4aea8330efdff153b986fe"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga27b1a00730534d4ce7ac51f63874cfc7">GPUCompareOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga7fd0fd56aa4aea8330efdff153b986fe">SDL::GPU_COMPAREOP_INVALID</a></td></tr>
<tr class="memdesc:ga7fd0fd56aa4aea8330efdff153b986fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_COMPAREOP_INVALID.  <br /></td></tr>
<tr class="separator:ga7fd0fd56aa4aea8330efdff153b986fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab84a896240e2a63fdbe6f8b688f5892d" id="r_gab84a896240e2a63fdbe6f8b688f5892d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga27b1a00730534d4ce7ac51f63874cfc7">GPUCompareOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gab84a896240e2a63fdbe6f8b688f5892d">SDL::GPU_COMPAREOP_NEVER</a></td></tr>
<tr class="memdesc:gab84a896240e2a63fdbe6f8b688f5892d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The comparison always evaluates false.  <br /></td></tr>
<tr class="separator:gab84a896240e2a63fdbe6f8b688f5892d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78e087497d46c8cd9b59f8c844ac70a4" id="r_ga78e087497d46c8cd9b59f8c844ac70a4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga27b1a00730534d4ce7ac51f63874cfc7">GPUCompareOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga78e087497d46c8cd9b59f8c844ac70a4">SDL::GPU_COMPAREOP_LESS</a></td></tr>
<tr class="memdesc:ga78e087497d46c8cd9b59f8c844ac70a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The comparison evaluates reference &lt; test.  <br /></td></tr>
<tr class="separator:ga78e087497d46c8cd9b59f8c844ac70a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cf4ce2a8ebb1aa67763f3353d30a972" id="r_ga5cf4ce2a8ebb1aa67763f3353d30a972"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga27b1a00730534d4ce7ac51f63874cfc7">GPUCompareOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga5cf4ce2a8ebb1aa67763f3353d30a972">SDL::GPU_COMPAREOP_EQUAL</a></td></tr>
<tr class="memdesc:ga5cf4ce2a8ebb1aa67763f3353d30a972"><td class="mdescLeft">&#160;</td><td class="mdescRight">The comparison evaluates reference == test.  <br /></td></tr>
<tr class="separator:ga5cf4ce2a8ebb1aa67763f3353d30a972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08501c5d5caa95d367729fd6d97eb4c5" id="r_ga08501c5d5caa95d367729fd6d97eb4c5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga27b1a00730534d4ce7ac51f63874cfc7">GPUCompareOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga08501c5d5caa95d367729fd6d97eb4c5">SDL::GPU_COMPAREOP_LESS_OR_EQUAL</a></td></tr>
<tr class="memdesc:ga08501c5d5caa95d367729fd6d97eb4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The comparison evaluates reference &lt;= test.  <br /></td></tr>
<tr class="separator:ga08501c5d5caa95d367729fd6d97eb4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga977fb956630868fd74913f5c4ea5bc2f" id="r_ga977fb956630868fd74913f5c4ea5bc2f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga27b1a00730534d4ce7ac51f63874cfc7">GPUCompareOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga977fb956630868fd74913f5c4ea5bc2f">SDL::GPU_COMPAREOP_GREATER</a></td></tr>
<tr class="memdesc:ga977fb956630868fd74913f5c4ea5bc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The comparison evaluates reference &gt; test.  <br /></td></tr>
<tr class="separator:ga977fb956630868fd74913f5c4ea5bc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24df1eaf59fc5c865be0cf82cca15a91" id="r_ga24df1eaf59fc5c865be0cf82cca15a91"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga27b1a00730534d4ce7ac51f63874cfc7">GPUCompareOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga24df1eaf59fc5c865be0cf82cca15a91">SDL::GPU_COMPAREOP_NOT_EQUAL</a></td></tr>
<tr class="memdesc:ga24df1eaf59fc5c865be0cf82cca15a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">The comparison evaluates reference != test.  <br /></td></tr>
<tr class="separator:ga24df1eaf59fc5c865be0cf82cca15a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19dedf1deb36540f335ee06e96bb7ce7" id="r_ga19dedf1deb36540f335ee06e96bb7ce7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga27b1a00730534d4ce7ac51f63874cfc7">GPUCompareOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga19dedf1deb36540f335ee06e96bb7ce7">SDL::GPU_COMPAREOP_GREATER_OR_EQUAL</a></td></tr>
<tr class="memdesc:ga19dedf1deb36540f335ee06e96bb7ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The comparison evaluates reference &gt;= test.  <br /></td></tr>
<tr class="separator:ga19dedf1deb36540f335ee06e96bb7ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c2fe5c9cc35f4a001d7977c836055b5" id="r_ga0c2fe5c9cc35f4a001d7977c836055b5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga27b1a00730534d4ce7ac51f63874cfc7">GPUCompareOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga0c2fe5c9cc35f4a001d7977c836055b5">SDL::GPU_COMPAREOP_ALWAYS</a></td></tr>
<tr class="memdesc:ga0c2fe5c9cc35f4a001d7977c836055b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The comparison always evaluates true.  <br /></td></tr>
<tr class="separator:ga0c2fe5c9cc35f4a001d7977c836055b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87addd4f93d60b5e9ff9a47259676b60" id="r_ga87addd4f93d60b5e9ff9a47259676b60"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaead0310f70b17c2bc2f92dab7646c96a">GPUStencilOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga87addd4f93d60b5e9ff9a47259676b60">SDL::GPU_STENCILOP_INVALID</a></td></tr>
<tr class="memdesc:ga87addd4f93d60b5e9ff9a47259676b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_STENCILOP_INVALID.  <br /></td></tr>
<tr class="separator:ga87addd4f93d60b5e9ff9a47259676b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8a5dffef751cd3f2648e86707c18f18" id="r_gac8a5dffef751cd3f2648e86707c18f18"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaead0310f70b17c2bc2f92dab7646c96a">GPUStencilOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gac8a5dffef751cd3f2648e86707c18f18">SDL::GPU_STENCILOP_KEEP</a></td></tr>
<tr class="memdesc:gac8a5dffef751cd3f2648e86707c18f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps the current value.  <br /></td></tr>
<tr class="separator:gac8a5dffef751cd3f2648e86707c18f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bb33e4fe5df8ff3e463e897b33daade" id="r_ga0bb33e4fe5df8ff3e463e897b33daade"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaead0310f70b17c2bc2f92dab7646c96a">GPUStencilOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga0bb33e4fe5df8ff3e463e897b33daade">SDL::GPU_STENCILOP_ZERO</a></td></tr>
<tr class="memdesc:ga0bb33e4fe5df8ff3e463e897b33daade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value to 0.  <br /></td></tr>
<tr class="separator:ga0bb33e4fe5df8ff3e463e897b33daade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4644224298317a30448cc61d4458187e" id="r_ga4644224298317a30448cc61d4458187e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaead0310f70b17c2bc2f92dab7646c96a">GPUStencilOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga4644224298317a30448cc61d4458187e">SDL::GPU_STENCILOP_REPLACE</a></td></tr>
<tr class="memdesc:ga4644224298317a30448cc61d4458187e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value to reference.  <br /></td></tr>
<tr class="separator:ga4644224298317a30448cc61d4458187e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7159861449c3a54dfdfeb7574dcc2b1" id="r_gaa7159861449c3a54dfdfeb7574dcc2b1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaead0310f70b17c2bc2f92dab7646c96a">GPUStencilOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa7159861449c3a54dfdfeb7574dcc2b1">SDL::GPU_STENCILOP_INCREMENT_AND_CLAMP</a></td></tr>
<tr class="memdesc:gaa7159861449c3a54dfdfeb7574dcc2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the current value and clamps to the maximum value.  <br /></td></tr>
<tr class="separator:gaa7159861449c3a54dfdfeb7574dcc2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga900c06dbde97b629aaad39b8b298d45c" id="r_ga900c06dbde97b629aaad39b8b298d45c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaead0310f70b17c2bc2f92dab7646c96a">GPUStencilOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga900c06dbde97b629aaad39b8b298d45c">SDL::GPU_STENCILOP_DECREMENT_AND_CLAMP</a></td></tr>
<tr class="memdesc:ga900c06dbde97b629aaad39b8b298d45c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the current value and clamps to 0.  <br /></td></tr>
<tr class="separator:ga900c06dbde97b629aaad39b8b298d45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga136d2fe4473e97a7c994e697b4d39d73" id="r_ga136d2fe4473e97a7c994e697b4d39d73"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaead0310f70b17c2bc2f92dab7646c96a">GPUStencilOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga136d2fe4473e97a7c994e697b4d39d73">SDL::GPU_STENCILOP_INVERT</a></td></tr>
<tr class="memdesc:ga136d2fe4473e97a7c994e697b4d39d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise-inverts the current value.  <br /></td></tr>
<tr class="separator:ga136d2fe4473e97a7c994e697b4d39d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf59f33d86ae6282f7144d2168a152163" id="r_gaf59f33d86ae6282f7144d2168a152163"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaead0310f70b17c2bc2f92dab7646c96a">GPUStencilOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf59f33d86ae6282f7144d2168a152163">SDL::GPU_STENCILOP_INCREMENT_AND_WRAP</a></td></tr>
<tr class="memdesc:gaf59f33d86ae6282f7144d2168a152163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the current value and wraps back to 0.  <br /></td></tr>
<tr class="separator:gaf59f33d86ae6282f7144d2168a152163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga854efcdee5489889fd4ac1e1a8abd08f" id="r_ga854efcdee5489889fd4ac1e1a8abd08f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaead0310f70b17c2bc2f92dab7646c96a">GPUStencilOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga854efcdee5489889fd4ac1e1a8abd08f">SDL::GPU_STENCILOP_DECREMENT_AND_WRAP</a></td></tr>
<tr class="memdesc:ga854efcdee5489889fd4ac1e1a8abd08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the current value and wraps to the maximum value.  <br /></td></tr>
<tr class="separator:ga854efcdee5489889fd4ac1e1a8abd08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54abe011ea0e9a2a45dd686b8aaaf768" id="r_ga54abe011ea0e9a2a45dd686b8aaaf768"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga2a39f40ae7ce461c6ac1918873e4975c">GPUBlendOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga54abe011ea0e9a2a45dd686b8aaaf768">SDL::GPU_BLENDOP_INVALID</a></td></tr>
<tr class="memdesc:ga54abe011ea0e9a2a45dd686b8aaaf768"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_BLENDOP_INVALID.  <br /></td></tr>
<tr class="separator:ga54abe011ea0e9a2a45dd686b8aaaf768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf508a4df8627ef7e53a77631d53ef796" id="r_gaf508a4df8627ef7e53a77631d53ef796"><td class="memItemLeft" align="right" valign="top"><a id="gaf508a4df8627ef7e53a77631d53ef796" name="gaf508a4df8627ef7e53a77631d53ef796"></a>
constexpr <a class="el" href="group__CategoryGPU.html#ga2a39f40ae7ce461c6ac1918873e4975c">GPUBlendOp</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::GPU_BLENDOP_ADD</b> = SDL_GPU_BLENDOP_ADD</td></tr>
<tr class="memdesc:gaf508a4df8627ef7e53a77631d53ef796"><td class="mdescLeft">&#160;</td><td class="mdescRight">(source * source_factor) + (destination * destination_factor) <br /></td></tr>
<tr class="separator:gaf508a4df8627ef7e53a77631d53ef796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade59b9172bd6b5d8a2a15614af736a88" id="r_gade59b9172bd6b5d8a2a15614af736a88"><td class="memItemLeft" align="right" valign="top"><a id="gade59b9172bd6b5d8a2a15614af736a88" name="gade59b9172bd6b5d8a2a15614af736a88"></a>
constexpr <a class="el" href="group__CategoryGPU.html#ga2a39f40ae7ce461c6ac1918873e4975c">GPUBlendOp</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::GPU_BLENDOP_SUBTRACT</b> = SDL_GPU_BLENDOP_SUBTRACT</td></tr>
<tr class="memdesc:gade59b9172bd6b5d8a2a15614af736a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">(source * source_factor) - (destination * destination_factor) <br /></td></tr>
<tr class="separator:gade59b9172bd6b5d8a2a15614af736a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadae1c1cd286316549094832929e71bfc" id="r_gadae1c1cd286316549094832929e71bfc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga2a39f40ae7ce461c6ac1918873e4975c">GPUBlendOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gadae1c1cd286316549094832929e71bfc">SDL::GPU_BLENDOP_REVERSE_SUBTRACT</a></td></tr>
<tr class="memdesc:gadae1c1cd286316549094832929e71bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">(destination * destination_factor) - (source * source_factor)  <br /></td></tr>
<tr class="separator:gadae1c1cd286316549094832929e71bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dc3ea4d27e2ee84e0c3e082445ada7e" id="r_ga0dc3ea4d27e2ee84e0c3e082445ada7e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga2a39f40ae7ce461c6ac1918873e4975c">GPUBlendOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga0dc3ea4d27e2ee84e0c3e082445ada7e">SDL::GPU_BLENDOP_MIN</a></td></tr>
<tr class="memdesc:ga0dc3ea4d27e2ee84e0c3e082445ada7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">min(source, destination)  <br /></td></tr>
<tr class="separator:ga0dc3ea4d27e2ee84e0c3e082445ada7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac19b61e01f23131578ebfcefd9130f62" id="r_gac19b61e01f23131578ebfcefd9130f62"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga2a39f40ae7ce461c6ac1918873e4975c">GPUBlendOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gac19b61e01f23131578ebfcefd9130f62">SDL::GPU_BLENDOP_MAX</a></td></tr>
<tr class="memdesc:gac19b61e01f23131578ebfcefd9130f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">max(source, destination)  <br /></td></tr>
<tr class="separator:gac19b61e01f23131578ebfcefd9130f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3f2281c2594325626d8ae26f096bb15" id="r_gaa3f2281c2594325626d8ae26f096bb15"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa3f2281c2594325626d8ae26f096bb15">SDL::GPU_BLENDFACTOR_INVALID</a></td></tr>
<tr class="memdesc:gaa3f2281c2594325626d8ae26f096bb15"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU_BLENDFACTOR_INVALID.  <br /></td></tr>
<tr class="separator:gaa3f2281c2594325626d8ae26f096bb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf8728c4ff14e6708b75088f780b91e2" id="r_gabf8728c4ff14e6708b75088f780b91e2"><td class="memItemLeft" align="right" valign="top"><a id="gabf8728c4ff14e6708b75088f780b91e2" name="gabf8728c4ff14e6708b75088f780b91e2"></a>
constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::GPU_BLENDFACTOR_ZERO</b> = SDL_GPU_BLENDFACTOR_ZERO</td></tr>
<tr class="memdesc:gabf8728c4ff14e6708b75088f780b91e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">0 <br /></td></tr>
<tr class="separator:gabf8728c4ff14e6708b75088f780b91e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa00c351b058a33f4f32b7910cf95064" id="r_gafa00c351b058a33f4f32b7910cf95064"><td class="memItemLeft" align="right" valign="top"><a id="gafa00c351b058a33f4f32b7910cf95064" name="gafa00c351b058a33f4f32b7910cf95064"></a>
constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::GPU_BLENDFACTOR_ONE</b> = SDL_GPU_BLENDFACTOR_ONE</td></tr>
<tr class="memdesc:gafa00c351b058a33f4f32b7910cf95064"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 <br /></td></tr>
<tr class="separator:gafa00c351b058a33f4f32b7910cf95064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9636bf6d4cadcf0de2ade93bb0f61c7" id="r_gaa9636bf6d4cadcf0de2ade93bb0f61c7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaa9636bf6d4cadcf0de2ade93bb0f61c7">SDL::GPU_BLENDFACTOR_SRC_COLOR</a></td></tr>
<tr class="memdesc:gaa9636bf6d4cadcf0de2ade93bb0f61c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">source color  <br /></td></tr>
<tr class="separator:gaa9636bf6d4cadcf0de2ade93bb0f61c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6139ba0c241af7cdb4fa79fadee2a791" id="r_ga6139ba0c241af7cdb4fa79fadee2a791"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga6139ba0c241af7cdb4fa79fadee2a791">SDL::GPU_BLENDFACTOR_ONE_MINUS_SRC_COLOR</a></td></tr>
<tr class="memdesc:ga6139ba0c241af7cdb4fa79fadee2a791"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 - source color  <br /></td></tr>
<tr class="separator:ga6139ba0c241af7cdb4fa79fadee2a791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b0e064448a0b4742fc967d118418205" id="r_ga4b0e064448a0b4742fc967d118418205"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga4b0e064448a0b4742fc967d118418205">SDL::GPU_BLENDFACTOR_DST_COLOR</a></td></tr>
<tr class="memdesc:ga4b0e064448a0b4742fc967d118418205"><td class="mdescLeft">&#160;</td><td class="mdescRight">destination color  <br /></td></tr>
<tr class="separator:ga4b0e064448a0b4742fc967d118418205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bd926f283d262c700178e9c7f6ff404" id="r_ga7bd926f283d262c700178e9c7f6ff404"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga7bd926f283d262c700178e9c7f6ff404">SDL::GPU_BLENDFACTOR_ONE_MINUS_DST_COLOR</a></td></tr>
<tr class="memdesc:ga7bd926f283d262c700178e9c7f6ff404"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 - destination color  <br /></td></tr>
<tr class="separator:ga7bd926f283d262c700178e9c7f6ff404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaeb144a7e02024b191ca4bb7ee15f3f" id="r_gabaeb144a7e02024b191ca4bb7ee15f3f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gabaeb144a7e02024b191ca4bb7ee15f3f">SDL::GPU_BLENDFACTOR_SRC_ALPHA</a></td></tr>
<tr class="memdesc:gabaeb144a7e02024b191ca4bb7ee15f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">source alpha  <br /></td></tr>
<tr class="separator:gabaeb144a7e02024b191ca4bb7ee15f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9a68b94d7f267af949e692753b1a349" id="r_gaf9a68b94d7f267af949e692753b1a349"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf9a68b94d7f267af949e692753b1a349">SDL::GPU_BLENDFACTOR_ONE_MINUS_SRC_ALPHA</a></td></tr>
<tr class="memdesc:gaf9a68b94d7f267af949e692753b1a349"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 - source alpha  <br /></td></tr>
<tr class="separator:gaf9a68b94d7f267af949e692753b1a349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe90828d516454cf5a6a380233e60ce4" id="r_gafe90828d516454cf5a6a380233e60ce4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gafe90828d516454cf5a6a380233e60ce4">SDL::GPU_BLENDFACTOR_DST_ALPHA</a></td></tr>
<tr class="memdesc:gafe90828d516454cf5a6a380233e60ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">destination alpha  <br /></td></tr>
<tr class="separator:gafe90828d516454cf5a6a380233e60ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6cf12404134f39fbccb0d3df74e8731" id="r_gac6cf12404134f39fbccb0d3df74e8731"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gac6cf12404134f39fbccb0d3df74e8731">SDL::GPU_BLENDFACTOR_ONE_MINUS_DST_ALPHA</a></td></tr>
<tr class="memdesc:gac6cf12404134f39fbccb0d3df74e8731"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 - destination alpha  <br /></td></tr>
<tr class="separator:gac6cf12404134f39fbccb0d3df74e8731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga691377c0b575938da07e1e22feea96f6" id="r_ga691377c0b575938da07e1e22feea96f6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga691377c0b575938da07e1e22feea96f6">SDL::GPU_BLENDFACTOR_CONSTANT_COLOR</a></td></tr>
<tr class="memdesc:ga691377c0b575938da07e1e22feea96f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">blend constant  <br /></td></tr>
<tr class="separator:ga691377c0b575938da07e1e22feea96f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga230f63d8e98833b4bde8f8500c07c57f" id="r_ga230f63d8e98833b4bde8f8500c07c57f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga230f63d8e98833b4bde8f8500c07c57f">SDL::GPU_BLENDFACTOR_ONE_MINUS_CONSTANT_COLOR</a></td></tr>
<tr class="memdesc:ga230f63d8e98833b4bde8f8500c07c57f"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 - blend constant  <br /></td></tr>
<tr class="separator:ga230f63d8e98833b4bde8f8500c07c57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6a75e7ca3b8171035baf6c07a87f922" id="r_gac6a75e7ca3b8171035baf6c07a87f922"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gac6a75e7ca3b8171035baf6c07a87f922">SDL::GPU_BLENDFACTOR_SRC_ALPHA_SATURATE</a></td></tr>
<tr class="memdesc:gac6a75e7ca3b8171035baf6c07a87f922"><td class="mdescLeft">&#160;</td><td class="mdescRight">min(source alpha, 1 - destination alpha)  <br /></td></tr>
<tr class="separator:gac6a75e7ca3b8171035baf6c07a87f922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c4e8f0a94608786366fd467746d3c3d" id="r_ga9c4e8f0a94608786366fd467746d3c3d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga62905cb8376e8611e4a5b2ac378966ea">GPUColorComponentFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga9c4e8f0a94608786366fd467746d3c3d">SDL::GPU_COLORCOMPONENT_R</a></td></tr>
<tr class="memdesc:ga9c4e8f0a94608786366fd467746d3c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the red component  <br /></td></tr>
<tr class="separator:ga9c4e8f0a94608786366fd467746d3c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb9b8901a74ccef57f84ebc444c52555" id="r_gadb9b8901a74ccef57f84ebc444c52555"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga62905cb8376e8611e4a5b2ac378966ea">GPUColorComponentFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gadb9b8901a74ccef57f84ebc444c52555">SDL::GPU_COLORCOMPONENT_G</a></td></tr>
<tr class="memdesc:gadb9b8901a74ccef57f84ebc444c52555"><td class="mdescLeft">&#160;</td><td class="mdescRight">the green component  <br /></td></tr>
<tr class="separator:gadb9b8901a74ccef57f84ebc444c52555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ca7ce998c705ae32c23a31d7d07709a" id="r_ga8ca7ce998c705ae32c23a31d7d07709a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga62905cb8376e8611e4a5b2ac378966ea">GPUColorComponentFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga8ca7ce998c705ae32c23a31d7d07709a">SDL::GPU_COLORCOMPONENT_B</a></td></tr>
<tr class="memdesc:ga8ca7ce998c705ae32c23a31d7d07709a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the blue component  <br /></td></tr>
<tr class="separator:ga8ca7ce998c705ae32c23a31d7d07709a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e5f058b756c24e8f587882494d1c9cf" id="r_ga3e5f058b756c24e8f587882494d1c9cf"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga62905cb8376e8611e4a5b2ac378966ea">GPUColorComponentFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga3e5f058b756c24e8f587882494d1c9cf">SDL::GPU_COLORCOMPONENT_A</a></td></tr>
<tr class="memdesc:ga3e5f058b756c24e8f587882494d1c9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">the alpha component  <br /></td></tr>
<tr class="separator:ga3e5f058b756c24e8f587882494d1c9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf14e0259e537744513983f7c3b0a7d84" id="r_gaf14e0259e537744513983f7c3b0a7d84"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaf59e313ae6b3da6531b643e8ab9a4c62">GPUFilter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaf14e0259e537744513983f7c3b0a7d84">SDL::GPU_FILTER_NEAREST</a></td></tr>
<tr class="memdesc:gaf14e0259e537744513983f7c3b0a7d84"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structSDL_1_1Point.html" title="The structure that defines a point (using integers).">Point</a> filtering.  <br /></td></tr>
<tr class="separator:gaf14e0259e537744513983f7c3b0a7d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6807701b7fb232515dc1403f0dba9d16" id="r_ga6807701b7fb232515dc1403f0dba9d16"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gaf59e313ae6b3da6531b643e8ab9a4c62">GPUFilter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga6807701b7fb232515dc1403f0dba9d16">SDL::GPU_FILTER_LINEAR</a></td></tr>
<tr class="memdesc:ga6807701b7fb232515dc1403f0dba9d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear filtering.  <br /></td></tr>
<tr class="separator:ga6807701b7fb232515dc1403f0dba9d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cd291cb8ddcff2d81dcb71518c9194e" id="r_ga9cd291cb8ddcff2d81dcb71518c9194e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga5f58e9e7f4f148b25f3e0f839081615f">GPUSamplerMipmapMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga9cd291cb8ddcff2d81dcb71518c9194e">SDL::GPU_SAMPLERMIPMAPMODE_NEAREST</a></td></tr>
<tr class="memdesc:ga9cd291cb8ddcff2d81dcb71518c9194e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structSDL_1_1Point.html" title="The structure that defines a point (using integers).">Point</a> filtering.  <br /></td></tr>
<tr class="separator:ga9cd291cb8ddcff2d81dcb71518c9194e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f86f7874f82dff858e48bf128552691" id="r_ga3f86f7874f82dff858e48bf128552691"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#ga5f58e9e7f4f148b25f3e0f839081615f">GPUSamplerMipmapMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga3f86f7874f82dff858e48bf128552691">SDL::GPU_SAMPLERMIPMAPMODE_LINEAR</a></td></tr>
<tr class="memdesc:ga3f86f7874f82dff858e48bf128552691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear filtering.  <br /></td></tr>
<tr class="separator:ga3f86f7874f82dff858e48bf128552691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga713cb70faf22933d8410fa4d1f099f4b" id="r_ga713cb70faf22933d8410fa4d1f099f4b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gae26794f6b687f9799cba905967796a0a">GPUSamplerAddressMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga713cb70faf22933d8410fa4d1f099f4b">SDL::GPU_SAMPLERADDRESSMODE_REPEAT</a></td></tr>
<tr class="memdesc:ga713cb70faf22933d8410fa4d1f099f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that the coordinates will wrap around.  <br /></td></tr>
<tr class="separator:ga713cb70faf22933d8410fa4d1f099f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebb3e928858723b23a3c953ea8663b33" id="r_gaebb3e928858723b23a3c953ea8663b33"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gae26794f6b687f9799cba905967796a0a">GPUSamplerAddressMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#gaebb3e928858723b23a3c953ea8663b33">SDL::GPU_SAMPLERADDRESSMODE_MIRRORED_REPEAT</a></td></tr>
<tr class="memdesc:gaebb3e928858723b23a3c953ea8663b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that the coordinates will wrap around mirrored.  <br /></td></tr>
<tr class="separator:gaebb3e928858723b23a3c953ea8663b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga320314a66f7502a993528269e6e90ae6" id="r_ga320314a66f7502a993528269e6e90ae6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryGPU.html#gae26794f6b687f9799cba905967796a0a">GPUSamplerAddressMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryGPU.html#ga320314a66f7502a993528269e6e90ae6">SDL::GPU_SAMPLERADDRESSMODE_CLAMP_TO_EDGE</a></td></tr>
<tr class="memdesc:ga320314a66f7502a993528269e6e90ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that the coordinates will clamp to the 0-1 range.  <br /></td></tr>
<tr class="separator:ga320314a66f7502a993528269e6e90ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>It offers both 3D graphics and compute support, in the style of Metal, Vulkan, and Direct3D 12.</p>
<p>A basic workflow might be something like this:</p>
<p>The app creates a GPU device with <a class="el" href="classSDL_1_1GPUDevice.html#a9fde3883d9146abd2533f4882d233906" title="Default ctor.">GPUDevice.GPUDevice()</a>, and assigns it to a window with <a class="el" href="group__CategoryGPU.html#gacbc4104e7cefaaccaf221b4938dacdd9" title="Claims a window, creating a swapchain structure for it.">GPUDevice.ClaimWindow()</a>&ndash;although strictly speaking you can render offscreen entirely, perhaps for image processing, and not use a window at all.</p>
<p>Next, the app prepares static data (things that are created once and used over and over). For example:</p>
<ul>
<li>Shaders (programs that run on the GPU): use <a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader()</a>.</li>
<li>Vertex buffers (arrays of geometry data) and other rendering data: use <a class="el" href="classSDL_1_1GPUBuffer.html#af5e9803e82a340e2fb9a39197f8ea839" title="Wraps GPUBuffer.">GPUBuffer.GPUBuffer()</a> and <a class="el" href="group__CategoryGPU.html#ga49c5fe1ce14d954d818e0510c7ee875c" title="Uploads data from a transfer buffer to a buffer.">GPUCopyPass.UploadToBuffer()</a>.</li>
<li>Textures (images): use <a class="el" href="classSDL_1_1GPUTexture.html#a275899ad3f4afee497cd31161f61cffa" title="Wraps GPUTexture.">GPUTexture.GPUTexture()</a> and <a class="el" href="group__CategoryGPU.html#gab5b7ed8fb63a9d190521a0618214b2c2" title="Uploads data from a transfer buffer to a texture.">GPUCopyPass.UploadToTexture()</a>.</li>
<li>Samplers (how textures should be read from): use <a class="el" href="classSDL_1_1GPUSampler.html#ac8f316c904af2387d9aa05b6952bbf88" title="Wraps GPUSampler.">GPUSampler.GPUSampler()</a>.</li>
<li>Render pipelines (precalculated rendering state): use <a class="el" href="classSDL_1_1GPUGraphicsPipeline.html#aa6c513650dc796f541138ec49883165e" title="Wraps GPUGraphicsPipeline.">GPUGraphicsPipeline.GPUGraphicsPipeline()</a></li>
</ul>
<p>To render, the app creates one or more command buffers, with <a class="el" href="group__CategoryGPU.html#ga3afecf456819388452c8af3797f84547" title="Acquire a command buffer.">GPUDevice.AcquireCommandBuffer()</a>. Command buffers collect rendering instructions that will be submitted to the GPU in batch. Complex scenes can use multiple command buffers, maybe configured across multiple threads in parallel, as long as they are submitted in the correct order, but many apps will just need one command buffer per frame.</p>
<p>Rendering can happen to a texture (what other APIs call a "render target") or it can happen to the swapchain texture (which is just a special texture that represents a window's contents). The app can use <a class="el" href="group__CategoryGPU.html#gae4234ed0ab6264374493b9b6cb07c770" title="Blocks the thread until a swapchain texture is available to be acquired, and then acquires it.">GPUCommandBuffer.WaitAndAcquireSwapchainTexture()</a> to render to the window.</p>
<p>Rendering actually happens in a Render Pass, which is encoded into a command buffer. One can encode multiple render passes (or alternate between render and compute passes) in a single command buffer, but many apps might simply need a single render pass in a single command buffer. Render Passes can render to up to four color textures and one depth texture simultaneously. If the set of textures being rendered to needs to change, the Render Pass must be ended and a new one must be begun.</p>
<p>The app calls <a class="el" href="group__CategoryGPU.html#gaf954393ca11e67b26e5ab32b5c85a56e" title="Begins a render pass on a command buffer.">GPUCommandBuffer.BeginRenderPass()</a>. Then it sets states it needs for each draw:</p>
<ul>
<li><a class="el" href="group__CategoryGPU.html#gabe7475370741dbc4a0b9ec8fbafd5c63" title="Binds a graphics pipeline on a render pass to be used in rendering.">GPURenderPass.BindPipeline()</a></li>
<li><a class="el" href="group__CategoryGPU.html#ga5dca24a164e094b5a9959e3e96872be1" title="Sets the current viewport state on a command buffer.">GPURenderPass.SetViewport()</a></li>
<li><a class="el" href="group__CategoryGPU.html#ga92908a319a7f02815bda65d27d1dcbfc" title="Binds vertex buffers on a command buffer for use with subsequent draw calls.">GPURenderPass.BindVertexBuffers()</a></li>
<li><a class="el" href="group__CategoryGPU.html#ga4ca101f553e4044b77d14c04f50d96ff" title="Binds texture-sampler pairs for use on the vertex shader.">GPURenderPass.BindVertexSamplers()</a></li>
<li>etc</li>
</ul>
<p>Then, make the actual draw commands with these states:</p>
<ul>
<li><a class="el" href="group__CategoryGPU.html#gaee46a464d450edc057c4a1fa60adf855" title="Draws data using bound graphics state.">GPURenderPass.DrawPrimitives()</a></li>
<li><a class="el" href="group__CategoryGPU.html#ga4cad31422505ada85f19d81536dfe3d9" title="Draws data using bound graphics state and with draw parameters set from a buffer.">GPURenderPass.DrawPrimitivesIndirect()</a></li>
<li><a class="el" href="group__CategoryGPU.html#gafef162b6d49f6d172616026fbc1d5b37" title="Draws data using bound graphics state with an index buffer enabled and with draw parameters set from ...">GPURenderPass.DrawIndexedPrimitivesIndirect()</a></li>
<li>etc</li>
</ul>
<p>After all the drawing commands for a pass are complete, the app should call <a class="el" href="group__CategoryGPU.html#ga93da9193744c70e7d6334440a676b787" title="Ends the given render pass.">GPURenderPass.End()</a>. Once a render pass ends all render-related state is reset.</p>
<p>The app can begin new Render Passes and make new draws in the same command buffer until the entire scene is rendered.</p>
<p>Once all of the render commands for the scene are complete, the app calls <a class="el" href="group__CategoryGPU.html#ga673e4e3d3bdfe9596fa05693cbde73b2" title="Submits a command buffer so its commands can be processed on the GPU.">GPUCommandBuffer.Submit()</a> to send it to the GPU for processing.</p>
<p>If the app needs to read back data from texture or buffers, the API has an efficient way of doing this, provided that the app is willing to tolerate some latency. When the app uses <a class="el" href="group__CategoryGPU.html#ga350647db0f6c39ab4556bc767eb9da69" title="Copies data from a texture to a transfer buffer on the GPU timeline.">GPUCopyPass.DownloadFromTexture()</a> or <a class="el" href="group__CategoryGPU.html#gacc93df1d338fafc2aedb4216f299a34e" title="Copies data from a buffer to a transfer buffer on the GPU timeline.">GPUCopyPass.DownloadFromBuffer()</a>, submitting the command buffer with <a class="el" href="group__CategoryGPU.html#gad610ad628240f1b49aaa7eaec0ccd271" title="Submits a command buffer so its commands can be processed on the GPU, and acquires a fence associated...">GPUCommandBuffer.SubmitAndAcquireFence()</a> will return a fence handle that the app can poll or wait on in a thread. Once the fence indicates that the command buffer is done processing, it is safe to read the downloaded data. Make sure to call <a class="el" href="group__CategoryGPU.html#ga63f199ccc1f91e8540c423b82555e186" title="Releases a fence obtained from GPUCommandBuffer.SubmitAndAcquireFence.">GPUDevice.ReleaseFence()</a> when done with the fence.</p>
<p>The API also has "compute" support. The app calls <a class="el" href="group__CategoryGPU.html#ga94a40eb89d9af8a06054a029bcc92dc7" title="Begins a compute pass on a command buffer.">GPUCommandBuffer.BeginComputePass()</a> with compute-writeable textures and/or buffers, which can be written to in a compute shader. Then it sets states it needs for the compute dispatches:</p>
<ul>
<li><a class="el" href="group__CategoryGPU.html#gac753bb4535cbb52be02c8aca142abea3" title="Binds a compute pipeline on a command buffer for use in compute dispatch.">GPUComputePass.BindPipeline()</a></li>
<li><a class="el" href="group__CategoryGPU.html#ga3867eeb6d7a78593063877ae13c11085" title="Binds storage buffers as readonly for use on the compute pipeline.">GPUComputePass.BindStorageBuffers()</a></li>
<li><a class="el" href="group__CategoryGPU.html#gaedb0e69f7d25a28e1230ab5e02aa18af" title="Binds storage textures as readonly for use on the compute pipeline.">GPUComputePass.BindStorageTextures()</a></li>
</ul>
<p>Then, dispatch compute work:</p>
<ul>
<li><a class="el" href="group__CategoryGPU.html#ga035cf70f11f2a3fb5061495b7e4b1c97" title="Dispatches compute work.">GPUComputePass.Dispatch()</a></li>
</ul>
<p>For advanced users, this opens up powerful GPU-driven workflows.</p>
<p>Graphics and compute pipelines require the use of shaders, which as mentioned above are small programs executed on the GPU. Each backend (Vulkan, Metal, D3D12) requires a different shader format. When the app creates the GPU device, the app lets the device know which shader formats the app can provide. It will then select the appropriate backend depending on the available shader formats and the backends available on the platform. When creating shaders, the app must provide the correct shader format for the selected backend. If you would like to learn more about why the API works this way, there is a detailed <a href="https://moonside.games/posts/layers-all-the-way-down/">blog post</a> explaining this situation.</p>
<p>It is optimal for apps to pre-compile the shader formats they might use, but for ease of use <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> provides a separate project, <a href="https://github.com/libsdl-org/SDL_shadercross">SDL_shadercross</a> , for performing runtime shader cross-compilation. It also has a CLI interface for offline precompilation as well.</p>
<p>This is an extremely quick overview that leaves out several important details. Already, though, one can see that GPU programming can be quite complex! If you just need simple 2D graphics, the <a href="https://wiki.libsdl.org/SDL3/CategoryRender">Render API</a> is much easier to use but still hardware-accelerated. That said, even for 2D applications the performance benefits and expressiveness of the GPU API are significant.</p>
<p>The GPU API targets a feature set with a wide range of hardware support and ease of portability. It is designed so that the app won't have to branch itself by querying feature support. If you need cutting-edge features with limited hardware support, this API is probably not for you.</p>
<p>Examples demonstrating proper usage of this API can be found <a href="https://github.com/TheSpydog/SDL_gpu_examples">here</a>.</p>
<h2><a class="anchor" id="performance-considerations"></a>
Performance considerations</h2>
<p>Here are some basic tips for maximizing your rendering performance.</p>
<ul>
<li>Beginning a new render pass is relatively expensive. Use as few render passes as you can.</li>
<li>Minimize the amount of state changes. For example, binding a pipeline is relatively cheap, but doing it hundreds of times when you don't need to will slow the performance significantly.</li>
<li>Perform your data uploads as early as possible in the frame.</li>
<li>Don't churn resources. Creating and releasing resources is expensive. It's better to create what you need up front and cache it.</li>
<li>Don't use uniform buffers for large amounts of data (more than a matrix or so). Use a storage buffer instead.</li>
<li>Use cycling correctly. There is a detailed explanation of cycling further below.</li>
<li>Use culling techniques to minimize pixel writes. The less writing the GPU has to do the better. Culling can be a very advanced topic but even simple culling techniques can boost performance significantly.</li>
</ul>
<p>In general try to remember the golden rule of performance: doing things is more expensive than not doing things. Don't Touch The Driver!</p>
<h2><a class="anchor" id="faq"></a>
FAQ</h2>
<p><b>Question: When are you adding more advanced features, like ray tracing or mesh shaders?</b></p>
<p>Answer: We don't have immediate plans to add more bleeding-edge features, but we certainly might in the future, when these features prove worthwhile, and reasonable to implement across several platforms and underlying APIs. So while these things are not in the "never" category, they are definitely not "near future" items either.</p>
<p><b>Question: Why is my shader not working?</b></p>
<p>Answer: A common oversight when using shaders is not properly laying out the shader resources/registers correctly. The GPU API is very strict with how it wants resources to be laid out and it's difficult for the API to automatically validate shaders to see if they have a compatible layout. See the documentation for <a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader()</a> and <a class="el" href="classSDL_1_1GPUComputePipeline.html#a31fb977bf2f3d0ec29c431979fa936a3" title="Wraps GPUComputePipeline.">GPUComputePipeline.GPUComputePipeline()</a> for information on the expected layout.</p>
<p>Another common issue is not setting the correct number of samplers, textures, and buffers in GPUShaderCreateInfo. If possible use shader reflection to extract the required information from the shader automatically instead of manually filling in the struct's values.</p>
<p><b>Question: My application isn't performing very well. Is this the GPU API's fault?</b></p>
<p>Answer: No. Long answer: The GPU API is a relatively thin layer over the underlying graphics API. While it's possible that we have done something inefficiently, it's very unlikely especially if you are relatively inexperienced with GPU rendering. Please see the performance tips above and make sure you are following them. Additionally, tools like RenderDoc can be very helpful for diagnosing incorrect behavior and performance issues.</p>
<h2><a class="anchor" id="system-requirements"></a>
System Requirements</h2>
<p><b>Vulkan:</b> Supported on Windows, Linux, Nintendo Switch, and certain Android devices. Requires Vulkan 1.0 with the following extensions and device features:</p>
<ul>
<li><code>VK_KHR_swapchain</code></li>
<li><code>VK_KHR_maintenance1</code></li>
<li><code>independentBlend</code></li>
<li><code>imageCubeArray</code></li>
<li><code>depthClamp</code></li>
<li><code>shaderClipDistance</code></li>
<li><code>drawIndirectFirstInstance</code></li>
</ul>
<p><b>D3D12:</b> Supported on Windows 10 or newer, Xbox One (GDK), and Xbox Series X|S (GDK). Requires a GPU that supports DirectX 12 Feature Level 11_0 and Resource Binding Tier 2 or above.</p>
<p><b>Metal:</b> Supported on macOS 10.14+ and iOS/tvOS 13.0+. Hardware requirements vary by operating system:</p>
<ul>
<li>macOS requires an Apple Silicon or <a href="https://developer.apple.com/documentation/metal/mtlfeatureset/mtlfeatureset_macos_gpufamily2_v1?language=objc">Intel Mac2 family</a> GPU</li>
<li>iOS/tvOS requires an A9 GPU or newer</li>
<li>iOS Simulator and tvOS Simulator are unsupported</li>
</ul>
<h2><a class="anchor" id="uniform-data"></a>
Uniform Data</h2>
<p>Uniforms are for passing data to shaders. The uniform data will be constant across all executions of the shader.</p>
<p>There are 4 available uniform slots per shader stage (where the stages are vertex, fragment, and compute). Uniform data pushed to a slot on a stage keeps its value throughout the command buffer until you call the relevant Push function on that slot again.</p>
<p>For example, you could write your vertex shaders to read a camera matrix from uniform binding slot 0, push the camera matrix at the start of the command buffer, and that data will be used for every subsequent draw call.</p>
<p>It is valid to push uniform data during a render or compute pass.</p>
<p>Uniforms are best for pushing small amounts of data. If you are pushing more than a matrix or two per call you should consider using a storage buffer instead.</p>
<h2><a class="anchor" id="a-note-on-cycling"></a>
A Note On Cycling</h2>
<p>When using a command buffer, operations do not occur immediately - they occur some time after the command buffer is submitted.</p>
<p>When a resource is used in a pending or active command buffer, it is considered to be "bound". When a resource is no longer used in any pending or active command buffers, it is considered to be "unbound".</p>
<p>If data resources are bound, it is unspecified when that data will be unbound unless you acquire a fence when submitting the command buffer and wait on it. However, this doesn't mean you need to track resource usage manually.</p>
<p>All of the functions and structs that involve writing to a resource have a "cycle" bool. <a class="el" href="classSDL_1_1GPUTransferBuffer.html" title="An opaque handle representing a transfer buffer.">GPUTransferBuffer</a>, <a class="el" href="classSDL_1_1GPUBuffer.html" title="An opaque handle representing a buffer.">GPUBuffer</a>, and <a class="el" href="classSDL_1_1GPUTexture.html" title="An opaque handle representing a texture.">GPUTexture</a> all effectively function as ring buffers on internal resources. When cycle is true, if the resource is bound, the cycle rotates to the next unbound internal resource, or if none are available, a new one is created. This means you don't have to worry about complex state tracking and synchronization as long as cycling is correctly employed.</p>
<p>For example: you can call <a class="el" href="group__CategoryGPU.html#ga1cf97fcd43dd972f87051ba4b3d6ebec" title="Maps a transfer buffer into application address space.">GPUDevice.MapTransferBuffer()</a>, write texture data, <a class="el" href="group__CategoryGPU.html#ga69ee23a532fc7ab5ed15480500de6b0e" title="Unmaps a previously mapped transfer buffer.">GPUDevice.UnmapTransferBuffer()</a>, and then <a class="el" href="group__CategoryGPU.html#gab5b7ed8fb63a9d190521a0618214b2c2" title="Uploads data from a transfer buffer to a texture.">GPUCopyPass.UploadToTexture()</a>. The next time you write texture data to the transfer buffer, if you set the cycle param to true, you don't have to worry about overwriting any data that is not yet uploaded.</p>
<p>Another example: If you are using a texture in a render pass every frame, this can cause a data dependency between frames. If you set cycle to true in the GPUColorTargetInfo struct, you can prevent this data dependency.</p>
<p>Cycling will never undefine already bound data. When cycling, all data in the resource is considered to be undefined for subsequent commands until that data is written again. You must take care not to read undefined data.</p>
<p>Note that when cycling a texture, the entire texture will be cycled, even if only part of the texture is used in the call, so you must consider the entire texture to contain undefined data after cycling.</p>
<p>You must also take care not to overwrite a section of data that has been referenced in a command without cycling first. It is OK to overwrite unreferenced data in a bound resource without cycling, but overwriting a section of data that has already been referenced will produce unexpected results. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga4f1b5cc82a6f49a6cf0644b60bebff89" name="ga4f1b5cc82a6f49a6cf0644b60bebff89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f1b5cc82a6f49a6cf0644b60bebff89">&#9670;&#160;</a></span>GPUBlendFactor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">SDL::GPUBlendFactor</a> = typedef SDL_GPUBlendFactor</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The source color is the value written by the fragment shader. The destination color is the value currently existing in the texture.</p>
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html#aa6c513650dc796f541138ec49883165e" title="Wraps GPUGraphicsPipeline.">GPUGraphicsPipeline.GPUGraphicsPipeline</a> </dd></dl>

</div>
</div>
<a id="ga2a39f40ae7ce461c6ac1918873e4975c" name="ga2a39f40ae7ce461c6ac1918873e4975c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a39f40ae7ce461c6ac1918873e4975c">&#9670;&#160;</a></span>GPUBlendOp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga2a39f40ae7ce461c6ac1918873e4975c">SDL::GPUBlendOp</a> = typedef SDL_GPUBlendOp</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The source color is the value written by the fragment shader. The destination color is the value currently existing in the texture.</p>
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html#aa6c513650dc796f541138ec49883165e" title="Wraps GPUGraphicsPipeline.">GPUGraphicsPipeline.GPUGraphicsPipeline</a> </dd></dl>

</div>
</div>
<a id="gaabb30629d61cc6f590279354030c3f73" name="gaabb30629d61cc6f590279354030c3f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabb30629d61cc6f590279354030c3f73">&#9670;&#160;</a></span>GPUBlitInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gaabb30629d61cc6f590279354030c3f73">SDL::GPUBlitInfo</a> = typedef SDL_GPUBlitInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga34fde09ad7856dc08b894c41fff9fc0f" title="Blits from a source texture region to a destination texture region.">GPUCommandBuffer.BlitTexture</a> </dd></dl>

</div>
</div>
<a id="gaf6925fa9fd549021a51eef2f7639204f" name="gaf6925fa9fd549021a51eef2f7639204f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6925fa9fd549021a51eef2f7639204f">&#9670;&#160;</a></span>GPUBlitRegion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gaf6925fa9fd549021a51eef2f7639204f">SDL::GPUBlitRegion</a> = typedef SDL_GPUBlitRegion</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga34fde09ad7856dc08b894c41fff9fc0f" title="Blits from a source texture region to a destination texture region.">GPUCommandBuffer.BlitTexture</a> </dd></dl>

</div>
</div>
<a id="ga698bbc29bd1e44bec1e2b87ce3a81dbb" name="ga698bbc29bd1e44bec1e2b87ce3a81dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga698bbc29bd1e44bec1e2b87ce3a81dbb">&#9670;&#160;</a></span>GPUBufferBinding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga698bbc29bd1e44bec1e2b87ce3a81dbb">SDL::GPUBufferBinding</a> = typedef SDL_GPUBufferBinding</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga92908a319a7f02815bda65d27d1dcbfc" title="Binds vertex buffers on a command buffer for use with subsequent draw calls.">GPURenderPass.BindVertexBuffers</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga81998c754544c2c494ec36f5450e6318" title="Binds an index buffer on a command buffer for use with subsequent draw calls.">GPURenderPass.BindIndexBuffer</a> </dd></dl>

</div>
</div>
<a id="ga6cb3830a3ade4303d47a017993de4fea" name="ga6cb3830a3ade4303d47a017993de4fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cb3830a3ade4303d47a017993de4fea">&#9670;&#160;</a></span>GPUBufferCreateInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga6cb3830a3ade4303d47a017993de4fea">SDL::GPUBufferCreateInfo</a> = typedef SDL_GPUBufferCreateInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Usage flags can be bitwise OR'd together for combinations of usages. Note that certain combinations are invalid, for example VERTEX and INDEX.</p>
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUBuffer.html#af5e9803e82a340e2fb9a39197f8ea839" title="Wraps GPUBuffer.">GPUBuffer.GPUBuffer</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga335d74d2f1cb0811156d8356904fb710" title="Specifies how a buffer is intended to be used by the client.">GPUBufferUsageFlags</a> </dd></dl>

</div>
</div>
<a id="ga6b24b7fc30f477db4a44bc2f1637bd35" name="ga6b24b7fc30f477db4a44bc2f1637bd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b24b7fc30f477db4a44bc2f1637bd35">&#9670;&#160;</a></span>GPUBufferLocation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga6b24b7fc30f477db4a44bc2f1637bd35">SDL::GPUBufferLocation</a> = typedef SDL_GPUBufferLocation</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used when copying data between buffers.</p>
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gaa95f70236a503838592fd233846d49a8" title="Performs a buffer-to-buffer copy.">GPUCopyPass.CopyBufferToBuffer</a> </dd></dl>

</div>
</div>
<a id="gac3310186554cb88f7b1a1599171aabdf" name="gac3310186554cb88f7b1a1599171aabdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3310186554cb88f7b1a1599171aabdf">&#9670;&#160;</a></span>GPUBufferRegion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gac3310186554cb88f7b1a1599171aabdf">SDL::GPUBufferRegion</a> = typedef SDL_GPUBufferRegion</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used when transferring data to or from buffers.</p>
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga49c5fe1ce14d954d818e0510c7ee875c" title="Uploads data from a transfer buffer to a buffer.">GPUCopyPass.UploadToBuffer</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gacc93df1d338fafc2aedb4216f299a34e" title="Copies data from a buffer to a transfer buffer on the GPU timeline.">GPUCopyPass.DownloadFromBuffer</a> </dd></dl>

</div>
</div>
<a id="ga335d74d2f1cb0811156d8356904fb710" name="ga335d74d2f1cb0811156d8356904fb710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga335d74d2f1cb0811156d8356904fb710">&#9670;&#160;</a></span>GPUBufferUsageFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga335d74d2f1cb0811156d8356904fb710">SDL::GPUBufferUsageFlags</a> = typedef <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A buffer must have at least one usage flag. Note that some usage flag combinations are invalid.</p>
<p>Unlike textures, READ | WRITE can be used for simultaneous read-write usage. The same data synchronization concerns as textures apply.</p>
<p>If you use a STORAGE flag, the data in the buffer must respect std140 layout conventions. In practical terms this means you must ensure that vec3 and vec4 fields are 16-byte aligned.</p>
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUBuffer.html#af5e9803e82a340e2fb9a39197f8ea839" title="Wraps GPUBuffer.">GPUBuffer.GPUBuffer</a> </dd></dl>

</div>
</div>
<a id="ga62905cb8376e8611e4a5b2ac378966ea" name="ga62905cb8376e8611e4a5b2ac378966ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62905cb8376e8611e4a5b2ac378966ea">&#9670;&#160;</a></span>GPUColorComponentFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga62905cb8376e8611e4a5b2ac378966ea">SDL::GPUColorComponentFlags</a> = typedef <a class="el" href="group__CategoryStdinc.html#gadeddb36a6d67c5bc92003dd7679b4b17">Uint8</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html#aa6c513650dc796f541138ec49883165e" title="Wraps GPUGraphicsPipeline.">GPUGraphicsPipeline.GPUGraphicsPipeline</a> </dd></dl>

</div>
</div>
<a id="ga566840738382b6dbf0d307149756e408" name="ga566840738382b6dbf0d307149756e408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga566840738382b6dbf0d307149756e408">&#9670;&#160;</a></span>GPUColorTargetBlendState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga566840738382b6dbf0d307149756e408">SDL::GPUColorTargetBlendState</a> = typedef SDL_GPUColorTargetBlendState</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga37eabd1e9acff0106e7c203493274188" title="A structure specifying the parameters of color targets used in a graphics pipeline.">GPUColorTargetDescription</a> </dd></dl>

</div>
</div>
<a id="ga37eabd1e9acff0106e7c203493274188" name="ga37eabd1e9acff0106e7c203493274188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37eabd1e9acff0106e7c203493274188">&#9670;&#160;</a></span>GPUColorTargetDescription</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga37eabd1e9acff0106e7c203493274188">SDL::GPUColorTargetDescription</a> = typedef SDL_GPUColorTargetDescription</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga2e000919fb7eb2049a72472a253094f8" title="A structure specifying the descriptions of render targets used in a graphics pipeline.">GPUGraphicsPipelineTargetInfo</a> </dd></dl>

</div>
</div>
<a id="ga26904510dffa9db5b09c79637b00edbc" name="ga26904510dffa9db5b09c79637b00edbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26904510dffa9db5b09c79637b00edbc">&#9670;&#160;</a></span>GPUColorTargetInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga26904510dffa9db5b09c79637b00edbc">SDL::GPUColorTargetInfo</a> = typedef SDL_GPUColorTargetInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The load_op field determines what is done with the texture at the beginning of the render pass.</p>
<ul>
<li>LOAD: Loads the data currently in the texture. Not recommended for multisample textures as it requires significant memory bandwidth.</li>
<li>CLEAR: Clears the texture to a single color.</li>
<li>DONT_CARE: The driver will do whatever it wants with the texture memory. This is a good option if you know that every single pixel will be touched in the render pass.</li>
</ul>
<p>The store_op field determines what is done with the color results of the render pass.</p>
<ul>
<li>STORE: Stores the results of the render pass in the texture. Not recommended for multisample textures as it requires significant memory bandwidth.</li>
<li>DONT_CARE: The driver will do whatever it wants with the texture memory. This is often a good option for depth/stencil textures.</li>
<li>RESOLVE: Resolves a multisample texture into resolve_texture, which must have a sample count of 1. Then the driver may discard the multisample texture memory. This is the most performant method of resolving a multisample target.</li>
<li>RESOLVE_AND_STORE: Resolves a multisample texture into the resolve_texture, which must have a sample count of 1. Then the driver stores the multisample texture's contents. Not recommended as it requires significant memory bandwidth.</li>
</ul>
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gaf954393ca11e67b26e5ab32b5c85a56e" title="Begins a render pass on a command buffer.">GPUCommandBuffer.BeginRenderPass</a> </dd></dl>

</div>
</div>
<a id="ga27b1a00730534d4ce7ac51f63874cfc7" name="ga27b1a00730534d4ce7ac51f63874cfc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27b1a00730534d4ce7ac51f63874cfc7">&#9670;&#160;</a></span>GPUCompareOp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga27b1a00730534d4ce7ac51f63874cfc7">SDL::GPUCompareOp</a> = typedef SDL_GPUCompareOp</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html#aa6c513650dc796f541138ec49883165e" title="Wraps GPUGraphicsPipeline.">GPUGraphicsPipeline.GPUGraphicsPipeline</a> </dd></dl>

</div>
</div>
<a id="ga9baa44a9f7478858ee1ac28037e0574f" name="ga9baa44a9f7478858ee1ac28037e0574f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9baa44a9f7478858ee1ac28037e0574f">&#9670;&#160;</a></span>GPUComputePipelineCreateInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga9baa44a9f7478858ee1ac28037e0574f">SDL::GPUComputePipelineCreateInfo</a> = typedef SDL_GPUComputePipelineCreateInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUComputePipeline.html#a31fb977bf2f3d0ec29c431979fa936a3" title="Wraps GPUComputePipeline.">GPUComputePipeline.GPUComputePipeline</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c" title="Specifies the format of shader code.">GPUShaderFormat</a> </dd></dl>

</div>
</div>
<a id="ga9818c5cd42d048d0b4597bedd340ea7a" name="ga9818c5cd42d048d0b4597bedd340ea7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9818c5cd42d048d0b4597bedd340ea7a">&#9670;&#160;</a></span>GPUCubeMapFace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga9818c5cd42d048d0b4597bedd340ea7a">SDL::GPUCubeMapFace</a> = typedef SDL_GPUCubeMapFace</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Can be passed in as the layer field in texture-related structs.</p>
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga776730df3e6b57476ae9773d3848c62c" name="ga776730df3e6b57476ae9773d3848c62c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga776730df3e6b57476ae9773d3848c62c">&#9670;&#160;</a></span>GPUCullMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga776730df3e6b57476ae9773d3848c62c">SDL::GPUCullMode</a> = typedef SDL_GPUCullMode</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html#aa6c513650dc796f541138ec49883165e" title="Wraps GPUGraphicsPipeline.">GPUGraphicsPipeline.GPUGraphicsPipeline</a> </dd></dl>

</div>
</div>
<a id="ga013a5670075cbdd8696a60b8339eacba" name="ga013a5670075cbdd8696a60b8339eacba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga013a5670075cbdd8696a60b8339eacba">&#9670;&#160;</a></span>GPUDepthStencilState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga013a5670075cbdd8696a60b8339eacba">SDL::GPUDepthStencilState</a> = typedef SDL_GPUDepthStencilState</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga60d171e0d2bee691d934e2275b2bf23b" title="A structure specifying the parameters of a graphics pipeline state.">GPUGraphicsPipelineCreateInfo</a> </dd></dl>

</div>
</div>
<a id="ga28e62eba4af4c55395ef3cecf7fc0ebc" name="ga28e62eba4af4c55395ef3cecf7fc0ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28e62eba4af4c55395ef3cecf7fc0ebc">&#9670;&#160;</a></span>GPUDepthStencilTargetInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga28e62eba4af4c55395ef3cecf7fc0ebc">SDL::GPUDepthStencilTargetInfo</a> = typedef SDL_GPUDepthStencilTargetInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The load_op field determines what is done with the depth contents of the texture at the beginning of the render pass.</p>
<ul>
<li>LOAD: Loads the depth values currently in the texture.</li>
<li>CLEAR: Clears the texture to a single depth.</li>
<li>DONT_CARE: The driver will do whatever it wants with the memory. This is a good option if you know that every single pixel will be touched in the render pass.</li>
</ul>
<p>The store_op field determines what is done with the depth results of the render pass.</p>
<ul>
<li>STORE: Stores the depth results in the texture.</li>
<li>DONT_CARE: The driver will do whatever it wants with the depth results. This is often a good option for depth/stencil textures that don't need to be reused again.</li>
</ul>
<p>The stencil_load_op field determines what is done with the stencil contents of the texture at the beginning of the render pass.</p>
<ul>
<li>LOAD: Loads the stencil values currently in the texture.</li>
<li>CLEAR: Clears the stencil values to a single value.</li>
<li>DONT_CARE: The driver will do whatever it wants with the memory. This is a good option if you know that every single pixel will be touched in the render pass.</li>
</ul>
<p>The stencil_store_op field determines what is done with the stencil results of the render pass.</p>
<ul>
<li>STORE: Stores the stencil results in the texture.</li>
<li>DONT_CARE: The driver will do whatever it wants with the stencil results. This is often a good option for depth/stencil textures that don't need to be reused again.</li>
</ul>
<p>Note that depth/stencil targets do not support multisample resolves.</p>
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gaf954393ca11e67b26e5ab32b5c85a56e" title="Begins a render pass on a command buffer.">GPUCommandBuffer.BeginRenderPass</a> </dd></dl>

</div>
</div>
<a id="gaeb64f32b16e58d8fcfc1baf718975d3b" name="gaeb64f32b16e58d8fcfc1baf718975d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb64f32b16e58d8fcfc1baf718975d3b">&#9670;&#160;</a></span>GPUFence</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gaeb64f32b16e58d8fcfc1baf718975d3b">SDL::GPUFence</a> = typedef SDL_GPUFence</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gad610ad628240f1b49aaa7eaec0ccd271" title="Submits a command buffer so its commands can be processed on the GPU, and acquires a fence associated...">GPUCommandBuffer.SubmitAndAcquireFence</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga498070ef88a1e82416556cb7f1ef0e67" title="Checks the status of a fence.">GPUDevice.QueryFence</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga0f8ec966ab858d2d3ae91a1b6f61f420" title="Blocks the thread until the given fences are signaled.">GPUDevice.WaitForFences</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga63f199ccc1f91e8540c423b82555e186" title="Releases a fence obtained from GPUCommandBuffer.SubmitAndAcquireFence.">GPUDevice.ReleaseFence</a> </dd></dl>

</div>
</div>
<a id="ga55ba5426913cb519b5a736f91e5a36c7" name="ga55ba5426913cb519b5a736f91e5a36c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55ba5426913cb519b5a736f91e5a36c7">&#9670;&#160;</a></span>GPUFillMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga55ba5426913cb519b5a736f91e5a36c7">SDL::GPUFillMode</a> = typedef SDL_GPUFillMode</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html#aa6c513650dc796f541138ec49883165e" title="Wraps GPUGraphicsPipeline.">GPUGraphicsPipeline.GPUGraphicsPipeline</a> </dd></dl>

</div>
</div>
<a id="gaf59e313ae6b3da6531b643e8ab9a4c62" name="gaf59e313ae6b3da6531b643e8ab9a4c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf59e313ae6b3da6531b643e8ab9a4c62">&#9670;&#160;</a></span>GPUFilter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gaf59e313ae6b3da6531b643e8ab9a4c62">SDL::GPUFilter</a> = typedef SDL_GPUFilter</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUSampler.html#ac8f316c904af2387d9aa05b6952bbf88" title="Wraps GPUSampler.">GPUSampler.GPUSampler</a> </dd></dl>

</div>
</div>
<a id="gae69a13df5715495d8e282f4ac2f1c2e0" name="gae69a13df5715495d8e282f4ac2f1c2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae69a13df5715495d8e282f4ac2f1c2e0">&#9670;&#160;</a></span>GPUFrontFace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gae69a13df5715495d8e282f4ac2f1c2e0">SDL::GPUFrontFace</a> = typedef SDL_GPUFrontFace</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html#aa6c513650dc796f541138ec49883165e" title="Wraps GPUGraphicsPipeline.">GPUGraphicsPipeline.GPUGraphicsPipeline</a> </dd></dl>

</div>
</div>
<a id="ga60d171e0d2bee691d934e2275b2bf23b" name="ga60d171e0d2bee691d934e2275b2bf23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60d171e0d2bee691d934e2275b2bf23b">&#9670;&#160;</a></span>GPUGraphicsPipelineCreateInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga60d171e0d2bee691d934e2275b2bf23b">SDL::GPUGraphicsPipelineCreateInfo</a> = typedef SDL_GPUGraphicsPipelineCreateInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html#aa6c513650dc796f541138ec49883165e" title="Wraps GPUGraphicsPipeline.">GPUGraphicsPipeline.GPUGraphicsPipeline</a> </dd>
<dd>
<a class="el" href="classSDL_1_1GPUShader.html" title="An opaque handle representing a compiled shader object.">GPUShader</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gaef63c13e265391ab25cca015821d03de" title="A structure specifying the parameters of a graphics pipeline vertex input state.">GPUVertexInputState</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gaa55e8850ba84241f691eec7b68c58bb3" title="Specifies the primitive topology of a graphics pipeline.">GPUPrimitiveType</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gadca1f8e35005fd7af36b7aa84e8d57c4" title="A structure specifying the parameters of the graphics pipeline rasterizer state.">GPURasterizerState</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga496f5b66ed2275b37fff29458ce51cf1" title="A structure specifying the parameters of the graphics pipeline multisample state.">GPUMultisampleState</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga013a5670075cbdd8696a60b8339eacba" title="A structure specifying the parameters of the graphics pipeline depth stencil state.">GPUDepthStencilState</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga2e000919fb7eb2049a72472a253094f8" title="A structure specifying the descriptions of render targets used in a graphics pipeline.">GPUGraphicsPipelineTargetInfo</a> </dd></dl>

</div>
</div>
<a id="ga2e000919fb7eb2049a72472a253094f8" name="ga2e000919fb7eb2049a72472a253094f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e000919fb7eb2049a72472a253094f8">&#9670;&#160;</a></span>GPUGraphicsPipelineTargetInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga2e000919fb7eb2049a72472a253094f8">SDL::GPUGraphicsPipelineTargetInfo</a> = typedef SDL_GPUGraphicsPipelineTargetInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga60d171e0d2bee691d934e2275b2bf23b" title="A structure specifying the parameters of a graphics pipeline state.">GPUGraphicsPipelineCreateInfo</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga37eabd1e9acff0106e7c203493274188" title="A structure specifying the parameters of color targets used in a graphics pipeline.">GPUColorTargetDescription</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc" title="Specifies the pixel format of a texture.">GPUTextureFormat</a> </dd></dl>

</div>
</div>
<a id="ga4accdcc2c5e4049b181bbb65585e588b" name="ga4accdcc2c5e4049b181bbb65585e588b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4accdcc2c5e4049b181bbb65585e588b">&#9670;&#160;</a></span>GPUIndexedIndirectDrawCommand</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga4accdcc2c5e4049b181bbb65585e588b">SDL::GPUIndexedIndirectDrawCommand</a> = typedef SDL_GPUIndexedIndirectDrawCommand</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Note that the <code>first_vertex</code> and <code>first_instance</code> parameters are NOT compatible with built-in vertex/instance ID variables in shaders (for example, SV_VertexID); GPU APIs and shader languages do not define these built-in variables consistently, so if your shader depends on them, the only way to keep behavior consistent and portable is to always pass 0 for the correlating parameter in the draw calls.</p>
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gafef162b6d49f6d172616026fbc1d5b37" title="Draws data using bound graphics state with an index buffer enabled and with draw parameters set from ...">GPURenderPass.DrawIndexedPrimitivesIndirect</a> </dd></dl>

</div>
</div>
<a id="gaec587594b432d13ab2ddd78ad77342a7" name="gaec587594b432d13ab2ddd78ad77342a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec587594b432d13ab2ddd78ad77342a7">&#9670;&#160;</a></span>GPUIndexElementSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gaec587594b432d13ab2ddd78ad77342a7">SDL::GPUIndexElementSize</a> = typedef SDL_GPUIndexElementSize</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html#aa6c513650dc796f541138ec49883165e" title="Wraps GPUGraphicsPipeline.">GPUGraphicsPipeline.GPUGraphicsPipeline</a> </dd></dl>

</div>
</div>
<a id="ga3e1ec8c5137a3d3142a5668ab76347a4" name="ga3e1ec8c5137a3d3142a5668ab76347a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e1ec8c5137a3d3142a5668ab76347a4">&#9670;&#160;</a></span>GPUIndirectDispatchCommand</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga3e1ec8c5137a3d3142a5668ab76347a4">SDL::GPUIndirectDispatchCommand</a> = typedef SDL_GPUIndirectDispatchCommand</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga5bd535fc79d0e38398d97b34f3640dd2" title="Dispatches compute work with parameters set from a buffer.">GPUComputePass.DispatchIndirect</a> </dd></dl>

</div>
</div>
<a id="gaf93a40deaafd77e9e29cee09c432c4c7" name="gaf93a40deaafd77e9e29cee09c432c4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf93a40deaafd77e9e29cee09c432c4c7">&#9670;&#160;</a></span>GPUIndirectDrawCommand</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gaf93a40deaafd77e9e29cee09c432c4c7">SDL::GPUIndirectDrawCommand</a> = typedef SDL_GPUIndirectDrawCommand</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Note that the <code>first_vertex</code> and <code>first_instance</code> parameters are NOT compatible with built-in vertex/instance ID variables in shaders (for example, SV_VertexID); GPU APIs and shader languages do not define these built-in variables consistently, so if your shader depends on them, the only way to keep behavior consistent and portable is to always pass 0 for the correlating parameter in the draw calls.</p>
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga4cad31422505ada85f19d81536dfe3d9" title="Draws data using bound graphics state and with draw parameters set from a buffer.">GPURenderPass.DrawPrimitivesIndirect</a> </dd></dl>

</div>
</div>
<a id="gaf5682b03e950adda302469fb07485f2a" name="gaf5682b03e950adda302469fb07485f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5682b03e950adda302469fb07485f2a">&#9670;&#160;</a></span>GPULoadOp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gaf5682b03e950adda302469fb07485f2a">SDL::GPULoadOp</a> = typedef SDL_GPULoadOp</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gaf954393ca11e67b26e5ab32b5c85a56e" title="Begins a render pass on a command buffer.">GPUCommandBuffer.BeginRenderPass</a> </dd></dl>

</div>
</div>
<a id="ga496f5b66ed2275b37fff29458ce51cf1" name="ga496f5b66ed2275b37fff29458ce51cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga496f5b66ed2275b37fff29458ce51cf1">&#9670;&#160;</a></span>GPUMultisampleState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga496f5b66ed2275b37fff29458ce51cf1">SDL::GPUMultisampleState</a> = typedef SDL_GPUMultisampleState</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga60d171e0d2bee691d934e2275b2bf23b" title="A structure specifying the parameters of a graphics pipeline state.">GPUGraphicsPipelineCreateInfo</a> </dd></dl>

</div>
</div>
<a id="ga695f2e29e8b1cc9061a08a95ae9690e5" name="ga695f2e29e8b1cc9061a08a95ae9690e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga695f2e29e8b1cc9061a08a95ae9690e5">&#9670;&#160;</a></span>GPUPresentMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga695f2e29e8b1cc9061a08a95ae9690e5">SDL::GPUPresentMode</a> = typedef SDL_GPUPresentMode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VSYNC mode will always be supported. IMMEDIATE and MAILBOX modes may not be supported on certain systems.</p>
<p>It is recommended to query <a class="el" href="group__CategoryGPU.html#gaeb189dcc6f70c6584763e72987ad1ec5" title="Determines whether a presentation mode is supported by the window.">GPUDevice.WindowSupportsPresentMode</a> after claiming the window if you wish to change the present mode to IMMEDIATE or MAILBOX.</p>
<ul>
<li>VSYNC: Waits for vblank before presenting. No tearing is possible. If there is a pending image to present, the new image is enqueued for presentation. Disallows tearing at the cost of visual latency.</li>
<li>IMMEDIATE: Immediately presents. Lowest latency option, but tearing may occur.</li>
<li>MAILBOX: Waits for vblank before presenting. No tearing is possible. If there is a pending image to present, the pending image is replaced by the new image. Similar to VSYNC, but with reduced visual latency.</li>
</ul>
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga8d862f6cb8aee49dcac4907349d9a186" title="Changes the swapchain parameters for the given claimed window.">GPUDevice.SetSwapchainParameters</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gaeb189dcc6f70c6584763e72987ad1ec5" title="Determines whether a presentation mode is supported by the window.">GPUDevice.WindowSupportsPresentMode</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gae4234ed0ab6264374493b9b6cb07c770" title="Blocks the thread until a swapchain texture is available to be acquired, and then acquires it.">GPUCommandBuffer.WaitAndAcquireSwapchainTexture</a> </dd></dl>

</div>
</div>
<a id="gaa55e8850ba84241f691eec7b68c58bb3" name="gaa55e8850ba84241f691eec7b68c58bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa55e8850ba84241f691eec7b68c58bb3">&#9670;&#160;</a></span>GPUPrimitiveType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gaa55e8850ba84241f691eec7b68c58bb3">SDL::GPUPrimitiveType</a> = typedef SDL_GPUPrimitiveType</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If you are using POINTLIST you must include a point size output in the vertex shader.</p>
<ul>
<li>For HLSL compiling to SPIRV you must decorate a float output with [[vk::builtin("PointSize")]].</li>
<li>For GLSL you must set the gl_PointSize builtin.</li>
<li>For MSL you must include a float output with the [[point_size]] decorator.</li>
</ul>
<p>Note that sized point topology is totally unsupported on D3D12. Any size other than 1 will be ignored. In general, you should avoid using point topology for both compatibility and performance reasons. You WILL regret using it.</p>
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html#aa6c513650dc796f541138ec49883165e" title="Wraps GPUGraphicsPipeline.">GPUGraphicsPipeline.GPUGraphicsPipeline</a> </dd></dl>

</div>
</div>
<a id="gadca1f8e35005fd7af36b7aa84e8d57c4" name="gadca1f8e35005fd7af36b7aa84e8d57c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadca1f8e35005fd7af36b7aa84e8d57c4">&#9670;&#160;</a></span>GPURasterizerState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gadca1f8e35005fd7af36b7aa84e8d57c4">SDL::GPURasterizerState</a> = typedef SDL_GPURasterizerState</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Note that GPU_FILLMODE_LINE is not supported on many Android devices. For those devices, the fill mode will automatically fall back to FILL.</p>
<p>Also note that the D3D12 driver will enable depth clamping even if enable_depth_clip is true. If you need this clamp+clip behavior, consider enabling depth clip and then manually clamping depth in your fragment shaders on Metal and Vulkan.</p>
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga60d171e0d2bee691d934e2275b2bf23b" title="A structure specifying the parameters of a graphics pipeline state.">GPUGraphicsPipelineCreateInfo</a> </dd></dl>

</div>
</div>
<a id="ga5265d3385d1ddc106c614016bee759d9" name="ga5265d3385d1ddc106c614016bee759d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5265d3385d1ddc106c614016bee759d9">&#9670;&#160;</a></span>GPUSampleCount</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga5265d3385d1ddc106c614016bee759d9">SDL::GPUSampleCount</a> = typedef SDL_GPUSampleCount</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used in multisampling. Note that this value only applies when the texture is used as a render target.</p>
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUTexture.html#a275899ad3f4afee497cd31161f61cffa" title="Wraps GPUTexture.">GPUTexture.GPUTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gac85fa5adda9fa49df12b8a85f98e67a9" title="Determines if a sample count for a texture format is supported.">GPUDevice.TextureSupportsSampleCount</a> </dd></dl>

</div>
</div>
<a id="gae26794f6b687f9799cba905967796a0a" name="gae26794f6b687f9799cba905967796a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae26794f6b687f9799cba905967796a0a">&#9670;&#160;</a></span>GPUSamplerAddressMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gae26794f6b687f9799cba905967796a0a">SDL::GPUSamplerAddressMode</a> = typedef SDL_GPUSamplerAddressMode</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUSampler.html#ac8f316c904af2387d9aa05b6952bbf88" title="Wraps GPUSampler.">GPUSampler.GPUSampler</a> </dd></dl>

</div>
</div>
<a id="ga9905b04780e8798c8cd2bf18a29bff27" name="ga9905b04780e8798c8cd2bf18a29bff27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9905b04780e8798c8cd2bf18a29bff27">&#9670;&#160;</a></span>GPUSamplerCreateInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga9905b04780e8798c8cd2bf18a29bff27">SDL::GPUSamplerCreateInfo</a> = typedef SDL_GPUSamplerCreateInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Note that mip_lod_bias is a no-op for the Metal driver. For Metal, LOD bias must be applied via shader instead.</p>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUSampler.html#ac8f316c904af2387d9aa05b6952bbf88" title="Wraps GPUSampler.">GPUSampler.GPUSampler</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gaf59e313ae6b3da6531b643e8ab9a4c62" title="Specifies a filter operation used by a sampler.">GPUFilter</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga5f58e9e7f4f148b25f3e0f839081615f" title="Specifies a mipmap mode used by a sampler.">GPUSamplerMipmapMode</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gae26794f6b687f9799cba905967796a0a" title="Specifies behavior of texture sampling when the coordinates exceed the 0-1 range.">GPUSamplerAddressMode</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga27b1a00730534d4ce7ac51f63874cfc7" title="Specifies a comparison operator for depth, stencil and sampler operations.">GPUCompareOp</a> </dd></dl>

</div>
</div>
<a id="ga5f58e9e7f4f148b25f3e0f839081615f" name="ga5f58e9e7f4f148b25f3e0f839081615f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f58e9e7f4f148b25f3e0f839081615f">&#9670;&#160;</a></span>GPUSamplerMipmapMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga5f58e9e7f4f148b25f3e0f839081615f">SDL::GPUSamplerMipmapMode</a> = typedef SDL_GPUSamplerMipmapMode</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUSampler.html#ac8f316c904af2387d9aa05b6952bbf88" title="Wraps GPUSampler.">GPUSampler.GPUSampler</a> </dd></dl>

</div>
</div>
<a id="gaec6e01546fef70020c8f7b44da82be99" name="gaec6e01546fef70020c8f7b44da82be99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec6e01546fef70020c8f7b44da82be99">&#9670;&#160;</a></span>GPUShaderCreateInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gaec6e01546fef70020c8f7b44da82be99">SDL::GPUShaderCreateInfo</a> = typedef SDL_GPUShaderCreateInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd></dl>

</div>
</div>
<a id="ga6257b71ec0a6c6cfa147db1ee7f0cc2c" name="ga6257b71ec0a6c6cfa147db1ee7f0cc2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">&#9670;&#160;</a></span>GPUShaderFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">SDL::GPUShaderFormat</a> = typedef <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each format corresponds to a specific backend that accepts it.</p>
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd></dl>

</div>
</div>
<a id="ga5dbe4dbc43d67929db39c145ccaa5e20" name="ga5dbe4dbc43d67929db39c145ccaa5e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dbe4dbc43d67929db39c145ccaa5e20">&#9670;&#160;</a></span>GPUShaderStage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga5dbe4dbc43d67929db39c145ccaa5e20">SDL::GPUShaderStage</a> = typedef SDL_GPUShaderStage</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd></dl>

</div>
</div>
<a id="gaead0310f70b17c2bc2f92dab7646c96a" name="gaead0310f70b17c2bc2f92dab7646c96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaead0310f70b17c2bc2f92dab7646c96a">&#9670;&#160;</a></span>GPUStencilOp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gaead0310f70b17c2bc2f92dab7646c96a">SDL::GPUStencilOp</a> = typedef SDL_GPUStencilOp</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html#aa6c513650dc796f541138ec49883165e" title="Wraps GPUGraphicsPipeline.">GPUGraphicsPipeline.GPUGraphicsPipeline</a> </dd></dl>

</div>
</div>
<a id="ga7d73c0cd03157b033817c619ae2247a0" name="ga7d73c0cd03157b033817c619ae2247a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d73c0cd03157b033817c619ae2247a0">&#9670;&#160;</a></span>GPUStencilOpState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga7d73c0cd03157b033817c619ae2247a0">SDL::GPUStencilOpState</a> = typedef SDL_GPUStencilOpState</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga013a5670075cbdd8696a60b8339eacba" title="A structure specifying the parameters of the graphics pipeline depth stencil state.">GPUDepthStencilState</a> </dd></dl>

</div>
</div>
<a id="gad1bd097ca5ba900d062e99162e62ab2c" name="gad1bd097ca5ba900d062e99162e62ab2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1bd097ca5ba900d062e99162e62ab2c">&#9670;&#160;</a></span>GPUStorageBufferReadWriteBinding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gad1bd097ca5ba900d062e99162e62ab2c">SDL::GPUStorageBufferReadWriteBinding</a> = typedef SDL_GPUStorageBufferReadWriteBinding</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga94a40eb89d9af8a06054a029bcc92dc7" title="Begins a compute pass on a command buffer.">GPUCommandBuffer.BeginComputePass</a> </dd></dl>

</div>
</div>
<a id="gaa4da71fb9f200b3a944c027d10c42675" name="gaa4da71fb9f200b3a944c027d10c42675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4da71fb9f200b3a944c027d10c42675">&#9670;&#160;</a></span>GPUStorageTextureReadWriteBinding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gaa4da71fb9f200b3a944c027d10c42675">SDL::GPUStorageTextureReadWriteBinding</a> = typedef SDL_GPUStorageTextureReadWriteBinding</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga94a40eb89d9af8a06054a029bcc92dc7" title="Begins a compute pass on a command buffer.">GPUCommandBuffer.BeginComputePass</a> </dd></dl>

</div>
</div>
<a id="gaace1f8aa9176f849a325dee8d65046f4" name="gaace1f8aa9176f849a325dee8d65046f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaace1f8aa9176f849a325dee8d65046f4">&#9670;&#160;</a></span>GPUStoreOp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gaace1f8aa9176f849a325dee8d65046f4">SDL::GPUStoreOp</a> = typedef SDL_GPUStoreOp</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gaf954393ca11e67b26e5ab32b5c85a56e" title="Begins a render pass on a command buffer.">GPUCommandBuffer.BeginRenderPass</a> </dd></dl>

</div>
</div>
<a id="gaa555f571dd4b1b9e5af82ee607a71fc5" name="gaa555f571dd4b1b9e5af82ee607a71fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa555f571dd4b1b9e5af82ee607a71fc5">&#9670;&#160;</a></span>GPUSwapchainComposition</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gaa555f571dd4b1b9e5af82ee607a71fc5">SDL::GPUSwapchainComposition</a> = typedef SDL_GPUSwapchainComposition</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SDR will always be supported. Other compositions may not be supported on certain systems.</p>
<p>It is recommended to query <a class="el" href="group__CategoryGPU.html#ga80eb2cbcd952006b3f129cbd6ebe44c7" title="Determines whether a swapchain composition is supported by the window.">GPUDevice.WindowSupportsSwapchainComposition</a> after claiming the window if you wish to change the swapchain composition from SDR.</p>
<ul>
<li>SDR: B8G8R8A8 or R8G8B8A8 swapchain. Pixel values are in sRGB encoding.</li>
<li>SDR_LINEAR: B8G8R8A8_SRGB or R8G8B8A8_SRGB swapchain. Pixel values are stored in memory in sRGB encoding but accessed in shaders in "linear
  sRGB" encoding which is sRGB but with a linear transfer function.</li>
<li>HDR_EXTENDED_LINEAR: R16G16B16A16_FLOAT swapchain. Pixel values are in extended linear sRGB encoding and permits values outside of the [0, 1] range.</li>
<li>HDR10_ST2084: A2R10G10B10 or A2B10G10R10 swapchain. Pixel values are in BT.2020 ST2084 (PQ) encoding.</li>
</ul>
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga8d862f6cb8aee49dcac4907349d9a186" title="Changes the swapchain parameters for the given claimed window.">GPUDevice.SetSwapchainParameters</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga80eb2cbcd952006b3f129cbd6ebe44c7" title="Determines whether a swapchain composition is supported by the window.">GPUDevice.WindowSupportsSwapchainComposition</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gae4234ed0ab6264374493b9b6cb07c770" title="Blocks the thread until a swapchain texture is available to be acquired, and then acquires it.">GPUCommandBuffer.WaitAndAcquireSwapchainTexture</a> </dd></dl>

</div>
</div>
<a id="ga87fcb53cd9c731a4a4f3c7c10a5edb6a" name="ga87fcb53cd9c731a4a4f3c7c10a5edb6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87fcb53cd9c731a4a4f3c7c10a5edb6a">&#9670;&#160;</a></span>GPUTextureCreateInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga87fcb53cd9c731a4a4f3c7c10a5edb6a">SDL::GPUTextureCreateInfo</a> = typedef SDL_GPUTextureCreateInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Usage flags can be bitwise OR'd together for combinations of usages. Note that certain usage combinations are invalid, for example SAMPLER and GRAPHICS_STORAGE.</p>
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUTexture.html#a275899ad3f4afee497cd31161f61cffa" title="Wraps GPUTexture.">GPUTexture.GPUTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga624b29173aac1a009aa85c14f46024a3" title="Specifies the type of a texture.">GPUTextureType</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc" title="Specifies the pixel format of a texture.">GPUTextureFormat</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga5a847c301baaf527c8ba644f0f55a59e" title="Specifies how a texture is intended to be used by the client.">GPUTextureUsageFlags</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga5265d3385d1ddc106c614016bee759d9" title="Specifies the sample count of a texture.">GPUSampleCount</a> </dd></dl>

</div>
</div>
<a id="gac38f30d58087639f21fb55594e935cbc" name="gac38f30d58087639f21fb55594e935cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac38f30d58087639f21fb55594e935cbc">&#9670;&#160;</a></span>GPUTextureFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">SDL::GPUTextureFormat</a> = typedef SDL_GPUTextureFormat</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1Texture.html" title="An efficient driver-specific representation of pixel data.">Texture</a> format support varies depending on driver, hardware, and usage flags. In general, you should use <a class="el" href="group__CategoryGPU.html#ga24dbdaadc509ba8acd1fb2689449c133" title="Determines whether a texture format is supported for a given type and usage.">GPUDevice.TextureSupportsFormat</a> to query if a format is supported before using it. However, there are a few guaranteed formats.</p>
<p>FIXME: Check universal support for 32-bit component formats FIXME: Check universal support for SIMULTANEOUS_READ_WRITE</p>
<p>For SAMPLER usage, the following formats are universally supported:</p>
<ul>
<li>R8G8B8A8_UNORM</li>
<li>B8G8R8A8_UNORM</li>
<li>R8_UNORM</li>
<li>R8_SNORM</li>
<li>R8G8_UNORM</li>
<li>R8G8_SNORM</li>
<li>R8G8B8A8_SNORM</li>
<li>R16_FLOAT</li>
<li>R16G16_FLOAT</li>
<li>R16G16B16A16_FLOAT</li>
<li>R32_FLOAT</li>
<li>R32G32_FLOAT</li>
<li>R32G32B32A32_FLOAT</li>
<li>R11G11B10_UFLOAT</li>
<li>R8G8B8A8_UNORM_SRGB</li>
<li>B8G8R8A8_UNORM_SRGB</li>
<li>D16_UNORM</li>
</ul>
<p>For COLOR_TARGET usage, the following formats are universally supported:</p>
<ul>
<li>R8G8B8A8_UNORM</li>
<li>B8G8R8A8_UNORM</li>
<li>R8_UNORM</li>
<li>R16_FLOAT</li>
<li>R16G16_FLOAT</li>
<li>R16G16B16A16_FLOAT</li>
<li>R32_FLOAT</li>
<li>R32G32_FLOAT</li>
<li>R32G32B32A32_FLOAT</li>
<li>R8_UINT</li>
<li>R8G8_UINT</li>
<li>R8G8B8A8_UINT</li>
<li>R16_UINT</li>
<li>R16G16_UINT</li>
<li>R16G16B16A16_UINT</li>
<li>R8_INT</li>
<li>R8G8_INT</li>
<li>R8G8B8A8_INT</li>
<li>R16_INT</li>
<li>R16G16_INT</li>
<li>R16G16B16A16_INT</li>
<li>R8G8B8A8_UNORM_SRGB</li>
<li>B8G8R8A8_UNORM_SRGB</li>
</ul>
<p>For STORAGE usages, the following formats are universally supported:</p>
<ul>
<li>R8G8B8A8_UNORM</li>
<li>R8G8B8A8_SNORM</li>
<li>R16G16B16A16_FLOAT</li>
<li>R32_FLOAT</li>
<li>R32G32_FLOAT</li>
<li>R32G32B32A32_FLOAT</li>
<li>R8G8B8A8_UINT</li>
<li>R16G16B16A16_UINT</li>
<li>R8G8B8A8_INT</li>
<li>R16G16B16A16_INT</li>
</ul>
<p>For DEPTH_STENCIL_TARGET usage, the following formats are universally supported:</p>
<ul>
<li>D16_UNORM</li>
<li>Either (but not necessarily both!) D24_UNORM or D32_FLOAT</li>
<li>Either (but not necessarily both!) D24_UNORM_S8_UINT or D32_FLOAT_S8_UINT</li>
</ul>
<p>Unless D16_UNORM is sufficient for your purposes, always check which of D24/D32 is supported before creating a depth-stencil texture!</p>
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUTexture.html#a275899ad3f4afee497cd31161f61cffa" title="Wraps GPUTexture.">GPUTexture.GPUTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga24dbdaadc509ba8acd1fb2689449c133" title="Determines whether a texture format is supported for a given type and usage.">GPUDevice.TextureSupportsFormat</a> </dd></dl>

</div>
</div>
<a id="ga5dac1b3fb8a5a1ba34f6d99b84e81792" name="ga5dac1b3fb8a5a1ba34f6d99b84e81792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dac1b3fb8a5a1ba34f6d99b84e81792">&#9670;&#160;</a></span>GPUTextureLocation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga5dac1b3fb8a5a1ba34f6d99b84e81792">SDL::GPUTextureLocation</a> = typedef SDL_GPUTextureLocation</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used when copying data from one texture to another.</p>
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga6c2b51e6d7a0d50b15a4a899f672b1cf" title="Performs a texture-to-texture copy.">GPUCopyPass.CopyTextureToTexture</a> </dd></dl>

</div>
</div>
<a id="ga0a4272ec9f67111e0956cfe1f999f903" name="ga0a4272ec9f67111e0956cfe1f999f903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a4272ec9f67111e0956cfe1f999f903">&#9670;&#160;</a></span>GPUTextureRegion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga0a4272ec9f67111e0956cfe1f999f903">SDL::GPUTextureRegion</a> = typedef SDL_GPUTextureRegion</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used when transferring data to or from a texture.</p>
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gab5b7ed8fb63a9d190521a0618214b2c2" title="Uploads data from a transfer buffer to a texture.">GPUCopyPass.UploadToTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga350647db0f6c39ab4556bc767eb9da69" title="Copies data from a texture to a transfer buffer on the GPU timeline.">GPUCopyPass.DownloadFromTexture</a> </dd>
<dd>
<a class="el" href="classSDL_1_1GPUTexture.html#a275899ad3f4afee497cd31161f61cffa" title="Wraps GPUTexture.">GPUTexture.GPUTexture</a> </dd></dl>

</div>
</div>
<a id="ga86e968acd12b623cb7b5056c323285b3" name="ga86e968acd12b623cb7b5056c323285b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86e968acd12b623cb7b5056c323285b3">&#9670;&#160;</a></span>GPUTextureSamplerBinding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga86e968acd12b623cb7b5056c323285b3">SDL::GPUTextureSamplerBinding</a> = typedef SDL_GPUTextureSamplerBinding</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga4ca101f553e4044b77d14c04f50d96ff" title="Binds texture-sampler pairs for use on the vertex shader.">GPURenderPass.BindVertexSamplers</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga3566cec8f39f95f37f2f7c66653c4c55" title="Binds texture-sampler pairs for use on the fragment shader.">GPURenderPass.BindFragmentSamplers</a> </dd></dl>

</div>
</div>
<a id="ga62c3161f89c494e71fef4b8bbd471167" name="ga62c3161f89c494e71fef4b8bbd471167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62c3161f89c494e71fef4b8bbd471167">&#9670;&#160;</a></span>GPUTextureTransferInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga62c3161f89c494e71fef4b8bbd471167">SDL::GPUTextureTransferInfo</a> = typedef SDL_GPUTextureTransferInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gab5b7ed8fb63a9d190521a0618214b2c2" title="Uploads data from a transfer buffer to a texture.">GPUCopyPass.UploadToTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga350647db0f6c39ab4556bc767eb9da69" title="Copies data from a texture to a transfer buffer on the GPU timeline.">GPUCopyPass.DownloadFromTexture</a> </dd></dl>

</div>
</div>
<a id="ga624b29173aac1a009aa85c14f46024a3" name="ga624b29173aac1a009aa85c14f46024a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga624b29173aac1a009aa85c14f46024a3">&#9670;&#160;</a></span>GPUTextureType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga624b29173aac1a009aa85c14f46024a3">SDL::GPUTextureType</a> = typedef SDL_GPUTextureType</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUTexture.html#a275899ad3f4afee497cd31161f61cffa" title="Wraps GPUTexture.">GPUTexture.GPUTexture</a> </dd></dl>

</div>
</div>
<a id="ga5a847c301baaf527c8ba644f0f55a59e" name="ga5a847c301baaf527c8ba644f0f55a59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a847c301baaf527c8ba644f0f55a59e">&#9670;&#160;</a></span>GPUTextureUsageFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga5a847c301baaf527c8ba644f0f55a59e">SDL::GPUTextureUsageFlags</a> = typedef <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A texture must have at least one usage flag. Note that some usage flag combinations are invalid.</p>
<p>With regards to compute storage usage, READ | WRITE means that you can have shader A that only writes into the texture and shader B that only reads from the texture and bind the same texture to either shader respectively. SIMULTANEOUS means that you can do reads and writes within the same shader or compute pass. It also implies that atomic ops can be used, since those are read-modify-write operations. If you use SIMULTANEOUS, you are responsible for avoiding data races, as there is no data synchronization within a compute pass. Note that SIMULTANEOUS usage is only supported by a limited number of texture formats.</p>
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUTexture.html#a275899ad3f4afee497cd31161f61cffa" title="Wraps GPUTexture.">GPUTexture.GPUTexture</a> </dd></dl>

</div>
</div>
<a id="gabf392df5f8790bf73f828ca3e1f21bd5" name="gabf392df5f8790bf73f828ca3e1f21bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf392df5f8790bf73f828ca3e1f21bd5">&#9670;&#160;</a></span>GPUTransferBufferCreateInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gabf392df5f8790bf73f828ca3e1f21bd5">SDL::GPUTransferBufferCreateInfo</a> = typedef SDL_GPUTransferBufferCreateInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUTransferBuffer.html#a22aa8fd80d1188a63bab8b0a835e63b7" title="Wraps GPUTransferBuffer.">GPUTransferBuffer.GPUTransferBuffer</a> </dd></dl>

</div>
</div>
<a id="ga9faa5600aabe5cabf35cbdf09851af6d" name="ga9faa5600aabe5cabf35cbdf09851af6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9faa5600aabe5cabf35cbdf09851af6d">&#9670;&#160;</a></span>GPUTransferBufferLocation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga9faa5600aabe5cabf35cbdf09851af6d">SDL::GPUTransferBufferLocation</a> = typedef SDL_GPUTransferBufferLocation</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used when transferring buffer data to or from a transfer buffer.</p>
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga49c5fe1ce14d954d818e0510c7ee875c" title="Uploads data from a transfer buffer to a buffer.">GPUCopyPass.UploadToBuffer</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gacc93df1d338fafc2aedb4216f299a34e" title="Copies data from a buffer to a transfer buffer on the GPU timeline.">GPUCopyPass.DownloadFromBuffer</a> </dd></dl>

</div>
</div>
<a id="gaa77f5c65445135e6df84bda3201c49db" name="gaa77f5c65445135e6df84bda3201c49db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa77f5c65445135e6df84bda3201c49db">&#9670;&#160;</a></span>GPUTransferBufferUsage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gaa77f5c65445135e6df84bda3201c49db">SDL::GPUTransferBufferUsage</a> = typedef SDL_GPUTransferBufferUsage</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Note that mapping and copying FROM an upload transfer buffer or TO a download transfer buffer is undefined behavior.</p>
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUTransferBuffer.html#a22aa8fd80d1188a63bab8b0a835e63b7" title="Wraps GPUTransferBuffer.">GPUTransferBuffer.GPUTransferBuffer</a> </dd></dl>

</div>
</div>
<a id="ga0dec8e1717cdae085c3f74c9a17b66ef" name="ga0dec8e1717cdae085c3f74c9a17b66ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dec8e1717cdae085c3f74c9a17b66ef">&#9670;&#160;</a></span>GPUVertexAttribute</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga0dec8e1717cdae085c3f74c9a17b66ef">SDL::GPUVertexAttribute</a> = typedef SDL_GPUVertexAttribute</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>All vertex attribute locations provided to an GPUVertexInputState must be unique.</p>
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga408662b71e44e86d3382fa1c1c9640bc" title="A structure specifying the parameters of vertex buffers used in a graphics pipeline.">GPUVertexBufferDescription</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gaef63c13e265391ab25cca015821d03de" title="A structure specifying the parameters of a graphics pipeline vertex input state.">GPUVertexInputState</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d" title="Specifies the format of a vertex attribute.">GPUVertexElementFormat</a> </dd></dl>

</div>
</div>
<a id="ga408662b71e44e86d3382fa1c1c9640bc" name="ga408662b71e44e86d3382fa1c1c9640bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga408662b71e44e86d3382fa1c1c9640bc">&#9670;&#160;</a></span>GPUVertexBufferDescription</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga408662b71e44e86d3382fa1c1c9640bc">SDL::GPUVertexBufferDescription</a> = typedef SDL_GPUVertexBufferDescription</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When you call <a class="el" href="group__CategoryGPU.html#ga92908a319a7f02815bda65d27d1dcbfc" title="Binds vertex buffers on a command buffer for use with subsequent draw calls.">GPURenderPass.BindVertexBuffers</a>, you specify the binding slots of the vertex buffers. For example if you called <a class="el" href="group__CategoryGPU.html#ga92908a319a7f02815bda65d27d1dcbfc" title="Binds vertex buffers on a command buffer for use with subsequent draw calls.">GPURenderPass.BindVertexBuffers</a> with a first_slot of 2 and num_bindings of 3, the binding slots 2, 3, 4 would be used by the vertex buffers you pass in.</p>
<p>Vertex attributes are linked to buffers via the buffer_slot field of GPUVertexAttribute. For example, if an attribute has a buffer_slot of 0, then that attribute belongs to the vertex buffer bound at slot 0.</p>
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga0dec8e1717cdae085c3f74c9a17b66ef" title="A structure specifying a vertex attribute.">GPUVertexAttribute</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gaf0c935ed3eb7b0a1f180472c021a91e3" title="Specifies the rate at which vertex attributes are pulled from buffers.">GPUVertexInputRate</a> </dd></dl>

</div>
</div>
<a id="ga7ee7085f0bec0d39da3df52edb34e29d" name="ga7ee7085f0bec0d39da3df52edb34e29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ee7085f0bec0d39da3df52edb34e29d">&#9670;&#160;</a></span>GPUVertexElementFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">SDL::GPUVertexElementFormat</a> = typedef SDL_GPUVertexElementFormat</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html#aa6c513650dc796f541138ec49883165e" title="Wraps GPUGraphicsPipeline.">GPUGraphicsPipeline.GPUGraphicsPipeline</a> </dd></dl>

</div>
</div>
<a id="gaf0c935ed3eb7b0a1f180472c021a91e3" name="gaf0c935ed3eb7b0a1f180472c021a91e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0c935ed3eb7b0a1f180472c021a91e3">&#9670;&#160;</a></span>GPUVertexInputRate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gaf0c935ed3eb7b0a1f180472c021a91e3">SDL::GPUVertexInputRate</a> = typedef SDL_GPUVertexInputRate</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html#aa6c513650dc796f541138ec49883165e" title="Wraps GPUGraphicsPipeline.">GPUGraphicsPipeline.GPUGraphicsPipeline</a> </dd></dl>

</div>
</div>
<a id="gaef63c13e265391ab25cca015821d03de" name="gaef63c13e265391ab25cca015821d03de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef63c13e265391ab25cca015821d03de">&#9670;&#160;</a></span>GPUVertexInputState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gaef63c13e265391ab25cca015821d03de">SDL::GPUVertexInputState</a> = typedef SDL_GPUVertexInputState</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga60d171e0d2bee691d934e2275b2bf23b" title="A structure specifying the parameters of a graphics pipeline state.">GPUGraphicsPipelineCreateInfo</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga408662b71e44e86d3382fa1c1c9640bc" title="A structure specifying the parameters of vertex buffers used in a graphics pipeline.">GPUVertexBufferDescription</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga0dec8e1717cdae085c3f74c9a17b66ef" title="A structure specifying a vertex attribute.">GPUVertexAttribute</a> </dd></dl>

</div>
</div>
<a id="gaf80d3281c271f2f02de8d8e14648fe20" name="gaf80d3281c271f2f02de8d8e14648fe20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf80d3281c271f2f02de8d8e14648fe20">&#9670;&#160;</a></span>GPUViewport</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryGPU.html#gaf80d3281c271f2f02de8d8e14648fe20">SDL::GPUViewport</a> = typedef SDL_GPUViewport</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga5dca24a164e094b5a9959e3e96872be1" title="Sets the current viewport state on a command buffer.">GPURenderPass.SetViewport</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3afecf456819388452c8af3797f84547" name="ga3afecf456819388452c8af3797f84547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3afecf456819388452c8af3797f84547">&#9670;&#160;</a></span>AcquireCommandBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a> SDL::GPUDevice::AcquireCommandBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This command buffer is managed by the implementation and should not be freed by the user. The command buffer may only be used on the thread it was acquired on. The command buffer should be submitted on the thread it was acquired on.</p>
<p>It is valid to acquire multiple command buffers on the same thread at once. In fact a common design pattern is to acquire two command buffers per frame where one is dedicated to render and compute passes and the other is dedicated to copy passes and other preparatory work such as generating mipmaps. Interleaving commands between the two command buffers reduces the total amount of passes overall which improves rendering performance.</p>
<dl class="section return"><dt>Returns</dt><dd>a command buffer, or nullptr on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga673e4e3d3bdfe9596fa05693cbde73b2" title="Submits a command buffer so its commands can be processed on the GPU.">GPUCommandBuffer.Submit</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gad610ad628240f1b49aaa7eaec0ccd271" title="Submits a command buffer so its commands can be processed on the GPU, and acquires a fence associated...">GPUCommandBuffer.SubmitAndAcquireFence</a> </dd></dl>

</div>
</div>
<a id="ga6b3a4de20ef99fcdac2269fca7b866ba" name="ga6b3a4de20ef99fcdac2269fca7b866ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b3a4de20ef99fcdac2269fca7b866ba">&#9670;&#160;</a></span>AcquireGPUCommandBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a> SDL::AcquireGPUCommandBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This command buffer is managed by the implementation and should not be freed by the user. The command buffer may only be used on the thread it was acquired on. The command buffer should be submitted on the thread it was acquired on.</p>
<p>It is valid to acquire multiple command buffers on the same thread at once. In fact a common design pattern is to acquire two command buffers per frame where one is dedicated to render and compute passes and the other is dedicated to copy passes and other preparatory work such as generating mipmaps. Interleaving commands between the two command buffers reduces the total amount of passes overall which improves rendering performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a command buffer, or nullptr on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga673e4e3d3bdfe9596fa05693cbde73b2" title="Submits a command buffer so its commands can be processed on the GPU.">GPUCommandBuffer.Submit</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gad610ad628240f1b49aaa7eaec0ccd271" title="Submits a command buffer so its commands can be processed on the GPU, and acquires a fence associated...">GPUCommandBuffer.SubmitAndAcquireFence</a> </dd></dl>

</div>
</div>
<a id="ga0e1aabbbf23f17368c09dfb4967ced9c" name="ga0e1aabbbf23f17368c09dfb4967ced9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e1aabbbf23f17368c09dfb4967ced9c">&#9670;&#160;</a></span>AcquireGPUSwapchainTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a> SDL::AcquireGPUSwapchainTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a>&#160;</td>
          <td class="paramname"><em>command_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a>&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> *&#160;</td>
          <td class="paramname"><em>swapchain_texture_width</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> *&#160;</td>
          <td class="paramname"><em>swapchain_texture_height</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When a swapchain texture is acquired on a command buffer, it will automatically be submitted for presentation when the command buffer is submitted. The swapchain texture should only be referenced by the command buffer used to acquire it.</p>
<p>This function will fill the swapchain texture handle with nullptr if too many frames are in flight. This is not an error.</p>
<p>If you use this function, it is possible to create a situation where many command buffers are allocated while the rendering context waits for the GPU to catch up, which will cause memory usage to grow. You should use <a class="el" href="group__CategoryGPU.html#gae4234ed0ab6264374493b9b6cb07c770" title="Blocks the thread until a swapchain texture is available to be acquired, and then acquires it.">GPUCommandBuffer.WaitAndAcquireSwapchainTexture()</a> unless you know what you are doing with timing.</p>
<p>The swapchain texture is managed by the implementation and must not be freed by the user. You MUST NOT call this function from any thread other than the one that created the window.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command_buffer</td><td>a command buffer. </td></tr>
    <tr><td class="paramname">window</td><td>a window that has been claimed. </td></tr>
    <tr><td class="paramname">swapchain_texture_width</td><td>a pointer filled in with the swapchain texture width, may be nullptr. </td></tr>
    <tr><td class="paramname">swapchain_texture_height</td><td>a pointer filled in with the swapchain texture height, may be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a swapchain texture handle. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called from the thread that created the window.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gacbc4104e7cefaaccaf221b4938dacdd9" title="Claims a window, creating a swapchain structure for it.">GPUDevice.ClaimWindow</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga673e4e3d3bdfe9596fa05693cbde73b2" title="Submits a command buffer so its commands can be processed on the GPU.">GPUCommandBuffer.Submit</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gad610ad628240f1b49aaa7eaec0ccd271" title="Submits a command buffer so its commands can be processed on the GPU, and acquires a fence associated...">GPUCommandBuffer.SubmitAndAcquireFence</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga3bfdeb35856182f070ef0a146a47997a" title="Cancels a command buffer.">GPUCommandBuffer.Cancel</a> </dd>
<dd>
<a class="el" href="classSDL_1_1Window.html#a8298b6de50606268917468cb0e074c3d" title="Get the size of a window&#39;s client area, in pixels.">Window.GetSizeInPixels</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga787c44fa9026ae09bf8a3d9deaebcde6" title="Blocks the thread until a swapchain texture is available to be acquired.">GPUDevice.WaitForSwapchain</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gae4234ed0ab6264374493b9b6cb07c770" title="Blocks the thread until a swapchain texture is available to be acquired, and then acquires it.">GPUCommandBuffer.WaitAndAcquireSwapchainTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga18c2598a4f6a749a04b5505520b70a0c" title="Configures the maximum allowed number of frames in flight.">GPUDevice.SetAllowedFramesInFlight</a> </dd></dl>

</div>
</div>
<a id="gaa9098e2e6b7139a3af4973e47b4f7d9e" name="gaa9098e2e6b7139a3af4973e47b4f7d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9098e2e6b7139a3af4973e47b4f7d9e">&#9670;&#160;</a></span>AcquireSwapchainTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a> SDL::GPUCommandBuffer::AcquireSwapchainTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a>&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> *&#160;</td>
          <td class="paramname"><em>swapchain_texture_width</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> *&#160;</td>
          <td class="paramname"><em>swapchain_texture_height</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When a swapchain texture is acquired on a command buffer, it will automatically be submitted for presentation when the command buffer is submitted. The swapchain texture should only be referenced by the command buffer used to acquire it.</p>
<p>This function will fill the swapchain texture handle with nullptr if too many frames are in flight. This is not an error.</p>
<p>If you use this function, it is possible to create a situation where many command buffers are allocated while the rendering context waits for the GPU to catch up, which will cause memory usage to grow. You should use <a class="el" href="group__CategoryGPU.html#gae4234ed0ab6264374493b9b6cb07c770" title="Blocks the thread until a swapchain texture is available to be acquired, and then acquires it.">GPUCommandBuffer.WaitAndAcquireSwapchainTexture()</a> unless you know what you are doing with timing.</p>
<p>The swapchain texture is managed by the implementation and must not be freed by the user. You MUST NOT call this function from any thread other than the one that created the window.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>a window that has been claimed. </td></tr>
    <tr><td class="paramname">swapchain_texture_width</td><td>a pointer filled in with the swapchain texture width, may be nullptr. </td></tr>
    <tr><td class="paramname">swapchain_texture_height</td><td>a pointer filled in with the swapchain texture height, may be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a swapchain texture handle. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called from the thread that created the window.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gacbc4104e7cefaaccaf221b4938dacdd9" title="Claims a window, creating a swapchain structure for it.">GPUDevice.ClaimWindow</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga673e4e3d3bdfe9596fa05693cbde73b2" title="Submits a command buffer so its commands can be processed on the GPU.">GPUCommandBuffer.Submit</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gad610ad628240f1b49aaa7eaec0ccd271" title="Submits a command buffer so its commands can be processed on the GPU, and acquires a fence associated...">GPUCommandBuffer.SubmitAndAcquireFence</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga3bfdeb35856182f070ef0a146a47997a" title="Cancels a command buffer.">GPUCommandBuffer.Cancel</a> </dd>
<dd>
<a class="el" href="classSDL_1_1Window.html#a8298b6de50606268917468cb0e074c3d" title="Get the size of a window&#39;s client area, in pixels.">Window.GetSizeInPixels</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga787c44fa9026ae09bf8a3d9deaebcde6" title="Blocks the thread until a swapchain texture is available to be acquired.">GPUDevice.WaitForSwapchain</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gae4234ed0ab6264374493b9b6cb07c770" title="Blocks the thread until a swapchain texture is available to be acquired, and then acquires it.">GPUCommandBuffer.WaitAndAcquireSwapchainTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga18c2598a4f6a749a04b5505520b70a0c" title="Configures the maximum allowed number of frames in flight.">GPUDevice.SetAllowedFramesInFlight</a> </dd></dl>

</div>
</div>
<a id="ga94a40eb89d9af8a06054a029bcc92dc7" name="ga94a40eb89d9af8a06054a029bcc92dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94a40eb89d9af8a06054a029bcc92dc7">&#9670;&#160;</a></span>BeginComputePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUComputePass.html">GPUComputePass</a> SDL::GPUCommandBuffer::BeginComputePass </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const <a class="el" href="group__CategoryGPU.html#gaa4da71fb9f200b3a944c027d10c42675">GPUStorageTextureReadWriteBinding</a> &gt;&#160;</td>
          <td class="paramname"><em>storage_texture_bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const <a class="el" href="group__CategoryGPU.html#gad1bd097ca5ba900d062e99162e62ab2c">GPUStorageBufferReadWriteBinding</a> &gt;&#160;</td>
          <td class="paramname"><em>storage_buffer_bindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A compute pass is defined by a set of texture subresources and buffers that may be written to by compute pipelines. These textures and buffers must have been created with the COMPUTE_STORAGE_WRITE bit or the COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the texture in the compute pass. All operations related to compute pipelines must take place inside of a compute pass. You must not begin another compute pass, or a render pass or copy pass before ending the compute pass.</p>
<p>A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT implicitly synchronized. This means you may cause data races by both reading and writing a resource region in a compute pass, or by writing multiple times to a resource region. If your compute work depends on reading the completed output from a previous dispatch, you MUST end the current compute pass and begin a new one before you can safely access the data. Otherwise you will receive unexpected results. Reading and writing a texture in the same compute pass is only supported by specific texture formats. Make sure you check the format support!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage_texture_bindings</td><td>an array of writeable storage texture binding structs. </td></tr>
    <tr><td class="paramname">storage_buffer_bindings</td><td>an array of writeable storage buffer binding structs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compute pass handle.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga7419495ee08e074491b534155cee2daf" title="Ends the current compute pass.">GPUComputePass.End</a> </dd></dl>

</div>
</div>
<a id="ga5260dd36b46eea0864c1dbd89c544df2" name="ga5260dd36b46eea0864c1dbd89c544df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5260dd36b46eea0864c1dbd89c544df2">&#9670;&#160;</a></span>BeginCopyPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUCopyPass.html">GPUCopyPass</a> SDL::GPUCommandBuffer::BeginCopyPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All operations related to copying to or from buffers or textures take place inside a copy pass. You must not begin another copy pass, or a render pass or compute pass before ending the copy pass.</p>
<dl class="section return"><dt>Returns</dt><dd>a copy pass handle.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga7c30db9796f7da21a958fecc86e14195" name="ga7c30db9796f7da21a958fecc86e14195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c30db9796f7da21a958fecc86e14195">&#9670;&#160;</a></span>BeginGPUComputePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUComputePass.html">GPUComputePass</a> SDL::BeginGPUComputePass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a>&#160;</td>
          <td class="paramname"><em>command_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const <a class="el" href="group__CategoryGPU.html#gaa4da71fb9f200b3a944c027d10c42675">GPUStorageTextureReadWriteBinding</a> &gt;&#160;</td>
          <td class="paramname"><em>storage_texture_bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const <a class="el" href="group__CategoryGPU.html#gad1bd097ca5ba900d062e99162e62ab2c">GPUStorageBufferReadWriteBinding</a> &gt;&#160;</td>
          <td class="paramname"><em>storage_buffer_bindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A compute pass is defined by a set of texture subresources and buffers that may be written to by compute pipelines. These textures and buffers must have been created with the COMPUTE_STORAGE_WRITE bit or the COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the texture in the compute pass. All operations related to compute pipelines must take place inside of a compute pass. You must not begin another compute pass, or a render pass or copy pass before ending the compute pass.</p>
<p>A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT implicitly synchronized. This means you may cause data races by both reading and writing a resource region in a compute pass, or by writing multiple times to a resource region. If your compute work depends on reading the completed output from a previous dispatch, you MUST end the current compute pass and begin a new one before you can safely access the data. Otherwise you will receive unexpected results. Reading and writing a texture in the same compute pass is only supported by specific texture formats. Make sure you check the format support!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command_buffer</td><td>a command buffer. </td></tr>
    <tr><td class="paramname">storage_texture_bindings</td><td>an array of writeable storage texture binding structs. </td></tr>
    <tr><td class="paramname">storage_buffer_bindings</td><td>an array of writeable storage buffer binding structs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compute pass handle.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga7419495ee08e074491b534155cee2daf" title="Ends the current compute pass.">GPUComputePass.End</a> </dd></dl>

</div>
</div>
<a id="gaf47189596f9ce0a1bfb7cf232a92d670" name="gaf47189596f9ce0a1bfb7cf232a92d670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf47189596f9ce0a1bfb7cf232a92d670">&#9670;&#160;</a></span>BeginGPUCopyPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUCopyPass.html">GPUCopyPass</a> SDL::BeginGPUCopyPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a>&#160;</td>
          <td class="paramname"><em>command_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All operations related to copying to or from buffers or textures take place inside a copy pass. You must not begin another copy pass, or a render pass or compute pass before ending the copy pass.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command_buffer</td><td>a command buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy pass handle.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga5564e25e15769a0ebe82cf21e45d46e3" name="ga5564e25e15769a0ebe82cf21e45d46e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5564e25e15769a0ebe82cf21e45d46e3">&#9670;&#160;</a></span>BeginGPURenderPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a> SDL::BeginGPURenderPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a>&#160;</td>
          <td class="paramname"><em>command_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const <a class="el" href="group__CategoryGPU.html#ga26904510dffa9db5b09c79637b00edbc">GPUColorTargetInfo</a> &gt;&#160;</td>
          <td class="paramname"><em>color_target_infos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga28e62eba4af4c55395ef3cecf7fc0ebc">GPUDepthStencilTargetInfo</a> &gt;&#160;</td>
          <td class="paramname"><em>depth_stencil_target_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A render pass consists of a set of texture subresources (or depth slices in the 3D texture case) which will be rendered to during the render pass, along with corresponding clear values and load/store operations. All operations related to graphics pipelines must take place inside of a render pass. A default viewport and scissor state are automatically set when this is called. You cannot begin another render pass, or begin a compute pass or copy pass until you have ended the render pass.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command_buffer</td><td>a command buffer. </td></tr>
    <tr><td class="paramname">color_target_infos</td><td>an array of texture subresources with corresponding clear values and load/store ops. </td></tr>
    <tr><td class="paramname">depth_stencil_target_info</td><td>a texture subresource with corresponding clear value and load/store ops, may be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a render pass handle.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga93da9193744c70e7d6334440a676b787" title="Ends the given render pass.">GPURenderPass.End</a> </dd></dl>

</div>
</div>
<a id="gaf954393ca11e67b26e5ab32b5c85a56e" name="gaf954393ca11e67b26e5ab32b5c85a56e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf954393ca11e67b26e5ab32b5c85a56e">&#9670;&#160;</a></span>BeginRenderPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a> SDL::GPUCommandBuffer::BeginRenderPass </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const <a class="el" href="group__CategoryGPU.html#ga26904510dffa9db5b09c79637b00edbc">GPUColorTargetInfo</a> &gt;&#160;</td>
          <td class="paramname"><em>color_target_infos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga28e62eba4af4c55395ef3cecf7fc0ebc">GPUDepthStencilTargetInfo</a> &gt;&#160;</td>
          <td class="paramname"><em>depth_stencil_target_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A render pass consists of a set of texture subresources (or depth slices in the 3D texture case) which will be rendered to during the render pass, along with corresponding clear values and load/store operations. All operations related to graphics pipelines must take place inside of a render pass. A default viewport and scissor state are automatically set when this is called. You cannot begin another render pass, or begin a compute pass or copy pass until you have ended the render pass.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color_target_infos</td><td>an array of texture subresources with corresponding clear values and load/store ops. </td></tr>
    <tr><td class="paramname">depth_stencil_target_info</td><td>a texture subresource with corresponding clear value and load/store ops, may be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a render pass handle.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga93da9193744c70e7d6334440a676b787" title="Ends the given render pass.">GPURenderPass.End</a> </dd></dl>

</div>
</div>
<a id="ga3566cec8f39f95f37f2f7c66653c4c55" name="ga3566cec8f39f95f37f2f7c66653c4c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3566cec8f39f95f37f2f7c66653c4c55">&#9670;&#160;</a></span>BindFragmentSamplers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPURenderPass::BindFragmentSamplers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const <a class="el" href="group__CategoryGPU.html#ga86e968acd12b623cb7b5056c323285b3">GPUTextureSamplerBinding</a> &gt;&#160;</td>
          <td class="paramname"><em>texture_sampler_bindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The textures must have been created with GPU_TEXTUREUSAGE_SAMPLER.</p>
<p>Be sure your shader is set up according to the requirements documented in <a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_slot</td><td>the fragment sampler slot to begin binding from. </td></tr>
    <tr><td class="paramname">texture_sampler_bindings</td><td>an array of texture-sampler binding structs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd></dl>

</div>
</div>
<a id="ga6908db6f33fe0605f2a4b9aa9bb23877" name="ga6908db6f33fe0605f2a4b9aa9bb23877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6908db6f33fe0605f2a4b9aa9bb23877">&#9670;&#160;</a></span>BindFragmentStorageBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPURenderPass::BindFragmentStorageBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga729f924587e663dffcd630a594e14396">GPUBufferRaw</a> &gt;&#160;</td>
          <td class="paramname"><em>storage_buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>These buffers must have been created with GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.</p>
<p>Be sure your shader is set up according to the requirements documented in <a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_slot</td><td>the fragment storage buffer slot to begin binding from. </td></tr>
    <tr><td class="paramname">storage_buffers</td><td>an array of storage buffers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd></dl>

</div>
</div>
<a id="ga4842b7086c6105187135bdc9526266c9" name="ga4842b7086c6105187135bdc9526266c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4842b7086c6105187135bdc9526266c9">&#9670;&#160;</a></span>BindFragmentStorageTextures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPURenderPass::BindFragmentStorageTextures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga07bab3d86cb28ae9761a1c91b04c285f">GPUTextureRaw</a> &gt;&#160;</td>
          <td class="paramname"><em>storage_textures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>These textures must have been created with GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.</p>
<p>Be sure your shader is set up according to the requirements documented in <a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_slot</td><td>the fragment storage texture slot to begin binding from. </td></tr>
    <tr><td class="paramname">storage_textures</td><td>an array of storage textures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd></dl>

</div>
</div>
<a id="ga686025dc203b1513e19bb87f1054a342" name="ga686025dc203b1513e19bb87f1054a342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga686025dc203b1513e19bb87f1054a342">&#9670;&#160;</a></span>BindGPUComputePipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::BindGPUComputePipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUComputePass.html">GPUComputePass</a>&#160;</td>
          <td class="paramname"><em>compute_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUComputePipeline.html">GPUComputePipeline</a>&#160;</td>
          <td class="paramname"><em>compute_pipeline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compute_pass</td><td>a compute pass handle. </td></tr>
    <tr><td class="paramname">compute_pipeline</td><td>a compute pipeline to bind.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaf2dc9da2b6bb45fafb44c8604325e111" name="gaf2dc9da2b6bb45fafb44c8604325e111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2dc9da2b6bb45fafb44c8604325e111">&#9670;&#160;</a></span>BindGPUComputeSamplers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::BindGPUComputeSamplers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUComputePass.html">GPUComputePass</a>&#160;</td>
          <td class="paramname"><em>compute_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const <a class="el" href="group__CategoryGPU.html#ga86e968acd12b623cb7b5056c323285b3">GPUTextureSamplerBinding</a> &gt;&#160;</td>
          <td class="paramname"><em>texture_sampler_bindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The textures must have been created with GPU_TEXTUREUSAGE_SAMPLER.</p>
<p>Be sure your shader is set up according to the requirements documented in <a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compute_pass</td><td>a compute pass handle. </td></tr>
    <tr><td class="paramname">first_slot</td><td>the compute sampler slot to begin binding from. </td></tr>
    <tr><td class="paramname">texture_sampler_bindings</td><td>an array of texture-sampler binding structs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd></dl>

</div>
</div>
<a id="gad82b45014282f06657afc76b7207f2c4" name="gad82b45014282f06657afc76b7207f2c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad82b45014282f06657afc76b7207f2c4">&#9670;&#160;</a></span>BindGPUComputeStorageBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::BindGPUComputeStorageBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUComputePass.html">GPUComputePass</a>&#160;</td>
          <td class="paramname"><em>compute_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga729f924587e663dffcd630a594e14396">GPUBufferRaw</a> &gt;&#160;</td>
          <td class="paramname"><em>storage_buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>These buffers must have been created with GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ.</p>
<p>Be sure your shader is set up according to the requirements documented in <a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compute_pass</td><td>a compute pass handle. </td></tr>
    <tr><td class="paramname">first_slot</td><td>the compute storage buffer slot to begin binding from. </td></tr>
    <tr><td class="paramname">storage_buffers</td><td>an array of storage buffer binding structs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd></dl>

</div>
</div>
<a id="gaf3eed8795d584b16141e9f7cfc1bdb5b" name="gaf3eed8795d584b16141e9f7cfc1bdb5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3eed8795d584b16141e9f7cfc1bdb5b">&#9670;&#160;</a></span>BindGPUComputeStorageTextures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::BindGPUComputeStorageTextures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUComputePass.html">GPUComputePass</a>&#160;</td>
          <td class="paramname"><em>compute_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga07bab3d86cb28ae9761a1c91b04c285f">GPUTextureRaw</a> &gt;&#160;</td>
          <td class="paramname"><em>storage_textures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>These textures must have been created with GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ.</p>
<p>Be sure your shader is set up according to the requirements documented in <a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compute_pass</td><td>a compute pass handle. </td></tr>
    <tr><td class="paramname">first_slot</td><td>the compute storage texture slot to begin binding from. </td></tr>
    <tr><td class="paramname">storage_textures</td><td>an array of storage textures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd></dl>

</div>
</div>
<a id="ga7c5cbf319a14dc8645cbb2f08a7b4e63" name="ga7c5cbf319a14dc8645cbb2f08a7b4e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c5cbf319a14dc8645cbb2f08a7b4e63">&#9670;&#160;</a></span>BindGPUFragmentSamplers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::BindGPUFragmentSamplers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a>&#160;</td>
          <td class="paramname"><em>render_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const <a class="el" href="group__CategoryGPU.html#ga86e968acd12b623cb7b5056c323285b3">GPUTextureSamplerBinding</a> &gt;&#160;</td>
          <td class="paramname"><em>texture_sampler_bindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The textures must have been created with GPU_TEXTUREUSAGE_SAMPLER.</p>
<p>Be sure your shader is set up according to the requirements documented in <a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">render_pass</td><td>a render pass handle. </td></tr>
    <tr><td class="paramname">first_slot</td><td>the fragment sampler slot to begin binding from. </td></tr>
    <tr><td class="paramname">texture_sampler_bindings</td><td>an array of texture-sampler binding structs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd></dl>

</div>
</div>
<a id="ga7848c8b3c8ef3a6a29a45e44b379a3e8" name="ga7848c8b3c8ef3a6a29a45e44b379a3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7848c8b3c8ef3a6a29a45e44b379a3e8">&#9670;&#160;</a></span>BindGPUFragmentStorageBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::BindGPUFragmentStorageBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a>&#160;</td>
          <td class="paramname"><em>render_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga729f924587e663dffcd630a594e14396">GPUBufferRaw</a> &gt;&#160;</td>
          <td class="paramname"><em>storage_buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>These buffers must have been created with GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.</p>
<p>Be sure your shader is set up according to the requirements documented in <a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">render_pass</td><td>a render pass handle. </td></tr>
    <tr><td class="paramname">first_slot</td><td>the fragment storage buffer slot to begin binding from. </td></tr>
    <tr><td class="paramname">storage_buffers</td><td>an array of storage buffers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd></dl>

</div>
</div>
<a id="ga0a54e6d56f4b59f954282b45cded7755" name="ga0a54e6d56f4b59f954282b45cded7755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a54e6d56f4b59f954282b45cded7755">&#9670;&#160;</a></span>BindGPUFragmentStorageTextures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::BindGPUFragmentStorageTextures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a>&#160;</td>
          <td class="paramname"><em>render_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga07bab3d86cb28ae9761a1c91b04c285f">GPUTextureRaw</a> &gt;&#160;</td>
          <td class="paramname"><em>storage_textures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>These textures must have been created with GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.</p>
<p>Be sure your shader is set up according to the requirements documented in <a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">render_pass</td><td>a render pass handle. </td></tr>
    <tr><td class="paramname">first_slot</td><td>the fragment storage texture slot to begin binding from. </td></tr>
    <tr><td class="paramname">storage_textures</td><td>an array of storage textures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd></dl>

</div>
</div>
<a id="gaacf3e7f9e1b9d6fe6ab45defe29619db" name="gaacf3e7f9e1b9d6fe6ab45defe29619db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacf3e7f9e1b9d6fe6ab45defe29619db">&#9670;&#160;</a></span>BindGPUGraphicsPipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::BindGPUGraphicsPipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a>&#160;</td>
          <td class="paramname"><em>render_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html">GPUGraphicsPipeline</a>&#160;</td>
          <td class="paramname"><em>graphics_pipeline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A graphics pipeline must be bound before making any draw calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">render_pass</td><td>a render pass handle. </td></tr>
    <tr><td class="paramname">graphics_pipeline</td><td>the graphics pipeline to bind.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga3612a1d963792f05f3ce2385334b346f" name="ga3612a1d963792f05f3ce2385334b346f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3612a1d963792f05f3ce2385334b346f">&#9670;&#160;</a></span>BindGPUIndexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::BindGPUIndexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a>&#160;</td>
          <td class="paramname"><em>render_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga698bbc29bd1e44bec1e2b87ce3a81dbb">GPUBufferBinding</a> &amp;&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#gaec587594b432d13ab2ddd78ad77342a7">GPUIndexElementSize</a>&#160;</td>
          <td class="paramname"><em>index_element_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">render_pass</td><td>a render pass handle. </td></tr>
    <tr><td class="paramname">binding</td><td>a pointer to a struct containing an index buffer and offset. </td></tr>
    <tr><td class="paramname">index_element_size</td><td>whether the index values in the buffer are 16- or 32-bit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaed8a93e9dec0a2ed731fc3bcb7f2a990" name="gaed8a93e9dec0a2ed731fc3bcb7f2a990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed8a93e9dec0a2ed731fc3bcb7f2a990">&#9670;&#160;</a></span>BindGPUVertexBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::BindGPUVertexBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a>&#160;</td>
          <td class="paramname"><em>render_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const <a class="el" href="group__CategoryGPU.html#ga698bbc29bd1e44bec1e2b87ce3a81dbb">GPUBufferBinding</a> &gt;&#160;</td>
          <td class="paramname"><em>bindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">render_pass</td><td>a render pass handle. </td></tr>
    <tr><td class="paramname">first_slot</td><td>the vertex buffer slot to begin binding from. </td></tr>
    <tr><td class="paramname">bindings</td><td>an array of GPUBufferBinding structs containing vertex buffers and offset values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga5a7be902e8ed2be091f44004c97e76f8" name="ga5a7be902e8ed2be091f44004c97e76f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a7be902e8ed2be091f44004c97e76f8">&#9670;&#160;</a></span>BindGPUVertexSamplers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::BindGPUVertexSamplers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a>&#160;</td>
          <td class="paramname"><em>render_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const <a class="el" href="group__CategoryGPU.html#ga86e968acd12b623cb7b5056c323285b3">GPUTextureSamplerBinding</a> &gt;&#160;</td>
          <td class="paramname"><em>texture_sampler_bindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The textures must have been created with GPU_TEXTUREUSAGE_SAMPLER.</p>
<p>Be sure your shader is set up according to the requirements documented in <a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">render_pass</td><td>a render pass handle. </td></tr>
    <tr><td class="paramname">first_slot</td><td>the vertex sampler slot to begin binding from. </td></tr>
    <tr><td class="paramname">texture_sampler_bindings</td><td>an array of texture-sampler binding structs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd></dl>

</div>
</div>
<a id="ga828298b19ad720a6c572b11eac29e9cf" name="ga828298b19ad720a6c572b11eac29e9cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga828298b19ad720a6c572b11eac29e9cf">&#9670;&#160;</a></span>BindGPUVertexStorageBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::BindGPUVertexStorageBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a>&#160;</td>
          <td class="paramname"><em>render_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga729f924587e663dffcd630a594e14396">GPUBufferRaw</a> &gt;&#160;</td>
          <td class="paramname"><em>storage_buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>These buffers must have been created with GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.</p>
<p>Be sure your shader is set up according to the requirements documented in <a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">render_pass</td><td>a render pass handle. </td></tr>
    <tr><td class="paramname">first_slot</td><td>the vertex storage buffer slot to begin binding from. </td></tr>
    <tr><td class="paramname">storage_buffers</td><td>an array of buffers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd></dl>

</div>
</div>
<a id="ga1ba65c65debea20e4b137379f47129d8" name="ga1ba65c65debea20e4b137379f47129d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ba65c65debea20e4b137379f47129d8">&#9670;&#160;</a></span>BindGPUVertexStorageTextures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::BindGPUVertexStorageTextures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a>&#160;</td>
          <td class="paramname"><em>render_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga07bab3d86cb28ae9761a1c91b04c285f">GPUTextureRaw</a> &gt;&#160;</td>
          <td class="paramname"><em>storage_textures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>These textures must have been created with GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.</p>
<p>Be sure your shader is set up according to the requirements documented in <a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">render_pass</td><td>a render pass handle. </td></tr>
    <tr><td class="paramname">first_slot</td><td>the vertex storage texture slot to begin binding from. </td></tr>
    <tr><td class="paramname">storage_textures</td><td>an array of storage textures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd></dl>

</div>
</div>
<a id="ga81998c754544c2c494ec36f5450e6318" name="ga81998c754544c2c494ec36f5450e6318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81998c754544c2c494ec36f5450e6318">&#9670;&#160;</a></span>BindIndexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPURenderPass::BindIndexBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga698bbc29bd1e44bec1e2b87ce3a81dbb">GPUBufferBinding</a> &amp;&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#gaec587594b432d13ab2ddd78ad77342a7">GPUIndexElementSize</a>&#160;</td>
          <td class="paramname"><em>index_element_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binding</td><td>a pointer to a struct containing an index buffer and offset. </td></tr>
    <tr><td class="paramname">index_element_size</td><td>whether the index values in the buffer are 16- or 32-bit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gac753bb4535cbb52be02c8aca142abea3" name="gac753bb4535cbb52be02c8aca142abea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac753bb4535cbb52be02c8aca142abea3">&#9670;&#160;</a></span>BindPipeline() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUComputePass::BindPipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUComputePipeline.html">GPUComputePipeline</a>&#160;</td>
          <td class="paramname"><em>compute_pipeline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compute_pipeline</td><td>a compute pipeline to bind.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gabe7475370741dbc4a0b9ec8fbafd5c63" name="gabe7475370741dbc4a0b9ec8fbafd5c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe7475370741dbc4a0b9ec8fbafd5c63">&#9670;&#160;</a></span>BindPipeline() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPURenderPass::BindPipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html">GPUGraphicsPipeline</a>&#160;</td>
          <td class="paramname"><em>graphics_pipeline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A graphics pipeline must be bound before making any draw calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graphics_pipeline</td><td>the graphics pipeline to bind.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga336fc1ded40e54a60d884f0d78a30b98" name="ga336fc1ded40e54a60d884f0d78a30b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga336fc1ded40e54a60d884f0d78a30b98">&#9670;&#160;</a></span>BindSamplers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUComputePass::BindSamplers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const <a class="el" href="group__CategoryGPU.html#ga86e968acd12b623cb7b5056c323285b3">GPUTextureSamplerBinding</a> &gt;&#160;</td>
          <td class="paramname"><em>texture_sampler_bindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The textures must have been created with GPU_TEXTUREUSAGE_SAMPLER.</p>
<p>Be sure your shader is set up according to the requirements documented in <a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_slot</td><td>the compute sampler slot to begin binding from. </td></tr>
    <tr><td class="paramname">texture_sampler_bindings</td><td>an array of texture-sampler binding structs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd></dl>

</div>
</div>
<a id="ga3867eeb6d7a78593063877ae13c11085" name="ga3867eeb6d7a78593063877ae13c11085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3867eeb6d7a78593063877ae13c11085">&#9670;&#160;</a></span>BindStorageBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUComputePass::BindStorageBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga729f924587e663dffcd630a594e14396">GPUBufferRaw</a> &gt;&#160;</td>
          <td class="paramname"><em>storage_buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>These buffers must have been created with GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ.</p>
<p>Be sure your shader is set up according to the requirements documented in <a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_slot</td><td>the compute storage buffer slot to begin binding from. </td></tr>
    <tr><td class="paramname">storage_buffers</td><td>an array of storage buffer binding structs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd></dl>

</div>
</div>
<a id="gaedb0e69f7d25a28e1230ab5e02aa18af" name="gaedb0e69f7d25a28e1230ab5e02aa18af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedb0e69f7d25a28e1230ab5e02aa18af">&#9670;&#160;</a></span>BindStorageTextures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUComputePass::BindStorageTextures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga07bab3d86cb28ae9761a1c91b04c285f">GPUTextureRaw</a> &gt;&#160;</td>
          <td class="paramname"><em>storage_textures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>These textures must have been created with GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ.</p>
<p>Be sure your shader is set up according to the requirements documented in <a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_slot</td><td>the compute storage texture slot to begin binding from. </td></tr>
    <tr><td class="paramname">storage_textures</td><td>an array of storage textures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd></dl>

</div>
</div>
<a id="ga92908a319a7f02815bda65d27d1dcbfc" name="ga92908a319a7f02815bda65d27d1dcbfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92908a319a7f02815bda65d27d1dcbfc">&#9670;&#160;</a></span>BindVertexBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPURenderPass::BindVertexBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const <a class="el" href="group__CategoryGPU.html#ga698bbc29bd1e44bec1e2b87ce3a81dbb">GPUBufferBinding</a> &gt;&#160;</td>
          <td class="paramname"><em>bindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_slot</td><td>the vertex buffer slot to begin binding from. </td></tr>
    <tr><td class="paramname">bindings</td><td>an array of GPUBufferBinding structs containing vertex buffers and offset values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga4ca101f553e4044b77d14c04f50d96ff" name="ga4ca101f553e4044b77d14c04f50d96ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ca101f553e4044b77d14c04f50d96ff">&#9670;&#160;</a></span>BindVertexSamplers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPURenderPass::BindVertexSamplers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const <a class="el" href="group__CategoryGPU.html#ga86e968acd12b623cb7b5056c323285b3">GPUTextureSamplerBinding</a> &gt;&#160;</td>
          <td class="paramname"><em>texture_sampler_bindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The textures must have been created with GPU_TEXTUREUSAGE_SAMPLER.</p>
<p>Be sure your shader is set up according to the requirements documented in <a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_slot</td><td>the vertex sampler slot to begin binding from. </td></tr>
    <tr><td class="paramname">texture_sampler_bindings</td><td>an array of texture-sampler binding structs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd></dl>

</div>
</div>
<a id="ga9487a0e6987e3d52ac8193bccc389bbf" name="ga9487a0e6987e3d52ac8193bccc389bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9487a0e6987e3d52ac8193bccc389bbf">&#9670;&#160;</a></span>BindVertexStorageBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPURenderPass::BindVertexStorageBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga729f924587e663dffcd630a594e14396">GPUBufferRaw</a> &gt;&#160;</td>
          <td class="paramname"><em>storage_buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>These buffers must have been created with GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.</p>
<p>Be sure your shader is set up according to the requirements documented in <a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_slot</td><td>the vertex storage buffer slot to begin binding from. </td></tr>
    <tr><td class="paramname">storage_buffers</td><td>an array of buffers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd></dl>

</div>
</div>
<a id="ga5679461b5fbc2a4c6604a5c5e35b2afb" name="ga5679461b5fbc2a4c6604a5c5e35b2afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5679461b5fbc2a4c6604a5c5e35b2afb">&#9670;&#160;</a></span>BindVertexStorageTextures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPURenderPass::BindVertexStorageTextures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const <a class="el" href="group__CategoryGPU.html#ga07bab3d86cb28ae9761a1c91b04c285f">GPUTextureRaw</a> &gt;&#160;</td>
          <td class="paramname"><em>storage_textures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>These textures must have been created with GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.</p>
<p>Be sure your shader is set up according to the requirements documented in <a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_slot</td><td>the vertex storage texture slot to begin binding from. </td></tr>
    <tr><td class="paramname">storage_textures</td><td>an array of storage textures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd></dl>

</div>
</div>
<a id="ga123ea0dae77b7f646aee56c82fde1f69" name="ga123ea0dae77b7f646aee56c82fde1f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga123ea0dae77b7f646aee56c82fde1f69">&#9670;&#160;</a></span>BlitGPUTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::BlitGPUTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a>&#160;</td>
          <td class="paramname"><em>command_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#gaabb30629d61cc6f590279354030c3f73">GPUBlitInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function must not be called inside of any pass.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command_buffer</td><td>a command buffer. </td></tr>
    <tr><td class="paramname">info</td><td>the blit info struct containing the blit parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga34fde09ad7856dc08b894c41fff9fc0f" name="ga34fde09ad7856dc08b894c41fff9fc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34fde09ad7856dc08b894c41fff9fc0f">&#9670;&#160;</a></span>BlitTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUCommandBuffer::BlitTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#gaabb30629d61cc6f590279354030c3f73">GPUBlitInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function must not be called inside of any pass.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>the blit info struct containing the blit parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaa45ed13d924cada7cb53f5b094c0057a" name="gaa45ed13d924cada7cb53f5b094c0057a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa45ed13d924cada7cb53f5b094c0057a">&#9670;&#160;</a></span>CalculateGPUTextureFormatSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> SDL::CalculateGPUTextureFormatSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>depth_or_layer_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>a texture format. </td></tr>
    <tr><td class="paramname">width</td><td>width in pixels. </td></tr>
    <tr><td class="paramname">height</td><td>height in pixels. </td></tr>
    <tr><td class="paramname">depth_or_layer_count</td><td>depth for 3D textures or layer count otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of a texture with this format and dimensions.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga3bfdeb35856182f070ef0a146a47997a" name="ga3bfdeb35856182f070ef0a146a47997a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bfdeb35856182f070ef0a146a47997a">&#9670;&#160;</a></span>Cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUCommandBuffer::Cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>None of the enqueued commands are executed.</p>
<p>It is an error to call this function after a swapchain texture has been acquired.</p>
<p>This must be called from the thread the command buffer was acquired on.</p>
<p>You must not reference the command buffer after calling this function.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gae4234ed0ab6264374493b9b6cb07c770" title="Blocks the thread until a swapchain texture is available to be acquired, and then acquires it.">GPUCommandBuffer.WaitAndAcquireSwapchainTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga3afecf456819388452c8af3797f84547" title="Acquire a command buffer.">GPUDevice.AcquireCommandBuffer</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gaa9098e2e6b7139a3af4973e47b4f7d9e" title="Acquire a texture to use in presentation.">GPUCommandBuffer.AcquireSwapchainTexture</a> </dd></dl>

</div>
</div>
<a id="ga27c79b73d90fd76f73b2df0a67054f22" name="ga27c79b73d90fd76f73b2df0a67054f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27c79b73d90fd76f73b2df0a67054f22">&#9670;&#160;</a></span>CancelGPUCommandBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::CancelGPUCommandBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a>&#160;</td>
          <td class="paramname"><em>command_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>None of the enqueued commands are executed.</p>
<p>It is an error to call this function after a swapchain texture has been acquired.</p>
<p>This must be called from the thread the command buffer was acquired on.</p>
<p>You must not reference the command buffer after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command_buffer</td><td>a command buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gae4234ed0ab6264374493b9b6cb07c770" title="Blocks the thread until a swapchain texture is available to be acquired, and then acquires it.">GPUCommandBuffer.WaitAndAcquireSwapchainTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga3afecf456819388452c8af3797f84547" title="Acquire a command buffer.">GPUDevice.AcquireCommandBuffer</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gaa9098e2e6b7139a3af4973e47b4f7d9e" title="Acquire a texture to use in presentation.">GPUCommandBuffer.AcquireSwapchainTexture</a> </dd></dl>

</div>
</div>
<a id="gacbc4104e7cefaaccaf221b4938dacdd9" name="gacbc4104e7cefaaccaf221b4938dacdd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbc4104e7cefaaccaf221b4938dacdd9">&#9670;&#160;</a></span>ClaimWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUDevice::ClaimWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a>&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This must be called before <a class="el" href="group__CategoryGPU.html#gaa9098e2e6b7139a3af4973e47b4f7d9e" title="Acquire a texture to use in presentation.">GPUCommandBuffer.AcquireSwapchainTexture</a> is called using the window. You should only call this function from the thread that created the window.</p>
<p>The swapchain will be created with GPU_SWAPCHAINCOMPOSITION_SDR and GPU_PRESENTMODE_VSYNC. If you want to have different swapchain parameters, you must call <a class="el" href="group__CategoryGPU.html#ga8d862f6cb8aee49dcac4907349d9a186" title="Changes the swapchain parameters for the given claimed window.">GPUDevice.SetSwapchainParameters</a> after claiming the window.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>an <a class="el" href="classSDL_1_1Window.html" title="The struct used as an opaque handle to a window.">Window</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called from the thread that created the window.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gae4234ed0ab6264374493b9b6cb07c770" title="Blocks the thread until a swapchain texture is available to be acquired, and then acquires it.">GPUCommandBuffer.WaitAndAcquireSwapchainTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga85c7fbccab856044a026f2fcdd157cad" title="Unclaims a window, destroying its swapchain structure.">GPUDevice.ReleaseWindow</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gaeb189dcc6f70c6584763e72987ad1ec5" title="Determines whether a presentation mode is supported by the window.">GPUDevice.WindowSupportsPresentMode</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga80eb2cbcd952006b3f129cbd6ebe44c7" title="Determines whether a swapchain composition is supported by the window.">GPUDevice.WindowSupportsSwapchainComposition</a> </dd></dl>

</div>
</div>
<a id="ga3d1d6f5c1e4f0a1c097cbc1b40b86b78" name="ga3d1d6f5c1e4f0a1c097cbc1b40b86b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d1d6f5c1e4f0a1c097cbc1b40b86b78">&#9670;&#160;</a></span>ClaimWindowForGPUDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::ClaimWindowForGPUDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a>&#160;</td>
          <td class="paramname"><em>window</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This must be called before <a class="el" href="group__CategoryGPU.html#gaa9098e2e6b7139a3af4973e47b4f7d9e" title="Acquire a texture to use in presentation.">GPUCommandBuffer.AcquireSwapchainTexture</a> is called using the window. You should only call this function from the thread that created the window.</p>
<p>The swapchain will be created with GPU_SWAPCHAINCOMPOSITION_SDR and GPU_PRESENTMODE_VSYNC. If you want to have different swapchain parameters, you must call <a class="el" href="group__CategoryGPU.html#ga8d862f6cb8aee49dcac4907349d9a186" title="Changes the swapchain parameters for the given claimed window.">GPUDevice.SetSwapchainParameters</a> after claiming the window.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
    <tr><td class="paramname">window</td><td>an <a class="el" href="classSDL_1_1Window.html" title="The struct used as an opaque handle to a window.">Window</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called from the thread that created the window.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gae4234ed0ab6264374493b9b6cb07c770" title="Blocks the thread until a swapchain texture is available to be acquired, and then acquires it.">GPUCommandBuffer.WaitAndAcquireSwapchainTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga85c7fbccab856044a026f2fcdd157cad" title="Unclaims a window, destroying its swapchain structure.">GPUDevice.ReleaseWindow</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gaeb189dcc6f70c6584763e72987ad1ec5" title="Determines whether a presentation mode is supported by the window.">GPUDevice.WindowSupportsPresentMode</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga80eb2cbcd952006b3f129cbd6ebe44c7" title="Determines whether a swapchain composition is supported by the window.">GPUDevice.WindowSupportsSwapchainComposition</a> </dd></dl>

</div>
</div>
<a id="gaa95f70236a503838592fd233846d49a8" name="gaa95f70236a503838592fd233846d49a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa95f70236a503838592fd233846d49a8">&#9670;&#160;</a></span>CopyBufferToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUCopyPass::CopyBufferToBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga6b24b7fc30f477db4a44bc2f1637bd35">GPUBufferLocation</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga6b24b7fc30f477db4a44bc2f1637bd35">GPUBufferLocation</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cycle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This copy occurs on the GPU timeline. You may assume the copy has finished in subsequent commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the buffer and offset to copy from. </td></tr>
    <tr><td class="paramname">destination</td><td>the buffer and offset to copy to. </td></tr>
    <tr><td class="paramname">size</td><td>the length of the buffer to copy. </td></tr>
    <tr><td class="paramname">cycle</td><td>if true, cycles the destination buffer if it is already bound, otherwise overwrites the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gab10c443a232ead5285455f1b57446530" name="gab10c443a232ead5285455f1b57446530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab10c443a232ead5285455f1b57446530">&#9670;&#160;</a></span>CopyGPUBufferToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::CopyGPUBufferToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCopyPass.html">GPUCopyPass</a>&#160;</td>
          <td class="paramname"><em>copy_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga6b24b7fc30f477db4a44bc2f1637bd35">GPUBufferLocation</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga6b24b7fc30f477db4a44bc2f1637bd35">GPUBufferLocation</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cycle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This copy occurs on the GPU timeline. You may assume the copy has finished in subsequent commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy_pass</td><td>a copy pass handle. </td></tr>
    <tr><td class="paramname">source</td><td>the buffer and offset to copy from. </td></tr>
    <tr><td class="paramname">destination</td><td>the buffer and offset to copy to. </td></tr>
    <tr><td class="paramname">size</td><td>the length of the buffer to copy. </td></tr>
    <tr><td class="paramname">cycle</td><td>if true, cycles the destination buffer if it is already bound, otherwise overwrites the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga0fbebbbcf601bcc0feab74edc95e37af" name="ga0fbebbbcf601bcc0feab74edc95e37af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fbebbbcf601bcc0feab74edc95e37af">&#9670;&#160;</a></span>CopyGPUTextureToTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::CopyGPUTextureToTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCopyPass.html">GPUCopyPass</a>&#160;</td>
          <td class="paramname"><em>copy_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga5dac1b3fb8a5a1ba34f6d99b84e81792">GPUTextureLocation</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga5dac1b3fb8a5a1ba34f6d99b84e81792">GPUTextureLocation</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cycle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This copy occurs on the GPU timeline. You may assume the copy has finished in subsequent commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy_pass</td><td>a copy pass handle. </td></tr>
    <tr><td class="paramname">source</td><td>a source texture region. </td></tr>
    <tr><td class="paramname">destination</td><td>a destination texture region. </td></tr>
    <tr><td class="paramname">w</td><td>the width of the region to copy. </td></tr>
    <tr><td class="paramname">h</td><td>the height of the region to copy. </td></tr>
    <tr><td class="paramname">d</td><td>the depth of the region to copy. </td></tr>
    <tr><td class="paramname">cycle</td><td>if true, cycles the destination texture if the destination texture is bound, otherwise overwrites the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga6c2b51e6d7a0d50b15a4a899f672b1cf" name="ga6c2b51e6d7a0d50b15a4a899f672b1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c2b51e6d7a0d50b15a4a899f672b1cf">&#9670;&#160;</a></span>CopyTextureToTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUCopyPass::CopyTextureToTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga5dac1b3fb8a5a1ba34f6d99b84e81792">GPUTextureLocation</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga5dac1b3fb8a5a1ba34f6d99b84e81792">GPUTextureLocation</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cycle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This copy occurs on the GPU timeline. You may assume the copy has finished in subsequent commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>a source texture region. </td></tr>
    <tr><td class="paramname">destination</td><td>a destination texture region. </td></tr>
    <tr><td class="paramname">w</td><td>the width of the region to copy. </td></tr>
    <tr><td class="paramname">h</td><td>the height of the region to copy. </td></tr>
    <tr><td class="paramname">d</td><td>the depth of the region to copy. </td></tr>
    <tr><td class="paramname">cycle</td><td>if true, cycles the destination texture if the destination texture is bound, otherwise overwrites the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga51df2106760ad17d238ec8a3d07e8b60" name="ga51df2106760ad17d238ec8a3d07e8b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51df2106760ad17d238ec8a3d07e8b60">&#9670;&#160;</a></span>CreateBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a> SDL::GPUDevice::CreateBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga6cb3830a3ade4303d47a017993de4fea">GPUBufferCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The contents of this buffer are undefined until data is written to the buffer.</p>
<p>Note that certain combinations of usage flags are invalid. For example, a buffer cannot have both the VERTEX and INDEX flags.</p>
<p>If you use a STORAGE flag, the data in the buffer must respect std140 layout conventions. In practical terms this means you must ensure that vec3 and vec4 fields are 16-byte aligned.</p>
<p>For better understanding of underlying concepts and memory management with <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> GPU API, you may refer <a href="https://moonside.games/posts/sdl-gpu-concepts-cycling/">this blog post</a>.</p>
<p>There are optional properties that can be provided through <code>props</code>. These are the supported properties:</p>
<ul>
<li><code>prop::GPUBuffer.CREATE_NAME_STRING</code>: a name that can be displayed in debugging tools.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createinfo</td><td>a struct describing the state of the buffer to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a buffer object on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga49c5fe1ce14d954d818e0510c7ee875c" title="Uploads data from a transfer buffer to a buffer.">GPUCopyPass.UploadToBuffer</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gacc93df1d338fafc2aedb4216f299a34e" title="Copies data from a buffer to a transfer buffer on the GPU timeline.">GPUCopyPass.DownloadFromBuffer</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gaa95f70236a503838592fd233846d49a8" title="Performs a buffer-to-buffer copy.">GPUCopyPass.CopyBufferToBuffer</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga92908a319a7f02815bda65d27d1dcbfc" title="Binds vertex buffers on a command buffer for use with subsequent draw calls.">GPURenderPass.BindVertexBuffers</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga81998c754544c2c494ec36f5450e6318" title="Binds an index buffer on a command buffer for use with subsequent draw calls.">GPURenderPass.BindIndexBuffer</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga9487a0e6987e3d52ac8193bccc389bbf" title="Binds storage buffers for use on the vertex shader.">GPURenderPass.BindVertexStorageBuffers</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga6908db6f33fe0605f2a4b9aa9bb23877" title="Binds storage buffers for use on the fragment shader.">GPURenderPass.BindFragmentStorageBuffers</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga4cad31422505ada85f19d81536dfe3d9" title="Draws data using bound graphics state and with draw parameters set from a buffer.">GPURenderPass.DrawPrimitivesIndirect</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gafef162b6d49f6d172616026fbc1d5b37" title="Draws data using bound graphics state with an index buffer enabled and with draw parameters set from ...">GPURenderPass.DrawIndexedPrimitivesIndirect</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga3867eeb6d7a78593063877ae13c11085" title="Binds storage buffers as readonly for use on the compute pipeline.">GPUComputePass.BindStorageBuffers</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga5bd535fc79d0e38398d97b34f3640dd2" title="Dispatches compute work with parameters set from a buffer.">GPUComputePass.DispatchIndirect</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gab5dc66c265218b99bb458030cac57723" title="Frees the given buffer as soon as it is safe to do so.">GPUDevice.ReleaseBuffer</a> </dd></dl>

</div>
</div>
<a id="ga24a308465055fd5b67fda9a5fe246daa" name="ga24a308465055fd5b67fda9a5fe246daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24a308465055fd5b67fda9a5fe246daa">&#9670;&#160;</a></span>CreateComputePipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUComputePipeline.html">GPUComputePipeline</a> SDL::GPUDevice::CreateComputePipeline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga9baa44a9f7478858ee1ac28037e0574f">GPUComputePipelineCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shader resource bindings must be authored to follow a particular order depending on the shader format.</p>
<p>For SPIR-V shaders, use the following resource sets:</p>
<ul>
<li>0: Sampled textures, followed by read-only storage textures, followed by read-only storage buffers</li>
<li>1: Read-write storage textures, followed by read-write storage buffers</li>
<li>2: Uniform buffers</li>
</ul>
<p>For DXBC and DXIL shaders, use the following register order:</p>
<ul>
<li>(t[n], space0): Sampled textures, followed by read-only storage textures, followed by read-only storage buffers</li>
<li>(u[n], space1): Read-write storage textures, followed by read-write storage buffers</li>
<li>(b[n], space2): Uniform buffers</li>
</ul>
<p>For MSL/metallib, use the following order:</p>
<ul>
<li>[[buffer]]: Uniform buffers, followed by read-only storage buffers, followed by read-write storage buffers</li>
<li>[[texture]]: Sampled textures, followed by read-only storage textures, followed by read-write storage textures</li>
</ul>
<p>There are optional properties that can be provided through <code>props</code>. These are the supported properties:</p>
<ul>
<li><code>prop::GPUComputePipeline.CREATE_NAME_STRING</code>: a name that can be displayed in debugging tools.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createinfo</td><td>a struct describing the state of the compute pipeline to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compute pipeline object on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gac753bb4535cbb52be02c8aca142abea3" title="Binds a compute pipeline on a command buffer for use in compute dispatch.">GPUComputePass.BindPipeline</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga4c669ef6c9ab4c71b8ef7834e7a39975" title="Frees the given compute pipeline as soon as it is safe to do so.">GPUDevice.ReleaseComputePipeline</a> </dd></dl>

</div>
</div>
<a id="ga8461578dfc858efa73dfd1e49295eed7" name="ga8461578dfc858efa73dfd1e49295eed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8461578dfc858efa73dfd1e49295eed7">&#9670;&#160;</a></span>CreateGPUBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a> SDL::CreateGPUBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga6cb3830a3ade4303d47a017993de4fea">GPUBufferCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The contents of this buffer are undefined until data is written to the buffer.</p>
<p>Note that certain combinations of usage flags are invalid. For example, a buffer cannot have both the VERTEX and INDEX flags.</p>
<p>If you use a STORAGE flag, the data in the buffer must respect std140 layout conventions. In practical terms this means you must ensure that vec3 and vec4 fields are 16-byte aligned.</p>
<p>For better understanding of underlying concepts and memory management with <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> GPU API, you may refer <a href="https://moonside.games/posts/sdl-gpu-concepts-cycling/">this blog post</a>.</p>
<p>There are optional properties that can be provided through <code>props</code>. These are the supported properties:</p>
<ul>
<li><code>prop::GPUBuffer.CREATE_NAME_STRING</code>: a name that can be displayed in debugging tools.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU Context. </td></tr>
    <tr><td class="paramname">createinfo</td><td>a struct describing the state of the buffer to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a buffer object on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga49c5fe1ce14d954d818e0510c7ee875c" title="Uploads data from a transfer buffer to a buffer.">GPUCopyPass.UploadToBuffer</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gacc93df1d338fafc2aedb4216f299a34e" title="Copies data from a buffer to a transfer buffer on the GPU timeline.">GPUCopyPass.DownloadFromBuffer</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gaa95f70236a503838592fd233846d49a8" title="Performs a buffer-to-buffer copy.">GPUCopyPass.CopyBufferToBuffer</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga92908a319a7f02815bda65d27d1dcbfc" title="Binds vertex buffers on a command buffer for use with subsequent draw calls.">GPURenderPass.BindVertexBuffers</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga81998c754544c2c494ec36f5450e6318" title="Binds an index buffer on a command buffer for use with subsequent draw calls.">GPURenderPass.BindIndexBuffer</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga9487a0e6987e3d52ac8193bccc389bbf" title="Binds storage buffers for use on the vertex shader.">GPURenderPass.BindVertexStorageBuffers</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga6908db6f33fe0605f2a4b9aa9bb23877" title="Binds storage buffers for use on the fragment shader.">GPURenderPass.BindFragmentStorageBuffers</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga4cad31422505ada85f19d81536dfe3d9" title="Draws data using bound graphics state and with draw parameters set from a buffer.">GPURenderPass.DrawPrimitivesIndirect</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gafef162b6d49f6d172616026fbc1d5b37" title="Draws data using bound graphics state with an index buffer enabled and with draw parameters set from ...">GPURenderPass.DrawIndexedPrimitivesIndirect</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga3867eeb6d7a78593063877ae13c11085" title="Binds storage buffers as readonly for use on the compute pipeline.">GPUComputePass.BindStorageBuffers</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga5bd535fc79d0e38398d97b34f3640dd2" title="Dispatches compute work with parameters set from a buffer.">GPUComputePass.DispatchIndirect</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gab5dc66c265218b99bb458030cac57723" title="Frees the given buffer as soon as it is safe to do so.">GPUDevice.ReleaseBuffer</a> </dd></dl>

</div>
</div>
<a id="gaa21891e9ebd97f17eda06d0e9fd2436b" name="gaa21891e9ebd97f17eda06d0e9fd2436b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa21891e9ebd97f17eda06d0e9fd2436b">&#9670;&#160;</a></span>CreateGPUComputePipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUComputePipeline.html">GPUComputePipeline</a> SDL::CreateGPUComputePipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga9baa44a9f7478858ee1ac28037e0574f">GPUComputePipelineCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shader resource bindings must be authored to follow a particular order depending on the shader format.</p>
<p>For SPIR-V shaders, use the following resource sets:</p>
<ul>
<li>0: Sampled textures, followed by read-only storage textures, followed by read-only storage buffers</li>
<li>1: Read-write storage textures, followed by read-write storage buffers</li>
<li>2: Uniform buffers</li>
</ul>
<p>For DXBC and DXIL shaders, use the following register order:</p>
<ul>
<li>(t[n], space0): Sampled textures, followed by read-only storage textures, followed by read-only storage buffers</li>
<li>(u[n], space1): Read-write storage textures, followed by read-write storage buffers</li>
<li>(b[n], space2): Uniform buffers</li>
</ul>
<p>For MSL/metallib, use the following order:</p>
<ul>
<li>[[buffer]]: Uniform buffers, followed by read-only storage buffers, followed by read-write storage buffers</li>
<li>[[texture]]: Sampled textures, followed by read-only storage textures, followed by read-write storage textures</li>
</ul>
<p>There are optional properties that can be provided through <code>props</code>. These are the supported properties:</p>
<ul>
<li><code>prop::GPUComputePipeline.CREATE_NAME_STRING</code>: a name that can be displayed in debugging tools.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU Context. </td></tr>
    <tr><td class="paramname">createinfo</td><td>a struct describing the state of the compute pipeline to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compute pipeline object on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gac753bb4535cbb52be02c8aca142abea3" title="Binds a compute pipeline on a command buffer for use in compute dispatch.">GPUComputePass.BindPipeline</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga4c669ef6c9ab4c71b8ef7834e7a39975" title="Frees the given compute pipeline as soon as it is safe to do so.">GPUDevice.ReleaseComputePipeline</a> </dd></dl>

</div>
</div>
<a id="gabd7a0adc1bbd7e1bd628f257c2f2f51d" name="gabd7a0adc1bbd7e1bd628f257c2f2f51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd7a0adc1bbd7e1bd628f257c2f2f51d">&#9670;&#160;</a></span>CreateGPUDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUDevice.html">GPUDevice</a> SDL::CreateGPUDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">GPUShaderFormat</a>&#160;</td>
          <td class="paramname"><em>format_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format_flags</td><td>a bitflag indicating which shader formats the app is able to provide. </td></tr>
    <tr><td class="paramname">debug_mode</td><td>enable debug mode properties and validations. </td></tr>
    <tr><td class="paramname">name</td><td>the preferred GPU driver, or nullptr to let <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> pick the optimal driver. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a GPU context on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gaf82030e566bd87483a83fac84210f0e0" title="Returns the supported shader formats for this GPU context.">GPUDevice.GetShaderFormats</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga09208b4ab434b99ecd69c1640179fde6" title="Returns the name of the backend used to create this GPU context.">GPUDevice.GetDriver</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga006c1144e0ac31c12c5184682709c3d3" title="Destroys a GPU context previously returned by GPUDevice.GPUDevice.">GPUDevice.Destroy</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gae97816ef9ed10b7e29d52a0bbeb929c6" title="Checks for GPU runtime support.">GPUSupportsShaderFormats</a> </dd></dl>

</div>
</div>
<a id="ga570cf45429ab2969bb5351037fba5919" name="ga570cf45429ab2969bb5351037fba5919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga570cf45429ab2969bb5351037fba5919">&#9670;&#160;</a></span>CreateGPUDeviceWithProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUDevice.html">GPUDevice</a> SDL::CreateGPUDeviceWithProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1PropertiesParam.html">PropertiesParam</a>&#160;</td>
          <td class="paramname"><em>props</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>These are the supported properties:</p>
<ul>
<li><code>prop::GpuDevice.CREATE_DEBUGMODE_BOOLEAN</code>: enable debug mode properties and validations, defaults to true.</li>
<li><code>prop::GpuDevice.CREATE_PREFERLOWPOWER_BOOLEAN</code>: enable to prefer energy efficiency over maximum GPU performance, defaults to false.</li>
<li><code>prop::GpuDevice.CREATE_NAME_STRING</code>: the name of the GPU driver to use, if a specific one is desired.</li>
</ul>
<p>These are the current shader format properties:</p>
<ul>
<li><code>prop::GpuDevice.CREATE_SHADERS_PRIVATE_BOOLEAN</code>: The app is able to provide shaders for an NDA platform.</li>
<li><code>prop::GpuDevice.CREATE_SHADERS_SPIRV_BOOLEAN</code>: The app is able to provide SPIR-V shaders if applicable.</li>
<li><code>prop::GpuDevice.CREATE_SHADERS_DXBC_BOOLEAN</code>: The app is able to provide DXBC shaders if applicable</li>
<li><code>prop::GpuDevice.CREATE_SHADERS_DXIL_BOOLEAN</code>: The app is able to provide DXIL shaders if applicable.</li>
<li><code>prop::GpuDevice.CREATE_SHADERS_MSL_BOOLEAN</code>: The app is able to provide MSL shaders if applicable.</li>
<li><code>prop::GpuDevice.CREATE_SHADERS_METALLIB_BOOLEAN</code>: The app is able to provide Metal shader libraries if applicable.</li>
</ul>
<p>With the D3D12 renderer:</p>
<ul>
<li><code>prop::GpuDevice.CREATE_D3D12_SEMANTIC_NAME_STRING</code>: the prefix to use for all vertex semantics, default is "TEXCOORD".</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">props</td><td>the properties to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a GPU context on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gaf82030e566bd87483a83fac84210f0e0" title="Returns the supported shader formats for this GPU context.">GPUDevice.GetShaderFormats</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga09208b4ab434b99ecd69c1640179fde6" title="Returns the name of the backend used to create this GPU context.">GPUDevice.GetDriver</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga006c1144e0ac31c12c5184682709c3d3" title="Destroys a GPU context previously returned by GPUDevice.GPUDevice.">GPUDevice.Destroy</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gadd98f2a7bff0b2815bf2da41ddf4a1c7" title="Checks for GPU runtime support.">GPUSupportsProperties</a> </dd></dl>

</div>
</div>
<a id="ga7d5e158e09ece9950142df75d9212b9c" name="ga7d5e158e09ece9950142df75d9212b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d5e158e09ece9950142df75d9212b9c">&#9670;&#160;</a></span>CreateGPUGraphicsPipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html">GPUGraphicsPipeline</a> SDL::CreateGPUGraphicsPipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga60d171e0d2bee691d934e2275b2bf23b">GPUGraphicsPipelineCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>There are optional properties that can be provided through <code>props</code>. These are the supported properties:</p>
<ul>
<li><code>prop::GPUGraphicsPipeline.CREATE_NAME_STRING</code>: a name that can be displayed in debugging tools.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU Context. </td></tr>
    <tr><td class="paramname">createinfo</td><td>a struct describing the state of the graphics pipeline to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a graphics pipeline object on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gabe7475370741dbc4a0b9ec8fbafd5c63" title="Binds a graphics pipeline on a render pass to be used in rendering.">GPURenderPass.BindPipeline</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gad3c154a75ac11895cf331e4d32796ea0" title="Frees the given graphics pipeline as soon as it is safe to do so.">GPUDevice.ReleaseGraphicsPipeline</a> </dd></dl>

</div>
</div>
<a id="gafe94feb1e693d65d092e72bd6d4cfdac" name="gafe94feb1e693d65d092e72bd6d4cfdac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe94feb1e693d65d092e72bd6d4cfdac">&#9670;&#160;</a></span>CreateGPUSampler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUSampler.html">GPUSampler</a> SDL::CreateGPUSampler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga9905b04780e8798c8cd2bf18a29bff27">GPUSamplerCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>There are optional properties that can be provided through <code>props</code>. These are the supported properties:</p>
<ul>
<li><code>prop::GPUSampler.CREATE_NAME_STRING</code>: a name that can be displayed in debugging tools.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU Context. </td></tr>
    <tr><td class="paramname">createinfo</td><td>a struct describing the state of the sampler to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sampler object on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga4ca101f553e4044b77d14c04f50d96ff" title="Binds texture-sampler pairs for use on the vertex shader.">GPURenderPass.BindVertexSamplers</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga3566cec8f39f95f37f2f7c66653c4c55" title="Binds texture-sampler pairs for use on the fragment shader.">GPURenderPass.BindFragmentSamplers</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga69f056178de21168997a6554cbc27c1e" title="Frees the given sampler as soon as it is safe to do so.">GPUDevice.ReleaseSampler</a> </dd></dl>

</div>
</div>
<a id="gaa11cb7a06cff34927d31e120e90eb064" name="gaa11cb7a06cff34927d31e120e90eb064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa11cb7a06cff34927d31e120e90eb064">&#9670;&#160;</a></span>CreateGPUShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUShader.html">GPUShader</a> SDL::CreateGPUShader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#gaec6e01546fef70020c8f7b44da82be99">GPUShaderCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shader resource bindings must be authored to follow a particular order depending on the shader format.</p>
<p>For SPIR-V shaders, use the following resource sets:</p>
<p>For vertex shaders:</p>
<ul>
<li>0: Sampled textures, followed by storage textures, followed by storage buffers</li>
<li>1: Uniform buffers</li>
</ul>
<p>For fragment shaders:</p>
<ul>
<li>2: Sampled textures, followed by storage textures, followed by storage buffers</li>
<li>3: Uniform buffers</li>
</ul>
<p>For DXBC and DXIL shaders, use the following register order:</p>
<p>For vertex shaders:</p>
<ul>
<li>(t[n], space0): Sampled textures, followed by storage textures, followed by storage buffers</li>
<li>(s[n], space0): Samplers with indices corresponding to the sampled textures</li>
<li>(b[n], space1): Uniform buffers</li>
</ul>
<p>For pixel shaders:</p>
<ul>
<li>(t[n], space2): Sampled textures, followed by storage textures, followed by storage buffers</li>
<li>(s[n], space2): Samplers with indices corresponding to the sampled textures</li>
<li>(b[n], space3): Uniform buffers</li>
</ul>
<p>For MSL/metallib, use the following order:</p>
<ul>
<li>[[texture]]: Sampled textures, followed by storage textures</li>
<li>[[sampler]]: Samplers with indices corresponding to the sampled textures</li>
<li>[[buffer]]: Uniform buffers, followed by storage buffers. Vertex buffer 0 is bound at [[buffer(14)]], vertex buffer 1 at [[buffer(15)]], and so on. Rather than manually authoring vertex buffer indices, use the [[stage_in]] attribute which will automatically use the vertex input information from the <a class="el" href="classSDL_1_1GPUGraphicsPipeline.html" title="An opaque handle representing a graphics pipeline.">GPUGraphicsPipeline</a>.</li>
</ul>
<p>Shader semantics other than system-value semantics do not matter in D3D12 and for ease of use the <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> implementation assumes that non system-value semantics will all be TEXCOORD. If you are using HLSL as the shader source language, your vertex semantics should start at TEXCOORD0 and increment like so: TEXCOORD1, TEXCOORD2, etc. If you wish to change the semantic prefix to something other than TEXCOORD you can use prop::GpuDevice.CREATE_D3D12_SEMANTIC_NAME_STRING with <a class="el" href="classSDL_1_1GPUDevice.html#a9fde3883d9146abd2533f4882d233906" title="Default ctor.">GPUDevice.GPUDevice()</a>.</p>
<p>There are optional properties that can be provided through <code>props</code>. These are the supported properties:</p>
<ul>
<li><code>prop::GPUShader.CREATE_NAME_STRING</code>: a name that can be displayed in debugging tools.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU Context. </td></tr>
    <tr><td class="paramname">createinfo</td><td>a struct describing the state of the shader to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a shader object on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html#aa6c513650dc796f541138ec49883165e" title="Wraps GPUGraphicsPipeline.">GPUGraphicsPipeline.GPUGraphicsPipeline</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga1a193a6c5e5396d8b09aeadaf537fdec" title="Frees the given shader as soon as it is safe to do so.">GPUDevice.ReleaseShader</a> </dd></dl>

</div>
</div>
<a id="ga9c21cb9e36008832e5d982833c5ff581" name="ga9c21cb9e36008832e5d982833c5ff581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c21cb9e36008832e5d982833c5ff581">&#9670;&#160;</a></span>CreateGPUTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a> SDL::CreateGPUTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga87fcb53cd9c731a4a4f3c7c10a5edb6a">GPUTextureCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The contents of this texture are undefined until data is written to the texture.</p>
<p>Note that certain combinations of usage flags are invalid. For example, a texture cannot have both the SAMPLER and GRAPHICS_STORAGE_READ flags.</p>
<p>If you request a sample count higher than the hardware supports, the implementation will automatically fall back to the highest available sample count.</p>
<p>There are optional properties that can be provided through GPUTextureCreateInfo's <code>props</code>. These are the supported properties:</p>
<ul>
<li><code>prop::GPUTexture.CREATE_D3D12_CLEAR_R_FLOAT</code>: (Direct3D 12 only) if the texture usage is GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture to a color with this red intensity. Defaults to zero.</li>
<li><code>prop::GPUTexture.CREATE_D3D12_CLEAR_G_FLOAT</code>: (Direct3D 12 only) if the texture usage is GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture to a color with this green intensity. Defaults to zero.</li>
<li><code>prop::GPUTexture.CREATE_D3D12_CLEAR_B_FLOAT</code>: (Direct3D 12 only) if the texture usage is GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture to a color with this blue intensity. Defaults to zero.</li>
<li><code>prop::GPUTexture.CREATE_D3D12_CLEAR_A_FLOAT</code>: (Direct3D 12 only) if the texture usage is GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture to a color with this alpha intensity. Defaults to zero.</li>
<li><code>prop::GPUTexture.CREATE_D3D12_CLEAR_DEPTH_FLOAT</code>: (Direct3D 12 only) if the texture usage is GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET, clear the texture to a depth of this value. Defaults to zero.</li>
<li><code>prop::GPUTexture.CREATE_D3D12_CLEAR_STENCIL_NUMBER</code>: (Direct3D 12 only) if the texture usage is GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET, clear the texture to a stencil of this Uint8 value. Defaults to zero.</li>
<li><code>prop::GPUTexture.CREATE_NAME_STRING</code>: a name that can be displayed in debugging tools.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU Context. </td></tr>
    <tr><td class="paramname">createinfo</td><td>a struct describing the state of the texture to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a texture object on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gab5b7ed8fb63a9d190521a0618214b2c2" title="Uploads data from a transfer buffer to a texture.">GPUCopyPass.UploadToTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga350647db0f6c39ab4556bc767eb9da69" title="Copies data from a texture to a transfer buffer on the GPU timeline.">GPUCopyPass.DownloadFromTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga4ca101f553e4044b77d14c04f50d96ff" title="Binds texture-sampler pairs for use on the vertex shader.">GPURenderPass.BindVertexSamplers</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga5679461b5fbc2a4c6604a5c5e35b2afb" title="Binds storage textures for use on the vertex shader.">GPURenderPass.BindVertexStorageTextures</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga3566cec8f39f95f37f2f7c66653c4c55" title="Binds texture-sampler pairs for use on the fragment shader.">GPURenderPass.BindFragmentSamplers</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga4842b7086c6105187135bdc9526266c9" title="Binds storage textures for use on the fragment shader.">GPURenderPass.BindFragmentStorageTextures</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gaedb0e69f7d25a28e1230ab5e02aa18af" title="Binds storage textures as readonly for use on the compute pipeline.">GPUComputePass.BindStorageTextures</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga34fde09ad7856dc08b894c41fff9fc0f" title="Blits from a source texture region to a destination texture region.">GPUCommandBuffer.BlitTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga95ea4befed403fa9c10298c547c9b95e" title="Frees the given texture as soon as it is safe to do so.">GPUDevice.ReleaseTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga24dbdaadc509ba8acd1fb2689449c133" title="Determines whether a texture format is supported for a given type and usage.">GPUDevice.TextureSupportsFormat</a> </dd></dl>

</div>
</div>
<a id="ga0309af2a31bb393288d480bcc42edce2" name="ga0309af2a31bb393288d480bcc42edce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0309af2a31bb393288d480bcc42edce2">&#9670;&#160;</a></span>CreateGPUTransferBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUTransferBuffer.html">GPUTransferBuffer</a> SDL::CreateGPUTransferBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#gabf392df5f8790bf73f828ca3e1f21bd5">GPUTransferBufferCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Download buffers can be particularly expensive to create, so it is good practice to reuse them if data will be downloaded regularly.</p>
<p>There are optional properties that can be provided through <code>props</code>. These are the supported properties:</p>
<ul>
<li><code>prop::GPUTransferBuffer.CREATE_NAME_STRING</code>: a name that can be displayed in debugging tools.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU Context. </td></tr>
    <tr><td class="paramname">createinfo</td><td>a struct describing the state of the transfer buffer to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a transfer buffer on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga49c5fe1ce14d954d818e0510c7ee875c" title="Uploads data from a transfer buffer to a buffer.">GPUCopyPass.UploadToBuffer</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gacc93df1d338fafc2aedb4216f299a34e" title="Copies data from a buffer to a transfer buffer on the GPU timeline.">GPUCopyPass.DownloadFromBuffer</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gab5b7ed8fb63a9d190521a0618214b2c2" title="Uploads data from a transfer buffer to a texture.">GPUCopyPass.UploadToTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga350647db0f6c39ab4556bc767eb9da69" title="Copies data from a texture to a transfer buffer on the GPU timeline.">GPUCopyPass.DownloadFromTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga1a709128809970cdde83691bb4a5b040" title="Frees the given transfer buffer as soon as it is safe to do so.">GPUDevice.ReleaseTransferBuffer</a> </dd></dl>

</div>
</div>
<a id="ga65eea93722c98ad0ce8bc7009b3da562" name="ga65eea93722c98ad0ce8bc7009b3da562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65eea93722c98ad0ce8bc7009b3da562">&#9670;&#160;</a></span>CreateGraphicsPipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html">GPUGraphicsPipeline</a> SDL::GPUDevice::CreateGraphicsPipeline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga60d171e0d2bee691d934e2275b2bf23b">GPUGraphicsPipelineCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>There are optional properties that can be provided through <code>props</code>. These are the supported properties:</p>
<ul>
<li><code>prop::GPUGraphicsPipeline.CREATE_NAME_STRING</code>: a name that can be displayed in debugging tools.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createinfo</td><td>a struct describing the state of the graphics pipeline to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a graphics pipeline object on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUShader.html#a356fa37dd18b03e9c7f93252330a85b0" title="Wraps GPUShader.">GPUShader.GPUShader</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gabe7475370741dbc4a0b9ec8fbafd5c63" title="Binds a graphics pipeline on a render pass to be used in rendering.">GPURenderPass.BindPipeline</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gad3c154a75ac11895cf331e4d32796ea0" title="Frees the given graphics pipeline as soon as it is safe to do so.">GPUDevice.ReleaseGraphicsPipeline</a> </dd></dl>

</div>
</div>
<a id="ga1c36338cbceee7ec433558e923cb275b" name="ga1c36338cbceee7ec433558e923cb275b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c36338cbceee7ec433558e923cb275b">&#9670;&#160;</a></span>CreateSampler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUSampler.html">GPUSampler</a> SDL::GPUDevice::CreateSampler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga9905b04780e8798c8cd2bf18a29bff27">GPUSamplerCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>There are optional properties that can be provided through <code>props</code>. These are the supported properties:</p>
<ul>
<li><code>prop::GPUSampler.CREATE_NAME_STRING</code>: a name that can be displayed in debugging tools.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createinfo</td><td>a struct describing the state of the sampler to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sampler object on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga4ca101f553e4044b77d14c04f50d96ff" title="Binds texture-sampler pairs for use on the vertex shader.">GPURenderPass.BindVertexSamplers</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga3566cec8f39f95f37f2f7c66653c4c55" title="Binds texture-sampler pairs for use on the fragment shader.">GPURenderPass.BindFragmentSamplers</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga69f056178de21168997a6554cbc27c1e" title="Frees the given sampler as soon as it is safe to do so.">GPUDevice.ReleaseSampler</a> </dd></dl>

</div>
</div>
<a id="gac338fa10a4d70148cd16d6d55d2a5dae" name="gac338fa10a4d70148cd16d6d55d2a5dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac338fa10a4d70148cd16d6d55d2a5dae">&#9670;&#160;</a></span>CreateShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUShader.html">GPUShader</a> SDL::GPUDevice::CreateShader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#gaec6e01546fef70020c8f7b44da82be99">GPUShaderCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shader resource bindings must be authored to follow a particular order depending on the shader format.</p>
<p>For SPIR-V shaders, use the following resource sets:</p>
<p>For vertex shaders:</p>
<ul>
<li>0: Sampled textures, followed by storage textures, followed by storage buffers</li>
<li>1: Uniform buffers</li>
</ul>
<p>For fragment shaders:</p>
<ul>
<li>2: Sampled textures, followed by storage textures, followed by storage buffers</li>
<li>3: Uniform buffers</li>
</ul>
<p>For DXBC and DXIL shaders, use the following register order:</p>
<p>For vertex shaders:</p>
<ul>
<li>(t[n], space0): Sampled textures, followed by storage textures, followed by storage buffers</li>
<li>(s[n], space0): Samplers with indices corresponding to the sampled textures</li>
<li>(b[n], space1): Uniform buffers</li>
</ul>
<p>For pixel shaders:</p>
<ul>
<li>(t[n], space2): Sampled textures, followed by storage textures, followed by storage buffers</li>
<li>(s[n], space2): Samplers with indices corresponding to the sampled textures</li>
<li>(b[n], space3): Uniform buffers</li>
</ul>
<p>For MSL/metallib, use the following order:</p>
<ul>
<li>[[texture]]: Sampled textures, followed by storage textures</li>
<li>[[sampler]]: Samplers with indices corresponding to the sampled textures</li>
<li>[[buffer]]: Uniform buffers, followed by storage buffers. Vertex buffer 0 is bound at [[buffer(14)]], vertex buffer 1 at [[buffer(15)]], and so on. Rather than manually authoring vertex buffer indices, use the [[stage_in]] attribute which will automatically use the vertex input information from the <a class="el" href="classSDL_1_1GPUGraphicsPipeline.html" title="An opaque handle representing a graphics pipeline.">GPUGraphicsPipeline</a>.</li>
</ul>
<p>Shader semantics other than system-value semantics do not matter in D3D12 and for ease of use the <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> implementation assumes that non system-value semantics will all be TEXCOORD. If you are using HLSL as the shader source language, your vertex semantics should start at TEXCOORD0 and increment like so: TEXCOORD1, TEXCOORD2, etc. If you wish to change the semantic prefix to something other than TEXCOORD you can use prop::GpuDevice.CREATE_D3D12_SEMANTIC_NAME_STRING with <a class="el" href="classSDL_1_1GPUDevice.html#a9fde3883d9146abd2533f4882d233906" title="Default ctor.">GPUDevice.GPUDevice()</a>.</p>
<p>There are optional properties that can be provided through <code>props</code>. These are the supported properties:</p>
<ul>
<li><code>prop::GPUShader.CREATE_NAME_STRING</code>: a name that can be displayed in debugging tools.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createinfo</td><td>a struct describing the state of the shader to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a shader object on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html#aa6c513650dc796f541138ec49883165e" title="Wraps GPUGraphicsPipeline.">GPUGraphicsPipeline.GPUGraphicsPipeline</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga1a193a6c5e5396d8b09aeadaf537fdec" title="Frees the given shader as soon as it is safe to do so.">GPUDevice.ReleaseShader</a> </dd></dl>

</div>
</div>
<a id="gac61cedc2ed961eec0ae3c7a5a9800c43" name="gac61cedc2ed961eec0ae3c7a5a9800c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac61cedc2ed961eec0ae3c7a5a9800c43">&#9670;&#160;</a></span>CreateTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a> SDL::GPUDevice::CreateTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga87fcb53cd9c731a4a4f3c7c10a5edb6a">GPUTextureCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The contents of this texture are undefined until data is written to the texture.</p>
<p>Note that certain combinations of usage flags are invalid. For example, a texture cannot have both the SAMPLER and GRAPHICS_STORAGE_READ flags.</p>
<p>If you request a sample count higher than the hardware supports, the implementation will automatically fall back to the highest available sample count.</p>
<p>There are optional properties that can be provided through GPUTextureCreateInfo's <code>props</code>. These are the supported properties:</p>
<ul>
<li><code>prop::GPUTexture.CREATE_D3D12_CLEAR_R_FLOAT</code>: (Direct3D 12 only) if the texture usage is GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture to a color with this red intensity. Defaults to zero.</li>
<li><code>prop::GPUTexture.CREATE_D3D12_CLEAR_G_FLOAT</code>: (Direct3D 12 only) if the texture usage is GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture to a color with this green intensity. Defaults to zero.</li>
<li><code>prop::GPUTexture.CREATE_D3D12_CLEAR_B_FLOAT</code>: (Direct3D 12 only) if the texture usage is GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture to a color with this blue intensity. Defaults to zero.</li>
<li><code>prop::GPUTexture.CREATE_D3D12_CLEAR_A_FLOAT</code>: (Direct3D 12 only) if the texture usage is GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture to a color with this alpha intensity. Defaults to zero.</li>
<li><code>prop::GPUTexture.CREATE_D3D12_CLEAR_DEPTH_FLOAT</code>: (Direct3D 12 only) if the texture usage is GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET, clear the texture to a depth of this value. Defaults to zero.</li>
<li><code>prop::GPUTexture.CREATE_D3D12_CLEAR_STENCIL_NUMBER</code>: (Direct3D 12 only) if the texture usage is GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET, clear the texture to a stencil of this Uint8 value. Defaults to zero.</li>
<li><code>prop::GPUTexture.CREATE_NAME_STRING</code>: a name that can be displayed in debugging tools.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createinfo</td><td>a struct describing the state of the texture to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a texture object on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gab5b7ed8fb63a9d190521a0618214b2c2" title="Uploads data from a transfer buffer to a texture.">GPUCopyPass.UploadToTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga350647db0f6c39ab4556bc767eb9da69" title="Copies data from a texture to a transfer buffer on the GPU timeline.">GPUCopyPass.DownloadFromTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga4ca101f553e4044b77d14c04f50d96ff" title="Binds texture-sampler pairs for use on the vertex shader.">GPURenderPass.BindVertexSamplers</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga5679461b5fbc2a4c6604a5c5e35b2afb" title="Binds storage textures for use on the vertex shader.">GPURenderPass.BindVertexStorageTextures</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga3566cec8f39f95f37f2f7c66653c4c55" title="Binds texture-sampler pairs for use on the fragment shader.">GPURenderPass.BindFragmentSamplers</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga4842b7086c6105187135bdc9526266c9" title="Binds storage textures for use on the fragment shader.">GPURenderPass.BindFragmentStorageTextures</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gaedb0e69f7d25a28e1230ab5e02aa18af" title="Binds storage textures as readonly for use on the compute pipeline.">GPUComputePass.BindStorageTextures</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga34fde09ad7856dc08b894c41fff9fc0f" title="Blits from a source texture region to a destination texture region.">GPUCommandBuffer.BlitTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga95ea4befed403fa9c10298c547c9b95e" title="Frees the given texture as soon as it is safe to do so.">GPUDevice.ReleaseTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga24dbdaadc509ba8acd1fb2689449c133" title="Determines whether a texture format is supported for a given type and usage.">GPUDevice.TextureSupportsFormat</a> </dd></dl>

</div>
</div>
<a id="ga9ecc2006d014d2a988fdbd2cc0af4d38" name="ga9ecc2006d014d2a988fdbd2cc0af4d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ecc2006d014d2a988fdbd2cc0af4d38">&#9670;&#160;</a></span>CreateTransferBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUTransferBuffer.html">GPUTransferBuffer</a> SDL::GPUDevice::CreateTransferBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#gabf392df5f8790bf73f828ca3e1f21bd5">GPUTransferBufferCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Download buffers can be particularly expensive to create, so it is good practice to reuse them if data will be downloaded regularly.</p>
<p>There are optional properties that can be provided through <code>props</code>. These are the supported properties:</p>
<ul>
<li><code>prop::GPUTransferBuffer.CREATE_NAME_STRING</code>: a name that can be displayed in debugging tools.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createinfo</td><td>a struct describing the state of the transfer buffer to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a transfer buffer on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga49c5fe1ce14d954d818e0510c7ee875c" title="Uploads data from a transfer buffer to a buffer.">GPUCopyPass.UploadToBuffer</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gacc93df1d338fafc2aedb4216f299a34e" title="Copies data from a buffer to a transfer buffer on the GPU timeline.">GPUCopyPass.DownloadFromBuffer</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gab5b7ed8fb63a9d190521a0618214b2c2" title="Uploads data from a transfer buffer to a texture.">GPUCopyPass.UploadToTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga350647db0f6c39ab4556bc767eb9da69" title="Copies data from a texture to a transfer buffer on the GPU timeline.">GPUCopyPass.DownloadFromTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga1a709128809970cdde83691bb4a5b040" title="Frees the given transfer buffer as soon as it is safe to do so.">GPUDevice.ReleaseTransferBuffer</a> </dd></dl>

</div>
</div>
<a id="ga006c1144e0ac31c12c5184682709c3d3" name="ga006c1144e0ac31c12c5184682709c3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga006c1144e0ac31c12c5184682709c3d3">&#9670;&#160;</a></span>Destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUDevice::Destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUDevice.html#a9fde3883d9146abd2533f4882d233906" title="Default ctor.">GPUDevice.GPUDevice</a> </dd></dl>

</div>
</div>
<a id="gaaac6e62e53451d12604898cec7addfee" name="gaaac6e62e53451d12604898cec7addfee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaac6e62e53451d12604898cec7addfee">&#9670;&#160;</a></span>DestroyGPUDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::DestroyGPUDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#gac9a40e8e5a66e5269284c096f0908a74">GPUDeviceRaw</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU Context to destroy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUDevice.html#a9fde3883d9146abd2533f4882d233906" title="Default ctor.">GPUDevice.GPUDevice</a> </dd></dl>

</div>
</div>
<a id="ga035cf70f11f2a3fb5061495b7e4b1c97" name="ga035cf70f11f2a3fb5061495b7e4b1c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga035cf70f11f2a3fb5061495b7e4b1c97">&#9670;&#160;</a></span>Dispatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUComputePass::Dispatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>groupcount_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>groupcount_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>groupcount_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must not call this function before binding a compute pipeline.</p>
<p>A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and the dispatches write to the same resource region as each other, there is no guarantee of which order the writes will occur. If the write order matters, you MUST end the compute pass and begin another one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupcount_x</td><td>number of local workgroups to dispatch in the X dimension. </td></tr>
    <tr><td class="paramname">groupcount_y</td><td>number of local workgroups to dispatch in the Y dimension. </td></tr>
    <tr><td class="paramname">groupcount_z</td><td>number of local workgroups to dispatch in the Z dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga79b297bf14faed46960f3c4aa670ad02" name="ga79b297bf14faed46960f3c4aa670ad02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79b297bf14faed46960f3c4aa670ad02">&#9670;&#160;</a></span>DispatchGPUCompute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::DispatchGPUCompute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUComputePass.html">GPUComputePass</a>&#160;</td>
          <td class="paramname"><em>compute_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>groupcount_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>groupcount_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>groupcount_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must not call this function before binding a compute pipeline.</p>
<p>A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and the dispatches write to the same resource region as each other, there is no guarantee of which order the writes will occur. If the write order matters, you MUST end the compute pass and begin another one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compute_pass</td><td>a compute pass handle. </td></tr>
    <tr><td class="paramname">groupcount_x</td><td>number of local workgroups to dispatch in the X dimension. </td></tr>
    <tr><td class="paramname">groupcount_y</td><td>number of local workgroups to dispatch in the Y dimension. </td></tr>
    <tr><td class="paramname">groupcount_z</td><td>number of local workgroups to dispatch in the Z dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gae26de86745cd7e4270f173b0b0dfdb88" name="gae26de86745cd7e4270f173b0b0dfdb88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae26de86745cd7e4270f173b0b0dfdb88">&#9670;&#160;</a></span>DispatchGPUComputeIndirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::DispatchGPUComputeIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUComputePass.html">GPUComputePass</a>&#160;</td>
          <td class="paramname"><em>compute_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The buffer layout should match the layout of GPUIndirectDispatchCommand. You must not call this function before binding a compute pipeline.</p>
<p>A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and the dispatches write to the same resource region as each other, there is no guarantee of which order the writes will occur. If the write order matters, you MUST end the compute pass and begin another one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compute_pass</td><td>a compute pass handle. </td></tr>
    <tr><td class="paramname">buffer</td><td>a buffer containing dispatch parameters. </td></tr>
    <tr><td class="paramname">offset</td><td>the offset to start reading from the dispatch buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga5bd535fc79d0e38398d97b34f3640dd2" name="ga5bd535fc79d0e38398d97b34f3640dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bd535fc79d0e38398d97b34f3640dd2">&#9670;&#160;</a></span>DispatchIndirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUComputePass::DispatchIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The buffer layout should match the layout of GPUIndirectDispatchCommand. You must not call this function before binding a compute pipeline.</p>
<p>A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and the dispatches write to the same resource region as each other, there is no guarantee of which order the writes will occur. If the write order matters, you MUST end the compute pass and begin another one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>a buffer containing dispatch parameters. </td></tr>
    <tr><td class="paramname">offset</td><td>the offset to start reading from the dispatch buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gacc93df1d338fafc2aedb4216f299a34e" name="gacc93df1d338fafc2aedb4216f299a34e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc93df1d338fafc2aedb4216f299a34e">&#9670;&#160;</a></span>DownloadFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUCopyPass::DownloadFromBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#gac3310186554cb88f7b1a1599171aabdf">GPUBufferRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga9faa5600aabe5cabf35cbdf09851af6d">GPUTransferBufferLocation</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This data is not guaranteed to be copied until the command buffer fence is signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the source buffer with offset and size. </td></tr>
    <tr><td class="paramname">destination</td><td>the destination transfer buffer with offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga8a58581a8c83f67fbc3546078a209b9d" name="ga8a58581a8c83f67fbc3546078a209b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a58581a8c83f67fbc3546078a209b9d">&#9670;&#160;</a></span>DownloadFromGPUBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::DownloadFromGPUBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCopyPass.html">GPUCopyPass</a>&#160;</td>
          <td class="paramname"><em>copy_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#gac3310186554cb88f7b1a1599171aabdf">GPUBufferRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga9faa5600aabe5cabf35cbdf09851af6d">GPUTransferBufferLocation</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This data is not guaranteed to be copied until the command buffer fence is signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy_pass</td><td>a copy pass handle. </td></tr>
    <tr><td class="paramname">source</td><td>the source buffer with offset and size. </td></tr>
    <tr><td class="paramname">destination</td><td>the destination transfer buffer with offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gad9ff23e7e51356708dfc42549d4a5087" name="gad9ff23e7e51356708dfc42549d4a5087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9ff23e7e51356708dfc42549d4a5087">&#9670;&#160;</a></span>DownloadFromGPUTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::DownloadFromGPUTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCopyPass.html">GPUCopyPass</a>&#160;</td>
          <td class="paramname"><em>copy_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga0a4272ec9f67111e0956cfe1f999f903">GPUTextureRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga62c3161f89c494e71fef4b8bbd471167">GPUTextureTransferInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This data is not guaranteed to be copied until the command buffer fence is signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy_pass</td><td>a copy pass handle. </td></tr>
    <tr><td class="paramname">source</td><td>the source texture region. </td></tr>
    <tr><td class="paramname">destination</td><td>the destination transfer buffer with image layout information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga350647db0f6c39ab4556bc767eb9da69" name="ga350647db0f6c39ab4556bc767eb9da69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga350647db0f6c39ab4556bc767eb9da69">&#9670;&#160;</a></span>DownloadFromTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUCopyPass::DownloadFromTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga0a4272ec9f67111e0956cfe1f999f903">GPUTextureRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga62c3161f89c494e71fef4b8bbd471167">GPUTextureTransferInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This data is not guaranteed to be copied until the command buffer fence is signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the source texture region. </td></tr>
    <tr><td class="paramname">destination</td><td>the destination transfer buffer with image layout information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga578daf1145105b76ff31a4a60feadab4" name="ga578daf1145105b76ff31a4a60feadab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga578daf1145105b76ff31a4a60feadab4">&#9670;&#160;</a></span>DrawGPUIndexedPrimitives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::DrawGPUIndexedPrimitives </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a>&#160;</td>
          <td class="paramname"><em>render_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>num_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>num_instances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga52ae1b7d45c9c8e49e98cd479de3694b">Sint32</a>&#160;</td>
          <td class="paramname"><em>vertex_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must not call this function before binding a graphics pipeline.</p>
<p>Note that the <code>first_vertex</code> and <code>first_instance</code> parameters are NOT compatible with built-in vertex/instance ID variables in shaders (for example, SV_VertexID); GPU APIs and shader languages do not define these built-in variables consistently, so if your shader depends on them, the only way to keep behavior consistent and portable is to always pass 0 for the correlating parameter in the draw calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">render_pass</td><td>a render pass handle. </td></tr>
    <tr><td class="paramname">num_indices</td><td>the number of indices to draw per instance. </td></tr>
    <tr><td class="paramname">num_instances</td><td>the number of instances to draw. </td></tr>
    <tr><td class="paramname">first_index</td><td>the starting index within the index buffer. </td></tr>
    <tr><td class="paramname">vertex_offset</td><td>value added to vertex index before indexing into the vertex buffer. </td></tr>
    <tr><td class="paramname">first_instance</td><td>the ID of the first instance to draw.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga0efcc5015ac05357634ac54b0b0764a3" name="ga0efcc5015ac05357634ac54b0b0764a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0efcc5015ac05357634ac54b0b0764a3">&#9670;&#160;</a></span>DrawGPUIndexedPrimitivesIndirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::DrawGPUIndexedPrimitivesIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a>&#160;</td>
          <td class="paramname"><em>render_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>draw_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The buffer must consist of tightly-packed draw parameter sets that each match the layout of GPUIndexedIndirectDrawCommand. You must not call this function before binding a graphics pipeline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">render_pass</td><td>a render pass handle. </td></tr>
    <tr><td class="paramname">buffer</td><td>a buffer containing draw parameters. </td></tr>
    <tr><td class="paramname">offset</td><td>the offset to start reading from the draw buffer. </td></tr>
    <tr><td class="paramname">draw_count</td><td>the number of draw parameter sets that should be read from the draw buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga3341d213cb8161e362fa2b749d4e1bee" name="ga3341d213cb8161e362fa2b749d4e1bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3341d213cb8161e362fa2b749d4e1bee">&#9670;&#160;</a></span>DrawGPUPrimitives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::DrawGPUPrimitives </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a>&#160;</td>
          <td class="paramname"><em>render_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>num_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>num_instances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must not call this function before binding a graphics pipeline.</p>
<p>Note that the <code>first_vertex</code> and <code>first_instance</code> parameters are NOT compatible with built-in vertex/instance ID variables in shaders (for example, SV_VertexID); GPU APIs and shader languages do not define these built-in variables consistently, so if your shader depends on them, the only way to keep behavior consistent and portable is to always pass 0 for the correlating parameter in the draw calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">render_pass</td><td>a render pass handle. </td></tr>
    <tr><td class="paramname">num_vertices</td><td>the number of vertices to draw. </td></tr>
    <tr><td class="paramname">num_instances</td><td>the number of instances that will be drawn. </td></tr>
    <tr><td class="paramname">first_vertex</td><td>the index of the first vertex to draw. </td></tr>
    <tr><td class="paramname">first_instance</td><td>the ID of the first instance to draw.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gabf0a88c6a42f9c08a8f3abb610eeda94" name="gabf0a88c6a42f9c08a8f3abb610eeda94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf0a88c6a42f9c08a8f3abb610eeda94">&#9670;&#160;</a></span>DrawGPUPrimitivesIndirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::DrawGPUPrimitivesIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a>&#160;</td>
          <td class="paramname"><em>render_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>draw_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The buffer must consist of tightly-packed draw parameter sets that each match the layout of GPUIndirectDrawCommand. You must not call this function before binding a graphics pipeline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">render_pass</td><td>a render pass handle. </td></tr>
    <tr><td class="paramname">buffer</td><td>a buffer containing draw parameters. </td></tr>
    <tr><td class="paramname">offset</td><td>the offset to start reading from the draw buffer. </td></tr>
    <tr><td class="paramname">draw_count</td><td>the number of draw parameter sets that should be read from the draw buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga1b313e7ad8440bc9c9f54dd6623862eb" name="ga1b313e7ad8440bc9c9f54dd6623862eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b313e7ad8440bc9c9f54dd6623862eb">&#9670;&#160;</a></span>DrawIndexedPrimitives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPURenderPass::DrawIndexedPrimitives </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>num_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>num_instances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga52ae1b7d45c9c8e49e98cd479de3694b">Sint32</a>&#160;</td>
          <td class="paramname"><em>vertex_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must not call this function before binding a graphics pipeline.</p>
<p>Note that the <code>first_vertex</code> and <code>first_instance</code> parameters are NOT compatible with built-in vertex/instance ID variables in shaders (for example, SV_VertexID); GPU APIs and shader languages do not define these built-in variables consistently, so if your shader depends on them, the only way to keep behavior consistent and portable is to always pass 0 for the correlating parameter in the draw calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_indices</td><td>the number of indices to draw per instance. </td></tr>
    <tr><td class="paramname">num_instances</td><td>the number of instances to draw. </td></tr>
    <tr><td class="paramname">first_index</td><td>the starting index within the index buffer. </td></tr>
    <tr><td class="paramname">vertex_offset</td><td>value added to vertex index before indexing into the vertex buffer. </td></tr>
    <tr><td class="paramname">first_instance</td><td>the ID of the first instance to draw.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gafef162b6d49f6d172616026fbc1d5b37" name="gafef162b6d49f6d172616026fbc1d5b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafef162b6d49f6d172616026fbc1d5b37">&#9670;&#160;</a></span>DrawIndexedPrimitivesIndirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPURenderPass::DrawIndexedPrimitivesIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>draw_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The buffer must consist of tightly-packed draw parameter sets that each match the layout of GPUIndexedIndirectDrawCommand. You must not call this function before binding a graphics pipeline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>a buffer containing draw parameters. </td></tr>
    <tr><td class="paramname">offset</td><td>the offset to start reading from the draw buffer. </td></tr>
    <tr><td class="paramname">draw_count</td><td>the number of draw parameter sets that should be read from the draw buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaee46a464d450edc057c4a1fa60adf855" name="gaee46a464d450edc057c4a1fa60adf855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee46a464d450edc057c4a1fa60adf855">&#9670;&#160;</a></span>DrawPrimitives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPURenderPass::DrawPrimitives </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>num_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>num_instances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>first_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must not call this function before binding a graphics pipeline.</p>
<p>Note that the <code>first_vertex</code> and <code>first_instance</code> parameters are NOT compatible with built-in vertex/instance ID variables in shaders (for example, SV_VertexID); GPU APIs and shader languages do not define these built-in variables consistently, so if your shader depends on them, the only way to keep behavior consistent and portable is to always pass 0 for the correlating parameter in the draw calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_vertices</td><td>the number of vertices to draw. </td></tr>
    <tr><td class="paramname">num_instances</td><td>the number of instances that will be drawn. </td></tr>
    <tr><td class="paramname">first_vertex</td><td>the index of the first vertex to draw. </td></tr>
    <tr><td class="paramname">first_instance</td><td>the ID of the first instance to draw.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga4cad31422505ada85f19d81536dfe3d9" name="ga4cad31422505ada85f19d81536dfe3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cad31422505ada85f19d81536dfe3d9">&#9670;&#160;</a></span>DrawPrimitivesIndirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPURenderPass::DrawPrimitivesIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>draw_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The buffer must consist of tightly-packed draw parameter sets that each match the layout of GPUIndirectDrawCommand. You must not call this function before binding a graphics pipeline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>a buffer containing draw parameters. </td></tr>
    <tr><td class="paramname">offset</td><td>the offset to start reading from the draw buffer. </td></tr>
    <tr><td class="paramname">draw_count</td><td>the number of draw parameter sets that should be read from the draw buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga93da9193744c70e7d6334440a676b787" name="ga93da9193744c70e7d6334440a676b787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93da9193744c70e7d6334440a676b787">&#9670;&#160;</a></span>End() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPURenderPass::End </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All bound graphics state on the render pass command buffer is unset. The render pass handle is now invalid.</p>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga7419495ee08e074491b534155cee2daf" name="ga7419495ee08e074491b534155cee2daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7419495ee08e074491b534155cee2daf">&#9670;&#160;</a></span>End() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUComputePass::End </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All bound compute state on the command buffer is unset. The compute pass handle is now invalid.</p>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gad28427a5325d9cc29c8082e64266b439" name="gad28427a5325d9cc29c8082e64266b439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad28427a5325d9cc29c8082e64266b439">&#9670;&#160;</a></span>End() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUCopyPass::End </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gafefae079a574d32c9eb4bada0bb8b0af" name="gafefae079a574d32c9eb4bada0bb8b0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafefae079a574d32c9eb4bada0bb8b0af">&#9670;&#160;</a></span>EndGPUComputePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::EndGPUComputePass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUComputePass.html">GPUComputePass</a>&#160;</td>
          <td class="paramname"><em>compute_pass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All bound compute state on the command buffer is unset. The compute pass handle is now invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compute_pass</td><td>a compute pass handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gae173376011ce271f5b16c8e930f70278" name="gae173376011ce271f5b16c8e930f70278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae173376011ce271f5b16c8e930f70278">&#9670;&#160;</a></span>EndGPUCopyPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::EndGPUCopyPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCopyPass.html">GPUCopyPass</a>&#160;</td>
          <td class="paramname"><em>copy_pass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy_pass</td><td>a copy pass handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gadadcc498dce398aba2c8d25329eeda38" name="gadadcc498dce398aba2c8d25329eeda38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadadcc498dce398aba2c8d25329eeda38">&#9670;&#160;</a></span>EndGPURenderPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::EndGPURenderPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a>&#160;</td>
          <td class="paramname"><em>render_pass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All bound graphics state on the render pass command buffer is unset. The render pass handle is now invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">render_pass</td><td>a render pass handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaa7e8c2e454131a5bf3fa6a52a862148f" name="gaa7e8c2e454131a5bf3fa6a52a862148f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7e8c2e454131a5bf3fa6a52a862148f">&#9670;&#160;</a></span>GenerateMipmapsForGPUTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GenerateMipmapsForGPUTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a>&#160;</td>
          <td class="paramname"><em>command_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a>&#160;</td>
          <td class="paramname"><em>texture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function must not be called inside of any pass.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command_buffer</td><td>a command_buffer. </td></tr>
    <tr><td class="paramname">texture</td><td>a texture with more than 1 mip level.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga997464b8389a61a692d34b935ef2cf42" name="ga997464b8389a61a692d34b935ef2cf42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga997464b8389a61a692d34b935ef2cf42">&#9670;&#160;</a></span>GenerateMipmapsForTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUCommandBuffer::GenerateMipmapsForTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a>&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function must not be called inside of any pass.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>a texture with more than 1 mip level.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga09208b4ab434b99ecd69c1640179fde6" name="ga09208b4ab434b99ecd69c1640179fde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09208b4ab434b99ecd69c1640179fde6">&#9670;&#160;</a></span>GetDriver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * SDL::GPUDevice::GetDriver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the name of the device's driver, or nullptr on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gacdd791b8144a50de53cea149befdba56" name="gacdd791b8144a50de53cea149befdba56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdd791b8144a50de53cea149befdba56">&#9670;&#160;</a></span>GetGPUDeviceDriver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * SDL::GetGPUDeviceDriver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the device's driver, or nullptr on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gac383aba530619d3c849e9801dc9a2f53" name="gac383aba530619d3c849e9801dc9a2f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac383aba530619d3c849e9801dc9a2f53">&#9670;&#160;</a></span>GetGPUDriver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * SDL::GetGPUDriver </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The GPU drivers are presented in the order in which they are normally checked during initialization.</p>
<p>The names of drivers are all simple, low-ASCII identifiers, like "vulkan", "metal" or "direct3d12". These never have Unicode characters, and are not meant to be proper names.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of a GPU driver. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the GPU driver with the given <b>index</b>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga096a87a2e48b07cba15df9e0ba0f9780" title="Get the number of GPU drivers compiled into SDL.">GetNumGPUDrivers</a> </dd></dl>

</div>
</div>
<a id="ga025bda7fe5d6157650ec1912b0f03107" name="ga025bda7fe5d6157650ec1912b0f03107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga025bda7fe5d6157650ec1912b0f03107">&#9670;&#160;</a></span>GetGPUShaderFormats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">GPUShaderFormat</a> SDL::GetGPUShaderFormats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a bitflag indicating which shader formats the driver is able to consume.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gac1bb6fdbd568ea6168038e6499d8e632" name="gac1bb6fdbd568ea6168038e6499d8e632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1bb6fdbd568ea6168038e6499d8e632">&#9670;&#160;</a></span>GetGPUSwapchainTextureFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GetGPUSwapchainTextureFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a>&#160;</td>
          <td class="paramname"><em>window</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Note that this format can change if the swapchain parameters change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
    <tr><td class="paramname">window</td><td>an <a class="el" href="classSDL_1_1Window.html" title="The struct used as an opaque handle to a window.">Window</a> that has been claimed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the texture format of the swapchain.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga096a87a2e48b07cba15df9e0ba0f9780" name="ga096a87a2e48b07cba15df9e0ba0f9780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga096a87a2e48b07cba15df9e0ba0f9780">&#9670;&#160;</a></span>GetNumGPUDrivers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::GetNumGPUDrivers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of built in GPU drivers.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gac383aba530619d3c849e9801dc9a2f53" title="Get the name of a built in GPU driver.">GetGPUDriver</a> </dd></dl>

</div>
</div>
<a id="gaf82030e566bd87483a83fac84210f0e0" name="gaf82030e566bd87483a83fac84210f0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf82030e566bd87483a83fac84210f0e0">&#9670;&#160;</a></span>GetShaderFormats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">GPUShaderFormat</a> SDL::GPUDevice::GetShaderFormats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a bitflag indicating which shader formats the driver is able to consume.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga60fd2d6f6ed10654c13640b212c79e95" name="ga60fd2d6f6ed10654c13640b212c79e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60fd2d6f6ed10654c13640b212c79e95">&#9670;&#160;</a></span>GetSwapchainTextureFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPUDevice::GetSwapchainTextureFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a>&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Note that this format can change if the swapchain parameters change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>an <a class="el" href="classSDL_1_1Window.html" title="The struct used as an opaque handle to a window.">Window</a> that has been claimed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the texture format of the swapchain.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gadd98f2a7bff0b2815bf2da41ddf4a1c7" name="gadd98f2a7bff0b2815bf2da41ddf4a1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd98f2a7bff0b2815bf2da41ddf4a1c7">&#9670;&#160;</a></span>GPUSupportsProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::GPUSupportsProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1PropertiesParam.html">PropertiesParam</a>&#160;</td>
          <td class="paramname"><em>props</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">props</td><td>the properties to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if supported, false otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUDevice.html#a9fde3883d9146abd2533f4882d233906" title="Default ctor.">GPUDevice.GPUDevice</a> </dd></dl>

</div>
</div>
<a id="gae97816ef9ed10b7e29d52a0bbeb929c6" name="gae97816ef9ed10b7e29d52a0bbeb929c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae97816ef9ed10b7e29d52a0bbeb929c6">&#9670;&#160;</a></span>GPUSupportsShaderFormats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::GPUSupportsShaderFormats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">GPUShaderFormat</a>&#160;</td>
          <td class="paramname"><em>format_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format_flags</td><td>a bitflag indicating which shader formats the app is able to provide. </td></tr>
    <tr><td class="paramname">name</td><td>the preferred GPU driver, or nullptr to let <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> pick the optimal driver. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if supported, false otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUDevice.html#a9fde3883d9146abd2533f4882d233906" title="Default ctor.">GPUDevice.GPUDevice</a> </dd></dl>

</div>
</div>
<a id="ga37d622cd71737704ced8c1217b1a4649" name="ga37d622cd71737704ced8c1217b1a4649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37d622cd71737704ced8c1217b1a4649">&#9670;&#160;</a></span>GPUTextureFormatTexelBlockSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> SDL::GPUTextureFormatTexelBlockSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>the texture format you want to know the texel size of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the texel block size of the texture format.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gab5b7ed8fb63a9d190521a0618214b2c2" title="Uploads data from a transfer buffer to a texture.">GPUCopyPass.UploadToTexture</a> </dd></dl>

</div>
</div>
<a id="ga37105d1a38c1a2fa8f2b7b799e71ec11" name="ga37105d1a38c1a2fa8f2b7b799e71ec11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37105d1a38c1a2fa8f2b7b799e71ec11">&#9670;&#160;</a></span>GPUTextureSupportsFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::GPUTextureSupportsFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#ga624b29173aac1a009aa85c14f46024a3">GPUTextureType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#ga5a847c301baaf527c8ba644f0f55a59e">GPUTextureUsageFlags</a>&#160;</td>
          <td class="paramname"><em>usage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
    <tr><td class="paramname">format</td><td>the texture format to check. </td></tr>
    <tr><td class="paramname">type</td><td>the type of texture (2D, 3D, Cube). </td></tr>
    <tr><td class="paramname">usage</td><td>a bitmask of all usage scenarios to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the texture format is supported for this type and usage.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga1ce3b9c81c56935f7be1ee15444f1165" name="ga1ce3b9c81c56935f7be1ee15444f1165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ce3b9c81c56935f7be1ee15444f1165">&#9670;&#160;</a></span>GPUTextureSupportsSampleCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::GPUTextureSupportsSampleCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#ga5265d3385d1ddc106c614016bee759d9">GPUSampleCount</a>&#160;</td>
          <td class="paramname"><em>sample_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
    <tr><td class="paramname">format</td><td>the texture format to check. </td></tr>
    <tr><td class="paramname">sample_count</td><td>the sample count to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the sample count is supported for this texture format.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gac5bf0e54cbed9dd35cfce8a28d834663" name="gac5bf0e54cbed9dd35cfce8a28d834663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5bf0e54cbed9dd35cfce8a28d834663">&#9670;&#160;</a></span>InsertDebugLabel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUCommandBuffer::InsertDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Useful for debugging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>a UTF-8 string constant to insert as the label.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gadf1179d3f9d5290ebe54fb1837efb5be" name="gadf1179d3f9d5290ebe54fb1837efb5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf1179d3f9d5290ebe54fb1837efb5be">&#9670;&#160;</a></span>InsertGPUDebugLabel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::InsertGPUDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a>&#160;</td>
          <td class="paramname"><em>command_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Useful for debugging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command_buffer</td><td>a command buffer. </td></tr>
    <tr><td class="paramname">text</td><td>a UTF-8 string constant to insert as the label.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gabdb58fe754b9754fc7767bfacd6853cb" name="gabdb58fe754b9754fc7767bfacd6853cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdb58fe754b9754fc7767bfacd6853cb">&#9670;&#160;</a></span>MapGPUTransferBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::MapGPUTransferBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUTransferBuffer.html">GPUTransferBuffer</a>&#160;</td>
          <td class="paramname"><em>transfer_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cycle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must unmap the transfer buffer before encoding upload commands. The memory is owned by the graphics driver - do NOT call <a class="el" href="group__CategoryStdinc.html#gadfa01257ca1f966fffb72f002db27fa6" title="Free allocated memory.">free()</a> on the returned pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
    <tr><td class="paramname">transfer_buffer</td><td>a transfer buffer. </td></tr>
    <tr><td class="paramname">cycle</td><td>if true, cycles the transfer buffer if it is already bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the mapped transfer buffer memory, or nullptr on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga1cf97fcd43dd972f87051ba4b3d6ebec" name="ga1cf97fcd43dd972f87051ba4b3d6ebec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cf97fcd43dd972f87051ba4b3d6ebec">&#9670;&#160;</a></span>MapTransferBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::GPUDevice::MapTransferBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUTransferBuffer.html">GPUTransferBuffer</a>&#160;</td>
          <td class="paramname"><em>transfer_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cycle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must unmap the transfer buffer before encoding upload commands. The memory is owned by the graphics driver - do NOT call <a class="el" href="group__CategoryStdinc.html#gadfa01257ca1f966fffb72f002db27fa6" title="Free allocated memory.">free()</a> on the returned pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer_buffer</td><td>a transfer buffer. </td></tr>
    <tr><td class="paramname">cycle</td><td>if true, cycles the transfer buffer if it is already bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the mapped transfer buffer memory, or nullptr on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gab5b665b341039657de084915adf4a720" name="gab5b665b341039657de084915adf4a720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5b665b341039657de084915adf4a720">&#9670;&#160;</a></span>PopDebugGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUCommandBuffer::PopDebugGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gae97164be3b0fb5e9566f8db2d3d46015" title="Begins a debug group with an arbitrary name.">GPUCommandBuffer.PushDebugGroup</a> </dd></dl>

</div>
</div>
<a id="gafb51e49130f6b17dc6ff82e7a2824ceb" name="gafb51e49130f6b17dc6ff82e7a2824ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb51e49130f6b17dc6ff82e7a2824ceb">&#9670;&#160;</a></span>PopGPUDebugGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::PopGPUDebugGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a>&#160;</td>
          <td class="paramname"><em>command_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command_buffer</td><td>a command buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gae97164be3b0fb5e9566f8db2d3d46015" title="Begins a debug group with an arbitrary name.">GPUCommandBuffer.PushDebugGroup</a> </dd></dl>

</div>
</div>
<a id="ga03d49babc2c6fcf28f0591bc31cc5d83" name="ga03d49babc2c6fcf28f0591bc31cc5d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03d49babc2c6fcf28f0591bc31cc5d83">&#9670;&#160;</a></span>PushComputeUniformData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUCommandBuffer::PushComputeUniformData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>slot_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1SourceBytes.html">SourceBytes</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subsequent draw calls will use this uniform data.</p>
<p>The data being pushed must respect std140 layout conventions. In practical terms this means you must ensure that vec3 and vec4 fields are 16-byte aligned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot_index</td><td>the uniform slot to push data to. </td></tr>
    <tr><td class="paramname">data</td><td>client data to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gae97164be3b0fb5e9566f8db2d3d46015" name="gae97164be3b0fb5e9566f8db2d3d46015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae97164be3b0fb5e9566f8db2d3d46015">&#9670;&#160;</a></span>PushDebugGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUCommandBuffer::PushDebugGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used for denoting groups of calls when viewing the command buffer callstream in a graphics debugging tool.</p>
<p>Each call to <a class="el" href="group__CategoryGPU.html#gae97164be3b0fb5e9566f8db2d3d46015" title="Begins a debug group with an arbitrary name.">GPUCommandBuffer.PushDebugGroup</a> must have a corresponding call to <a class="el" href="group__CategoryGPU.html#gab5b665b341039657de084915adf4a720" title="Ends the most-recently pushed debug group.">GPUCommandBuffer.PopDebugGroup</a>.</p>
<p>On some backends (e.g. Metal), pushing a debug group during a render/blit/compute pass will create a group that is scoped to the native pass rather than the command buffer. For best results, if you push a debug group during a pass, always pop it in the same pass.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a UTF-8 string constant that names the group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gab5b665b341039657de084915adf4a720" title="Ends the most-recently pushed debug group.">GPUCommandBuffer.PopDebugGroup</a> </dd></dl>

</div>
</div>
<a id="gaa1376bc7dc6bf928fcba014e6de7f7e8" name="gaa1376bc7dc6bf928fcba014e6de7f7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1376bc7dc6bf928fcba014e6de7f7e8">&#9670;&#160;</a></span>PushFragmentUniformData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUCommandBuffer::PushFragmentUniformData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>slot_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1SourceBytes.html">SourceBytes</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subsequent draw calls will use this uniform data.</p>
<p>The data being pushed must respect std140 layout conventions. In practical terms this means you must ensure that vec3 and vec4 fields are 16-byte aligned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot_index</td><td>the fragment uniform slot to push data to. </td></tr>
    <tr><td class="paramname">data</td><td>client data to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaa39d284c1bb4c7c3615cbd3a09db921e" name="gaa39d284c1bb4c7c3615cbd3a09db921e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa39d284c1bb4c7c3615cbd3a09db921e">&#9670;&#160;</a></span>PushGPUComputeUniformData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::PushGPUComputeUniformData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a>&#160;</td>
          <td class="paramname"><em>command_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>slot_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1SourceBytes.html">SourceBytes</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subsequent draw calls will use this uniform data.</p>
<p>The data being pushed must respect std140 layout conventions. In practical terms this means you must ensure that vec3 and vec4 fields are 16-byte aligned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command_buffer</td><td>a command buffer. </td></tr>
    <tr><td class="paramname">slot_index</td><td>the uniform slot to push data to. </td></tr>
    <tr><td class="paramname">data</td><td>client data to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga1ca15527eab7b27fc215704a88363a1c" name="ga1ca15527eab7b27fc215704a88363a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ca15527eab7b27fc215704a88363a1c">&#9670;&#160;</a></span>PushGPUDebugGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::PushGPUDebugGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a>&#160;</td>
          <td class="paramname"><em>command_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used for denoting groups of calls when viewing the command buffer callstream in a graphics debugging tool.</p>
<p>Each call to <a class="el" href="group__CategoryGPU.html#gae97164be3b0fb5e9566f8db2d3d46015" title="Begins a debug group with an arbitrary name.">GPUCommandBuffer.PushDebugGroup</a> must have a corresponding call to <a class="el" href="group__CategoryGPU.html#gab5b665b341039657de084915adf4a720" title="Ends the most-recently pushed debug group.">GPUCommandBuffer.PopDebugGroup</a>.</p>
<p>On some backends (e.g. Metal), pushing a debug group during a render/blit/compute pass will create a group that is scoped to the native pass rather than the command buffer. For best results, if you push a debug group during a pass, always pop it in the same pass.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command_buffer</td><td>a command buffer. </td></tr>
    <tr><td class="paramname">name</td><td>a UTF-8 string constant that names the group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gab5b665b341039657de084915adf4a720" title="Ends the most-recently pushed debug group.">GPUCommandBuffer.PopDebugGroup</a> </dd></dl>

</div>
</div>
<a id="ga097fb8be416be0911835d10cabf3d938" name="ga097fb8be416be0911835d10cabf3d938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga097fb8be416be0911835d10cabf3d938">&#9670;&#160;</a></span>PushGPUFragmentUniformData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::PushGPUFragmentUniformData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a>&#160;</td>
          <td class="paramname"><em>command_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>slot_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1SourceBytes.html">SourceBytes</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subsequent draw calls will use this uniform data.</p>
<p>The data being pushed must respect std140 layout conventions. In practical terms this means you must ensure that vec3 and vec4 fields are 16-byte aligned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command_buffer</td><td>a command buffer. </td></tr>
    <tr><td class="paramname">slot_index</td><td>the fragment uniform slot to push data to. </td></tr>
    <tr><td class="paramname">data</td><td>client data to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga9c1354e8b92832a9e74b5c013e1781c5" name="ga9c1354e8b92832a9e74b5c013e1781c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c1354e8b92832a9e74b5c013e1781c5">&#9670;&#160;</a></span>PushGPUVertexUniformData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::PushGPUVertexUniformData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a>&#160;</td>
          <td class="paramname"><em>command_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>slot_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1SourceBytes.html">SourceBytes</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subsequent draw calls will use this uniform data.</p>
<p>The data being pushed must respect std140 layout conventions. In practical terms this means you must ensure that vec3 and vec4 fields are 16-byte aligned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command_buffer</td><td>a command buffer. </td></tr>
    <tr><td class="paramname">slot_index</td><td>the vertex uniform slot to push data to. </td></tr>
    <tr><td class="paramname">data</td><td>client data to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaa57c6b82ad0455dbdcf7fe87e3a15199" name="gaa57c6b82ad0455dbdcf7fe87e3a15199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa57c6b82ad0455dbdcf7fe87e3a15199">&#9670;&#160;</a></span>PushVertexUniformData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUCommandBuffer::PushVertexUniformData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>slot_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1SourceBytes.html">SourceBytes</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subsequent draw calls will use this uniform data.</p>
<p>The data being pushed must respect std140 layout conventions. In practical terms this means you must ensure that vec3 and vec4 fields are 16-byte aligned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot_index</td><td>the vertex uniform slot to push data to. </td></tr>
    <tr><td class="paramname">data</td><td>client data to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga498070ef88a1e82416556cb7f1ef0e67" name="ga498070ef88a1e82416556cb7f1ef0e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga498070ef88a1e82416556cb7f1ef0e67">&#9670;&#160;</a></span>QueryFence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::GPUDevice::QueryFence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#gaeb64f32b16e58d8fcfc1baf718975d3b">GPUFence</a> *&#160;</td>
          <td class="paramname"><em>fence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fence</td><td>a fence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the fence is signaled, false if it is not.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gad610ad628240f1b49aaa7eaec0ccd271" title="Submits a command buffer so its commands can be processed on the GPU, and acquires a fence associated...">GPUCommandBuffer.SubmitAndAcquireFence</a> </dd></dl>

</div>
</div>
<a id="ga522264abe3e3fd6f0b86b656e5373a64" name="ga522264abe3e3fd6f0b86b656e5373a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga522264abe3e3fd6f0b86b656e5373a64">&#9670;&#160;</a></span>QueryGPUFence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::QueryGPUFence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#gaeb64f32b16e58d8fcfc1baf718975d3b">GPUFence</a> *&#160;</td>
          <td class="paramname"><em>fence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
    <tr><td class="paramname">fence</td><td>a fence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the fence is signaled, false if it is not.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gad610ad628240f1b49aaa7eaec0ccd271" title="Submits a command buffer so its commands can be processed on the GPU, and acquires a fence associated...">GPUCommandBuffer.SubmitAndAcquireFence</a> </dd></dl>

</div>
</div>
<a id="gab5dc66c265218b99bb458030cac57723" name="gab5dc66c265218b99bb458030cac57723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5dc66c265218b99bb458030cac57723">&#9670;&#160;</a></span>ReleaseBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUDevice::ReleaseBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must not reference the buffer after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>a buffer to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga4c669ef6c9ab4c71b8ef7834e7a39975" name="ga4c669ef6c9ab4c71b8ef7834e7a39975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c669ef6c9ab4c71b8ef7834e7a39975">&#9670;&#160;</a></span>ReleaseComputePipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUDevice::ReleaseComputePipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUComputePipeline.html">GPUComputePipeline</a>&#160;</td>
          <td class="paramname"><em>compute_pipeline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must not reference the compute pipeline after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compute_pipeline</td><td>a compute pipeline to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga63f199ccc1f91e8540c423b82555e186" name="ga63f199ccc1f91e8540c423b82555e186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63f199ccc1f91e8540c423b82555e186">&#9670;&#160;</a></span>ReleaseFence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUDevice::ReleaseFence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#gaeb64f32b16e58d8fcfc1baf718975d3b">GPUFence</a> *&#160;</td>
          <td class="paramname"><em>fence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must not reference the fence after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fence</td><td>a fence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gad610ad628240f1b49aaa7eaec0ccd271" title="Submits a command buffer so its commands can be processed on the GPU, and acquires a fence associated...">GPUCommandBuffer.SubmitAndAcquireFence</a> </dd></dl>

</div>
</div>
<a id="gaa9e53b951df3be7cc4df709ab9292248" name="gaa9e53b951df3be7cc4df709ab9292248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9e53b951df3be7cc4df709ab9292248">&#9670;&#160;</a></span>ReleaseGPUBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::ReleaseGPUBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must not reference the buffer after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
    <tr><td class="paramname">buffer</td><td>a buffer to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga40091a14557e718733af0c0e46fb8dca" name="ga40091a14557e718733af0c0e46fb8dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40091a14557e718733af0c0e46fb8dca">&#9670;&#160;</a></span>ReleaseGPUComputePipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::ReleaseGPUComputePipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUComputePipeline.html">GPUComputePipeline</a>&#160;</td>
          <td class="paramname"><em>compute_pipeline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must not reference the compute pipeline after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
    <tr><td class="paramname">compute_pipeline</td><td>a compute pipeline to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga38b295d480145fdff3b9033032b182c2" name="ga38b295d480145fdff3b9033032b182c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38b295d480145fdff3b9033032b182c2">&#9670;&#160;</a></span>ReleaseGPUFence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::ReleaseGPUFence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#gaeb64f32b16e58d8fcfc1baf718975d3b">GPUFence</a> *&#160;</td>
          <td class="paramname"><em>fence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must not reference the fence after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
    <tr><td class="paramname">fence</td><td>a fence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gad610ad628240f1b49aaa7eaec0ccd271" title="Submits a command buffer so its commands can be processed on the GPU, and acquires a fence associated...">GPUCommandBuffer.SubmitAndAcquireFence</a> </dd></dl>

</div>
</div>
<a id="ga8780f11c5723998ac9724abb17805a14" name="ga8780f11c5723998ac9724abb17805a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8780f11c5723998ac9724abb17805a14">&#9670;&#160;</a></span>ReleaseGPUGraphicsPipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::ReleaseGPUGraphicsPipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html">GPUGraphicsPipeline</a>&#160;</td>
          <td class="paramname"><em>graphics_pipeline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must not reference the graphics pipeline after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
    <tr><td class="paramname">graphics_pipeline</td><td>a graphics pipeline to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga1cc4888d0473c9fe59f287f633bc0a48" name="ga1cc4888d0473c9fe59f287f633bc0a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cc4888d0473c9fe59f287f633bc0a48">&#9670;&#160;</a></span>ReleaseGPUSampler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::ReleaseGPUSampler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUSampler.html">GPUSampler</a>&#160;</td>
          <td class="paramname"><em>sampler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must not reference the sampler after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
    <tr><td class="paramname">sampler</td><td>a sampler to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gab7476f92df93eb6268e3bc7fee41a4dd" name="gab7476f92df93eb6268e3bc7fee41a4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7476f92df93eb6268e3bc7fee41a4dd">&#9670;&#160;</a></span>ReleaseGPUShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::ReleaseGPUShader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUShader.html">GPUShader</a>&#160;</td>
          <td class="paramname"><em>shader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must not reference the shader after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
    <tr><td class="paramname">shader</td><td>a shader to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaa0a0743470c177313845bca7b6b5c70f" name="gaa0a0743470c177313845bca7b6b5c70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0a0743470c177313845bca7b6b5c70f">&#9670;&#160;</a></span>ReleaseGPUTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::ReleaseGPUTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a>&#160;</td>
          <td class="paramname"><em>texture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must not reference the texture after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
    <tr><td class="paramname">texture</td><td>a texture to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaec1587e6b22a0ff93cd6b8887381507d" name="gaec1587e6b22a0ff93cd6b8887381507d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec1587e6b22a0ff93cd6b8887381507d">&#9670;&#160;</a></span>ReleaseGPUTransferBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::ReleaseGPUTransferBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUTransferBuffer.html">GPUTransferBuffer</a>&#160;</td>
          <td class="paramname"><em>transfer_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must not reference the transfer buffer after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
    <tr><td class="paramname">transfer_buffer</td><td>a transfer buffer to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gad3c154a75ac11895cf331e4d32796ea0" name="gad3c154a75ac11895cf331e4d32796ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3c154a75ac11895cf331e4d32796ea0">&#9670;&#160;</a></span>ReleaseGraphicsPipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUDevice::ReleaseGraphicsPipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUGraphicsPipeline.html">GPUGraphicsPipeline</a>&#160;</td>
          <td class="paramname"><em>graphics_pipeline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must not reference the graphics pipeline after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graphics_pipeline</td><td>a graphics pipeline to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga69f056178de21168997a6554cbc27c1e" name="ga69f056178de21168997a6554cbc27c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69f056178de21168997a6554cbc27c1e">&#9670;&#160;</a></span>ReleaseSampler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUDevice::ReleaseSampler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUSampler.html">GPUSampler</a>&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must not reference the sampler after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampler</td><td>a sampler to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga1a193a6c5e5396d8b09aeadaf537fdec" name="ga1a193a6c5e5396d8b09aeadaf537fdec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a193a6c5e5396d8b09aeadaf537fdec">&#9670;&#160;</a></span>ReleaseShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUDevice::ReleaseShader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUShader.html">GPUShader</a>&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must not reference the shader after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shader</td><td>a shader to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga95ea4befed403fa9c10298c547c9b95e" name="ga95ea4befed403fa9c10298c547c9b95e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95ea4befed403fa9c10298c547c9b95e">&#9670;&#160;</a></span>ReleaseTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUDevice::ReleaseTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a>&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must not reference the texture after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>a texture to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga1a709128809970cdde83691bb4a5b040" name="ga1a709128809970cdde83691bb4a5b040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a709128809970cdde83691bb4a5b040">&#9670;&#160;</a></span>ReleaseTransferBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUDevice::ReleaseTransferBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUTransferBuffer.html">GPUTransferBuffer</a>&#160;</td>
          <td class="paramname"><em>transfer_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must not reference the transfer buffer after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer_buffer</td><td>a transfer buffer to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga85c7fbccab856044a026f2fcdd157cad" name="ga85c7fbccab856044a026f2fcdd157cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85c7fbccab856044a026f2fcdd157cad">&#9670;&#160;</a></span>ReleaseWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUDevice::ReleaseWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a>&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>an <a class="el" href="classSDL_1_1Window.html" title="The struct used as an opaque handle to a window.">Window</a> that has been claimed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gacbc4104e7cefaaccaf221b4938dacdd9" title="Claims a window, creating a swapchain structure for it.">GPUDevice.ClaimWindow</a> </dd></dl>

</div>
</div>
<a id="ga4d8a04f7c1bbc5de4c5e62977c4777cb" name="ga4d8a04f7c1bbc5de4c5e62977c4777cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d8a04f7c1bbc5de4c5e62977c4777cb">&#9670;&#160;</a></span>ReleaseWindowFromGPUDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::ReleaseWindowFromGPUDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a>&#160;</td>
          <td class="paramname"><em>window</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
    <tr><td class="paramname">window</td><td>an <a class="el" href="classSDL_1_1Window.html" title="The struct used as an opaque handle to a window.">Window</a> that has been claimed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gacbc4104e7cefaaccaf221b4938dacdd9" title="Claims a window, creating a swapchain structure for it.">GPUDevice.ClaimWindow</a> </dd></dl>

</div>
</div>
<a id="ga18c2598a4f6a749a04b5505520b70a0c" name="ga18c2598a4f6a749a04b5505520b70a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18c2598a4f6a749a04b5505520b70a0c">&#9670;&#160;</a></span>SetAllowedFramesInFlight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::GPUDevice::SetAllowedFramesInFlight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>allowed_frames_in_flight</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default value when the device is created is 2. This means that after you have submitted 2 frames for presentation, if the GPU has not finished working on the first frame, <a class="el" href="group__CategoryGPU.html#gaa9098e2e6b7139a3af4973e47b4f7d9e" title="Acquire a texture to use in presentation.">GPUCommandBuffer.AcquireSwapchainTexture()</a> will fill the swapchain texture pointer with nullptr, and <a class="el" href="group__CategoryGPU.html#gae4234ed0ab6264374493b9b6cb07c770" title="Blocks the thread until a swapchain texture is available to be acquired, and then acquires it.">GPUCommandBuffer.WaitAndAcquireSwapchainTexture()</a> will block.</p>
<p>Higher values increase throughput at the expense of visual latency. Lower values decrease visual latency at the expense of throughput.</p>
<p>Note that calling this function will stall and flush the command queue to prevent synchronization issues.</p>
<p>The minimum value of allowed frames in flight is 1, and the maximum is 3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allowed_frames_in_flight</td><td>the maximum number of frames that can be pending on the GPU. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false on error; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gab98b11b475384dcc4f5a306583d819af" name="gab98b11b475384dcc4f5a306583d819af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab98b11b475384dcc4f5a306583d819af">&#9670;&#160;</a></span>SetBlendConstants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPURenderPass::SetBlendConstants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryPixels.html#gadfaf5b77d5957860167740c745343e4e">FColorRaw</a>&#160;</td>
          <td class="paramname"><em>blend_constants</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend_constants</td><td>the blend constant color.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga691377c0b575938da07e1e22feea96f6" title="blend constant">GPU_BLENDFACTOR_CONSTANT_COLOR</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga230f63d8e98833b4bde8f8500c07c57f" title="1 - blend constant">GPU_BLENDFACTOR_ONE_MINUS_CONSTANT_COLOR</a> </dd></dl>

</div>
</div>
<a id="ga9f2208b408ff8e8d01504687eb27ad9d" name="ga9f2208b408ff8e8d01504687eb27ad9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f2208b408ff8e8d01504687eb27ad9d">&#9670;&#160;</a></span>SetBufferName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUDevice::SetBufferName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You should use prop::GPUBuffer.CREATE_NAME_STRING with <a class="el" href="classSDL_1_1GPUBuffer.html#af5e9803e82a340e2fb9a39197f8ea839" title="Wraps GPUBuffer.">GPUBuffer.GPUBuffer</a> instead of this function to avoid thread safety issues.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>a buffer to attach the name to. </td></tr>
    <tr><td class="paramname">text</td><td>a UTF-8 string constant to mark as the name of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe, you must make sure the buffer is not simultaneously used by any other thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUBuffer.html#af5e9803e82a340e2fb9a39197f8ea839" title="Wraps GPUBuffer.">GPUBuffer.GPUBuffer</a> </dd></dl>

</div>
</div>
<a id="gae33e829c160d187e5798e197c4329bca" name="gae33e829c160d187e5798e197c4329bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae33e829c160d187e5798e197c4329bca">&#9670;&#160;</a></span>SetGPUAllowedFramesInFlight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::SetGPUAllowedFramesInFlight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>allowed_frames_in_flight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default value when the device is created is 2. This means that after you have submitted 2 frames for presentation, if the GPU has not finished working on the first frame, <a class="el" href="group__CategoryGPU.html#gaa9098e2e6b7139a3af4973e47b4f7d9e" title="Acquire a texture to use in presentation.">GPUCommandBuffer.AcquireSwapchainTexture()</a> will fill the swapchain texture pointer with nullptr, and <a class="el" href="group__CategoryGPU.html#gae4234ed0ab6264374493b9b6cb07c770" title="Blocks the thread until a swapchain texture is available to be acquired, and then acquires it.">GPUCommandBuffer.WaitAndAcquireSwapchainTexture()</a> will block.</p>
<p>Higher values increase throughput at the expense of visual latency. Lower values decrease visual latency at the expense of throughput.</p>
<p>Note that calling this function will stall and flush the command queue to prevent synchronization issues.</p>
<p>The minimum value of allowed frames in flight is 1, and the maximum is 3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
    <tr><td class="paramname">allowed_frames_in_flight</td><td>the maximum number of frames that can be pending on the GPU. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false on error; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gace75858cd83969cec098f543e6c26bf4" name="gace75858cd83969cec098f543e6c26bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace75858cd83969cec098f543e6c26bf4">&#9670;&#160;</a></span>SetGPUBlendConstants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::SetGPUBlendConstants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a>&#160;</td>
          <td class="paramname"><em>render_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryPixels.html#gadfaf5b77d5957860167740c745343e4e">FColorRaw</a>&#160;</td>
          <td class="paramname"><em>blend_constants</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">render_pass</td><td>a render pass handle. </td></tr>
    <tr><td class="paramname">blend_constants</td><td>the blend constant color.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga691377c0b575938da07e1e22feea96f6" title="blend constant">GPU_BLENDFACTOR_CONSTANT_COLOR</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga230f63d8e98833b4bde8f8500c07c57f" title="1 - blend constant">GPU_BLENDFACTOR_ONE_MINUS_CONSTANT_COLOR</a> </dd></dl>

</div>
</div>
<a id="ga1d086a0646edf1f73d758e2a350e6ce0" name="ga1d086a0646edf1f73d758e2a350e6ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d086a0646edf1f73d758e2a350e6ce0">&#9670;&#160;</a></span>SetGPUBufferName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::SetGPUBufferName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUBuffer.html">GPUBuffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You should use prop::GPUBuffer.CREATE_NAME_STRING with <a class="el" href="classSDL_1_1GPUBuffer.html#af5e9803e82a340e2fb9a39197f8ea839" title="Wraps GPUBuffer.">GPUBuffer.GPUBuffer</a> instead of this function to avoid thread safety issues.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU Context. </td></tr>
    <tr><td class="paramname">buffer</td><td>a buffer to attach the name to. </td></tr>
    <tr><td class="paramname">text</td><td>a UTF-8 string constant to mark as the name of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe, you must make sure the buffer is not simultaneously used by any other thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUBuffer.html#af5e9803e82a340e2fb9a39197f8ea839" title="Wraps GPUBuffer.">GPUBuffer.GPUBuffer</a> </dd></dl>

</div>
</div>
<a id="gaef421368adf50fa00376de4978643d31" name="gaef421368adf50fa00376de4978643d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef421368adf50fa00376de4978643d31">&#9670;&#160;</a></span>SetGPUScissor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::SetGPUScissor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a>&#160;</td>
          <td class="paramname"><em>render_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryRect.html#gadeb77054b31c63a38d6594652fb0b7f4">RectRaw</a> &amp;&#160;</td>
          <td class="paramname"><em>scissor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">render_pass</td><td>a render pass handle. </td></tr>
    <tr><td class="paramname">scissor</td><td>the scissor area to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga7839d651b14a4e9b7e338929dc1c49e3" name="ga7839d651b14a4e9b7e338929dc1c49e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7839d651b14a4e9b7e338929dc1c49e3">&#9670;&#160;</a></span>SetGPUStencilReference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::SetGPUStencilReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a>&#160;</td>
          <td class="paramname"><em>render_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gadeddb36a6d67c5bc92003dd7679b4b17">Uint8</a>&#160;</td>
          <td class="paramname"><em>reference</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">render_pass</td><td>a render pass handle. </td></tr>
    <tr><td class="paramname">reference</td><td>the stencil reference value to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga6747a3be03c0833106ec543f63625176" name="ga6747a3be03c0833106ec543f63625176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6747a3be03c0833106ec543f63625176">&#9670;&#160;</a></span>SetGPUSwapchainParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::SetGPUSwapchainParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a>&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#gaa555f571dd4b1b9e5af82ee607a71fc5">GPUSwapchainComposition</a>&#160;</td>
          <td class="paramname"><em>swapchain_composition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#ga695f2e29e8b1cc9061a08a95ae9690e5">GPUPresentMode</a>&#160;</td>
          <td class="paramname"><em>present_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will fail if the requested present mode or swapchain composition are unsupported by the device. Check if the parameters are supported via <a class="el" href="group__CategoryGPU.html#gaeb189dcc6f70c6584763e72987ad1ec5" title="Determines whether a presentation mode is supported by the window.">GPUDevice.WindowSupportsPresentMode</a> / <a class="el" href="group__CategoryGPU.html#ga80eb2cbcd952006b3f129cbd6ebe44c7" title="Determines whether a swapchain composition is supported by the window.">GPUDevice.WindowSupportsSwapchainComposition</a> prior to calling this function.</p>
<p>GPU_PRESENTMODE_VSYNC with GPU_SWAPCHAINCOMPOSITION_SDR are always supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
    <tr><td class="paramname">window</td><td>an <a class="el" href="classSDL_1_1Window.html" title="The struct used as an opaque handle to a window.">Window</a> that has been claimed. </td></tr>
    <tr><td class="paramname">swapchain_composition</td><td>the desired composition of the swapchain. </td></tr>
    <tr><td class="paramname">present_mode</td><td>the desired present mode for the swapchain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false on error; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gaeb189dcc6f70c6584763e72987ad1ec5" title="Determines whether a presentation mode is supported by the window.">GPUDevice.WindowSupportsPresentMode</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga80eb2cbcd952006b3f129cbd6ebe44c7" title="Determines whether a swapchain composition is supported by the window.">GPUDevice.WindowSupportsSwapchainComposition</a> </dd></dl>

</div>
</div>
<a id="ga3701961d411ec57410c58c1e7e3512ab" name="ga3701961d411ec57410c58c1e7e3512ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3701961d411ec57410c58c1e7e3512ab">&#9670;&#160;</a></span>SetGPUTextureName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::SetGPUTextureName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a>&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You should use prop::GPUTexture.CREATE_NAME_STRING with <a class="el" href="classSDL_1_1GPUTexture.html#a275899ad3f4afee497cd31161f61cffa" title="Wraps GPUTexture.">GPUTexture.GPUTexture</a> instead of this function to avoid thread safety issues.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU Context. </td></tr>
    <tr><td class="paramname">texture</td><td>a texture to attach the name to. </td></tr>
    <tr><td class="paramname">text</td><td>a UTF-8 string constant to mark as the name of the texture.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe, you must make sure the texture is not simultaneously used by any other thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUTexture.html#a275899ad3f4afee497cd31161f61cffa" title="Wraps GPUTexture.">GPUTexture.GPUTexture</a> </dd></dl>

</div>
</div>
<a id="ga22bacd025df5958ae85ec37519de23a4" name="ga22bacd025df5958ae85ec37519de23a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22bacd025df5958ae85ec37519de23a4">&#9670;&#160;</a></span>SetGPUViewport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::SetGPUViewport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPURenderPass.html">GPURenderPass</a>&#160;</td>
          <td class="paramname"><em>render_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#gaf80d3281c271f2f02de8d8e14648fe20">GPUViewport</a> &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">render_pass</td><td>a render pass handle. </td></tr>
    <tr><td class="paramname">viewport</td><td>the viewport to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga24da70f6b4278e527620189088a99a6c" name="ga24da70f6b4278e527620189088a99a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24da70f6b4278e527620189088a99a6c">&#9670;&#160;</a></span>SetScissor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPURenderPass::SetScissor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CategoryRect.html#gadeb77054b31c63a38d6594652fb0b7f4">RectRaw</a> &amp;&#160;</td>
          <td class="paramname"><em>scissor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scissor</td><td>the scissor area to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga40077d8ac37cc564db0a696bd0c32b91" name="ga40077d8ac37cc564db0a696bd0c32b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40077d8ac37cc564db0a696bd0c32b91">&#9670;&#160;</a></span>SetStencilReference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPURenderPass::SetStencilReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gadeddb36a6d67c5bc92003dd7679b4b17">Uint8</a>&#160;</td>
          <td class="paramname"><em>reference</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference</td><td>the stencil reference value to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga8d862f6cb8aee49dcac4907349d9a186" name="ga8d862f6cb8aee49dcac4907349d9a186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d862f6cb8aee49dcac4907349d9a186">&#9670;&#160;</a></span>SetSwapchainParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::GPUDevice::SetSwapchainParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a>&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#gaa555f571dd4b1b9e5af82ee607a71fc5">GPUSwapchainComposition</a>&#160;</td>
          <td class="paramname"><em>swapchain_composition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#ga695f2e29e8b1cc9061a08a95ae9690e5">GPUPresentMode</a>&#160;</td>
          <td class="paramname"><em>present_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will fail if the requested present mode or swapchain composition are unsupported by the device. Check if the parameters are supported via <a class="el" href="group__CategoryGPU.html#gaeb189dcc6f70c6584763e72987ad1ec5" title="Determines whether a presentation mode is supported by the window.">GPUDevice.WindowSupportsPresentMode</a> / <a class="el" href="group__CategoryGPU.html#ga80eb2cbcd952006b3f129cbd6ebe44c7" title="Determines whether a swapchain composition is supported by the window.">GPUDevice.WindowSupportsSwapchainComposition</a> prior to calling this function.</p>
<p>GPU_PRESENTMODE_VSYNC with GPU_SWAPCHAINCOMPOSITION_SDR are always supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>an <a class="el" href="classSDL_1_1Window.html" title="The struct used as an opaque handle to a window.">Window</a> that has been claimed. </td></tr>
    <tr><td class="paramname">swapchain_composition</td><td>the desired composition of the swapchain. </td></tr>
    <tr><td class="paramname">present_mode</td><td>the desired present mode for the swapchain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false on error; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gaeb189dcc6f70c6584763e72987ad1ec5" title="Determines whether a presentation mode is supported by the window.">GPUDevice.WindowSupportsPresentMode</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga80eb2cbcd952006b3f129cbd6ebe44c7" title="Determines whether a swapchain composition is supported by the window.">GPUDevice.WindowSupportsSwapchainComposition</a> </dd></dl>

</div>
</div>
<a id="gabce01d5f2ece06d59e630a721241dfe2" name="gabce01d5f2ece06d59e630a721241dfe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabce01d5f2ece06d59e630a721241dfe2">&#9670;&#160;</a></span>SetTextureName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUDevice::SetTextureName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a>&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You should use prop::GPUTexture.CREATE_NAME_STRING with <a class="el" href="classSDL_1_1GPUTexture.html#a275899ad3f4afee497cd31161f61cffa" title="Wraps GPUTexture.">GPUTexture.GPUTexture</a> instead of this function to avoid thread safety issues.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>a texture to attach the name to. </td></tr>
    <tr><td class="paramname">text</td><td>a UTF-8 string constant to mark as the name of the texture.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe, you must make sure the texture is not simultaneously used by any other thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1GPUTexture.html#a275899ad3f4afee497cd31161f61cffa" title="Wraps GPUTexture.">GPUTexture.GPUTexture</a> </dd></dl>

</div>
</div>
<a id="ga5dca24a164e094b5a9959e3e96872be1" name="ga5dca24a164e094b5a9959e3e96872be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dca24a164e094b5a9959e3e96872be1">&#9670;&#160;</a></span>SetViewport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPURenderPass::SetViewport </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#gaf80d3281c271f2f02de8d8e14648fe20">GPUViewport</a> &amp;&#160;</td>
          <td class="paramname"><em>viewport</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewport</td><td>the viewport to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga673e4e3d3bdfe9596fa05693cbde73b2" name="ga673e4e3d3bdfe9596fa05693cbde73b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga673e4e3d3bdfe9596fa05693cbde73b2">&#9670;&#160;</a></span>Submit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUCommandBuffer::Submit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>It is invalid to use the command buffer after this is called.</p>
<p>This must be called from the thread the command buffer was acquired on.</p>
<p>All commands in the submission are guaranteed to begin executing before any command in a subsequent submission begins executing.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga3afecf456819388452c8af3797f84547" title="Acquire a command buffer.">GPUDevice.AcquireCommandBuffer</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gae4234ed0ab6264374493b9b6cb07c770" title="Blocks the thread until a swapchain texture is available to be acquired, and then acquires it.">GPUCommandBuffer.WaitAndAcquireSwapchainTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gaa9098e2e6b7139a3af4973e47b4f7d9e" title="Acquire a texture to use in presentation.">GPUCommandBuffer.AcquireSwapchainTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gad610ad628240f1b49aaa7eaec0ccd271" title="Submits a command buffer so its commands can be processed on the GPU, and acquires a fence associated...">GPUCommandBuffer.SubmitAndAcquireFence</a> </dd></dl>

</div>
</div>
<a id="gad610ad628240f1b49aaa7eaec0ccd271" name="gad610ad628240f1b49aaa7eaec0ccd271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad610ad628240f1b49aaa7eaec0ccd271">&#9670;&#160;</a></span>SubmitAndAcquireFence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategoryGPU.html#gaeb64f32b16e58d8fcfc1baf718975d3b">GPUFence</a> * SDL::GPUCommandBuffer::SubmitAndAcquireFence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must release this fence when it is no longer needed or it will cause a leak. It is invalid to use the command buffer after this is called.</p>
<p>This must be called from the thread the command buffer was acquired on.</p>
<p>All commands in the submission are guaranteed to begin executing before any command in a subsequent submission begins executing.</p>
<dl class="section return"><dt>Returns</dt><dd>a fence associated with the command buffer, or nullptr on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga3afecf456819388452c8af3797f84547" title="Acquire a command buffer.">GPUDevice.AcquireCommandBuffer</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gae4234ed0ab6264374493b9b6cb07c770" title="Blocks the thread until a swapchain texture is available to be acquired, and then acquires it.">GPUCommandBuffer.WaitAndAcquireSwapchainTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gaa9098e2e6b7139a3af4973e47b4f7d9e" title="Acquire a texture to use in presentation.">GPUCommandBuffer.AcquireSwapchainTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga673e4e3d3bdfe9596fa05693cbde73b2" title="Submits a command buffer so its commands can be processed on the GPU.">GPUCommandBuffer.Submit</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga63f199ccc1f91e8540c423b82555e186" title="Releases a fence obtained from GPUCommandBuffer.SubmitAndAcquireFence.">GPUDevice.ReleaseFence</a> </dd></dl>

</div>
</div>
<a id="gaf02465fef670ff039324bbcb7dff3ea9" name="gaf02465fef670ff039324bbcb7dff3ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf02465fef670ff039324bbcb7dff3ea9">&#9670;&#160;</a></span>SubmitGPUCommandBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::SubmitGPUCommandBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a>&#160;</td>
          <td class="paramname"><em>command_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>It is invalid to use the command buffer after this is called.</p>
<p>This must be called from the thread the command buffer was acquired on.</p>
<p>All commands in the submission are guaranteed to begin executing before any command in a subsequent submission begins executing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command_buffer</td><td>a command buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga3afecf456819388452c8af3797f84547" title="Acquire a command buffer.">GPUDevice.AcquireCommandBuffer</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gae4234ed0ab6264374493b9b6cb07c770" title="Blocks the thread until a swapchain texture is available to be acquired, and then acquires it.">GPUCommandBuffer.WaitAndAcquireSwapchainTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gaa9098e2e6b7139a3af4973e47b4f7d9e" title="Acquire a texture to use in presentation.">GPUCommandBuffer.AcquireSwapchainTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gad610ad628240f1b49aaa7eaec0ccd271" title="Submits a command buffer so its commands can be processed on the GPU, and acquires a fence associated...">GPUCommandBuffer.SubmitAndAcquireFence</a> </dd></dl>

</div>
</div>
<a id="ga12c61d85c573ea886f0abdef6c88a301" name="ga12c61d85c573ea886f0abdef6c88a301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12c61d85c573ea886f0abdef6c88a301">&#9670;&#160;</a></span>SubmitGPUCommandBufferAndAcquireFence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategoryGPU.html#gaeb64f32b16e58d8fcfc1baf718975d3b">GPUFence</a> * SDL::SubmitGPUCommandBufferAndAcquireFence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a>&#160;</td>
          <td class="paramname"><em>command_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You must release this fence when it is no longer needed or it will cause a leak. It is invalid to use the command buffer after this is called.</p>
<p>This must be called from the thread the command buffer was acquired on.</p>
<p>All commands in the submission are guaranteed to begin executing before any command in a subsequent submission begins executing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command_buffer</td><td>a command buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a fence associated with the command buffer, or nullptr on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga3afecf456819388452c8af3797f84547" title="Acquire a command buffer.">GPUDevice.AcquireCommandBuffer</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gae4234ed0ab6264374493b9b6cb07c770" title="Blocks the thread until a swapchain texture is available to be acquired, and then acquires it.">GPUCommandBuffer.WaitAndAcquireSwapchainTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gaa9098e2e6b7139a3af4973e47b4f7d9e" title="Acquire a texture to use in presentation.">GPUCommandBuffer.AcquireSwapchainTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga673e4e3d3bdfe9596fa05693cbde73b2" title="Submits a command buffer so its commands can be processed on the GPU.">GPUCommandBuffer.Submit</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga63f199ccc1f91e8540c423b82555e186" title="Releases a fence obtained from GPUCommandBuffer.SubmitAndAcquireFence.">GPUDevice.ReleaseFence</a> </dd></dl>

</div>
</div>
<a id="ga24dbdaadc509ba8acd1fb2689449c133" name="ga24dbdaadc509ba8acd1fb2689449c133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24dbdaadc509ba8acd1fb2689449c133">&#9670;&#160;</a></span>TextureSupportsFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::GPUDevice::TextureSupportsFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#ga624b29173aac1a009aa85c14f46024a3">GPUTextureType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#ga5a847c301baaf527c8ba644f0f55a59e">GPUTextureUsageFlags</a>&#160;</td>
          <td class="paramname"><em>usage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>the texture format to check. </td></tr>
    <tr><td class="paramname">type</td><td>the type of texture (2D, 3D, Cube). </td></tr>
    <tr><td class="paramname">usage</td><td>a bitmask of all usage scenarios to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the texture format is supported for this type and usage.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gac85fa5adda9fa49df12b8a85f98e67a9" name="gac85fa5adda9fa49df12b8a85f98e67a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac85fa5adda9fa49df12b8a85f98e67a9">&#9670;&#160;</a></span>TextureSupportsSampleCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::GPUDevice::TextureSupportsSampleCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#ga5265d3385d1ddc106c614016bee759d9">GPUSampleCount</a>&#160;</td>
          <td class="paramname"><em>sample_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>the texture format to check. </td></tr>
    <tr><td class="paramname">sample_count</td><td>the sample count to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the sample count is supported for this texture format.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga8365ac3dbab1c09786dfccf76573a4fd" name="ga8365ac3dbab1c09786dfccf76573a4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8365ac3dbab1c09786dfccf76573a4fd">&#9670;&#160;</a></span>UnmapGPUTransferBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::UnmapGPUTransferBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUTransferBuffer.html">GPUTransferBuffer</a>&#160;</td>
          <td class="paramname"><em>transfer_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
    <tr><td class="paramname">transfer_buffer</td><td>a previously mapped transfer buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga69ee23a532fc7ab5ed15480500de6b0e" name="ga69ee23a532fc7ab5ed15480500de6b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69ee23a532fc7ab5ed15480500de6b0e">&#9670;&#160;</a></span>UnmapTransferBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUDevice::UnmapTransferBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUTransferBuffer.html">GPUTransferBuffer</a>&#160;</td>
          <td class="paramname"><em>transfer_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer_buffer</td><td>a previously mapped transfer buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga49c5fe1ce14d954d818e0510c7ee875c" name="ga49c5fe1ce14d954d818e0510c7ee875c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49c5fe1ce14d954d818e0510c7ee875c">&#9670;&#160;</a></span>UploadToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUCopyPass::UploadToBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga9faa5600aabe5cabf35cbdf09851af6d">GPUTransferBufferLocation</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#gac3310186554cb88f7b1a1599171aabdf">GPUBufferRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cycle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The upload occurs on the GPU timeline. You may assume that the upload has finished in subsequent commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the source transfer buffer with offset. </td></tr>
    <tr><td class="paramname">destination</td><td>the destination buffer with offset and size. </td></tr>
    <tr><td class="paramname">cycle</td><td>if true, cycles the buffer if it is already bound, otherwise overwrites the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaa37913aaeb02cefd9a1bdf894a994765" name="gaa37913aaeb02cefd9a1bdf894a994765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa37913aaeb02cefd9a1bdf894a994765">&#9670;&#160;</a></span>UploadToGPUBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::UploadToGPUBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCopyPass.html">GPUCopyPass</a>&#160;</td>
          <td class="paramname"><em>copy_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga9faa5600aabe5cabf35cbdf09851af6d">GPUTransferBufferLocation</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#gac3310186554cb88f7b1a1599171aabdf">GPUBufferRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cycle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The upload occurs on the GPU timeline. You may assume that the upload has finished in subsequent commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy_pass</td><td>a copy pass handle. </td></tr>
    <tr><td class="paramname">source</td><td>the source transfer buffer with offset. </td></tr>
    <tr><td class="paramname">destination</td><td>the destination buffer with offset and size. </td></tr>
    <tr><td class="paramname">cycle</td><td>if true, cycles the buffer if it is already bound, otherwise overwrites the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga89ada8c30a3597bb6f0ebb6a1c2c669d" name="ga89ada8c30a3597bb6f0ebb6a1c2c669d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89ada8c30a3597bb6f0ebb6a1c2c669d">&#9670;&#160;</a></span>UploadToGPUTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::UploadToGPUTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCopyPass.html">GPUCopyPass</a>&#160;</td>
          <td class="paramname"><em>copy_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga62c3161f89c494e71fef4b8bbd471167">GPUTextureTransferInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga0a4272ec9f67111e0956cfe1f999f903">GPUTextureRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cycle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The upload occurs on the GPU timeline. You may assume that the upload has finished in subsequent commands.</p>
<p>You must align the data in the transfer buffer to a multiple of the texel size of the texture format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy_pass</td><td>a copy pass handle. </td></tr>
    <tr><td class="paramname">source</td><td>the source transfer buffer with image layout information. </td></tr>
    <tr><td class="paramname">destination</td><td>the destination texture region. </td></tr>
    <tr><td class="paramname">cycle</td><td>if true, cycles the texture if the texture is bound, otherwise overwrites the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gab5b7ed8fb63a9d190521a0618214b2c2" name="gab5b7ed8fb63a9d190521a0618214b2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5b7ed8fb63a9d190521a0618214b2c2">&#9670;&#160;</a></span>UploadToTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUCopyPass::UploadToTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga62c3161f89c494e71fef4b8bbd471167">GPUTextureTransferInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryGPU.html#ga0a4272ec9f67111e0956cfe1f999f903">GPUTextureRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cycle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The upload occurs on the GPU timeline. You may assume that the upload has finished in subsequent commands.</p>
<p>You must align the data in the transfer buffer to a multiple of the texel size of the texture format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the source transfer buffer with image layout information. </td></tr>
    <tr><td class="paramname">destination</td><td>the destination texture region. </td></tr>
    <tr><td class="paramname">cycle</td><td>if true, cycles the texture if the texture is bound, otherwise overwrites the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga0981f23794ee1e41ecece8727766e692" name="ga0981f23794ee1e41ecece8727766e692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0981f23794ee1e41ecece8727766e692">&#9670;&#160;</a></span>WaitAndAcquireGPUSwapchainTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a> SDL::WaitAndAcquireGPUSwapchainTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1GPUCommandBuffer.html">GPUCommandBuffer</a>&#160;</td>
          <td class="paramname"><em>command_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a>&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> *&#160;</td>
          <td class="paramname"><em>swapchain_texture_width</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> *&#160;</td>
          <td class="paramname"><em>swapchain_texture_height</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When a swapchain texture is acquired on a command buffer, it will automatically be submitted for presentation when the command buffer is submitted. The swapchain texture should only be referenced by the command buffer used to acquire it. It is an error to call <a class="el" href="group__CategoryGPU.html#ga3bfdeb35856182f070ef0a146a47997a" title="Cancels a command buffer.">GPUCommandBuffer.Cancel()</a> after a swapchain texture is acquired.</p>
<p>This function can fill the swapchain texture handle with nullptr in certain cases, for example if the window is minimized. This is not an error. You should always make sure to check whether the pointer is nullptr before actually using it.</p>
<p>The swapchain texture is managed by the implementation and must not be freed by the user. You MUST NOT call this function from any thread other than the one that created the window.</p>
<p>The swapchain texture is write-only and cannot be used as a sampler or for another reading operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command_buffer</td><td>a command buffer. </td></tr>
    <tr><td class="paramname">window</td><td>a window that has been claimed. </td></tr>
    <tr><td class="paramname">swapchain_texture_width</td><td>a pointer filled in with the swapchain texture width, may be nullptr. </td></tr>
    <tr><td class="paramname">swapchain_texture_height</td><td>a pointer filled in with the swapchain texture height, may be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a swapchain texture handle. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called from the thread that created the window.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga673e4e3d3bdfe9596fa05693cbde73b2" title="Submits a command buffer so its commands can be processed on the GPU.">GPUCommandBuffer.Submit</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gad610ad628240f1b49aaa7eaec0ccd271" title="Submits a command buffer so its commands can be processed on the GPU, and acquires a fence associated...">GPUCommandBuffer.SubmitAndAcquireFence</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gaa9098e2e6b7139a3af4973e47b4f7d9e" title="Acquire a texture to use in presentation.">GPUCommandBuffer.AcquireSwapchainTexture</a> </dd></dl>

</div>
</div>
<a id="gae4234ed0ab6264374493b9b6cb07c770" name="gae4234ed0ab6264374493b9b6cb07c770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4234ed0ab6264374493b9b6cb07c770">&#9670;&#160;</a></span>WaitAndAcquireSwapchainTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1GPUTexture.html">GPUTexture</a> SDL::GPUCommandBuffer::WaitAndAcquireSwapchainTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a>&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> *&#160;</td>
          <td class="paramname"><em>swapchain_texture_width</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> *&#160;</td>
          <td class="paramname"><em>swapchain_texture_height</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When a swapchain texture is acquired on a command buffer, it will automatically be submitted for presentation when the command buffer is submitted. The swapchain texture should only be referenced by the command buffer used to acquire it. It is an error to call <a class="el" href="group__CategoryGPU.html#ga3bfdeb35856182f070ef0a146a47997a" title="Cancels a command buffer.">GPUCommandBuffer.Cancel()</a> after a swapchain texture is acquired.</p>
<p>This function can fill the swapchain texture handle with nullptr in certain cases, for example if the window is minimized. This is not an error. You should always make sure to check whether the pointer is nullptr before actually using it.</p>
<p>The swapchain texture is managed by the implementation and must not be freed by the user. You MUST NOT call this function from any thread other than the one that created the window.</p>
<p>The swapchain texture is write-only and cannot be used as a sampler or for another reading operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>a window that has been claimed. </td></tr>
    <tr><td class="paramname">swapchain_texture_width</td><td>a pointer filled in with the swapchain texture width, may be nullptr. </td></tr>
    <tr><td class="paramname">swapchain_texture_height</td><td>a pointer filled in with the swapchain texture height, may be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a swapchain texture handle. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called from the thread that created the window.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga673e4e3d3bdfe9596fa05693cbde73b2" title="Submits a command buffer so its commands can be processed on the GPU.">GPUCommandBuffer.Submit</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gad610ad628240f1b49aaa7eaec0ccd271" title="Submits a command buffer so its commands can be processed on the GPU, and acquires a fence associated...">GPUCommandBuffer.SubmitAndAcquireFence</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gaa9098e2e6b7139a3af4973e47b4f7d9e" title="Acquire a texture to use in presentation.">GPUCommandBuffer.AcquireSwapchainTexture</a> </dd></dl>

</div>
</div>
<a id="ga0f8ec966ab858d2d3ae91a1b6f61f420" name="ga0f8ec966ab858d2d3ae91a1b6f61f420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f8ec966ab858d2d3ae91a1b6f61f420">&#9670;&#160;</a></span>WaitForFences()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUDevice::WaitForFences </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait_all</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; <a class="el" href="group__CategoryGPU.html#gaeb64f32b16e58d8fcfc1baf718975d3b">GPUFence</a> *const &gt;&#160;</td>
          <td class="paramname"><em>fences</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wait_all</td><td>if 0, wait for any fence to be signaled, if 1, wait for all fences to be signaled. </td></tr>
    <tr><td class="paramname">fences</td><td>an array of fences to wait on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gad610ad628240f1b49aaa7eaec0ccd271" title="Submits a command buffer so its commands can be processed on the GPU, and acquires a fence associated...">GPUCommandBuffer.SubmitAndAcquireFence</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gad76143dc3095e35133fb14f2229faac8" title="Blocks the thread until the GPU is completely idle.">GPUDevice.WaitForIdle</a> </dd></dl>

</div>
</div>
<a id="gabef2c73881dead5403eb1ea024faa9ea" name="gabef2c73881dead5403eb1ea024faa9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabef2c73881dead5403eb1ea024faa9ea">&#9670;&#160;</a></span>WaitForGPUFences()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::WaitForGPUFences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait_all</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; <a class="el" href="group__CategoryGPU.html#gaeb64f32b16e58d8fcfc1baf718975d3b">GPUFence</a> *const &gt;&#160;</td>
          <td class="paramname"><em>fences</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
    <tr><td class="paramname">wait_all</td><td>if 0, wait for any fence to be signaled, if 1, wait for all fences to be signaled. </td></tr>
    <tr><td class="paramname">fences</td><td>an array of fences to wait on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gad610ad628240f1b49aaa7eaec0ccd271" title="Submits a command buffer so its commands can be processed on the GPU, and acquires a fence associated...">GPUCommandBuffer.SubmitAndAcquireFence</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gad76143dc3095e35133fb14f2229faac8" title="Blocks the thread until the GPU is completely idle.">GPUDevice.WaitForIdle</a> </dd></dl>

</div>
</div>
<a id="gadcd0f36650628136d8a5ed3aa7cd47e0" name="gadcd0f36650628136d8a5ed3aa7cd47e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcd0f36650628136d8a5ed3aa7cd47e0">&#9670;&#160;</a></span>WaitForGPUIdle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::WaitForGPUIdle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga0f8ec966ab858d2d3ae91a1b6f61f420" title="Blocks the thread until the given fences are signaled.">GPUDevice.WaitForFences</a> </dd></dl>

</div>
</div>
<a id="gab29626a894a352577739da2930ac2756" name="gab29626a894a352577739da2930ac2756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab29626a894a352577739da2930ac2756">&#9670;&#160;</a></span>WaitForGPUSwapchain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::WaitForGPUSwapchain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a>&#160;</td>
          <td class="paramname"><em>window</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
    <tr><td class="paramname">window</td><td>a window that has been claimed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called from the thread that created the window.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gaa9098e2e6b7139a3af4973e47b4f7d9e" title="Acquire a texture to use in presentation.">GPUCommandBuffer.AcquireSwapchainTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gae4234ed0ab6264374493b9b6cb07c770" title="Blocks the thread until a swapchain texture is available to be acquired, and then acquires it.">GPUCommandBuffer.WaitAndAcquireSwapchainTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga18c2598a4f6a749a04b5505520b70a0c" title="Configures the maximum allowed number of frames in flight.">GPUDevice.SetAllowedFramesInFlight</a> </dd></dl>

</div>
</div>
<a id="gad76143dc3095e35133fb14f2229faac8" name="gad76143dc3095e35133fb14f2229faac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad76143dc3095e35133fb14f2229faac8">&#9670;&#160;</a></span>WaitForIdle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUDevice::WaitForIdle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#ga0f8ec966ab858d2d3ae91a1b6f61f420" title="Blocks the thread until the given fences are signaled.">GPUDevice.WaitForFences</a> </dd></dl>

</div>
</div>
<a id="ga787c44fa9026ae09bf8a3d9deaebcde6" name="ga787c44fa9026ae09bf8a3d9deaebcde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga787c44fa9026ae09bf8a3d9deaebcde6">&#9670;&#160;</a></span>WaitForSwapchain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GPUDevice::WaitForSwapchain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a>&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>a window that has been claimed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called from the thread that created the window.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gaa9098e2e6b7139a3af4973e47b4f7d9e" title="Acquire a texture to use in presentation.">GPUCommandBuffer.AcquireSwapchainTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#gae4234ed0ab6264374493b9b6cb07c770" title="Blocks the thread until a swapchain texture is available to be acquired, and then acquires it.">GPUCommandBuffer.WaitAndAcquireSwapchainTexture</a> </dd>
<dd>
<a class="el" href="group__CategoryGPU.html#ga18c2598a4f6a749a04b5505520b70a0c" title="Configures the maximum allowed number of frames in flight.">GPUDevice.SetAllowedFramesInFlight</a> </dd></dl>

</div>
</div>
<a id="gadacc63a189cf4d0bec8e06b4d6e6d00c" name="gadacc63a189cf4d0bec8e06b4d6e6d00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadacc63a189cf4d0bec8e06b4d6e6d00c">&#9670;&#160;</a></span>WindowSupportsGPUPresentMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::WindowSupportsGPUPresentMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a>&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#ga695f2e29e8b1cc9061a08a95ae9690e5">GPUPresentMode</a>&#160;</td>
          <td class="paramname"><em>present_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The window must be claimed before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
    <tr><td class="paramname">window</td><td>an <a class="el" href="classSDL_1_1Window.html" title="The struct used as an opaque handle to a window.">Window</a>. </td></tr>
    <tr><td class="paramname">present_mode</td><td>the presentation mode to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if supported, false if unsupported.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gacbc4104e7cefaaccaf221b4938dacdd9" title="Claims a window, creating a swapchain structure for it.">GPUDevice.ClaimWindow</a> </dd></dl>

</div>
</div>
<a id="ga904f586db6ff9081c77aa1dcdc4c7c03" name="ga904f586db6ff9081c77aa1dcdc4c7c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga904f586db6ff9081c77aa1dcdc4c7c03">&#9670;&#160;</a></span>WindowSupportsGPUSwapchainComposition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::WindowSupportsGPUSwapchainComposition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1GPUDeviceParam.html">GPUDeviceParam</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a>&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#gaa555f571dd4b1b9e5af82ee607a71fc5">GPUSwapchainComposition</a>&#160;</td>
          <td class="paramname"><em>swapchain_composition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The window must be claimed before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a GPU context. </td></tr>
    <tr><td class="paramname">window</td><td>an <a class="el" href="classSDL_1_1Window.html" title="The struct used as an opaque handle to a window.">Window</a>. </td></tr>
    <tr><td class="paramname">swapchain_composition</td><td>the swapchain composition to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if supported, false if unsupported.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gacbc4104e7cefaaccaf221b4938dacdd9" title="Claims a window, creating a swapchain structure for it.">GPUDevice.ClaimWindow</a> </dd></dl>

</div>
</div>
<a id="gaeb189dcc6f70c6584763e72987ad1ec5" name="gaeb189dcc6f70c6584763e72987ad1ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb189dcc6f70c6584763e72987ad1ec5">&#9670;&#160;</a></span>WindowSupportsPresentMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::GPUDevice::WindowSupportsPresentMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a>&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#ga695f2e29e8b1cc9061a08a95ae9690e5">GPUPresentMode</a>&#160;</td>
          <td class="paramname"><em>present_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The window must be claimed before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>an <a class="el" href="classSDL_1_1Window.html" title="The struct used as an opaque handle to a window.">Window</a>. </td></tr>
    <tr><td class="paramname">present_mode</td><td>the presentation mode to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if supported, false if unsupported.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gacbc4104e7cefaaccaf221b4938dacdd9" title="Claims a window, creating a swapchain structure for it.">GPUDevice.ClaimWindow</a> </dd></dl>

</div>
</div>
<a id="ga80eb2cbcd952006b3f129cbd6ebe44c7" name="ga80eb2cbcd952006b3f129cbd6ebe44c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80eb2cbcd952006b3f129cbd6ebe44c7">&#9670;&#160;</a></span>WindowSupportsSwapchainComposition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::GPUDevice::WindowSupportsSwapchainComposition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1WindowParam.html">WindowParam</a>&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryGPU.html#gaa555f571dd4b1b9e5af82ee607a71fc5">GPUSwapchainComposition</a>&#160;</td>
          <td class="paramname"><em>swapchain_composition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The window must be claimed before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>an <a class="el" href="classSDL_1_1Window.html" title="The struct used as an opaque handle to a window.">Window</a>. </td></tr>
    <tr><td class="paramname">swapchain_composition</td><td>the swapchain composition to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if supported, false if unsupported.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryGPU.html#gacbc4104e7cefaaccaf221b4938dacdd9" title="Claims a window, creating a swapchain structure for it.">GPUDevice.ClaimWindow</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga691377c0b575938da07e1e22feea96f6" name="ga691377c0b575938da07e1e22feea96f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga691377c0b575938da07e1e22feea96f6">&#9670;&#160;</a></span>GPU_BLENDFACTOR_CONSTANT_COLOR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a> SDL::GPU_BLENDFACTOR_CONSTANT_COLOR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_BLENDFACTOR_CONSTANT_COLOR</div>
</div><!-- fragment -->
</div>
</div>
<a id="gafe90828d516454cf5a6a380233e60ce4" name="gafe90828d516454cf5a6a380233e60ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe90828d516454cf5a6a380233e60ce4">&#9670;&#160;</a></span>GPU_BLENDFACTOR_DST_ALPHA</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a> SDL::GPU_BLENDFACTOR_DST_ALPHA</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_BLENDFACTOR_DST_ALPHA</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga4b0e064448a0b4742fc967d118418205" name="ga4b0e064448a0b4742fc967d118418205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b0e064448a0b4742fc967d118418205">&#9670;&#160;</a></span>GPU_BLENDFACTOR_DST_COLOR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a> SDL::GPU_BLENDFACTOR_DST_COLOR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_BLENDFACTOR_DST_COLOR</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaa3f2281c2594325626d8ae26f096bb15" name="gaa3f2281c2594325626d8ae26f096bb15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3f2281c2594325626d8ae26f096bb15">&#9670;&#160;</a></span>GPU_BLENDFACTOR_INVALID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a> SDL::GPU_BLENDFACTOR_INVALID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_BLENDFACTOR_INVALID</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga230f63d8e98833b4bde8f8500c07c57f" name="ga230f63d8e98833b4bde8f8500c07c57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga230f63d8e98833b4bde8f8500c07c57f">&#9670;&#160;</a></span>GPU_BLENDFACTOR_ONE_MINUS_CONSTANT_COLOR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a> SDL::GPU_BLENDFACTOR_ONE_MINUS_CONSTANT_COLOR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_BLENDFACTOR_ONE_MINUS_CONSTANT_COLOR</div>
</div><!-- fragment -->
</div>
</div>
<a id="gac6cf12404134f39fbccb0d3df74e8731" name="gac6cf12404134f39fbccb0d3df74e8731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6cf12404134f39fbccb0d3df74e8731">&#9670;&#160;</a></span>GPU_BLENDFACTOR_ONE_MINUS_DST_ALPHA</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a> SDL::GPU_BLENDFACTOR_ONE_MINUS_DST_ALPHA</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_BLENDFACTOR_ONE_MINUS_DST_ALPHA</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga7bd926f283d262c700178e9c7f6ff404" name="ga7bd926f283d262c700178e9c7f6ff404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bd926f283d262c700178e9c7f6ff404">&#9670;&#160;</a></span>GPU_BLENDFACTOR_ONE_MINUS_DST_COLOR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a> SDL::GPU_BLENDFACTOR_ONE_MINUS_DST_COLOR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_BLENDFACTOR_ONE_MINUS_DST_COLOR</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaf9a68b94d7f267af949e692753b1a349" name="gaf9a68b94d7f267af949e692753b1a349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9a68b94d7f267af949e692753b1a349">&#9670;&#160;</a></span>GPU_BLENDFACTOR_ONE_MINUS_SRC_ALPHA</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a> SDL::GPU_BLENDFACTOR_ONE_MINUS_SRC_ALPHA</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_BLENDFACTOR_ONE_MINUS_SRC_ALPHA</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga6139ba0c241af7cdb4fa79fadee2a791" name="ga6139ba0c241af7cdb4fa79fadee2a791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6139ba0c241af7cdb4fa79fadee2a791">&#9670;&#160;</a></span>GPU_BLENDFACTOR_ONE_MINUS_SRC_COLOR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a> SDL::GPU_BLENDFACTOR_ONE_MINUS_SRC_COLOR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_BLENDFACTOR_ONE_MINUS_SRC_COLOR</div>
</div><!-- fragment -->
</div>
</div>
<a id="gabaeb144a7e02024b191ca4bb7ee15f3f" name="gabaeb144a7e02024b191ca4bb7ee15f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaeb144a7e02024b191ca4bb7ee15f3f">&#9670;&#160;</a></span>GPU_BLENDFACTOR_SRC_ALPHA</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a> SDL::GPU_BLENDFACTOR_SRC_ALPHA</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_BLENDFACTOR_SRC_ALPHA</div>
</div><!-- fragment -->
</div>
</div>
<a id="gac6a75e7ca3b8171035baf6c07a87f922" name="gac6a75e7ca3b8171035baf6c07a87f922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6a75e7ca3b8171035baf6c07a87f922">&#9670;&#160;</a></span>GPU_BLENDFACTOR_SRC_ALPHA_SATURATE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a> SDL::GPU_BLENDFACTOR_SRC_ALPHA_SATURATE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_BLENDFACTOR_SRC_ALPHA_SATURATE</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaa9636bf6d4cadcf0de2ade93bb0f61c7" name="gaa9636bf6d4cadcf0de2ade93bb0f61c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9636bf6d4cadcf0de2ade93bb0f61c7">&#9670;&#160;</a></span>GPU_BLENDFACTOR_SRC_COLOR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga4f1b5cc82a6f49a6cf0644b60bebff89">GPUBlendFactor</a> SDL::GPU_BLENDFACTOR_SRC_COLOR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_BLENDFACTOR_SRC_COLOR</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga54abe011ea0e9a2a45dd686b8aaaf768" name="ga54abe011ea0e9a2a45dd686b8aaaf768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54abe011ea0e9a2a45dd686b8aaaf768">&#9670;&#160;</a></span>GPU_BLENDOP_INVALID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga2a39f40ae7ce461c6ac1918873e4975c">GPUBlendOp</a> SDL::GPU_BLENDOP_INVALID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_BLENDOP_INVALID</div>
</div><!-- fragment -->
</div>
</div>
<a id="gac19b61e01f23131578ebfcefd9130f62" name="gac19b61e01f23131578ebfcefd9130f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac19b61e01f23131578ebfcefd9130f62">&#9670;&#160;</a></span>GPU_BLENDOP_MAX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga2a39f40ae7ce461c6ac1918873e4975c">GPUBlendOp</a> SDL::GPU_BLENDOP_MAX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_BLENDOP_MAX</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga0dc3ea4d27e2ee84e0c3e082445ada7e" name="ga0dc3ea4d27e2ee84e0c3e082445ada7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dc3ea4d27e2ee84e0c3e082445ada7e">&#9670;&#160;</a></span>GPU_BLENDOP_MIN</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga2a39f40ae7ce461c6ac1918873e4975c">GPUBlendOp</a> SDL::GPU_BLENDOP_MIN</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_BLENDOP_MIN</div>
</div><!-- fragment -->
</div>
</div>
<a id="gadae1c1cd286316549094832929e71bfc" name="gadae1c1cd286316549094832929e71bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadae1c1cd286316549094832929e71bfc">&#9670;&#160;</a></span>GPU_BLENDOP_REVERSE_SUBTRACT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga2a39f40ae7ce461c6ac1918873e4975c">GPUBlendOp</a> SDL::GPU_BLENDOP_REVERSE_SUBTRACT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_BLENDOP_REVERSE_SUBTRACT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gacafe8005b8033e20026179bcd0227e38" name="gacafe8005b8033e20026179bcd0227e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacafe8005b8033e20026179bcd0227e38">&#9670;&#160;</a></span>GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga335d74d2f1cb0811156d8356904fb710">GPUBufferUsageFlags</a> SDL::GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga3e6f9cef980c19a774bf0983f2048b80" name="ga3e6f9cef980c19a774bf0983f2048b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e6f9cef980c19a774bf0983f2048b80">&#9670;&#160;</a></span>GPU_BUFFERUSAGE_COMPUTE_STORAGE_WRITE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga335d74d2f1cb0811156d8356904fb710">GPUBufferUsageFlags</a> SDL::GPU_BUFFERUSAGE_COMPUTE_STORAGE_WRITE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_WRITE</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga5b1ff54b00464f0d7f51fa0dcf63645e" name="ga5b1ff54b00464f0d7f51fa0dcf63645e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b1ff54b00464f0d7f51fa0dcf63645e">&#9670;&#160;</a></span>GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga335d74d2f1cb0811156d8356904fb710">GPUBufferUsageFlags</a> SDL::GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga8df140c028b236e5ed49c9a1f911ea77" name="ga8df140c028b236e5ed49c9a1f911ea77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8df140c028b236e5ed49c9a1f911ea77">&#9670;&#160;</a></span>GPU_BUFFERUSAGE_INDEX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga335d74d2f1cb0811156d8356904fb710">GPUBufferUsageFlags</a> SDL::GPU_BUFFERUSAGE_INDEX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_BUFFERUSAGE_INDEX</div>
</div><!-- fragment -->
</div>
</div>
<a id="gadc7e10ad41409bde1368bd925307a87f" name="gadc7e10ad41409bde1368bd925307a87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc7e10ad41409bde1368bd925307a87f">&#9670;&#160;</a></span>GPU_BUFFERUSAGE_INDIRECT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga335d74d2f1cb0811156d8356904fb710">GPUBufferUsageFlags</a> SDL::GPU_BUFFERUSAGE_INDIRECT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_BUFFERUSAGE_INDIRECT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga59a7a2c989380823746ea674e55c688f" name="ga59a7a2c989380823746ea674e55c688f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59a7a2c989380823746ea674e55c688f">&#9670;&#160;</a></span>GPU_BUFFERUSAGE_VERTEX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga335d74d2f1cb0811156d8356904fb710">GPUBufferUsageFlags</a> SDL::GPU_BUFFERUSAGE_VERTEX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_BUFFERUSAGE_VERTEX</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga3e5f058b756c24e8f587882494d1c9cf" name="ga3e5f058b756c24e8f587882494d1c9cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e5f058b756c24e8f587882494d1c9cf">&#9670;&#160;</a></span>GPU_COLORCOMPONENT_A</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga62905cb8376e8611e4a5b2ac378966ea">GPUColorComponentFlags</a> SDL::GPU_COLORCOMPONENT_A</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_COLORCOMPONENT_A</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga8ca7ce998c705ae32c23a31d7d07709a" name="ga8ca7ce998c705ae32c23a31d7d07709a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ca7ce998c705ae32c23a31d7d07709a">&#9670;&#160;</a></span>GPU_COLORCOMPONENT_B</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga62905cb8376e8611e4a5b2ac378966ea">GPUColorComponentFlags</a> SDL::GPU_COLORCOMPONENT_B</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_COLORCOMPONENT_B</div>
</div><!-- fragment -->
</div>
</div>
<a id="gadb9b8901a74ccef57f84ebc444c52555" name="gadb9b8901a74ccef57f84ebc444c52555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb9b8901a74ccef57f84ebc444c52555">&#9670;&#160;</a></span>GPU_COLORCOMPONENT_G</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga62905cb8376e8611e4a5b2ac378966ea">GPUColorComponentFlags</a> SDL::GPU_COLORCOMPONENT_G</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_COLORCOMPONENT_G</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga9c4e8f0a94608786366fd467746d3c3d" name="ga9c4e8f0a94608786366fd467746d3c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c4e8f0a94608786366fd467746d3c3d">&#9670;&#160;</a></span>GPU_COLORCOMPONENT_R</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga62905cb8376e8611e4a5b2ac378966ea">GPUColorComponentFlags</a> SDL::GPU_COLORCOMPONENT_R</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_COLORCOMPONENT_R</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga0c2fe5c9cc35f4a001d7977c836055b5" name="ga0c2fe5c9cc35f4a001d7977c836055b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c2fe5c9cc35f4a001d7977c836055b5">&#9670;&#160;</a></span>GPU_COMPAREOP_ALWAYS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga27b1a00730534d4ce7ac51f63874cfc7">GPUCompareOp</a> SDL::GPU_COMPAREOP_ALWAYS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_COMPAREOP_ALWAYS</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga5cf4ce2a8ebb1aa67763f3353d30a972" name="ga5cf4ce2a8ebb1aa67763f3353d30a972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cf4ce2a8ebb1aa67763f3353d30a972">&#9670;&#160;</a></span>GPU_COMPAREOP_EQUAL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga27b1a00730534d4ce7ac51f63874cfc7">GPUCompareOp</a> SDL::GPU_COMPAREOP_EQUAL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_COMPAREOP_EQUAL</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga977fb956630868fd74913f5c4ea5bc2f" name="ga977fb956630868fd74913f5c4ea5bc2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga977fb956630868fd74913f5c4ea5bc2f">&#9670;&#160;</a></span>GPU_COMPAREOP_GREATER</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga27b1a00730534d4ce7ac51f63874cfc7">GPUCompareOp</a> SDL::GPU_COMPAREOP_GREATER</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_COMPAREOP_GREATER</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga19dedf1deb36540f335ee06e96bb7ce7" name="ga19dedf1deb36540f335ee06e96bb7ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19dedf1deb36540f335ee06e96bb7ce7">&#9670;&#160;</a></span>GPU_COMPAREOP_GREATER_OR_EQUAL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga27b1a00730534d4ce7ac51f63874cfc7">GPUCompareOp</a> SDL::GPU_COMPAREOP_GREATER_OR_EQUAL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_COMPAREOP_GREATER_OR_EQUAL</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga7fd0fd56aa4aea8330efdff153b986fe" name="ga7fd0fd56aa4aea8330efdff153b986fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fd0fd56aa4aea8330efdff153b986fe">&#9670;&#160;</a></span>GPU_COMPAREOP_INVALID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga27b1a00730534d4ce7ac51f63874cfc7">GPUCompareOp</a> SDL::GPU_COMPAREOP_INVALID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_COMPAREOP_INVALID</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga78e087497d46c8cd9b59f8c844ac70a4" name="ga78e087497d46c8cd9b59f8c844ac70a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78e087497d46c8cd9b59f8c844ac70a4">&#9670;&#160;</a></span>GPU_COMPAREOP_LESS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga27b1a00730534d4ce7ac51f63874cfc7">GPUCompareOp</a> SDL::GPU_COMPAREOP_LESS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_COMPAREOP_LESS</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga08501c5d5caa95d367729fd6d97eb4c5" name="ga08501c5d5caa95d367729fd6d97eb4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08501c5d5caa95d367729fd6d97eb4c5">&#9670;&#160;</a></span>GPU_COMPAREOP_LESS_OR_EQUAL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga27b1a00730534d4ce7ac51f63874cfc7">GPUCompareOp</a> SDL::GPU_COMPAREOP_LESS_OR_EQUAL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_COMPAREOP_LESS_OR_EQUAL</div>
</div><!-- fragment -->
</div>
</div>
<a id="gab84a896240e2a63fdbe6f8b688f5892d" name="gab84a896240e2a63fdbe6f8b688f5892d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab84a896240e2a63fdbe6f8b688f5892d">&#9670;&#160;</a></span>GPU_COMPAREOP_NEVER</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga27b1a00730534d4ce7ac51f63874cfc7">GPUCompareOp</a> SDL::GPU_COMPAREOP_NEVER</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_COMPAREOP_NEVER</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga24df1eaf59fc5c865be0cf82cca15a91" name="ga24df1eaf59fc5c865be0cf82cca15a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24df1eaf59fc5c865be0cf82cca15a91">&#9670;&#160;</a></span>GPU_COMPAREOP_NOT_EQUAL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga27b1a00730534d4ce7ac51f63874cfc7">GPUCompareOp</a> SDL::GPU_COMPAREOP_NOT_EQUAL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_COMPAREOP_NOT_EQUAL</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga73a88a09a55c8427ba745c6e14571766" name="ga73a88a09a55c8427ba745c6e14571766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73a88a09a55c8427ba745c6e14571766">&#9670;&#160;</a></span>GPU_CUBEMAPFACE_NEGATIVEX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga9818c5cd42d048d0b4597bedd340ea7a">GPUCubeMapFace</a> SDL::GPU_CUBEMAPFACE_NEGATIVEX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_CUBEMAPFACE_NEGATIVEX</div>
</div><!-- fragment -->
</div>
</div>
<a id="gae7d878ac053060caf1a3b568fbb28760" name="gae7d878ac053060caf1a3b568fbb28760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7d878ac053060caf1a3b568fbb28760">&#9670;&#160;</a></span>GPU_CUBEMAPFACE_NEGATIVEY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga9818c5cd42d048d0b4597bedd340ea7a">GPUCubeMapFace</a> SDL::GPU_CUBEMAPFACE_NEGATIVEY</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_CUBEMAPFACE_NEGATIVEY</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga83774d36da4155e58135ef48fe82b27c" name="ga83774d36da4155e58135ef48fe82b27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83774d36da4155e58135ef48fe82b27c">&#9670;&#160;</a></span>GPU_CUBEMAPFACE_NEGATIVEZ</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga9818c5cd42d048d0b4597bedd340ea7a">GPUCubeMapFace</a> SDL::GPU_CUBEMAPFACE_NEGATIVEZ</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_CUBEMAPFACE_NEGATIVEZ</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaf2dbd057c6e46ed890d985b8bbb7baa9" name="gaf2dbd057c6e46ed890d985b8bbb7baa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2dbd057c6e46ed890d985b8bbb7baa9">&#9670;&#160;</a></span>GPU_CUBEMAPFACE_POSITIVEX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga9818c5cd42d048d0b4597bedd340ea7a">GPUCubeMapFace</a> SDL::GPU_CUBEMAPFACE_POSITIVEX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_CUBEMAPFACE_POSITIVEX</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga967b28b157fed64b317d0b1d28daad50" name="ga967b28b157fed64b317d0b1d28daad50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga967b28b157fed64b317d0b1d28daad50">&#9670;&#160;</a></span>GPU_CUBEMAPFACE_POSITIVEY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga9818c5cd42d048d0b4597bedd340ea7a">GPUCubeMapFace</a> SDL::GPU_CUBEMAPFACE_POSITIVEY</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_CUBEMAPFACE_POSITIVEY</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga5b2563f031b147ce78c3e8bfc2324c96" name="ga5b2563f031b147ce78c3e8bfc2324c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b2563f031b147ce78c3e8bfc2324c96">&#9670;&#160;</a></span>GPU_CUBEMAPFACE_POSITIVEZ</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga9818c5cd42d048d0b4597bedd340ea7a">GPUCubeMapFace</a> SDL::GPU_CUBEMAPFACE_POSITIVEZ</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_CUBEMAPFACE_POSITIVEZ</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga9e7066c4df69d9f1b59f5c780e789b34" name="ga9e7066c4df69d9f1b59f5c780e789b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e7066c4df69d9f1b59f5c780e789b34">&#9670;&#160;</a></span>GPU_CULLMODE_BACK</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga776730df3e6b57476ae9773d3848c62c">GPUCullMode</a> SDL::GPU_CULLMODE_BACK</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_CULLMODE_BACK</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga960494b2dc4b164b92d1e82c8e097142" name="ga960494b2dc4b164b92d1e82c8e097142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga960494b2dc4b164b92d1e82c8e097142">&#9670;&#160;</a></span>GPU_CULLMODE_FRONT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga776730df3e6b57476ae9773d3848c62c">GPUCullMode</a> SDL::GPU_CULLMODE_FRONT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_CULLMODE_FRONT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gafe01ad4d6c1bd34e975ae59eaac89c9f" name="gafe01ad4d6c1bd34e975ae59eaac89c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe01ad4d6c1bd34e975ae59eaac89c9f">&#9670;&#160;</a></span>GPU_CULLMODE_NONE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga776730df3e6b57476ae9773d3848c62c">GPUCullMode</a> SDL::GPU_CULLMODE_NONE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_CULLMODE_NONE</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga05e8512e2dbc871e08483174460abf75" name="ga05e8512e2dbc871e08483174460abf75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05e8512e2dbc871e08483174460abf75">&#9670;&#160;</a></span>GPU_FILLMODE_FILL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga55ba5426913cb519b5a736f91e5a36c7">GPUFillMode</a> SDL::GPU_FILLMODE_FILL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_FILLMODE_FILL</div>
</div><!-- fragment -->
</div>
</div>
<a id="gab021222d8ac759481a5c228dc74e6e94" name="gab021222d8ac759481a5c228dc74e6e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab021222d8ac759481a5c228dc74e6e94">&#9670;&#160;</a></span>GPU_FILLMODE_LINE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga55ba5426913cb519b5a736f91e5a36c7">GPUFillMode</a> SDL::GPU_FILLMODE_LINE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_FILLMODE_LINE</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga6807701b7fb232515dc1403f0dba9d16" name="ga6807701b7fb232515dc1403f0dba9d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6807701b7fb232515dc1403f0dba9d16">&#9670;&#160;</a></span>GPU_FILTER_LINEAR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaf59e313ae6b3da6531b643e8ab9a4c62">GPUFilter</a> SDL::GPU_FILTER_LINEAR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_FILTER_LINEAR</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaf14e0259e537744513983f7c3b0a7d84" name="gaf14e0259e537744513983f7c3b0a7d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf14e0259e537744513983f7c3b0a7d84">&#9670;&#160;</a></span>GPU_FILTER_NEAREST</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaf59e313ae6b3da6531b643e8ab9a4c62">GPUFilter</a> SDL::GPU_FILTER_NEAREST</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_FILTER_NEAREST</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga9b821237ef733ae06c7355d181db02de" name="ga9b821237ef733ae06c7355d181db02de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b821237ef733ae06c7355d181db02de">&#9670;&#160;</a></span>GPU_FRONTFACE_COUNTER_CLOCKWISE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gae69a13df5715495d8e282f4ac2f1c2e0">GPUFrontFace</a> SDL::GPU_FRONTFACE_COUNTER_CLOCKWISE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_FRONTFACE_COUNTER_CLOCKWISE</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga8fb9e1c18c517a2256f814d560567653" name="ga8fb9e1c18c517a2256f814d560567653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fb9e1c18c517a2256f814d560567653">&#9670;&#160;</a></span>GPU_INDEXELEMENTSIZE_16BIT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaec587594b432d13ab2ddd78ad77342a7">GPUIndexElementSize</a> SDL::GPU_INDEXELEMENTSIZE_16BIT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_INDEXELEMENTSIZE_16BIT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga09e421993abac1302f95386e4054436a" name="ga09e421993abac1302f95386e4054436a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09e421993abac1302f95386e4054436a">&#9670;&#160;</a></span>GPU_INDEXELEMENTSIZE_32BIT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaec587594b432d13ab2ddd78ad77342a7">GPUIndexElementSize</a> SDL::GPU_INDEXELEMENTSIZE_32BIT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_INDEXELEMENTSIZE_32BIT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gabf3ca9f7ea2091820fd7146d8dbedf02" name="gabf3ca9f7ea2091820fd7146d8dbedf02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf3ca9f7ea2091820fd7146d8dbedf02">&#9670;&#160;</a></span>GPU_LOADOP_DONT_CARE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaf5682b03e950adda302469fb07485f2a">GPULoadOp</a> SDL::GPU_LOADOP_DONT_CARE = SDL_GPU_LOADOP_DONT_CARE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The contents will be undefined. </p>

</div>
</div>
<a id="ga5976299de3c88b51177915fd8b52bdab" name="ga5976299de3c88b51177915fd8b52bdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5976299de3c88b51177915fd8b52bdab">&#9670;&#160;</a></span>GPU_PRESENTMODE_IMMEDIATE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga695f2e29e8b1cc9061a08a95ae9690e5">GPUPresentMode</a> SDL::GPU_PRESENTMODE_IMMEDIATE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_PRESENTMODE_IMMEDIATE</div>
</div><!-- fragment -->
</div>
</div>
<a id="gae72c327a3a48c8447df470e06078be11" name="gae72c327a3a48c8447df470e06078be11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae72c327a3a48c8447df470e06078be11">&#9670;&#160;</a></span>GPU_PRESENTMODE_MAILBOX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga695f2e29e8b1cc9061a08a95ae9690e5">GPUPresentMode</a> SDL::GPU_PRESENTMODE_MAILBOX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_PRESENTMODE_MAILBOX</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga6fa16c0a220f131ceea8f3daf5af83ca" name="ga6fa16c0a220f131ceea8f3daf5af83ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fa16c0a220f131ceea8f3daf5af83ca">&#9670;&#160;</a></span>GPU_PRESENTMODE_VSYNC</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga695f2e29e8b1cc9061a08a95ae9690e5">GPUPresentMode</a> SDL::GPU_PRESENTMODE_VSYNC</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_PRESENTMODE_VSYNC</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga1c26f2d8e9a5b78ffcd64b68bda2cbc9" name="ga1c26f2d8e9a5b78ffcd64b68bda2cbc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c26f2d8e9a5b78ffcd64b68bda2cbc9">&#9670;&#160;</a></span>GPU_PRIMITIVETYPE_LINELIST</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaa55e8850ba84241f691eec7b68c58bb3">GPUPrimitiveType</a> SDL::GPU_PRIMITIVETYPE_LINELIST</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_PRIMITIVETYPE_LINELIST</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga84170253c13eedaece60c951532143f0" name="ga84170253c13eedaece60c951532143f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84170253c13eedaece60c951532143f0">&#9670;&#160;</a></span>GPU_PRIMITIVETYPE_LINESTRIP</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaa55e8850ba84241f691eec7b68c58bb3">GPUPrimitiveType</a> SDL::GPU_PRIMITIVETYPE_LINESTRIP</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_PRIMITIVETYPE_LINESTRIP</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga7b21a18c8157e657dd9aff8d40c8bfe4" name="ga7b21a18c8157e657dd9aff8d40c8bfe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b21a18c8157e657dd9aff8d40c8bfe4">&#9670;&#160;</a></span>GPU_PRIMITIVETYPE_POINTLIST</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaa55e8850ba84241f691eec7b68c58bb3">GPUPrimitiveType</a> SDL::GPU_PRIMITIVETYPE_POINTLIST</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_PRIMITIVETYPE_POINTLIST</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga2bd6d2d0b1bec78509ec227efe7e580d" name="ga2bd6d2d0b1bec78509ec227efe7e580d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bd6d2d0b1bec78509ec227efe7e580d">&#9670;&#160;</a></span>GPU_PRIMITIVETYPE_TRIANGLELIST</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaa55e8850ba84241f691eec7b68c58bb3">GPUPrimitiveType</a> SDL::GPU_PRIMITIVETYPE_TRIANGLELIST</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_PRIMITIVETYPE_TRIANGLELIST</div>
</div><!-- fragment -->
</div>
</div>
<a id="gab2a557d732dc19f651f693fd1adb3151" name="gab2a557d732dc19f651f693fd1adb3151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2a557d732dc19f651f693fd1adb3151">&#9670;&#160;</a></span>GPU_PRIMITIVETYPE_TRIANGLESTRIP</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaa55e8850ba84241f691eec7b68c58bb3">GPUPrimitiveType</a> SDL::GPU_PRIMITIVETYPE_TRIANGLESTRIP</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_PRIMITIVETYPE_TRIANGLESTRIP</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaf912b12833fe79778324bc2979e5f8ed" name="gaf912b12833fe79778324bc2979e5f8ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf912b12833fe79778324bc2979e5f8ed">&#9670;&#160;</a></span>GPU_SAMPLECOUNT_1</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga5265d3385d1ddc106c614016bee759d9">GPUSampleCount</a> SDL::GPU_SAMPLECOUNT_1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_SAMPLECOUNT_1</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga92c893b198c69ecada31bf0fe9b85f8e" name="ga92c893b198c69ecada31bf0fe9b85f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92c893b198c69ecada31bf0fe9b85f8e">&#9670;&#160;</a></span>GPU_SAMPLECOUNT_2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga5265d3385d1ddc106c614016bee759d9">GPUSampleCount</a> SDL::GPU_SAMPLECOUNT_2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_SAMPLECOUNT_2</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga86b44bd29df86e5bfed30718b3875c7d" name="ga86b44bd29df86e5bfed30718b3875c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86b44bd29df86e5bfed30718b3875c7d">&#9670;&#160;</a></span>GPU_SAMPLECOUNT_4</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga5265d3385d1ddc106c614016bee759d9">GPUSampleCount</a> SDL::GPU_SAMPLECOUNT_4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_SAMPLECOUNT_4</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga8d40543e044bf9b5d977388c1c554773" name="ga8d40543e044bf9b5d977388c1c554773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d40543e044bf9b5d977388c1c554773">&#9670;&#160;</a></span>GPU_SAMPLECOUNT_8</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga5265d3385d1ddc106c614016bee759d9">GPUSampleCount</a> SDL::GPU_SAMPLECOUNT_8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_SAMPLECOUNT_8</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga320314a66f7502a993528269e6e90ae6" name="ga320314a66f7502a993528269e6e90ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga320314a66f7502a993528269e6e90ae6">&#9670;&#160;</a></span>GPU_SAMPLERADDRESSMODE_CLAMP_TO_EDGE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gae26794f6b687f9799cba905967796a0a">GPUSamplerAddressMode</a> SDL::GPU_SAMPLERADDRESSMODE_CLAMP_TO_EDGE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_SAMPLERADDRESSMODE_CLAMP_TO_EDGE</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaebb3e928858723b23a3c953ea8663b33" name="gaebb3e928858723b23a3c953ea8663b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebb3e928858723b23a3c953ea8663b33">&#9670;&#160;</a></span>GPU_SAMPLERADDRESSMODE_MIRRORED_REPEAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gae26794f6b687f9799cba905967796a0a">GPUSamplerAddressMode</a> SDL::GPU_SAMPLERADDRESSMODE_MIRRORED_REPEAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_SAMPLERADDRESSMODE_MIRRORED_REPEAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga713cb70faf22933d8410fa4d1f099f4b" name="ga713cb70faf22933d8410fa4d1f099f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga713cb70faf22933d8410fa4d1f099f4b">&#9670;&#160;</a></span>GPU_SAMPLERADDRESSMODE_REPEAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gae26794f6b687f9799cba905967796a0a">GPUSamplerAddressMode</a> SDL::GPU_SAMPLERADDRESSMODE_REPEAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_SAMPLERADDRESSMODE_REPEAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga3f86f7874f82dff858e48bf128552691" name="ga3f86f7874f82dff858e48bf128552691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f86f7874f82dff858e48bf128552691">&#9670;&#160;</a></span>GPU_SAMPLERMIPMAPMODE_LINEAR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga5f58e9e7f4f148b25f3e0f839081615f">GPUSamplerMipmapMode</a> SDL::GPU_SAMPLERMIPMAPMODE_LINEAR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_SAMPLERMIPMAPMODE_LINEAR</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga9cd291cb8ddcff2d81dcb71518c9194e" name="ga9cd291cb8ddcff2d81dcb71518c9194e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cd291cb8ddcff2d81dcb71518c9194e">&#9670;&#160;</a></span>GPU_SAMPLERMIPMAPMODE_NEAREST</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga5f58e9e7f4f148b25f3e0f839081615f">GPUSamplerMipmapMode</a> SDL::GPU_SAMPLERMIPMAPMODE_NEAREST</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_SAMPLERMIPMAPMODE_NEAREST</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga3fe7e0d94c4f8b1a44d4297c7937fdd7" name="ga3fe7e0d94c4f8b1a44d4297c7937fdd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fe7e0d94c4f8b1a44d4297c7937fdd7">&#9670;&#160;</a></span>GPU_SHADERFORMAT_DXBC</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">GPUShaderFormat</a> SDL::GPU_SHADERFORMAT_DXBC</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_SHADERFORMAT_DXBC</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga02b670fd2ce72cb88fd985d82d87e66e" name="ga02b670fd2ce72cb88fd985d82d87e66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02b670fd2ce72cb88fd985d82d87e66e">&#9670;&#160;</a></span>GPU_SHADERFORMAT_DXIL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">GPUShaderFormat</a> SDL::GPU_SHADERFORMAT_DXIL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_SHADERFORMAT_DXIL</div>
</div><!-- fragment -->
</div>
</div>
<a id="gad730725e9fea43bfb5b23d80a56b2d53" name="gad730725e9fea43bfb5b23d80a56b2d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad730725e9fea43bfb5b23d80a56b2d53">&#9670;&#160;</a></span>GPU_SHADERFORMAT_INVALID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">GPUShaderFormat</a> SDL::GPU_SHADERFORMAT_INVALID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_SHADERFORMAT_INVALID</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaaedea166fac00b128410ab95c997dc87" name="gaaedea166fac00b128410ab95c997dc87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaedea166fac00b128410ab95c997dc87">&#9670;&#160;</a></span>GPU_SHADERFORMAT_METALLIB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">GPUShaderFormat</a> SDL::GPU_SHADERFORMAT_METALLIB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_SHADERFORMAT_METALLIB</div>
</div><!-- fragment -->
</div>
</div>
<a id="gab4c8591f06b0d9da5b836401ea53b540" name="gab4c8591f06b0d9da5b836401ea53b540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4c8591f06b0d9da5b836401ea53b540">&#9670;&#160;</a></span>GPU_SHADERFORMAT_MSL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">GPUShaderFormat</a> SDL::GPU_SHADERFORMAT_MSL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_SHADERFORMAT_MSL</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga079252fe778e9ee6a0f8ce385b811c28" name="ga079252fe778e9ee6a0f8ce385b811c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga079252fe778e9ee6a0f8ce385b811c28">&#9670;&#160;</a></span>GPU_SHADERFORMAT_PRIVATE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">GPUShaderFormat</a> SDL::GPU_SHADERFORMAT_PRIVATE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_SHADERFORMAT_PRIVATE</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaea1c0902e8b14f52fa1f65972035246c" name="gaea1c0902e8b14f52fa1f65972035246c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea1c0902e8b14f52fa1f65972035246c">&#9670;&#160;</a></span>GPU_SHADERFORMAT_SPIRV</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga6257b71ec0a6c6cfa147db1ee7f0cc2c">GPUShaderFormat</a> SDL::GPU_SHADERFORMAT_SPIRV</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_SHADERFORMAT_SPIRV</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga7fa14a6d77d3ffbae3e7db1490d49853" name="ga7fa14a6d77d3ffbae3e7db1490d49853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fa14a6d77d3ffbae3e7db1490d49853">&#9670;&#160;</a></span>GPU_SHADERSTAGE_FRAGMENT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga5dbe4dbc43d67929db39c145ccaa5e20">GPUShaderStage</a> SDL::GPU_SHADERSTAGE_FRAGMENT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_SHADERSTAGE_FRAGMENT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga76fa51f8ac6f15ccd3e240a39593077b" name="ga76fa51f8ac6f15ccd3e240a39593077b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76fa51f8ac6f15ccd3e240a39593077b">&#9670;&#160;</a></span>GPU_SHADERSTAGE_VERTEX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga5dbe4dbc43d67929db39c145ccaa5e20">GPUShaderStage</a> SDL::GPU_SHADERSTAGE_VERTEX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_SHADERSTAGE_VERTEX</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga900c06dbde97b629aaad39b8b298d45c" name="ga900c06dbde97b629aaad39b8b298d45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga900c06dbde97b629aaad39b8b298d45c">&#9670;&#160;</a></span>GPU_STENCILOP_DECREMENT_AND_CLAMP</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaead0310f70b17c2bc2f92dab7646c96a">GPUStencilOp</a> SDL::GPU_STENCILOP_DECREMENT_AND_CLAMP</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_STENCILOP_DECREMENT_AND_CLAMP</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga854efcdee5489889fd4ac1e1a8abd08f" name="ga854efcdee5489889fd4ac1e1a8abd08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga854efcdee5489889fd4ac1e1a8abd08f">&#9670;&#160;</a></span>GPU_STENCILOP_DECREMENT_AND_WRAP</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaead0310f70b17c2bc2f92dab7646c96a">GPUStencilOp</a> SDL::GPU_STENCILOP_DECREMENT_AND_WRAP</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_STENCILOP_DECREMENT_AND_WRAP</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaa7159861449c3a54dfdfeb7574dcc2b1" name="gaa7159861449c3a54dfdfeb7574dcc2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7159861449c3a54dfdfeb7574dcc2b1">&#9670;&#160;</a></span>GPU_STENCILOP_INCREMENT_AND_CLAMP</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaead0310f70b17c2bc2f92dab7646c96a">GPUStencilOp</a> SDL::GPU_STENCILOP_INCREMENT_AND_CLAMP</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_STENCILOP_INCREMENT_AND_CLAMP</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaf59f33d86ae6282f7144d2168a152163" name="gaf59f33d86ae6282f7144d2168a152163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf59f33d86ae6282f7144d2168a152163">&#9670;&#160;</a></span>GPU_STENCILOP_INCREMENT_AND_WRAP</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaead0310f70b17c2bc2f92dab7646c96a">GPUStencilOp</a> SDL::GPU_STENCILOP_INCREMENT_AND_WRAP</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_STENCILOP_INCREMENT_AND_WRAP</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga87addd4f93d60b5e9ff9a47259676b60" name="ga87addd4f93d60b5e9ff9a47259676b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87addd4f93d60b5e9ff9a47259676b60">&#9670;&#160;</a></span>GPU_STENCILOP_INVALID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaead0310f70b17c2bc2f92dab7646c96a">GPUStencilOp</a> SDL::GPU_STENCILOP_INVALID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_STENCILOP_INVALID</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga136d2fe4473e97a7c994e697b4d39d73" name="ga136d2fe4473e97a7c994e697b4d39d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga136d2fe4473e97a7c994e697b4d39d73">&#9670;&#160;</a></span>GPU_STENCILOP_INVERT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaead0310f70b17c2bc2f92dab7646c96a">GPUStencilOp</a> SDL::GPU_STENCILOP_INVERT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_STENCILOP_INVERT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gac8a5dffef751cd3f2648e86707c18f18" name="gac8a5dffef751cd3f2648e86707c18f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8a5dffef751cd3f2648e86707c18f18">&#9670;&#160;</a></span>GPU_STENCILOP_KEEP</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaead0310f70b17c2bc2f92dab7646c96a">GPUStencilOp</a> SDL::GPU_STENCILOP_KEEP</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_STENCILOP_KEEP</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga4644224298317a30448cc61d4458187e" name="ga4644224298317a30448cc61d4458187e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4644224298317a30448cc61d4458187e">&#9670;&#160;</a></span>GPU_STENCILOP_REPLACE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaead0310f70b17c2bc2f92dab7646c96a">GPUStencilOp</a> SDL::GPU_STENCILOP_REPLACE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_STENCILOP_REPLACE</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga0bb33e4fe5df8ff3e463e897b33daade" name="ga0bb33e4fe5df8ff3e463e897b33daade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bb33e4fe5df8ff3e463e897b33daade">&#9670;&#160;</a></span>GPU_STENCILOP_ZERO</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaead0310f70b17c2bc2f92dab7646c96a">GPUStencilOp</a> SDL::GPU_STENCILOP_ZERO</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_STENCILOP_ZERO</div>
</div><!-- fragment -->
</div>
</div>
<a id="gae34e33b560a98fe8662339871de6180f" name="gae34e33b560a98fe8662339871de6180f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae34e33b560a98fe8662339871de6180f">&#9670;&#160;</a></span>GPU_STOREOP_DONT_CARE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaace1f8aa9176f849a325dee8d65046f4">GPUStoreOp</a> SDL::GPU_STOREOP_DONT_CARE = SDL_GPU_STOREOP_DONT_CARE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The contents will be undefined. </p>

</div>
</div>
<a id="ga2f8d337ba5b30144f4398acadc27e558" name="ga2f8d337ba5b30144f4398acadc27e558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f8d337ba5b30144f4398acadc27e558">&#9670;&#160;</a></span>GPU_STOREOP_RESOLVE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaace1f8aa9176f849a325dee8d65046f4">GPUStoreOp</a> SDL::GPU_STOREOP_RESOLVE = SDL_GPU_STOREOP_RESOLVE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The contents in the multisample texture may then be discarded and will be undefined. </p>

</div>
</div>
<a id="ga6f0c71a6fbb618a73c80b5cb041a270e" name="ga6f0c71a6fbb618a73c80b5cb041a270e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f0c71a6fbb618a73c80b5cb041a270e">&#9670;&#160;</a></span>GPU_STOREOP_RESOLVE_AND_STORE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaace1f8aa9176f849a325dee8d65046f4">GPUStoreOp</a> SDL::GPU_STOREOP_RESOLVE_AND_STORE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_STOREOP_RESOLVE_AND_STORE</div>
</div><!-- fragment --><p>The contents in the multisample texture will be written to memory. </p>

</div>
</div>
<a id="ga0880e5af55d47e52b757b324d6cea484" name="ga0880e5af55d47e52b757b324d6cea484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0880e5af55d47e52b757b324d6cea484">&#9670;&#160;</a></span>GPU_SWAPCHAINCOMPOSITION_HDR10_ST2084</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaa555f571dd4b1b9e5af82ee607a71fc5">GPUSwapchainComposition</a> SDL::GPU_SWAPCHAINCOMPOSITION_HDR10_ST2084</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_SWAPCHAINCOMPOSITION_HDR10_ST2084</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga55512d0adad0984db705504871f5324e" name="ga55512d0adad0984db705504871f5324e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55512d0adad0984db705504871f5324e">&#9670;&#160;</a></span>GPU_SWAPCHAINCOMPOSITION_HDR_EXTENDED_LINEAR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaa555f571dd4b1b9e5af82ee607a71fc5">GPUSwapchainComposition</a> SDL::GPU_SWAPCHAINCOMPOSITION_HDR_EXTENDED_LINEAR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_SWAPCHAINCOMPOSITION_HDR_EXTENDED_LINEAR</div>
</div><!-- fragment -->
</div>
</div>
<a id="gadc466f8d69ab9d7a048e477cbb696a92" name="gadc466f8d69ab9d7a048e477cbb696a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc466f8d69ab9d7a048e477cbb696a92">&#9670;&#160;</a></span>GPU_SWAPCHAINCOMPOSITION_SDR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaa555f571dd4b1b9e5af82ee607a71fc5">GPUSwapchainComposition</a> SDL::GPU_SWAPCHAINCOMPOSITION_SDR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_SWAPCHAINCOMPOSITION_SDR</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga5f87cb8e2190a5252cfc5b4216d7fba7" name="ga5f87cb8e2190a5252cfc5b4216d7fba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f87cb8e2190a5252cfc5b4216d7fba7">&#9670;&#160;</a></span>GPU_SWAPCHAINCOMPOSITION_SDR_LINEAR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaa555f571dd4b1b9e5af82ee607a71fc5">GPUSwapchainComposition</a> SDL::GPU_SWAPCHAINCOMPOSITION_SDR_LINEAR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_SWAPCHAINCOMPOSITION_SDR_LINEAR</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga2c826e8e7d6fbd05e50e920fc991dce3" name="ga2c826e8e7d6fbd05e50e920fc991dce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c826e8e7d6fbd05e50e920fc991dce3">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_A8_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_A8_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_A8_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga4de9171166fff58e7bd1546e1d84cb40" name="ga4de9171166fff58e7bd1546e1d84cb40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4de9171166fff58e7bd1546e1d84cb40">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_10x10_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_10x10_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_10x10_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaabf8f403aedae85332337e554a45922d" name="gaabf8f403aedae85332337e554a45922d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabf8f403aedae85332337e554a45922d">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_10x10_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_10x10_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_10x10_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="gadf8dad3124443ee567b2c12f9528378b" name="gadf8dad3124443ee567b2c12f9528378b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf8dad3124443ee567b2c12f9528378b">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_10x10_UNORM_SRGB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_10x10_UNORM_SRGB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_10x10_UNORM_SRGB</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga9c91910e9d0d78ec0a6d9a48329d3751" name="ga9c91910e9d0d78ec0a6d9a48329d3751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c91910e9d0d78ec0a6d9a48329d3751">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_10x5_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_10x5_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_10x5_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaffb11c42816a9d5826441b3c715dc7a6" name="gaffb11c42816a9d5826441b3c715dc7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffb11c42816a9d5826441b3c715dc7a6">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_10x5_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_10x5_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_10x5_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="gacdd9d56c5681cf7aa0cec7829553911b" name="gacdd9d56c5681cf7aa0cec7829553911b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdd9d56c5681cf7aa0cec7829553911b">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_10x5_UNORM_SRGB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_10x5_UNORM_SRGB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_10x5_UNORM_SRGB</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga3fed779dc2b0f9a7baf69ee60a681fed" name="ga3fed779dc2b0f9a7baf69ee60a681fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fed779dc2b0f9a7baf69ee60a681fed">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_10x6_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_10x6_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_10x6_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaa01ba244c414f0a6cd37feea64467562" name="gaa01ba244c414f0a6cd37feea64467562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa01ba244c414f0a6cd37feea64467562">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_10x6_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_10x6_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_10x6_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaf231fa83dd9609993e2b8c9a79ab1ae2" name="gaf231fa83dd9609993e2b8c9a79ab1ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf231fa83dd9609993e2b8c9a79ab1ae2">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_10x6_UNORM_SRGB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_10x6_UNORM_SRGB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_10x6_UNORM_SRGB</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga531e94ad956b603d660f8ac3be92e2ad" name="ga531e94ad956b603d660f8ac3be92e2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga531e94ad956b603d660f8ac3be92e2ad">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_10x8_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_10x8_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_10x8_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga2ad6bc8e84b323619154489c91cdd1b4" name="ga2ad6bc8e84b323619154489c91cdd1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ad6bc8e84b323619154489c91cdd1b4">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_10x8_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_10x8_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_10x8_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga3b0748ca05c288819d435cfe1ac19ac5" name="ga3b0748ca05c288819d435cfe1ac19ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b0748ca05c288819d435cfe1ac19ac5">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_10x8_UNORM_SRGB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_10x8_UNORM_SRGB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_10x8_UNORM_SRGB</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga8c4dbedd3ad678bd63f56200436631d6" name="ga8c4dbedd3ad678bd63f56200436631d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c4dbedd3ad678bd63f56200436631d6">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_12x10_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_12x10_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_12x10_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaacf2335d2f269bb3cdb0e7c7ce95d220" name="gaacf2335d2f269bb3cdb0e7c7ce95d220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacf2335d2f269bb3cdb0e7c7ce95d220">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_12x10_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_12x10_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_12x10_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaaa9b8b03d1a7548dc8c380aad0d9feae" name="gaaa9b8b03d1a7548dc8c380aad0d9feae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa9b8b03d1a7548dc8c380aad0d9feae">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_12x10_UNORM_SRGB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_12x10_UNORM_SRGB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_12x10_UNORM_SRGB</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga9933b29c18c095dc0a28339a464606c7" name="ga9933b29c18c095dc0a28339a464606c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9933b29c18c095dc0a28339a464606c7">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_12x12_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_12x12_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_12x12_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga1201d834e059badaa4f194879b64d4f2" name="ga1201d834e059badaa4f194879b64d4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1201d834e059badaa4f194879b64d4f2">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_12x12_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_12x12_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_12x12_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga054df995978f69ec0588b2441baf7368" name="ga054df995978f69ec0588b2441baf7368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga054df995978f69ec0588b2441baf7368">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_12x12_UNORM_SRGB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_12x12_UNORM_SRGB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_12x12_UNORM_SRGB</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga135a086b6de0f928d3c3a46f34d030ff" name="ga135a086b6de0f928d3c3a46f34d030ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga135a086b6de0f928d3c3a46f34d030ff">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_4x4_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_4x4_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_4x4_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gab253e388a6af61a09c8a2300be973f7f" name="gab253e388a6af61a09c8a2300be973f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab253e388a6af61a09c8a2300be973f7f">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_4x4_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_4x4_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_4x4_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga5b2d19ba99cbebfbd17be100d11c347c" name="ga5b2d19ba99cbebfbd17be100d11c347c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b2d19ba99cbebfbd17be100d11c347c">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_4x4_UNORM_SRGB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_4x4_UNORM_SRGB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_4x4_UNORM_SRGB</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga8a7553ebb4b0650a4b13f1d2a50857a9" name="ga8a7553ebb4b0650a4b13f1d2a50857a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a7553ebb4b0650a4b13f1d2a50857a9">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_5x4_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_5x4_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_5x4_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gad20492ae7a70de23dbefb5b0263b5701" name="gad20492ae7a70de23dbefb5b0263b5701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad20492ae7a70de23dbefb5b0263b5701">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_5x4_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_5x4_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_5x4_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaac2e98149cbbb37f01c49811db3ce355" name="gaac2e98149cbbb37f01c49811db3ce355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac2e98149cbbb37f01c49811db3ce355">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_5x4_UNORM_SRGB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_5x4_UNORM_SRGB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_5x4_UNORM_SRGB</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga2f306dda0fdb8d5a0231de586ff597e8" name="ga2f306dda0fdb8d5a0231de586ff597e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f306dda0fdb8d5a0231de586ff597e8">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_5x5_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_5x5_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_5x5_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaf67d514e72a5b308d5776018faf707bc" name="gaf67d514e72a5b308d5776018faf707bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf67d514e72a5b308d5776018faf707bc">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_5x5_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_5x5_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_5x5_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaae0b402bf7995d949a3ca208c172ab44" name="gaae0b402bf7995d949a3ca208c172ab44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae0b402bf7995d949a3ca208c172ab44">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_5x5_UNORM_SRGB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_5x5_UNORM_SRGB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_5x5_UNORM_SRGB</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga33e396547d512d496dbb926e71578134" name="ga33e396547d512d496dbb926e71578134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33e396547d512d496dbb926e71578134">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_6x5_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_6x5_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_6x5_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga9e17f2610c3534b4a9671f4880105be0" name="ga9e17f2610c3534b4a9671f4880105be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e17f2610c3534b4a9671f4880105be0">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_6x5_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_6x5_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_6x5_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga516a1838360523b6c8c3733b4737aff1" name="ga516a1838360523b6c8c3733b4737aff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga516a1838360523b6c8c3733b4737aff1">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_6x5_UNORM_SRGB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_6x5_UNORM_SRGB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_6x5_UNORM_SRGB</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga0ad69f51ba7d853a769e9495fd438220" name="ga0ad69f51ba7d853a769e9495fd438220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ad69f51ba7d853a769e9495fd438220">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_6x6_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_6x6_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_6x6_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga10962582b1dd02246369897516f4afa7" name="ga10962582b1dd02246369897516f4afa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10962582b1dd02246369897516f4afa7">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_6x6_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_6x6_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_6x6_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="gabde02e7dc3b0428866756813b72a90c4" name="gabde02e7dc3b0428866756813b72a90c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabde02e7dc3b0428866756813b72a90c4">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_6x6_UNORM_SRGB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_6x6_UNORM_SRGB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_6x6_UNORM_SRGB</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaef035a8d1a509fa612661fa3acd17e41" name="gaef035a8d1a509fa612661fa3acd17e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef035a8d1a509fa612661fa3acd17e41">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_8x5_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_8x5_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_8x5_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga94f519c24769021f3d1834215221af0d" name="ga94f519c24769021f3d1834215221af0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94f519c24769021f3d1834215221af0d">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_8x5_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_8x5_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_8x5_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="gabb25d16573fa2c4ba833b27ae51f3479" name="gabb25d16573fa2c4ba833b27ae51f3479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb25d16573fa2c4ba833b27ae51f3479">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_8x5_UNORM_SRGB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_8x5_UNORM_SRGB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_8x5_UNORM_SRGB</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga1aaec5379de7864831fa784184d8137e" name="ga1aaec5379de7864831fa784184d8137e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1aaec5379de7864831fa784184d8137e">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_8x6_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_8x6_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_8x6_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga1e0d2582afbae3e305d3587677951e91" name="ga1e0d2582afbae3e305d3587677951e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e0d2582afbae3e305d3587677951e91">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_8x6_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_8x6_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_8x6_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga336acf7f8cf9686f95e06a9014e735b7" name="ga336acf7f8cf9686f95e06a9014e735b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga336acf7f8cf9686f95e06a9014e735b7">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_8x6_UNORM_SRGB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_8x6_UNORM_SRGB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_8x6_UNORM_SRGB</div>
</div><!-- fragment -->
</div>
</div>
<a id="gacff96875795281fcd9b45661e29f8e7f" name="gacff96875795281fcd9b45661e29f8e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacff96875795281fcd9b45661e29f8e7f">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_8x8_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_8x8_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_8x8_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gac7ff1e2f3723e557af64497e494bc0c5" name="gac7ff1e2f3723e557af64497e494bc0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7ff1e2f3723e557af64497e494bc0c5">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_8x8_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_8x8_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_8x8_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga8caa3bb414363a7fb3496b68b919333b" name="ga8caa3bb414363a7fb3496b68b919333b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8caa3bb414363a7fb3496b68b919333b">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_ASTC_8x8_UNORM_SRGB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_ASTC_8x8_UNORM_SRGB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_ASTC_8x8_UNORM_SRGB</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaaa1c425cbf635f4c45aaf4b91c076c15" name="gaaa1c425cbf635f4c45aaf4b91c076c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa1c425cbf635f4c45aaf4b91c076c15">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_B4G4R4A4_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_B4G4R4A4_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_B4G4R4A4_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga64904728cf9da2ea8db618988ed3dfc8" name="ga64904728cf9da2ea8db618988ed3dfc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64904728cf9da2ea8db618988ed3dfc8">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_B5G5R5A1_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_B5G5R5A1_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_B5G5R5A1_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="gad8e9d74a24be38d6369481c5306c696c" name="gad8e9d74a24be38d6369481c5306c696c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8e9d74a24be38d6369481c5306c696c">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_B5G6R5_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_B5G6R5_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_B5G6R5_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="gabeff90a6f6dff0b715f4bba54dbe9607" name="gabeff90a6f6dff0b715f4bba54dbe9607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabeff90a6f6dff0b715f4bba54dbe9607">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_B8G8R8A8_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_B8G8R8A8_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_B8G8R8A8_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga8c5cc0c167d13197f72f9c6e6b75db39" name="ga8c5cc0c167d13197f72f9c6e6b75db39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c5cc0c167d13197f72f9c6e6b75db39">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_B8G8R8A8_UNORM_SRGB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_B8G8R8A8_UNORM_SRGB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_B8G8R8A8_UNORM_SRGB</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga347bb71b1e09e4deca421d0618304d1e" name="ga347bb71b1e09e4deca421d0618304d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga347bb71b1e09e4deca421d0618304d1e">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_BC1_RGBA_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_BC1_RGBA_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_BC1_RGBA_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga8b65a1a4ae8bf8544f9f19e88d37c2b8" name="ga8b65a1a4ae8bf8544f9f19e88d37c2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b65a1a4ae8bf8544f9f19e88d37c2b8">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_BC1_RGBA_UNORM_SRGB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_BC1_RGBA_UNORM_SRGB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_BC1_RGBA_UNORM_SRGB</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaa98d480975453eb6ee9970356b7f550d" name="gaa98d480975453eb6ee9970356b7f550d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa98d480975453eb6ee9970356b7f550d">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_BC2_RGBA_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_BC2_RGBA_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_BC2_RGBA_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="gac5aaf1dbc0260633220eb376df34f0dd" name="gac5aaf1dbc0260633220eb376df34f0dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5aaf1dbc0260633220eb376df34f0dd">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_BC2_RGBA_UNORM_SRGB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_BC2_RGBA_UNORM_SRGB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_BC2_RGBA_UNORM_SRGB</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga36adcc27d43d110e38f8a26538a7c266" name="ga36adcc27d43d110e38f8a26538a7c266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36adcc27d43d110e38f8a26538a7c266">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_BC3_RGBA_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_BC3_RGBA_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_BC3_RGBA_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaf5d75629886f9e8eacd1c768c39a66be" name="gaf5d75629886f9e8eacd1c768c39a66be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5d75629886f9e8eacd1c768c39a66be">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_BC3_RGBA_UNORM_SRGB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_BC3_RGBA_UNORM_SRGB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_BC3_RGBA_UNORM_SRGB</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga5a6e3a2690a8c11d145279de08029abd" name="ga5a6e3a2690a8c11d145279de08029abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a6e3a2690a8c11d145279de08029abd">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_BC4_R_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_BC4_R_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_BC4_R_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga805b844a0614f60962b4019fa06b5164" name="ga805b844a0614f60962b4019fa06b5164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga805b844a0614f60962b4019fa06b5164">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_BC5_RG_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_BC5_RG_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_BC5_RG_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga7f2b40430e6aeeb7a0f4f4d532e290cd" name="ga7f2b40430e6aeeb7a0f4f4d532e290cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f2b40430e6aeeb7a0f4f4d532e290cd">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_BC6H_RGB_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_BC6H_RGB_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_BC6H_RGB_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga8e106af5c06cf672761cefdd86618100" name="ga8e106af5c06cf672761cefdd86618100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e106af5c06cf672761cefdd86618100">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_BC6H_RGB_UFLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_BC6H_RGB_UFLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_BC6H_RGB_UFLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga7c0dbb47c91725414be7c13106967c1a" name="ga7c0dbb47c91725414be7c13106967c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c0dbb47c91725414be7c13106967c1a">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_BC7_RGBA_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_BC7_RGBA_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_BC7_RGBA_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="gac5c1b3ef90b63e0f6df36debdf0c4edb" name="gac5c1b3ef90b63e0f6df36debdf0c4edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5c1b3ef90b63e0f6df36debdf0c4edb">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_BC7_RGBA_UNORM_SRGB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_BC7_RGBA_UNORM_SRGB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_BC7_RGBA_UNORM_SRGB</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaef7e970324e922808d2dfea76a8cf86a" name="gaef7e970324e922808d2dfea76a8cf86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef7e970324e922808d2dfea76a8cf86a">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_D16_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_D16_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_D16_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga7742bf18626ef4d35e77f937ed0e8961" name="ga7742bf18626ef4d35e77f937ed0e8961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7742bf18626ef4d35e77f937ed0e8961">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_D24_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_D24_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_D24_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga481c4182ad4cba44edc684bbc4e956b3" name="ga481c4182ad4cba44edc684bbc4e956b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga481c4182ad4cba44edc684bbc4e956b3">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_D24_UNORM_S8_UINT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_D24_UNORM_S8_UINT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_D24_UNORM_S8_UINT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga1621ff55592de0a2b5105852670faf8c" name="ga1621ff55592de0a2b5105852670faf8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1621ff55592de0a2b5105852670faf8c">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_D32_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_D32_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_D32_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaa7ba67799c8b10883f9188b78e5611d5" name="gaa7ba67799c8b10883f9188b78e5611d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7ba67799c8b10883f9188b78e5611d5">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_D32_FLOAT_S8_UINT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_D32_FLOAT_S8_UINT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_D32_FLOAT_S8_UINT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaf5e80ccde34cb873795c787b1323a85e" name="gaf5e80ccde34cb873795c787b1323a85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5e80ccde34cb873795c787b1323a85e">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_INVALID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_INVALID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_INVALID</div>
</div><!-- fragment -->
</div>
</div>
<a id="gabe268288eecb9fb7dbd0fb058160fba0" name="gabe268288eecb9fb7dbd0fb058160fba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe268288eecb9fb7dbd0fb058160fba0">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R10G10B10A2_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R10G10B10A2_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R10G10B10A2_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga424474f383d0da50084eb7a529e53fe4" name="ga424474f383d0da50084eb7a529e53fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga424474f383d0da50084eb7a529e53fe4">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R11G11B10_UFLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R11G11B10_UFLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R11G11B10_UFLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga98b4d734f6250735b02d9ef6ae28fadd" name="ga98b4d734f6250735b02d9ef6ae28fadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98b4d734f6250735b02d9ef6ae28fadd">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R16_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R16_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R16_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga47f16ebd215a5a6320f47dd874cb2c6e" name="ga47f16ebd215a5a6320f47dd874cb2c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47f16ebd215a5a6320f47dd874cb2c6e">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R16_INT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R16_INT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R16_INT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga6f25887c17e66ac3b72565a48848d51f" name="ga6f25887c17e66ac3b72565a48848d51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f25887c17e66ac3b72565a48848d51f">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R16_SNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R16_SNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R16_SNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga90f774a2f5b89430e0751852e1762d27" name="ga90f774a2f5b89430e0751852e1762d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90f774a2f5b89430e0751852e1762d27">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R16_UINT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R16_UINT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R16_UINT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gadf53abf9acbc83bb078a8fbb049d2cc1" name="gadf53abf9acbc83bb078a8fbb049d2cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf53abf9acbc83bb078a8fbb049d2cc1">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R16_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R16_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R16_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga921f5ee7efc871d3c906dc3d70def99e" name="ga921f5ee7efc871d3c906dc3d70def99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga921f5ee7efc871d3c906dc3d70def99e">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R16G16_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R16G16_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R16G16_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gac19f3aa8b2278220d5131aa78109f0e0" name="gac19f3aa8b2278220d5131aa78109f0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac19f3aa8b2278220d5131aa78109f0e0">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R16G16_INT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R16G16_INT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R16G16_INT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gab962aba40dec59204030a49a9acfe136" name="gab962aba40dec59204030a49a9acfe136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab962aba40dec59204030a49a9acfe136">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R16G16_SNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R16G16_SNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R16G16_SNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga2758d8bbe9189c4458b088a43edc9e6d" name="ga2758d8bbe9189c4458b088a43edc9e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2758d8bbe9189c4458b088a43edc9e6d">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R16G16_UINT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R16G16_UINT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R16G16_UINT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga324065d084a6e4cbe15e31c2c9560d14" name="ga324065d084a6e4cbe15e31c2c9560d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga324065d084a6e4cbe15e31c2c9560d14">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R16G16_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R16G16_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R16G16_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga4c005a44820eec554408f4dbd2450aad" name="ga4c005a44820eec554408f4dbd2450aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c005a44820eec554408f4dbd2450aad">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R16G16B16A16_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R16G16B16A16_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R16G16B16A16_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga11df8a95a38cb885273830a7392c319d" name="ga11df8a95a38cb885273830a7392c319d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11df8a95a38cb885273830a7392c319d">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R16G16B16A16_INT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R16G16B16A16_INT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R16G16B16A16_INT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga8cbf8097921bc2511b23cf2571d66799" name="ga8cbf8097921bc2511b23cf2571d66799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cbf8097921bc2511b23cf2571d66799">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R16G16B16A16_SNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R16G16B16A16_SNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R16G16B16A16_SNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="gacecfb8543995c7607f86fc1ebfa269fb" name="gacecfb8543995c7607f86fc1ebfa269fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacecfb8543995c7607f86fc1ebfa269fb">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R16G16B16A16_UINT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R16G16B16A16_UINT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R16G16B16A16_UINT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga2602909d34406366d3a25a80b9bcb1d0" name="ga2602909d34406366d3a25a80b9bcb1d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2602909d34406366d3a25a80b9bcb1d0">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R16G16B16A16_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R16G16B16A16_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R16G16B16A16_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga2f7f0ad0cee4409330252a9c21cc2477" name="ga2f7f0ad0cee4409330252a9c21cc2477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f7f0ad0cee4409330252a9c21cc2477">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R32_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R32_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R32_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga885d542d6093e1e3e037cc65b5ca33e2" name="ga885d542d6093e1e3e037cc65b5ca33e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga885d542d6093e1e3e037cc65b5ca33e2">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R32_INT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R32_INT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R32_INT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga1c823213ac9f780d708475e3deeeb332" name="ga1c823213ac9f780d708475e3deeeb332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c823213ac9f780d708475e3deeeb332">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R32_UINT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R32_UINT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R32_UINT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga105359992cfd837e1a5ce75fa7e0b69b" name="ga105359992cfd837e1a5ce75fa7e0b69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga105359992cfd837e1a5ce75fa7e0b69b">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R32G32_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R32G32_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R32G32_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga5411c74c137ae06997202171c1bb1dd8" name="ga5411c74c137ae06997202171c1bb1dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5411c74c137ae06997202171c1bb1dd8">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R32G32_INT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R32G32_INT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R32G32_INT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga3577869bf1c43d24fe9a895c7dd279e9" name="ga3577869bf1c43d24fe9a895c7dd279e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3577869bf1c43d24fe9a895c7dd279e9">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R32G32_UINT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R32G32_UINT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R32G32_UINT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga6f046d1234f7740962e6083fb499187f" name="ga6f046d1234f7740962e6083fb499187f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f046d1234f7740962e6083fb499187f">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R32G32B32A32_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R32G32B32A32_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R32G32B32A32_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gac0f351800f44f9e9ea7b95058685b617" name="gac0f351800f44f9e9ea7b95058685b617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0f351800f44f9e9ea7b95058685b617">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R32G32B32A32_INT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R32G32B32A32_INT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R32G32B32A32_INT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gae558bb9c7b2ebc2008d37ce2185746f2" name="gae558bb9c7b2ebc2008d37ce2185746f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae558bb9c7b2ebc2008d37ce2185746f2">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R32G32B32A32_UINT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R32G32B32A32_UINT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R32G32B32A32_UINT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gadeba122447e6bdfc7c0be5c436bea010" name="gadeba122447e6bdfc7c0be5c436bea010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadeba122447e6bdfc7c0be5c436bea010">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R8_INT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R8_INT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R8_INT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga3905156c962c16762fed265f571bc823" name="ga3905156c962c16762fed265f571bc823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3905156c962c16762fed265f571bc823">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R8_SNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R8_SNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R8_SNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga86452619cae3b6545b728d1f7b733646" name="ga86452619cae3b6545b728d1f7b733646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86452619cae3b6545b728d1f7b733646">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R8_UINT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R8_UINT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R8_UINT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga0c509fbf45e1574ab9755fd0d6c6c7e8" name="ga0c509fbf45e1574ab9755fd0d6c6c7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c509fbf45e1574ab9755fd0d6c6c7e8">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R8_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R8_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R8_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga108af664704454564eea48bbe26200d7" name="ga108af664704454564eea48bbe26200d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga108af664704454564eea48bbe26200d7">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R8G8_INT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R8G8_INT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R8G8_INT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gac0584ed3ec134ae9412039e0f35e44c0" name="gac0584ed3ec134ae9412039e0f35e44c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0584ed3ec134ae9412039e0f35e44c0">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R8G8_SNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R8G8_SNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R8G8_SNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaffd8230a95ee0c35b257068da1dc95e6" name="gaffd8230a95ee0c35b257068da1dc95e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffd8230a95ee0c35b257068da1dc95e6">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R8G8_UINT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R8G8_UINT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R8G8_UINT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gadaa0306ce056fb6485aa258959dc4315" name="gadaa0306ce056fb6485aa258959dc4315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadaa0306ce056fb6485aa258959dc4315">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R8G8_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R8G8_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R8G8_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga6be9f859b55a2d219c842d7b3ba8c064" name="ga6be9f859b55a2d219c842d7b3ba8c064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6be9f859b55a2d219c842d7b3ba8c064">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R8G8B8A8_INT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R8G8B8A8_INT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R8G8B8A8_INT</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaa0aba049fc0507881b186455f445b7a6" name="gaa0aba049fc0507881b186455f445b7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0aba049fc0507881b186455f445b7a6">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R8G8B8A8_SNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R8G8B8A8_SNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R8G8B8A8_SNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga5a216c880d7f493a5733d15c5005188d" name="ga5a216c880d7f493a5733d15c5005188d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a216c880d7f493a5733d15c5005188d">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R8G8B8A8_UINT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R8G8B8A8_UINT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UINT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga6abd2cc0590e5d74c005d387d0f22fac" name="ga6abd2cc0590e5d74c005d387d0f22fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6abd2cc0590e5d74c005d387d0f22fac">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R8G8B8A8_UNORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R8G8B8A8_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UNORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaa9fa30c3d23c4225f2ce858c2105ab3e" name="gaa9fa30c3d23c4225f2ce858c2105ab3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9fa30c3d23c4225f2ce858c2105ab3e">&#9670;&#160;</a></span>GPU_TEXTUREFORMAT_R8G8B8A8_UNORM_SRGB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gac38f30d58087639f21fb55594e935cbc">GPUTextureFormat</a> SDL::GPU_TEXTUREFORMAT_R8G8B8A8_UNORM_SRGB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UNORM_SRGB</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaa83a4667024d1ef57f20614a39e7e80d" name="gaa83a4667024d1ef57f20614a39e7e80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa83a4667024d1ef57f20614a39e7e80d">&#9670;&#160;</a></span>GPU_TEXTURETYPE_2D</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga624b29173aac1a009aa85c14f46024a3">GPUTextureType</a> SDL::GPU_TEXTURETYPE_2D</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTURETYPE_2D</div>
</div><!-- fragment -->
</div>
</div>
<a id="gae61e70b3c73250ee60abe4878fa72b75" name="gae61e70b3c73250ee60abe4878fa72b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae61e70b3c73250ee60abe4878fa72b75">&#9670;&#160;</a></span>GPU_TEXTURETYPE_2D_ARRAY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga624b29173aac1a009aa85c14f46024a3">GPUTextureType</a> SDL::GPU_TEXTURETYPE_2D_ARRAY</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTURETYPE_2D_ARRAY</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga8d7f76222c6a79ae47b1d076b8f90d47" name="ga8d7f76222c6a79ae47b1d076b8f90d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d7f76222c6a79ae47b1d076b8f90d47">&#9670;&#160;</a></span>GPU_TEXTURETYPE_3D</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga624b29173aac1a009aa85c14f46024a3">GPUTextureType</a> SDL::GPU_TEXTURETYPE_3D</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTURETYPE_3D</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaf56bdd99ec28ff221df851b2bf3ad624" name="gaf56bdd99ec28ff221df851b2bf3ad624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf56bdd99ec28ff221df851b2bf3ad624">&#9670;&#160;</a></span>GPU_TEXTURETYPE_CUBE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga624b29173aac1a009aa85c14f46024a3">GPUTextureType</a> SDL::GPU_TEXTURETYPE_CUBE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTURETYPE_CUBE</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga87d9f7e1518b5a3a1b29936a13143776" name="ga87d9f7e1518b5a3a1b29936a13143776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87d9f7e1518b5a3a1b29936a13143776">&#9670;&#160;</a></span>GPU_TEXTURETYPE_CUBE_ARRAY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga624b29173aac1a009aa85c14f46024a3">GPUTextureType</a> SDL::GPU_TEXTURETYPE_CUBE_ARRAY</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTURETYPE_CUBE_ARRAY</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga43673fe44405ff6c3b93701ccb014b08" name="ga43673fe44405ff6c3b93701ccb014b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43673fe44405ff6c3b93701ccb014b08">&#9670;&#160;</a></span>GPU_TEXTUREUSAGE_COLOR_TARGET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga5a847c301baaf527c8ba644f0f55a59e">GPUTextureUsageFlags</a> SDL::GPU_TEXTUREUSAGE_COLOR_TARGET</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREUSAGE_COLOR_TARGET</div>
</div><!-- fragment -->
</div>
</div>
<a id="gadde64b9b6bd2b5e4a3bba572d8a79b6c" name="gadde64b9b6bd2b5e4a3bba572d8a79b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadde64b9b6bd2b5e4a3bba572d8a79b6c">&#9670;&#160;</a></span>GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga5a847c301baaf527c8ba644f0f55a59e">GPUTextureUsageFlags</a> SDL::GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga105f825311d81d845d1c08f4022c699b" name="ga105f825311d81d845d1c08f4022c699b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga105f825311d81d845d1c08f4022c699b">&#9670;&#160;</a></span>GPU_TEXTUREUSAGE_COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga5a847c301baaf527c8ba644f0f55a59e">GPUTextureUsageFlags</a> SDL::GPU_TEXTUREUSAGE_COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE</div>
</div><!-- fragment --><p>This is NOT equivalent to READ | WRITE. </p>

</div>
</div>
<a id="ga92cd7e2ea4b7e284763017a916aee77f" name="ga92cd7e2ea4b7e284763017a916aee77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92cd7e2ea4b7e284763017a916aee77f">&#9670;&#160;</a></span>GPU_TEXTUREUSAGE_COMPUTE_STORAGE_WRITE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga5a847c301baaf527c8ba644f0f55a59e">GPUTextureUsageFlags</a> SDL::GPU_TEXTUREUSAGE_COMPUTE_STORAGE_WRITE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_WRITE</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga791d3bf7f12eed705aa3265fa5a4d9d5" name="ga791d3bf7f12eed705aa3265fa5a4d9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga791d3bf7f12eed705aa3265fa5a4d9d5">&#9670;&#160;</a></span>GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga5a847c301baaf527c8ba644f0f55a59e">GPUTextureUsageFlags</a> SDL::GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga383bb5e680c67e7b0169ea46683e3b4d" name="ga383bb5e680c67e7b0169ea46683e3b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga383bb5e680c67e7b0169ea46683e3b4d">&#9670;&#160;</a></span>GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga5a847c301baaf527c8ba644f0f55a59e">GPUTextureUsageFlags</a> SDL::GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga3ab5f1ebf543b13831d6b2fd5e34ab58" name="ga3ab5f1ebf543b13831d6b2fd5e34ab58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ab5f1ebf543b13831d6b2fd5e34ab58">&#9670;&#160;</a></span>GPU_TEXTUREUSAGE_SAMPLER</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga5a847c301baaf527c8ba644f0f55a59e">GPUTextureUsageFlags</a> SDL::GPU_TEXTUREUSAGE_SAMPLER</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TEXTUREUSAGE_SAMPLER</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga872d33e90827aedd5b3e4ef2bc083c72" name="ga872d33e90827aedd5b3e4ef2bc083c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga872d33e90827aedd5b3e4ef2bc083c72">&#9670;&#160;</a></span>GPU_TRANSFERBUFFERUSAGE_DOWNLOAD</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaa77f5c65445135e6df84bda3201c49db">GPUTransferBufferUsage</a> SDL::GPU_TRANSFERBUFFERUSAGE_DOWNLOAD</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TRANSFERBUFFERUSAGE_DOWNLOAD</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga6c3f2d42d85ac17ebcb9607cc7ee1f30" name="ga6c3f2d42d85ac17ebcb9607cc7ee1f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c3f2d42d85ac17ebcb9607cc7ee1f30">&#9670;&#160;</a></span>GPU_TRANSFERBUFFERUSAGE_UPLOAD</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaa77f5c65445135e6df84bda3201c49db">GPUTransferBufferUsage</a> SDL::GPU_TRANSFERBUFFERUSAGE_UPLOAD</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD</div>
</div><!-- fragment -->
</div>
</div>
<a id="gac7f4d8a8b2223a7f55f7a23531a7f586" name="gac7f4d8a8b2223a7f55f7a23531a7f586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7f4d8a8b2223a7f55f7a23531a7f586">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_BYTE2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_BYTE2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_BYTE2</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga9d15af14666ee751d81e1aec0f586364" name="ga9d15af14666ee751d81e1aec0f586364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d15af14666ee751d81e1aec0f586364">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_BYTE2_NORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_BYTE2_NORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_BYTE2_NORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga5ea47beffddbf11580f737948a39b28a" name="ga5ea47beffddbf11580f737948a39b28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ea47beffddbf11580f737948a39b28a">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_BYTE4</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_BYTE4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_BYTE4</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaf8d0ee8c1d43920bd4f8ea8a92591b5f" name="gaf8d0ee8c1d43920bd4f8ea8a92591b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8d0ee8c1d43920bd4f8ea8a92591b5f">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_BYTE4_NORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_BYTE4_NORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_BYTE4_NORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaf8e9b6a43a2216abaa3b3a60a4b4b7da" name="gaf8e9b6a43a2216abaa3b3a60a4b4b7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8e9b6a43a2216abaa3b3a60a4b4b7da">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_FLOAT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_FLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_FLOAT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga0f1d3996988e5f7a00d10d21b074b712" name="ga0f1d3996988e5f7a00d10d21b074b712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f1d3996988e5f7a00d10d21b074b712">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_FLOAT2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_FLOAT2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_FLOAT2</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga191fdc13001a91c4655fa40dcdf39edc" name="ga191fdc13001a91c4655fa40dcdf39edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga191fdc13001a91c4655fa40dcdf39edc">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_FLOAT3</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_FLOAT3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_FLOAT3</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga4de5653c1bdbd5813d14b2c7c34ac9c7" name="ga4de5653c1bdbd5813d14b2c7c34ac9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4de5653c1bdbd5813d14b2c7c34ac9c7">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_FLOAT4</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_FLOAT4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_FLOAT4</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga9d4702172276daf56741758a11ef15e4" name="ga9d4702172276daf56741758a11ef15e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d4702172276daf56741758a11ef15e4">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_HALF2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_HALF2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_HALF2</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga72f101c67edaa524cbb96e8d6591bbcc" name="ga72f101c67edaa524cbb96e8d6591bbcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72f101c67edaa524cbb96e8d6591bbcc">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_HALF4</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_HALF4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_HALF4</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga43dc14f2c0c8a2e57bed77ac5d13de01" name="ga43dc14f2c0c8a2e57bed77ac5d13de01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43dc14f2c0c8a2e57bed77ac5d13de01">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_INT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_INT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_INT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga79d861f1a78b7e2b8bc55ed5e36de9d4" name="ga79d861f1a78b7e2b8bc55ed5e36de9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79d861f1a78b7e2b8bc55ed5e36de9d4">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_INT2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_INT2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_INT2</div>
</div><!-- fragment -->
</div>
</div>
<a id="gac90ef78df4ab934440d5d2ba1d5a5eb8" name="gac90ef78df4ab934440d5d2ba1d5a5eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac90ef78df4ab934440d5d2ba1d5a5eb8">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_INT3</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_INT3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_INT3</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga2db7bcb5b6bc120d950191ec58f7e526" name="ga2db7bcb5b6bc120d950191ec58f7e526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2db7bcb5b6bc120d950191ec58f7e526">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_INT4</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_INT4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_INT4</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaa4daefe54d723add7825b44244670cbc" name="gaa4daefe54d723add7825b44244670cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4daefe54d723add7825b44244670cbc">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_INVALID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_INVALID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_INVALID</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga3891b9d546cf24d2432808958d554a68" name="ga3891b9d546cf24d2432808958d554a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3891b9d546cf24d2432808958d554a68">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_SHORT2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_SHORT2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_SHORT2</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga5e517ab6c01b194ff44b38f20f448146" name="ga5e517ab6c01b194ff44b38f20f448146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e517ab6c01b194ff44b38f20f448146">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_SHORT2_NORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_SHORT2_NORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_SHORT2_NORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="gafb033b89b422d579a1c6492019ef3942" name="gafb033b89b422d579a1c6492019ef3942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb033b89b422d579a1c6492019ef3942">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_SHORT4</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_SHORT4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_SHORT4</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaa7389c388cf6fb310d48c1a6707bf52e" name="gaa7389c388cf6fb310d48c1a6707bf52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7389c388cf6fb310d48c1a6707bf52e">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_SHORT4_NORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_SHORT4_NORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_SHORT4_NORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga1b6ccb8666100d7504b48bf55d9770ed" name="ga1b6ccb8666100d7504b48bf55d9770ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b6ccb8666100d7504b48bf55d9770ed">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_UBYTE2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_UBYTE2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_UBYTE2</div>
</div><!-- fragment -->
</div>
</div>
<a id="gafae02251aa771780aac088534a3a2f0f" name="gafae02251aa771780aac088534a3a2f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafae02251aa771780aac088534a3a2f0f">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_UBYTE2_NORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_UBYTE2_NORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_UBYTE2_NORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaa0e9434a8d96b06533bed5765862f045" name="gaa0e9434a8d96b06533bed5765862f045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0e9434a8d96b06533bed5765862f045">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_UBYTE4</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_UBYTE4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_UBYTE4</div>
</div><!-- fragment -->
</div>
</div>
<a id="gae3bf247629f6cce54d71087c3755dcb9" name="gae3bf247629f6cce54d71087c3755dcb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3bf247629f6cce54d71087c3755dcb9">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_UBYTE4_NORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_UBYTE4_NORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_UBYTE4_NORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga02ae52f352503654af8013f86bd4fe0f" name="ga02ae52f352503654af8013f86bd4fe0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02ae52f352503654af8013f86bd4fe0f">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_UINT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_UINT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_UINT</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga9f2e70a24cc8c831119d0c56417d6eb0" name="ga9f2e70a24cc8c831119d0c56417d6eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f2e70a24cc8c831119d0c56417d6eb0">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_UINT2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_UINT2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_UINT2</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga7369a9343adf6ec2d451d80d83d6e469" name="ga7369a9343adf6ec2d451d80d83d6e469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7369a9343adf6ec2d451d80d83d6e469">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_UINT3</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_UINT3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_UINT3</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga9095c7dfb1ebbb4e35e715a37f8a521e" name="ga9095c7dfb1ebbb4e35e715a37f8a521e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9095c7dfb1ebbb4e35e715a37f8a521e">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_UINT4</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_UINT4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_UINT4</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga2576ebc7a6f0e83310a8c2eb0f537648" name="ga2576ebc7a6f0e83310a8c2eb0f537648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2576ebc7a6f0e83310a8c2eb0f537648">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_USHORT2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_USHORT2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_USHORT2</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga106ff338c6de59c39c5d5dd6fde73023" name="ga106ff338c6de59c39c5d5dd6fde73023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga106ff338c6de59c39c5d5dd6fde73023">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_USHORT2_NORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_USHORT2_NORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_USHORT2_NORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="gad472148386d0cb34a7c0a9214cff4154" name="gad472148386d0cb34a7c0a9214cff4154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad472148386d0cb34a7c0a9214cff4154">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_USHORT4</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_USHORT4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_USHORT4</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga1c7c9d712cdec31df8d51813ee202687" name="ga1c7c9d712cdec31df8d51813ee202687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c7c9d712cdec31df8d51813ee202687">&#9670;&#160;</a></span>GPU_VERTEXELEMENTFORMAT_USHORT4_NORM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#ga7ee7085f0bec0d39da3df52edb34e29d">GPUVertexElementFormat</a> SDL::GPU_VERTEXELEMENTFORMAT_USHORT4_NORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXELEMENTFORMAT_USHORT4_NORM</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga7d60d95216a581841ce8bdc098488a8c" name="ga7d60d95216a581841ce8bdc098488a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d60d95216a581841ce8bdc098488a8c">&#9670;&#160;</a></span>GPU_VERTEXINPUTRATE_INSTANCE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaf0c935ed3eb7b0a1f180472c021a91e3">GPUVertexInputRate</a> SDL::GPU_VERTEXINPUTRATE_INSTANCE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXINPUTRATE_INSTANCE</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga6947b96b1a3e1bebfc56caf0d4ac5719" name="ga6947b96b1a3e1bebfc56caf0d4ac5719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6947b96b1a3e1bebfc56caf0d4ac5719">&#9670;&#160;</a></span>GPU_VERTEXINPUTRATE_VERTEX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryGPU.html#gaf0c935ed3eb7b0a1f180472c021a91e3">GPUVertexInputRate</a> SDL::GPU_VERTEXINPUTRATE_VERTEX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_GPU_VERTEXINPUTRATE_VERTEX</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
