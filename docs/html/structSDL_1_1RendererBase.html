<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDL3pp: SDL::RendererBase&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SDL3pp
   </div>
   <div id="projectbrief">A slim C++ wrapper for SDL3</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSDL.html">SDL</a></li><li class="navelem"><a class="el" href="structSDL_1_1RendererBase.html">RendererBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structSDL_1_1RendererBase-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SDL::RendererBase&lt; T &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__Categories.html">Categories</a> &raquo; <a class="el" href="group__CategoriesVideo.html">Video</a> &raquo; <a class="el" href="group__CategoryRender.html">2D Accelerated Rendering</a> &#124; <a class="el" href="group__Categories.html">Categories</a> &raquo; <a class="el" href="group__CategoriesVideo.html">Video</a> &raquo; <a class="el" href="group__CategoryVideo.html">Display and Window Management</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A structure representing rendering state.  
 <a href="structSDL_1_1RendererBase.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for SDL::RendererBase&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structSDL_1_1RendererBase__inherit__graph.png" border="0" usemap="#aSDL_1_1RendererBase_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aSDL_1_1RendererBase_3_01T_01_4_inherit__map" id="aSDL_1_1RendererBase_3_01T_01_4_inherit__map">
<area shape="rect" title="A structure representing rendering state." alt="" coords="5,79,189,104"/>
<area shape="rect" title=" " alt="" coords="78,5,117,31"/>
<area shape="poly" title=" " alt="" coords="100,44,100,79,95,79,95,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for SDL::RendererBase&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structSDL_1_1RendererBase__coll__graph.png" border="0" usemap="#aSDL_1_1RendererBase_3_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aSDL_1_1RendererBase_3_01T_01_4_coll__map" id="aSDL_1_1RendererBase_3_01T_01_4_coll__map">
<area shape="rect" title="A structure representing rendering state." alt="" coords="5,79,189,104"/>
<area shape="rect" title=" " alt="" coords="78,5,117,31"/>
<area shape="poly" title=" " alt="" coords="100,44,100,79,95,79,95,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6cd596ee84afc3ead3c26a6c429a797c" id="r_a6cd596ee84afc3ead3c26a6c429a797c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a6cd596ee84afc3ead3c26a6c429a797c">RendererBase</a> (<a class="el" href="group__CategoryVideo.html#ga42069207012bd44674fe1677bd5a1066">WindowRef</a> window)</td></tr>
<tr class="memdesc:a6cd596ee84afc3ead3c26a6c429a797c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 2D rendering context for a window.  <br /></td></tr>
<tr class="separator:a6cd596ee84afc3ead3c26a6c429a797c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40139cb8ccb05de0bfa1de252a16a413" id="r_a40139cb8ccb05de0bfa1de252a16a413"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a40139cb8ccb05de0bfa1de252a16a413">RendererBase</a> (<a class="el" href="group__CategoryVideo.html#ga42069207012bd44674fe1677bd5a1066">WindowRef</a> window, <a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> name)</td></tr>
<tr class="memdesc:a40139cb8ccb05de0bfa1de252a16a413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 2D rendering context for a window.  <br /></td></tr>
<tr class="separator:a40139cb8ccb05de0bfa1de252a16a413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e35780944151019d207ce15e91e6bc" id="r_ac2e35780944151019d207ce15e91e6bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#ac2e35780944151019d207ce15e91e6bc">RendererBase</a> (<a class="el" href="group__CategoryProperties.html#gaa5faab1a5ca99f759b68b5800ab0697f">PropertiesRef</a> props)</td></tr>
<tr class="memdesc:ac2e35780944151019d207ce15e91e6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 2D rendering context for a window, with the specified properties.  <br /></td></tr>
<tr class="separator:ac2e35780944151019d207ce15e91e6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46ac713dd82379701bb276f3d081d92" id="r_ab46ac713dd82379701bb276f3d081d92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#ab46ac713dd82379701bb276f3d081d92">RendererBase</a> (<a class="el" href="group__CategorySurface.html#ga2ea8e6016ec594c51738ef06f469d5d2">SurfaceRef</a> surface)</td></tr>
<tr class="memdesc:ab46ac713dd82379701bb276f3d081d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 2D software rendering context for a surface.  <br /></td></tr>
<tr class="separator:ab46ac713dd82379701bb276f3d081d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2453f319060765f13e80ef49b77e8a39" id="r_a2453f319060765f13e80ef49b77e8a39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategoryVideo.html#ga42069207012bd44674fe1677bd5a1066">WindowRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a2453f319060765f13e80ef49b77e8a39">GetWindow</a> ()</td></tr>
<tr class="memdesc:a2453f319060765f13e80ef49b77e8a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the window associated with a renderer.  <br /></td></tr>
<tr class="separator:a2453f319060765f13e80ef49b77e8a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e12268f5d4a0d7fdb63c448762aced" id="r_a25e12268f5d4a0d7fdb63c448762aced"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a25e12268f5d4a0d7fdb63c448762aced">GetName</a> () const</td></tr>
<tr class="memdesc:a25e12268f5d4a0d7fdb63c448762aced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of a renderer.  <br /></td></tr>
<tr class="separator:a25e12268f5d4a0d7fdb63c448762aced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffe3a24cc96cd303be80238b537f00b" id="r_aaffe3a24cc96cd303be80238b537f00b"><td class="memItemLeft" align="right" valign="top"><a id="aaffe3a24cc96cd303be80238b537f00b" name="aaffe3a24cc96cd303be80238b537f00b"></a>
std::optional&lt; <a class="el" href="structSDL_1_1Point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetOutputSize</b> () const</td></tr>
<tr class="separator:aaffe3a24cc96cd303be80238b537f00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbdd1ddd5d6fea7af6eb3b0e33bd2ac4" id="r_acbdd1ddd5d6fea7af6eb3b0e33bd2ac4"><td class="memItemLeft" align="right" valign="top"><a id="acbdd1ddd5d6fea7af6eb3b0e33bd2ac4" name="acbdd1ddd5d6fea7af6eb3b0e33bd2ac4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetOutputSize</b> (SDL_Point *size) const</td></tr>
<tr class="separator:acbdd1ddd5d6fea7af6eb3b0e33bd2ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ede670010086138ad523545e0b14be9" id="r_a7ede670010086138ad523545e0b14be9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a7ede670010086138ad523545e0b14be9">GetOutputSize</a> (int *w, int *h) const</td></tr>
<tr class="memdesc:a7ede670010086138ad523545e0b14be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the output size in pixels of a rendering context.  <br /></td></tr>
<tr class="separator:a7ede670010086138ad523545e0b14be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bfed3fbb4b92f116c4e5ca1e96837f" id="r_a77bfed3fbb4b92f116c4e5ca1e96837f"><td class="memItemLeft" align="right" valign="top"><a id="a77bfed3fbb4b92f116c4e5ca1e96837f" name="a77bfed3fbb4b92f116c4e5ca1e96837f"></a>
std::optional&lt; <a class="el" href="structSDL_1_1Point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetCurrentOutputSize</b> () const</td></tr>
<tr class="separator:a77bfed3fbb4b92f116c4e5ca1e96837f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a65569ed1cc97116848e1bf97ab9b87" id="r_a0a65569ed1cc97116848e1bf97ab9b87"><td class="memItemLeft" align="right" valign="top"><a id="a0a65569ed1cc97116848e1bf97ab9b87" name="a0a65569ed1cc97116848e1bf97ab9b87"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetCurrentOutputSize</b> (SDL_Point *size) const</td></tr>
<tr class="separator:a0a65569ed1cc97116848e1bf97ab9b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc01bda29bd2bc7d1e3f848c8b194fd" id="r_a8fc01bda29bd2bc7d1e3f848c8b194fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a8fc01bda29bd2bc7d1e3f848c8b194fd">GetCurrentOutputSize</a> (int *w, int *h) const</td></tr>
<tr class="memdesc:a8fc01bda29bd2bc7d1e3f848c8b194fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current output size in pixels of a rendering context.  <br /></td></tr>
<tr class="separator:a8fc01bda29bd2bc7d1e3f848c8b194fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a311b6d4c3597689ffe65718208a1f5" id="r_a2a311b6d4c3597689ffe65718208a1f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategoryProperties.html#gaa5faab1a5ca99f759b68b5800ab0697f">PropertiesRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a2a311b6d4c3597689ffe65718208a1f5">GetProperties</a> () const</td></tr>
<tr class="memdesc:a2a311b6d4c3597689ffe65718208a1f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the properties associated with a renderer.  <br /></td></tr>
<tr class="separator:a2a311b6d4c3597689ffe65718208a1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca57a9d138be624fa363a40cb887718" id="r_a4ca57a9d138be624fa363a40cb887718"><td class="memItemLeft" align="right" valign="top"><a id="a4ca57a9d138be624fa363a40cb887718" name="a4ca57a9d138be624fa363a40cb887718"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ResetTarget</b> ()</td></tr>
<tr class="separator:a4ca57a9d138be624fa363a40cb887718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f6fe44be445493f8ee9384bf764c87" id="r_a00f6fe44be445493f8ee9384bf764c87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a00f6fe44be445493f8ee9384bf764c87">SetTarget</a> (<a class="el" href="group__CategoryRender.html#ga4b68df1674a8dea4fabd4e9ab9e745d7">TextureRef</a> texture)</td></tr>
<tr class="memdesc:a00f6fe44be445493f8ee9384bf764c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a texture as the current rendering target.  <br /></td></tr>
<tr class="separator:a00f6fe44be445493f8ee9384bf764c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a08906b9ff3d00e0ad75107e991f5d1" id="r_a0a08906b9ff3d00e0ad75107e991f5d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategoryRender.html#ga4b68df1674a8dea4fabd4e9ab9e745d7">TextureRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a0a08906b9ff3d00e0ad75107e991f5d1">GetTarget</a> () const</td></tr>
<tr class="memdesc:a0a08906b9ff3d00e0ad75107e991f5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current render target.  <br /></td></tr>
<tr class="separator:a0a08906b9ff3d00e0ad75107e991f5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6989d7e5c77b8af134de07765c00344" id="r_af6989d7e5c77b8af134de07765c00344"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#af6989d7e5c77b8af134de07765c00344">SetLogicalPresentation</a> (SDL_Point size, <a class="el" href="group__CategoryRender.html#ga91be24b12fa4efe591c43f2ece44e32d">RendererLogicalPresentation</a> mode)</td></tr>
<tr class="memdesc:af6989d7e5c77b8af134de07765c00344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a device independent resolution and presentation mode for rendering.  <br /></td></tr>
<tr class="separator:af6989d7e5c77b8af134de07765c00344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a46c5ec2a153ed79933f1efb2eafbb" id="r_ad0a46c5ec2a153ed79933f1efb2eafbb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#ad0a46c5ec2a153ed79933f1efb2eafbb">GetLogicalPresentation</a> (SDL_Point *size, <a class="el" href="group__CategoryRender.html#ga91be24b12fa4efe591c43f2ece44e32d">RendererLogicalPresentation</a> *mode)</td></tr>
<tr class="memdesc:ad0a46c5ec2a153ed79933f1efb2eafbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get device independent resolution and presentation mode for rendering.  <br /></td></tr>
<tr class="separator:ad0a46c5ec2a153ed79933f1efb2eafbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d0ed84af87f05209122dccf4a39722" id="r_a04d0ed84af87f05209122dccf4a39722"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a04d0ed84af87f05209122dccf4a39722">GetLogicalPresentation</a> (int *w, int *h, <a class="el" href="group__CategoryRender.html#ga91be24b12fa4efe591c43f2ece44e32d">RendererLogicalPresentation</a> *mode) const</td></tr>
<tr class="memdesc:a04d0ed84af87f05209122dccf4a39722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get device independent resolution and presentation mode for rendering.  <br /></td></tr>
<tr class="separator:a04d0ed84af87f05209122dccf4a39722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e231417b3b5cee3048276f4ed5ac701" id="r_a4e231417b3b5cee3048276f4ed5ac701"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structSDL_1_1FRect.html">FRect</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a4e231417b3b5cee3048276f4ed5ac701">GetLogicalPresentationRect</a> () const</td></tr>
<tr class="memdesc:a4e231417b3b5cee3048276f4ed5ac701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the final presentation rectangle for rendering.  <br /></td></tr>
<tr class="separator:a4e231417b3b5cee3048276f4ed5ac701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c7fdbb523366fa5691fa2cd18bf7f3" id="r_a59c7fdbb523366fa5691fa2cd18bf7f3"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structSDL_1_1FPoint.html">FPoint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a59c7fdbb523366fa5691fa2cd18bf7f3">RenderCoordinatesFromWindow</a> (const SDL_FPoint &amp;window_coord) const</td></tr>
<tr class="memdesc:a59c7fdbb523366fa5691fa2cd18bf7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a point in render coordinates when given a point in window coordinates.  <br /></td></tr>
<tr class="separator:a59c7fdbb523366fa5691fa2cd18bf7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee953b66b42c5d7672db78aa5a7e735" id="r_a4ee953b66b42c5d7672db78aa5a7e735"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structSDL_1_1FPoint.html">FPoint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a4ee953b66b42c5d7672db78aa5a7e735">RenderCoordinatesToWindow</a> (const SDL_FPoint &amp;coord) const</td></tr>
<tr class="memdesc:a4ee953b66b42c5d7672db78aa5a7e735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a point in window coordinates when given a point in render coordinates.  <br /></td></tr>
<tr class="separator:a4ee953b66b42c5d7672db78aa5a7e735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8883859100726a7c7f08134ee0fc0229" id="r_a8883859100726a7c7f08134ee0fc0229"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a8883859100726a7c7f08134ee0fc0229">ConvertEventToRenderCoordinates</a> (SDL_Event *event) const</td></tr>
<tr class="memdesc:a8883859100726a7c7f08134ee0fc0229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the coordinates in an event to render coordinates.  <br /></td></tr>
<tr class="separator:a8883859100726a7c7f08134ee0fc0229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44e212c72e672a441ec729a18c26ecb" id="r_aa44e212c72e672a441ec729a18c26ecb"><td class="memItemLeft" align="right" valign="top"><a id="aa44e212c72e672a441ec729a18c26ecb" name="aa44e212c72e672a441ec729a18c26ecb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ResetViewport</b> ()</td></tr>
<tr class="separator:aa44e212c72e672a441ec729a18c26ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f48812426d05f0ac160cb1b116c6932" id="r_a1f48812426d05f0ac160cb1b116c6932"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a1f48812426d05f0ac160cb1b116c6932">SetViewport</a> (<a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_Rect &gt; rect)</td></tr>
<tr class="memdesc:a1f48812426d05f0ac160cb1b116c6932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the drawing area for rendering on the current target.  <br /></td></tr>
<tr class="separator:a1f48812426d05f0ac160cb1b116c6932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74c59e900e3ffd5a6ff9f5258fefef8" id="r_ad74c59e900e3ffd5a6ff9f5258fefef8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structSDL_1_1Rect.html">Rect</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#ad74c59e900e3ffd5a6ff9f5258fefef8">GetViewport</a> () const</td></tr>
<tr class="memdesc:ad74c59e900e3ffd5a6ff9f5258fefef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the drawing area for the current target.  <br /></td></tr>
<tr class="separator:ad74c59e900e3ffd5a6ff9f5258fefef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2908ff72f1fcfe85cd2c9b2ce703fca" id="r_ab2908ff72f1fcfe85cd2c9b2ce703fca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#ab2908ff72f1fcfe85cd2c9b2ce703fca">IsViewportSet</a> () const</td></tr>
<tr class="memdesc:ab2908ff72f1fcfe85cd2c9b2ce703fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether an explicit rectangle was set as the viewport.  <br /></td></tr>
<tr class="separator:ab2908ff72f1fcfe85cd2c9b2ce703fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea5bb6aff35c2777433b0c659b6e486" id="r_a8ea5bb6aff35c2777433b0c659b6e486"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structSDL_1_1Rect.html">Rect</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a8ea5bb6aff35c2777433b0c659b6e486">GetSafeArea</a> () const</td></tr>
<tr class="memdesc:a8ea5bb6aff35c2777433b0c659b6e486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the safe area for rendering within the current viewport.  <br /></td></tr>
<tr class="separator:a8ea5bb6aff35c2777433b0c659b6e486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf093d5d6a7423dab461367031cffbd" id="r_aadf093d5d6a7423dab461367031cffbd"><td class="memItemLeft" align="right" valign="top"><a id="aadf093d5d6a7423dab461367031cffbd" name="aadf093d5d6a7423dab461367031cffbd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ResetClipRect</b> ()</td></tr>
<tr class="separator:aadf093d5d6a7423dab461367031cffbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6809765651f06b11bd0711c60d24633" id="r_af6809765651f06b11bd0711c60d24633"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#af6809765651f06b11bd0711c60d24633">SetClipRect</a> (<a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_Rect &gt; rect)</td></tr>
<tr class="memdesc:af6809765651f06b11bd0711c60d24633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the clip rectangle for rendering on the specified target.  <br /></td></tr>
<tr class="separator:af6809765651f06b11bd0711c60d24633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755bccca740076de95e4a4a889a54b48" id="r_a755bccca740076de95e4a4a889a54b48"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structSDL_1_1Rect.html">Rect</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a755bccca740076de95e4a4a889a54b48">GetClipRect</a> () const</td></tr>
<tr class="memdesc:a755bccca740076de95e4a4a889a54b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the clip rectangle for the current target.  <br /></td></tr>
<tr class="separator:a755bccca740076de95e4a4a889a54b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeec4f8fc6eb0fe6a742aafa04609fef" id="r_aeeec4f8fc6eb0fe6a742aafa04609fef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#aeeec4f8fc6eb0fe6a742aafa04609fef">IsClipEnabled</a> () const</td></tr>
<tr class="memdesc:aeeec4f8fc6eb0fe6a742aafa04609fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether clipping is enabled on the given renderer.  <br /></td></tr>
<tr class="separator:aeeec4f8fc6eb0fe6a742aafa04609fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2e2c2a7eab09a2252d67b43a7de7eb" id="r_aaf2e2c2a7eab09a2252d67b43a7de7eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#aaf2e2c2a7eab09a2252d67b43a7de7eb">SetScale</a> (SDL_FPoint scale)</td></tr>
<tr class="memdesc:aaf2e2c2a7eab09a2252d67b43a7de7eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the drawing scale for rendering on the current target.  <br /></td></tr>
<tr class="separator:aaf2e2c2a7eab09a2252d67b43a7de7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcd884ff71913fb2b29de66ba46573f" id="r_a4bcd884ff71913fb2b29de66ba46573f"><td class="memItemLeft" align="right" valign="top"><a id="a4bcd884ff71913fb2b29de66ba46573f" name="a4bcd884ff71913fb2b29de66ba46573f"></a>
std::optional&lt; <a class="el" href="structSDL_1_1FPoint.html">FPoint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetScale</b> () const</td></tr>
<tr class="separator:a4bcd884ff71913fb2b29de66ba46573f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52eff7fddc4bbc4d8f048cc788bf40c2" id="r_a52eff7fddc4bbc4d8f048cc788bf40c2"><td class="memItemLeft" align="right" valign="top"><a id="a52eff7fddc4bbc4d8f048cc788bf40c2" name="a52eff7fddc4bbc4d8f048cc788bf40c2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetScale</b> (<a class="el" href="structSDL_1_1FPoint.html">FPoint</a> *scale) const</td></tr>
<tr class="separator:a52eff7fddc4bbc4d8f048cc788bf40c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2575fc8ac70cc87bb27d98beaa89fe25" id="r_a2575fc8ac70cc87bb27d98beaa89fe25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a2575fc8ac70cc87bb27d98beaa89fe25">GetScale</a> (float *scaleX, float *scaleY) const</td></tr>
<tr class="memdesc:a2575fc8ac70cc87bb27d98beaa89fe25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the drawing scale for the current target.  <br /></td></tr>
<tr class="separator:a2575fc8ac70cc87bb27d98beaa89fe25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc3966cdb024d1061115f0e79af6867" id="r_a7dc3966cdb024d1061115f0e79af6867"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a7dc3966cdb024d1061115f0e79af6867">SetDrawColor</a> (SDL_Color c)</td></tr>
<tr class="memdesc:a7dc3966cdb024d1061115f0e79af6867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the color used for drawing operations.  <br /></td></tr>
<tr class="separator:a7dc3966cdb024d1061115f0e79af6867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d39f29732e13b3e5b2dce47f78479f" id="r_ab5d39f29732e13b3e5b2dce47f78479f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#ab5d39f29732e13b3e5b2dce47f78479f">SetDrawColor</a> (SDL_FColor c)</td></tr>
<tr class="memdesc:ab5d39f29732e13b3e5b2dce47f78479f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the color used for drawing operations (<a class="el" href="structSDL_1_1Rect.html" title="A rectangle, with the origin at the upper left (using integers).">Rect</a>, Line and Clear).  <br /></td></tr>
<tr class="separator:ab5d39f29732e13b3e5b2dce47f78479f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5583d29c44a38c505d5fd1d830314c8e" id="r_a5583d29c44a38c505d5fd1d830314c8e"><td class="memItemLeft" align="right" valign="top"><a id="a5583d29c44a38c505d5fd1d830314c8e" name="a5583d29c44a38c505d5fd1d830314c8e"></a>
std::optional&lt; <a class="el" href="structSDL_1_1FColor.html">FColor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetDrawColor</b> () const</td></tr>
<tr class="separator:a5583d29c44a38c505d5fd1d830314c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84472282efbcf5b52b2db615f9e9fcaf" id="r_a84472282efbcf5b52b2db615f9e9fcaf"><td class="memItemLeft" align="right" valign="top"><a id="a84472282efbcf5b52b2db615f9e9fcaf" name="a84472282efbcf5b52b2db615f9e9fcaf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetDrawColor</b> (SDL_Color *c) const</td></tr>
<tr class="separator:a84472282efbcf5b52b2db615f9e9fcaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21113c787e4aafd3d0b768a9796d3c0e" id="r_a21113c787e4aafd3d0b768a9796d3c0e"><td class="memItemLeft" align="right" valign="top"><a id="a21113c787e4aafd3d0b768a9796d3c0e" name="a21113c787e4aafd3d0b768a9796d3c0e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetDrawColor</b> (SDL_FColor *c) const</td></tr>
<tr class="separator:a21113c787e4aafd3d0b768a9796d3c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87188c54fb244244994f3c2cdbf78b6" id="r_ae87188c54fb244244994f3c2cdbf78b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#ae87188c54fb244244994f3c2cdbf78b6">GetDrawColor</a> (Uint8 *r, Uint8 *g, Uint8 *b, Uint8 *a) const</td></tr>
<tr class="memdesc:ae87188c54fb244244994f3c2cdbf78b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the color used for drawing operations (<a class="el" href="structSDL_1_1Rect.html" title="A rectangle, with the origin at the upper left (using integers).">Rect</a>, Line and Clear).  <br /></td></tr>
<tr class="separator:ae87188c54fb244244994f3c2cdbf78b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdacc19afd18b9d4777c7479c47aff06" id="r_abdacc19afd18b9d4777c7479c47aff06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#abdacc19afd18b9d4777c7479c47aff06">GetDrawColor</a> (float *r, float *g, float *b, float *a) const</td></tr>
<tr class="memdesc:abdacc19afd18b9d4777c7479c47aff06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the color used for drawing operations (<a class="el" href="structSDL_1_1Rect.html" title="A rectangle, with the origin at the upper left (using integers).">Rect</a>, Line and Clear).  <br /></td></tr>
<tr class="separator:abdacc19afd18b9d4777c7479c47aff06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85566531c35dc2c49e56a577fb4fb060" id="r_a85566531c35dc2c49e56a577fb4fb060"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a85566531c35dc2c49e56a577fb4fb060">SetColorScale</a> (float scale)</td></tr>
<tr class="memdesc:a85566531c35dc2c49e56a577fb4fb060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the color scale used for render operations.  <br /></td></tr>
<tr class="separator:a85566531c35dc2c49e56a577fb4fb060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3455f1ed5c9673fb3560f769fcfdca1" id="r_aa3455f1ed5c9673fb3560f769fcfdca1"><td class="memItemLeft" align="right" valign="top">std::optional&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#aa3455f1ed5c9673fb3560f769fcfdca1">GetColorScale</a> () const</td></tr>
<tr class="memdesc:aa3455f1ed5c9673fb3560f769fcfdca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the color scale used for render operations.  <br /></td></tr>
<tr class="separator:aa3455f1ed5c9673fb3560f769fcfdca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d16732d32a1527f38860ee1cb424953" id="r_a9d16732d32a1527f38860ee1cb424953"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a9d16732d32a1527f38860ee1cb424953">SetDrawBlendMode</a> (<a class="el" href="group__CategoryBlendmode.html#gad02afeb206989ff841629dca2c93e694">BlendMode</a> blendMode)</td></tr>
<tr class="memdesc:a9d16732d32a1527f38860ee1cb424953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the blend mode used for drawing operations (Fill and Line).  <br /></td></tr>
<tr class="separator:a9d16732d32a1527f38860ee1cb424953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157ad97e3ed83a6c87b21cb5094c57b4" id="r_a157ad97e3ed83a6c87b21cb5094c57b4"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="group__CategoryBlendmode.html#gad02afeb206989ff841629dca2c93e694">BlendMode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a157ad97e3ed83a6c87b21cb5094c57b4">GetDrawBlendMode</a> () const</td></tr>
<tr class="memdesc:a157ad97e3ed83a6c87b21cb5094c57b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the blend mode used for drawing operations.  <br /></td></tr>
<tr class="separator:a157ad97e3ed83a6c87b21cb5094c57b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6edc12d14e357905ec3b408f1eaf3b" id="r_aeb6edc12d14e357905ec3b408f1eaf3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#aeb6edc12d14e357905ec3b408f1eaf3b">RenderClear</a> ()</td></tr>
<tr class="memdesc:aeb6edc12d14e357905ec3b408f1eaf3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the current rendering target with the drawing color.  <br /></td></tr>
<tr class="separator:aeb6edc12d14e357905ec3b408f1eaf3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7bceadc05d738847268b50578603c3" id="r_a8e7bceadc05d738847268b50578603c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a8e7bceadc05d738847268b50578603c3">RenderPoint</a> (SDL_FPoint p)</td></tr>
<tr class="memdesc:a8e7bceadc05d738847268b50578603c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a point on the current rendering target at subpixel precision.  <br /></td></tr>
<tr class="separator:a8e7bceadc05d738847268b50578603c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa245447951bf506af88095c44314b565" id="r_aa245447951bf506af88095c44314b565"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#aa245447951bf506af88095c44314b565">RenderPoints</a> (<a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const SDL_FPoint &gt; points)</td></tr>
<tr class="memdesc:aa245447951bf506af88095c44314b565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw multiple points on the current rendering target at subpixel precision.  <br /></td></tr>
<tr class="separator:aa245447951bf506af88095c44314b565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c25e025f1e42de768716e4006123450" id="r_a4c25e025f1e42de768716e4006123450"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a4c25e025f1e42de768716e4006123450">RenderLine</a> (SDL_FPoint p1, SDL_FPoint p2)</td></tr>
<tr class="memdesc:a4c25e025f1e42de768716e4006123450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a line on the current rendering target at subpixel precision.  <br /></td></tr>
<tr class="separator:a4c25e025f1e42de768716e4006123450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95212b469e89d2e43210ddd456d6011b" id="r_a95212b469e89d2e43210ddd456d6011b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a95212b469e89d2e43210ddd456d6011b">RenderLines</a> (<a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const SDL_FPoint &gt; points)</td></tr>
<tr class="memdesc:a95212b469e89d2e43210ddd456d6011b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a series of connected lines on the current rendering target at subpixel precision.  <br /></td></tr>
<tr class="separator:a95212b469e89d2e43210ddd456d6011b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0baac7e747fdca98d7dafb05e35401" id="r_aff0baac7e747fdca98d7dafb05e35401"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#aff0baac7e747fdca98d7dafb05e35401">RenderRect</a> (<a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FRect &gt; rect)</td></tr>
<tr class="memdesc:aff0baac7e747fdca98d7dafb05e35401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a rectangle on the current rendering target at subpixel precision.  <br /></td></tr>
<tr class="separator:aff0baac7e747fdca98d7dafb05e35401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5b1e8fcc7b52a7f2ef04ea6e18a309" id="r_aae5b1e8fcc7b52a7f2ef04ea6e18a309"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#aae5b1e8fcc7b52a7f2ef04ea6e18a309">RenderRects</a> (<a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const SDL_FRect &gt; rects)</td></tr>
<tr class="memdesc:aae5b1e8fcc7b52a7f2ef04ea6e18a309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw some number of rectangles on the current rendering target at subpixel precision.  <br /></td></tr>
<tr class="separator:aae5b1e8fcc7b52a7f2ef04ea6e18a309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cf4e2266ac4aebb2cbe9578f019aa8" id="r_a18cf4e2266ac4aebb2cbe9578f019aa8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a18cf4e2266ac4aebb2cbe9578f019aa8">RenderFillRect</a> (<a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FRect &gt; rect)</td></tr>
<tr class="memdesc:a18cf4e2266ac4aebb2cbe9578f019aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a rectangle on the current rendering target with the drawing color at subpixel precision.  <br /></td></tr>
<tr class="separator:a18cf4e2266ac4aebb2cbe9578f019aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa112dbeabca41279666106c3a3c4adc5" id="r_aa112dbeabca41279666106c3a3c4adc5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#aa112dbeabca41279666106c3a3c4adc5">RenderFillRects</a> (<a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const SDL_FRect &gt; rects)</td></tr>
<tr class="memdesc:aa112dbeabca41279666106c3a3c4adc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill some number of rectangles on the current rendering target with the drawing color at subpixel precision.  <br /></td></tr>
<tr class="separator:aa112dbeabca41279666106c3a3c4adc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac685a8eac163763f9dd2fbc1e7c1cc5b" id="r_ac685a8eac163763f9dd2fbc1e7c1cc5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#ac685a8eac163763f9dd2fbc1e7c1cc5b">RenderTexture</a> (<a class="el" href="group__CategoryRender.html#ga4b68df1674a8dea4fabd4e9ab9e745d7">TextureRef</a> texture, <a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FRect &gt; srcrect, <a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FRect &gt; dstrect)</td></tr>
<tr class="memdesc:ac685a8eac163763f9dd2fbc1e7c1cc5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a portion of the texture to the current rendering target at subpixel precision.  <br /></td></tr>
<tr class="separator:ac685a8eac163763f9dd2fbc1e7c1cc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2a1e67025b9088b791ac12b7ce39f8" id="r_a5d2a1e67025b9088b791ac12b7ce39f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a5d2a1e67025b9088b791ac12b7ce39f8">RenderTextureRotated</a> (<a class="el" href="group__CategoryRender.html#ga4b68df1674a8dea4fabd4e9ab9e745d7">TextureRef</a> texture, <a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FRect &gt; srcrect, <a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FRect &gt; dstrect, double angle, <a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FPoint &gt; center={}, <a class="el" href="group__CategorySurface.html#gaa139652f1cfad9672e6e9898f965812b">FlipMode</a> flip=SDL_FLIP_NONE)</td></tr>
<tr class="memdesc:a5d2a1e67025b9088b791ac12b7ce39f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a portion of the source texture to the current rendering target, with rotation and flipping, at subpixel precision.  <br /></td></tr>
<tr class="separator:a5d2a1e67025b9088b791ac12b7ce39f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8228728e43fc07ec7e7ac63ff3eb73" id="r_adc8228728e43fc07ec7e7ac63ff3eb73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#adc8228728e43fc07ec7e7ac63ff3eb73">RenderTextureAffine</a> (<a class="el" href="group__CategoryRender.html#ga4b68df1674a8dea4fabd4e9ab9e745d7">TextureRef</a> texture, <a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FRect &gt; srcrect, <a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FPoint &gt; origin, <a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FPoint &gt; right, <a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FPoint &gt; down)</td></tr>
<tr class="memdesc:adc8228728e43fc07ec7e7ac63ff3eb73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a portion of the source texture to the current rendering target, with affine transform, at subpixel precision.  <br /></td></tr>
<tr class="separator:adc8228728e43fc07ec7e7ac63ff3eb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f85fc3e77bb94c11da38708374337a" id="r_ae0f85fc3e77bb94c11da38708374337a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#ae0f85fc3e77bb94c11da38708374337a">RenderTextureTiled</a> (<a class="el" href="group__CategoryRender.html#ga4b68df1674a8dea4fabd4e9ab9e745d7">TextureRef</a> texture, <a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FRect &gt; srcrect, float scale, <a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FRect &gt; dstrect)</td></tr>
<tr class="memdesc:ae0f85fc3e77bb94c11da38708374337a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile a portion of the texture to the current rendering target at subpixel precision.  <br /></td></tr>
<tr class="separator:ae0f85fc3e77bb94c11da38708374337a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d4980a4b7dbaf9e088def788f53d13" id="r_a90d4980a4b7dbaf9e088def788f53d13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a90d4980a4b7dbaf9e088def788f53d13">RenderTexture9Grid</a> (<a class="el" href="group__CategoryRender.html#ga4b68df1674a8dea4fabd4e9ab9e745d7">TextureRef</a> texture, <a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FRect &gt; srcrect, float left_width, float right_width, float top_height, float bottom_height, float scale, <a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FRect &gt; dstrect)</td></tr>
<tr class="memdesc:a90d4980a4b7dbaf9e088def788f53d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a scaled copy using the 9-grid algorithm to the current rendering target at subpixel precision.  <br /></td></tr>
<tr class="separator:a90d4980a4b7dbaf9e088def788f53d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e5115b6632a6f0f6b68e5acd5f5b9c" id="r_a73e5115b6632a6f0f6b68e5acd5f5b9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a73e5115b6632a6f0f6b68e5acd5f5b9c">RenderGeometry</a> (<a class="el" href="group__CategoryRender.html#ga4b68df1674a8dea4fabd4e9ab9e745d7">TextureRef</a> texture, std::span&lt; const <a class="el" href="group__CategoryRender.html#ga4b86011ede078f9ba75274ed30df602b">Vertex</a> &gt; vertices, std::span&lt; const int &gt; indices={})</td></tr>
<tr class="memdesc:a73e5115b6632a6f0f6b68e5acd5f5b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a list of triangles, optionally using a texture and indices into the vertex array <a class="el" href="structSDL_1_1Color.html" title="A structure that represents a color as RGBA components.">Color</a> and alpha modulation is done per vertex (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).  <br /></td></tr>
<tr class="separator:a73e5115b6632a6f0f6b68e5acd5f5b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe5c21e5796984337b0e97ae60d6769" id="r_a2fe5c21e5796984337b0e97ae60d6769"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a2fe5c21e5796984337b0e97ae60d6769">RenderGeometryRaw</a> (<a class="el" href="group__CategoryRender.html#ga4b68df1674a8dea4fabd4e9ab9e745d7">TextureRef</a> texture, const float *xy, int xy_stride, const <a class="el" href="structSDL_1_1FColor.html">FColor</a> *color, int color_stride, const float *uv, int uv_stride, int num_vertices, const void *indices, int num_indices, int size_indices)</td></tr>
<tr class="memdesc:a2fe5c21e5796984337b0e97ae60d6769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a list of triangles, optionally using a texture and indices into the vertex arrays <a class="el" href="structSDL_1_1Color.html" title="A structure that represents a color as RGBA components.">Color</a> and alpha modulation is done per vertex (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).  <br /></td></tr>
<tr class="separator:a2fe5c21e5796984337b0e97ae60d6769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9eaca37c44ae44584ec0b69f37d2ca" id="r_a0e9eaca37c44ae44584ec0b69f37d2ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a0e9eaca37c44ae44584ec0b69f37d2ca">RenderReadPixels</a> (<a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_Rect &gt; rect) const</td></tr>
<tr class="memdesc:a0e9eaca37c44ae44584ec0b69f37d2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read pixels from the current rendering target.  <br /></td></tr>
<tr class="separator:a0e9eaca37c44ae44584ec0b69f37d2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0b5783b55fc7542f4d3784430c77d0" id="r_a3c0b5783b55fc7542f4d3784430c77d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a3c0b5783b55fc7542f4d3784430c77d0">Present</a> ()</td></tr>
<tr class="memdesc:a3c0b5783b55fc7542f4d3784430c77d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the screen with any rendering performed since the previous call.  <br /></td></tr>
<tr class="separator:a3c0b5783b55fc7542f4d3784430c77d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf3c91b4c53fdd0b9ca34594b0e87f6" id="r_abaf3c91b4c53fdd0b9ca34594b0e87f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#abaf3c91b4c53fdd0b9ca34594b0e87f6">Flush</a> ()</td></tr>
<tr class="memdesc:abaf3c91b4c53fdd0b9ca34594b0e87f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the rendering context to flush any pending commands and state.  <br /></td></tr>
<tr class="separator:abaf3c91b4c53fdd0b9ca34594b0e87f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f956ae897c56fe35213f70e3d548790" id="r_a7f956ae897c56fe35213f70e3d548790"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a7f956ae897c56fe35213f70e3d548790">SetVSync</a> (int vsync)</td></tr>
<tr class="memdesc:a7f956ae897c56fe35213f70e3d548790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle VSync of the given renderer.  <br /></td></tr>
<tr class="separator:a7f956ae897c56fe35213f70e3d548790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b89b4471bea4dbcab9d63e1aacd871" id="r_aa7b89b4471bea4dbcab9d63e1aacd871"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#aa7b89b4471bea4dbcab9d63e1aacd871">GetVSync</a> () const</td></tr>
<tr class="memdesc:aa7b89b4471bea4dbcab9d63e1aacd871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get VSync of the given renderer.  <br /></td></tr>
<tr class="separator:aa7b89b4471bea4dbcab9d63e1aacd871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5f20990f4aa8ab99b8bd7639b665dc" id="r_abf5f20990f4aa8ab99b8bd7639b665dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#abf5f20990f4aa8ab99b8bd7639b665dc">RenderDebugText</a> (<a class="el" href="structSDL_1_1FPoint.html">FPoint</a> p, <a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str)</td></tr>
<tr class="memdesc:abf5f20990f4aa8ab99b8bd7639b665dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw debug text to an SDL_Renderer.  <br /></td></tr>
<tr class="separator:abf5f20990f4aa8ab99b8bd7639b665dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561ff5daacc18b6a372bcc62324d33e7" id="r_a561ff5daacc18b6a372bcc62324d33e7"><td class="memTemplParams" colspan="2">template&lt;class... ARGS&gt; </td></tr>
<tr class="memitem:a561ff5daacc18b6a372bcc62324d33e7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a561ff5daacc18b6a372bcc62324d33e7">RenderDebugTextFormat</a> (<a class="el" href="structSDL_1_1FPoint.html">FPoint</a> p, <a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> fmt, ARGS... args)</td></tr>
<tr class="memdesc:a561ff5daacc18b6a372bcc62324d33e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw debug text to an SDL_Renderer.  <br /></td></tr>
<tr class="separator:a561ff5daacc18b6a372bcc62324d33e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5798bee1abea5a16b88b6ab0667c76" id="r_a8e5798bee1abea5a16b88b6ab0667c76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1RendererBase.html#a8e5798bee1abea5a16b88b6ab0667c76">Destroy</a> ()</td></tr>
<tr class="memdesc:a8e5798bee1abea5a16b88b6ab0667c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the rendering context for a window and free all associated textures.  <br /></td></tr>
<tr class="separator:a8e5798bee1abea5a16b88b6ab0667c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt;<br />
struct SDL::RendererBase&lt; T &gt;</div><dl class="section user"><dt>Category:</dt><dd><a class="el" href="resource.html">Resource</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd>resource </dd>
<dd>
<a class="el" href="group__CategoryRender.html#gaf76226a4b7cbb3af8578bdbd93f6b068" title="Handle to an owned renderer.">Renderer</a> </dd>
<dd>
<a class="el" href="group__CategoryVideo.html#ga3c15747c0c3091d37a2f14511aba1c7d" title="Handle to a non owned renderer.">RendererRef</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6cd596ee84afc3ead3c26a6c429a797c" name="a6cd596ee84afc3ead3c26a6c429a797c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd596ee84afc3ead3c26a6c429a797c">&#9670;&#160;</a></span>RendererBase() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RendererBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryVideo.html#ga42069207012bd44674fe1677bd5a1066">WindowRef</a>&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>By default the rendering size matches the window size in pixels, but you can call SDL_SetRenderLogicalPresentation() to change the content size and scaling options.</p>
<p>It renderer creation fails for any reason this object is falsy; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>the window where rendering is displayed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread. </dd></dl>

</div>
</div>
<a id="a40139cb8ccb05de0bfa1de252a16a413" name="a40139cb8ccb05de0bfa1de252a16a413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40139cb8ccb05de0bfa1de252a16a413">&#9670;&#160;</a></span>RendererBase() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RendererBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryVideo.html#ga42069207012bd44674fe1677bd5a1066">WindowRef</a>&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If you want a specific renderer, you can specify its name here. A list of available renderers can be obtained by calling SDL_GetRenderDriver() multiple times, with indices from 0 to SDL_GetNumRenderDrivers()-1. If you don't need a specific renderer, specify NULL and <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> will attempt to choose the best option for you, based on what is available on the user's system.</p>
<p>If <code>name</code> is a comma-separated list, <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> will try each name, in the order listed, until one succeeds or all of them fail.</p>
<p>By default the rendering size matches the window size in pixels, but you can call SDL_SetRenderLogicalPresentation() to change the content size and scaling options.</p>
<p>It renderer creation fails for any reason this object is falsy; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>the window where rendering is displayed. </td></tr>
    <tr><td class="paramname">name</td><td>the name of the rendering driver to initialize</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryRender.html#gaeb8dc812e83b8aee07c7bc37d233d599" title="Get the number of 2D rendering drivers available for the current display.">GetNumRenderDrivers()</a> </dd>
<dd>
<a class="el" href="group__CategoryRender.html#gaec060bae8c84c9565bf316e335b36c5a" title="Use this function to get the name of a built in 2D rendering driver.">GetRenderDriver()</a> </dd>
<dd>
GetRendererName() </dd></dl>

</div>
</div>
<a id="ac2e35780944151019d207ce15e91e6bc" name="ac2e35780944151019d207ce15e91e6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e35780944151019d207ce15e91e6bc">&#9670;&#160;</a></span>RendererBase() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RendererBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryProperties.html#gaa5faab1a5ca99f759b68b5800ab0697f">PropertiesRef</a>&#160;</td>
          <td class="paramname"><em>props</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>These are the supported properties:</p>
<ul>
<li><code>SDL_PROP_RENDERER_CREATE_NAME_STRING</code>: the name of the rendering driver to use, if a specific one is desired</li>
<li><code>SDL_PROP_RENDERER_CREATE_WINDOW_POINTER</code>: the window where rendering is displayed, required if this isn't a software renderer using a surface</li>
<li><code>SDL_PROP_RENDERER_CREATE_SURFACE_POINTER</code>: the surface where rendering is displayed, if you want a software renderer without a window</li>
<li><code>SDL_PROP_RENDERER_CREATE_OUTPUT_COLORSPACE_NUMBER</code>: an SDL_Colorspace value describing the colorspace for output to the display, defaults to SDL_COLORSPACE_SRGB. The direct3d11, direct3d12, and metal renderers support SDL_COLORSPACE_SRGB_LINEAR, which is a linear color space and supports HDR output. If you select SDL_COLORSPACE_SRGB_LINEAR, drawing still uses the sRGB colorspace, but values can go beyond 1.0 and float (linear) format textures can be used for HDR content.</li>
<li><code>SDL_PROP_RENDERER_CREATE_PRESENT_VSYNC_NUMBER</code>: non-zero if you want present synchronized with the refresh rate. This property can take any value that is supported by SDL_SetRenderVSync() for the renderer.</li>
</ul>
<p>With the vulkan renderer:</p>
<ul>
<li><code>SDL_PROP_RENDERER_CREATE_VULKAN_INSTANCE_POINTER</code>: the VkInstance to use with the renderer, optional.</li>
<li><code>SDL_PROP_RENDERER_CREATE_VULKAN_SURFACE_NUMBER</code>: the VkSurfaceKHR to use with the renderer, optional.</li>
<li><code>SDL_PROP_RENDERER_CREATE_VULKAN_PHYSICAL_DEVICE_POINTER</code>: the VkPhysicalDevice to use with the renderer, optional.</li>
<li><code>SDL_PROP_RENDERER_CREATE_VULKAN_DEVICE_POINTER</code>: the VkDevice to use with the renderer, optional.</li>
<li><code>SDL_PROP_RENDERER_CREATE_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER</code>: the queue family index used for rendering.</li>
<li><code>SDL_PROP_RENDERER_CREATE_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER</code>: the queue family index used for presentation.</li>
</ul>
<p>It renderer creation fails for any reason this object is falsy; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">props</td><td>the properties to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryProperties.html#ga06dc2e7d322964dbf2cb788b9cbaf7e5" title="Handle to an owned properties.">Properties</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RendererBase.html#a25e12268f5d4a0d7fdb63c448762aced" title="Get the name of a renderer.">GetName()</a> </dd></dl>

</div>
</div>
<a id="ab46ac713dd82379701bb276f3d081d92" name="ab46ac713dd82379701bb276f3d081d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46ac713dd82379701bb276f3d081d92">&#9670;&#160;</a></span>RendererBase() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RendererBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategorySurface.html#ga2ea8e6016ec594c51738ef06f469d5d2">SurfaceRef</a>&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Two other API which can be used to create Renderer: <a class="el" href="structSDL_1_1RendererBase.html#a6cd596ee84afc3ead3c26a6c429a797c" title="Create a 2D rendering context for a window.">RendererBase(WindowRef)</a> and SDL_CreateWindowAndRenderer(WindowRef,
StringParam). These can <em>also</em> create a software renderer, but they are intended to be used with an Window as the final destination and not an Surface.</p>
<p>It renderer creation fails for any reason this object is falsy; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>the SDL_Surface structure representing the surface where rendering is done.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8883859100726a7c7f08134ee0fc0229" name="a8883859100726a7c7f08134ee0fc0229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8883859100726a7c7f08134ee0fc0229">&#9670;&#160;</a></span>ConvertEventToRenderCoordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::ConvertEventToRenderCoordinates </td>
          <td>(</td>
          <td class="paramtype">SDL_Event *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This takes into account several states:</p>
<ul>
<li>The window dimensions.</li>
<li>The logical presentation settings (SDL_SetRenderLogicalPresentation)</li>
<li>The scale (SDL_SetRenderScale)</li>
<li>The viewport (SDL_SetRenderViewport)</li>
</ul>
<p>Various event types are converted with this function: mouse, touch, pen, etc.</p>
<p>Touch coordinates are converted from normalized coordinates in the window to non-normalized rendering coordinates.</p>
<p>Relative mouse coordinates (xrel and yrel event fields) are <em>also</em> converted. Applications that do not want these fields converted should use SDL_RenderCoordinatesFromWindow() on the specific event fields instead of converting the entire event structure.</p>
<p>Once converted, coordinates may be outside the rendering area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>the event to modify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_RenderCoordinatesFromWindow </dd></dl>

</div>
</div>
<a id="a8e5798bee1abea5a16b88b6ab0667c76" name="a8e5798bee1abea5a16b88b6ab0667c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5798bee1abea5a16b88b6ab0667c76">&#9670;&#160;</a></span>Destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::Destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This object becomes empty after the call.</p>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_CreateRenderer </dd></dl>

</div>
</div>
<a id="abaf3c91b4c53fdd0b9ca34594b0e87f6" name="abaf3c91b4c53fdd0b9ca34594b0e87f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf3c91b4c53fdd0b9ca34594b0e87f6">&#9670;&#160;</a></span>Flush()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::Flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You do not need to (and in fact, shouldn't) call this function unless you are planning to call into OpenGL/Direct3D/Metal/whatever directly, in addition to using an SDL_Renderer.</p>
<p>This is for a very-specific case: if you are using <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a>'s render API, and you plan to make OpenGL/D3D/whatever calls in addition to <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> render API calls. If this applies, you should call this function between calls to <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a>'s render API and the low-level API you're using in cooperation.</p>
<p>In all other cases, you can ignore this function.</p>
<p>This call makes <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> flush any pending rendering work it was queueing up to do later in a single batch, and marks any internal cached state as invalid, so it'll prepare all its state again later, from scratch.</p>
<p>This means you do not need to save state in your rendering code to protect the <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> renderer. However, there lots of arbitrary pieces of Direct3D and OpenGL state that can confuse things; you should use your best judgment and be prepared to make changes if specific state needs to be protected.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a755bccca740076de95e4a4a889a54b48" name="a755bccca740076de95e4a4a889a54b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755bccca740076de95e4a4a889a54b48">&#9670;&#160;</a></span>GetClipRect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structSDL_1_1Rect.html">Rect</a> &gt; <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::GetClipRect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the rect filled in with the current clipping area or an empty rectangle if clipping is disabled on success; std::nullopt on failure, call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ClipEnabled() </dd>
<dd>
<a class="el" href="structSDL_1_1RendererBase.html#af6809765651f06b11bd0711c60d24633" title="Set the clip rectangle for rendering on the specified target.">SetClipRect()</a> </dd></dl>

</div>
</div>
<a id="aa3455f1ed5c9673fb3560f769fcfdca1" name="aa3455f1ed5c9673fb3560f769fcfdca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3455f1ed5c9673fb3560f769fcfdca1">&#9670;&#160;</a></span>GetColorScale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; float &gt; <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::GetColorScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a float representing the current color scale on success or std::nullopt on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#a85566531c35dc2c49e56a577fb4fb060" title="Set the color scale used for render operations.">SetColorScale()</a> </dd></dl>

</div>
</div>
<a id="a8fc01bda29bd2bc7d1e3f848c8b194fd" name="a8fc01bda29bd2bc7d1e3f848c8b194fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc01bda29bd2bc7d1e3f848c8b194fd">&#9670;&#160;</a></span>GetCurrentOutputSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::GetCurrentOutputSize </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If a rendering target is active, this will return the size of the rendering target in pixels, otherwise if a logical size is set, it will return the logical size, otherwise it will return the value of SDL_GetRenderOutputSize().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>a pointer filled in with the current width. </td></tr>
    <tr><td class="paramname">h</td><td>a pointer filled in with the current height. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>GetOutputSize() </dd></dl>

</div>
</div>
<a id="a157ad97e3ed83a6c87b21cb5094c57b4" name="a157ad97e3ed83a6c87b21cb5094c57b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a157ad97e3ed83a6c87b21cb5094c57b4">&#9670;&#160;</a></span>GetDrawBlendMode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="group__CategoryBlendmode.html#gad02afeb206989ff841629dca2c93e694">BlendMode</a> &gt; <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::GetDrawBlendMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the current BlendMode on success or std::nullopt on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#a9d16732d32a1527f38860ee1cb424953" title="Set the blend mode used for drawing operations (Fill and Line).">SetDrawBlendMode()</a> </dd></dl>

</div>
</div>
<a id="abdacc19afd18b9d4777c7479c47aff06" name="abdacc19afd18b9d4777c7479c47aff06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdacc19afd18b9d4777c7479c47aff06">&#9670;&#160;</a></span>GetDrawColor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::GetDrawColor </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>a pointer filled in with the red value used to draw on the rendering target. </td></tr>
    <tr><td class="paramname">g</td><td>a pointer filled in with the green value used to draw on the rendering target. </td></tr>
    <tr><td class="paramname">b</td><td>a pointer filled in with the blue value used to draw on the rendering target. </td></tr>
    <tr><td class="paramname">a</td><td>a pointer filled in with the alpha value used to draw on the rendering target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SetDrawColorFloat() </dd>
<dd>
GetDrawColor() </dd></dl>

</div>
</div>
<a id="ae87188c54fb244244994f3c2cdbf78b6" name="ae87188c54fb244244994f3c2cdbf78b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87188c54fb244244994f3c2cdbf78b6">&#9670;&#160;</a></span>GetDrawColor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::GetDrawColor </td>
          <td>(</td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>a pointer filled in with the red value used to draw on the rendering target. </td></tr>
    <tr><td class="paramname">g</td><td>a pointer filled in with the green value used to draw on the rendering target. </td></tr>
    <tr><td class="paramname">b</td><td>a pointer filled in with the blue value used to draw on the rendering target. </td></tr>
    <tr><td class="paramname">a</td><td>a pointer filled in with the alpha value used to draw on the rendering target; usually <code>SDL_ALPHA_OPAQUE</code> (255). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>GetDrawColorFloat() </dd>
<dd>
<a class="el" href="structSDL_1_1RendererBase.html#a7dc3966cdb024d1061115f0e79af6867" title="Set the color used for drawing operations.">SetDrawColor()</a> </dd></dl>

</div>
</div>
<a id="a04d0ed84af87f05209122dccf4a39722" name="a04d0ed84af87f05209122dccf4a39722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d0ed84af87f05209122dccf4a39722">&#9670;&#160;</a></span>GetLogicalPresentation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::GetLogicalPresentation </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryRender.html#ga91be24b12fa4efe591c43f2ece44e32d">RendererLogicalPresentation</a> *&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function gets the width and height of the logical rendering output, or the output size in pixels if a logical resolution is not enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>an int to be filled with the width. </td></tr>
    <tr><td class="paramname">h</td><td>an int to be filled with the height. </td></tr>
    <tr><td class="paramname">mode</td><td>the presentation mode used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#af6989d7e5c77b8af134de07765c00344" title="Set a device independent resolution and presentation mode for rendering.">SetLogicalPresentation()</a> </dd></dl>

</div>
</div>
<a id="ad0a46c5ec2a153ed79933f1efb2eafbb" name="ad0a46c5ec2a153ed79933f1efb2eafbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a46c5ec2a153ed79933f1efb2eafbb">&#9670;&#160;</a></span>GetLogicalPresentation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::GetLogicalPresentation </td>
          <td>(</td>
          <td class="paramtype">SDL_Point *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryRender.html#ga91be24b12fa4efe591c43f2ece44e32d">RendererLogicalPresentation</a> *&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function gets the width and height of the logical rendering output, or the output size in pixels if a logical resolution is not enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>a <a class="el" href="structSDL_1_1Point.html" title="The structure that defines a point (using integers)">Point</a> to be filled with the width and height. </td></tr>
    <tr><td class="paramname">mode</td><td>the presentation mode used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#af6989d7e5c77b8af134de07765c00344" title="Set a device independent resolution and presentation mode for rendering.">SetLogicalPresentation()</a> </dd></dl>

</div>
</div>
<a id="a4e231417b3b5cee3048276f4ed5ac701" name="a4e231417b3b5cee3048276f4ed5ac701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e231417b3b5cee3048276f4ed5ac701">&#9670;&#160;</a></span>GetLogicalPresentationRect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structSDL_1_1FRect.html">FRect</a> &gt; <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::GetLogicalPresentationRect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the calculated rectangle used for logical presentation, based on the presentation mode and output size. If logical presentation is disabled, it will fill the rectangle with the output size, in pixels.</p>
<dl class="section return"><dt>Returns</dt><dd>the rect with the final presentation rectangle on success or std::nullopt on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#af6989d7e5c77b8af134de07765c00344" title="Set a device independent resolution and presentation mode for rendering.">SetLogicalPresentation()</a> </dd></dl>

</div>
</div>
<a id="a25e12268f5d4a0d7fdb63c448762aced" name="a25e12268f5d4a0d7fdb63c448762aced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e12268f5d4a0d7fdb63c448762aced">&#9670;&#160;</a></span>GetName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::GetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the name of the selected renderer, or NULL on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a7ede670010086138ad523545e0b14be9" name="a7ede670010086138ad523545e0b14be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ede670010086138ad523545e0b14be9">&#9670;&#160;</a></span>GetOutputSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::GetOutputSize </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This returns the true output size in pixels, ignoring any render targets or logical size and presentation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>a pointer filled in with the width in pixels. </td></tr>
    <tr><td class="paramname">h</td><td>a pointer filled in with the height in pixels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>GetCurrentOutputSize() </dd></dl>

</div>
</div>
<a id="a2a311b6d4c3597689ffe65718208a1f5" name="a2a311b6d4c3597689ffe65718208a1f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a311b6d4c3597689ffe65718208a1f5">&#9670;&#160;</a></span>GetProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategoryProperties.html#gaa5faab1a5ca99f759b68b5800ab0697f">PropertiesRef</a> <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::GetProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The following read-only properties are provided by <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a>:</p>
<ul>
<li><code>SDL_PROP_RENDERER_NAME_STRING</code>: the name of the rendering driver</li>
<li><code>SDL_PROP_RENDERER_WINDOW_POINTER</code>: the window where rendering is displayed, if any</li>
<li><code>SDL_PROP_RENDERER_SURFACE_POINTER</code>: the surface where rendering is displayed, if this is a software renderer without a window</li>
<li><code>SDL_PROP_RENDERER_VSYNC_NUMBER</code>: the current vsync setting</li>
<li><code>SDL_PROP_RENDERER_MAX_TEXTURE_SIZE_NUMBER</code>: the maximum texture width and height</li>
<li><code>SDL_PROP_RENDERER_TEXTURE_FORMATS_POINTER</code>: a (const SDL_PixelFormat *) array of pixel formats, terminated with SDL_PIXELFORMAT_UNKNOWN, representing the available texture formats for this renderer.</li>
<li><code>SDL_PROP_RENDERER_OUTPUT_COLORSPACE_NUMBER</code>: an SDL_Colorspace value describing the colorspace for output to the display, defaults to SDL_COLORSPACE_SRGB.</li>
<li><code>SDL_PROP_RENDERER_HDR_ENABLED_BOOLEAN</code>: true if the output colorspace is SDL_COLORSPACE_SRGB_LINEAR and the renderer is showing on a display with HDR enabled. This property can change dynamically when SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.</li>
<li><code>SDL_PROP_RENDERER_SDR_WHITE_POINT_FLOAT</code>: the value of SDR white in the SDL_COLORSPACE_SRGB_LINEAR colorspace. When HDR is enabled, this value is automatically multiplied into the color scale. This property can change dynamically when SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.</li>
<li><code>SDL_PROP_RENDERER_HDR_HEADROOM_FLOAT</code>: the additional high dynamic range that can be displayed, in terms of the SDR white point. When HDR is not enabled, this will be 1.0. This property can change dynamically when SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.</li>
</ul>
<p>With the direct3d renderer:</p>
<ul>
<li><code>SDL_PROP_RENDERER_D3D9_DEVICE_POINTER</code>: the IDirect3DDevice9 associated with the renderer</li>
</ul>
<p>With the direct3d11 renderer:</p>
<ul>
<li><code>SDL_PROP_RENDERER_D3D11_DEVICE_POINTER</code>: the ID3D11Device associated with the renderer</li>
<li><code>SDL_PROP_RENDERER_D3D11_SWAPCHAIN_POINTER</code>: the IDXGISwapChain1 associated with the renderer. This may change when the window is resized.</li>
</ul>
<p>With the direct3d12 renderer:</p>
<ul>
<li><code>SDL_PROP_RENDERER_D3D12_DEVICE_POINTER</code>: the ID3D12Device associated with the renderer</li>
<li><code>SDL_PROP_RENDERER_D3D12_SWAPCHAIN_POINTER</code>: the IDXGISwapChain4 associated with the renderer.</li>
<li><code>SDL_PROP_RENDERER_D3D12_COMMAND_QUEUE_POINTER</code>: the ID3D12CommandQueue associated with the renderer</li>
</ul>
<p>With the vulkan renderer:</p>
<ul>
<li><code>SDL_PROP_RENDERER_VULKAN_INSTANCE_POINTER</code>: the VkInstance associated with the renderer</li>
<li><code>SDL_PROP_RENDERER_VULKAN_SURFACE_NUMBER</code>: the VkSurfaceKHR associated with the renderer</li>
<li><code>SDL_PROP_RENDERER_VULKAN_PHYSICAL_DEVICE_POINTER</code>: the VkPhysicalDevice associated with the renderer</li>
<li><code>SDL_PROP_RENDERER_VULKAN_DEVICE_POINTER</code>: the VkDevice associated with the renderer</li>
<li><code>SDL_PROP_RENDERER_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER</code>: the queue family index used for rendering</li>
<li><code>SDL_PROP_RENDERER_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER</code>: the queue family index used for presentation</li>
<li><code>SDL_PROP_RENDERER_VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER</code>: the number of swapchain images, or potential frames in flight, used by the Vulkan renderer</li>
</ul>
<p>With the gpu renderer:</p>
<ul>
<li><code>SDL_PROP_RENDERER_GPU_DEVICE_POINTER</code>: the SDL_GPUDevice associated with the renderer</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a valid property ID on success or 0 on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a8ea5bb6aff35c2777433b0c659b6e486" name="a8ea5bb6aff35c2777433b0c659b6e486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea5bb6aff35c2777433b0c659b6e486">&#9670;&#160;</a></span>GetSafeArea()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structSDL_1_1Rect.html">Rect</a> &gt; <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::GetSafeArea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Some devices have portions of the screen which are partially obscured or not interactive, possibly due to on-screen controls, curved edges, camera notches, TV overscan, etc. This function provides the area of the current viewport which is safe to have interactible content. You should continue rendering into the rest of the render target, but it should not contain visually important or interactible content.</p>
<dl class="section return"><dt>Returns</dt><dd>the rect filled the area that is safe for interactive content on success or std::nullopt on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a2575fc8ac70cc87bb27d98beaa89fe25" name="a2575fc8ac70cc87bb27d98beaa89fe25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2575fc8ac70cc87bb27d98beaa89fe25">&#9670;&#160;</a></span>GetScale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::GetScale </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>scaleX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>scaleY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleX</td><td>a pointer filled in with the horizontal scaling factor. </td></tr>
    <tr><td class="paramname">scaleY</td><td>a pointer filled in with the vertical scaling factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#aaf2e2c2a7eab09a2252d67b43a7de7eb" title="Set the drawing scale for rendering on the current target.">SetScale()</a> </dd></dl>

</div>
</div>
<a id="a0a08906b9ff3d00e0ad75107e991f5d1" name="a0a08906b9ff3d00e0ad75107e991f5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a08906b9ff3d00e0ad75107e991f5d1">&#9670;&#160;</a></span>GetTarget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategoryRender.html#ga4b68df1674a8dea4fabd4e9ab9e745d7">TextureRef</a> <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::GetTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default render target is the window for which the renderer was created, and is reported a NULL here.</p>
<dl class="section return"><dt>Returns</dt><dd>the current render target or NULL for the default render target.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#a00f6fe44be445493f8ee9384bf764c87" title="Set a texture as the current rendering target.">SetTarget()</a> </dd></dl>

</div>
</div>
<a id="ad74c59e900e3ffd5a6ff9f5258fefef8" name="ad74c59e900e3ffd5a6ff9f5258fefef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74c59e900e3ffd5a6ff9f5258fefef8">&#9670;&#160;</a></span>GetViewport()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structSDL_1_1Rect.html">Rect</a> &gt; <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::GetViewport </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Each render target has its own viewport. This function gets the viewport for the current render target.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#ab2908ff72f1fcfe85cd2c9b2ce703fca" title="Return whether an explicit rectangle was set as the viewport.">IsViewportSet()</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RendererBase.html#a1f48812426d05f0ac160cb1b116c6932" title="Set the drawing area for rendering on the current target.">SetViewport()</a> </dd></dl>

</div>
</div>
<a id="aa7b89b4471bea4dbcab9d63e1aacd871" name="aa7b89b4471bea4dbcab9d63e1aacd871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b89b4471bea4dbcab9d63e1aacd871">&#9670;&#160;</a></span>GetVSync()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; int &gt; <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::GetVSync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the current vertical refresh sync interval on success or std::nullopt on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#a7f956ae897c56fe35213f70e3d548790" title="Toggle VSync of the given renderer.">SetVSync()</a> </dd></dl>

</div>
</div>
<a id="a2453f319060765f13e80ef49b77e8a39" name="a2453f319060765f13e80ef49b77e8a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2453f319060765f13e80ef49b77e8a39">&#9670;&#160;</a></span>GetWindow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategoryVideo.html#ga42069207012bd44674fe1677bd5a1066">WindowRef</a> <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::GetWindow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the window on success or NULL on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="aeeec4f8fc6eb0fe6a742aafa04609fef" name="aeeec4f8fc6eb0fe6a742aafa04609fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeec4f8fc6eb0fe6a742aafa04609fef">&#9670;&#160;</a></span>IsClipEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::IsClipEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if clipping is enabled or false if not; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#a755bccca740076de95e4a4a889a54b48" title="Get the clip rectangle for the current target.">GetClipRect()</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RendererBase.html#af6809765651f06b11bd0711c60d24633" title="Set the clip rectangle for rendering on the specified target.">SetClipRect()</a> </dd></dl>

</div>
</div>
<a id="ab2908ff72f1fcfe85cd2c9b2ce703fca" name="ab2908ff72f1fcfe85cd2c9b2ce703fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2908ff72f1fcfe85cd2c9b2ce703fca">&#9670;&#160;</a></span>IsViewportSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::IsViewportSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is useful if you're saving and restoring the viewport and want to know whether you should restore a specific rectangle or NULL. Note that the viewport is always reset when changing rendering targets.</p>
<p>Each render target has its own viewport. This function checks the viewport for the current render target.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the viewport was set to a specific rectangle, or false if it was set to NULL (the entire target).</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#ad74c59e900e3ffd5a6ff9f5258fefef8" title="Get the drawing area for the current target.">GetViewport()</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RendererBase.html#a1f48812426d05f0ac160cb1b116c6932" title="Set the drawing area for rendering on the current target.">SetViewport()</a> </dd></dl>

</div>
</div>
<a id="a3c0b5783b55fc7542f4d3784430c77d0" name="a3c0b5783b55fc7542f4d3784430c77d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0b5783b55fc7542f4d3784430c77d0">&#9670;&#160;</a></span>Present()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::Present </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a>'s rendering functions operate on a backbuffer; that is, calling a rendering function such as SDL_RenderLine() does not directly put a line on the screen, but rather updates the backbuffer. As such, you compose your entire scene and <em>present</em> the composed backbuffer to the screen as a complete picture.</p>
<p>Therefore, when using <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a>'s rendering API, one does all drawing intended for the frame, and then calls this function once per frame to present the final drawing to the user.</p>
<p>The backbuffer should be considered invalidated after each present; do not assume that previous contents will exist between frames. You are strongly encouraged to call SDL_RenderClear() to initialize the backbuffer before starting each new frame's drawing, even if you plan to overwrite every pixel.</p>
<p>Please note, that in case of rendering to a texture - there is <b>no need</b> to call <code>SDL_RenderPresent</code> after drawing needed objects to a texture, and should not be done; you are only required to change back the rendering target to default via <code>SDL_SetRenderTarget(renderer, NULL)</code> afterwards, as textures by themselves do not have a concept of backbuffers. Calling SDL_RenderPresent while rendering to a texture will still update the screen with any current drawing that has been done <em>to the window itself</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#aeb6edc12d14e357905ec3b408f1eaf3b" title="Clear the current rendering target with the drawing color.">RenderClear()</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RendererBase.html#a18cf4e2266ac4aebb2cbe9578f019aa8" title="Fill a rectangle on the current rendering target with the drawing color at subpixel precision.">RenderFillRect()</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RendererBase.html#aa112dbeabca41279666106c3a3c4adc5" title="Fill some number of rectangles on the current rendering target with the drawing color at subpixel pre...">RenderFillRects()</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RendererBase.html#a4c25e025f1e42de768716e4006123450" title="Draw a line on the current rendering target at subpixel precision.">RenderLine()</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RendererBase.html#a95212b469e89d2e43210ddd456d6011b" title="Draw a series of connected lines on the current rendering target at subpixel precision.">RenderLines()</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RendererBase.html#a8e7bceadc05d738847268b50578603c3" title="Draw a point on the current rendering target at subpixel precision.">RenderPoint()</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RendererBase.html#aa245447951bf506af88095c44314b565" title="Draw multiple points on the current rendering target at subpixel precision.">RenderPoints()</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RendererBase.html#aff0baac7e747fdca98d7dafb05e35401" title="Draw a rectangle on the current rendering target at subpixel precision.">RenderRect()</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RendererBase.html#aae5b1e8fcc7b52a7f2ef04ea6e18a309" title="Draw some number of rectangles on the current rendering target at subpixel precision.">RenderRects()</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RendererBase.html#a9d16732d32a1527f38860ee1cb424953" title="Set the blend mode used for drawing operations (Fill and Line).">SetDrawBlendMode()</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RendererBase.html#a7dc3966cdb024d1061115f0e79af6867" title="Set the color used for drawing operations.">SetDrawColor()</a> </dd></dl>

</div>
</div>
<a id="aeb6edc12d14e357905ec3b408f1eaf3b" name="aeb6edc12d14e357905ec3b408f1eaf3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6edc12d14e357905ec3b408f1eaf3b">&#9670;&#160;</a></span>RenderClear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RenderClear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function clears the entire rendering target, ignoring the viewport and the clip rectangle. Note, that clearing will also set/fill all pixels of the rendering target to current renderer draw color, so make sure to invoke SDL_SetRenderDrawColor() when needed.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#a7dc3966cdb024d1061115f0e79af6867" title="Set the color used for drawing operations.">SetDrawColor()</a> </dd></dl>

</div>
</div>
<a id="a59c7fdbb523366fa5691fa2cd18bf7f3" name="a59c7fdbb523366fa5691fa2cd18bf7f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c7fdbb523366fa5691fa2cd18bf7f3">&#9670;&#160;</a></span>RenderCoordinatesFromWindow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structSDL_1_1FPoint.html">FPoint</a> &gt; <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RenderCoordinatesFromWindow </td>
          <td>(</td>
          <td class="paramtype">const SDL_FPoint &amp;&#160;</td>
          <td class="paramname"><em>window_coord</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This takes into account several states:</p>
<ul>
<li>The window dimensions.</li>
<li>The logical presentation settings (SDL_SetRenderLogicalPresentation)</li>
<li>The scale (SDL_SetRenderScale)</li>
<li>The viewport (SDL_SetRenderViewport)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window_coord</td><td>the x, y coordinate in window coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="structSDL_1_1FPoint.html" title="The structure that defines a point (using floating point values).">FPoint</a> containing ther render coordinates on success or std::nullopt on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#af6989d7e5c77b8af134de07765c00344" title="Set a device independent resolution and presentation mode for rendering.">SetLogicalPresentation()</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RendererBase.html#aaf2e2c2a7eab09a2252d67b43a7de7eb" title="Set the drawing scale for rendering on the current target.">SetScale()</a> </dd></dl>

</div>
</div>
<a id="a4ee953b66b42c5d7672db78aa5a7e735" name="a4ee953b66b42c5d7672db78aa5a7e735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee953b66b42c5d7672db78aa5a7e735">&#9670;&#160;</a></span>RenderCoordinatesToWindow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structSDL_1_1FPoint.html">FPoint</a> &gt; <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RenderCoordinatesToWindow </td>
          <td>(</td>
          <td class="paramtype">const SDL_FPoint &amp;&#160;</td>
          <td class="paramname"><em>coord</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This takes into account several states:</p>
<ul>
<li>The window dimensions.</li>
<li>The logical presentation settings (SDL_SetRenderLogicalPresentation)</li>
<li>The scale (SDL_SetRenderScale)</li>
<li>The viewport (SDL_SetRenderViewport)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coord</td><td>the x, y coordinate in render coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="structSDL_1_1FPoint.html" title="The structure that defines a point (using floating point values).">FPoint</a> filled with window coordinates on success or std::nullopt on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#af6989d7e5c77b8af134de07765c00344" title="Set a device independent resolution and presentation mode for rendering.">SetLogicalPresentation()</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RendererBase.html#aaf2e2c2a7eab09a2252d67b43a7de7eb" title="Set the drawing scale for rendering on the current target.">SetScale()</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RendererBase.html#a1f48812426d05f0ac160cb1b116c6932" title="Set the drawing area for rendering on the current target.">SetViewport()</a> </dd></dl>

</div>
</div>
<a id="abf5f20990f4aa8ab99b8bd7639b665dc" name="abf5f20990f4aa8ab99b8bd7639b665dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5f20990f4aa8ab99b8bd7639b665dc">&#9670;&#160;</a></span>RenderDebugText()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RenderDebugText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1FPoint.html">FPoint</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will render a string of text to an SDL_Renderer. Note that this is a convenience function for debugging, with severe limitations, and not intended to be used for production apps and games.</p>
<p>Among these limitations:</p>
<ul>
<li>It accepts UTF-8 strings, but will only renders ASCII characters.</li>
<li>It has a single, tiny size (8x8 pixels). One can use logical presentation or scaling to adjust it, but it will be blurry.</li>
<li>It uses a simple, hardcoded bitmap font. It does not allow different font selections and it does not support truetype, for proper scaling.</li>
<li>It does no word-wrapping and does not treat newline characters as a line break. If the text goes out of the window, it's gone.</li>
</ul>
<p>For serious text rendering, there are several good options, such as SDL_ttf, stb_truetype, or other external libraries.</p>
<p>On first use, this will create an internal texture for rendering glyphs. This texture will live until the renderer is destroyed.</p>
<p>The text is drawn in the color specified by SDL_SetRenderDrawColor().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the x, y coordinates where the top-left corner of the text will draw. </td></tr>
    <tr><td class="paramname">str</td><td>the string to render. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>DebugTextFormat() </dd>
<dd>
SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE </dd></dl>

</div>
</div>
<a id="a561ff5daacc18b6a372bcc62324d33e7" name="a561ff5daacc18b6a372bcc62324d33e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561ff5daacc18b6a372bcc62324d33e7">&#9670;&#160;</a></span>RenderDebugTextFormat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<div class="memtemplate">
template&lt;class... ARGS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RenderDebugTextFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1FPoint.html">FPoint</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will render a std::format()-style format string to a renderer. Note that this is a convenience function for debugging, with severe limitations, and is not intended to be used for production apps and games.</p>
<p>For the full list of limitations and other useful information, see SDL_RenderDebugText.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the x, y coordinates where the top-left corner of the text will draw. </td></tr>
    <tr><td class="paramname">fmt</td><td>the format string to draw. </td></tr>
    <tr><td class="paramname">args</td><td>additional parameters matching {} tokens in the <code>fmt</code> string, if any. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#abf5f20990f4aa8ab99b8bd7639b665dc" title="Draw debug text to an SDL_Renderer.">RenderDebugText()</a> </dd>
<dd>
SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE </dd></dl>

</div>
</div>
<a id="a18cf4e2266ac4aebb2cbe9578f019aa8" name="a18cf4e2266ac4aebb2cbe9578f019aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18cf4e2266ac4aebb2cbe9578f019aa8">&#9670;&#160;</a></span>RenderFillRect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RenderFillRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FRect &gt;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>a pointer to the destination rectangle, or std::nullopt for the entire rendering target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_RenderFillRects </dd></dl>

</div>
</div>
<a id="aa112dbeabca41279666106c3a3c4adc5" name="aa112dbeabca41279666106c3a3c4adc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa112dbeabca41279666106c3a3c4adc5">&#9670;&#160;</a></span>RenderFillRects()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RenderFillRects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const SDL_FRect &gt;&#160;</td>
          <td class="paramname"><em>rects</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rects</td><td>a pointer to an array of destination rectangles. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_RenderFillRect </dd></dl>

</div>
</div>
<a id="a73e5115b6632a6f0f6b68e5acd5f5b9c" name="a73e5115b6632a6f0f6b68e5acd5f5b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e5115b6632a6f0f6b68e5acd5f5b9c">&#9670;&#160;</a></span>RenderGeometry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RenderGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryRender.html#ga4b68df1674a8dea4fabd4e9ab9e745d7">TextureRef</a>&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const <a class="el" href="group__CategoryRender.html#ga4b86011ede078f9ba75274ed30df602b">Vertex</a> &gt;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const int &gt;&#160;</td>
          <td class="paramname"><em>indices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>(optional) The <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> texture to use. </td></tr>
    <tr><td class="paramname">vertices</td><td>vertices. </td></tr>
    <tr><td class="paramname">indices</td><td>(optional) An array of integer indices into the 'vertices' array, if NULL all vertices will be rendered in sequential order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_RenderGeometryRaw </dd></dl>

</div>
</div>
<a id="a2fe5c21e5796984337b0e97ae60d6769" name="a2fe5c21e5796984337b0e97ae60d6769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe5c21e5796984337b0e97ae60d6769">&#9670;&#160;</a></span>RenderGeometryRaw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RenderGeometryRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryRender.html#ga4b68df1674a8dea4fabd4e9ab9e745d7">TextureRef</a>&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>xy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xy_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSDL_1_1FColor.html">FColor</a> *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>color_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>uv_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>(optional) The <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> texture to use. </td></tr>
    <tr><td class="paramname">xy</td><td>vertex positions. </td></tr>
    <tr><td class="paramname">xy_stride</td><td>byte size to move from one element to the next element. </td></tr>
    <tr><td class="paramname">color</td><td>vertex colors (as SDL_FColor). </td></tr>
    <tr><td class="paramname">color_stride</td><td>byte size to move from one element to the next element. </td></tr>
    <tr><td class="paramname">uv</td><td>vertex normalized texture coordinates. </td></tr>
    <tr><td class="paramname">uv_stride</td><td>byte size to move from one element to the next element. </td></tr>
    <tr><td class="paramname">num_vertices</td><td>number of vertices. </td></tr>
    <tr><td class="paramname">indices</td><td>(optional) An array of indices into the 'vertices' arrays, if NULL all vertices will be rendered in sequential order. </td></tr>
    <tr><td class="paramname">num_indices</td><td>number of indices. </td></tr>
    <tr><td class="paramname">size_indices</td><td>index size: 1 (byte), 2 (short), 4 (int). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_RenderGeometry </dd></dl>

</div>
</div>
<a id="a4c25e025f1e42de768716e4006123450" name="a4c25e025f1e42de768716e4006123450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c25e025f1e42de768716e4006123450">&#9670;&#160;</a></span>RenderLine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RenderLine </td>
          <td>(</td>
          <td class="paramtype">SDL_FPoint&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_FPoint&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>the x,y coordinate of the start point. </td></tr>
    <tr><td class="paramname">p2</td><td>the x,y coordinate of the end point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_RenderLines </dd></dl>

</div>
</div>
<a id="a95212b469e89d2e43210ddd456d6011b" name="a95212b469e89d2e43210ddd456d6011b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95212b469e89d2e43210ddd456d6011b">&#9670;&#160;</a></span>RenderLines()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RenderLines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const SDL_FPoint &gt;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the points along the lines, drawing count-1 lines. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_RenderLine </dd></dl>

</div>
</div>
<a id="a8e7bceadc05d738847268b50578603c3" name="a8e7bceadc05d738847268b50578603c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7bceadc05d738847268b50578603c3">&#9670;&#160;</a></span>RenderPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RenderPoint </td>
          <td>(</td>
          <td class="paramtype">SDL_FPoint&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the x, y coordinates of the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_RenderPoints </dd></dl>

</div>
</div>
<a id="aa245447951bf506af88095c44314b565" name="aa245447951bf506af88095c44314b565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa245447951bf506af88095c44314b565">&#9670;&#160;</a></span>RenderPoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RenderPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const SDL_FPoint &gt;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the points to draw. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_RenderPoint </dd></dl>

</div>
</div>
<a id="a0e9eaca37c44ae44584ec0b69f37d2ca" name="a0e9eaca37c44ae44584ec0b69f37d2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9eaca37c44ae44584ec0b69f37d2ca">&#9670;&#160;</a></span>RenderReadPixels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a> <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RenderReadPixels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_Rect &gt;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: This is a very slow operation, and should not be used frequently. If you're using this on the main rendering target, it should be called after rendering and before SDL_RenderPresent().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>an SDL_Rect structure representing the area in pixels relative to the to current viewport, or std::nullopt for the entire viewport. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new SDL_Surface on success or NULL on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="aff0baac7e747fdca98d7dafb05e35401" name="aff0baac7e747fdca98d7dafb05e35401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0baac7e747fdca98d7dafb05e35401">&#9670;&#160;</a></span>RenderRect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RenderRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FRect &gt;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>a pointer to the destination rectangle, or std::nullopt to outline the entire rendering target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_RenderRects </dd></dl>

</div>
</div>
<a id="aae5b1e8fcc7b52a7f2ef04ea6e18a309" name="aae5b1e8fcc7b52a7f2ef04ea6e18a309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5b1e8fcc7b52a7f2ef04ea6e18a309">&#9670;&#160;</a></span>RenderRects()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RenderRects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1SpanRef.html">SpanRef</a>&lt; const SDL_FRect &gt;&#160;</td>
          <td class="paramname"><em>rects</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rects</td><td>a pointer to an array of destination rectangles. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_RenderRect </dd></dl>

</div>
</div>
<a id="ac685a8eac163763f9dd2fbc1e7c1cc5b" name="ac685a8eac163763f9dd2fbc1e7c1cc5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac685a8eac163763f9dd2fbc1e7c1cc5b">&#9670;&#160;</a></span>RenderTexture()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RenderTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryRender.html#ga4b68df1674a8dea4fabd4e9ab9e745d7">TextureRef</a>&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FRect &gt;&#160;</td>
          <td class="paramname"><em>srcrect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FRect &gt;&#160;</td>
          <td class="paramname"><em>dstrect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>the source texture. </td></tr>
    <tr><td class="paramname">srcrect</td><td>a pointer to the source rectangle, or NULL for the entire texture. </td></tr>
    <tr><td class="paramname">dstrect</td><td>a pointer to the destination rectangle, or NULL for the entire rendering target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_RenderTextureRotated </dd>
<dd>
SDL_RenderTextureTiled </dd></dl>

</div>
</div>
<a id="a90d4980a4b7dbaf9e088def788f53d13" name="a90d4980a4b7dbaf9e088def788f53d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d4980a4b7dbaf9e088def788f53d13">&#9670;&#160;</a></span>RenderTexture9Grid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RenderTexture9Grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryRender.html#ga4b68df1674a8dea4fabd4e9ab9e745d7">TextureRef</a>&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FRect &gt;&#160;</td>
          <td class="paramname"><em>srcrect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>left_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>right_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FRect &gt;&#160;</td>
          <td class="paramname"><em>dstrect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The pixels in the texture are split into a 3x3 grid, using the different corner sizes for each corner, and the sides and center making up the remaining pixels. The corners are then scaled using <code>scale</code> and fit into the corners of the destination rectangle. The sides and center are then stretched into place to cover the remaining destination rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>the source texture. </td></tr>
    <tr><td class="paramname">srcrect</td><td>the SDL_Rect structure representing the rectangle to be used for the 9-grid, or NULL to use the entire texture. </td></tr>
    <tr><td class="paramname">left_width</td><td>the width, in pixels, of the left corners in <code>srcrect</code>. </td></tr>
    <tr><td class="paramname">right_width</td><td>the width, in pixels, of the right corners in <code>srcrect</code>. </td></tr>
    <tr><td class="paramname">top_height</td><td>the height, in pixels, of the top corners in <code>srcrect</code>. </td></tr>
    <tr><td class="paramname">bottom_height</td><td>the height, in pixels, of the bottom corners in <code>srcrect</code>. </td></tr>
    <tr><td class="paramname">scale</td><td>the scale used to transform the corner of <code>srcrect</code> into the corner of <code>dstrect</code>, or 0.0f for an unscaled copy. </td></tr>
    <tr><td class="paramname">dstrect</td><td>a pointer to the destination rectangle, or NULL for the entire rendering target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_RenderTexture </dd></dl>

</div>
</div>
<a id="adc8228728e43fc07ec7e7ac63ff3eb73" name="adc8228728e43fc07ec7e7ac63ff3eb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8228728e43fc07ec7e7ac63ff3eb73">&#9670;&#160;</a></span>RenderTextureAffine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RenderTextureAffine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryRender.html#ga4b68df1674a8dea4fabd4e9ab9e745d7">TextureRef</a>&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FRect &gt;&#160;</td>
          <td class="paramname"><em>srcrect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FPoint &gt;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FPoint &gt;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FPoint &gt;&#160;</td>
          <td class="paramname"><em>down</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>the source texture. </td></tr>
    <tr><td class="paramname">srcrect</td><td>a pointer to the source rectangle, or NULL for the entire texture. </td></tr>
    <tr><td class="paramname">origin</td><td>a pointer to a point indicating where the top-left corner of srcrect should be mapped to, or NULL for the rendering target's origin. </td></tr>
    <tr><td class="paramname">right</td><td>a pointer to a point indicating where the top-right corner of srcrect should be mapped to, or NULL for the rendering target's top-right corner. </td></tr>
    <tr><td class="paramname">down</td><td>a pointer to a point indicating where the bottom-left corner of srcrect should be mapped to, or NULL for the rendering target's bottom-left corner. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>You may only call this function from the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_RenderTexture </dd></dl>

</div>
</div>
<a id="a5d2a1e67025b9088b791ac12b7ce39f8" name="a5d2a1e67025b9088b791ac12b7ce39f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2a1e67025b9088b791ac12b7ce39f8">&#9670;&#160;</a></span>RenderTextureRotated()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RenderTextureRotated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryRender.html#ga4b68df1674a8dea4fabd4e9ab9e745d7">TextureRef</a>&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FRect &gt;&#160;</td>
          <td class="paramname"><em>srcrect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FRect &gt;&#160;</td>
          <td class="paramname"><em>dstrect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FPoint &gt;&#160;</td>
          <td class="paramname"><em>center</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategorySurface.html#gaa139652f1cfad9672e6e9898f965812b">FlipMode</a>&#160;</td>
          <td class="paramname"><em>flip</em> = <code>SDL_FLIP_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>the source texture. </td></tr>
    <tr><td class="paramname">srcrect</td><td>a pointer to the source rectangle, or NULL for the entire texture. </td></tr>
    <tr><td class="paramname">dstrect</td><td>a pointer to the destination rectangle, or NULL for the entire rendering target. </td></tr>
    <tr><td class="paramname">angle</td><td>an angle in degrees that indicates the rotation that will be applied to dstrect, rotating it in a clockwise direction. </td></tr>
    <tr><td class="paramname">center</td><td>a pointer to a point indicating the point around which dstrect will be rotated (if NULL, rotation will be done around dstrect.w/2, dstrect.h/2). </td></tr>
    <tr><td class="paramname">flip</td><td>an SDL_FlipMode value stating which flipping actions should be performed on the texture. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_RenderTexture </dd></dl>

</div>
</div>
<a id="ae0f85fc3e77bb94c11da38708374337a" name="ae0f85fc3e77bb94c11da38708374337a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f85fc3e77bb94c11da38708374337a">&#9670;&#160;</a></span>RenderTextureTiled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::RenderTextureTiled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryRender.html#ga4b68df1674a8dea4fabd4e9ab9e745d7">TextureRef</a>&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FRect &gt;&#160;</td>
          <td class="paramname"><em>srcrect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_FRect &gt;&#160;</td>
          <td class="paramname"><em>dstrect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The pixels in <code>srcrect</code> will be repeated as many times as needed to completely fill <code>dstrect</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>the source texture. </td></tr>
    <tr><td class="paramname">srcrect</td><td>a pointer to the source rectangle, or NULL for the entire texture. </td></tr>
    <tr><td class="paramname">scale</td><td>the scale used to transform srcrect into the destination rectangle, e.g. a 32x32 texture with a scale of 2 would fill 64x64 tiles. </td></tr>
    <tr><td class="paramname">dstrect</td><td>a pointer to the destination rectangle, or NULL for the entire rendering target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_RenderTexture </dd></dl>

</div>
</div>
<a id="af6809765651f06b11bd0711c60d24633" name="af6809765651f06b11bd0711c60d24633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6809765651f06b11bd0711c60d24633">&#9670;&#160;</a></span>SetClipRect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::SetClipRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_Rect &gt;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>an SDL_Rect structure representing the clip area, relative to the viewport, or NULL to disable clipping. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#a755bccca740076de95e4a4a889a54b48" title="Get the clip rectangle for the current target.">GetClipRect()</a> </dd>
<dd>
ClipEnabled() </dd></dl>

</div>
</div>
<a id="a85566531c35dc2c49e56a577fb4fb060" name="a85566531c35dc2c49e56a577fb4fb060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85566531c35dc2c49e56a577fb4fb060">&#9670;&#160;</a></span>SetColorScale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::SetColorScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The color scale is an additional scale multiplied into the pixel color value while rendering. This can be used to adjust the brightness of colors during HDR rendering, or changing HDR video brightness when playing on an SDR display.</p>
<p>The color scale does not affect the alpha channel, only the color brightness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>the color scale value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#aa3455f1ed5c9673fb3560f769fcfdca1" title="Get the color scale used for render operations.">GetColorScale()</a> </dd></dl>

</div>
</div>
<a id="a9d16732d32a1527f38860ee1cb424953" name="a9d16732d32a1527f38860ee1cb424953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d16732d32a1527f38860ee1cb424953">&#9670;&#160;</a></span>SetDrawBlendMode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::SetDrawBlendMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryBlendmode.html#gad02afeb206989ff841629dca2c93e694">BlendMode</a>&#160;</td>
          <td class="paramname"><em>blendMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the blend mode is not supported, the closest supported mode is chosen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blendMode</td><td>the SDL_BlendMode to use for blending. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#a157ad97e3ed83a6c87b21cb5094c57b4" title="Get the blend mode used for drawing operations.">GetDrawBlendMode()</a> </dd></dl>

</div>
</div>
<a id="a7dc3966cdb024d1061115f0e79af6867" name="a7dc3966cdb024d1061115f0e79af6867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc3966cdb024d1061115f0e79af6867">&#9670;&#160;</a></span>SetDrawColor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::SetDrawColor </td>
          <td>(</td>
          <td class="paramtype">SDL_Color&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the color for drawing or filling rectangles, lines, and points, and for SDL_RenderClear().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the color value used to draw on the rendering target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>GetDrawColor() </dd>
<dd>
SetDrawColorFloat() </dd></dl>

</div>
</div>
<a id="ab5d39f29732e13b3e5b2dce47f78479f" name="ab5d39f29732e13b3e5b2dce47f78479f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d39f29732e13b3e5b2dce47f78479f">&#9670;&#160;</a></span>SetDrawColor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::SetDrawColor </td>
          <td>(</td>
          <td class="paramtype">SDL_FColor&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the color for drawing or filling rectangles, lines, and points, and for SDL_RenderClear().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the RGBA values used to draw on the rendering target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>GetDrawColorFloat() </dd>
<dd>
<a class="el" href="structSDL_1_1RendererBase.html#a7dc3966cdb024d1061115f0e79af6867" title="Set the color used for drawing operations.">SetDrawColor()</a> </dd></dl>

</div>
</div>
<a id="af6989d7e5c77b8af134de07765c00344" name="af6989d7e5c77b8af134de07765c00344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6989d7e5c77b8af134de07765c00344">&#9670;&#160;</a></span>SetLogicalPresentation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::SetLogicalPresentation </td>
          <td>(</td>
          <td class="paramtype">SDL_Point&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryRender.html#ga91be24b12fa4efe591c43f2ece44e32d">RendererLogicalPresentation</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function sets the width and height of the logical rendering output. The renderer will act as if the window is always the requested dimensions, scaling to the actual window resolution as necessary.</p>
<p>This can be useful for games that expect a fixed size, but would like to scale the output to whatever is available, regardless of how a user resizes a window, or if the display is high DPI.</p>
<p>You can disable logical coordinates by setting the mode to SDL_LOGICAL_PRESENTATION_DISABLED, and in that case you get the full pixel resolution of the output window; it is safe to toggle logical presentation during the rendering of a frame: perhaps most of the rendering is done to specific dimensions but to make fonts look sharp, the app turns off logical presentation while drawing text.</p>
<p>Letterboxing will only happen if logical presentation is enabled during SDL_RenderPresent; be sure to reenable it first if you were using it.</p>
<p>You can convert coordinates in an event into rendering coordinates using SDL_ConvertEventToRenderCoordinates().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the width and height of the logical resolution. </td></tr>
    <tr><td class="paramname">mode</td><td>the presentation mode used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#a8883859100726a7c7f08134ee0fc0229" title="Convert the coordinates in an event to render coordinates.">ConvertEventToRenderCoordinates()</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RendererBase.html#ad0a46c5ec2a153ed79933f1efb2eafbb" title="Get device independent resolution and presentation mode for rendering.">GetLogicalPresentation()</a> </dd>
<dd>
<a class="el" href="structSDL_1_1RendererBase.html#a4e231417b3b5cee3048276f4ed5ac701" title="Get the final presentation rectangle for rendering.">GetLogicalPresentationRect()</a> </dd></dl>

</div>
</div>
<a id="aaf2e2c2a7eab09a2252d67b43a7de7eb" name="aaf2e2c2a7eab09a2252d67b43a7de7eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2e2c2a7eab09a2252d67b43a7de7eb">&#9670;&#160;</a></span>SetScale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::SetScale </td>
          <td>(</td>
          <td class="paramtype">SDL_FPoint&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The drawing coordinates are scaled by the x/y scaling factors before they are used by the renderer. This allows resolution independent drawing with a single coordinate system.</p>
<p>If this results in scaling or subpixel drawing by the rendering backend, it will be handled using the appropriate quality hints. For best results use integer scaling factors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>the x, y scaling factors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>GetScale() </dd></dl>

</div>
</div>
<a id="a00f6fe44be445493f8ee9384bf764c87" name="a00f6fe44be445493f8ee9384bf764c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f6fe44be445493f8ee9384bf764c87">&#9670;&#160;</a></span>SetTarget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::SetTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryRender.html#ga4b68df1674a8dea4fabd4e9ab9e745d7">TextureRef</a>&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default render target is the window for which the renderer was created. To stop rendering to a texture and render to the window again, call this function with a NULL <code>texture</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>the targeted texture, which must be created with the <code>SDL_TEXTUREACCESS_TARGET</code> flag, or NULL to render to the window instead of a texture. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#a0a08906b9ff3d00e0ad75107e991f5d1" title="Get the current render target.">GetTarget()</a> </dd></dl>

</div>
</div>
<a id="a1f48812426d05f0ac160cb1b116c6932" name="a1f48812426d05f0ac160cb1b116c6932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f48812426d05f0ac160cb1b116c6932">&#9670;&#160;</a></span>SetViewport()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::SetViewport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_Rect &gt;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Drawing will clip to this area (separately from any clipping done with SDL_SetRenderClipRect), and the top left of the area will become coordinate (0, 0) for future drawing commands.</p>
<p>The area's width and height must be &gt;= 0.</p>
<p>Each render target has its own viewport. This function sets the viewport for the current render target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>the SDL_Rect structure representing the drawing area, or std::nullopt to set the viewport to the entire target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#ad74c59e900e3ffd5a6ff9f5258fefef8" title="Get the drawing area for the current target.">GetViewport()</a> </dd>
<dd>
ViewportSet() </dd></dl>

</div>
</div>
<a id="a7f956ae897c56fe35213f70e3d548790" name="a7f956ae897c56fe35213f70e3d548790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f956ae897c56fe35213f70e3d548790">&#9670;&#160;</a></span>SetVSync()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Renderer * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1RendererBase.html">SDL::RendererBase</a>&lt; T &gt;::SetVSync </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vsync</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When a renderer is created, vsync defaults to SDL_RENDERER_VSYNC_DISABLED.</p>
<p>The <code>vsync</code> parameter can be 1 to synchronize present with every vertical refresh, 2 to synchronize present with every second vertical refresh, etc., SDL_RENDERER_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync), or SDL_RENDERER_VSYNC_DISABLED to disable. Not every value is supported by every driver, so you should check the return value to see whether the requested setting is supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsync</td><td>the vertical refresh sync interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1RendererBase.html#aa7b89b4471bea4dbcab9d63e1aacd871" title="Get VSync of the given renderer.">GetVSync()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>SDL3pp/<a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
