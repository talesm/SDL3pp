<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDL3pp: SDL::IOStreamRef Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SDL3pp
   </div>
   <div id="projectbrief">A slim C++ wrapper for SDL3</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSDL.html">SDL</a></li><li class="navelem"><a class="el" href="structSDL_1_1IOStreamRef.html">IOStreamRef</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structSDL_1_1IOStreamRef-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SDL::IOStreamRef Struct Reference<div class="ingroups"><a class="el" href="group__Categories.html">Categories</a> &raquo; <a class="el" href="group__CategoriesFileIO.html">File and I/O Abstractions</a> &raquo; <a class="el" href="group__CategoryIOStream.html">I/O Streams</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>The read/write operation structure.  
 <a href="structSDL_1_1IOStreamRef.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for SDL::IOStreamRef:</div>
<div class="dyncontent">
<div class="center"><img src="structSDL_1_1IOStreamRef__inherit__graph.png" border="0" usemap="#aSDL_1_1IOStreamRef_inherit__map" alt="Inheritance graph"/></div>
<map name="aSDL_1_1IOStreamRef_inherit__map" id="aSDL_1_1IOStreamRef_inherit__map">
<area shape="rect" title="The read/write operation structure." alt="" coords="13,93,152,119"/>
<area shape="rect" href="classSDL_1_1Resource.html" title=" " alt="" coords="5,5,160,45"/>
<area shape="poly" title=" " alt="" coords="85,59,85,93,80,93,80,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1a1353a4805a52c4066da56d2c83e2f7" id="r_a1a1353a4805a52c4066da56d2c83e2f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSDL_1_1PropertiesRef.html">PropertiesRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a1a1353a4805a52c4066da56d2c83e2f7">GetProperties</a> () const</td></tr>
<tr class="memdesc:a1a1353a4805a52c4066da56d2c83e2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the properties associated with an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a>.  <br /></td></tr>
<tr class="separator:a1a1353a4805a52c4066da56d2c83e2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8a2b80b055cb98bb2fd57824a2b9e1" id="r_a1d8a2b80b055cb98bb2fd57824a2b9e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategoryIOStream.html#gac6fe4a8e6aa95d60056f3a597416c642">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1">GetStatus</a> () const</td></tr>
<tr class="memdesc:a1d8a2b80b055cb98bb2fd57824a2b9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the stream status of an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a>.  <br /></td></tr>
<tr class="separator:a1d8a2b80b055cb98bb2fd57824a2b9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354a7c0f986108a5c4f8a8a004d3b501" id="r_a354a7c0f986108a5c4f8a8a004d3b501"><td class="memItemLeft" align="right" valign="top">Sint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a354a7c0f986108a5c4f8a8a004d3b501">GetSize</a> () const</td></tr>
<tr class="memdesc:a354a7c0f986108a5c4f8a8a004d3b501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to get the size of the data stream in an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a>.  <br /></td></tr>
<tr class="separator:a354a7c0f986108a5c4f8a8a004d3b501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af710faeadacc85343667c27e2fa9f03a" id="r_af710faeadacc85343667c27e2fa9f03a"><td class="memItemLeft" align="right" valign="top">Sint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#af710faeadacc85343667c27e2fa9f03a">Seek</a> (Sint64 offset, <a class="el" href="group__CategoryIOStream.html#ga4adfc77466072724dd0d0d41b5c49421">IOWhence</a> whence)</td></tr>
<tr class="memdesc:af710faeadacc85343667c27e2fa9f03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek within an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> data stream.  <br /></td></tr>
<tr class="separator:af710faeadacc85343667c27e2fa9f03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae119e0f3d32d947312fc642e529bfb00" id="r_ae119e0f3d32d947312fc642e529bfb00"><td class="memItemLeft" align="right" valign="top">Sint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#ae119e0f3d32d947312fc642e529bfb00">Tell</a> () const</td></tr>
<tr class="memdesc:ae119e0f3d32d947312fc642e529bfb00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the current read/write offset in an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> data stream.  <br /></td></tr>
<tr class="separator:ae119e0f3d32d947312fc642e529bfb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26c1118dcfb7dfb3c0584233239d1ac" id="r_af26c1118dcfb7dfb3c0584233239d1ac"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#af26c1118dcfb7dfb3c0584233239d1ac">Read</a> (size_t size=-1)</td></tr>
<tr class="memdesc:af26c1118dcfb7dfb3c0584233239d1ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a data source.  <br /></td></tr>
<tr class="separator:af26c1118dcfb7dfb3c0584233239d1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935e63607e1ceb9b911e4b73960933cf" id="r_a935e63607e1ceb9b911e4b73960933cf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a935e63607e1ceb9b911e4b73960933cf">Read</a> (<a class="el" href="structSDL_1_1TargetBytes.html">TargetBytes</a> buf)</td></tr>
<tr class="memdesc:a935e63607e1ceb9b911e4b73960933cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a data source.  <br /></td></tr>
<tr class="separator:a935e63607e1ceb9b911e4b73960933cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b518bd679bf9533679313cb6d82027" id="r_ae3b518bd679bf9533679313cb6d82027"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#ae3b518bd679bf9533679313cb6d82027">Write</a> (<a class="el" href="structSDL_1_1SourceBytes.html">SourceBytes</a> buf)</td></tr>
<tr class="memdesc:ae3b518bd679bf9533679313cb6d82027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> data stream.  <br /></td></tr>
<tr class="separator:ae3b518bd679bf9533679313cb6d82027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427f0ace244ac6bb464a6321e8b0f561" id="r_a427f0ace244ac6bb464a6321e8b0f561"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a427f0ace244ac6bb464a6321e8b0f561">print</a> (std::string_view fmt, auto... args)</td></tr>
<tr class="separator:a427f0ace244ac6bb464a6321e8b0f561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852c75ac064fea3caaff30e1f4341473" id="r_a852c75ac064fea3caaff30e1f4341473"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a852c75ac064fea3caaff30e1f4341473">println</a> (std::string_view fmt, auto... args)</td></tr>
<tr class="separator:a852c75ac064fea3caaff30e1f4341473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1add38ee45c1bb15910177a5221e29f" id="r_aa1add38ee45c1bb15910177a5221e29f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#aa1add38ee45c1bb15910177a5221e29f">printf</a> (SDL_PRINTF_FORMAT_STRING const char *fmt,...)</td></tr>
<tr class="memdesc:aa1add38ee45c1bb15910177a5221e29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print to an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> data stream.  <br /></td></tr>
<tr class="separator:aa1add38ee45c1bb15910177a5221e29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5dae59f1d5d904945a51c724efea24" id="r_add5dae59f1d5d904945a51c724efea24"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#add5dae59f1d5d904945a51c724efea24">vprintf</a> (SDL_PRINTF_FORMAT_STRING const char *fmt, va_list ap)</td></tr>
<tr class="memdesc:add5dae59f1d5d904945a51c724efea24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print to an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> data stream.  <br /></td></tr>
<tr class="separator:add5dae59f1d5d904945a51c724efea24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac208e55f1cc620e61221c5cc1e732f1a" id="r_ac208e55f1cc620e61221c5cc1e732f1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#ac208e55f1cc620e61221c5cc1e732f1a">Flush</a> ()</td></tr>
<tr class="memdesc:ac208e55f1cc620e61221c5cc1e732f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush any buffered data in the stream.  <br /></td></tr>
<tr class="separator:ac208e55f1cc620e61221c5cc1e732f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f779015005015ba17c9672331a1872" id="r_ad8f779015005015ba17c9672331a1872"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSDL_1_1StringResult.html">StringResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#ad8f779015005015ba17c9672331a1872">LoadFile</a> ()</td></tr>
<tr class="memdesc:ad8f779015005015ba17c9672331a1872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all the data from an <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> data stream.  <br /></td></tr>
<tr class="separator:ad8f779015005015ba17c9672331a1872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640f74da9562d1d176f4b7213c261301" id="r_a640f74da9562d1d176f4b7213c261301"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a640f74da9562d1d176f4b7213c261301"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OwnArray.html">OwnArray</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a640f74da9562d1d176f4b7213c261301">LoadFileAs</a> ()</td></tr>
<tr class="memdesc:a640f74da9562d1d176f4b7213c261301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all the data from an <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> data stream.  <br /></td></tr>
<tr class="separator:a640f74da9562d1d176f4b7213c261301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735b413c092e9fadd55a03dd56be62a6" id="r_a735b413c092e9fadd55a03dd56be62a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a735b413c092e9fadd55a03dd56be62a6">SaveFile</a> (<a class="el" href="structSDL_1_1SourceBytes.html">SourceBytes</a> data)</td></tr>
<tr class="memdesc:a735b413c092e9fadd55a03dd56be62a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save all the data into an <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> data stream.  <br /></td></tr>
<tr class="separator:a735b413c092e9fadd55a03dd56be62a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f32150e07368975e51bccf0325e90c7" id="r_a9f32150e07368975e51bccf0325e90c7"><td class="memItemLeft" align="right" valign="top">Uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a9f32150e07368975e51bccf0325e90c7">ReadU8</a> ()</td></tr>
<tr class="memdesc:a9f32150e07368975e51bccf0325e90c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read a byte from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a>.  <br /></td></tr>
<tr class="separator:a9f32150e07368975e51bccf0325e90c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101cb819d4a6b98b7810a1cf2ca7aac1" id="r_a101cb819d4a6b98b7810a1cf2ca7aac1"><td class="memItemLeft" align="right" valign="top">Sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a101cb819d4a6b98b7810a1cf2ca7aac1">ReadS8</a> ()</td></tr>
<tr class="memdesc:a101cb819d4a6b98b7810a1cf2ca7aac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read a signed byte from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a>.  <br /></td></tr>
<tr class="separator:a101cb819d4a6b98b7810a1cf2ca7aac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d71638526c0d41555297adaced82fe" id="r_ab0d71638526c0d41555297adaced82fe"><td class="memItemLeft" align="right" valign="top">Uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#ab0d71638526c0d41555297adaced82fe">ReadU16LE</a> ()</td></tr>
<tr class="memdesc:ab0d71638526c0d41555297adaced82fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 16 bits of little-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:ab0d71638526c0d41555297adaced82fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbe68ed57f98dcf08423bca2518a592" id="r_a6dbe68ed57f98dcf08423bca2518a592"><td class="memItemLeft" align="right" valign="top">Sint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a6dbe68ed57f98dcf08423bca2518a592">ReadS16LE</a> ()</td></tr>
<tr class="memdesc:a6dbe68ed57f98dcf08423bca2518a592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 16 bits of little-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:a6dbe68ed57f98dcf08423bca2518a592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839b35d63a8d34826d6e826709d7ca92" id="r_a839b35d63a8d34826d6e826709d7ca92"><td class="memItemLeft" align="right" valign="top">Uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a839b35d63a8d34826d6e826709d7ca92">ReadU16BE</a> ()</td></tr>
<tr class="memdesc:a839b35d63a8d34826d6e826709d7ca92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 16 bits of big-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:a839b35d63a8d34826d6e826709d7ca92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eae1271f8e924587efd14f334853d8e" id="r_a2eae1271f8e924587efd14f334853d8e"><td class="memItemLeft" align="right" valign="top">Sint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a2eae1271f8e924587efd14f334853d8e">ReadS16BE</a> ()</td></tr>
<tr class="memdesc:a2eae1271f8e924587efd14f334853d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 16 bits of big-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:a2eae1271f8e924587efd14f334853d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af8cf1023f2b0fba5a1b01ca01c978f" id="r_a4af8cf1023f2b0fba5a1b01ca01c978f"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a4af8cf1023f2b0fba5a1b01ca01c978f">ReadU32LE</a> ()</td></tr>
<tr class="memdesc:a4af8cf1023f2b0fba5a1b01ca01c978f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 32 bits of little-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:a4af8cf1023f2b0fba5a1b01ca01c978f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0ea261aa58e0f7d87d9276c8aa4645" id="r_a8d0ea261aa58e0f7d87d9276c8aa4645"><td class="memItemLeft" align="right" valign="top">Sint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a8d0ea261aa58e0f7d87d9276c8aa4645">ReadS32LE</a> ()</td></tr>
<tr class="memdesc:a8d0ea261aa58e0f7d87d9276c8aa4645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 32 bits of little-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:a8d0ea261aa58e0f7d87d9276c8aa4645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfddf359c7a10a8e412328259c2536b" id="r_a9dfddf359c7a10a8e412328259c2536b"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a9dfddf359c7a10a8e412328259c2536b">ReadU32BE</a> ()</td></tr>
<tr class="memdesc:a9dfddf359c7a10a8e412328259c2536b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 32 bits of big-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:a9dfddf359c7a10a8e412328259c2536b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa970c2cdaeb3a176b223d9ccb648ac9b" id="r_aa970c2cdaeb3a176b223d9ccb648ac9b"><td class="memItemLeft" align="right" valign="top">Sint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#aa970c2cdaeb3a176b223d9ccb648ac9b">ReadS32BE</a> ()</td></tr>
<tr class="memdesc:aa970c2cdaeb3a176b223d9ccb648ac9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 32 bits of big-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:aa970c2cdaeb3a176b223d9ccb648ac9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfe31e1ce3b988549c8aebf50b79773" id="r_a0dfe31e1ce3b988549c8aebf50b79773"><td class="memItemLeft" align="right" valign="top">Uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a0dfe31e1ce3b988549c8aebf50b79773">ReadU64LE</a> ()</td></tr>
<tr class="memdesc:a0dfe31e1ce3b988549c8aebf50b79773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 64 bits of little-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:a0dfe31e1ce3b988549c8aebf50b79773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee65caad6ca48ac9c4d4f7d3e16fed5" id="r_afee65caad6ca48ac9c4d4f7d3e16fed5"><td class="memItemLeft" align="right" valign="top">Sint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#afee65caad6ca48ac9c4d4f7d3e16fed5">ReadS64LE</a> ()</td></tr>
<tr class="memdesc:afee65caad6ca48ac9c4d4f7d3e16fed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 64 bits of little-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:afee65caad6ca48ac9c4d4f7d3e16fed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ccacd0f0df79e88e64737dc4e37df8" id="r_af7ccacd0f0df79e88e64737dc4e37df8"><td class="memItemLeft" align="right" valign="top">Uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#af7ccacd0f0df79e88e64737dc4e37df8">ReadU64BE</a> ()</td></tr>
<tr class="memdesc:af7ccacd0f0df79e88e64737dc4e37df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 64 bits of big-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:af7ccacd0f0df79e88e64737dc4e37df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff3d96040de326d907a1a1cd544a474" id="r_a7ff3d96040de326d907a1a1cd544a474"><td class="memItemLeft" align="right" valign="top">Sint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a7ff3d96040de326d907a1a1cd544a474">ReadS64BE</a> ()</td></tr>
<tr class="memdesc:a7ff3d96040de326d907a1a1cd544a474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 64 bits of big-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:a7ff3d96040de326d907a1a1cd544a474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f8816904e297db1c116940a939d005" id="r_ac0f8816904e297db1c116940a939d005"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#ac0f8816904e297db1c116940a939d005">WriteU8</a> (Uint8 value)</td></tr>
<tr class="memdesc:ac0f8816904e297db1c116940a939d005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to write a byte to an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a>.  <br /></td></tr>
<tr class="separator:ac0f8816904e297db1c116940a939d005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080ec45f9d8b80589574ad5479d97790" id="r_a080ec45f9d8b80589574ad5479d97790"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a080ec45f9d8b80589574ad5479d97790">WriteS8</a> (Sint8 value)</td></tr>
<tr class="memdesc:a080ec45f9d8b80589574ad5479d97790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to write a signed byte to an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a>.  <br /></td></tr>
<tr class="separator:a080ec45f9d8b80589574ad5479d97790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a675e3d3180e30b7173274fef4d6f5" id="r_a26a675e3d3180e30b7173274fef4d6f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a26a675e3d3180e30b7173274fef4d6f5">WriteU16LE</a> (Uint16 value)</td></tr>
<tr class="memdesc:a26a675e3d3180e30b7173274fef4d6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to write 16 bits in native format to an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> as little-endian data.  <br /></td></tr>
<tr class="separator:a26a675e3d3180e30b7173274fef4d6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e286b98128df9a4471966dc9246938" id="r_ae9e286b98128df9a4471966dc9246938"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#ae9e286b98128df9a4471966dc9246938">WriteS16LE</a> (Sint16 value)</td></tr>
<tr class="memdesc:ae9e286b98128df9a4471966dc9246938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to write 16 bits in native format to an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> as little-endian data.  <br /></td></tr>
<tr class="separator:ae9e286b98128df9a4471966dc9246938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7344a5bc403634025a182e795615bb07" id="r_a7344a5bc403634025a182e795615bb07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a7344a5bc403634025a182e795615bb07">WriteU16BE</a> (Uint16 value)</td></tr>
<tr class="memdesc:a7344a5bc403634025a182e795615bb07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to write 16 bits in native format to an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> as big-endian data.  <br /></td></tr>
<tr class="separator:a7344a5bc403634025a182e795615bb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc9dc24484e6906344b94c8dca0a3e9" id="r_afcc9dc24484e6906344b94c8dca0a3e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#afcc9dc24484e6906344b94c8dca0a3e9">WriteS16BE</a> (Sint16 value)</td></tr>
<tr class="memdesc:afcc9dc24484e6906344b94c8dca0a3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to write 16 bits in native format to an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> as big-endian data.  <br /></td></tr>
<tr class="separator:afcc9dc24484e6906344b94c8dca0a3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb297b525c97fead3f799034aeb10f9" id="r_a8bb297b525c97fead3f799034aeb10f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a8bb297b525c97fead3f799034aeb10f9">WriteU32LE</a> (Uint32 value)</td></tr>
<tr class="memdesc:a8bb297b525c97fead3f799034aeb10f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to write 32 bits in native format to an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> as little-endian data.  <br /></td></tr>
<tr class="separator:a8bb297b525c97fead3f799034aeb10f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7fb28e9af23e2ec5fe041667b47ef5" id="r_aef7fb28e9af23e2ec5fe041667b47ef5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#aef7fb28e9af23e2ec5fe041667b47ef5">WriteS32LE</a> (Sint32 value)</td></tr>
<tr class="memdesc:aef7fb28e9af23e2ec5fe041667b47ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to write 32 bits in native format to an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> as little-endian data.  <br /></td></tr>
<tr class="separator:aef7fb28e9af23e2ec5fe041667b47ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443178ccbacefd6c6debcbdffc7b5bd2" id="r_a443178ccbacefd6c6debcbdffc7b5bd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a443178ccbacefd6c6debcbdffc7b5bd2">WriteU32BE</a> (Uint32 value)</td></tr>
<tr class="memdesc:a443178ccbacefd6c6debcbdffc7b5bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to write 32 bits in native format to an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> as big-endian data.  <br /></td></tr>
<tr class="separator:a443178ccbacefd6c6debcbdffc7b5bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66a90c818ceb2a87d2e652eb645a7c5" id="r_ab66a90c818ceb2a87d2e652eb645a7c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#ab66a90c818ceb2a87d2e652eb645a7c5">WriteS32BE</a> (Sint32 value)</td></tr>
<tr class="memdesc:ab66a90c818ceb2a87d2e652eb645a7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to write 32 bits in native format to an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> as big-endian data.  <br /></td></tr>
<tr class="separator:ab66a90c818ceb2a87d2e652eb645a7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cac4cda5297ef805c839730ecd9b7fe" id="r_a5cac4cda5297ef805c839730ecd9b7fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a5cac4cda5297ef805c839730ecd9b7fe">WriteU64LE</a> (Uint64 value)</td></tr>
<tr class="memdesc:a5cac4cda5297ef805c839730ecd9b7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to write 64 bits in native format to an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> as little-endian data.  <br /></td></tr>
<tr class="separator:a5cac4cda5297ef805c839730ecd9b7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd4bb8cec5403b93282a5a4f5574b6f" id="r_a2bd4bb8cec5403b93282a5a4f5574b6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a2bd4bb8cec5403b93282a5a4f5574b6f">WriteS64LE</a> (Sint64 value)</td></tr>
<tr class="memdesc:a2bd4bb8cec5403b93282a5a4f5574b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to write 64 bits in native format to an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> as little-endian data.  <br /></td></tr>
<tr class="separator:a2bd4bb8cec5403b93282a5a4f5574b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107f2a596e6d3687de93fa53a701b986" id="r_a107f2a596e6d3687de93fa53a701b986"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a107f2a596e6d3687de93fa53a701b986">WriteU64BE</a> (Uint64 value)</td></tr>
<tr class="memdesc:a107f2a596e6d3687de93fa53a701b986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to write 64 bits in native format to an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> as big-endian data.  <br /></td></tr>
<tr class="separator:a107f2a596e6d3687de93fa53a701b986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c49a147bd58ca922f64a1b8d56a8a19" id="r_a3c49a147bd58ca922f64a1b8d56a8a19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a3c49a147bd58ca922f64a1b8d56a8a19">WriteS64BE</a> (Sint64 value)</td></tr>
<tr class="memdesc:a3c49a147bd58ca922f64a1b8d56a8a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to write 64 bits in native format to an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> as big-endian data.  <br /></td></tr>
<tr class="separator:a3c49a147bd58ca922f64a1b8d56a8a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea56d2a56964972987a1472acab0796" id="r_aeea56d2a56964972987a1472acab0796"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Uint8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#aeea56d2a56964972987a1472acab0796">TryReadU8</a> ()</td></tr>
<tr class="memdesc:aeea56d2a56964972987a1472acab0796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read a byte from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a>.  <br /></td></tr>
<tr class="separator:aeea56d2a56964972987a1472acab0796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc93a7746aabadddeeddb9dcd44d757" id="r_a7cc93a7746aabadddeeddb9dcd44d757"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Sint8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a7cc93a7746aabadddeeddb9dcd44d757">TryReadS8</a> ()</td></tr>
<tr class="memdesc:a7cc93a7746aabadddeeddb9dcd44d757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read a byte from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a>.  <br /></td></tr>
<tr class="separator:a7cc93a7746aabadddeeddb9dcd44d757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447a44f0e26a57775bbd197de9dde8f0" id="r_a447a44f0e26a57775bbd197de9dde8f0"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Uint16 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a447a44f0e26a57775bbd197de9dde8f0">TryReadU16LE</a> ()</td></tr>
<tr class="memdesc:a447a44f0e26a57775bbd197de9dde8f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 16 bits of little-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:a447a44f0e26a57775bbd197de9dde8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fba31cd98ce8d209785f8c86988cc57" id="r_a6fba31cd98ce8d209785f8c86988cc57"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Sint16 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a6fba31cd98ce8d209785f8c86988cc57">TryReadS16LE</a> ()</td></tr>
<tr class="memdesc:a6fba31cd98ce8d209785f8c86988cc57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 16 bits of little-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:a6fba31cd98ce8d209785f8c86988cc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af974e8d60f5279f547f0218377e27346" id="r_af974e8d60f5279f547f0218377e27346"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Uint16 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#af974e8d60f5279f547f0218377e27346">TryReadU16BE</a> ()</td></tr>
<tr class="memdesc:af974e8d60f5279f547f0218377e27346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 16 bits of big-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:af974e8d60f5279f547f0218377e27346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032747c4494e1ffb8dbd5269f7ba6796" id="r_a032747c4494e1ffb8dbd5269f7ba6796"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Sint16 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a032747c4494e1ffb8dbd5269f7ba6796">TryReadS16BE</a> ()</td></tr>
<tr class="memdesc:a032747c4494e1ffb8dbd5269f7ba6796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 16 bits of big-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:a032747c4494e1ffb8dbd5269f7ba6796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb79183c2452811e9b88bf38d45af82" id="r_aebb79183c2452811e9b88bf38d45af82"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Uint32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#aebb79183c2452811e9b88bf38d45af82">TryReadU32LE</a> ()</td></tr>
<tr class="memdesc:aebb79183c2452811e9b88bf38d45af82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 32 bits of little-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:aebb79183c2452811e9b88bf38d45af82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8877b4701f8367e3819109a533c70005" id="r_a8877b4701f8367e3819109a533c70005"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Sint32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a8877b4701f8367e3819109a533c70005">TryReadS32LE</a> ()</td></tr>
<tr class="memdesc:a8877b4701f8367e3819109a533c70005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 32 bits of little-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:a8877b4701f8367e3819109a533c70005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b2c226b00992aefdeba5c05b8c8c09" id="r_a90b2c226b00992aefdeba5c05b8c8c09"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Uint32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a90b2c226b00992aefdeba5c05b8c8c09">TryReadU32BE</a> ()</td></tr>
<tr class="memdesc:a90b2c226b00992aefdeba5c05b8c8c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 32 bits of big-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:a90b2c226b00992aefdeba5c05b8c8c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39753125e9abb5ca19433b7b12ad85dd" id="r_a39753125e9abb5ca19433b7b12ad85dd"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Sint32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a39753125e9abb5ca19433b7b12ad85dd">TryReadS32BE</a> ()</td></tr>
<tr class="memdesc:a39753125e9abb5ca19433b7b12ad85dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 32 bits of big-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:a39753125e9abb5ca19433b7b12ad85dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac222f1ca86f5590d8c914ea82640e6fa" id="r_ac222f1ca86f5590d8c914ea82640e6fa"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Uint64 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#ac222f1ca86f5590d8c914ea82640e6fa">TryReadU64LE</a> ()</td></tr>
<tr class="memdesc:ac222f1ca86f5590d8c914ea82640e6fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 64 bits of little-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:ac222f1ca86f5590d8c914ea82640e6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2389148770e064d05d2e1d977451e7d" id="r_ad2389148770e064d05d2e1d977451e7d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Sint64 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#ad2389148770e064d05d2e1d977451e7d">TryReadS64LE</a> ()</td></tr>
<tr class="memdesc:ad2389148770e064d05d2e1d977451e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 64 bits of little-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:ad2389148770e064d05d2e1d977451e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab955812271daec122dbf4e40a97a367f" id="r_ab955812271daec122dbf4e40a97a367f"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Uint64 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#ab955812271daec122dbf4e40a97a367f">TryReadU64BE</a> ()</td></tr>
<tr class="memdesc:ab955812271daec122dbf4e40a97a367f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 64 bits of big-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:ab955812271daec122dbf4e40a97a367f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee6af092685a1f1659882c095b31bf7" id="r_a7ee6af092685a1f1659882c095b31bf7"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Sint64 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a7ee6af092685a1f1659882c095b31bf7">TryReadS64BE</a> ()</td></tr>
<tr class="memdesc:a7ee6af092685a1f1659882c095b31bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to read 64 bits of big-endian data from an <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> and return in native format.  <br /></td></tr>
<tr class="separator:a7ee6af092685a1f1659882c095b31bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959604d891dcae230bf4c378c046a21d" id="r_a959604d891dcae230bf4c378c046a21d"><td class="memItemLeft" align="right" valign="top"><a id="a959604d891dcae230bf4c378c046a21d" name="a959604d891dcae230bf4c378c046a21d"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>Resource</b> (T resource={})</td></tr>
<tr class="memdesc:a959604d891dcae230bf4c378c046a21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs from the underlying resource. <br /></td></tr>
<tr class="separator:a959604d891dcae230bf4c378c046a21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78be254b85f48c12179a782cb04da9ac" id="r_a78be254b85f48c12179a782cb04da9ac"><td class="memItemLeft" align="right" valign="top"><a id="a78be254b85f48c12179a782cb04da9ac" name="a78be254b85f48c12179a782cb04da9ac"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>Resource</b> (const ResourceHandle&lt; <a class="el" href="classSDL_1_1Resource.html">Resource</a>&lt; T &gt; &gt; auto &amp;resource)</td></tr>
<tr class="memdesc:a78be254b85f48c12179a782cb04da9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs from pointer like. <br /></td></tr>
<tr class="separator:a78be254b85f48c12179a782cb04da9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988d47fefd6d7a5f623d3de9fce5ea59" id="r_a988d47fefd6d7a5f623d3de9fce5ea59"><td class="memItemLeft" align="right" valign="top"><a id="a988d47fefd6d7a5f623d3de9fce5ea59" name="a988d47fefd6d7a5f623d3de9fce5ea59"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>Resource</b> (std::nullptr_t)</td></tr>
<tr class="memdesc:a988d47fefd6d7a5f623d3de9fce5ea59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to default ctor. <br /></td></tr>
<tr class="separator:a988d47fefd6d7a5f623d3de9fce5ea59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb3168108af6a8bd0e23edc712b6a09" id="r_afbb3168108af6a8bd0e23edc712b6a09"><td class="memItemLeft" align="right" valign="top"><a id="afbb3168108af6a8bd0e23edc712b6a09" name="afbb3168108af6a8bd0e23edc712b6a09"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>Resource</b> (std::nullopt_t)</td></tr>
<tr class="memdesc:afbb3168108af6a8bd0e23edc712b6a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to default ctor. <br /></td></tr>
<tr class="separator:afbb3168108af6a8bd0e23edc712b6a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSDL_1_1Resource"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSDL_1_1Resource')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSDL_1_1Resource.html">SDL::Resource&lt; SDL_IOStream * &gt;</a></td></tr>
<tr class="memitem:a959604d891dcae230bf4c378c046a21d inherit pub_methods_classSDL_1_1Resource" id="r_a959604d891dcae230bf4c378c046a21d"><td class="memItemLeft" align="right" valign="top">
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>Resource</b> (SDL_IOStream * resource={})</td></tr>
<tr class="memdesc:a959604d891dcae230bf4c378c046a21d inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs from the underlying resource. <br /></td></tr>
<tr class="separator:a959604d891dcae230bf4c378c046a21d inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78be254b85f48c12179a782cb04da9ac inherit pub_methods_classSDL_1_1Resource" id="r_a78be254b85f48c12179a782cb04da9ac"><td class="memItemLeft" align="right" valign="top">
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>Resource</b> (const ResourceHandle&lt; <a class="el" href="classSDL_1_1Resource.html">Resource</a>&lt; SDL_IOStream * &gt; &gt; auto &amp;resource)</td></tr>
<tr class="memdesc:a78be254b85f48c12179a782cb04da9ac inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs from pointer like. <br /></td></tr>
<tr class="separator:a78be254b85f48c12179a782cb04da9ac inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988d47fefd6d7a5f623d3de9fce5ea59 inherit pub_methods_classSDL_1_1Resource" id="r_a988d47fefd6d7a5f623d3de9fce5ea59"><td class="memItemLeft" align="right" valign="top">
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>Resource</b> (std::nullptr_t)</td></tr>
<tr class="memdesc:a988d47fefd6d7a5f623d3de9fce5ea59 inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to default ctor. <br /></td></tr>
<tr class="separator:a988d47fefd6d7a5f623d3de9fce5ea59 inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb3168108af6a8bd0e23edc712b6a09 inherit pub_methods_classSDL_1_1Resource" id="r_afbb3168108af6a8bd0e23edc712b6a09"><td class="memItemLeft" align="right" valign="top">
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>Resource</b> (std::nullopt_t)</td></tr>
<tr class="memdesc:afbb3168108af6a8bd0e23edc712b6a09 inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to default ctor. <br /></td></tr>
<tr class="separator:afbb3168108af6a8bd0e23edc712b6a09 inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1e912fa44fa869f6db73e4ba7720a9 inherit pub_methods_classSDL_1_1Resource" id="r_a0c1e912fa44fa869f6db73e4ba7720a9"><td class="memItemLeft" align="right" valign="top">
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>operator bool</b> () const</td></tr>
<tr class="memdesc:a0c1e912fa44fa869f6db73e4ba7720a9 inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if contains a valid resource. <br /></td></tr>
<tr class="separator:a0c1e912fa44fa869f6db73e4ba7720a9 inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4aa1e63564473a72dc97256340d104f inherit pub_methods_classSDL_1_1Resource" id="r_ab4aa1e63564473a72dc97256340d104f"><td class="memItemLeft" align="right" valign="top">
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>operator value_type</b> () const</td></tr>
<tr class="memdesc:ab4aa1e63564473a72dc97256340d104f inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts back to underlying type. <br /></td></tr>
<tr class="separator:ab4aa1e63564473a72dc97256340d104f inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00783ea48f16c278f89467a3ade29b18 inherit pub_methods_classSDL_1_1Resource" id="r_a00783ea48f16c278f89467a3ade29b18"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classSDL_1_1Resource.html">Resource</a> &amp;other) const=default</td></tr>
<tr class="memdesc:a00783ea48f16c278f89467a3ade29b18 inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison. <br /></td></tr>
<tr class="separator:a00783ea48f16c278f89467a3ade29b18 inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a82bc79a7dae41ceb1a25647ae1c0d inherit pub_methods_classSDL_1_1Resource" id="r_ad2a82bc79a7dae41ceb1a25647ae1c0d"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (std::nullopt_t) const</td></tr>
<tr class="memdesc:ad2a82bc79a7dae41ceb1a25647ae1c0d inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison. <br /></td></tr>
<tr class="separator:ad2a82bc79a7dae41ceb1a25647ae1c0d inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab110e6568060a7ae58ab7b29ad68f7fc inherit pub_methods_classSDL_1_1Resource" id="r_ab110e6568060a7ae58ab7b29ad68f7fc"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (std::nullptr_t) const</td></tr>
<tr class="memdesc:ab110e6568060a7ae58ab7b29ad68f7fc inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison. <br /></td></tr>
<tr class="separator:ab110e6568060a7ae58ab7b29ad68f7fc inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab273a0a0285b8eed1f70f5d3759f4167 inherit pub_methods_classSDL_1_1Resource" id="r_ab273a0a0285b8eed1f70f5d3759f4167"><td class="memItemLeft" align="right" valign="top">
constexpr SDL_IOStream *&#160;</td><td class="memItemRight" valign="bottom"><b>get</b> () const</td></tr>
<tr class="memdesc:ab273a0a0285b8eed1f70f5d3759f4167 inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return contained resource;. <br /></td></tr>
<tr class="separator:ab273a0a0285b8eed1f70f5d3759f4167 inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795922875f43cc42165896b02af59d0c inherit pub_methods_classSDL_1_1Resource" id="r_a795922875f43cc42165896b02af59d0c"><td class="memItemLeft" align="right" valign="top">
constexpr SDL_IOStream *&#160;</td><td class="memItemRight" valign="bottom"><b>release</b> (SDL_IOStream * newResource={})</td></tr>
<tr class="memdesc:a795922875f43cc42165896b02af59d0c inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return contained resource and empties or replace value. <br /></td></tr>
<tr class="separator:a795922875f43cc42165896b02af59d0c inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21f6ed563dbdb86c0d6d21c2721c767 inherit pub_methods_classSDL_1_1Resource" id="r_aa21f6ed563dbdb86c0d6d21c2721c767"><td class="memItemLeft" align="right" valign="top">
constexpr const SDL_IOStream *&#160;</td><td class="memItemRight" valign="bottom"><b>operator-&gt;</b> () const</td></tr>
<tr class="memdesc:aa21f6ed563dbdb86c0d6d21c2721c767 inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to fields. <br /></td></tr>
<tr class="separator:aa21f6ed563dbdb86c0d6d21c2721c767 inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bac10eb8bfedf254b67081d767c1a68 inherit pub_methods_classSDL_1_1Resource" id="r_a1bac10eb8bfedf254b67081d767c1a68"><td class="memItemLeft" align="right" valign="top">
constexpr SDL_IOStream *&#160;</td><td class="memItemRight" valign="bottom"><b>operator-&gt;</b> ()</td></tr>
<tr class="memdesc:a1bac10eb8bfedf254b67081d767c1a68 inherit pub_methods_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to fields. <br /></td></tr>
<tr class="separator:a1bac10eb8bfedf254b67081d767c1a68 inherit pub_methods_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a492ef68db5f34610f272630f8053db24" id="r_a492ef68db5f34610f272630f8053db24"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IOStreamRef.html#a492ef68db5f34610f272630f8053db24">reset</a> (SDL_IOStream *resource)</td></tr>
<tr class="memdesc:a492ef68db5f34610f272630f8053db24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close and free an allocated <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> structure.  <br /></td></tr>
<tr class="separator:a492ef68db5f34610f272630f8053db24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classSDL_1_1Resource"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSDL_1_1Resource')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSDL_1_1Resource.html">SDL::Resource&lt; SDL_IOStream * &gt;</a></td></tr>
<tr class="memitem:a11ac29cf1f6da9fb29c508669f40b38d inherit pub_types_classSDL_1_1Resource" id="r_a11ac29cf1f6da9fb29c508669f40b38d"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = SDL_IOStream *</td></tr>
<tr class="memdesc:a11ac29cf1f6da9fb29c508669f40b38d inherit pub_types_classSDL_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw resource type. <br /></td></tr>
<tr class="separator:a11ac29cf1f6da9fb29c508669f40b38d inherit pub_types_classSDL_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This operates as an opaque handle. There are several APIs to create various types of I/O streams, or an app can supply an IOStreamInterface to <a class="el" href="structSDL_1_1IOStream.html#a0e7631873815248557dd83ff665ea25e" title="Create a custom IOStreamRef.">IOStream.Open()</a> to provide their own stream implementation behind this struct's abstract interface.</p>
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section user"><dt>Category:</dt><dd><a class="el" href="resource.html">Resource</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1IOStream.html" title="Handle to an owned iOStream.">IOStream</a> </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac208e55f1cc620e61221c5cc1e732f1a" name="ac208e55f1cc620e61221c5cc1e732f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac208e55f1cc620e61221c5cc1e732f1a">&#9670;&#160;</a></span>Flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::IOStreamRef::Flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function makes sure that any buffered data is written to the stream. Normally this isn't necessary but if the stream is a pipe or socket it guarantees that any pending data is sent.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1IOStream.html#a991da53140a740b71e05f122562173ea" title="Use this function to create a new IOStream structure for reading from and/or writing to a named file.">IOStream.FromFile</a> </dd>
<dd>
<a class="el" href="structSDL_1_1IOStreamRef.html#ae3b518bd679bf9533679313cb6d82027" title="Write to an IOStreamRef data stream.">IOStreamRef.Write</a> </dd></dl>

</div>
</div>
<a id="a1a1353a4805a52c4066da56d2c83e2f7" name="a1a1353a4805a52c4066da56d2c83e2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a1353a4805a52c4066da56d2c83e2f7">&#9670;&#160;</a></span>GetProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSDL_1_1PropertiesRef.html">PropertiesRef</a> SDL::IOStreamRef::GetProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a valid property ID on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a354a7c0f986108a5c4f8a8a004d3b501" name="a354a7c0f986108a5c4f8a8a004d3b501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354a7c0f986108a5c4f8a8a004d3b501">&#9670;&#160;</a></span>GetSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sint64 SDL::IOStreamRef::GetSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the size of the data stream in the <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a1d8a2b80b055cb98bb2fd57824a2b9e1" name="a1d8a2b80b055cb98bb2fd57824a2b9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8a2b80b055cb98bb2fd57824a2b9e1">&#9670;&#160;</a></span>GetStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategoryIOStream.html#gac6fe4a8e6aa95d60056f3a597416c642">IOStatus</a> SDL::IOStreamRef::GetStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This information can be useful to decide if a short read or write was due to an error, an EOF, or a non-blocking operation that isn't yet ready to complete.</p>
<p>An <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a>'s status is only expected to change after a <a class="el" href="structSDL_1_1IOStreamRef.html#af26c1118dcfb7dfb3c0584233239d1ac" title="Read from a data source.">IOStreamRef.Read</a> or <a class="el" href="structSDL_1_1IOStreamRef.html#ae3b518bd679bf9533679313cb6d82027" title="Write to an IOStreamRef data stream.">IOStreamRef.Write</a> call; don't expect it to change if you just call this query function in a tight loop.</p>
<dl class="section return"><dt>Returns</dt><dd>an IOStatus enum with the current state.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ad8f779015005015ba17c9672331a1872" name="ad8f779015005015ba17c9672331a1872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f779015005015ba17c9672331a1872">&#9670;&#160;</a></span>LoadFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSDL_1_1StringResult.html">StringResult</a> SDL::IOStreamRef::LoadFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The data is allocated with a zero byte at the end (null terminated) for convenience. This extra byte is not included in the value reported via <code>datasize</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>the data in bytes </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1IOStreamRef.html#ad8f779015005015ba17c9672331a1872" title="Load all the data from an SDL data stream.">LoadFile</a> </dd>
<dd>
<a class="el" href="structSDL_1_1IOStreamRef.html#a735b413c092e9fadd55a03dd56be62a6" title="Save all the data into an SDL data stream.">IOStreamRef.SaveFile</a> </dd></dl>

</div>
</div>
<a id="a640f74da9562d1d176f4b7213c261301" name="a640f74da9562d1d176f4b7213c261301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640f74da9562d1d176f4b7213c261301">&#9670;&#160;</a></span>LoadFileAs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OwnArray.html">OwnArray</a>&lt; T &gt; SDL::IOStreamRef::LoadFileAs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The data is allocated with a zero byte at the end (null terminated) for convenience. This extra byte is not included in the value reported via <code>datasize</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>the data in bytes </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1IOStreamRef.html#ad8f779015005015ba17c9672331a1872" title="Load all the data from an SDL data stream.">LoadFile</a> </dd>
<dd>
<a class="el" href="structSDL_1_1IOStreamRef.html#a735b413c092e9fadd55a03dd56be62a6" title="Save all the data into an SDL data stream.">IOStreamRef.SaveFile</a> </dd></dl>

</div>
</div>
<a id="a427f0ace244ac6bb464a6321e8b0f561" name="a427f0ace244ac6bb464a6321e8b0f561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427f0ace244ac6bb464a6321e8b0f561">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::IOStreamRef::print </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Category:</dt><dd><a class="el" href="formatted-string.html">Formatted string</a> </dd></dl>

</div>
</div>
<a id="aa1add38ee45c1bb15910177a5221e29f" name="aa1add38ee45c1bb15910177a5221e29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1add38ee45c1bb15910177a5221e29f">&#9670;&#160;</a></span>printf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::IOStreamRef::printf </td>
          <td>(</td>
          <td class="paramtype">SDL_PRINTF_FORMAT_STRING const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>this is not typesafe! Prefer using <a class="el" href="structSDL_1_1IOStreamRef.html#a427f0ace244ac6bb464a6321e8b0f561">print()</a> and <a class="el" href="structSDL_1_1IOStreamRef.html#a852c75ac064fea3caaff30e1f4341473">println()</a></dd></dl>
<p>This function does formatted printing to the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>a <a class="el" href="structSDL_1_1IOStreamRef.html#aa1add38ee45c1bb15910177a5221e29f" title="Print to an IOStreamRef data stream.">printf()</a> style format string. </td></tr>
    <tr><td class="paramname">...</td><td>additional parameters matching % tokens in the <code>fmt</code> string, if any. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written or 0 on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1IOStreamRef.html#add5dae59f1d5d904945a51c724efea24" title="Print to an IOStreamRef data stream.">IOStreamRef.vprintf</a> </dd>
<dd>
<a class="el" href="structSDL_1_1IOStreamRef.html#ae3b518bd679bf9533679313cb6d82027" title="Write to an IOStreamRef data stream.">IOStreamRef.Write</a> </dd></dl>

</div>
</div>
<a id="a852c75ac064fea3caaff30e1f4341473" name="a852c75ac064fea3caaff30e1f4341473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852c75ac064fea3caaff30e1f4341473">&#9670;&#160;</a></span>println()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::IOStreamRef::println </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Category:</dt><dd><a class="el" href="formatted-string.html">Formatted string</a> </dd></dl>

</div>
</div>
<a id="af26c1118dcfb7dfb3c0584233239d1ac" name="af26c1118dcfb7dfb3c0584233239d1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26c1118dcfb7dfb3c0584233239d1ac">&#9670;&#160;</a></span>Read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string SDL::IOStreamRef::Read </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function reads up <code>size</code> bytes from the data source to the area pointed at by <code>ptr</code>. This function may read less bytes than requested.</p>
<p>This function will return zero when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If zero is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the number of bytes to read from the data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bytes, or empty string on end of file or other failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1IOStreamRef.html#ae3b518bd679bf9533679313cb6d82027" title="Write to an IOStreamRef data stream.">IOStreamRef.Write</a> </dd>
<dd>
<a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus</a> </dd></dl>

</div>
</div>
<a id="a935e63607e1ceb9b911e4b73960933cf" name="a935e63607e1ceb9b911e4b73960933cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935e63607e1ceb9b911e4b73960933cf">&#9670;&#160;</a></span>Read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::IOStreamRef::Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1TargetBytes.html">TargetBytes</a>&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function reads up <code>size</code> bytes from the data source to the area pointed at by <code>ptr</code>. This function may read less bytes than requested.</p>
<p>This function will return zero when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If zero is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer to read data into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read, or 0 on end of file or other failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1IOStreamRef.html#ae3b518bd679bf9533679313cb6d82027" title="Write to an IOStreamRef data stream.">IOStreamRef.Write</a> </dd>
<dd>
<a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus</a> </dd></dl>

</div>
</div>
<a id="a2eae1271f8e924587efd14f334853d8e" name="a2eae1271f8e924587efd14f334853d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eae1271f8e924587efd14f334853d8e">&#9670;&#160;</a></span>ReadS16BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sint16 SDL::IOStreamRef::ReadS16BE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a6dbe68ed57f98dcf08423bca2518a592" name="a6dbe68ed57f98dcf08423bca2518a592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dbe68ed57f98dcf08423bca2518a592">&#9670;&#160;</a></span>ReadS16LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sint16 SDL::IOStreamRef::ReadS16LE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="aa970c2cdaeb3a176b223d9ccb648ac9b" name="aa970c2cdaeb3a176b223d9ccb648ac9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa970c2cdaeb3a176b223d9ccb648ac9b">&#9670;&#160;</a></span>ReadS32BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sint32 SDL::IOStreamRef::ReadS32BE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a8d0ea261aa58e0f7d87d9276c8aa4645" name="a8d0ea261aa58e0f7d87d9276c8aa4645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0ea261aa58e0f7d87d9276c8aa4645">&#9670;&#160;</a></span>ReadS32LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sint32 SDL::IOStreamRef::ReadS32LE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a7ff3d96040de326d907a1a1cd544a474" name="a7ff3d96040de326d907a1a1cd544a474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff3d96040de326d907a1a1cd544a474">&#9670;&#160;</a></span>ReadS64BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sint64 SDL::IOStreamRef::ReadS64BE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="afee65caad6ca48ac9c4d4f7d3e16fed5" name="afee65caad6ca48ac9c4d4f7d3e16fed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee65caad6ca48ac9c4d4f7d3e16fed5">&#9670;&#160;</a></span>ReadS64LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sint64 SDL::IOStreamRef::ReadS64LE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a101cb819d4a6b98b7810a1cf2ca7aac1" name="a101cb819d4a6b98b7810a1cf2ca7aac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101cb819d4a6b98b7810a1cf2ca7aac1">&#9670;&#160;</a></span>ReadS8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sint8 SDL::IOStreamRef::ReadS8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a839b35d63a8d34826d6e826709d7ca92" name="a839b35d63a8d34826d6e826709d7ca92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839b35d63a8d34826d6e826709d7ca92">&#9670;&#160;</a></span>ReadU16BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint16 SDL::IOStreamRef::ReadU16BE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ab0d71638526c0d41555297adaced82fe" name="ab0d71638526c0d41555297adaced82fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d71638526c0d41555297adaced82fe">&#9670;&#160;</a></span>ReadU16LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint16 SDL::IOStreamRef::ReadU16LE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a9dfddf359c7a10a8e412328259c2536b" name="a9dfddf359c7a10a8e412328259c2536b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dfddf359c7a10a8e412328259c2536b">&#9670;&#160;</a></span>ReadU32BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 SDL::IOStreamRef::ReadU32BE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a4af8cf1023f2b0fba5a1b01ca01c978f" name="a4af8cf1023f2b0fba5a1b01ca01c978f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af8cf1023f2b0fba5a1b01ca01c978f">&#9670;&#160;</a></span>ReadU32LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 SDL::IOStreamRef::ReadU32LE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="af7ccacd0f0df79e88e64737dc4e37df8" name="af7ccacd0f0df79e88e64737dc4e37df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ccacd0f0df79e88e64737dc4e37df8">&#9670;&#160;</a></span>ReadU64BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint64 SDL::IOStreamRef::ReadU64BE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a0dfe31e1ce3b988549c8aebf50b79773" name="a0dfe31e1ce3b988549c8aebf50b79773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dfe31e1ce3b988549c8aebf50b79773">&#9670;&#160;</a></span>ReadU64LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint64 SDL::IOStreamRef::ReadU64LE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a9f32150e07368975e51bccf0325e90c7" name="a9f32150e07368975e51bccf0325e90c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f32150e07368975e51bccf0325e90c7">&#9670;&#160;</a></span>ReadU8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint8 SDL::IOStreamRef::ReadU8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a492ef68db5f34610f272630f8053db24" name="a492ef68db5f34610f272630f8053db24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492ef68db5f34610f272630f8053db24">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL::IOStreamRef::reset </td>
          <td>(</td>
          <td class="paramtype">SDL_IOStream *&#160;</td>
          <td class="paramname"><em>resource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="structSDL_1_1IOStream.html#a60482e493111870baf49cf7571732839" title="Close and free an allocated IOStreamRef structure.">IOStream.Close()</a> closes and cleans up the <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> stream. It releases any resources used by the stream and frees the <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> itself. This returns true on success, or false if the stream failed to flush to its output (e.g. to disk).</p>
<p>Note that if this fails to flush the stream for any reason, this function reports an error, but the <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> is still invalid once this function returns.</p>
<p>This call flushes any buffered writes to the operating system, but there are no guarantees that those writes have gone to physical media; they might be in the OS's file cache, waiting to go to disk later. If it's absolutely crucial that writes go to disk immediately, so they are definitely stored even if the power fails before the file cache would have caught up, one should call <a class="el" href="structSDL_1_1IOStreamRef.html#ac208e55f1cc620e61221c5cc1e732f1a" title="Flush any buffered data in the stream.">IOStreamRef.Flush()</a> before closing. Note that flushing takes time and makes the system and your app operate less efficiently, so do so sparingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resource</td><td><a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a> structure to close. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1IOStream.html#a0e7631873815248557dd83ff665ea25e" title="Create a custom IOStreamRef.">IOStream.Open</a> </dd></dl>

</div>
</div>
<a id="a735b413c092e9fadd55a03dd56be62a6" name="a735b413c092e9fadd55a03dd56be62a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a735b413c092e9fadd55a03dd56be62a6">&#9670;&#160;</a></span>SaveFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::IOStreamRef::SaveFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1SourceBytes.html">SourceBytes</a>&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the buf to be written. If datasize is 0, may be nullptr or a invalid pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1IOStreamRef.html#a735b413c092e9fadd55a03dd56be62a6" title="Save all the data into an SDL data stream.">SaveFile</a> </dd>
<dd>
<a class="el" href="structSDL_1_1IOStreamRef.html#ad8f779015005015ba17c9672331a1872" title="Load all the data from an SDL data stream.">IOStreamRef.LoadFile</a> </dd></dl>

</div>
</div>
<a id="af710faeadacc85343667c27e2fa9f03a" name="af710faeadacc85343667c27e2fa9f03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af710faeadacc85343667c27e2fa9f03a">&#9670;&#160;</a></span>Seek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sint64 SDL::IOStreamRef::Seek </td>
          <td>(</td>
          <td class="paramtype">Sint64&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryIOStream.html#ga4adfc77466072724dd0d0d41b5c49421">IOWhence</a>&#160;</td>
          <td class="paramname"><em>whence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function seeks to byte <code>offset</code>, relative to <code>whence</code>.</p>
<p><code>whence</code> may be any of the following values:</p>
<ul>
<li><code>IO_SEEK_SET</code>: seek from the beginning of data</li>
<li><code>IO_SEEK_CUR</code>: seek relative to current read point</li>
<li><code>IO_SEEK_END</code>: seek relative to the end of data</li>
</ul>
<p>If this stream can not seek, it will return -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>an offset in bytes, relative to <code>whence</code> location; can be negative. </td></tr>
    <tr><td class="paramname">whence</td><td>any of <code>IO_SEEK_SET</code>, <code>IO_SEEK_CUR</code>, <code>IO_SEEK_END</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the final offset in the data stream after the seek or -1 on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1IOStreamRef.html#ae119e0f3d32d947312fc642e529bfb00" title="Determine the current read/write offset in an IOStreamRef data stream.">IOStreamRef.Tell</a> </dd></dl>

</div>
</div>
<a id="ae119e0f3d32d947312fc642e529bfb00" name="ae119e0f3d32d947312fc642e529bfb00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae119e0f3d32d947312fc642e529bfb00">&#9670;&#160;</a></span>Tell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sint64 SDL::IOStreamRef::Tell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="structSDL_1_1IOStreamRef.html#ae119e0f3d32d947312fc642e529bfb00" title="Determine the current read/write offset in an IOStreamRef data stream.">IOStreamRef.Tell</a> is actually a wrapper function that calls the <a class="el" href="structSDL_1_1IOStreamRef.html" title="The read/write operation structure.">IOStreamRef</a>'s <code>seek</code> method, with an offset of 0 bytes from <code>IO_SEEK_CUR</code>, to simplify application development.</p>
<dl class="section return"><dt>Returns</dt><dd>the current offset in the stream, or -1 if the information can not be determined.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1IOStreamRef.html#af710faeadacc85343667c27e2fa9f03a" title="Seek within an IOStreamRef data stream.">IOStreamRef.Seek</a> </dd></dl>

</div>
</div>
<a id="a032747c4494e1ffb8dbd5269f7ba6796" name="a032747c4494e1ffb8dbd5269f7ba6796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032747c4494e1ffb8dbd5269f7ba6796">&#9670;&#160;</a></span>TryReadS16BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Sint16 &gt; SDL::IOStreamRef::TryReadS16BE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success, std::nullopt on failure.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a6fba31cd98ce8d209785f8c86988cc57" name="a6fba31cd98ce8d209785f8c86988cc57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fba31cd98ce8d209785f8c86988cc57">&#9670;&#160;</a></span>TryReadS16LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Sint16 &gt; SDL::IOStreamRef::TryReadS16LE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success, std::nullopt on failure.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a39753125e9abb5ca19433b7b12ad85dd" name="a39753125e9abb5ca19433b7b12ad85dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39753125e9abb5ca19433b7b12ad85dd">&#9670;&#160;</a></span>TryReadS32BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Sint32 &gt; SDL::IOStreamRef::TryReadS32BE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success, std::nullopt on failure.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a8877b4701f8367e3819109a533c70005" name="a8877b4701f8367e3819109a533c70005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8877b4701f8367e3819109a533c70005">&#9670;&#160;</a></span>TryReadS32LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Sint32 &gt; SDL::IOStreamRef::TryReadS32LE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success, std::nullopt on failure.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a7ee6af092685a1f1659882c095b31bf7" name="a7ee6af092685a1f1659882c095b31bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee6af092685a1f1659882c095b31bf7">&#9670;&#160;</a></span>TryReadS64BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Sint64 &gt; SDL::IOStreamRef::TryReadS64BE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success, std::nullopt on failure.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ad2389148770e064d05d2e1d977451e7d" name="ad2389148770e064d05d2e1d977451e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2389148770e064d05d2e1d977451e7d">&#9670;&#160;</a></span>TryReadS64LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Sint64 &gt; SDL::IOStreamRef::TryReadS64LE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success, std::nullopt on failure.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a7cc93a7746aabadddeeddb9dcd44d757" name="a7cc93a7746aabadddeeddb9dcd44d757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc93a7746aabadddeeddb9dcd44d757">&#9670;&#160;</a></span>TryReadS8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Sint8 &gt; SDL::IOStreamRef::TryReadS8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success, std::nullopt on failure.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="af974e8d60f5279f547f0218377e27346" name="af974e8d60f5279f547f0218377e27346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af974e8d60f5279f547f0218377e27346">&#9670;&#160;</a></span>TryReadU16BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Uint16 &gt; SDL::IOStreamRef::TryReadU16BE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success, std::nullopt on failure.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a447a44f0e26a57775bbd197de9dde8f0" name="a447a44f0e26a57775bbd197de9dde8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447a44f0e26a57775bbd197de9dde8f0">&#9670;&#160;</a></span>TryReadU16LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Uint16 &gt; SDL::IOStreamRef::TryReadU16LE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success, std::nullopt on failure.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a90b2c226b00992aefdeba5c05b8c8c09" name="a90b2c226b00992aefdeba5c05b8c8c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b2c226b00992aefdeba5c05b8c8c09">&#9670;&#160;</a></span>TryReadU32BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Uint32 &gt; SDL::IOStreamRef::TryReadU32BE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success, std::nullopt on failure.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="aebb79183c2452811e9b88bf38d45af82" name="aebb79183c2452811e9b88bf38d45af82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb79183c2452811e9b88bf38d45af82">&#9670;&#160;</a></span>TryReadU32LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Uint32 &gt; SDL::IOStreamRef::TryReadU32LE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success, std::nullopt on failure.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ab955812271daec122dbf4e40a97a367f" name="ab955812271daec122dbf4e40a97a367f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab955812271daec122dbf4e40a97a367f">&#9670;&#160;</a></span>TryReadU64BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Uint64 &gt; SDL::IOStreamRef::TryReadU64BE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success, std::nullopt on failure.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ac222f1ca86f5590d8c914ea82640e6fa" name="ac222f1ca86f5590d8c914ea82640e6fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac222f1ca86f5590d8c914ea82640e6fa">&#9670;&#160;</a></span>TryReadU64LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Uint64 &gt; SDL::IOStreamRef::TryReadU64LE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the data returned will be in the native byte order.</p>
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success, std::nullopt on failure.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="aeea56d2a56964972987a1472acab0796" name="aeea56d2a56964972987a1472acab0796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea56d2a56964972987a1472acab0796">&#9670;&#160;</a></span>TryReadU8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Uint8 &gt; SDL::IOStreamRef::TryReadU8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will return false when the data stream is completely read, and <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return IO_STATUS_EOF. If false is returned and the stream is not at EOF, <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> will return a different error value and <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> will offer a human-readable message.</p>
<dl class="section return"><dt>Returns</dt><dd>the data read on success, std::nullopt on failure.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="add5dae59f1d5d904945a51c724efea24" name="add5dae59f1d5d904945a51c724efea24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5dae59f1d5d904945a51c724efea24">&#9670;&#160;</a></span>vprintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::IOStreamRef::vprintf </td>
          <td>(</td>
          <td class="paramtype">SDL_PRINTF_FORMAT_STRING const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>this is not typesafe! Prefer using <a class="el" href="structSDL_1_1IOStreamRef.html#a427f0ace244ac6bb464a6321e8b0f561">print()</a> and <a class="el" href="structSDL_1_1IOStreamRef.html#a852c75ac064fea3caaff30e1f4341473">println()</a></dd></dl>
<p>This function does formatted printing to the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>a <a class="el" href="structSDL_1_1IOStreamRef.html#aa1add38ee45c1bb15910177a5221e29f" title="Print to an IOStreamRef data stream.">printf()</a> style format string. </td></tr>
    <tr><td class="paramname">ap</td><td>a variable argument list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written or 0 on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1IOStreamRef.html#aa1add38ee45c1bb15910177a5221e29f" title="Print to an IOStreamRef data stream.">IOStreamRef.printf</a> </dd>
<dd>
<a class="el" href="structSDL_1_1IOStreamRef.html#ae3b518bd679bf9533679313cb6d82027" title="Write to an IOStreamRef data stream.">IOStreamRef.Write</a> </dd></dl>

</div>
</div>
<a id="ae3b518bd679bf9533679313cb6d82027" name="ae3b518bd679bf9533679313cb6d82027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b518bd679bf9533679313cb6d82027">&#9670;&#160;</a></span>Write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::IOStreamRef::Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1SourceBytes.html">SourceBytes</a>&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function writes exactly <code>size</code> bytes from the area pointed at by <code>ptr</code> to the stream. If this fails for any reason, it'll return less than <code>size</code> to demonstrate how far the write progressed. On success, it returns <code>size</code>.</p>
<p>On error, this function still attempts to write as much as possible, so it might return a positive value less than the requested write size.</p>
<p>The caller can use <a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus()</a> to determine if the problem is recoverable, such as a non-blocking write that can simply be retried later, or a fatal error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the bytes to write to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written, which will be less than <code>size</code> on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1IOStreamRef.html#aa1add38ee45c1bb15910177a5221e29f" title="Print to an IOStreamRef data stream.">IOStreamRef.printf</a> </dd>
<dd>
<a class="el" href="structSDL_1_1IOStreamRef.html#af26c1118dcfb7dfb3c0584233239d1ac" title="Read from a data source.">IOStreamRef.Read</a> </dd>
<dd>
<a class="el" href="structSDL_1_1IOStreamRef.html#af710faeadacc85343667c27e2fa9f03a" title="Seek within an IOStreamRef data stream.">IOStreamRef.Seek</a> </dd>
<dd>
<a class="el" href="structSDL_1_1IOStreamRef.html#ac208e55f1cc620e61221c5cc1e732f1a" title="Flush any buffered data in the stream.">IOStreamRef.Flush</a> </dd>
<dd>
<a class="el" href="structSDL_1_1IOStreamRef.html#a1d8a2b80b055cb98bb2fd57824a2b9e1" title="Query the stream status of an IOStreamRef.">IOStreamRef.GetStatus</a> </dd></dl>

</div>
</div>
<a id="afcc9dc24484e6906344b94c8dca0a3e9" name="afcc9dc24484e6906344b94c8dca0a3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc9dc24484e6906344b94c8dca0a3e9">&#9670;&#160;</a></span>WriteS16BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::IOStreamRef::WriteS16BE </td>
          <td>(</td>
          <td class="paramtype">Sint16&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in big-endian format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the data to be written, in native format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ae9e286b98128df9a4471966dc9246938" name="ae9e286b98128df9a4471966dc9246938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e286b98128df9a4471966dc9246938">&#9670;&#160;</a></span>WriteS16LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::IOStreamRef::WriteS16LE </td>
          <td>(</td>
          <td class="paramtype">Sint16&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in little-endian format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the data to be written, in native format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ab66a90c818ceb2a87d2e652eb645a7c5" name="ab66a90c818ceb2a87d2e652eb645a7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66a90c818ceb2a87d2e652eb645a7c5">&#9670;&#160;</a></span>WriteS32BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::IOStreamRef::WriteS32BE </td>
          <td>(</td>
          <td class="paramtype">Sint32&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in big-endian format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the data to be written, in native format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="aef7fb28e9af23e2ec5fe041667b47ef5" name="aef7fb28e9af23e2ec5fe041667b47ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7fb28e9af23e2ec5fe041667b47ef5">&#9670;&#160;</a></span>WriteS32LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::IOStreamRef::WriteS32LE </td>
          <td>(</td>
          <td class="paramtype">Sint32&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in little-endian format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the data to be written, in native format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a3c49a147bd58ca922f64a1b8d56a8a19" name="a3c49a147bd58ca922f64a1b8d56a8a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c49a147bd58ca922f64a1b8d56a8a19">&#9670;&#160;</a></span>WriteS64BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::IOStreamRef::WriteS64BE </td>
          <td>(</td>
          <td class="paramtype">Sint64&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in big-endian format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the data to be written, in native format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a2bd4bb8cec5403b93282a5a4f5574b6f" name="a2bd4bb8cec5403b93282a5a4f5574b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd4bb8cec5403b93282a5a4f5574b6f">&#9670;&#160;</a></span>WriteS64LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::IOStreamRef::WriteS64LE </td>
          <td>(</td>
          <td class="paramtype">Sint64&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in little-endian format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the data to be written, in native format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a080ec45f9d8b80589574ad5479d97790" name="a080ec45f9d8b80589574ad5479d97790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080ec45f9d8b80589574ad5479d97790">&#9670;&#160;</a></span>WriteS8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::IOStreamRef::WriteS8 </td>
          <td>(</td>
          <td class="paramtype">Sint8&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the byte value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a7344a5bc403634025a182e795615bb07" name="a7344a5bc403634025a182e795615bb07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7344a5bc403634025a182e795615bb07">&#9670;&#160;</a></span>WriteU16BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::IOStreamRef::WriteU16BE </td>
          <td>(</td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in big-endian format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the data to be written, in native format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a26a675e3d3180e30b7173274fef4d6f5" name="a26a675e3d3180e30b7173274fef4d6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a675e3d3180e30b7173274fef4d6f5">&#9670;&#160;</a></span>WriteU16LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::IOStreamRef::WriteU16LE </td>
          <td>(</td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in little-endian format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the data to be written, in native format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a443178ccbacefd6c6debcbdffc7b5bd2" name="a443178ccbacefd6c6debcbdffc7b5bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443178ccbacefd6c6debcbdffc7b5bd2">&#9670;&#160;</a></span>WriteU32BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::IOStreamRef::WriteU32BE </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in big-endian format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the data to be written, in native format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a8bb297b525c97fead3f799034aeb10f9" name="a8bb297b525c97fead3f799034aeb10f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb297b525c97fead3f799034aeb10f9">&#9670;&#160;</a></span>WriteU32LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::IOStreamRef::WriteU32LE </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in little-endian format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the data to be written, in native format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a107f2a596e6d3687de93fa53a701b986" name="a107f2a596e6d3687de93fa53a701b986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a107f2a596e6d3687de93fa53a701b986">&#9670;&#160;</a></span>WriteU64BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::IOStreamRef::WriteU64BE </td>
          <td>(</td>
          <td class="paramtype">Uint64&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in big-endian format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the data to be written, in native format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="a5cac4cda5297ef805c839730ecd9b7fe" name="a5cac4cda5297ef805c839730ecd9b7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cac4cda5297ef805c839730ecd9b7fe">&#9670;&#160;</a></span>WriteU64LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::IOStreamRef::WriteU64LE </td>
          <td>(</td>
          <td class="paramtype">Uint64&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in little-endian format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the data to be written, in native format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ac0f8816904e297db1c116940a939d005" name="ac0f8816904e297db1c116940a939d005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f8816904e297db1c116940a939d005">&#9670;&#160;</a></span>WriteU8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::IOStreamRef::WriteU8 </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the byte value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>SDL3pp/<a class="el" href="SDL3pp__iostream_8h_source.html">SDL3pp_iostream.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
