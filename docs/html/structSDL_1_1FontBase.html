<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDL3pp: SDL::FontBase&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SDL3pp
   </div>
   <div id="projectbrief">A slim C++ wrapper for SDL3</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSDL.html">SDL</a></li><li class="navelem"><a class="el" href="structSDL_1_1FontBase.html">FontBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structSDL_1_1FontBase-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SDL::FontBase&lt; T &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__Categories.html">Categories</a> &raquo; <a class="el" href="group__CategoriesLibs.html">Satellite Libraries</a> &raquo; <a class="el" href="group__CategorySDLTTF.html">True type font support</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>The internal structure containing font information.  
 <a href="structSDL_1_1FontBase.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SDL3pp__ttf_8h_source.html">SDL3pp_ttf.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SDL::FontBase&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structSDL_1_1FontBase__inherit__graph.png" border="0" usemap="#aSDL_1_1FontBase_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aSDL_1_1FontBase_3_01T_01_4_inherit__map" id="aSDL_1_1FontBase_3_01T_01_4_inherit__map">
<area shape="rect" title="The internal structure containing font information." alt="" coords="5,79,159,104"/>
<area shape="rect" title=" " alt="" coords="63,5,101,31"/>
<area shape="poly" title=" " alt="" coords="85,44,85,79,79,79,79,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for SDL::FontBase&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structSDL_1_1FontBase__coll__graph.png" border="0" usemap="#aSDL_1_1FontBase_3_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aSDL_1_1FontBase_3_01T_01_4_coll__map" id="aSDL_1_1FontBase_3_01T_01_4_coll__map">
<area shape="rect" title="The internal structure containing font information." alt="" coords="5,79,159,104"/>
<area shape="rect" title=" " alt="" coords="63,5,101,31"/>
<area shape="poly" title=" " alt="" coords="85,44,85,79,79,79,79,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad2088904970ac90520ff83ea4ccdb90b" id="r_ad2088904970ac90520ff83ea4ccdb90b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#ad2088904970ac90520ff83ea4ccdb90b">FontBase</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> file, float ptsize)</td></tr>
<tr class="memdesc:ad2088904970ac90520ff83ea4ccdb90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a font from a file, using a specified point size.  <br /></td></tr>
<tr class="separator:ad2088904970ac90520ff83ea4ccdb90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cc919ac1c08b1881eada50c6e46231" id="r_a93cc919ac1c08b1881eada50c6e46231"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a93cc919ac1c08b1881eada50c6e46231">FontBase</a> (ObjectBox&lt; SDL_IOStream &gt; auto &amp;&amp;src, bool closeio, float ptsize)</td></tr>
<tr class="memdesc:a93cc919ac1c08b1881eada50c6e46231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a font from an SDL_IOStream, using a specified point size.  <br /></td></tr>
<tr class="separator:a93cc919ac1c08b1881eada50c6e46231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fc7a185c7627c348272ac3125730e4" id="r_a56fc7a185c7627c348272ac3125730e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a56fc7a185c7627c348272ac3125730e4">FontBase</a> (<a class="el" href="group__CategoryProperties.html#gaa5faab1a5ca99f759b68b5800ab0697f">PropertiesRef</a> props)</td></tr>
<tr class="memdesc:a56fc7a185c7627c348272ac3125730e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a font with the specified properties.  <br /></td></tr>
<tr class="separator:a56fc7a185c7627c348272ac3125730e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819312530ea776a22fc669197b145fbd" id="r_a819312530ea776a22fc669197b145fbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategorySDLTTF.html#ga4dd382dc093e6f59f96c32663e22a20e">Font</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a819312530ea776a22fc669197b145fbd">Copy</a> () const</td></tr>
<tr class="memdesc:a819312530ea776a22fc669197b145fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of an existing font.  <br /></td></tr>
<tr class="separator:a819312530ea776a22fc669197b145fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade426080265efb4938d524b23848ba0b" id="r_ade426080265efb4938d524b23848ba0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategoryProperties.html#gaa5faab1a5ca99f759b68b5800ab0697f">PropertiesRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#ade426080265efb4938d524b23848ba0b">GetProperties</a> ()</td></tr>
<tr class="memdesc:ade426080265efb4938d524b23848ba0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the properties associated with a font.  <br /></td></tr>
<tr class="separator:ade426080265efb4938d524b23848ba0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3487fb44b86ebb96089f1d0a3f70d58" id="r_ab3487fb44b86ebb96089f1d0a3f70d58"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#ab3487fb44b86ebb96089f1d0a3f70d58">GetGeneration</a> () const</td></tr>
<tr class="memdesc:ab3487fb44b86ebb96089f1d0a3f70d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the font generation.  <br /></td></tr>
<tr class="separator:ab3487fb44b86ebb96089f1d0a3f70d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf535beaea74350ae40af88fa25e7c5" id="r_a8bf535beaea74350ae40af88fa25e7c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a8bf535beaea74350ae40af88fa25e7c5">AddFallback</a> (<a class="el" href="group__CategorySDLTTF.html#ga4b737abba8bfc633457b3ec919a79960">FontRef</a> fallback)</td></tr>
<tr class="memdesc:a8bf535beaea74350ae40af88fa25e7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a fallback font.  <br /></td></tr>
<tr class="separator:a8bf535beaea74350ae40af88fa25e7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8bd695fb731654a8ee835fe7519bdd" id="r_a3f8bd695fb731654a8ee835fe7519bdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a3f8bd695fb731654a8ee835fe7519bdd">RemoveFallback</a> (<a class="el" href="group__CategorySDLTTF.html#ga4b737abba8bfc633457b3ec919a79960">FontRef</a> fallback)</td></tr>
<tr class="memdesc:a3f8bd695fb731654a8ee835fe7519bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a fallback font.  <br /></td></tr>
<tr class="separator:a3f8bd695fb731654a8ee835fe7519bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84d5a8b851688b3cd8212ac61f024f6" id="r_ae84d5a8b851688b3cd8212ac61f024f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#ae84d5a8b851688b3cd8212ac61f024f6">ClearFallbacks</a> ()</td></tr>
<tr class="memdesc:ae84d5a8b851688b3cd8212ac61f024f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all fallback fonts.  <br /></td></tr>
<tr class="separator:ae84d5a8b851688b3cd8212ac61f024f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26319f879baf1f9e62a348da82305444" id="r_a26319f879baf1f9e62a348da82305444"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a26319f879baf1f9e62a348da82305444">SetSize</a> (float ptsize)</td></tr>
<tr class="memdesc:a26319f879baf1f9e62a348da82305444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a font's size dynamically.  <br /></td></tr>
<tr class="separator:a26319f879baf1f9e62a348da82305444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa90ad4d1035a537b0837bcc45148f83" id="r_aaa90ad4d1035a537b0837bcc45148f83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#aaa90ad4d1035a537b0837bcc45148f83">SetSizeDPI</a> (float ptsize, int hdpi, int vdpi)</td></tr>
<tr class="memdesc:aaa90ad4d1035a537b0837bcc45148f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set font size dynamically with target resolutions, in dots per inch.  <br /></td></tr>
<tr class="separator:aaa90ad4d1035a537b0837bcc45148f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9480df190e9508df2bab37e9ec4db24" id="r_ad9480df190e9508df2bab37e9ec4db24"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#ad9480df190e9508df2bab37e9ec4db24">GetSize</a> () const</td></tr>
<tr class="memdesc:ad9480df190e9508df2bab37e9ec4db24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a font.  <br /></td></tr>
<tr class="separator:ad9480df190e9508df2bab37e9ec4db24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd02829532f228912d6cf8165f7ec9a1" id="r_abd02829532f228912d6cf8165f7ec9a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#abd02829532f228912d6cf8165f7ec9a1">GetDPI</a> (int *hdpi, int *vdpi) const</td></tr>
<tr class="memdesc:abd02829532f228912d6cf8165f7ec9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get font target resolutions, in dots per inch.  <br /></td></tr>
<tr class="separator:abd02829532f228912d6cf8165f7ec9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e686800ddc86a7b1955e83780484ea" id="r_a59e686800ddc86a7b1955e83780484ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a59e686800ddc86a7b1955e83780484ea">SetStyle</a> (<a class="el" href="group__CategorySDLTTF.html#ga5cd0ae7a98a535d094ec54cefa0076cd">FontStyleFlags</a> style)</td></tr>
<tr class="memdesc:a59e686800ddc86a7b1955e83780484ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a font's current style.  <br /></td></tr>
<tr class="separator:a59e686800ddc86a7b1955e83780484ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4bfbce1afb092f7663622e4b4c145b0" id="r_ae4bfbce1afb092f7663622e4b4c145b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategorySDLTTF.html#ga5cd0ae7a98a535d094ec54cefa0076cd">FontStyleFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#ae4bfbce1afb092f7663622e4b4c145b0">GetStyle</a> () const</td></tr>
<tr class="memdesc:ae4bfbce1afb092f7663622e4b4c145b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a font's current style.  <br /></td></tr>
<tr class="separator:ae4bfbce1afb092f7663622e4b4c145b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31061d9e3a626e7dd74b02d5dc153d98" id="r_a31061d9e3a626e7dd74b02d5dc153d98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a31061d9e3a626e7dd74b02d5dc153d98">SetOutline</a> (int outline)</td></tr>
<tr class="memdesc:a31061d9e3a626e7dd74b02d5dc153d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a font's current outline.  <br /></td></tr>
<tr class="separator:a31061d9e3a626e7dd74b02d5dc153d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe88cb55536775b9e6faa6ffbfa92b3" id="r_aefe88cb55536775b9e6faa6ffbfa92b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#aefe88cb55536775b9e6faa6ffbfa92b3">GetOutline</a> () const</td></tr>
<tr class="memdesc:aefe88cb55536775b9e6faa6ffbfa92b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a font's current outline.  <br /></td></tr>
<tr class="separator:aefe88cb55536775b9e6faa6ffbfa92b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d153bcc47420c591096b77db98f4f72" id="r_a5d153bcc47420c591096b77db98f4f72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a5d153bcc47420c591096b77db98f4f72">SetHinting</a> (<a class="el" href="group__CategorySDLTTF.html#ga45c17da1112591a8709c37afb95e7dba">HintingFlags</a> hinting)</td></tr>
<tr class="memdesc:a5d153bcc47420c591096b77db98f4f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a font's current hinter setting.  <br /></td></tr>
<tr class="separator:a5d153bcc47420c591096b77db98f4f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da82317f4a09159691b9cf125b9af13" id="r_a5da82317f4a09159691b9cf125b9af13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a5da82317f4a09159691b9cf125b9af13">GetNumFaces</a> () const</td></tr>
<tr class="memdesc:a5da82317f4a09159691b9cf125b9af13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of faces of a font.  <br /></td></tr>
<tr class="separator:a5da82317f4a09159691b9cf125b9af13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f0651f48d48b66dbf1ceddb782907a" id="r_ae0f0651f48d48b66dbf1ceddb782907a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategorySDLTTF.html#ga45c17da1112591a8709c37afb95e7dba">HintingFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#ae0f0651f48d48b66dbf1ceddb782907a">GetHinting</a> () const</td></tr>
<tr class="memdesc:ae0f0651f48d48b66dbf1ceddb782907a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a font's current FreeType hinter setting.  <br /></td></tr>
<tr class="separator:ae0f0651f48d48b66dbf1ceddb782907a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e81c295cbe9cab137c6c5f02fb0826" id="r_ac9e81c295cbe9cab137c6c5f02fb0826"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#ac9e81c295cbe9cab137c6c5f02fb0826">SetSDF</a> (bool enabled)</td></tr>
<tr class="memdesc:ac9e81c295cbe9cab137c6c5f02fb0826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Signed Distance Field rendering for a font.  <br /></td></tr>
<tr class="separator:ac9e81c295cbe9cab137c6c5f02fb0826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0ec19df003e99bd8e1a506fef298a1" id="r_a8a0ec19df003e99bd8e1a506fef298a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a8a0ec19df003e99bd8e1a506fef298a1">GetSDF</a> () const</td></tr>
<tr class="memdesc:a8a0ec19df003e99bd8e1a506fef298a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether Signed Distance Field rendering is enabled for a font.  <br /></td></tr>
<tr class="separator:a8a0ec19df003e99bd8e1a506fef298a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104e432e4861f271c0499487cbaddeaf" id="r_a104e432e4861f271c0499487cbaddeaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a104e432e4861f271c0499487cbaddeaf">SetWrapAlignment</a> (<a class="el" href="group__CategorySDLTTF.html#gad84ec37f41813cbbd941700f70207d1d">HorizontalAlignment</a> align)</td></tr>
<tr class="memdesc:a104e432e4861f271c0499487cbaddeaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a font's current wrap alignment option.  <br /></td></tr>
<tr class="separator:a104e432e4861f271c0499487cbaddeaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426d7bd38474a70fd58aeee33cf2ea71" id="r_a426d7bd38474a70fd58aeee33cf2ea71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategorySDLTTF.html#gad84ec37f41813cbbd941700f70207d1d">HorizontalAlignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a426d7bd38474a70fd58aeee33cf2ea71">GetWrapAlignment</a> () const</td></tr>
<tr class="memdesc:a426d7bd38474a70fd58aeee33cf2ea71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a font's current wrap alignment option.  <br /></td></tr>
<tr class="separator:a426d7bd38474a70fd58aeee33cf2ea71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e16117574e0c686791f04c6f1d351b5" id="r_a9e16117574e0c686791f04c6f1d351b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a9e16117574e0c686791f04c6f1d351b5">GetHeight</a> () const</td></tr>
<tr class="memdesc:a9e16117574e0c686791f04c6f1d351b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the total height of a font.  <br /></td></tr>
<tr class="separator:a9e16117574e0c686791f04c6f1d351b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99719ed076eb56969cf1720231d73cc" id="r_aa99719ed076eb56969cf1720231d73cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#aa99719ed076eb56969cf1720231d73cc">GetAscent</a> () const</td></tr>
<tr class="memdesc:aa99719ed076eb56969cf1720231d73cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the offset from the baseline to the top of a font.  <br /></td></tr>
<tr class="separator:aa99719ed076eb56969cf1720231d73cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23d0568d5a230faf6fc8ede31f61c4c" id="r_ac23d0568d5a230faf6fc8ede31f61c4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#ac23d0568d5a230faf6fc8ede31f61c4c">GetDescent</a> () const</td></tr>
<tr class="memdesc:ac23d0568d5a230faf6fc8ede31f61c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the offset from the baseline to the bottom of a font.  <br /></td></tr>
<tr class="separator:ac23d0568d5a230faf6fc8ede31f61c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ee8b02794f6341e37720e8c526cb91" id="r_ae8ee8b02794f6341e37720e8c526cb91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#ae8ee8b02794f6341e37720e8c526cb91">SetLineSkip</a> (int lineskip)</td></tr>
<tr class="memdesc:ae8ee8b02794f6341e37720e8c526cb91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the spacing between lines of text for a font.  <br /></td></tr>
<tr class="separator:ae8ee8b02794f6341e37720e8c526cb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7415a14e6873a2fd6583918d85d48d" id="r_a2f7415a14e6873a2fd6583918d85d48d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a2f7415a14e6873a2fd6583918d85d48d">GetLineSkip</a> () const</td></tr>
<tr class="memdesc:a2f7415a14e6873a2fd6583918d85d48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the spacing between lines of text for a font.  <br /></td></tr>
<tr class="separator:a2f7415a14e6873a2fd6583918d85d48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ec4f02cc3f1d4ab1659d320bd3314f" id="r_ab1ec4f02cc3f1d4ab1659d320bd3314f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#ab1ec4f02cc3f1d4ab1659d320bd3314f">SetKerning</a> (bool enabled)</td></tr>
<tr class="memdesc:ab1ec4f02cc3f1d4ab1659d320bd3314f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set if kerning is enabled for a font.  <br /></td></tr>
<tr class="separator:ab1ec4f02cc3f1d4ab1659d320bd3314f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58d72963452d55d114245518893fc00" id="r_ab58d72963452d55d114245518893fc00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#ab58d72963452d55d114245518893fc00">GetKerning</a> () const</td></tr>
<tr class="memdesc:ab58d72963452d55d114245518893fc00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether or not kerning is enabled for a font.  <br /></td></tr>
<tr class="separator:ab58d72963452d55d114245518893fc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160ffc4dc070bc7a41558eaac5aa09fd" id="r_a160ffc4dc070bc7a41558eaac5aa09fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a160ffc4dc070bc7a41558eaac5aa09fd">IsFixedWidth</a> () const</td></tr>
<tr class="memdesc:a160ffc4dc070bc7a41558eaac5aa09fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether a font is fixed-width.  <br /></td></tr>
<tr class="separator:a160ffc4dc070bc7a41558eaac5aa09fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2154976865a9b4387a3093a6d39b379" id="r_aa2154976865a9b4387a3093a6d39b379"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#aa2154976865a9b4387a3093a6d39b379">IsScalable</a> () const</td></tr>
<tr class="memdesc:aa2154976865a9b4387a3093a6d39b379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether a font is scalable or not.  <br /></td></tr>
<tr class="separator:aa2154976865a9b4387a3093a6d39b379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d20993bead27d3a587050ed3953c68" id="r_af6d20993bead27d3a587050ed3953c68"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#af6d20993bead27d3a587050ed3953c68">GetFamilyName</a> () const</td></tr>
<tr class="memdesc:af6d20993bead27d3a587050ed3953c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a font's family name.  <br /></td></tr>
<tr class="separator:af6d20993bead27d3a587050ed3953c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48cb765e8d843b285d6fd20cf231525" id="r_ac48cb765e8d843b285d6fd20cf231525"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#ac48cb765e8d843b285d6fd20cf231525">GetStyleName</a> () const</td></tr>
<tr class="memdesc:ac48cb765e8d843b285d6fd20cf231525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a font's style name.  <br /></td></tr>
<tr class="separator:ac48cb765e8d843b285d6fd20cf231525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13aa678e51df5ae076d0734227b6b778" id="r_a13aa678e51df5ae076d0734227b6b778"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a13aa678e51df5ae076d0734227b6b778">SetDirection</a> (<a class="el" href="group__CategorySDLTTF.html#gaf7bd9c3d8e546a09ac49f2f82eb16f3a">Direction</a> direction)</td></tr>
<tr class="memdesc:a13aa678e51df5ae076d0734227b6b778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the direction to be used for text shaping by a font.  <br /></td></tr>
<tr class="separator:a13aa678e51df5ae076d0734227b6b778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7972327fc038ac1f6b158e690c9bcc38" id="r_a7972327fc038ac1f6b158e690c9bcc38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategorySDLTTF.html#gaf7bd9c3d8e546a09ac49f2f82eb16f3a">Direction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a7972327fc038ac1f6b158e690c9bcc38">GetDirection</a> () const</td></tr>
<tr class="memdesc:a7972327fc038ac1f6b158e690c9bcc38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the direction to be used for text shaping by a font.  <br /></td></tr>
<tr class="separator:a7972327fc038ac1f6b158e690c9bcc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc4a6b547cfa94aa8c75bc4da38591f" id="r_a1dc4a6b547cfa94aa8c75bc4da38591f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a1dc4a6b547cfa94aa8c75bc4da38591f">SetScript</a> (Uint32 script)</td></tr>
<tr class="memdesc:a1dc4a6b547cfa94aa8c75bc4da38591f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the script to be used for text shaping by a font.  <br /></td></tr>
<tr class="separator:a1dc4a6b547cfa94aa8c75bc4da38591f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b77ff49c7d58ed91ce6ca8ce146a44" id="r_ae8b77ff49c7d58ed91ce6ca8ce146a44"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#ae8b77ff49c7d58ed91ce6ca8ce146a44">GetScript</a> () const</td></tr>
<tr class="memdesc:ae8b77ff49c7d58ed91ce6ca8ce146a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the script used for text shaping a font.  <br /></td></tr>
<tr class="separator:ae8b77ff49c7d58ed91ce6ca8ce146a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c3dc2621dc2811a284348680b20f24" id="r_ae4c3dc2621dc2811a284348680b20f24"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#ae4c3dc2621dc2811a284348680b20f24">GetGlyphScript</a> (Uint32 ch) const</td></tr>
<tr class="memdesc:ae4c3dc2621dc2811a284348680b20f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the script used by a 32-bit codepoint.  <br /></td></tr>
<tr class="separator:ae4c3dc2621dc2811a284348680b20f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9229654b55be73a6ecef726833813b" id="r_a7e9229654b55be73a6ecef726833813b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a7e9229654b55be73a6ecef726833813b">SetLanguage</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> language_bcp47)</td></tr>
<tr class="memdesc:a7e9229654b55be73a6ecef726833813b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set language to be used for text shaping by a font.  <br /></td></tr>
<tr class="separator:a7e9229654b55be73a6ecef726833813b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7425e7615c5e0c011ea8dc1faf0e628" id="r_aa7425e7615c5e0c011ea8dc1faf0e628"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#aa7425e7615c5e0c011ea8dc1faf0e628">HasGlyph</a> (Uint32 ch) const</td></tr>
<tr class="memdesc:aa7425e7615c5e0c011ea8dc1faf0e628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a glyph is provided by the font for a UNICODE codepoint.  <br /></td></tr>
<tr class="separator:aa7425e7615c5e0c011ea8dc1faf0e628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d714538aa12047a88f7f70c978721d4" id="r_a0d714538aa12047a88f7f70c978721d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategorySurface.html#ga2ea8e6016ec594c51738ef06f469d5d2">SurfaceRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a0d714538aa12047a88f7f70c978721d4">GetGlyphImage</a> (Uint32 ch, <a class="el" href="group__CategorySDLTTF.html#ga98bfeba14cf51c2601ce84f001e074b8">ImageType</a> *image_type) const</td></tr>
<tr class="memdesc:a0d714538aa12047a88f7f70c978721d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pixel image for a UNICODE codepoint.  <br /></td></tr>
<tr class="separator:a0d714538aa12047a88f7f70c978721d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadfd7295678f3310b853aa798ef7d03" id="r_afadfd7295678f3310b853aa798ef7d03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategorySurface.html#ga2ea8e6016ec594c51738ef06f469d5d2">SurfaceRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#afadfd7295678f3310b853aa798ef7d03">GetGlyphImageForIndex</a> (Uint32 glyph_index, <a class="el" href="group__CategorySDLTTF.html#ga98bfeba14cf51c2601ce84f001e074b8">ImageType</a> *image_type) const</td></tr>
<tr class="memdesc:afadfd7295678f3310b853aa798ef7d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pixel image for a character index.  <br /></td></tr>
<tr class="separator:afadfd7295678f3310b853aa798ef7d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224d04c892730c4b669a35e311e494ee" id="r_a224d04c892730c4b669a35e311e494ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a224d04c892730c4b669a35e311e494ee">GetGlyphMetrics</a> (Uint32 ch, int *minx, int *maxx, int *miny, int *maxy, int *advance) const</td></tr>
<tr class="memdesc:a224d04c892730c4b669a35e311e494ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the metrics (dimensions) of a font's glyph for a UNICODE codepoint.  <br /></td></tr>
<tr class="separator:a224d04c892730c4b669a35e311e494ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8701775116ecbc9ed7fc733551e32fc8" id="r_a8701775116ecbc9ed7fc733551e32fc8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a8701775116ecbc9ed7fc733551e32fc8">GetGlyphKerning</a> (Uint32 previous_ch, Uint32 ch) const</td></tr>
<tr class="memdesc:a8701775116ecbc9ed7fc733551e32fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the kerning size between the glyphs of two UNICODE codepoints.  <br /></td></tr>
<tr class="separator:a8701775116ecbc9ed7fc733551e32fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0102cc99e89d8cc94f4b0d88eaf6dc4f" id="r_a0102cc99e89d8cc94f4b0d88eaf6dc4f"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structSDL_1_1Point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a0102cc99e89d8cc94f4b0d88eaf6dc4f">GetStringSize</a> (std::string_view text) const</td></tr>
<tr class="memdesc:a0102cc99e89d8cc94f4b0d88eaf6dc4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the dimensions of a rendered string of UTF-8 text.  <br /></td></tr>
<tr class="separator:a0102cc99e89d8cc94f4b0d88eaf6dc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1515e8776e443fd401865ebf90868d53" id="r_a1515e8776e443fd401865ebf90868d53"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a1515e8776e443fd401865ebf90868d53">GetStringSize</a> (std::string_view text, int *w, int *h) const</td></tr>
<tr class="memdesc:a1515e8776e443fd401865ebf90868d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the dimensions of a rendered string of UTF-8 text.  <br /></td></tr>
<tr class="separator:a1515e8776e443fd401865ebf90868d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ec68d51dc3c736801d2abe14c14167" id="r_a00ec68d51dc3c736801d2abe14c14167"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structSDL_1_1Point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a00ec68d51dc3c736801d2abe14c14167">GetStringSizeWrapped</a> (std::string_view text, int wrap_width) const</td></tr>
<tr class="memdesc:a00ec68d51dc3c736801d2abe14c14167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the dimensions of a rendered string of UTF-8 text.  <br /></td></tr>
<tr class="separator:a00ec68d51dc3c736801d2abe14c14167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66583e48d3ffef083e137b2c365b0d2b" id="r_a66583e48d3ffef083e137b2c365b0d2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a66583e48d3ffef083e137b2c365b0d2b">GetStringSizeWrapped</a> (std::string_view text, int wrap_width, int *w, int *h) const</td></tr>
<tr class="memdesc:a66583e48d3ffef083e137b2c365b0d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the dimensions of a rendered string of UTF-8 text.  <br /></td></tr>
<tr class="separator:a66583e48d3ffef083e137b2c365b0d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dac156c7012dc40c22bd9db59d8d7b" id="r_ad4dac156c7012dc40c22bd9db59d8d7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#ad4dac156c7012dc40c22bd9db59d8d7b">MeasureString</a> (std::string_view text, int max_width, int *measured_width, size_t *measured_length) const</td></tr>
<tr class="memdesc:ad4dac156c7012dc40c22bd9db59d8d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate how much of a UTF-8 string will fit in a given width.  <br /></td></tr>
<tr class="separator:ad4dac156c7012dc40c22bd9db59d8d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cc457b4765e888383da7e6b6b2d048" id="r_a13cc457b4765e888383da7e6b6b2d048"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a13cc457b4765e888383da7e6b6b2d048">RenderText_Solid</a> (std::string_view text, <a class="el" href="structSDL_1_1Color.html">Color</a> fg) const</td></tr>
<tr class="memdesc:a13cc457b4765e888383da7e6b6b2d048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render UTF-8 text at fast quality to a new 8-bit surface.  <br /></td></tr>
<tr class="separator:a13cc457b4765e888383da7e6b6b2d048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca312b387aaa6d12eb53fa8a6f57ee66" id="r_aca312b387aaa6d12eb53fa8a6f57ee66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#aca312b387aaa6d12eb53fa8a6f57ee66">RenderText_Solid_Wrapped</a> (std::string_view text, <a class="el" href="structSDL_1_1Color.html">Color</a> fg, int wrapLength) const</td></tr>
<tr class="memdesc:aca312b387aaa6d12eb53fa8a6f57ee66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render word-wrapped UTF-8 text at fast quality to a new 8-bit surface.  <br /></td></tr>
<tr class="separator:aca312b387aaa6d12eb53fa8a6f57ee66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7068f32b3d72b8175f920b62d5f3743" id="r_ad7068f32b3d72b8175f920b62d5f3743"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#ad7068f32b3d72b8175f920b62d5f3743">RenderGlyph_Solid</a> (Uint32 ch, <a class="el" href="structSDL_1_1Color.html">Color</a> fg) const</td></tr>
<tr class="memdesc:ad7068f32b3d72b8175f920b62d5f3743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a single 32-bit glyph at fast quality to a new 8-bit surface.  <br /></td></tr>
<tr class="separator:ad7068f32b3d72b8175f920b62d5f3743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ca6ad21695d0116e4e35f390b46680" id="r_a33ca6ad21695d0116e4e35f390b46680"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a33ca6ad21695d0116e4e35f390b46680">RenderText_Shaded</a> (std::string_view text, <a class="el" href="structSDL_1_1Color.html">Color</a> fg, <a class="el" href="structSDL_1_1Color.html">Color</a> bg) const</td></tr>
<tr class="memdesc:a33ca6ad21695d0116e4e35f390b46680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render UTF-8 text at high quality to a new 8-bit surface.  <br /></td></tr>
<tr class="separator:a33ca6ad21695d0116e4e35f390b46680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63217313efb3dea3873aee50e0410ce" id="r_ab63217313efb3dea3873aee50e0410ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#ab63217313efb3dea3873aee50e0410ce">RenderText_Shaded_Wrapped</a> (std::string_view text, <a class="el" href="structSDL_1_1Color.html">Color</a> fg, <a class="el" href="structSDL_1_1Color.html">Color</a> bg, int wrap_width) const</td></tr>
<tr class="memdesc:ab63217313efb3dea3873aee50e0410ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render word-wrapped UTF-8 text at high quality to a new 8-bit surface.  <br /></td></tr>
<tr class="separator:ab63217313efb3dea3873aee50e0410ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17247d4c0e58045e424fd71fc174a92" id="r_ae17247d4c0e58045e424fd71fc174a92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#ae17247d4c0e58045e424fd71fc174a92">RenderGlyph_Shaded</a> (Uint32 ch, <a class="el" href="structSDL_1_1Color.html">Color</a> fg, <a class="el" href="structSDL_1_1Color.html">Color</a> bg) const</td></tr>
<tr class="memdesc:ae17247d4c0e58045e424fd71fc174a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a single UNICODE codepoint at high quality to a new 8-bit surface.  <br /></td></tr>
<tr class="separator:ae17247d4c0e58045e424fd71fc174a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89bffb959f8faeec9aba4cfe6589d9fa" id="r_a89bffb959f8faeec9aba4cfe6589d9fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a89bffb959f8faeec9aba4cfe6589d9fa">RenderText_Blended</a> (std::string_view text, <a class="el" href="structSDL_1_1Color.html">Color</a> fg) const</td></tr>
<tr class="memdesc:a89bffb959f8faeec9aba4cfe6589d9fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render UTF-8 text at high quality to a new ARGB surface.  <br /></td></tr>
<tr class="separator:a89bffb959f8faeec9aba4cfe6589d9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1946fec06d73cc61b48bb218db40393" id="r_ae1946fec06d73cc61b48bb218db40393"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#ae1946fec06d73cc61b48bb218db40393">RenderText_Blended_Wrapped</a> (std::string_view text, <a class="el" href="structSDL_1_1Color.html">Color</a> fg, int wrap_width) const</td></tr>
<tr class="memdesc:ae1946fec06d73cc61b48bb218db40393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render word-wrapped UTF-8 text at high quality to a new ARGB surface.  <br /></td></tr>
<tr class="separator:ae1946fec06d73cc61b48bb218db40393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba325dae54902d5deb0fea09a318000" id="r_aeba325dae54902d5deb0fea09a318000"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#aeba325dae54902d5deb0fea09a318000">RenderGlyph_Blended</a> (Uint32 ch, <a class="el" href="structSDL_1_1Color.html">Color</a> fg) const</td></tr>
<tr class="memdesc:aeba325dae54902d5deb0fea09a318000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a single UNICODE codepoint at high quality to a new ARGB surface.  <br /></td></tr>
<tr class="separator:aeba325dae54902d5deb0fea09a318000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83de87f263c6e3204553a09247d4db22" id="r_a83de87f263c6e3204553a09247d4db22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a83de87f263c6e3204553a09247d4db22">RenderText_LCD</a> (std::string_view text, <a class="el" href="structSDL_1_1Color.html">Color</a> fg, <a class="el" href="structSDL_1_1Color.html">Color</a> bg) const</td></tr>
<tr class="memdesc:a83de87f263c6e3204553a09247d4db22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render UTF-8 text at LCD subpixel quality to a new ARGB surface.  <br /></td></tr>
<tr class="separator:a83de87f263c6e3204553a09247d4db22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993e747f13b6432879052c6e0e0b5c63" id="r_a993e747f13b6432879052c6e0e0b5c63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a993e747f13b6432879052c6e0e0b5c63">RenderText_LCD_Wrapped</a> (std::string_view text, <a class="el" href="structSDL_1_1Color.html">Color</a> fg, <a class="el" href="structSDL_1_1Color.html">Color</a> bg, int wrap_width) const</td></tr>
<tr class="memdesc:a993e747f13b6432879052c6e0e0b5c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render word-wrapped UTF-8 text at LCD subpixel quality to a new ARGB surface.  <br /></td></tr>
<tr class="separator:a993e747f13b6432879052c6e0e0b5c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d07514db16bbd63005f3d77dc4f4cf" id="r_ad9d07514db16bbd63005f3d77dc4f4cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#ad9d07514db16bbd63005f3d77dc4f4cf">RenderGlyph_LCD</a> (Uint32 ch, <a class="el" href="structSDL_1_1Color.html">Color</a> fg, <a class="el" href="structSDL_1_1Color.html">Color</a> bg) const</td></tr>
<tr class="memdesc:ad9d07514db16bbd63005f3d77dc4f4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a single UNICODE codepoint at LCD subpixel quality to a new ARGB surface.  <br /></td></tr>
<tr class="separator:ad9d07514db16bbd63005f3d77dc4f4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b695d2e810438ea6e60e61d7c25816" id="r_a19b695d2e810438ea6e60e61d7c25816"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1FontBase.html#a19b695d2e810438ea6e60e61d7c25816">Close</a> ()</td></tr>
<tr class="memdesc:a19b695d2e810438ea6e60e61d7c25816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispose of a previously-created font.  <br /></td></tr>
<tr class="separator:a19b695d2e810438ea6e60e61d7c25816"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt;<br />
struct SDL::FontBase&lt; T &gt;</div><dl class="section user"><dt>Category:</dt><dd><a class="el" href="resource.html">Resource</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad2088904970ac90520ff83ea4ccdb90b" name="ad2088904970ac90520ff83ea4ccdb90b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2088904970ac90520ff83ea4ccdb90b">&#9670;&#160;</a></span>FontBase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::FontBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ptsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Some .fon fonts will have several sizes embedded in the file, so the point size becomes the index of choosing which size. If the value is too high, the last indexed size will be the default.</p>
<p>When done with the returned TTF_Font, use TTF_CloseFont() to dispose of it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>path to font file. </td></tr>
    <tr><td class="paramname">ptsize</td><td>point size to use for the newly-opened font. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>a valid TTF_Font, or NULL on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_CloseFont </dd></dl>

</div>
</div>
<a id="a93cc919ac1c08b1881eada50c6e46231" name="a93cc919ac1c08b1881eada50c6e46231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93cc919ac1c08b1881eada50c6e46231">&#9670;&#160;</a></span>FontBase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::FontBase </td>
          <td>(</td>
          <td class="paramtype">ObjectBox&lt; SDL_IOStream &gt; auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>closeio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ptsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Some .fon fonts will have several sizes embedded in the file, so the point size becomes the index of choosing which size. If the value is too high, the last indexed size will be the default.</p>
<p>If <code>closeio</code> is true, <code>src</code> will be automatically closed once the font is closed. Otherwise you should close <code>src</code> yourself after closing the font.</p>
<p>When done with the returned TTF_Font, use TTF_CloseFont() to dispose of it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>an SDL_IOStream to provide a font file's data. </td></tr>
    <tr><td class="paramname">closeio</td><td>true to close <code>src</code> when the font is closed, false to leave it open. </td></tr>
    <tr><td class="paramname">ptsize</td><td>point size to use for the newly-opened font. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>a valid TTF_Font, or NULL on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_CloseFont </dd></dl>

</div>
</div>
<a id="a56fc7a185c7627c348272ac3125730e4" name="a56fc7a185c7627c348272ac3125730e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56fc7a185c7627c348272ac3125730e4">&#9670;&#160;</a></span>FontBase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::FontBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryProperties.html#gaa5faab1a5ca99f759b68b5800ab0697f">PropertiesRef</a>&#160;</td>
          <td class="paramname"><em>props</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>These are the supported properties:</p>
<ul>
<li><code>TTF_PROP_FONT_CREATE_FILENAME_STRING</code>: the font file to open, if an SDL_IOStream isn't being used. This is required if <code>TTF_PROP_FONT_CREATE_IOSTREAM_POINTER</code> and <code>TTF_PROP_FONT_CREATE_EXISTING_FONT</code> aren't set.</li>
<li><code>TTF_PROP_FONT_CREATE_IOSTREAM_POINTER</code>: an SDL_IOStream containing the font to be opened. This should not be closed until the font is closed. This is required if <code>TTF_PROP_FONT_CREATE_FILENAME_STRING</code> and <code>TTF_PROP_FONT_CREATE_EXISTING_FONT</code> aren't set.</li>
<li><code>TTF_PROP_FONT_CREATE_IOSTREAM_OFFSET_NUMBER</code>: the offset in the iostream for the beginning of the font, defaults to 0.</li>
<li><code>TTF_PROP_FONT_CREATE_IOSTREAM_AUTOCLOSE_BOOLEAN</code>: true if closing the font should also close the associated SDL_IOStream.</li>
<li><code>TTF_PROP_FONT_CREATE_SIZE_FLOAT</code>: the point size of the font. Some .fon fonts will have several sizes embedded in the file, so the point size becomes the index of choosing which size. If the value is too high, the last indexed size will be the default.</li>
<li><code>TTF_PROP_FONT_CREATE_FACE_NUMBER</code>: the face index of the font, if the font contains multiple font faces.</li>
<li><code>TTF_PROP_FONT_CREATE_HORIZONTAL_DPI_NUMBER</code>: the horizontal DPI to use for font rendering, defaults to <code>TTF_PROP_FONT_CREATE_VERTICAL_DPI_NUMBER</code> if set, or 72 otherwise.</li>
<li><code>TTF_PROP_FONT_CREATE_VERTICAL_DPI_NUMBER</code>: the vertical DPI to use for font rendering, defaults to <code>TTF_PROP_FONT_CREATE_HORIZONTAL_DPI_NUMBER</code> if set, or 72 otherwise.</li>
<li><code>TTF_PROP_FONT_CREATE_EXISTING_FONT</code>: an optional TTF_Font that, if set, will be used as the font data source and the initial size and style of the new font.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">props</td><td>the properties to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>a valid TTF_Font, or NULL on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_CloseFont </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8bf535beaea74350ae40af88fa25e7c5" name="a8bf535beaea74350ae40af88fa25e7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf535beaea74350ae40af88fa25e7c5">&#9670;&#160;</a></span>AddFallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::AddFallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategorySDLTTF.html#ga4b737abba8bfc633457b3ec919a79960">FontRef</a>&#160;</td>
          <td class="paramname"><em>fallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a font that will be used for glyphs that are not in the current font. The fallback font should have the same size and style as the current font.</p>
<p>If there are multiple fallback fonts, they are used in the order added.</p>
<p>This updates any TTF_Text objects using this font.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fallback</td><td>the font to add as a fallback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created both fonts.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_ClearFallbackFonts </dd>
<dd>
TTF_RemoveFallbackFont </dd></dl>

</div>
</div>
<a id="ae84d5a8b851688b3cd8212ac61f024f6" name="ae84d5a8b851688b3cd8212ac61f024f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84d5a8b851688b3cd8212ac61f024f6">&#9670;&#160;</a></span>ClearFallbacks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::ClearFallbacks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This updates any TTF_Text objects using this font.</p>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_AddFallbackFont </dd>
<dd>
TTF_RemoveFallbackFont </dd></dl>

</div>
</div>
<a id="a19b695d2e810438ea6e60e61d7c25816" name="a19b695d2e810438ea6e60e61d7c25816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b695d2e810438ea6e60e61d7c25816">&#9670;&#160;</a></span>Close()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::Close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call this when done with a font. This function will free any resources associated with it. It is safe to call this function on NULL, for example on the result of a failed call to TTF_OpenFont().</p>
<p>The font is not valid after being passed to this function. String pointers from functions that return information on this font, such as TTF_GetFontFamilyName() and TTF_GetFontStyleName(), are no longer valid after this call, as well.</p>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should not be called while any other thread is using the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_OpenFont </dd>
<dd>
TTF_OpenFontIO </dd></dl>

</div>
</div>
<a id="a819312530ea776a22fc669197b145fbd" name="a819312530ea776a22fc669197b145fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819312530ea776a22fc669197b145fbd">&#9670;&#160;</a></span>Copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategorySDLTTF.html#ga4dd382dc093e6f59f96c32663e22a20e">Font</a> <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::Copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will be distinct from the original, but will share the font file and have the same size and style as the original.</p>
<p>When done with the returned TTF_Font, use TTF_CloseFont() to dispose of it.</p>
<dl class="section return"><dt>Returns</dt><dd>a valid TTF_Font, or NULL on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the original font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_CloseFont </dd></dl>

</div>
</div>
<a id="aa99719ed076eb56969cf1720231d73cc" name="aa99719ed076eb56969cf1720231d73cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99719ed076eb56969cf1720231d73cc">&#9670;&#160;</a></span>GetAscent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetAscent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a positive value, relative to the baseline.</p>
<dl class="section return"><dt>Returns</dt><dd>the font's ascent.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0. </dd></dl>

</div>
</div>
<a id="ac23d0568d5a230faf6fc8ede31f61c4c" name="ac23d0568d5a230faf6fc8ede31f61c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23d0568d5a230faf6fc8ede31f61c4c">&#9670;&#160;</a></span>GetDescent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetDescent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a negative value, relative to the baseline.</p>
<dl class="section return"><dt>Returns</dt><dd>the font's descent.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0. </dd></dl>

</div>
</div>
<a id="a7972327fc038ac1f6b158e690c9bcc38" name="a7972327fc038ac1f6b158e690c9bcc38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7972327fc038ac1f6b158e690c9bcc38">&#9670;&#160;</a></span>GetDirection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategorySDLTTF.html#gaf7bd9c3d8e546a09ac49f2f82eb16f3a">Direction</a> <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetDirection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This defaults to TTF_DIRECTION_INVALID if it hasn't been set.</p>
<dl class="section return"><dt>Returns</dt><dd>the direction to be used for text shaping.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0. </dd></dl>

</div>
</div>
<a id="abd02829532f228912d6cf8165f7ec9a1" name="abd02829532f228912d6cf8165f7ec9a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd02829532f228912d6cf8165f7ec9a1">&#9670;&#160;</a></span>GetDPI()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetDPI </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>hdpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>vdpi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hdpi</td><td>a pointer filled in with the target horizontal DPI. </td></tr>
    <tr><td class="paramname">vdpi</td><td>a pointer filled in with the target vertical DPI. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_SetFontSizeDPI </dd></dl>

</div>
</div>
<a id="af6d20993bead27d3a587050ed3953c68" name="af6d20993bead27d3a587050ed3953c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d20993bead27d3a587050ed3953c68">&#9670;&#160;</a></span>GetFamilyName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetFamilyName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This string is dictated by the contents of the font file.</p>
<p>Note that the returned string is to internal storage, and should not be modified or free'd by the caller. The string becomes invalid, with the rest of the font, when <code>font</code> is handed to TTF_CloseFont().</p>
<dl class="section return"><dt>Returns</dt><dd>the font's family name.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0. </dd></dl>

</div>
</div>
<a id="ab3487fb44b86ebb96089f1d0a3f70d58" name="ab3487fb44b86ebb96089f1d0a3f70d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3487fb44b86ebb96089f1d0a3f70d58">&#9670;&#160;</a></span>GetGeneration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetGeneration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The generation is incremented each time font properties change that require rebuilding glyphs, such as style, size, etc.</p>
<dl class="section return"><dt>Returns</dt><dd>the font generation or 0 on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0. </dd></dl>

</div>
</div>
<a id="a0d714538aa12047a88f7f70c978721d4" name="a0d714538aa12047a88f7f70c978721d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d714538aa12047a88f7f70c978721d4">&#9670;&#160;</a></span>GetGlyphImage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategorySurface.html#ga2ea8e6016ec594c51738ef06f469d5d2">SurfaceRef</a> <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetGlyphImage </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategorySDLTTF.html#ga98bfeba14cf51c2601ce84f001e074b8">ImageType</a> *&#160;</td>
          <td class="paramname"><em>image_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>the codepoint to check. </td></tr>
    <tr><td class="paramname">image_type</td><td>a pointer filled in with the glyph image type, may be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an SDL_Surface containing the glyph, or NULL on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0. </dd></dl>

</div>
</div>
<a id="afadfd7295678f3310b853aa798ef7d03" name="afadfd7295678f3310b853aa798ef7d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afadfd7295678f3310b853aa798ef7d03">&#9670;&#160;</a></span>GetGlyphImageForIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategorySurface.html#ga2ea8e6016ec594c51738ef06f469d5d2">SurfaceRef</a> <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetGlyphImageForIndex </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>glyph_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategorySDLTTF.html#ga98bfeba14cf51c2601ce84f001e074b8">ImageType</a> *&#160;</td>
          <td class="paramname"><em>image_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is useful for text engine implementations, which can call this with the <code>glyph_index</code> in a TTF_CopyOperation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glyph_index</td><td>the index of the glyph to return. </td></tr>
    <tr><td class="paramname">image_type</td><td>a pointer filled in with the glyph image type, may be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an SDL_Surface containing the glyph, or NULL on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0. </dd></dl>

</div>
</div>
<a id="a8701775116ecbc9ed7fc733551e32fc8" name="a8701775116ecbc9ed7fc733551e32fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8701775116ecbc9ed7fc733551e32fc8">&#9670;&#160;</a></span>GetGlyphKerning()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; int &gt; <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetGlyphKerning </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>previous_ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">previous_ch</td><td>the previous codepoint. </td></tr>
    <tr><td class="paramname">ch</td><td>the current codepoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the kerning size between the two glyphs, in pixels, on success or false on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0. </dd></dl>

</div>
</div>
<a id="a224d04c892730c4b669a35e311e494ee" name="a224d04c892730c4b669a35e311e494ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224d04c892730c4b669a35e311e494ee">&#9670;&#160;</a></span>GetGlyphMetrics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetGlyphMetrics </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>minx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>maxx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>miny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>maxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>advance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To understand what these metrics mean, here is a useful link:</p>
<p><a href="https://freetype.sourceforge.net/freetype2/docs/tutorial/step2.html">https://freetype.sourceforge.net/freetype2/docs/tutorial/step2.html</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>the codepoint to check. </td></tr>
    <tr><td class="paramname">minx</td><td>a pointer filled in with the minimum x coordinate of the glyph from the left edge of its bounding box. This value may be negative. </td></tr>
    <tr><td class="paramname">maxx</td><td>a pointer filled in with the maximum x coordinate of the glyph from the left edge of its bounding box. </td></tr>
    <tr><td class="paramname">miny</td><td>a pointer filled in with the minimum y coordinate of the glyph from the bottom edge of its bounding box. This value may be negative. </td></tr>
    <tr><td class="paramname">maxy</td><td>a pointer filled in with the maximum y coordinate of the glyph from the bottom edge of its bounding box. </td></tr>
    <tr><td class="paramname">advance</td><td>a pointer filled in with the distance to the next glyph from the left edge of this glyph's bounding box. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0. </dd></dl>

</div>
</div>
<a id="ae4c3dc2621dc2811a284348680b20f24" name="ae4c3dc2621dc2811a284348680b20f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c3dc2621dc2811a284348680b20f24">&#9670;&#160;</a></span>GetGlyphScript()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetGlyphScript </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>the character code to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a href="https://unicode.org/iso15924/iso15924-codes.html">ISO 15924 code</a> on success, or 0 on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is thread-safe.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_TagToString </dd></dl>

</div>
</div>
<a id="a9e16117574e0c686791f04c6f1d351b5" name="a9e16117574e0c686791f04c6f1d351b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e16117574e0c686791f04c6f1d351b5">&#9670;&#160;</a></span>GetHeight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is usually equal to point size.</p>
<dl class="section return"><dt>Returns</dt><dd>the font's height.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0. </dd></dl>

</div>
</div>
<a id="ae0f0651f48d48b66dbf1ceddb782907a" name="ae0f0651f48d48b66dbf1ceddb782907a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f0651f48d48b66dbf1ceddb782907a">&#9670;&#160;</a></span>GetHinting()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategorySDLTTF.html#ga45c17da1112591a8709c37afb95e7dba">HintingFlags</a> <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetHinting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The hinter setting is a single value:</p>
<ul>
<li><code>TTF_HINTING_NORMAL</code></li>
<li><code>TTF_HINTING_LIGHT</code></li>
<li><code>TTF_HINTING_MONO</code></li>
<li><code>TTF_HINTING_NONE</code></li>
<li><code>TTF_HINTING_LIGHT_SUBPIXEL</code> (available in SDL_ttf 3.0.0 and later)</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the font's current hinter value.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_SetFontHinting </dd></dl>

</div>
</div>
<a id="ab58d72963452d55d114245518893fc00" name="ab58d72963452d55d114245518893fc00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58d72963452d55d114245518893fc00">&#9670;&#160;</a></span>GetKerning()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetKerning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if kerning is enabled, false otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_SetFontKerning </dd></dl>

</div>
</div>
<a id="a2f7415a14e6873a2fd6583918d85d48d" name="a2f7415a14e6873a2fd6583918d85d48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7415a14e6873a2fd6583918d85d48d">&#9670;&#160;</a></span>GetLineSkip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetLineSkip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the font's recommended spacing.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_SetFontLineSkip </dd></dl>

</div>
</div>
<a id="a5da82317f4a09159691b9cf125b9af13" name="a5da82317f4a09159691b9cf125b9af13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da82317f4a09159691b9cf125b9af13">&#9670;&#160;</a></span>GetNumFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetNumFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of FreeType font faces.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0. </dd></dl>

</div>
</div>
<a id="aefe88cb55536775b9e6faa6ffbfa92b3" name="aefe88cb55536775b9e6faa6ffbfa92b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe88cb55536775b9e6faa6ffbfa92b3">&#9670;&#160;</a></span>GetOutline()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetOutline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the font's current outline value.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_SetFontOutline </dd></dl>

</div>
</div>
<a id="ade426080265efb4938d524b23848ba0b" name="ade426080265efb4938d524b23848ba0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade426080265efb4938d524b23848ba0b">&#9670;&#160;</a></span>GetProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategoryProperties.html#gaa5faab1a5ca99f759b68b5800ab0697f">PropertiesRef</a> <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The following read-write properties are provided by <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a>:</p>
<ul>
<li><code>TTF_PROP_FONT_OUTLINE_LINE_CAP_NUMBER</code>: The FT_Stroker_LineCap value used when setting the font outline, defaults to <code>FT_STROKER_LINECAP_ROUND</code>.</li>
<li><code>TTF_PROP_FONT_OUTLINE_LINE_JOIN_NUMBER</code>: The FT_Stroker_LineJoin value used when setting the font outline, defaults to <code>FT_STROKER_LINEJOIN_ROUND</code>.</li>
<li><code>TTF_PROP_FONT_OUTLINE_MITER_LIMIT_NUMBER</code>: The FT_Fixed miter limit used when setting the font outline, defaults to 0.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a valid property ID on success or 0 on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0. </dd></dl>

</div>
</div>
<a id="ae8b77ff49c7d58ed91ce6ca8ce146a44" name="ae8b77ff49c7d58ed91ce6ca8ce146a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b77ff49c7d58ed91ce6ca8ce146a44">&#9670;&#160;</a></span>GetScript()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetScript </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an <a href="https://unicode.org/iso15924/iso15924-codes.html">ISO 15924 code</a> or 0 if a script hasn't been set.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_TagToString </dd></dl>

</div>
</div>
<a id="a8a0ec19df003e99bd8e1a506fef298a1" name="a8a0ec19df003e99bd8e1a506fef298a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0ec19df003e99bd8e1a506fef298a1">&#9670;&#160;</a></span>GetSDF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetSDF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if enabled, false otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_SetFontSDF </dd></dl>

</div>
</div>
<a id="ad9480df190e9508df2bab37e9ec4db24" name="ad9480df190e9508df2bab37e9ec4db24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9480df190e9508df2bab37e9ec4db24">&#9670;&#160;</a></span>GetSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the size of the font, or 0.0f on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_SetFontSize </dd>
<dd>
TTF_SetFontSizeDPI </dd></dl>

</div>
</div>
<a id="a0102cc99e89d8cc94f4b0d88eaf6dc4f" name="a0102cc99e89d8cc94f4b0d88eaf6dc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0102cc99e89d8cc94f4b0d88eaf6dc4f">&#9670;&#160;</a></span>GetStringSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structSDL_1_1Point.html">Point</a> &gt; <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetStringSize </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will report the width and height, in pixels, of the space that the specified string will take to fully render.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>text to calculate, in UTF-8 encoding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return a <a class="el" href="structSDL_1_1Point.html" title="The structure that defines a point (using integers)">Point</a> with the width, height on success or std::nullopt on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0. </dd></dl>

</div>
</div>
<a id="a1515e8776e443fd401865ebf90868d53" name="a1515e8776e443fd401865ebf90868d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1515e8776e443fd401865ebf90868d53">&#9670;&#160;</a></span>GetStringSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetStringSize </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will report the width and height, in pixels, of the space that the specified string will take to fully render.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>text to calculate, in UTF-8 encoding. </td></tr>
    <tr><td class="paramname">w</td><td>will be filled with width, in pixels, on return. </td></tr>
    <tr><td class="paramname">h</td><td>will be filled with height, in pixels, on return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0. </dd></dl>

</div>
</div>
<a id="a00ec68d51dc3c736801d2abe14c14167" name="a00ec68d51dc3c736801d2abe14c14167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ec68d51dc3c736801d2abe14c14167">&#9670;&#160;</a></span>GetStringSizeWrapped() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structSDL_1_1Point.html">Point</a> &gt; <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetStringSizeWrapped </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wrap_width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will report the width and height, in pixels, of the space that the specified string will take to fully render.</p>
<p>Text is wrapped to multiple lines on line endings and on word boundaries if it extends beyond <code>wrap_width</code> in pixels.</p>
<p>If wrap_width is 0, this function will only wrap on newline characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>text to calculate, in UTF-8 encoding. </td></tr>
    <tr><td class="paramname">wrap_width</td><td>the maximum width or 0 to wrap on newline characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return a <a class="el" href="structSDL_1_1Point.html" title="The structure that defines a point (using integers)">Point</a> with the width, height on success or std::nullopt on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0. </dd></dl>

</div>
</div>
<a id="a66583e48d3ffef083e137b2c365b0d2b" name="a66583e48d3ffef083e137b2c365b0d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66583e48d3ffef083e137b2c365b0d2b">&#9670;&#160;</a></span>GetStringSizeWrapped() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetStringSizeWrapped </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wrap_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will report the width and height, in pixels, of the space that the specified string will take to fully render.</p>
<p>Text is wrapped to multiple lines on line endings and on word boundaries if it extends beyond <code>wrap_width</code> in pixels.</p>
<p>If wrap_width is 0, this function will only wrap on newline characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>text to calculate, in UTF-8 encoding. </td></tr>
    <tr><td class="paramname">wrap_width</td><td>the maximum width or 0 to wrap on newline characters. </td></tr>
    <tr><td class="paramname">w</td><td>will be filled with width, in pixels, on return. </td></tr>
    <tr><td class="paramname">h</td><td>will be filled with height, in pixels, on return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0. </dd></dl>

</div>
</div>
<a id="ae4bfbce1afb092f7663622e4b4c145b0" name="ae4bfbce1afb092f7663622e4b4c145b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4bfbce1afb092f7663622e4b4c145b0">&#9670;&#160;</a></span>GetStyle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategorySDLTTF.html#ga5cd0ae7a98a535d094ec54cefa0076cd">FontStyleFlags</a> <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetStyle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The font styles are a set of bit flags, OR'd together:</p>
<ul>
<li><code>TTF_STYLE_NORMAL</code> (is zero)</li>
<li><code>TTF_STYLE_BOLD</code></li>
<li><code>TTF_STYLE_ITALIC</code></li>
<li><code>TTF_STYLE_UNDERLINE</code></li>
<li><code>TTF_STYLE_STRIKETHROUGH</code></li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the current font style, as a set of bit flags.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_SetFontStyle </dd></dl>

</div>
</div>
<a id="ac48cb765e8d843b285d6fd20cf231525" name="ac48cb765e8d843b285d6fd20cf231525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48cb765e8d843b285d6fd20cf231525">&#9670;&#160;</a></span>GetStyleName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetStyleName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This string is dictated by the contents of the font file.</p>
<p>Note that the returned string is to internal storage, and should not be modified or free'd by the caller. The string becomes invalid, with the rest of the font, when <code>font</code> is handed to TTF_CloseFont().</p>
<dl class="section return"><dt>Returns</dt><dd>the font's style name.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0. </dd></dl>

</div>
</div>
<a id="a426d7bd38474a70fd58aeee33cf2ea71" name="a426d7bd38474a70fd58aeee33cf2ea71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426d7bd38474a70fd58aeee33cf2ea71">&#9670;&#160;</a></span>GetWrapAlignment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategorySDLTTF.html#gad84ec37f41813cbbd941700f70207d1d">HorizontalAlignment</a> <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::GetWrapAlignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the font's current wrap alignment option.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_SetFontWrapAlignment </dd></dl>

</div>
</div>
<a id="aa7425e7615c5e0c011ea8dc1faf0e628" name="aa7425e7615c5e0c011ea8dc1faf0e628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7425e7615c5e0c011ea8dc1faf0e628">&#9670;&#160;</a></span>HasGlyph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::HasGlyph </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>the codepoint to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if font provides a glyph for this character, false if not.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0. </dd></dl>

</div>
</div>
<a id="a160ffc4dc070bc7a41558eaac5aa09fd" name="a160ffc4dc070bc7a41558eaac5aa09fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160ffc4dc070bc7a41558eaac5aa09fd">&#9670;&#160;</a></span>IsFixedWidth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::IsFixedWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A "fixed-width" font means all glyphs are the same width across; a lowercase 'i' will be the same size across as a capital 'W', for example. This is common for terminals and text editors, and other apps that treat text as a grid. Most other things (WYSIWYG word processors, web pages, etc) are more likely to not be fixed-width in most cases.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the font is fixed-width, false otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0. </dd></dl>

</div>
</div>
<a id="aa2154976865a9b4387a3093a6d39b379" name="aa2154976865a9b4387a3093a6d39b379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2154976865a9b4387a3093a6d39b379">&#9670;&#160;</a></span>IsScalable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::IsScalable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalability lets us distinguish between outline and bitmap fonts.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the font is scalable, false otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_SetFontSDF </dd></dl>

</div>
</div>
<a id="ad4dac156c7012dc40c22bd9db59d8d7b" name="ad4dac156c7012dc40c22bd9db59d8d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4dac156c7012dc40c22bd9db59d8d7b">&#9670;&#160;</a></span>MeasureString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::MeasureString </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>measured_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>measured_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This reports the number of characters that can be rendered before reaching <code>max_width</code>.</p>
<p>This does not need to render the string to do this calculation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>text to calculate, in UTF-8 encoding. </td></tr>
    <tr><td class="paramname">max_width</td><td>maximum width, in pixels, available for the string, or 0 for unbounded width. </td></tr>
    <tr><td class="paramname">measured_width</td><td>a pointer filled in with the width, in pixels, of the string that will fit, may be NULL. </td></tr>
    <tr><td class="paramname">measured_length</td><td>a pointer filled in with the length, in bytes, of the string that will fit, may be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0. </dd></dl>

</div>
</div>
<a id="a3f8bd695fb731654a8ee835fe7519bdd" name="a3f8bd695fb731654a8ee835fe7519bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8bd695fb731654a8ee835fe7519bdd">&#9670;&#160;</a></span>RemoveFallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::RemoveFallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategorySDLTTF.html#ga4b737abba8bfc633457b3ec919a79960">FontRef</a>&#160;</td>
          <td class="paramname"><em>fallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This updates any TTF_Text objects using this font.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fallback</td><td>the font to remove as a fallback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created both fonts.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_AddFallbackFont </dd>
<dd>
TTF_ClearFallbackFonts </dd></dl>

</div>
</div>
<a id="aeba325dae54902d5deb0fea09a318000" name="aeba325dae54902d5deb0fea09a318000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba325dae54902d5deb0fea09a318000">&#9670;&#160;</a></span>RenderGlyph_Blended()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a> <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::RenderGlyph_Blended </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>fg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will allocate a new 32-bit, ARGB surface, using alpha blending to dither the font with the given color. This function returns the new surface, or NULL if there was an error.</p>
<p>The glyph is rendered without any padding or centering in the X direction, and aligned normally in the Y direction.</p>
<p>You can render at other quality levels with TTF_RenderGlyph_Solid, TTF_RenderGlyph_Shaded, and TTF_RenderGlyph_LCD.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>the codepoint to render. </td></tr>
    <tr><td class="paramname">fg</td><td>the foreground color for the text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new 32-bit, ARGB surface, or NULL if there was an error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_RenderGlyph_LCD </dd>
<dd>
TTF_RenderGlyph_Shaded </dd>
<dd>
TTF_RenderGlyph_Solid </dd></dl>

</div>
</div>
<a id="ad9d07514db16bbd63005f3d77dc4f4cf" name="ad9d07514db16bbd63005f3d77dc4f4cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d07514db16bbd63005f3d77dc4f4cf">&#9670;&#160;</a></span>RenderGlyph_LCD()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a> <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::RenderGlyph_LCD </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>bg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will allocate a new 32-bit, ARGB surface, and render alpha-blended text using FreeType's LCD subpixel rendering. This function returns the new surface, or NULL if there was an error.</p>
<p>The glyph is rendered without any padding or centering in the X direction, and aligned normally in the Y direction.</p>
<p>You can render at other quality levels with TTF_RenderGlyph_Solid, TTF_RenderGlyph_Shaded, and TTF_RenderGlyph_Blended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>the codepoint to render. </td></tr>
    <tr><td class="paramname">fg</td><td>the foreground color for the text. </td></tr>
    <tr><td class="paramname">bg</td><td>the background color for the text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new 32-bit, ARGB surface, or NULL if there was an error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_RenderGlyph_Blended </dd>
<dd>
TTF_RenderGlyph_Shaded </dd>
<dd>
TTF_RenderGlyph_Solid </dd></dl>

</div>
</div>
<a id="ae17247d4c0e58045e424fd71fc174a92" name="ae17247d4c0e58045e424fd71fc174a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17247d4c0e58045e424fd71fc174a92">&#9670;&#160;</a></span>RenderGlyph_Shaded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a> <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::RenderGlyph_Shaded </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>bg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will allocate a new 8-bit, palettized surface. The surface's 0 pixel will be the specified background color, while other pixels have varying degrees of the foreground color. This function returns the new surface, or NULL if there was an error.</p>
<p>The glyph is rendered without any padding or centering in the X direction, and aligned normally in the Y direction.</p>
<p>You can render at other quality levels with TTF_RenderGlyph_Solid, TTF_RenderGlyph_Blended, and TTF_RenderGlyph_LCD.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>the codepoint to render. </td></tr>
    <tr><td class="paramname">fg</td><td>the foreground color for the text. </td></tr>
    <tr><td class="paramname">bg</td><td>the background color for the text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new 8-bit, palettized surface, or NULL if there was an error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_RenderGlyph_Blended </dd>
<dd>
TTF_RenderGlyph_LCD </dd>
<dd>
TTF_RenderGlyph_Solid </dd></dl>

</div>
</div>
<a id="ad7068f32b3d72b8175f920b62d5f3743" name="ad7068f32b3d72b8175f920b62d5f3743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7068f32b3d72b8175f920b62d5f3743">&#9670;&#160;</a></span>RenderGlyph_Solid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a> <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::RenderGlyph_Solid </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>fg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will allocate a new 8-bit, palettized surface. The surface's 0 pixel will be the colorkey, giving a transparent background. The 1 pixel will be set to the text color.</p>
<p>The glyph is rendered without any padding or centering in the X direction, and aligned normally in the Y direction.</p>
<p>You can render at other quality levels with TTF_RenderGlyph_Shaded, TTF_RenderGlyph_Blended, and TTF_RenderGlyph_LCD.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>the character to render. </td></tr>
    <tr><td class="paramname">fg</td><td>the foreground color for the text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new 8-bit, palettized surface, or NULL if there was an error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_RenderGlyph_Blended </dd>
<dd>
TTF_RenderGlyph_LCD </dd>
<dd>
TTF_RenderGlyph_Shaded </dd></dl>

</div>
</div>
<a id="a89bffb959f8faeec9aba4cfe6589d9fa" name="a89bffb959f8faeec9aba4cfe6589d9fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89bffb959f8faeec9aba4cfe6589d9fa">&#9670;&#160;</a></span>RenderText_Blended()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a> <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::RenderText_Blended </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>fg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will allocate a new 32-bit, ARGB surface, using alpha blending to dither the font with the given color. This function returns the new surface, or NULL if there was an error.</p>
<p>This will not word-wrap the string; you'll get a surface with a single line of text, as long as the string requires. You can use TTF_RenderText_Blended_Wrapped() instead if you need to wrap the output to multiple lines.</p>
<p>This will not wrap on newline characters.</p>
<p>You can render at other quality levels with TTF_RenderText_Solid, TTF_RenderText_Shaded, and TTF_RenderText_LCD.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>text to render, in UTF-8 encoding. </td></tr>
    <tr><td class="paramname">fg</td><td>the foreground color for the text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new 32-bit, ARGB surface, or NULL if there was an error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_RenderText_Blended_Wrapped </dd>
<dd>
TTF_RenderText_LCD </dd>
<dd>
TTF_RenderText_Shaded </dd>
<dd>
TTF_RenderText_Solid </dd></dl>

</div>
</div>
<a id="ae1946fec06d73cc61b48bb218db40393" name="ae1946fec06d73cc61b48bb218db40393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1946fec06d73cc61b48bb218db40393">&#9670;&#160;</a></span>RenderText_Blended_Wrapped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a> <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::RenderText_Blended_Wrapped </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wrap_width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will allocate a new 32-bit, ARGB surface, using alpha blending to dither the font with the given color. This function returns the new surface, or NULL if there was an error.</p>
<p>Text is wrapped to multiple lines on line endings and on word boundaries if it extends beyond <code>wrap_width</code> in pixels.</p>
<p>If wrap_width is 0, this function will only wrap on newline characters.</p>
<p>You can render at other quality levels with TTF_RenderText_Solid_Wrapped, TTF_RenderText_Shaded_Wrapped, and TTF_RenderText_LCD_Wrapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>text to render, in UTF-8 encoding. </td></tr>
    <tr><td class="paramname">fg</td><td>the foreground color for the text. </td></tr>
    <tr><td class="paramname">wrap_width</td><td>the maximum width of the text surface or 0 to wrap on newline characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new 32-bit, ARGB surface, or NULL if there was an error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_RenderText_Blended </dd>
<dd>
TTF_RenderText_LCD_Wrapped </dd>
<dd>
TTF_RenderText_Shaded_Wrapped </dd>
<dd>
TTF_RenderText_Solid_Wrapped </dd></dl>

</div>
</div>
<a id="a83de87f263c6e3204553a09247d4db22" name="a83de87f263c6e3204553a09247d4db22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83de87f263c6e3204553a09247d4db22">&#9670;&#160;</a></span>RenderText_LCD()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a> <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::RenderText_LCD </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>bg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will allocate a new 32-bit, ARGB surface, and render alpha-blended text using FreeType's LCD subpixel rendering. This function returns the new surface, or NULL if there was an error.</p>
<p>This will not word-wrap the string; you'll get a surface with a single line of text, as long as the string requires. You can use TTF_RenderText_LCD_Wrapped() instead if you need to wrap the output to multiple lines.</p>
<p>This will not wrap on newline characters.</p>
<p>You can render at other quality levels with TTF_RenderText_Solid, TTF_RenderText_Shaded, and TTF_RenderText_Blended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>text to render, in UTF-8 encoding. </td></tr>
    <tr><td class="paramname">fg</td><td>the foreground color for the text. </td></tr>
    <tr><td class="paramname">bg</td><td>the background color for the text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new 32-bit, ARGB surface, or NULL if there was an error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_RenderText_Blended </dd>
<dd>
TTF_RenderText_LCD_Wrapped </dd>
<dd>
TTF_RenderText_Shaded </dd>
<dd>
TTF_RenderText_Solid </dd></dl>

</div>
</div>
<a id="a993e747f13b6432879052c6e0e0b5c63" name="a993e747f13b6432879052c6e0e0b5c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a993e747f13b6432879052c6e0e0b5c63">&#9670;&#160;</a></span>RenderText_LCD_Wrapped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a> <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::RenderText_LCD_Wrapped </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>bg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wrap_width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will allocate a new 32-bit, ARGB surface, and render alpha-blended text using FreeType's LCD subpixel rendering. This function returns the new surface, or NULL if there was an error.</p>
<p>Text is wrapped to multiple lines on line endings and on word boundaries if it extends beyond <code>wrap_width</code> in pixels.</p>
<p>If wrap_width is 0, this function will only wrap on newline characters.</p>
<p>You can render at other quality levels with TTF_RenderText_Solid_Wrapped, TTF_RenderText_Shaded_Wrapped, and TTF_RenderText_Blended_Wrapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>text to render, in UTF-8 encoding. </td></tr>
    <tr><td class="paramname">fg</td><td>the foreground color for the text. </td></tr>
    <tr><td class="paramname">bg</td><td>the background color for the text. </td></tr>
    <tr><td class="paramname">wrap_width</td><td>the maximum width of the text surface or 0 to wrap on newline characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new 32-bit, ARGB surface, or NULL if there was an error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_RenderText_Blended_Wrapped </dd>
<dd>
TTF_RenderText_LCD </dd>
<dd>
TTF_RenderText_Shaded_Wrapped </dd>
<dd>
TTF_RenderText_Solid_Wrapped </dd></dl>

</div>
</div>
<a id="a33ca6ad21695d0116e4e35f390b46680" name="a33ca6ad21695d0116e4e35f390b46680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ca6ad21695d0116e4e35f390b46680">&#9670;&#160;</a></span>RenderText_Shaded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a> <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::RenderText_Shaded </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>bg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will allocate a new 8-bit, palettized surface. The surface's 0 pixel will be the specified background color, while other pixels have varying degrees of the foreground color. This function returns the new surface, or NULL if there was an error.</p>
<p>This will not word-wrap the string; you'll get a surface with a single line of text, as long as the string requires. You can use TTF_RenderText_Shaded_Wrapped() instead if you need to wrap the output to multiple lines.</p>
<p>This will not wrap on newline characters.</p>
<p>You can render at other quality levels with TTF_RenderText_Solid, TTF_RenderText_Blended, and TTF_RenderText_LCD.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>text to render, in UTF-8 encoding. </td></tr>
    <tr><td class="paramname">fg</td><td>the foreground color for the text. </td></tr>
    <tr><td class="paramname">bg</td><td>the background color for the text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new 8-bit, palettized surface, or NULL if there was an error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_RenderText_Blended </dd>
<dd>
TTF_RenderText_LCD </dd>
<dd>
TTF_RenderText_Shaded_Wrapped </dd>
<dd>
TTF_RenderText_Solid </dd></dl>

</div>
</div>
<a id="ab63217313efb3dea3873aee50e0410ce" name="ab63217313efb3dea3873aee50e0410ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63217313efb3dea3873aee50e0410ce">&#9670;&#160;</a></span>RenderText_Shaded_Wrapped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a> <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::RenderText_Shaded_Wrapped </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>bg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wrap_width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will allocate a new 8-bit, palettized surface. The surface's 0 pixel will be the specified background color, while other pixels have varying degrees of the foreground color. This function returns the new surface, or NULL if there was an error.</p>
<p>Text is wrapped to multiple lines on line endings and on word boundaries if it extends beyond <code>wrap_width</code> in pixels.</p>
<p>If wrap_width is 0, this function will only wrap on newline characters.</p>
<p>You can render at other quality levels with TTF_RenderText_Solid_Wrapped, TTF_RenderText_Blended_Wrapped, and TTF_RenderText_LCD_Wrapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>text to render, in UTF-8 encoding. </td></tr>
    <tr><td class="paramname">fg</td><td>the foreground color for the text. </td></tr>
    <tr><td class="paramname">bg</td><td>the background color for the text. </td></tr>
    <tr><td class="paramname">wrap_width</td><td>the maximum width of the text surface or 0 to wrap on newline characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new 8-bit, palettized surface, or NULL if there was an error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_RenderText_Blended_Wrapped </dd>
<dd>
TTF_RenderText_LCD_Wrapped </dd>
<dd>
TTF_RenderText_Shaded </dd>
<dd>
TTF_RenderText_Solid_Wrapped </dd></dl>

</div>
</div>
<a id="a13cc457b4765e888383da7e6b6b2d048" name="a13cc457b4765e888383da7e6b6b2d048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13cc457b4765e888383da7e6b6b2d048">&#9670;&#160;</a></span>RenderText_Solid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a> <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::RenderText_Solid </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>fg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will allocate a new 8-bit, palettized surface. The surface's 0 pixel will be the colorkey, giving a transparent background. The 1 pixel will be set to the text color.</p>
<p>This will not word-wrap the string; you'll get a surface with a single line of text, as long as the string requires. You can use TTF_RenderText_Solid_Wrapped() instead if you need to wrap the output to multiple lines.</p>
<p>This will not wrap on newline characters.</p>
<p>You can render at other quality levels with TTF_RenderText_Shaded, TTF_RenderText_Blended, and TTF_RenderText_LCD.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>text to render, in UTF-8 encoding. </td></tr>
    <tr><td class="paramname">fg</td><td>the foreground color for the text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new 8-bit, palettized surface, or NULL if there was an error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_RenderText_Blended </dd>
<dd>
TTF_RenderText_LCD </dd>
<dd>
TTF_RenderText_Shaded </dd>
<dd>
TTF_RenderText_Solid </dd>
<dd>
TTF_RenderText_Solid_Wrapped </dd></dl>

</div>
</div>
<a id="aca312b387aaa6d12eb53fa8a6f57ee66" name="aca312b387aaa6d12eb53fa8a6f57ee66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca312b387aaa6d12eb53fa8a6f57ee66">&#9670;&#160;</a></span>RenderText_Solid_Wrapped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategorySurface.html#ga5128f762b815ce424b759043e06fd646">Surface</a> <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::RenderText_Solid_Wrapped </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wrapLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will allocate a new 8-bit, palettized surface. The surface's 0 pixel will be the colorkey, giving a transparent background. The 1 pixel will be set to the text color.</p>
<p>Text is wrapped to multiple lines on line endings and on word boundaries if it extends beyond <code>wrapLength</code> in pixels.</p>
<p>If wrapLength is 0, this function will only wrap on newline characters.</p>
<p>You can render at other quality levels with TTF_RenderText_Shaded_Wrapped, TTF_RenderText_Blended_Wrapped, and TTF_RenderText_LCD_Wrapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>text to render, in UTF-8 encoding. </td></tr>
    <tr><td class="paramname">fg</td><td>the foreground color for the text. </td></tr>
    <tr><td class="paramname">wrapLength</td><td>the maximum width of the text surface or 0 to wrap on newline characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new 8-bit, palettized surface, or NULL if there was an error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_RenderText_Blended_Wrapped </dd>
<dd>
TTF_RenderText_LCD_Wrapped </dd>
<dd>
TTF_RenderText_Shaded_Wrapped </dd>
<dd>
TTF_RenderText_Solid </dd></dl>

</div>
</div>
<a id="a13aa678e51df5ae076d0734227b6b778" name="a13aa678e51df5ae076d0734227b6b778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13aa678e51df5ae076d0734227b6b778">&#9670;&#160;</a></span>SetDirection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::SetDirection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategorySDLTTF.html#gaf7bd9c3d8e546a09ac49f2f82eb16f3a">Direction</a>&#160;</td>
          <td class="paramname"><em>direction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function only supports left-to-right text shaping if SDL_ttf was not built with HarfBuzz support.</p>
<p>This updates any TTF_Text objects using this font.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>the new direction for text to flow. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0. </dd></dl>

</div>
</div>
<a id="a5d153bcc47420c591096b77db98f4f72" name="a5d153bcc47420c591096b77db98f4f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d153bcc47420c591096b77db98f4f72">&#9670;&#160;</a></span>SetHinting()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::SetHinting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategorySDLTTF.html#ga45c17da1112591a8709c37afb95e7dba">HintingFlags</a>&#160;</td>
          <td class="paramname"><em>hinting</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This updates any TTF_Text objects using this font, and clears already-generated glyphs, if any, from the cache.</p>
<p>The hinter setting is a single value:</p>
<ul>
<li><code>TTF_HINTING_NORMAL</code></li>
<li><code>TTF_HINTING_LIGHT</code></li>
<li><code>TTF_HINTING_MONO</code></li>
<li><code>TTF_HINTING_NONE</code></li>
<li><code>TTF_HINTING_LIGHT_SUBPIXEL</code> (available in SDL_ttf 3.0.0 and later)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hinting</td><td>the new hinter setting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_GetFontHinting </dd></dl>

</div>
</div>
<a id="ab1ec4f02cc3f1d4ab1659d320bd3314f" name="ab1ec4f02cc3f1d4ab1659d320bd3314f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ec4f02cc3f1d4ab1659d320bd3314f">&#9670;&#160;</a></span>SetKerning()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::SetKerning </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Newly-opened fonts default to allowing kerning. This is generally a good policy unless you have a strong reason to disable it, as it tends to produce better rendering (with kerning disabled, some fonts might render the word <code>kerning</code> as something that looks like <code>keming</code> for example).</p>
<p>This updates any TTF_Text objects using this font.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>true to enable kerning, false to disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_GetFontKerning </dd></dl>

</div>
</div>
<a id="a7e9229654b55be73a6ecef726833813b" name="a7e9229654b55be73a6ecef726833813b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9229654b55be73a6ecef726833813b">&#9670;&#160;</a></span>SetLanguage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::SetLanguage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>language_bcp47</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If SDL_ttf was not built with HarfBuzz support, this function returns false.</p>
<p>This updates any TTF_Text objects using this font.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">language_bcp47</td><td>a null-terminated string containing the desired language's BCP47 code. Or null to reset the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0. </dd></dl>

</div>
</div>
<a id="ae8ee8b02794f6341e37720e8c526cb91" name="ae8ee8b02794f6341e37720e8c526cb91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ee8b02794f6341e37720e8c526cb91">&#9670;&#160;</a></span>SetLineSkip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::SetLineSkip </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineskip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This updates any TTF_Text objects using this font.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lineskip</td><td>the new line spacing for the font.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_GetFontLineSkip </dd></dl>

</div>
</div>
<a id="a31061d9e3a626e7dd74b02d5dc153d98" name="a31061d9e3a626e7dd74b02d5dc153d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31061d9e3a626e7dd74b02d5dc153d98">&#9670;&#160;</a></span>SetOutline()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::SetOutline </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This uses the font properties <code>TTF_PROP_FONT_OUTLINE_LINE_CAP_NUMBER</code>, <code>TTF_PROP_FONT_OUTLINE_LINE_JOIN_NUMBER</code>, and <code>TTF_PROP_FONT_OUTLINE_MITER_LIMIT_NUMBER</code> when setting the font outline.</p>
<p>This updates any TTF_Text objects using this font, and clears already-generated glyphs, if any, from the cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outline</td><td>positive outline value, 0 to default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_GetFontOutline </dd></dl>

</div>
</div>
<a id="a1dc4a6b547cfa94aa8c75bc4da38591f" name="a1dc4a6b547cfa94aa8c75bc4da38591f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc4a6b547cfa94aa8c75bc4da38591f">&#9670;&#160;</a></span>SetScript()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::SetScript </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>script</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This returns false if SDL_ttf isn't built with HarfBuzz support.</p>
<p>This updates any TTF_Text objects using this font.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">script</td><td>an <a href="https://unicode.org/iso15924/iso15924-codes.html">ISO 15924 code</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_StringToTag </dd></dl>

</div>
</div>
<a id="ac9e81c295cbe9cab137c6c5f02fb0826" name="ac9e81c295cbe9cab137c6c5f02fb0826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e81c295cbe9cab137c6c5f02fb0826">&#9670;&#160;</a></span>SetSDF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::SetSDF </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>SDF is a technique that helps fonts look sharp even when scaling and rotating, and requires special shader support for display.</p>
<p>This works with Blended APIs, and generates the raw signed distance values in the alpha channel of the resulting texture.</p>
<p>This updates any TTF_Text objects using this font, and clears already-generated glyphs, if any, from the cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>true to enable SDF, false to disable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_GetFontSDF </dd></dl>

</div>
</div>
<a id="a26319f879baf1f9e62a348da82305444" name="a26319f879baf1f9e62a348da82305444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26319f879baf1f9e62a348da82305444">&#9670;&#160;</a></span>SetSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::SetSize </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ptsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This updates any TTF_Text objects using this font, and clears already-generated glyphs, if any, from the cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptsize</td><td>the new point size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_GetFontSize </dd></dl>

</div>
</div>
<a id="aaa90ad4d1035a537b0837bcc45148f83" name="aaa90ad4d1035a537b0837bcc45148f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa90ad4d1035a537b0837bcc45148f83">&#9670;&#160;</a></span>SetSizeDPI()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::SetSizeDPI </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ptsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hdpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vdpi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This updates any TTF_Text objects using this font, and clears already-generated glyphs, if any, from the cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptsize</td><td>the new point size. </td></tr>
    <tr><td class="paramname">hdpi</td><td>the target horizontal DPI. </td></tr>
    <tr><td class="paramname">vdpi</td><td>the target vertical DPI. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_GetFontSize </dd>
<dd>
TTF_GetFontSizeDPI </dd></dl>

</div>
</div>
<a id="a59e686800ddc86a7b1955e83780484ea" name="a59e686800ddc86a7b1955e83780484ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e686800ddc86a7b1955e83780484ea">&#9670;&#160;</a></span>SetStyle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::SetStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategorySDLTTF.html#ga5cd0ae7a98a535d094ec54cefa0076cd">FontStyleFlags</a>&#160;</td>
          <td class="paramname"><em>style</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This updates any TTF_Text objects using this font, and clears already-generated glyphs, if any, from the cache.</p>
<p>The font styles are a set of bit flags, OR'd together:</p>
<ul>
<li><code>TTF_STYLE_NORMAL</code> (is zero)</li>
<li><code>TTF_STYLE_BOLD</code></li>
<li><code>TTF_STYLE_ITALIC</code></li>
<li><code>TTF_STYLE_UNDERLINE</code></li>
<li><code>TTF_STYLE_STRIKETHROUGH</code></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">style</td><td>the new style values to set, OR'd together.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_GetFontStyle </dd></dl>

</div>
</div>
<a id="a104e432e4861f271c0499487cbaddeaf" name="a104e432e4861f271c0499487cbaddeaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104e432e4861f271c0499487cbaddeaf">&#9670;&#160;</a></span>SetWrapAlignment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; TTF_Font * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structSDL_1_1FontBase.html">SDL::FontBase</a>&lt; T &gt;::SetWrapAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategorySDLTTF.html#gad84ec37f41813cbbd941700f70207d1d">HorizontalAlignment</a>&#160;</td>
          <td class="paramname"><em>align</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This updates any TTF_Text objects using this font.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">align</td><td>the new wrap alignment option.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should be called on the thread that created the font.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_ttf 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TTF_GetFontWrapAlignment </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>SDL3pp/<a class="el" href="SDL3pp__ttf_8h_source.html">SDL3pp_ttf.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
