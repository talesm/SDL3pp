<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDL3pp: Audio Playback, Recording, and Mixing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SDL3pp
   </div>
   <div id="projectbrief">A slim C++ wrapper for SDL3</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Audio Playback, Recording, and Mixing<div class="ingroups"><a class="el" href="group__Categories.html">Categories</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Audio functionality for the <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1AudioFormat.html">SDL::AudioFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Audio format.  <a href="classSDL_1_1AudioFormat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1AudioDeviceRef.html">SDL::AudioDeviceRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> Audio Device instance IDs.  <a href="structSDL_1_1AudioDeviceRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1AudioDevice.html">SDL::AudioDevice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to an owned audioDevice.  <a href="structSDL_1_1AudioDevice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1AudioStreamRef.html">SDL::AudioStreamRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The opaque handle that represents an audio stream.  <a href="structSDL_1_1AudioStreamRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1AudioStream.html">SDL::AudioStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to an owned audioStream.  <a href="structSDL_1_1AudioStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1AudioStreamLock.html">SDL::AudioStreamLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks a <a class="el" href="structSDL_1_1AudioStream.html" title="Handle to an owned audioStream.">AudioStream</a>.  <a href="structSDL_1_1AudioStreamLock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gade51417b52dbd9511d56066caae0038b" id="r_gade51417b52dbd9511d56066caae0038b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#gade51417b52dbd9511d56066caae0038b">SDL_AUDIO_MASK_BITSIZE</a>&#160;&#160;&#160;(0xFFu)</td></tr>
<tr class="memdesc:gade51417b52dbd9511d56066caae0038b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask of bits in an AudioFormat that contains the format bit size.  <br /></td></tr>
<tr class="separator:gade51417b52dbd9511d56066caae0038b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca86003b4287870be9525fce5ab2916f" id="r_gaca86003b4287870be9525fce5ab2916f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#gaca86003b4287870be9525fce5ab2916f">SDL_AUDIO_MASK_FLOAT</a>&#160;&#160;&#160;(1u &lt;&lt; 8)</td></tr>
<tr class="memdesc:gaca86003b4287870be9525fce5ab2916f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask of bits in an AudioFormat that contain the floating point flag.  <br /></td></tr>
<tr class="separator:gaca86003b4287870be9525fce5ab2916f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8a794d1f4b7b4b78322b0e40fb781a2" id="r_gaf8a794d1f4b7b4b78322b0e40fb781a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#gaf8a794d1f4b7b4b78322b0e40fb781a2">SDL_AUDIO_MASK_BIG_ENDIAN</a>&#160;&#160;&#160;(1u &lt;&lt; 12)</td></tr>
<tr class="memdesc:gaf8a794d1f4b7b4b78322b0e40fb781a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask of bits in an AudioFormat that contain the bigendian flag.  <br /></td></tr>
<tr class="separator:gaf8a794d1f4b7b4b78322b0e40fb781a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06fc66d3c421c6c9b733854b73d104ce" id="r_ga06fc66d3c421c6c9b733854b73d104ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#ga06fc66d3c421c6c9b733854b73d104ce">SDL_AUDIO_MASK_SIGNED</a>&#160;&#160;&#160;(1u &lt;&lt; 15)</td></tr>
<tr class="memdesc:ga06fc66d3c421c6c9b733854b73d104ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask of bits in an AudioFormat that contain the signed data flag.  <br /></td></tr>
<tr class="separator:ga06fc66d3c421c6c9b733854b73d104ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga278e46a8d2922ad0aa9a58e35bbcb92e" id="r_ga278e46a8d2922ad0aa9a58e35bbcb92e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#ga278e46a8d2922ad0aa9a58e35bbcb92e">SDL::AudioSpec</a> = SDL_AudioSpec</td></tr>
<tr class="memdesc:ga278e46a8d2922ad0aa9a58e35bbcb92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format specifier for audio data.  <br /></td></tr>
<tr class="separator:ga278e46a8d2922ad0aa9a58e35bbcb92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae12773fac83d661b028da1a429d5cf87" id="r_gae12773fac83d661b028da1a429d5cf87"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#gae12773fac83d661b028da1a429d5cf87">SDL::OptionalAudioStream</a> = <a class="el" href="classSDL_1_1OptionalResource.html">OptionalResource</a>&lt; <a class="el" href="structSDL_1_1AudioStreamRef.html">AudioStreamRef</a>, <a class="el" href="structSDL_1_1AudioStream.html">AudioStream</a> &gt;</td></tr>
<tr class="memdesc:gae12773fac83d661b028da1a429d5cf87"><td class="mdescLeft">&#160;</td><td class="mdescRight">A audioStream parameter that might own its value.  <br /></td></tr>
<tr class="separator:gae12773fac83d661b028da1a429d5cf87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e483caf8bcf7944d6f995ad9ab1ffe7" id="r_ga2e483caf8bcf7944d6f995ad9ab1ffe7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#ga2e483caf8bcf7944d6f995ad9ab1ffe7">SDL::AudioPostmixCallback</a> = SDL_AudioPostmixCallback</td></tr>
<tr class="memdesc:ga2e483caf8bcf7944d6f995ad9ab1ffe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback that fires when data is about to be fed to an audio device.  <br /></td></tr>
<tr class="separator:ga2e483caf8bcf7944d6f995ad9ab1ffe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b9847647bcb90afe05f8d5cce8a128e" id="r_ga9b9847647bcb90afe05f8d5cce8a128e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#ga9b9847647bcb90afe05f8d5cce8a128e">SDL::AudioPostmixCB</a> = std::function&lt; void(const <a class="el" href="group__CategoryAudio.html#ga278e46a8d2922ad0aa9a58e35bbcb92e">AudioSpec</a> &amp;spec, std::span&lt; float &gt; buffer)&gt;</td></tr>
<tr class="memdesc:ga9b9847647bcb90afe05f8d5cce8a128e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback that fires when data is about to be fed to an audio device.  <br /></td></tr>
<tr class="separator:ga9b9847647bcb90afe05f8d5cce8a128e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf137bc28b994c19c9e4c214a512a15a1" id="r_gaf137bc28b994c19c9e4c214a512a15a1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#gaf137bc28b994c19c9e4c214a512a15a1">SDL::AudioStreamCallback</a> = SDL_AudioStreamCallback</td></tr>
<tr class="memdesc:gaf137bc28b994c19c9e4c214a512a15a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback that fires when data passes through an <a class="el" href="structSDL_1_1AudioStreamRef.html" title="The opaque handle that represents an audio stream.">AudioStreamRef</a>.  <br /></td></tr>
<tr class="separator:gaf137bc28b994c19c9e4c214a512a15a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e94ca585b8e971289b7bfd6780762cc" id="r_ga7e94ca585b8e971289b7bfd6780762cc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#ga7e94ca585b8e971289b7bfd6780762cc">SDL::AudioStreamCB</a> = std::function&lt; void(<a class="el" href="structSDL_1_1AudioStreamRef.html">AudioStreamRef</a> stream, int additional_amount, int total_amount)&gt;</td></tr>
<tr class="memdesc:ga7e94ca585b8e971289b7bfd6780762cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback that fires when data passes through an <a class="el" href="structSDL_1_1AudioStreamRef.html" title="The opaque handle that represents an audio stream.">AudioStreamRef</a>.  <br /></td></tr>
<tr class="separator:ga7e94ca585b8e971289b7bfd6780762cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafd736bb7a8107101eac9d0ad555460c3" id="r_gafd736bb7a8107101eac9d0ad555460c3"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#gafd736bb7a8107101eac9d0ad555460c3">SDL::AudioFrameSize</a> (const <a class="el" href="group__CategoryAudio.html#ga278e46a8d2922ad0aa9a58e35bbcb92e">AudioSpec</a> &amp;x)</td></tr>
<tr class="memdesc:gafd736bb7a8107101eac9d0ad555460c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the size of each audio frame (in bytes) from an AudioSpec.  <br /></td></tr>
<tr class="separator:gafd736bb7a8107101eac9d0ad555460c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf9859eb75df1d2c15aba976069e165b" id="r_gabf9859eb75df1d2c15aba976069e165b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#gabf9859eb75df1d2c15aba976069e165b">SDL::GetNumAudioDrivers</a> ()</td></tr>
<tr class="memdesc:gabf9859eb75df1d2c15aba976069e165b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to get the number of built-in audio drivers.  <br /></td></tr>
<tr class="separator:gabf9859eb75df1d2c15aba976069e165b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97ae58cdecc93ccd529ee40053b6dec4" id="r_ga97ae58cdecc93ccd529ee40053b6dec4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#ga97ae58cdecc93ccd529ee40053b6dec4">SDL::GetAudioDriver</a> (int index)</td></tr>
<tr class="memdesc:ga97ae58cdecc93ccd529ee40053b6dec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to get the name of a built in audio driver.  <br /></td></tr>
<tr class="separator:ga97ae58cdecc93ccd529ee40053b6dec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fc36d5a1cbcbc60b3822839100a725b" id="r_ga3fc36d5a1cbcbc60b3822839100a725b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#ga3fc36d5a1cbcbc60b3822839100a725b">SDL::GetCurrentAudioDriver</a> ()</td></tr>
<tr class="memdesc:ga3fc36d5a1cbcbc60b3822839100a725b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the current audio driver.  <br /></td></tr>
<tr class="separator:ga3fc36d5a1cbcbc60b3822839100a725b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae01ace687559a15b37b2d43ecd080bc1" id="r_gae01ace687559a15b37b2d43ecd080bc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OwnArray.html">OwnArray</a>&lt; <a class="el" href="structSDL_1_1AudioDeviceRef.html">AudioDeviceRef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#gae01ace687559a15b37b2d43ecd080bc1">SDL::GetAudioPlaybackDevices</a> ()</td></tr>
<tr class="memdesc:gae01ace687559a15b37b2d43ecd080bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of currently-connected audio playback devices.  <br /></td></tr>
<tr class="separator:gae01ace687559a15b37b2d43ecd080bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d9ae95b5f46a3c01191ad9db38b4eeb" id="r_ga8d9ae95b5f46a3c01191ad9db38b4eeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OwnArray.html">OwnArray</a>&lt; <a class="el" href="structSDL_1_1AudioDeviceRef.html">AudioDeviceRef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#ga8d9ae95b5f46a3c01191ad9db38b4eeb">SDL::GetAudioRecordingDevices</a> ()</td></tr>
<tr class="memdesc:ga8d9ae95b5f46a3c01191ad9db38b4eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of currently-connected audio recording devices.  <br /></td></tr>
<tr class="separator:ga8d9ae95b5f46a3c01191ad9db38b4eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0f5f4b1f949b706d57a560190c0cddf" id="r_gac0f5f4b1f949b706d57a560190c0cddf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#gac0f5f4b1f949b706d57a560190c0cddf">SDL::UnbindAudioStreams</a> (std::span&lt; <a class="el" href="structSDL_1_1AudioStreamRef.html">AudioStreamRef</a> &gt; streams)</td></tr>
<tr class="memdesc:gac0f5f4b1f949b706d57a560190c0cddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind a list of audio streams from their audio devices.  <br /></td></tr>
<tr class="separator:gac0f5f4b1f949b706d57a560190c0cddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa86de6f7c358ef5f2ad75c9898423a27" id="r_gaa86de6f7c358ef5f2ad75c9898423a27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OwnArray.html">OwnArray</a>&lt; Uint8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#gaa86de6f7c358ef5f2ad75c9898423a27">SDL::LoadWAV</a> (<a class="el" href="structSDL_1_1IOStreamRef.html">IOStreamRef</a> &amp;src, <a class="el" href="group__CategoryAudio.html#ga278e46a8d2922ad0aa9a58e35bbcb92e">AudioSpec</a> *spec)</td></tr>
<tr class="memdesc:gaa86de6f7c358ef5f2ad75c9898423a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the audio data of a WAVE file into memory.  <br /></td></tr>
<tr class="separator:gaa86de6f7c358ef5f2ad75c9898423a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaff063971ee474fedad66da38c10ec43" id="r_gaaff063971ee474fedad66da38c10ec43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OwnArray.html">OwnArray</a>&lt; Uint8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#gaaff063971ee474fedad66da38c10ec43">SDL::LoadWAV</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> path, <a class="el" href="group__CategoryAudio.html#ga278e46a8d2922ad0aa9a58e35bbcb92e">AudioSpec</a> *spec)</td></tr>
<tr class="memdesc:gaaff063971ee474fedad66da38c10ec43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a WAV from a file path.  <br /></td></tr>
<tr class="separator:gaaff063971ee474fedad66da38c10ec43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa8a066451543172b07d02bf4eff8882" id="r_gaaa8a066451543172b07d02bf4eff8882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#gaaa8a066451543172b07d02bf4eff8882">SDL::MixAudio</a> (Uint8 *dst, <a class="el" href="structSDL_1_1SourceBytes.html">SourceBytes</a> src, <a class="el" href="classSDL_1_1AudioFormat.html">AudioFormat</a> format, float volume)</td></tr>
<tr class="memdesc:gaaa8a066451543172b07d02bf4eff8882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mix audio data in a specified format.  <br /></td></tr>
<tr class="separator:gaaa8a066451543172b07d02bf4eff8882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90ebbeaafbf2f69bbd771abbd5b94f23" id="r_ga90ebbeaafbf2f69bbd771abbd5b94f23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#ga90ebbeaafbf2f69bbd771abbd5b94f23">SDL::MixAudio</a> (<a class="el" href="structSDL_1_1TargetBytes.html">TargetBytes</a> dst, <a class="el" href="structSDL_1_1SourceBytes.html">SourceBytes</a> src, <a class="el" href="classSDL_1_1AudioFormat.html">AudioFormat</a> format, float volume)</td></tr>
<tr class="memdesc:ga90ebbeaafbf2f69bbd771abbd5b94f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mix audio data in a specified format.  <br /></td></tr>
<tr class="separator:ga90ebbeaafbf2f69bbd771abbd5b94f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21787c751aa8f17579f1dca4a1b8b8ff" id="r_ga21787c751aa8f17579f1dca4a1b8b8ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OwnArray.html">OwnArray</a>&lt; Uint8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#ga21787c751aa8f17579f1dca4a1b8b8ff">SDL::ConvertAudioSamples</a> (const <a class="el" href="group__CategoryAudio.html#ga278e46a8d2922ad0aa9a58e35bbcb92e">AudioSpec</a> &amp;src_spec, <a class="el" href="structSDL_1_1SourceBytes.html">SourceBytes</a> src_data, const <a class="el" href="group__CategoryAudio.html#ga278e46a8d2922ad0aa9a58e35bbcb92e">AudioSpec</a> &amp;dst_spec)</td></tr>
<tr class="memdesc:ga21787c751aa8f17579f1dca4a1b8b8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert some audio data of one format to another format.  <br /></td></tr>
<tr class="separator:ga21787c751aa8f17579f1dca4a1b8b8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac900e515ecdc88b660fc1e0c49f3b15b" id="r_gac900e515ecdc88b660fc1e0c49f3b15b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#gac900e515ecdc88b660fc1e0c49f3b15b">SDL::AudioDeviceRef::BindAudioStreams</a> (std::span&lt; <a class="el" href="structSDL_1_1AudioStreamRef.html">AudioStreamRef</a> &gt; streams)</td></tr>
<tr class="memdesc:gac900e515ecdc88b660fc1e0c49f3b15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a list of audio streams to an audio device.  <br /></td></tr>
<tr class="separator:gac900e515ecdc88b660fc1e0c49f3b15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5ad89fcbe1ab761e0e2b2865e358fa7" id="r_gac5ad89fcbe1ab761e0e2b2865e358fa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#gac5ad89fcbe1ab761e0e2b2865e358fa7">SDL::AudioDeviceRef::BindAudioStream</a> (<a class="el" href="structSDL_1_1AudioStreamRef.html">AudioStreamRef</a> &amp;stream)</td></tr>
<tr class="memdesc:gac5ad89fcbe1ab761e0e2b2865e358fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a single audio stream to an audio device.  <br /></td></tr>
<tr class="separator:gac5ad89fcbe1ab761e0e2b2865e358fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5cf7026d0330daa1eec716a321908b0" id="r_gac5cf7026d0330daa1eec716a321908b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSDL_1_1AudioStreamLock.html">AudioStreamLock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#gac5cf7026d0330daa1eec716a321908b0">SDL::AudioStreamRef::Lock</a> ()</td></tr>
<tr class="memdesc:gac5cf7026d0330daa1eec716a321908b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock an audio stream for serialized access.  <br /></td></tr>
<tr class="separator:gac5cf7026d0330daa1eec716a321908b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaff751fbf4be129fabe99a981a64f934f" id="r_gaff751fbf4be129fabe99a981a64f934f"><td class="memItemLeft" align="right" valign="top">constexpr SDL_AudioFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#gaff751fbf4be129fabe99a981a64f934f">SDL::AUDIO_UNKNOWN</a></td></tr>
<tr class="memdesc:gaff751fbf4be129fabe99a981a64f934f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unspecified audio format.  <br /></td></tr>
<tr class="separator:gaff751fbf4be129fabe99a981a64f934f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3b2c39b4c93d9a794685d3b713466e0" id="r_gac3b2c39b4c93d9a794685d3b713466e0"><td class="memItemLeft" align="right" valign="top"><a id="gac3b2c39b4c93d9a794685d3b713466e0" name="gac3b2c39b4c93d9a794685d3b713466e0"></a>
constexpr SDL_AudioFormat&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::AUDIO_U8</b> = SDL_AUDIO_U8</td></tr>
<tr class="memdesc:gac3b2c39b4c93d9a794685d3b713466e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned 8-bit samples. <br /></td></tr>
<tr class="separator:gac3b2c39b4c93d9a794685d3b713466e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec1480b6af5ee4862de889476a01c0ba" id="r_gaec1480b6af5ee4862de889476a01c0ba"><td class="memItemLeft" align="right" valign="top"><a id="gaec1480b6af5ee4862de889476a01c0ba" name="gaec1480b6af5ee4862de889476a01c0ba"></a>
constexpr SDL_AudioFormat&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::AUDIO_S8</b> = SDL_AUDIO_S8</td></tr>
<tr class="memdesc:gaec1480b6af5ee4862de889476a01c0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed 8-bit samples. <br /></td></tr>
<tr class="separator:gaec1480b6af5ee4862de889476a01c0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79231e9846a14b6c28e30e1c2db02f11" id="r_ga79231e9846a14b6c28e30e1c2db02f11"><td class="memItemLeft" align="right" valign="top">constexpr SDL_AudioFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#ga79231e9846a14b6c28e30e1c2db02f11">SDL::AUDIO_S16LE</a></td></tr>
<tr class="memdesc:ga79231e9846a14b6c28e30e1c2db02f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed 16-bit samples.  <br /></td></tr>
<tr class="separator:ga79231e9846a14b6c28e30e1c2db02f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2546f053ac4218ddf4238dd8ec2f44db" id="r_ga2546f053ac4218ddf4238dd8ec2f44db"><td class="memItemLeft" align="right" valign="top">constexpr SDL_AudioFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#ga2546f053ac4218ddf4238dd8ec2f44db">SDL::AUDIO_S16BE</a></td></tr>
<tr class="memdesc:ga2546f053ac4218ddf4238dd8ec2f44db"><td class="mdescLeft">&#160;</td><td class="mdescRight">As above, but big-endian byte order.  <br /></td></tr>
<tr class="separator:ga2546f053ac4218ddf4238dd8ec2f44db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d3b4c9ee67abdfec4ab43d59e3e7b89" id="r_ga4d3b4c9ee67abdfec4ab43d59e3e7b89"><td class="memItemLeft" align="right" valign="top">constexpr SDL_AudioFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#ga4d3b4c9ee67abdfec4ab43d59e3e7b89">SDL::AUDIO_S32LE</a></td></tr>
<tr class="memdesc:ga4d3b4c9ee67abdfec4ab43d59e3e7b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit integer samples  <br /></td></tr>
<tr class="separator:ga4d3b4c9ee67abdfec4ab43d59e3e7b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5295e3b9f425ca7d31f2f186b99c6d34" id="r_ga5295e3b9f425ca7d31f2f186b99c6d34"><td class="memItemLeft" align="right" valign="top">constexpr SDL_AudioFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#ga5295e3b9f425ca7d31f2f186b99c6d34">SDL::AUDIO_S32BE</a></td></tr>
<tr class="memdesc:ga5295e3b9f425ca7d31f2f186b99c6d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">As above, but big-endian byte order.  <br /></td></tr>
<tr class="separator:ga5295e3b9f425ca7d31f2f186b99c6d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab17527facb7753347af62787282ffc46" id="r_gab17527facb7753347af62787282ffc46"><td class="memItemLeft" align="right" valign="top">constexpr SDL_AudioFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#gab17527facb7753347af62787282ffc46">SDL::AUDIO_F32LE</a></td></tr>
<tr class="memdesc:gab17527facb7753347af62787282ffc46"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit floating point samples  <br /></td></tr>
<tr class="separator:gab17527facb7753347af62787282ffc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf40419458b3fb954894648336fbf46d2" id="r_gaf40419458b3fb954894648336fbf46d2"><td class="memItemLeft" align="right" valign="top">constexpr SDL_AudioFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#gaf40419458b3fb954894648336fbf46d2">SDL::AUDIO_F32BE</a></td></tr>
<tr class="memdesc:gaf40419458b3fb954894648336fbf46d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">As above, but big-endian byte order.  <br /></td></tr>
<tr class="separator:gaf40419458b3fb954894648336fbf46d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97d66c8fdc63f7db3a4745e432739477" id="r_ga97d66c8fdc63f7db3a4745e432739477"><td class="memItemLeft" align="right" valign="top"><a id="ga97d66c8fdc63f7db3a4745e432739477" name="ga97d66c8fdc63f7db3a4745e432739477"></a>
constexpr SDL_AudioFormat&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::AUDIO_S16</b> = SDL_AUDIO_S16</td></tr>
<tr class="memdesc:ga97d66c8fdc63f7db3a4745e432739477"><td class="mdescLeft">&#160;</td><td class="mdescRight">AUDIO_S16. <br /></td></tr>
<tr class="separator:ga97d66c8fdc63f7db3a4745e432739477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4f6c492dded5bc2da63d417e618e610" id="r_gac4f6c492dded5bc2da63d417e618e610"><td class="memItemLeft" align="right" valign="top"><a id="gac4f6c492dded5bc2da63d417e618e610" name="gac4f6c492dded5bc2da63d417e618e610"></a>
constexpr SDL_AudioFormat&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::AUDIO_S32</b> = SDL_AUDIO_S32</td></tr>
<tr class="memdesc:gac4f6c492dded5bc2da63d417e618e610"><td class="mdescLeft">&#160;</td><td class="mdescRight">AUDIO_S32. <br /></td></tr>
<tr class="separator:gac4f6c492dded5bc2da63d417e618e610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab009aa117bc632f3a979be98f71c81cb" id="r_gab009aa117bc632f3a979be98f71c81cb"><td class="memItemLeft" align="right" valign="top"><a id="gab009aa117bc632f3a979be98f71c81cb" name="gab009aa117bc632f3a979be98f71c81cb"></a>
constexpr SDL_AudioFormat&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::AUDIO_F32</b> = SDL_AUDIO_F32</td></tr>
<tr class="memdesc:gab009aa117bc632f3a979be98f71c81cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">AUDIO_F32. <br /></td></tr>
<tr class="separator:gab009aa117bc632f3a979be98f71c81cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3480f032a4bbe82de546e36cf1c857f2" id="r_ga3480f032a4bbe82de546e36cf1c857f2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structSDL_1_1AudioDeviceRef.html">AudioDeviceRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#ga3480f032a4bbe82de546e36cf1c857f2">SDL::AUDIO_DEVICE_DEFAULT_PLAYBACK</a></td></tr>
<tr class="memdesc:ga3480f032a4bbe82de546e36cf1c857f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A value used to request a default playback audio device.  <br /></td></tr>
<tr class="separator:ga3480f032a4bbe82de546e36cf1c857f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d825e059fc09f4000a6b6912b0760f1" id="r_ga6d825e059fc09f4000a6b6912b0760f1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structSDL_1_1AudioDeviceRef.html">AudioDeviceRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAudio.html#ga6d825e059fc09f4000a6b6912b0760f1">SDL::AUDIO_DEVICE_DEFAULT_RECORDING</a></td></tr>
<tr class="memdesc:ga6d825e059fc09f4000a6b6912b0760f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A value used to request a default recording audio device.  <br /></td></tr>
<tr class="separator:ga6d825e059fc09f4000a6b6912b0760f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>All audio in SDL3 revolves around <a class="el" href="structSDL_1_1AudioStream.html" title="Handle to an owned audioStream.">AudioStream</a>. Whether you want to play or record audio, convert it, stream it, buffer it, or mix it, you're going to be passing it through an audio stream.</p>
<p>Audio streams are quite flexible; they can accept any amount of data at a time, in any supported format, and output it as needed in any other format, even if the data format changes on either side halfway through.</p>
<p>An app opens an audio device and binds any number of audio streams to it, feeding more data to the streams as available. When the device needs more data, it will pull it from all bound streams and mix them together for playback.</p>
<p>Audio streams can also use an app-provided callback to supply data on-demand, which maps pretty closely to the SDL2 audio model.</p>
<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> also provides a simple .WAV loader in LoadWAV (and LoadWAV if you aren't reading from a file) as a basic means to load sound data into your program.</p>
<h2><a class="anchor" id="logical-audio-devices"></a>
Logical audio devices</h2>
<p>In SDL3, opening a physical device (like a SoundBlaster 16 Pro) gives you a logical device ID that you can bind audio streams to. In almost all cases, logical devices can be used anywhere in the API that a physical device is normally used. However, since each device opening generates a new logical device, different parts of the program (say, a VoIP library, or text-to-speech framework, or maybe some other sort of mixer on top of <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a>) can have their own device opens that do not interfere with each other; each logical device will mix its separate audio down to a single buffer, fed to the physical device, behind the scenes. As many logical devices as you like can come and go; <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> will only have to open the physical device at the OS level once, and will manage all the logical devices on top of it internally.</p>
<p>One other benefit of logical devices: if you don't open a specific physical device, instead opting for the default, <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> can automatically migrate those logical devices to different hardware as circumstances change: a user plugged in headphones? The system default changed? <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> can transparently migrate the logical devices to the correct physical device seamlessly and keep playing; the app doesn't even have to know it happened if it doesn't want to.</p>
<h2><a class="anchor" id="simplified-audio"></a>
Simplified audio</h2>
<p>As a simplified model for when a single source of audio is all that's needed, an app can use <a class="el" href="structSDL_1_1AudioStream.html#a6915820b3df672f7c2f45e8815a6150f" title="Constructs from the underlying resource.">AudioStream.AudioStream</a>, which is a single function to open an audio device, create an audio stream, bind that stream to the newly-opened device, and (optionally) provide a callback for obtaining audio data. When using this function, the primary interface is the <a class="el" href="structSDL_1_1AudioStream.html" title="Handle to an owned audioStream.">AudioStream</a> and the device handle is mostly hidden away; destroying a stream created through this function will also close the device, stream bindings cannot be changed, etc. One other quirk of this is that the device is started in a <em>paused</em> state and must be explicitly resumed; this is partially to offer a clean migration for SDL2 apps and partially because the app might have to do more setup before playback begins; in the non-simplified form, nothing will play until a stream is bound to a device, so they start <em>unpaused</em>.</p>
<h2><a class="anchor" id="channel-layouts"></a>
Channel layouts</h2>
<p>Audio data passing through <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is uncompressed PCM data, interleaved. One can provide their own decompression through an MP3, etc, decoder, but <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> does not provide this directly. Each interleaved channel of data is meant to be in a specific order.</p>
<p>Abbreviations:</p>
<ul>
<li>FRONT = single mono speaker</li>
<li>FL = front left speaker</li>
<li>FR = front right speaker</li>
<li>FC = front center speaker</li>
<li>BL = back left speaker</li>
<li>BR = back right speaker</li>
<li>SR = surround right speaker</li>
<li>SL = surround left speaker</li>
<li>BC = back center speaker</li>
<li>LFE = low-frequency speaker</li>
</ul>
<p>These are listed in the order they are laid out in memory, so "FL, FR" means "the front left speaker is laid out in memory first, then the front
right, then it repeats for the next audio frame".</p>
<ul>
<li>1 channel (mono) layout: FRONT</li>
<li>2 channels (stereo) layout: FL, FR</li>
<li>3 channels (2.1) layout: FL, FR, LFE</li>
<li>4 channels (quad) layout: FL, FR, BL, BR</li>
<li>5 channels (4.1) layout: FL, FR, LFE, BL, BR</li>
<li>6 channels (5.1) layout: FL, FR, FC, LFE, BL, BR (last two can also be SL, SR)</li>
<li>7 channels (6.1) layout: FL, FR, FC, LFE, BC, SL, SR</li>
<li>8 channels (7.1) layout: FL, FR, FC, LFE, BL, BR, SL, SR</li>
</ul>
<p>This is the same order as DirectSound expects, but applied to all platforms; <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> will swizzle the channels as necessary if a platform expects something different.</p>
<p><a class="el" href="structSDL_1_1AudioStream.html" title="Handle to an owned audioStream.">AudioStream</a> can also be provided channel maps to change this ordering to whatever is necessary, in other audio processing scenarios. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaf8a794d1f4b7b4b78322b0e40fb781a2" name="gaf8a794d1f4b7b4b78322b0e40fb781a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8a794d1f4b7b4b78322b0e40fb781a2">&#9670;&#160;</a></span>SDL_AUDIO_MASK_BIG_ENDIAN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_AUDIO_MASK_BIG_ENDIAN&#160;&#160;&#160;(1u &lt;&lt; 12)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generally one should use AudioFormat.IsBigEndian or AudioFormat.IsLittleEndian instead of this macro directly.</p>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gade51417b52dbd9511d56066caae0038b" name="gade51417b52dbd9511d56066caae0038b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade51417b52dbd9511d56066caae0038b">&#9670;&#160;</a></span>SDL_AUDIO_MASK_BITSIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_AUDIO_MASK_BITSIZE&#160;&#160;&#160;(0xFFu)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generally one should use AudioFormat.GetBitSize instead of this macro directly.</p>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaca86003b4287870be9525fce5ab2916f" name="gaca86003b4287870be9525fce5ab2916f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca86003b4287870be9525fce5ab2916f">&#9670;&#160;</a></span>SDL_AUDIO_MASK_FLOAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_AUDIO_MASK_FLOAT&#160;&#160;&#160;(1u &lt;&lt; 8)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generally one should use AudioFormat.IsFloat instead of this macro directly.</p>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga06fc66d3c421c6c9b733854b73d104ce" name="ga06fc66d3c421c6c9b733854b73d104ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06fc66d3c421c6c9b733854b73d104ce">&#9670;&#160;</a></span>SDL_AUDIO_MASK_SIGNED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_AUDIO_MASK_SIGNED&#160;&#160;&#160;(1u &lt;&lt; 15)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generally one should use AudioFormat.IsSigned instead of this macro directly.</p>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga2e483caf8bcf7944d6f995ad9ab1ffe7" name="ga2e483caf8bcf7944d6f995ad9ab1ffe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e483caf8bcf7944d6f995ad9ab1ffe7">&#9670;&#160;</a></span>AudioPostmixCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryAudio.html#ga2e483caf8bcf7944d6f995ad9ab1ffe7">SDL::AudioPostmixCallback</a> = typedef SDL_AudioPostmixCallback</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is useful for accessing the final mix, perhaps for writing a visualizer or applying a final effect to the audio data before playback.</p>
<p>This callback should run as quickly as possible and not block for any significant time, as this callback delays submission of data to the audio device, which can cause audio playback problems.</p>
<p>The postmix callback <em>must</em> be able to handle any audio data format specified in <code>spec</code>, which can change between callbacks if the audio device changed. However, this only covers frequency and channel count; data is always provided here in AUDIO_F32 format.</p>
<p>The postmix callback runs <em>after</em> logical device gain and audiostream gain have been applied, which is to say you can make the output data louder at this point than the gain settings would suggest.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userdata</td><td>a pointer provided by the app through <a class="el" href="structSDL_1_1AudioDeviceRef.html#a175d35c5b7013e041cc4c1694511772c" title="Set a callback that fires when data is about to be fed to an audio device.">AudioDeviceRef.SetPostmixCallback</a>, for its own use. </td></tr>
    <tr><td class="paramname">spec</td><td>the current format of audio that is to be submitted to the audio device. </td></tr>
    <tr><td class="paramname">buffer</td><td>the buffer of audio samples to be submitted. The callback can inspect and/or modify this data. </td></tr>
    <tr><td class="paramname">buflen</td><td>the size of <code>buffer</code> in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This will run from a background thread owned by <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a>. The application is responsible for locking resources the callback touches that need to be protected.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1AudioDeviceRef.html#a175d35c5b7013e041cc4c1694511772c" title="Set a callback that fires when data is about to be fed to an audio device.">AudioDeviceRef.SetPostmixCallback</a> </dd></dl>

</div>
</div>
<a id="ga9b9847647bcb90afe05f8d5cce8a128e" name="ga9b9847647bcb90afe05f8d5cce8a128e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b9847647bcb90afe05f8d5cce8a128e">&#9670;&#160;</a></span>AudioPostmixCB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryAudio.html#ga9b9847647bcb90afe05f8d5cce8a128e">SDL::AudioPostmixCB</a> = typedef std::function&lt;void(const <a class="el" href="group__CategoryAudio.html#ga278e46a8d2922ad0aa9a58e35bbcb92e">AudioSpec</a>&amp; spec, std::span&lt;float&gt; buffer)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is useful for accessing the final mix, perhaps for writing a visualizer or applying a final effect to the audio data before playback.</p>
<p>This callback should run as quickly as possible and not block for any significant time, as this callback delays submission of data to the audio device, which can cause audio playback problems.</p>
<p>The postmix callback <em>must</em> be able to handle any audio data format specified in <code>spec</code>, which can change between callbacks if the audio device changed. However, this only covers frequency and channel count; data is always provided here in AUDIO_F32 format.</p>
<p>The postmix callback runs <em>after</em> logical device gain and audiostream gain have been applied, which is to say you can make the output data louder at this point than the gain settings would suggest.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spec</td><td>the current format of audio that is to be submitted to the audio device. </td></tr>
    <tr><td class="paramname">buffer</td><td>the buffer of audio samples to be submitted. The callback can inspect and/or modify this data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This will run from a background thread owned by <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a>. The application is responsible for locking resources the callback touches that need to be protected.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1AudioDeviceRef.html#a175d35c5b7013e041cc4c1694511772c" title="Set a callback that fires when data is about to be fed to an audio device.">AudioDeviceRef.SetPostmixCallback</a> </dd>
<dd>
<a class="el" href="group__CategoryAudio.html#ga2e483caf8bcf7944d6f995ad9ab1ffe7" title="A callback that fires when data is about to be fed to an audio device.">AudioPostmixCallback</a> </dd></dl>

</div>
</div>
<a id="ga278e46a8d2922ad0aa9a58e35bbcb92e" name="ga278e46a8d2922ad0aa9a58e35bbcb92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga278e46a8d2922ad0aa9a58e35bbcb92e">&#9670;&#160;</a></span>AudioSpec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryAudio.html#ga278e46a8d2922ad0aa9a58e35bbcb92e">SDL::AudioSpec</a> = typedef SDL_AudioSpec</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSDL_1_1AudioFormat.html" title="Audio format.">AudioFormat</a> </dd></dl>

</div>
</div>
<a id="gaf137bc28b994c19c9e4c214a512a15a1" name="gaf137bc28b994c19c9e4c214a512a15a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf137bc28b994c19c9e4c214a512a15a1">&#9670;&#160;</a></span>AudioStreamCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryAudio.html#gaf137bc28b994c19c9e4c214a512a15a1">SDL::AudioStreamCallback</a> = typedef SDL_AudioStreamCallback</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apps can (optionally) register a callback with an audio stream that is called when data is added with <a class="el" href="structSDL_1_1AudioStreamRef.html#a98d44233259c85840a44328b83c42f57" title="Add data to the stream.">AudioStreamRef.PutData</a>, or requested with <a class="el" href="structSDL_1_1AudioStreamRef.html#a30190621ee9e16b81998af35af8af33e" title="Get converted/resampled data from the stream.">AudioStreamRef.GetData</a>.</p>
<p>Two values are offered here: one is the amount of additional data needed to satisfy the immediate request (which might be zero if the stream already has enough data queued) and the other is the total amount being requested. In a Get call triggering a Put callback, these values can be different. In a Put call triggering a Get callback, these values are always the same.</p>
<p>Byte counts might be slightly overestimated due to buffering or resampling, and may change from call to call.</p>
<p>This callback is not required to do anything. Generally this is useful for adding/reading data on demand, and the app will often put/get data as appropriate, but the system goes on with the data currently available to it if this callback does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>the <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> audio stream associated with this callback. </td></tr>
    <tr><td class="paramname">additional_amount</td><td>the amount of data, in bytes, that is needed right now. </td></tr>
    <tr><td class="paramname">total_amount</td><td>the total amount of data requested, in bytes, that is requested or available. </td></tr>
    <tr><td class="paramname">userdata</td><td>an opaque pointer provided by the app for their personal use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This callbacks may run from any thread, so if you need to protect shared data, you should use <a class="el" href="group__CategoryAudio.html#gac5cf7026d0330daa1eec716a321908b0" title="Lock an audio stream for serialized access.">AudioStreamRef.Lock</a> to serialize access; this lock will be held before your callback is called, so your callback does not need to manage the lock explicitly.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1AudioStreamRef.html#a8f06f9ad56e1eba11825f58dc21b1014" title="Set a callback that runs when data is requested from an audio stream.">AudioStreamRef.SetGetCallback</a> </dd>
<dd>
<a class="el" href="structSDL_1_1AudioStreamRef.html#a1a2883172ba0273c79f57e506f6dc3a6" title="Set a callback that runs when data is added to an audio stream.">AudioStreamRef.SetPutCallback</a> </dd></dl>

</div>
</div>
<a id="ga7e94ca585b8e971289b7bfd6780762cc" name="ga7e94ca585b8e971289b7bfd6780762cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e94ca585b8e971289b7bfd6780762cc">&#9670;&#160;</a></span>AudioStreamCB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryAudio.html#ga7e94ca585b8e971289b7bfd6780762cc">SDL::AudioStreamCB</a> = typedef std::function&lt; void(<a class="el" href="structSDL_1_1AudioStreamRef.html">AudioStreamRef</a> stream, int additional_amount, int total_amount)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apps can (optionally) register a callback with an audio stream that is called when data is added with <a class="el" href="structSDL_1_1AudioStreamRef.html#a98d44233259c85840a44328b83c42f57" title="Add data to the stream.">AudioStreamRef.PutData</a>, or requested with <a class="el" href="structSDL_1_1AudioStreamRef.html#a30190621ee9e16b81998af35af8af33e" title="Get converted/resampled data from the stream.">AudioStreamRef.GetData</a>.</p>
<p>Two values are offered here: one is the amount of additional data needed to satisfy the immediate request (which might be zero if the stream already has enough data queued) and the other is the total amount being requested. In a Get call triggering a Put callback, these values can be different. In a Put call triggering a Get callback, these values are always the same.</p>
<p>Byte counts might be slightly overestimated due to buffering or resampling, and may change from call to call.</p>
<p>This callback is not required to do anything. Generally this is useful for adding/reading data on demand, and the app will often put/get data as appropriate, but the system goes on with the data currently available to it if this callback does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>the <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> audio stream associated with this callback. </td></tr>
    <tr><td class="paramname">additional_amount</td><td>the amount of data, in bytes, that is needed right now. </td></tr>
    <tr><td class="paramname">total_amount</td><td>the total amount of data requested, in bytes, that is requested or available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This callbacks may run from any thread, so if you need to protect shared data, you should use <a class="el" href="group__CategoryAudio.html#gac5cf7026d0330daa1eec716a321908b0" title="Lock an audio stream for serialized access.">AudioStreamRef.Lock</a> to serialize access; this lock will be held before your callback is called, so your callback does not need to manage the lock explicitly.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1AudioStreamRef.html#a8f06f9ad56e1eba11825f58dc21b1014" title="Set a callback that runs when data is requested from an audio stream.">AudioStreamRef.SetGetCallback</a> </dd>
<dd>
<a class="el" href="structSDL_1_1AudioStreamRef.html#a1a2883172ba0273c79f57e506f6dc3a6" title="Set a callback that runs when data is added to an audio stream.">AudioStreamRef.SetPutCallback</a> </dd>
<dd>
<a class="el" href="group__CategoryAudio.html#gaf137bc28b994c19c9e4c214a512a15a1" title="A callback that fires when data passes through an AudioStreamRef.">AudioStreamCallback</a> </dd></dl>

</div>
</div>
<a id="gae12773fac83d661b028da1a429d5cf87" name="gae12773fac83d661b028da1a429d5cf87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae12773fac83d661b028da1a429d5cf87">&#9670;&#160;</a></span>OptionalAudioStream</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryAudio.html#gae12773fac83d661b028da1a429d5cf87">SDL::OptionalAudioStream</a> = typedef <a class="el" href="classSDL_1_1OptionalResource.html">OptionalResource</a>&lt;<a class="el" href="structSDL_1_1AudioStreamRef.html">AudioStreamRef</a>, <a class="el" href="structSDL_1_1AudioStream.html">AudioStream</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is designed to be used on parameter's type and accepts that accepts a std::nullopt, a non-owned <a class="el" href="structSDL_1_1AudioStreamRef.html" title="The opaque handle that represents an audio stream.">AudioStreamRef</a> or an owned <a class="el" href="structSDL_1_1AudioStream.html" title="Handle to an owned audioStream.">AudioStream</a> </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gafd736bb7a8107101eac9d0ad555460c3" name="gafd736bb7a8107101eac9d0ad555460c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd736bb7a8107101eac9d0ad555460c3">&#9670;&#160;</a></span>AudioFrameSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int SDL::AudioFrameSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CategoryAudio.html#ga278e46a8d2922ad0aa9a58e35bbcb92e">AudioSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This reports on the size of an audio sample frame: stereo Sint16 data (2 channels of 2 bytes each) would be 4 bytes per frame, for example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>an AudioSpec to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes used per sample frame.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this macro from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gac5ad89fcbe1ab761e0e2b2865e358fa7" name="gac5ad89fcbe1ab761e0e2b2865e358fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5ad89fcbe1ab761e0e2b2865e358fa7">&#9670;&#160;</a></span>BindAudioStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::AudioDeviceRef::BindAudioStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1AudioStreamRef.html">AudioStreamRef</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a convenience function, equivalent to calling <code><a class="el" href="group__CategoryAudio.html#gac900e515ecdc88b660fc1e0c49f3b15b" title="Bind a list of audio streams to an audio device.">AudioDeviceRef.BindAudioStreams</a>(devid, &amp;stream, 1)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>an audio stream to bind to a device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAudio.html#gac900e515ecdc88b660fc1e0c49f3b15b" title="Bind a list of audio streams to an audio device.">AudioDeviceRef.BindAudioStreams</a> </dd>
<dd>
<a class="el" href="structSDL_1_1AudioStreamRef.html#aa3fa302bd61a63c97b4ca3ffb7d4fd7e" title="Unbind a single audio stream from its audio device.">AudioStreamRef.Unbind</a> </dd>
<dd>
<a class="el" href="structSDL_1_1AudioStreamRef.html#a0638d4c1d5113a8db10614d6a2f51de0" title="Query an audio stream for its currently-bound device.">AudioStreamRef.GetDevice</a> </dd></dl>

</div>
</div>
<a id="gac900e515ecdc88b660fc1e0c49f3b15b" name="gac900e515ecdc88b660fc1e0c49f3b15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac900e515ecdc88b660fc1e0c49f3b15b">&#9670;&#160;</a></span>BindAudioStreams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::AudioDeviceRef::BindAudioStreams </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; <a class="el" href="structSDL_1_1AudioStreamRef.html">AudioStreamRef</a> &gt;&#160;</td>
          <td class="paramname"><em>streams</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Audio data will flow through any bound streams. For a playback device, data for all bound streams will be mixed together and fed to the device. For a recording device, a copy of recorded data will be provided to each bound stream.</p>
<p>Audio streams can only be bound to an open device. This operation is atomic&ndash;all streams bound in the same call will start processing at the same time, so they can stay in sync. Also: either all streams will be bound or none of them will be.</p>
<p>It is an error to bind an already-bound stream; it must be explicitly unbound first.</p>
<p>Binding a stream to a device will set its output format for playback devices, and its input format for recording devices, so they match the device's settings. The caller is welcome to change the other end of the stream's format at any time with <a class="el" href="structSDL_1_1AudioStreamRef.html#aa2c35be20ef4f73096a561a5555404a0" title="Change the input and output formats of an audio stream.">AudioStreamRef.SetFormat()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streams</td><td>an array of audio streams to bind. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAudio.html#gac900e515ecdc88b660fc1e0c49f3b15b" title="Bind a list of audio streams to an audio device.">AudioDeviceRef.BindAudioStreams</a> </dd>
<dd>
<a class="el" href="structSDL_1_1AudioStreamRef.html#aa3fa302bd61a63c97b4ca3ffb7d4fd7e" title="Unbind a single audio stream from its audio device.">AudioStreamRef.Unbind</a> </dd>
<dd>
<a class="el" href="structSDL_1_1AudioStreamRef.html#a0638d4c1d5113a8db10614d6a2f51de0" title="Query an audio stream for its currently-bound device.">AudioStreamRef.GetDevice</a> </dd></dl>

</div>
</div>
<a id="ga21787c751aa8f17579f1dca4a1b8b8ff" name="ga21787c751aa8f17579f1dca4a1b8b8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21787c751aa8f17579f1dca4a1b8b8ff">&#9670;&#160;</a></span>ConvertAudioSamples()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OwnArray.html">OwnArray</a>&lt; Uint8 &gt; SDL::ConvertAudioSamples </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CategoryAudio.html#ga278e46a8d2922ad0aa9a58e35bbcb92e">AudioSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>src_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1SourceBytes.html">SourceBytes</a>&#160;</td>
          <td class="paramname"><em>src_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CategoryAudio.html#ga278e46a8d2922ad0aa9a58e35bbcb92e">AudioSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>dst_spec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Please note that this function is for convenience, but should not be used to resample audio in blocks, as it will introduce audio artifacts on the boundaries. You should only use this function if you are converting audio data in its entirety in one call. If you want to convert audio in smaller chunks, use an <a class="el" href="structSDL_1_1AudioStreamRef.html" title="The opaque handle that represents an audio stream.">AudioStreamRef</a>, which is designed for this situation.</p>
<p>Internally, this function creates and destroys an <a class="el" href="structSDL_1_1AudioStreamRef.html" title="The opaque handle that represents an audio stream.">AudioStreamRef</a> on each use, so it's also less efficient than using one directly, if you need to convert multiple times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_spec</td><td>the format details of the input audio. </td></tr>
    <tr><td class="paramname">src_data</td><td>the audio data to be converted. </td></tr>
    <tr><td class="paramname">dst_spec</td><td>the format details of the output audio. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted audio data on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga97ae58cdecc93ccd529ee40053b6dec4" name="ga97ae58cdecc93ccd529ee40053b6dec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97ae58cdecc93ccd529ee40053b6dec4">&#9670;&#160;</a></span>GetAudioDriver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * SDL::GetAudioDriver </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The list of audio drivers is given in the order that they are normally initialized by default; the drivers that seem more reasonable to choose first (as far as the <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> developers believe) are earlier in the list.</p>
<p>The names of drivers are all simple, low-ASCII identifiers, like "alsa", "coreaudio" or "wasapi". These never have Unicode characters, and are not meant to be proper names.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the audio driver; the value ranges from 0 to <a class="el" href="group__CategoryAudio.html#gabf9859eb75df1d2c15aba976069e165b" title="Use this function to get the number of built-in audio drivers.">GetNumAudioDrivers()</a> - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the audio driver at the requested index, or nullptr if an invalid index was specified.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAudio.html#gabf9859eb75df1d2c15aba976069e165b" title="Use this function to get the number of built-in audio drivers.">GetNumAudioDrivers</a> </dd></dl>

</div>
</div>
<a id="gae01ace687559a15b37b2d43ecd080bc1" name="gae01ace687559a15b37b2d43ecd080bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae01ace687559a15b37b2d43ecd080bc1">&#9670;&#160;</a></span>GetAudioPlaybackDevices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OwnArray.html">OwnArray</a>&lt; <a class="el" href="structSDL_1_1AudioDeviceRef.html">AudioDeviceRef</a> &gt; SDL::GetAudioPlaybackDevices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This returns of list of available devices that play sound, perhaps to speakers or headphones ("playback" devices). If you want devices that record audio, like a microphone ("recording" devices), use <a class="el" href="group__CategoryAudio.html#ga8d9ae95b5f46a3c01191ad9db38b4eeb" title="Get a list of currently-connected audio recording devices.">GetAudioRecordingDevices()</a> instead.</p>
<p>This only returns a list of physical devices; it will not have any device IDs returned by <a class="el" href="structSDL_1_1AudioDeviceRef.html#a61fc8354673ddffb00d9f323fce40f24" title="Copy constructor.">AudioDeviceRef.AudioDeviceRef()</a>.</p>
<p>If this function returns nullptr, to signify an error, <code>*count</code> will be set to zero.</p>
<dl class="section return"><dt>Returns</dt><dd>a 0 terminated array of device instance IDs or nullptr on error; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information. This should be freed with <a class="el" href="group__CategoryStdinc.html#gadfa01257ca1f966fffb72f002db27fa6" title="Free allocated memory.">free()</a> when it is no longer needed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1AudioDeviceRef.html#a61fc8354673ddffb00d9f323fce40f24" title="Copy constructor.">AudioDeviceRef.AudioDeviceRef</a> </dd>
<dd>
<a class="el" href="group__CategoryAudio.html#ga8d9ae95b5f46a3c01191ad9db38b4eeb" title="Get a list of currently-connected audio recording devices.">GetAudioRecordingDevices</a> </dd></dl>

</div>
</div>
<a id="ga8d9ae95b5f46a3c01191ad9db38b4eeb" name="ga8d9ae95b5f46a3c01191ad9db38b4eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d9ae95b5f46a3c01191ad9db38b4eeb">&#9670;&#160;</a></span>GetAudioRecordingDevices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OwnArray.html">OwnArray</a>&lt; <a class="el" href="structSDL_1_1AudioDeviceRef.html">AudioDeviceRef</a> &gt; SDL::GetAudioRecordingDevices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This returns of list of available devices that record audio, like a microphone ("recording" devices). If you want devices that play sound, perhaps to speakers or headphones ("playback" devices), use <a class="el" href="group__CategoryAudio.html#gae01ace687559a15b37b2d43ecd080bc1" title="Get a list of currently-connected audio playback devices.">GetAudioPlaybackDevices()</a> instead.</p>
<p>This only returns a list of physical devices; it will not have any device IDs returned by <a class="el" href="structSDL_1_1AudioDeviceRef.html#a61fc8354673ddffb00d9f323fce40f24" title="Copy constructor.">AudioDeviceRef.AudioDeviceRef()</a>.</p>
<p>If this function returns nullptr, to signify an error, <code>*count</code> will be set to zero.</p>
<dl class="section return"><dt>Returns</dt><dd>a 0 terminated array of device instance IDs, or nullptr on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information. This should be freed with <a class="el" href="group__CategoryStdinc.html#gadfa01257ca1f966fffb72f002db27fa6" title="Free allocated memory.">free()</a> when it is no longer needed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1AudioDeviceRef.html#a61fc8354673ddffb00d9f323fce40f24" title="Copy constructor.">AudioDeviceRef.AudioDeviceRef</a> </dd>
<dd>
<a class="el" href="group__CategoryAudio.html#gae01ace687559a15b37b2d43ecd080bc1" title="Get a list of currently-connected audio playback devices.">GetAudioPlaybackDevices</a> </dd></dl>

</div>
</div>
<a id="ga3fc36d5a1cbcbc60b3822839100a725b" name="ga3fc36d5a1cbcbc60b3822839100a725b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fc36d5a1cbcbc60b3822839100a725b">&#9670;&#160;</a></span>GetCurrentAudioDriver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * SDL::GetCurrentAudioDriver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The names of drivers are all simple, low-ASCII identifiers, like "alsa", "coreaudio" or "wasapi". These never have Unicode characters, and are not meant to be proper names.</p>
<dl class="section return"><dt>Returns</dt><dd>the name of the current audio driver or nullptr if no driver has been initialized.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gabf9859eb75df1d2c15aba976069e165b" name="gabf9859eb75df1d2c15aba976069e165b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf9859eb75df1d2c15aba976069e165b">&#9670;&#160;</a></span>GetNumAudioDrivers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::GetNumAudioDrivers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns a hardcoded number. This never returns a negative value; if there are no drivers compiled into this build of <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a>, this function returns zero. The presence of a driver in this list does not mean it will function, it just means <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is capable of interacting with that interface. For example, a build of <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> might have esound support, but if there's no esound server available, <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a>'s esound driver would fail if used.</p>
<p>By default, <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> tries all drivers, in its preferred order, until one is found to be usable.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of built-in audio drivers.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAudio.html#ga97ae58cdecc93ccd529ee40053b6dec4" title="Use this function to get the name of a built in audio driver.">GetAudioDriver</a> </dd></dl>

</div>
</div>
<a id="gaa86de6f7c358ef5f2ad75c9898423a27" name="gaa86de6f7c358ef5f2ad75c9898423a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa86de6f7c358ef5f2ad75c9898423a27">&#9670;&#160;</a></span>LoadWAV() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OwnArray.html">OwnArray</a>&lt; Uint8 &gt; SDL::LoadWAV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1IOStreamRef.html">IOStreamRef</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryAudio.html#ga278e46a8d2922ad0aa9a58e35bbcb92e">AudioSpec</a> *&#160;</td>
          <td class="paramname"><em>spec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loading a WAVE file requires <code>src</code>, <code>spec</code>, <code>audio_buf</code> and <code>audio_len</code> to be valid pointers. The entire data portion of the file is then loaded into memory and decoded if necessary.</p>
<p>Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and A-law and mu-law (8 bits). Other formats are currently unsupported and cause an error.</p>
<p>If this function succeeds, the return value is zero and the pointer to the audio data allocated by the function is written to <code>audio_buf</code> and its length in bytes to <code>audio_len</code>. The AudioSpec members <code>freq</code>, <code>channels</code>, and <code>format</code> are set to the values of the audio data in the buffer.</p>
<p>It's necessary to use <a class="el" href="group__CategoryStdinc.html#gadfa01257ca1f966fffb72f002db27fa6" title="Free allocated memory.">free()</a> to free the audio data returned in <code>audio_buf</code> when it is no longer used.</p>
<p>Because of the underspecification of the .WAV format, there are many problematic files in the wild that cause issues with strict decoders. To provide compatibility with these files, this decoder is lenient in regards to the truncation of the file, the fact chunk, and the size of the RIFF chunk. The hints <code>SDL_HINT_WAVE_RIFF_CHUNK_SIZE</code>, <code>SDL_HINT_WAVE_TRUNCATION</code>, and <code>SDL_HINT_WAVE_FACT_CHUNK</code> can be used to tune the behavior of the loading process.</p>
<p>Any file that is invalid (due to truncation, corruption, or wrong values in the headers), too big, or unsupported causes an error. Additionally, any critical I/O error from the data source will terminate the loading process with an error. The function returns nullptr on error and in all cases (with the exception of <code>src</code> being nullptr), an appropriate error message will be set.</p>
<p>It is required that the data source supports seeking.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__CategoryAudio.html#gaa86de6f7c358ef5f2ad75c9898423a27">LoadWAV</a>(<a class="code hl_struct" href="structSDL_1_1IOStreamRef.html">IOStreamRef</a>.<a class="code hl_function" href="structSDL_1_1IOStreamRef.html#a8b76e37e156393479492ad62d6e86a51">IOStreamRef</a>(<span class="stringliteral">&quot;sample.wav&quot;</span>, <span class="stringliteral">&quot;rb&quot;</span>), <span class="keyword">true</span>, &amp;spec, &amp;buf,</div>
<div class="line">&amp;len);</div>
<div class="ttc" id="agroup__CategoryAudio_html_gaa86de6f7c358ef5f2ad75c9898423a27"><div class="ttname"><a href="group__CategoryAudio.html#gaa86de6f7c358ef5f2ad75c9898423a27">SDL::LoadWAV</a></div><div class="ttdeci">OwnArray&lt; Uint8 &gt; LoadWAV(IOStreamRef &amp;src, AudioSpec *spec)</div><div class="ttdoc">Load the audio data of a WAVE file into memory.</div><div class="ttdef"><b>Definition</b> SDL3pp_audio.h:2817</div></div>
<div class="ttc" id="astructSDL_1_1IOStreamRef_html"><div class="ttname"><a href="structSDL_1_1IOStreamRef.html">SDL::IOStreamRef</a></div><div class="ttdoc">The read/write operation structure.</div><div class="ttdef"><b>Definition</b> SDL3pp_iostream.h:104</div></div>
<div class="ttc" id="astructSDL_1_1IOStreamRef_html_a8b76e37e156393479492ad62d6e86a51"><div class="ttname"><a href="structSDL_1_1IOStreamRef.html#a8b76e37e156393479492ad62d6e86a51">SDL::IOStreamRef::IOStreamRef</a></div><div class="ttdeci">constexpr IOStreamRef(const IOStreamRef &amp;other)</div><div class="ttdoc">Copy constructor.</div><div class="ttdef"><b>Definition</b> SDL3pp_iostream.h:110</div></div>
</div><!-- fragment --><p>Note that the LoadWAV function does this same thing for you, but in a less messy way:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__CategoryAudio.html#gaa86de6f7c358ef5f2ad75c9898423a27">LoadWAV</a>(<span class="stringliteral">&quot;sample.wav&quot;</span>, &amp;spec, &amp;buf, &amp;len);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the data source for the WAVE data. </td></tr>
    <tr><td class="paramname">spec</td><td>a pointer to an AudioSpec that will be set to the WAVE data's format details on successful return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the audio data on success or nullptr on failure.</dd></dl>
<p>This function throws false if the .WAV file cannot be opened, uses an unknown data format, or is corrupt,</p>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAudio.html#gaa86de6f7c358ef5f2ad75c9898423a27" title="Load the audio data of a WAVE file into memory.">LoadWAV</a> </dd></dl>

</div>
</div>
<a id="gaaff063971ee474fedad66da38c10ec43" name="gaaff063971ee474fedad66da38c10ec43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaff063971ee474fedad66da38c10ec43">&#9670;&#160;</a></span>LoadWAV() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OwnArray.html">OwnArray</a>&lt; Uint8 &gt; SDL::LoadWAV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryAudio.html#ga278e46a8d2922ad0aa9a58e35bbcb92e">AudioSpec</a> *&#160;</td>
          <td class="paramname"><em>spec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a convenience function that is effectively the same as:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__CategoryAudio.html#gaa86de6f7c358ef5f2ad75c9898423a27">LoadWAV</a>(<a class="code hl_struct" href="structSDL_1_1IOStreamRef.html">IOStreamRef</a>.<a class="code hl_function" href="structSDL_1_1IOStreamRef.html#a8b76e37e156393479492ad62d6e86a51">IOStreamRef</a>(path, <span class="stringliteral">&quot;rb&quot;</span>), <span class="keyword">true</span>, spec, audio_buf,</div>
<div class="line">audio_len);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the file path of the WAV file to open. </td></tr>
    <tr><td class="paramname">spec</td><td>a pointer to an AudioSpec that will be set to the WAVE data's format details on successful return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the audio data on success or nullptr on failure.</dd></dl>
<p>This function throws false if the .WAV file cannot be opened, uses an unknown data format, or is corrupt,</p>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAudio.html#gaa86de6f7c358ef5f2ad75c9898423a27" title="Load the audio data of a WAVE file into memory.">LoadWAV</a> </dd></dl>

</div>
</div>
<a id="gac5cf7026d0330daa1eec716a321908b0" name="gac5cf7026d0330daa1eec716a321908b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5cf7026d0330daa1eec716a321908b0">&#9670;&#160;</a></span>Lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSDL_1_1AudioStreamLock.html">AudioStreamLock</a> SDL::AudioStreamRef::Lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Each <a class="el" href="structSDL_1_1AudioStreamRef.html" title="The opaque handle that represents an audio stream.">AudioStreamRef</a> has an internal mutex it uses to protect its data structures from threading conflicts. This function allows an app to lock that mutex, which could be useful if registering callbacks on this stream.</p>
<p>One does not need to lock a stream to use in it most cases, as the stream manages this lock internally. However, this lock is held during callbacks, which may run from arbitrary threads at any time, so if an app needs to protect shared data during those callbacks, locking the stream guarantees that the callback is not running while the lock is held.</p>
<p>As this is just a wrapper over <a class="el" href="structSDL_1_1MutexRef.html#aee56f4bcb72708c15e2f5cddd76d3490" title="Lock the mutex.">MutexRef.Lock</a> for an internal lock; it has all the same attributes (recursive locks are allowed, etc).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1AudioStreamLock.html#aee1860112aa0fd89884f8375378c0083" title="Unlock an audio stream for serialized access.">AudioStreamLock.Unlock</a> </dd></dl>

</div>
</div>
<a id="ga90ebbeaafbf2f69bbd771abbd5b94f23" name="ga90ebbeaafbf2f69bbd771abbd5b94f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90ebbeaafbf2f69bbd771abbd5b94f23">&#9670;&#160;</a></span>MixAudio() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::MixAudio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1TargetBytes.html">TargetBytes</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1SourceBytes.html">SourceBytes</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1AudioFormat.html">AudioFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>volume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This takes an audio buffer <code>src</code> of <code>len</code> bytes of <code>format</code> data and mixes it into <code>dst</code>, performing addition, volume adjustment, and overflow clipping. The buffer pointed to by <code>dst</code> must also be <code>len</code> bytes of <code>format</code> data.</p>
<p>This is provided for convenience &ndash; you can mix your own audio data.</p>
<p>Do not use this function for mixing together more than two streams of sample data. The output from repeated application of this function may be distorted by clipping, because there is no accumulator with greater range than the input (not to mention this being an inefficient way of doing it).</p>
<p>It is a common misconception that this function is required to write audio data to an output stream in an audio callback. While you can do that, <a class="el" href="group__CategoryAudio.html#gaaa8a066451543172b07d02bf4eff8882" title="Mix audio data in a specified format.">MixAudio()</a> is really only needed when you're mixing a single audio stream with a volume adjustment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>the destination for the mixed audio. </td></tr>
    <tr><td class="paramname">src</td><td>the source audio buffer to be mixed. </td></tr>
    <tr><td class="paramname">format</td><td>the <a class="el" href="classSDL_1_1AudioFormat.html" title="Audio format.">AudioFormat</a> structure representing the desired audio format. </td></tr>
    <tr><td class="paramname">volume</td><td>ranges from 0.0 - 1.0, and should be set to 1.0 for full audio volume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaaa8a066451543172b07d02bf4eff8882" name="gaaa8a066451543172b07d02bf4eff8882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa8a066451543172b07d02bf4eff8882">&#9670;&#160;</a></span>MixAudio() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::MixAudio </td>
          <td>(</td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1SourceBytes.html">SourceBytes</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1AudioFormat.html">AudioFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>volume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This takes an audio buffer <code>src</code> of <code>len</code> bytes of <code>format</code> data and mixes it into <code>dst</code>, performing addition, volume adjustment, and overflow clipping. The buffer pointed to by <code>dst</code> must also be <code>len</code> bytes of <code>format</code> data.</p>
<p>This is provided for convenience &ndash; you can mix your own audio data.</p>
<p>Do not use this function for mixing together more than two streams of sample data. The output from repeated application of this function may be distorted by clipping, because there is no accumulator with greater range than the input (not to mention this being an inefficient way of doing it).</p>
<p>It is a common misconception that this function is required to write audio data to an output stream in an audio callback. While you can do that, <a class="el" href="group__CategoryAudio.html#gaaa8a066451543172b07d02bf4eff8882" title="Mix audio data in a specified format.">MixAudio()</a> is really only needed when you're mixing a single audio stream with a volume adjustment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>the destination for the mixed audio. </td></tr>
    <tr><td class="paramname">src</td><td>the source audio buffer to be mixed. </td></tr>
    <tr><td class="paramname">format</td><td>the <a class="el" href="classSDL_1_1AudioFormat.html" title="Audio format.">AudioFormat</a> structure representing the desired audio format. </td></tr>
    <tr><td class="paramname">volume</td><td>ranges from 0.0 - 1.0, and should be set to 1.0 for full audio volume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gac0f5f4b1f949b706d57a560190c0cddf" name="gac0f5f4b1f949b706d57a560190c0cddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0f5f4b1f949b706d57a560190c0cddf">&#9670;&#160;</a></span>UnbindAudioStreams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::UnbindAudioStreams </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; <a class="el" href="structSDL_1_1AudioStreamRef.html">AudioStreamRef</a> &gt;&#160;</td>
          <td class="paramname"><em>streams</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The streams being unbound do not all have to be on the same device. All streams on the same device will be unbound atomically (data will stop flowing through all unbound streams on the same device at the same time).</p>
<p>Unbinding a stream that isn't bound to a device is a legal no-op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streams</td><td>an array of audio streams to unbind. Can be nullptr or contain nullptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAudio.html#gac900e515ecdc88b660fc1e0c49f3b15b" title="Bind a list of audio streams to an audio device.">AudioDeviceRef.BindAudioStreams</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga3480f032a4bbe82de546e36cf1c857f2" name="ga3480f032a4bbe82de546e36cf1c857f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3480f032a4bbe82de546e36cf1c857f2">&#9670;&#160;</a></span>AUDIO_DEVICE_DEFAULT_PLAYBACK</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structSDL_1_1AudioDeviceRef.html">AudioDeviceRef</a> SDL::AUDIO_DEVICE_DEFAULT_PLAYBACK</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK</div>
</div><!-- fragment --><p>Several functions that require an <a class="el" href="structSDL_1_1AudioDeviceRef.html" title="SDL Audio Device instance IDs.">AudioDeviceRef</a> will accept this value to signify the app just wants the system to choose a default device instead of the app providing a specific one.</p>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga6d825e059fc09f4000a6b6912b0760f1" name="ga6d825e059fc09f4000a6b6912b0760f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d825e059fc09f4000a6b6912b0760f1">&#9670;&#160;</a></span>AUDIO_DEVICE_DEFAULT_RECORDING</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structSDL_1_1AudioDeviceRef.html">AudioDeviceRef</a> SDL::AUDIO_DEVICE_DEFAULT_RECORDING</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_AUDIO_DEVICE_DEFAULT_RECORDING</div>
</div><!-- fragment --><p>Several functions that require an <a class="el" href="structSDL_1_1AudioDeviceRef.html" title="SDL Audio Device instance IDs.">AudioDeviceRef</a> will accept this value to signify the app just wants the system to choose a default device instead of the app providing a specific one.</p>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaf40419458b3fb954894648336fbf46d2" name="gaf40419458b3fb954894648336fbf46d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf40419458b3fb954894648336fbf46d2">&#9670;&#160;</a></span>AUDIO_F32BE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr SDL_AudioFormat SDL::AUDIO_F32BE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_AUDIO_F32BE</div>
</div><!-- fragment -->
</div>
</div>
<a id="gab17527facb7753347af62787282ffc46" name="gab17527facb7753347af62787282ffc46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab17527facb7753347af62787282ffc46">&#9670;&#160;</a></span>AUDIO_F32LE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr SDL_AudioFormat SDL::AUDIO_F32LE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_AUDIO_F32LE</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga2546f053ac4218ddf4238dd8ec2f44db" name="ga2546f053ac4218ddf4238dd8ec2f44db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2546f053ac4218ddf4238dd8ec2f44db">&#9670;&#160;</a></span>AUDIO_S16BE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr SDL_AudioFormat SDL::AUDIO_S16BE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_AUDIO_S16BE</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga79231e9846a14b6c28e30e1c2db02f11" name="ga79231e9846a14b6c28e30e1c2db02f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79231e9846a14b6c28e30e1c2db02f11">&#9670;&#160;</a></span>AUDIO_S16LE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr SDL_AudioFormat SDL::AUDIO_S16LE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_AUDIO_S16LE</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga5295e3b9f425ca7d31f2f186b99c6d34" name="ga5295e3b9f425ca7d31f2f186b99c6d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5295e3b9f425ca7d31f2f186b99c6d34">&#9670;&#160;</a></span>AUDIO_S32BE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr SDL_AudioFormat SDL::AUDIO_S32BE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_AUDIO_S32BE</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga4d3b4c9ee67abdfec4ab43d59e3e7b89" name="ga4d3b4c9ee67abdfec4ab43d59e3e7b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d3b4c9ee67abdfec4ab43d59e3e7b89">&#9670;&#160;</a></span>AUDIO_S32LE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr SDL_AudioFormat SDL::AUDIO_S32LE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_AUDIO_S32LE</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaff751fbf4be129fabe99a981a64f934f" name="gaff751fbf4be129fabe99a981a64f934f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff751fbf4be129fabe99a981a64f934f">&#9670;&#160;</a></span>AUDIO_UNKNOWN</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr SDL_AudioFormat SDL::AUDIO_UNKNOWN</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_AUDIO_UNKNOWN</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
