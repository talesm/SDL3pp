<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDL3pp: Async I/O</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SDL3pp
   </div>
   <div id="projectbrief">A slim C++ wrapper for SDL3</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Async I/O<div class="ingroups"><a class="el" href="group__Categories.html">Categories</a> &raquo; <a class="el" href="group__CategoriesFileIO.html">File and I/O Abstractions</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> offers a way to perform I/O asynchronously.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1AsyncIOParam.html">SDL::AsyncIOParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely wrap <a class="el" href="classSDL_1_1AsyncIO.html" title="The asynchronous I/O operation structure.">AsyncIO</a> for non owning parameters.  <a href="structSDL_1_1AsyncIOParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1AsyncIOQueueParam.html">SDL::AsyncIOQueueParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely wrap <a class="el" href="classSDL_1_1AsyncIOQueue.html" title="A queue of completed asynchronous I/O tasks.">AsyncIOQueue</a> for non owning parameters.  <a href="structSDL_1_1AsyncIOQueueParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1AsyncIO.html">SDL::AsyncIO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The asynchronous I/O operation structure.  <a href="classSDL_1_1AsyncIO.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1AsyncIORef.html">SDL::AsyncIORef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semi-safe reference for <a class="el" href="classSDL_1_1AsyncIO.html" title="The asynchronous I/O operation structure.">AsyncIO</a>.  <a href="structSDL_1_1AsyncIORef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1AsyncIOQueue.html">SDL::AsyncIOQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A queue of completed asynchronous I/O tasks.  <a href="classSDL_1_1AsyncIOQueue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1AsyncIOQueueRef.html">SDL::AsyncIOQueueRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semi-safe reference for <a class="el" href="classSDL_1_1AsyncIOQueue.html" title="A queue of completed asynchronous I/O tasks.">AsyncIOQueue</a>.  <a href="structSDL_1_1AsyncIOQueueRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga933bd971d2ccad5e099dc7c6d95825c4" id="r_ga933bd971d2ccad5e099dc7c6d95825c4"><td class="memItemLeft" align="right" valign="top"><a id="ga933bd971d2ccad5e099dc7c6d95825c4" name="ga933bd971d2ccad5e099dc7c6d95825c4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::AsyncIORaw</b> = SDL_AsyncIO *</td></tr>
<tr class="memdesc:ga933bd971d2ccad5e099dc7c6d95825c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to raw representation for <a class="el" href="classSDL_1_1AsyncIO.html" title="The asynchronous I/O operation structure.">AsyncIO</a>. <br /></td></tr>
<tr class="separator:ga933bd971d2ccad5e099dc7c6d95825c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff7950b181335ce4b2adf2a1b7ef2646" id="r_gaff7950b181335ce4b2adf2a1b7ef2646"><td class="memItemLeft" align="right" valign="top"><a id="gaff7950b181335ce4b2adf2a1b7ef2646" name="gaff7950b181335ce4b2adf2a1b7ef2646"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::AsyncIOQueueRaw</b> = SDL_AsyncIOQueue *</td></tr>
<tr class="memdesc:gaff7950b181335ce4b2adf2a1b7ef2646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to raw representation for <a class="el" href="classSDL_1_1AsyncIOQueue.html" title="A queue of completed asynchronous I/O tasks.">AsyncIOQueue</a>. <br /></td></tr>
<tr class="separator:gaff7950b181335ce4b2adf2a1b7ef2646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ced0daa86e13c8fb857a7de2d3ea3fc" id="r_ga5ced0daa86e13c8fb857a7de2d3ea3fc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#ga5ced0daa86e13c8fb857a7de2d3ea3fc">SDL::AsyncIOTaskType</a> = SDL_AsyncIOTaskType</td></tr>
<tr class="memdesc:ga5ced0daa86e13c8fb857a7de2d3ea3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of asynchronous I/O tasks.  <br /></td></tr>
<tr class="separator:ga5ced0daa86e13c8fb857a7de2d3ea3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf01bc0057e6d26f43fcb866acc7b5403" id="r_gaf01bc0057e6d26f43fcb866acc7b5403"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#gaf01bc0057e6d26f43fcb866acc7b5403">SDL::AsyncIOResult</a> = SDL_AsyncIOResult</td></tr>
<tr class="memdesc:gaf01bc0057e6d26f43fcb866acc7b5403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible outcomes of an asynchronous I/O task.  <br /></td></tr>
<tr class="separator:gaf01bc0057e6d26f43fcb866acc7b5403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49382059be2b9dd333b2b43bdf686717" id="r_ga49382059be2b9dd333b2b43bdf686717"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#ga49382059be2b9dd333b2b43bdf686717">SDL::AsyncIOOutcome</a> = SDL_AsyncIOOutcome</td></tr>
<tr class="memdesc:ga49382059be2b9dd333b2b43bdf686717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a completed asynchronous I/O request.  <br /></td></tr>
<tr class="separator:ga49382059be2b9dd333b2b43bdf686717"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga63ca43e4936d353920099e2755ca072f" id="r_ga63ca43e4936d353920099e2755ca072f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1AsyncIO.html">AsyncIO</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#ga63ca43e4936d353920099e2755ca072f">SDL::AsyncIOFromFile</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> file, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> mode)</td></tr>
<tr class="memdesc:ga63ca43e4936d353920099e2755ca072f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to create a new <a class="el" href="classSDL_1_1AsyncIO.html" title="The asynchronous I/O operation structure.">AsyncIO</a> object for reading from and/or writing to a named file.  <br /></td></tr>
<tr class="separator:ga63ca43e4936d353920099e2755ca072f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd0a645e5debeb2997784f68a7d87162" id="r_gafd0a645e5debeb2997784f68a7d87162"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategoryStdinc.html#ga2feaa627ab3612aab570e5a359b1e637">Sint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#gafd0a645e5debeb2997784f68a7d87162">SDL::GetAsyncIOSize</a> (<a class="el" href="structSDL_1_1AsyncIOParam.html">AsyncIOParam</a> asyncio)</td></tr>
<tr class="memdesc:gafd0a645e5debeb2997784f68a7d87162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to get the size of the data stream in an <a class="el" href="classSDL_1_1AsyncIO.html" title="The asynchronous I/O operation structure.">AsyncIO</a>.  <br /></td></tr>
<tr class="separator:gafd0a645e5debeb2997784f68a7d87162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf97914a74e52faed859fd7192e170eaf" id="r_gaf97914a74e52faed859fd7192e170eaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#gaf97914a74e52faed859fd7192e170eaf">SDL::ReadAsyncIO</a> (<a class="el" href="structSDL_1_1AsyncIOParam.html">AsyncIOParam</a> asyncio, void *ptr, <a class="el" href="group__CategoryStdinc.html#gad1c0b6121968b312e1133bcf0db2a2b0">Uint64</a> offset, <a class="el" href="group__CategoryStdinc.html#gad1c0b6121968b312e1133bcf0db2a2b0">Uint64</a> size, <a class="el" href="structSDL_1_1AsyncIOQueueParam.html">AsyncIOQueueParam</a> queue, void *userdata)</td></tr>
<tr class="memdesc:gaf97914a74e52faed859fd7192e170eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an async read.  <br /></td></tr>
<tr class="separator:gaf97914a74e52faed859fd7192e170eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b8d20d62189de16c9fb13302546d82e" id="r_ga8b8d20d62189de16c9fb13302546d82e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#ga8b8d20d62189de16c9fb13302546d82e">SDL::WriteAsyncIO</a> (<a class="el" href="structSDL_1_1AsyncIOParam.html">AsyncIOParam</a> asyncio, void *ptr, <a class="el" href="group__CategoryStdinc.html#gad1c0b6121968b312e1133bcf0db2a2b0">Uint64</a> offset, <a class="el" href="group__CategoryStdinc.html#gad1c0b6121968b312e1133bcf0db2a2b0">Uint64</a> size, <a class="el" href="structSDL_1_1AsyncIOQueueParam.html">AsyncIOQueueParam</a> queue, void *userdata)</td></tr>
<tr class="memdesc:ga8b8d20d62189de16c9fb13302546d82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an async write.  <br /></td></tr>
<tr class="separator:ga8b8d20d62189de16c9fb13302546d82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae999d5100fe32c334f7145af38591ca4" id="r_gae999d5100fe32c334f7145af38591ca4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#gae999d5100fe32c334f7145af38591ca4">SDL::CloseAsyncIO</a> (<a class="el" href="group__CategoryAsyncIO.html#ga933bd971d2ccad5e099dc7c6d95825c4">AsyncIORaw</a> asyncio, bool flush, <a class="el" href="structSDL_1_1AsyncIOQueueParam.html">AsyncIOQueueParam</a> queue, void *userdata)</td></tr>
<tr class="memdesc:gae999d5100fe32c334f7145af38591ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close and free any allocated resources for an async I/O object.  <br /></td></tr>
<tr class="separator:gae999d5100fe32c334f7145af38591ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45a5878f8fae598039744c57812e0996" id="r_ga45a5878f8fae598039744c57812e0996"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1AsyncIOQueue.html">AsyncIOQueue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#ga45a5878f8fae598039744c57812e0996">SDL::CreateAsyncIOQueue</a> ()</td></tr>
<tr class="memdesc:ga45a5878f8fae598039744c57812e0996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a task queue for tracking multiple I/O operations.  <br /></td></tr>
<tr class="separator:ga45a5878f8fae598039744c57812e0996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8459be067bf7aa8a5732eb62e119226" id="r_gac8459be067bf7aa8a5732eb62e119226"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#gac8459be067bf7aa8a5732eb62e119226">SDL::DestroyAsyncIOQueue</a> (<a class="el" href="group__CategoryAsyncIO.html#gaff7950b181335ce4b2adf2a1b7ef2646">AsyncIOQueueRaw</a> queue)</td></tr>
<tr class="memdesc:gac8459be067bf7aa8a5732eb62e119226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a previously-created async I/O task queue.  <br /></td></tr>
<tr class="separator:gac8459be067bf7aa8a5732eb62e119226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9887afa67e69a51105f87511a5cfc60" id="r_gae9887afa67e69a51105f87511a5cfc60"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="group__CategoryAsyncIO.html#ga49382059be2b9dd333b2b43bdf686717">AsyncIOOutcome</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#gae9887afa67e69a51105f87511a5cfc60">SDL::GetAsyncIOResult</a> (<a class="el" href="structSDL_1_1AsyncIOQueueParam.html">AsyncIOQueueParam</a> queue)</td></tr>
<tr class="memdesc:gae9887afa67e69a51105f87511a5cfc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query an async I/O task queue for completed tasks.  <br /></td></tr>
<tr class="separator:gae9887afa67e69a51105f87511a5cfc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69abe8fddcec99a149055627a39bfcaa" id="r_ga69abe8fddcec99a149055627a39bfcaa"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="group__CategoryAsyncIO.html#ga49382059be2b9dd333b2b43bdf686717">AsyncIOOutcome</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#ga69abe8fddcec99a149055627a39bfcaa">SDL::WaitAsyncIOResult</a> (<a class="el" href="structSDL_1_1AsyncIOQueueParam.html">AsyncIOQueueParam</a> queue, <a class="el" href="group__CategoryStdinc.html#ga5765477d75fe29a5fb40cb8e8f6cc68f">Milliseconds</a> timeout)</td></tr>
<tr class="memdesc:ga69abe8fddcec99a149055627a39bfcaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until an async I/O task queue has a completed task.  <br /></td></tr>
<tr class="separator:ga69abe8fddcec99a149055627a39bfcaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f642e5d636791ad3d45c0c30304ae7d" id="r_ga0f642e5d636791ad3d45c0c30304ae7d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="group__CategoryAsyncIO.html#ga49382059be2b9dd333b2b43bdf686717">AsyncIOOutcome</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#ga0f642e5d636791ad3d45c0c30304ae7d">SDL::WaitAsyncIOResult</a> (<a class="el" href="structSDL_1_1AsyncIOQueueParam.html">AsyncIOQueueParam</a> queue)</td></tr>
<tr class="memdesc:ga0f642e5d636791ad3d45c0c30304ae7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until an async I/O task queue has a completed task.  <br /></td></tr>
<tr class="separator:ga0f642e5d636791ad3d45c0c30304ae7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32cebf01af5fd6ebe70f53e175a54b0a" id="r_ga32cebf01af5fd6ebe70f53e175a54b0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#ga32cebf01af5fd6ebe70f53e175a54b0a">SDL::SignalAsyncIOQueue</a> (<a class="el" href="structSDL_1_1AsyncIOQueueParam.html">AsyncIOQueueParam</a> queue)</td></tr>
<tr class="memdesc:ga32cebf01af5fd6ebe70f53e175a54b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake up any threads that are blocking in <a class="el" href="group__CategoryAsyncIO.html#gaae336352719b9bfbed2c9d306146ed76" title="Block until an async I/O task queue has a completed task.">AsyncIOQueue.WaitResult()</a>.  <br /></td></tr>
<tr class="separator:ga32cebf01af5fd6ebe70f53e175a54b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b454d36be59b621326e9a8314e8c500" id="r_ga9b454d36be59b621326e9a8314e8c500"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#ga9b454d36be59b621326e9a8314e8c500">SDL::LoadFileAsync</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> file, <a class="el" href="structSDL_1_1AsyncIOQueueParam.html">AsyncIOQueueParam</a> queue, void *userdata)</td></tr>
<tr class="memdesc:ga9b454d36be59b621326e9a8314e8c500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all the data from a file path, asynchronously.  <br /></td></tr>
<tr class="separator:ga9b454d36be59b621326e9a8314e8c500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05ab82a91d072c192224b472fc95f48a" id="r_ga05ab82a91d072c192224b472fc95f48a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategoryStdinc.html#ga2feaa627ab3612aab570e5a359b1e637">Sint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#ga05ab82a91d072c192224b472fc95f48a">SDL::AsyncIO::GetSize</a> ()</td></tr>
<tr class="memdesc:ga05ab82a91d072c192224b472fc95f48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to get the size of the data stream in an <a class="el" href="classSDL_1_1AsyncIO.html" title="The asynchronous I/O operation structure.">AsyncIO</a>.  <br /></td></tr>
<tr class="separator:ga05ab82a91d072c192224b472fc95f48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga593fd7f4b1fbf36f46b783480f49a8f6" id="r_ga593fd7f4b1fbf36f46b783480f49a8f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#ga593fd7f4b1fbf36f46b783480f49a8f6">SDL::AsyncIO::Read</a> (void *ptr, <a class="el" href="group__CategoryStdinc.html#gad1c0b6121968b312e1133bcf0db2a2b0">Uint64</a> offset, <a class="el" href="group__CategoryStdinc.html#gad1c0b6121968b312e1133bcf0db2a2b0">Uint64</a> size, <a class="el" href="structSDL_1_1AsyncIOQueueParam.html">AsyncIOQueueParam</a> queue, void *userdata)</td></tr>
<tr class="memdesc:ga593fd7f4b1fbf36f46b783480f49a8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an async read.  <br /></td></tr>
<tr class="separator:ga593fd7f4b1fbf36f46b783480f49a8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab67259533ebe86aeee8fc41d12008845" id="r_gab67259533ebe86aeee8fc41d12008845"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#gab67259533ebe86aeee8fc41d12008845">SDL::AsyncIO::Write</a> (void *ptr, <a class="el" href="group__CategoryStdinc.html#gad1c0b6121968b312e1133bcf0db2a2b0">Uint64</a> offset, <a class="el" href="group__CategoryStdinc.html#gad1c0b6121968b312e1133bcf0db2a2b0">Uint64</a> size, <a class="el" href="structSDL_1_1AsyncIOQueueParam.html">AsyncIOQueueParam</a> queue, void *userdata)</td></tr>
<tr class="memdesc:gab67259533ebe86aeee8fc41d12008845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an async write.  <br /></td></tr>
<tr class="separator:gab67259533ebe86aeee8fc41d12008845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga196649a0d680ddf71bb832dc6573d768" id="r_ga196649a0d680ddf71bb832dc6573d768"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#ga196649a0d680ddf71bb832dc6573d768">SDL::AsyncIO::Close</a> (bool flush, <a class="el" href="structSDL_1_1AsyncIOQueueParam.html">AsyncIOQueueParam</a> queue, void *userdata)</td></tr>
<tr class="memdesc:ga196649a0d680ddf71bb832dc6573d768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close and free any allocated resources for an async I/O object.  <br /></td></tr>
<tr class="separator:ga196649a0d680ddf71bb832dc6573d768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3376f8e510bc086a6b87784dd68546b5" id="r_ga3376f8e510bc086a6b87784dd68546b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#ga3376f8e510bc086a6b87784dd68546b5">SDL::AsyncIOQueue::Destroy</a> ()</td></tr>
<tr class="memdesc:ga3376f8e510bc086a6b87784dd68546b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a previously-created async I/O task queue.  <br /></td></tr>
<tr class="separator:ga3376f8e510bc086a6b87784dd68546b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86449618e7c0a06bd10e1d820c0fb4f8" id="r_ga86449618e7c0a06bd10e1d820c0fb4f8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="group__CategoryAsyncIO.html#ga49382059be2b9dd333b2b43bdf686717">AsyncIOOutcome</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#ga86449618e7c0a06bd10e1d820c0fb4f8">SDL::AsyncIOQueue::GetResult</a> ()</td></tr>
<tr class="memdesc:ga86449618e7c0a06bd10e1d820c0fb4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query an async I/O task queue for completed tasks.  <br /></td></tr>
<tr class="separator:ga86449618e7c0a06bd10e1d820c0fb4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a50f074ccb4deade54eb3361930a5cd" id="r_ga9a50f074ccb4deade54eb3361930a5cd"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="group__CategoryAsyncIO.html#ga49382059be2b9dd333b2b43bdf686717">AsyncIOOutcome</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#ga9a50f074ccb4deade54eb3361930a5cd">SDL::AsyncIOQueue::WaitResult</a> (<a class="el" href="group__CategoryStdinc.html#ga5765477d75fe29a5fb40cb8e8f6cc68f">Milliseconds</a> timeout)</td></tr>
<tr class="memdesc:ga9a50f074ccb4deade54eb3361930a5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until an async I/O task queue has a completed task.  <br /></td></tr>
<tr class="separator:ga9a50f074ccb4deade54eb3361930a5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae336352719b9bfbed2c9d306146ed76" id="r_gaae336352719b9bfbed2c9d306146ed76"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="group__CategoryAsyncIO.html#ga49382059be2b9dd333b2b43bdf686717">AsyncIOOutcome</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#gaae336352719b9bfbed2c9d306146ed76">SDL::AsyncIOQueue::WaitResult</a> ()</td></tr>
<tr class="memdesc:gaae336352719b9bfbed2c9d306146ed76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until an async I/O task queue has a completed task.  <br /></td></tr>
<tr class="separator:gaae336352719b9bfbed2c9d306146ed76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79c948c3e97531c8ef690be7bbef12c3" id="r_ga79c948c3e97531c8ef690be7bbef12c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#ga79c948c3e97531c8ef690be7bbef12c3">SDL::AsyncIOQueue::Signal</a> ()</td></tr>
<tr class="memdesc:ga79c948c3e97531c8ef690be7bbef12c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake up any threads that are blocking in <a class="el" href="group__CategoryAsyncIO.html#gaae336352719b9bfbed2c9d306146ed76" title="Block until an async I/O task queue has a completed task.">AsyncIOQueue.WaitResult()</a>.  <br /></td></tr>
<tr class="separator:ga79c948c3e97531c8ef690be7bbef12c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga70a329ff5135f9603b8eedc940353a68" id="r_ga70a329ff5135f9603b8eedc940353a68"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryAsyncIO.html#ga5ced0daa86e13c8fb857a7de2d3ea3fc">AsyncIOTaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#ga70a329ff5135f9603b8eedc940353a68">SDL::ASYNCIO_TASK_READ</a></td></tr>
<tr class="memdesc:ga70a329ff5135f9603b8eedc940353a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">A read operation.  <br /></td></tr>
<tr class="separator:ga70a329ff5135f9603b8eedc940353a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb532ea0d531113768d7158ab35e48ca" id="r_gaeb532ea0d531113768d7158ab35e48ca"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryAsyncIO.html#ga5ced0daa86e13c8fb857a7de2d3ea3fc">AsyncIOTaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#gaeb532ea0d531113768d7158ab35e48ca">SDL::ASYNCIO_TASK_WRITE</a></td></tr>
<tr class="memdesc:gaeb532ea0d531113768d7158ab35e48ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">A write operation.  <br /></td></tr>
<tr class="separator:gaeb532ea0d531113768d7158ab35e48ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51c704b04fd3ca41d0f390dd07b72a2a" id="r_ga51c704b04fd3ca41d0f390dd07b72a2a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryAsyncIO.html#ga5ced0daa86e13c8fb857a7de2d3ea3fc">AsyncIOTaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#ga51c704b04fd3ca41d0f390dd07b72a2a">SDL::ASYNCIO_TASK_CLOSE</a></td></tr>
<tr class="memdesc:ga51c704b04fd3ca41d0f390dd07b72a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A close operation.  <br /></td></tr>
<tr class="separator:ga51c704b04fd3ca41d0f390dd07b72a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97f9595a1d2191f4e24ca2f931442610" id="r_ga97f9595a1d2191f4e24ca2f931442610"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryAsyncIO.html#gaf01bc0057e6d26f43fcb866acc7b5403">AsyncIOResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#ga97f9595a1d2191f4e24ca2f931442610">SDL::ASYNCIO_COMPLETE</a></td></tr>
<tr class="memdesc:ga97f9595a1d2191f4e24ca2f931442610"><td class="mdescLeft">&#160;</td><td class="mdescRight">request was completed without error  <br /></td></tr>
<tr class="separator:ga97f9595a1d2191f4e24ca2f931442610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab67ec500dd06904ebeae82b80056ffe1" id="r_gab67ec500dd06904ebeae82b80056ffe1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryAsyncIO.html#gaf01bc0057e6d26f43fcb866acc7b5403">AsyncIOResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#gab67ec500dd06904ebeae82b80056ffe1">SDL::ASYNCIO_FAILURE</a></td></tr>
<tr class="memdesc:gab67ec500dd06904ebeae82b80056ffe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">request failed for some reason; check <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a>!  <br /></td></tr>
<tr class="separator:gab67ec500dd06904ebeae82b80056ffe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga443ae4dcc45af2ede2693a09bd40d3cb" id="r_ga443ae4dcc45af2ede2693a09bd40d3cb"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__CategoryAsyncIO.html#gaf01bc0057e6d26f43fcb866acc7b5403">AsyncIOResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAsyncIO.html#ga443ae4dcc45af2ede2693a09bd40d3cb">SDL::ASYNCIO_CANCELED</a></td></tr>
<tr class="memdesc:ga443ae4dcc45af2ede2693a09bd40d3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">request was canceled before completing.  <br /></td></tr>
<tr class="separator:ga443ae4dcc45af2ede2693a09bd40d3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This allows an app to read or write files without waiting for data to actually transfer; the functions that request I/O never block while the request is fulfilled.</p>
<p>Instead, the data moves in the background and the app can check for results at their leisure.</p>
<p>This is more complicated than just reading and writing files in a synchronous way, but it can allow for more efficiency, and never having framerate drops as the hard drive catches up, etc.</p>
<p>The general usage pattern for async I/O is:</p>
<ul>
<li>Create one or more <a class="el" href="classSDL_1_1AsyncIOQueue.html" title="A queue of completed asynchronous I/O tasks.">AsyncIOQueue</a> objects.</li>
<li>Open files with <a class="el" href="classSDL_1_1AsyncIO.html#aab86f995bf5ae172d6310f8bc4efacc4" title="Default ctor.">AsyncIO.AsyncIO</a>.</li>
<li>Start I/O tasks to the files with <a class="el" href="group__CategoryAsyncIO.html#ga593fd7f4b1fbf36f46b783480f49a8f6" title="Start an async read.">AsyncIO.Read</a> or <a class="el" href="group__CategoryAsyncIO.html#gab67259533ebe86aeee8fc41d12008845" title="Start an async write.">AsyncIO.Write</a>, putting those tasks into one of the queues.</li>
<li>Later on, use <a class="el" href="group__CategoryAsyncIO.html#ga86449618e7c0a06bd10e1d820c0fb4f8" title="Query an async I/O task queue for completed tasks.">AsyncIOQueue.GetResult</a> on a queue to see if any task is finished without blocking. Tasks might finish in any order with success or failure.</li>
<li>When all your tasks are done, close the file with <a class="el" href="group__CategoryAsyncIO.html#ga196649a0d680ddf71bb832dc6573d768" title="Close and free any allocated resources for an async I/O object.">AsyncIO.Close</a>. This also generates a task, since it might flush data to disk!</li>
</ul>
<p>This all works, without blocking, in a single thread, but one can also wait on a queue in a background thread, sleeping until new results have arrived:</p>
<ul>
<li>Call <a class="el" href="group__CategoryAsyncIO.html#ga9a50f074ccb4deade54eb3361930a5cd" title="Block until an async I/O task queue has a completed task.">AsyncIOQueue.WaitResult</a> from one or more threads to efficiently block until new tasks complete.</li>
<li>When shutting down, call <a class="el" href="group__CategoryAsyncIO.html#ga79c948c3e97531c8ef690be7bbef12c3" title="Wake up any threads that are blocking in AsyncIOQueue.WaitResult().">AsyncIOQueue.Signal</a> to unblock any sleeping threads despite there being no new tasks completed.</li>
</ul>
<p>And, of course, to match the synchronous LoadFile, we offer LoadFileAsync as a convenience function. This will handle allocating a buffer, slurping in the file data, and null-terminating it; you still check for results later.</p>
<p>Behind the scenes, <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> will use newer, efficient APIs on platforms that support them: Linux's io_uring and Windows 11's IoRing, for example. If those technologies aren't available, <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> will offload the work to a thread pool that will manage otherwise-synchronous loads without blocking the app.</p>
<h2><a class="anchor" id="best-practices"></a>
Best Practices</h2>
<p>Simple non-blocking I/O&ndash;for an app that just wants to pick up data whenever it's ready without losing framerate waiting on disks to spin&ndash;can use whatever pattern works well for the program. In this case, simply call <a class="el" href="group__CategoryAsyncIO.html#ga593fd7f4b1fbf36f46b783480f49a8f6" title="Start an async read.">AsyncIO.Read</a>, or maybe LoadFileAsync, as needed. Once a frame, call <a class="el" href="group__CategoryAsyncIO.html#ga86449618e7c0a06bd10e1d820c0fb4f8" title="Query an async I/O task queue for completed tasks.">AsyncIOQueue.GetResult</a> to check for any completed tasks and deal with the data as it arrives.</p>
<p>If two separate pieces of the same program need their own I/O, it is legal for each to create their own queue. This will prevent either piece from accidentally consuming the other's completed tasks. Each queue does require some amount of resources, but it is not an overwhelming cost. Do not make a queue for each task, however. It is better to put many tasks into a single queue. They will be reported in order of completion, not in the order they were submitted, so it doesn't generally matter what order tasks are started.</p>
<p>One async I/O queue can be shared by multiple threads, or one thread can have more than one queue, but the most efficient way&ndash;if ruthless efficiency is the goal&ndash;is to have one queue per thread, with multiple threads working in parallel, and attempt to keep each queue loaded with tasks that are both started by and consumed by the same thread. On modern platforms that can use newer interfaces, this can keep data flowing as efficiently as possible all the way from storage hardware to the app, with no contention between threads for access to the same queue.</p>
<p>Written data is not guaranteed to make it to physical media by the time a closing task is completed, unless <a class="el" href="group__CategoryAsyncIO.html#ga196649a0d680ddf71bb832dc6573d768" title="Close and free any allocated resources for an async I/O object.">AsyncIO.Close</a> is called with its <code>flush</code> parameter set to true, which is to say that a successful result here can still result in lost data during an unfortunately-timed power outage if not flushed. However, flushing will take longer and may be unnecessary, depending on the app's needs. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga49382059be2b9dd333b2b43bdf686717" name="ga49382059be2b9dd333b2b43bdf686717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49382059be2b9dd333b2b43bdf686717">&#9670;&#160;</a></span>AsyncIOOutcome</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryAsyncIO.html#ga49382059be2b9dd333b2b43bdf686717">SDL::AsyncIOOutcome</a> = typedef SDL_AsyncIOOutcome</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaf01bc0057e6d26f43fcb866acc7b5403" name="gaf01bc0057e6d26f43fcb866acc7b5403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf01bc0057e6d26f43fcb866acc7b5403">&#9670;&#160;</a></span>AsyncIOResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryAsyncIO.html#gaf01bc0057e6d26f43fcb866acc7b5403">SDL::AsyncIOResult</a> = typedef SDL_AsyncIOResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga5ced0daa86e13c8fb857a7de2d3ea3fc" name="ga5ced0daa86e13c8fb857a7de2d3ea3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ced0daa86e13c8fb857a7de2d3ea3fc">&#9670;&#160;</a></span>AsyncIOTaskType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryAsyncIO.html#ga5ced0daa86e13c8fb857a7de2d3ea3fc">SDL::AsyncIOTaskType</a> = typedef SDL_AsyncIOTaskType</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This enum is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga63ca43e4936d353920099e2755ca072f" name="ga63ca43e4936d353920099e2755ca072f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63ca43e4936d353920099e2755ca072f">&#9670;&#160;</a></span>AsyncIOFromFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1AsyncIO.html">AsyncIO</a> SDL::AsyncIOFromFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <code>mode</code> string understands the following values:</p>
<ul>
<li>"r": Open a file for reading only. It must exist.</li>
<li>"w": Open a file for writing only. It will create missing files or truncate existing ones.</li>
<li>"r+": Open a file for update both reading and writing. The file must exist.</li>
<li>"w+": Create an empty file for both reading and writing. If a file with the same name already exists its content is erased and the file is treated as a new empty file.</li>
</ul>
<p>There is no "b" mode, as there is only "binary" style I/O, and no "a" mode for appending, since you specify the position when starting a task.</p>
<p>This function supports Unicode filenames, but they must be encoded in UTF-8 format, regardless of the underlying operating system.</p>
<p>This call is <em>not</em> asynchronous; it will open the file before returning, under the assumption that doing so is generally a fast operation. Future reads and writes to the opened file will be async, however.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>a UTF-8 string representing the filename to open. </td></tr>
    <tr><td class="paramname">mode</td><td>an ASCII string representing the mode to be used for opening the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="classSDL_1_1AsyncIO.html" title="The asynchronous I/O operation structure.">AsyncIO</a> structure that is created or nullptr on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAsyncIO.html#ga196649a0d680ddf71bb832dc6573d768" title="Close and free any allocated resources for an async I/O object.">AsyncIO.Close</a> </dd>
<dd>
<a class="el" href="group__CategoryAsyncIO.html#ga593fd7f4b1fbf36f46b783480f49a8f6" title="Start an async read.">AsyncIO.Read</a> </dd>
<dd>
<a class="el" href="group__CategoryAsyncIO.html#gab67259533ebe86aeee8fc41d12008845" title="Start an async write.">AsyncIO.Write</a> </dd></dl>

</div>
</div>
<a id="ga196649a0d680ddf71bb832dc6573d768" name="ga196649a0d680ddf71bb832dc6573d768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga196649a0d680ddf71bb832dc6573d768">&#9670;&#160;</a></span>Close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::AsyncIO::Close </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1AsyncIOQueueParam.html">AsyncIOQueueParam</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Closing a file is <em>also</em> an asynchronous task! If a write failure were to happen during the closing process, for example, the task results will report it as usual.</p>
<p>Closing a file that has been written to does not guarantee the data has made it to physical media; it may remain in the operating system's file cache, for later writing to disk. This means that a successfully-closed file can be lost if the system crashes or loses power in this small window. To prevent this, call this function with the <code>flush</code> parameter set to true. This will make the operation take longer, and perhaps increase system load in general, but a successful result guarantees that the data has made it to physical storage. Don't use this for temporary files, caches, and unimportant data, and definitely use it for crucial irreplaceable files, like game saves.</p>
<p>This function guarantees that the close will happen after any other pending tasks to <code>asyncio</code>, so it's safe to open a file, start several operations, close the file immediately, then check for all results later. This function will not block until the tasks have completed.</p>
<p>Once this function returns true, <code>asyncio</code> is no longer valid, regardless of any future outcomes. Any completed tasks might still contain this pointer in their AsyncIOOutcome data, in case the app was using this value to track information, but it should not be used again.</p>
<p>If this function returns false, the close wasn't started at all, and it's safe to attempt to close again later.</p>
<p>An <a class="el" href="classSDL_1_1AsyncIOQueue.html" title="A queue of completed asynchronous I/O tasks.">AsyncIOQueue</a> must be specified. The newly-created task will be added to it when it completes its work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flush</td><td>true if data should sync to disk before the task completes. </td></tr>
    <tr><td class="paramname">queue</td><td>a queue to add the new <a class="el" href="classSDL_1_1AsyncIO.html" title="The asynchronous I/O operation structure.">AsyncIO</a> to. </td></tr>
    <tr><td class="paramname">userdata</td><td>an app-defined pointer that will be provided with the task results. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread, but two threads should not attempt to close the same object.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gae999d5100fe32c334f7145af38591ca4" name="gae999d5100fe32c334f7145af38591ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae999d5100fe32c334f7145af38591ca4">&#9670;&#160;</a></span>CloseAsyncIO()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::CloseAsyncIO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryAsyncIO.html#ga933bd971d2ccad5e099dc7c6d95825c4">AsyncIORaw</a>&#160;</td>
          <td class="paramname"><em>asyncio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1AsyncIOQueueParam.html">AsyncIOQueueParam</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Closing a file is <em>also</em> an asynchronous task! If a write failure were to happen during the closing process, for example, the task results will report it as usual.</p>
<p>Closing a file that has been written to does not guarantee the data has made it to physical media; it may remain in the operating system's file cache, for later writing to disk. This means that a successfully-closed file can be lost if the system crashes or loses power in this small window. To prevent this, call this function with the <code>flush</code> parameter set to true. This will make the operation take longer, and perhaps increase system load in general, but a successful result guarantees that the data has made it to physical storage. Don't use this for temporary files, caches, and unimportant data, and definitely use it for crucial irreplaceable files, like game saves.</p>
<p>This function guarantees that the close will happen after any other pending tasks to <code>asyncio</code>, so it's safe to open a file, start several operations, close the file immediately, then check for all results later. This function will not block until the tasks have completed.</p>
<p>Once this function returns true, <code>asyncio</code> is no longer valid, regardless of any future outcomes. Any completed tasks might still contain this pointer in their AsyncIOOutcome data, in case the app was using this value to track information, but it should not be used again.</p>
<p>If this function returns false, the close wasn't started at all, and it's safe to attempt to close again later.</p>
<p>An <a class="el" href="classSDL_1_1AsyncIOQueue.html" title="A queue of completed asynchronous I/O tasks.">AsyncIOQueue</a> must be specified. The newly-created task will be added to it when it completes its work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asyncio</td><td>a pointer to an <a class="el" href="classSDL_1_1AsyncIO.html" title="The asynchronous I/O operation structure.">AsyncIO</a> structure to close. </td></tr>
    <tr><td class="paramname">flush</td><td>true if data should sync to disk before the task completes. </td></tr>
    <tr><td class="paramname">queue</td><td>a queue to add the new <a class="el" href="classSDL_1_1AsyncIO.html" title="The asynchronous I/O operation structure.">AsyncIO</a> to. </td></tr>
    <tr><td class="paramname">userdata</td><td>an app-defined pointer that will be provided with the task results. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread, but two threads should not attempt to close the same object.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga45a5878f8fae598039744c57812e0996" name="ga45a5878f8fae598039744c57812e0996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45a5878f8fae598039744c57812e0996">&#9670;&#160;</a></span>CreateAsyncIOQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1AsyncIOQueue.html">AsyncIOQueue</a> SDL::CreateAsyncIOQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Async I/O operations are assigned to a queue when started. The queue can be checked for completed tasks thereafter.</p>
<dl class="section return"><dt>Returns</dt><dd>a new task queue object or nullptr if there was an error; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAsyncIO.html#ga3376f8e510bc086a6b87784dd68546b5" title="Destroy a previously-created async I/O task queue.">AsyncIOQueue.Destroy</a> </dd>
<dd>
<a class="el" href="group__CategoryAsyncIO.html#ga86449618e7c0a06bd10e1d820c0fb4f8" title="Query an async I/O task queue for completed tasks.">AsyncIOQueue.GetResult</a> </dd>
<dd>
<a class="el" href="group__CategoryAsyncIO.html#ga9a50f074ccb4deade54eb3361930a5cd" title="Block until an async I/O task queue has a completed task.">AsyncIOQueue.WaitResult</a> </dd></dl>

</div>
</div>
<a id="ga3376f8e510bc086a6b87784dd68546b5" name="ga3376f8e510bc086a6b87784dd68546b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3376f8e510bc086a6b87784dd68546b5">&#9670;&#160;</a></span>Destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::AsyncIOQueue::Destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If there are still tasks pending for this queue, this call will block until those tasks are finished. All those tasks will be deallocated. Their results will be lost to the app.</p>
<p>Any pending reads from <a class="el" href="group__CategoryAsyncIO.html#ga9b454d36be59b621326e9a8314e8c500" title="Load all the data from a file path, asynchronously.">LoadFileAsync()</a> that are still in this queue will have their buffers deallocated by this function, to prevent a memory leak.</p>
<p>Once this function is called, the queue is no longer valid and should not be used, including by other threads that might access it while destruction is blocking on pending tasks.</p>
<p>Do not destroy a queue that still has threads waiting on it through <a class="el" href="group__CategoryAsyncIO.html#gaae336352719b9bfbed2c9d306146ed76" title="Block until an async I/O task queue has a completed task.">AsyncIOQueue.WaitResult()</a>. You can call <a class="el" href="group__CategoryAsyncIO.html#ga79c948c3e97531c8ef690be7bbef12c3" title="Wake up any threads that are blocking in AsyncIOQueue.WaitResult().">AsyncIOQueue.Signal()</a> first to unblock those threads, and take measures (such as <a class="el" href="group__CategoryThread.html#gab66600b4af530b39983b071d4ff4c812" title="Wait for a thread to finish.">Thread.Wait()</a>) to make sure they have finished their wait and won't wait on the queue again.</p>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread, so long as no other thread is waiting on the queue with <a class="el" href="group__CategoryAsyncIO.html#ga9a50f074ccb4deade54eb3361930a5cd" title="Block until an async I/O task queue has a completed task.">AsyncIOQueue.WaitResult</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gac8459be067bf7aa8a5732eb62e119226" name="gac8459be067bf7aa8a5732eb62e119226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8459be067bf7aa8a5732eb62e119226">&#9670;&#160;</a></span>DestroyAsyncIOQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::DestroyAsyncIOQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryAsyncIO.html#gaff7950b181335ce4b2adf2a1b7ef2646">AsyncIOQueueRaw</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If there are still tasks pending for this queue, this call will block until those tasks are finished. All those tasks will be deallocated. Their results will be lost to the app.</p>
<p>Any pending reads from <a class="el" href="group__CategoryAsyncIO.html#ga9b454d36be59b621326e9a8314e8c500" title="Load all the data from a file path, asynchronously.">LoadFileAsync()</a> that are still in this queue will have their buffers deallocated by this function, to prevent a memory leak.</p>
<p>Once this function is called, the queue is no longer valid and should not be used, including by other threads that might access it while destruction is blocking on pending tasks.</p>
<p>Do not destroy a queue that still has threads waiting on it through <a class="el" href="group__CategoryAsyncIO.html#gaae336352719b9bfbed2c9d306146ed76" title="Block until an async I/O task queue has a completed task.">AsyncIOQueue.WaitResult()</a>. You can call <a class="el" href="group__CategoryAsyncIO.html#ga79c948c3e97531c8ef690be7bbef12c3" title="Wake up any threads that are blocking in AsyncIOQueue.WaitResult().">AsyncIOQueue.Signal()</a> first to unblock those threads, and take measures (such as <a class="el" href="group__CategoryThread.html#gab66600b4af530b39983b071d4ff4c812" title="Wait for a thread to finish.">Thread.Wait()</a>) to make sure they have finished their wait and won't wait on the queue again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>the task queue to destroy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread, so long as no other thread is waiting on the queue with <a class="el" href="group__CategoryAsyncIO.html#ga9a50f074ccb4deade54eb3361930a5cd" title="Block until an async I/O task queue has a completed task.">AsyncIOQueue.WaitResult</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gae9887afa67e69a51105f87511a5cfc60" name="gae9887afa67e69a51105f87511a5cfc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9887afa67e69a51105f87511a5cfc60">&#9670;&#160;</a></span>GetAsyncIOResult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="group__CategoryAsyncIO.html#ga49382059be2b9dd333b2b43bdf686717">AsyncIOOutcome</a> &gt; SDL::GetAsyncIOResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1AsyncIOQueueParam.html">AsyncIOQueueParam</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If a task assigned to this queue has finished, this will return true and fill in <code>outcome</code> with the details of the task. If no task in the queue has finished, this function will return false. This function does not block.</p>
<p>If a task has completed, this function will free its resources and the task pointer will no longer be valid. The task will be removed from the queue.</p>
<p>It is safe for multiple threads to call this function on the same queue at once; a completed task will only go to one of the threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>the async I/O task queue to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of a finished task if a task has completed, std::nullopt otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAsyncIO.html#ga9a50f074ccb4deade54eb3361930a5cd" title="Block until an async I/O task queue has a completed task.">AsyncIOQueue.WaitResult</a> </dd></dl>

</div>
</div>
<a id="gafd0a645e5debeb2997784f68a7d87162" name="gafd0a645e5debeb2997784f68a7d87162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd0a645e5debeb2997784f68a7d87162">&#9670;&#160;</a></span>GetAsyncIOSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategoryStdinc.html#ga2feaa627ab3612aab570e5a359b1e637">Sint64</a> SDL::GetAsyncIOSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1AsyncIOParam.html">AsyncIOParam</a>&#160;</td>
          <td class="paramname"><em>asyncio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This call is <em>not</em> asynchronous; it assumes that obtaining this info is a non-blocking operation in most reasonable cases.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asyncio</td><td>the <a class="el" href="classSDL_1_1AsyncIO.html" title="The asynchronous I/O operation structure.">AsyncIO</a> to get the size of the data stream from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the data stream in the <a class="el" href="classSDL_1_1IOStream.html" title="The read/write operation structure.">IOStream</a> on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga86449618e7c0a06bd10e1d820c0fb4f8" name="ga86449618e7c0a06bd10e1d820c0fb4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86449618e7c0a06bd10e1d820c0fb4f8">&#9670;&#160;</a></span>GetResult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="group__CategoryAsyncIO.html#ga49382059be2b9dd333b2b43bdf686717">AsyncIOOutcome</a> &gt; SDL::AsyncIOQueue::GetResult </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If a task assigned to this queue has finished, this will return true and fill in <code>outcome</code> with the details of the task. If no task in the queue has finished, this function will return false. This function does not block.</p>
<p>If a task has completed, this function will free its resources and the task pointer will no longer be valid. The task will be removed from the queue.</p>
<p>It is safe for multiple threads to call this function on the same queue at once; a completed task will only go to one of the threads.</p>
<dl class="section return"><dt>Returns</dt><dd>details of a finished task if a task has completed, std::nullopt otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAsyncIO.html#ga9a50f074ccb4deade54eb3361930a5cd" title="Block until an async I/O task queue has a completed task.">AsyncIOQueue.WaitResult</a> </dd></dl>

</div>
</div>
<a id="ga05ab82a91d072c192224b472fc95f48a" name="ga05ab82a91d072c192224b472fc95f48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05ab82a91d072c192224b472fc95f48a">&#9670;&#160;</a></span>GetSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategoryStdinc.html#ga2feaa627ab3612aab570e5a359b1e637">Sint64</a> SDL::AsyncIO::GetSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This call is <em>not</em> asynchronous; it assumes that obtaining this info is a non-blocking operation in most reasonable cases.</p>
<dl class="section return"><dt>Returns</dt><dd>the size of the data stream in the <a class="el" href="classSDL_1_1IOStream.html" title="The read/write operation structure.">IOStream</a> on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga9b454d36be59b621326e9a8314e8c500" name="ga9b454d36be59b621326e9a8314e8c500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b454d36be59b621326e9a8314e8c500">&#9670;&#160;</a></span>LoadFileAsync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::LoadFileAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1AsyncIOQueueParam.html">AsyncIOQueueParam</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns as quickly as possible; it does not wait for the read to complete. On a successful return, this work will continue in the background. If the work begins, even failure is asynchronous: a failing return value from this function only means the work couldn't start at all.</p>
<p>The data is allocated with a zero byte at the end (null terminated) for convenience. This extra byte is not included in AsyncIOOutcome's bytes_transferred value.</p>
<p>This function will allocate the buffer to contain the file. It must be deallocated by calling <a class="el" href="group__CategoryStdinc.html#gadfa01257ca1f966fffb72f002db27fa6" title="Free allocated memory.">free()</a> on AsyncIOOutcome's buffer field after completion.</p>
<p>An <a class="el" href="classSDL_1_1AsyncIOQueue.html" title="A queue of completed asynchronous I/O tasks.">AsyncIOQueue</a> must be specified. The newly-created task will be added to it when it completes its work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the path to read all available data from. </td></tr>
    <tr><td class="paramname">queue</td><td>a queue to add the new <a class="el" href="classSDL_1_1AsyncIO.html" title="The asynchronous I/O operation structure.">AsyncIO</a> to. </td></tr>
    <tr><td class="paramname">userdata</td><td>an app-defined pointer that will be provided with the task results. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryIOStream.html#gab20c44553f40b839544c87f25f2f43d9" title="Load all the data from an SDL data stream.">IOStream.LoadFile</a> </dd></dl>

</div>
</div>
<a id="ga593fd7f4b1fbf36f46b783480f49a8f6" name="ga593fd7f4b1fbf36f46b783480f49a8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga593fd7f4b1fbf36f46b783480f49a8f6">&#9670;&#160;</a></span>Read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::AsyncIO::Read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gad1c0b6121968b312e1133bcf0db2a2b0">Uint64</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gad1c0b6121968b312e1133bcf0db2a2b0">Uint64</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1AsyncIOQueueParam.html">AsyncIOQueueParam</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function reads up to <code>size</code> bytes from <code>offset</code> position in the data source to the area pointed at by <code>ptr</code>. This function may read less bytes than requested.</p>
<p>This function returns as quickly as possible; it does not wait for the read to complete. On a successful return, this work will continue in the background. If the work begins, even failure is asynchronous: a failing return value from this function only means the work couldn't start at all.</p>
<p><code>ptr</code> must remain available until the work is done, and may be accessed by the system at any time until then. Do not allocate it on the stack, as this might take longer than the life of the calling function to complete!</p>
<p>An <a class="el" href="classSDL_1_1AsyncIOQueue.html" title="A queue of completed asynchronous I/O tasks.">AsyncIOQueue</a> must be specified. The newly-created task will be added to it when it completes its work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>a pointer to a buffer to read data into. </td></tr>
    <tr><td class="paramname">offset</td><td>the position to start reading in the data source. </td></tr>
    <tr><td class="paramname">size</td><td>the number of bytes to read from the data source. </td></tr>
    <tr><td class="paramname">queue</td><td>a queue to add the new <a class="el" href="classSDL_1_1AsyncIO.html" title="The asynchronous I/O operation structure.">AsyncIO</a> to. </td></tr>
    <tr><td class="paramname">userdata</td><td>an app-defined pointer that will be provided with the task results. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAsyncIO.html#gab67259533ebe86aeee8fc41d12008845" title="Start an async write.">AsyncIO.Write</a> </dd>
<dd>
<a class="el" href="classSDL_1_1AsyncIOQueue.html#a6d56c206cc28918a5684d31789adef9b" title="Constructs from AsyncIOQueueParam.">AsyncIOQueue.AsyncIOQueue</a> </dd></dl>

</div>
</div>
<a id="gaf97914a74e52faed859fd7192e170eaf" name="gaf97914a74e52faed859fd7192e170eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf97914a74e52faed859fd7192e170eaf">&#9670;&#160;</a></span>ReadAsyncIO()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::ReadAsyncIO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1AsyncIOParam.html">AsyncIOParam</a>&#160;</td>
          <td class="paramname"><em>asyncio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gad1c0b6121968b312e1133bcf0db2a2b0">Uint64</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gad1c0b6121968b312e1133bcf0db2a2b0">Uint64</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1AsyncIOQueueParam.html">AsyncIOQueueParam</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function reads up to <code>size</code> bytes from <code>offset</code> position in the data source to the area pointed at by <code>ptr</code>. This function may read less bytes than requested.</p>
<p>This function returns as quickly as possible; it does not wait for the read to complete. On a successful return, this work will continue in the background. If the work begins, even failure is asynchronous: a failing return value from this function only means the work couldn't start at all.</p>
<p><code>ptr</code> must remain available until the work is done, and may be accessed by the system at any time until then. Do not allocate it on the stack, as this might take longer than the life of the calling function to complete!</p>
<p>An <a class="el" href="classSDL_1_1AsyncIOQueue.html" title="A queue of completed asynchronous I/O tasks.">AsyncIOQueue</a> must be specified. The newly-created task will be added to it when it completes its work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asyncio</td><td>a pointer to an <a class="el" href="classSDL_1_1AsyncIO.html" title="The asynchronous I/O operation structure.">AsyncIO</a> structure. </td></tr>
    <tr><td class="paramname">ptr</td><td>a pointer to a buffer to read data into. </td></tr>
    <tr><td class="paramname">offset</td><td>the position to start reading in the data source. </td></tr>
    <tr><td class="paramname">size</td><td>the number of bytes to read from the data source. </td></tr>
    <tr><td class="paramname">queue</td><td>a queue to add the new <a class="el" href="classSDL_1_1AsyncIO.html" title="The asynchronous I/O operation structure.">AsyncIO</a> to. </td></tr>
    <tr><td class="paramname">userdata</td><td>an app-defined pointer that will be provided with the task results. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAsyncIO.html#gab67259533ebe86aeee8fc41d12008845" title="Start an async write.">AsyncIO.Write</a> </dd>
<dd>
<a class="el" href="classSDL_1_1AsyncIOQueue.html#a6d56c206cc28918a5684d31789adef9b" title="Constructs from AsyncIOQueueParam.">AsyncIOQueue.AsyncIOQueue</a> </dd></dl>

</div>
</div>
<a id="ga79c948c3e97531c8ef690be7bbef12c3" name="ga79c948c3e97531c8ef690be7bbef12c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79c948c3e97531c8ef690be7bbef12c3">&#9670;&#160;</a></span>Signal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::AsyncIOQueue::Signal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will unblock any threads that are sleeping in a call to <a class="el" href="group__CategoryAsyncIO.html#ga9a50f074ccb4deade54eb3361930a5cd" title="Block until an async I/O task queue has a completed task.">AsyncIOQueue.WaitResult</a> for the specified queue, and cause them to return from that function.</p>
<p>This can be useful when destroying a queue to make sure nothing is touching it indefinitely. In this case, once this call completes, the caller should take measures to make sure any previously-blocked threads have returned from their wait and will not touch the queue again (perhaps by setting a flag to tell the threads to terminate and then using <a class="el" href="group__CategoryThread.html#gab66600b4af530b39983b071d4ff4c812" title="Wait for a thread to finish.">Thread.Wait()</a> to make sure they've done so).</p>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAsyncIO.html#ga9a50f074ccb4deade54eb3361930a5cd" title="Block until an async I/O task queue has a completed task.">AsyncIOQueue.WaitResult</a> </dd></dl>

</div>
</div>
<a id="ga32cebf01af5fd6ebe70f53e175a54b0a" name="ga32cebf01af5fd6ebe70f53e175a54b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32cebf01af5fd6ebe70f53e175a54b0a">&#9670;&#160;</a></span>SignalAsyncIOQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::SignalAsyncIOQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1AsyncIOQueueParam.html">AsyncIOQueueParam</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will unblock any threads that are sleeping in a call to <a class="el" href="group__CategoryAsyncIO.html#ga9a50f074ccb4deade54eb3361930a5cd" title="Block until an async I/O task queue has a completed task.">AsyncIOQueue.WaitResult</a> for the specified queue, and cause them to return from that function.</p>
<p>This can be useful when destroying a queue to make sure nothing is touching it indefinitely. In this case, once this call completes, the caller should take measures to make sure any previously-blocked threads have returned from their wait and will not touch the queue again (perhaps by setting a flag to tell the threads to terminate and then using <a class="el" href="group__CategoryThread.html#gab66600b4af530b39983b071d4ff4c812" title="Wait for a thread to finish.">Thread.Wait()</a> to make sure they've done so).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>the async I/O task queue to signal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAsyncIO.html#ga9a50f074ccb4deade54eb3361930a5cd" title="Block until an async I/O task queue has a completed task.">AsyncIOQueue.WaitResult</a> </dd></dl>

</div>
</div>
<a id="ga0f642e5d636791ad3d45c0c30304ae7d" name="ga0f642e5d636791ad3d45c0c30304ae7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f642e5d636791ad3d45c0c30304ae7d">&#9670;&#160;</a></span>WaitAsyncIOResult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="group__CategoryAsyncIO.html#ga49382059be2b9dd333b2b43bdf686717">AsyncIOOutcome</a> &gt; SDL::WaitAsyncIOResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1AsyncIOQueueParam.html">AsyncIOQueueParam</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function puts the calling thread to sleep until there a task assigned to the queue that has finished.</p>
<p>If a task assigned to the queue has finished, this will return true and fill in <code>outcome</code> with the details of the task. If no task in the queue has finished, this function will return false.</p>
<p>If a task has completed, this function will free its resources and the task pointer will no longer be valid. The task will be removed from the queue.</p>
<p>It is safe for multiple threads to call this function on the same queue at once; a completed task will only go to one of the threads.</p>
<p>Note that by the nature of various platforms, more than one waiting thread may wake to handle a single task, but only one will obtain it, so <code>timeoutMS</code> is a <em>maximum</em> wait time, and this function may return false sooner.</p>
<p>This function may return false if there was a system error, the OS inadvertently awoke multiple threads, or if <a class="el" href="group__CategoryAsyncIO.html#ga79c948c3e97531c8ef690be7bbef12c3" title="Wake up any threads that are blocking in AsyncIOQueue.WaitResult().">AsyncIOQueue.Signal()</a> was called to wake up all waiting threads without a finished task.</p>
<p>A timeout can be used to specify a maximum wait time, but rather than polling, it is possible to have a timeout of -1 to wait forever, and use <a class="el" href="group__CategoryAsyncIO.html#ga79c948c3e97531c8ef690be7bbef12c3" title="Wake up any threads that are blocking in AsyncIOQueue.WaitResult().">AsyncIOQueue.Signal()</a> to wake up the waiting threads later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>the async I/O task queue to wait on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of a finished task if a task has completed, std::nullopt otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAsyncIO.html#ga79c948c3e97531c8ef690be7bbef12c3" title="Wake up any threads that are blocking in AsyncIOQueue.WaitResult().">AsyncIOQueue.Signal</a> </dd></dl>

</div>
</div>
<a id="ga69abe8fddcec99a149055627a39bfcaa" name="ga69abe8fddcec99a149055627a39bfcaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69abe8fddcec99a149055627a39bfcaa">&#9670;&#160;</a></span>WaitAsyncIOResult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="group__CategoryAsyncIO.html#ga49382059be2b9dd333b2b43bdf686717">AsyncIOOutcome</a> &gt; SDL::WaitAsyncIOResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1AsyncIOQueueParam.html">AsyncIOQueueParam</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga5765477d75fe29a5fb40cb8e8f6cc68f">Milliseconds</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function puts the calling thread to sleep until there a task assigned to the queue that has finished.</p>
<p>If a task assigned to the queue has finished, this will return true and fill in <code>outcome</code> with the details of the task. If no task in the queue has finished, this function will return false.</p>
<p>If a task has completed, this function will free its resources and the task pointer will no longer be valid. The task will be removed from the queue.</p>
<p>It is safe for multiple threads to call this function on the same queue at once; a completed task will only go to one of the threads.</p>
<p>Note that by the nature of various platforms, more than one waiting thread may wake to handle a single task, but only one will obtain it, so <code>timeoutMS</code> is a <em>maximum</em> wait time, and this function may return false sooner.</p>
<p>This function may return false if there was a system error, the OS inadvertently awoke multiple threads, or if <a class="el" href="group__CategoryAsyncIO.html#ga79c948c3e97531c8ef690be7bbef12c3" title="Wake up any threads that are blocking in AsyncIOQueue.WaitResult().">AsyncIOQueue.Signal()</a> was called to wake up all waiting threads without a finished task.</p>
<p>A timeout can be used to specify a maximum wait time, but rather than polling, it is possible to have a timeout of -1 to wait forever, and use <a class="el" href="group__CategoryAsyncIO.html#ga79c948c3e97531c8ef690be7bbef12c3" title="Wake up any threads that are blocking in AsyncIOQueue.WaitResult().">AsyncIOQueue.Signal()</a> to wake up the waiting threads later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>the async I/O task queue to wait on. </td></tr>
    <tr><td class="paramname">timeout</td><td>the maximum time to wait, in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of a finished task if a task has completed, std::nullopt otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAsyncIO.html#ga79c948c3e97531c8ef690be7bbef12c3" title="Wake up any threads that are blocking in AsyncIOQueue.WaitResult().">AsyncIOQueue.Signal</a> </dd></dl>

</div>
</div>
<a id="gaae336352719b9bfbed2c9d306146ed76" name="gaae336352719b9bfbed2c9d306146ed76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae336352719b9bfbed2c9d306146ed76">&#9670;&#160;</a></span>WaitResult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="group__CategoryAsyncIO.html#ga49382059be2b9dd333b2b43bdf686717">AsyncIOOutcome</a> &gt; SDL::AsyncIOQueue::WaitResult </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function puts the calling thread to sleep until there a task assigned to the queue that has finished.</p>
<p>If a task assigned to the queue has finished, this will return true and fill in <code>outcome</code> with the details of the task. If no task in the queue has finished, this function will return false.</p>
<p>If a task has completed, this function will free its resources and the task pointer will no longer be valid. The task will be removed from the queue.</p>
<p>It is safe for multiple threads to call this function on the same queue at once; a completed task will only go to one of the threads.</p>
<p>Note that by the nature of various platforms, more than one waiting thread may wake to handle a single task, but only one will obtain it, so <code>timeoutMS</code> is a <em>maximum</em> wait time, and this function may return false sooner.</p>
<p>This function may return false if there was a system error, the OS inadvertently awoke multiple threads, or if <a class="el" href="group__CategoryAsyncIO.html#ga79c948c3e97531c8ef690be7bbef12c3" title="Wake up any threads that are blocking in AsyncIOQueue.WaitResult().">AsyncIOQueue.Signal()</a> was called to wake up all waiting threads without a finished task.</p>
<p>A timeout can be used to specify a maximum wait time, but rather than polling, it is possible to have a timeout of -1 to wait forever, and use <a class="el" href="group__CategoryAsyncIO.html#ga79c948c3e97531c8ef690be7bbef12c3" title="Wake up any threads that are blocking in AsyncIOQueue.WaitResult().">AsyncIOQueue.Signal()</a> to wake up the waiting threads later.</p>
<dl class="section return"><dt>Returns</dt><dd>details of a finished task if a task has completed, std::nullopt otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAsyncIO.html#ga79c948c3e97531c8ef690be7bbef12c3" title="Wake up any threads that are blocking in AsyncIOQueue.WaitResult().">AsyncIOQueue.Signal</a> </dd></dl>

</div>
</div>
<a id="ga9a50f074ccb4deade54eb3361930a5cd" name="ga9a50f074ccb4deade54eb3361930a5cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a50f074ccb4deade54eb3361930a5cd">&#9670;&#160;</a></span>WaitResult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="group__CategoryAsyncIO.html#ga49382059be2b9dd333b2b43bdf686717">AsyncIOOutcome</a> &gt; SDL::AsyncIOQueue::WaitResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga5765477d75fe29a5fb40cb8e8f6cc68f">Milliseconds</a>&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function puts the calling thread to sleep until there a task assigned to the queue that has finished.</p>
<p>If a task assigned to the queue has finished, this will return true and fill in <code>outcome</code> with the details of the task. If no task in the queue has finished, this function will return false.</p>
<p>If a task has completed, this function will free its resources and the task pointer will no longer be valid. The task will be removed from the queue.</p>
<p>It is safe for multiple threads to call this function on the same queue at once; a completed task will only go to one of the threads.</p>
<p>Note that by the nature of various platforms, more than one waiting thread may wake to handle a single task, but only one will obtain it, so <code>timeoutMS</code> is a <em>maximum</em> wait time, and this function may return false sooner.</p>
<p>This function may return false if there was a system error, the OS inadvertently awoke multiple threads, or if <a class="el" href="group__CategoryAsyncIO.html#ga79c948c3e97531c8ef690be7bbef12c3" title="Wake up any threads that are blocking in AsyncIOQueue.WaitResult().">AsyncIOQueue.Signal()</a> was called to wake up all waiting threads without a finished task.</p>
<p>A timeout can be used to specify a maximum wait time, but rather than polling, it is possible to have a timeout of -1 to wait forever, and use <a class="el" href="group__CategoryAsyncIO.html#ga79c948c3e97531c8ef690be7bbef12c3" title="Wake up any threads that are blocking in AsyncIOQueue.WaitResult().">AsyncIOQueue.Signal()</a> to wake up the waiting threads later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>the maximum time to wait, in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of a finished task if a task has completed, std::nullopt otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAsyncIO.html#ga79c948c3e97531c8ef690be7bbef12c3" title="Wake up any threads that are blocking in AsyncIOQueue.WaitResult().">AsyncIOQueue.Signal</a> </dd></dl>

</div>
</div>
<a id="gab67259533ebe86aeee8fc41d12008845" name="gab67259533ebe86aeee8fc41d12008845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab67259533ebe86aeee8fc41d12008845">&#9670;&#160;</a></span>Write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::AsyncIO::Write </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gad1c0b6121968b312e1133bcf0db2a2b0">Uint64</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gad1c0b6121968b312e1133bcf0db2a2b0">Uint64</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1AsyncIOQueueParam.html">AsyncIOQueueParam</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function writes <code>size</code> bytes from <code>offset</code> position in the data source to the area pointed at by <code>ptr</code>.</p>
<p>This function returns as quickly as possible; it does not wait for the write to complete. On a successful return, this work will continue in the background. If the work begins, even failure is asynchronous: a failing return value from this function only means the work couldn't start at all.</p>
<p><code>ptr</code> must remain available until the work is done, and may be accessed by the system at any time until then. Do not allocate it on the stack, as this might take longer than the life of the calling function to complete!</p>
<p>An <a class="el" href="classSDL_1_1AsyncIOQueue.html" title="A queue of completed asynchronous I/O tasks.">AsyncIOQueue</a> must be specified. The newly-created task will be added to it when it completes its work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>a pointer to a buffer to write data from. </td></tr>
    <tr><td class="paramname">offset</td><td>the position to start writing to the data source. </td></tr>
    <tr><td class="paramname">size</td><td>the number of bytes to write to the data source. </td></tr>
    <tr><td class="paramname">queue</td><td>a queue to add the new <a class="el" href="classSDL_1_1AsyncIO.html" title="The asynchronous I/O operation structure.">AsyncIO</a> to. </td></tr>
    <tr><td class="paramname">userdata</td><td>an app-defined pointer that will be provided with the task results. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAsyncIO.html#ga593fd7f4b1fbf36f46b783480f49a8f6" title="Start an async read.">AsyncIO.Read</a> </dd>
<dd>
<a class="el" href="classSDL_1_1AsyncIOQueue.html#a6d56c206cc28918a5684d31789adef9b" title="Constructs from AsyncIOQueueParam.">AsyncIOQueue.AsyncIOQueue</a> </dd></dl>

</div>
</div>
<a id="ga8b8d20d62189de16c9fb13302546d82e" name="ga8b8d20d62189de16c9fb13302546d82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b8d20d62189de16c9fb13302546d82e">&#9670;&#160;</a></span>WriteAsyncIO()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::WriteAsyncIO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1AsyncIOParam.html">AsyncIOParam</a>&#160;</td>
          <td class="paramname"><em>asyncio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gad1c0b6121968b312e1133bcf0db2a2b0">Uint64</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gad1c0b6121968b312e1133bcf0db2a2b0">Uint64</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1AsyncIOQueueParam.html">AsyncIOQueueParam</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function writes <code>size</code> bytes from <code>offset</code> position in the data source to the area pointed at by <code>ptr</code>.</p>
<p>This function returns as quickly as possible; it does not wait for the write to complete. On a successful return, this work will continue in the background. If the work begins, even failure is asynchronous: a failing return value from this function only means the work couldn't start at all.</p>
<p><code>ptr</code> must remain available until the work is done, and may be accessed by the system at any time until then. Do not allocate it on the stack, as this might take longer than the life of the calling function to complete!</p>
<p>An <a class="el" href="classSDL_1_1AsyncIOQueue.html" title="A queue of completed asynchronous I/O tasks.">AsyncIOQueue</a> must be specified. The newly-created task will be added to it when it completes its work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asyncio</td><td>a pointer to an <a class="el" href="classSDL_1_1AsyncIO.html" title="The asynchronous I/O operation structure.">AsyncIO</a> structure. </td></tr>
    <tr><td class="paramname">ptr</td><td>a pointer to a buffer to write data from. </td></tr>
    <tr><td class="paramname">offset</td><td>the position to start writing to the data source. </td></tr>
    <tr><td class="paramname">size</td><td>the number of bytes to write to the data source. </td></tr>
    <tr><td class="paramname">queue</td><td>a queue to add the new <a class="el" href="classSDL_1_1AsyncIO.html" title="The asynchronous I/O operation structure.">AsyncIO</a> to. </td></tr>
    <tr><td class="paramname">userdata</td><td>an app-defined pointer that will be provided with the task results. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAsyncIO.html#ga593fd7f4b1fbf36f46b783480f49a8f6" title="Start an async read.">AsyncIO.Read</a> </dd>
<dd>
<a class="el" href="classSDL_1_1AsyncIOQueue.html#a6d56c206cc28918a5684d31789adef9b" title="Constructs from AsyncIOQueueParam.">AsyncIOQueue.AsyncIOQueue</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga443ae4dcc45af2ede2693a09bd40d3cb" name="ga443ae4dcc45af2ede2693a09bd40d3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga443ae4dcc45af2ede2693a09bd40d3cb">&#9670;&#160;</a></span>ASYNCIO_CANCELED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryAsyncIO.html#gaf01bc0057e6d26f43fcb866acc7b5403">AsyncIOResult</a> SDL::ASYNCIO_CANCELED</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_ASYNCIO_CANCELED</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga97f9595a1d2191f4e24ca2f931442610" name="ga97f9595a1d2191f4e24ca2f931442610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97f9595a1d2191f4e24ca2f931442610">&#9670;&#160;</a></span>ASYNCIO_COMPLETE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryAsyncIO.html#gaf01bc0057e6d26f43fcb866acc7b5403">AsyncIOResult</a> SDL::ASYNCIO_COMPLETE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_ASYNCIO_COMPLETE</div>
</div><!-- fragment -->
</div>
</div>
<a id="gab67ec500dd06904ebeae82b80056ffe1" name="gab67ec500dd06904ebeae82b80056ffe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab67ec500dd06904ebeae82b80056ffe1">&#9670;&#160;</a></span>ASYNCIO_FAILURE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryAsyncIO.html#gaf01bc0057e6d26f43fcb866acc7b5403">AsyncIOResult</a> SDL::ASYNCIO_FAILURE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_ASYNCIO_FAILURE</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga51c704b04fd3ca41d0f390dd07b72a2a" name="ga51c704b04fd3ca41d0f390dd07b72a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51c704b04fd3ca41d0f390dd07b72a2a">&#9670;&#160;</a></span>ASYNCIO_TASK_CLOSE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryAsyncIO.html#ga5ced0daa86e13c8fb857a7de2d3ea3fc">AsyncIOTaskType</a> SDL::ASYNCIO_TASK_CLOSE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_ASYNCIO_TASK_CLOSE</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga70a329ff5135f9603b8eedc940353a68" name="ga70a329ff5135f9603b8eedc940353a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70a329ff5135f9603b8eedc940353a68">&#9670;&#160;</a></span>ASYNCIO_TASK_READ</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryAsyncIO.html#ga5ced0daa86e13c8fb857a7de2d3ea3fc">AsyncIOTaskType</a> SDL::ASYNCIO_TASK_READ</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_ASYNCIO_TASK_READ</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaeb532ea0d531113768d7158ab35e48ca" name="gaeb532ea0d531113768d7158ab35e48ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb532ea0d531113768d7158ab35e48ca">&#9670;&#160;</a></span>ASYNCIO_TASK_WRITE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__CategoryAsyncIO.html#ga5ced0daa86e13c8fb857a7de2d3ea3fc">AsyncIOTaskType</a> SDL::ASYNCIO_TASK_WRITE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  SDL_ASYNCIO_TASK_WRITE</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
