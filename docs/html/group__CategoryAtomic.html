<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDL3pp: Atomic Operations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SDL3pp
   </div>
   <div id="projectbrief">A slim C++ wrapper for SDL3</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Atomic Operations<div class="ingroups"><a class="el" href="group__Categories.html">Categories</a> &raquo; <a class="el" href="group__CategoriesThreads.html">Threads</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Atomic operations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1AtomicInt.html">SDL::AtomicInt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type representing an atomic integer value.  <a href="classSDL_1_1AtomicInt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1AtomicU32.html">SDL::AtomicU32</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type representing an atomic unsigned 32-bit value.  <a href="classSDL_1_1AtomicU32.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1AtomicPointer.html">SDL::AtomicPointer&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga36d435d444dc115a5cc11fa7027576ec" id="r_ga36d435d444dc115a5cc11fa7027576ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#ga36d435d444dc115a5cc11fa7027576ec">SDL_CompilerBarrier</a>()&#160;&#160;&#160;DoCompilerSpecificReadWriteBarrier()</td></tr>
<tr class="memdesc:ga36d435d444dc115a5cc11fa7027576ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a compiler barrier.  <br /></td></tr>
<tr class="separator:ga36d435d444dc115a5cc11fa7027576ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga041cb5705236fe51b35cb3d59c1fbba7" id="r_ga041cb5705236fe51b35cb3d59c1fbba7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#ga041cb5705236fe51b35cb3d59c1fbba7">SDL_MemoryBarrierRelease</a>()&#160;&#160;&#160;SDL_MemoryBarrierReleaseFunction()</td></tr>
<tr class="memdesc:ga041cb5705236fe51b35cb3d59c1fbba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a memory release barrier (macro version).  <br /></td></tr>
<tr class="separator:ga041cb5705236fe51b35cb3d59c1fbba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa33019d94c637a106218dde56b46a20a" id="r_gaa33019d94c637a106218dde56b46a20a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#gaa33019d94c637a106218dde56b46a20a">SDL_MemoryBarrierAcquire</a>()&#160;&#160;&#160;SDL_MemoryBarrierAcquireFunction()</td></tr>
<tr class="memdesc:gaa33019d94c637a106218dde56b46a20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a memory acquire barrier (macro version).  <br /></td></tr>
<tr class="separator:gaa33019d94c637a106218dde56b46a20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aa8f8635b3a07f02fe26e5cc052a5f6" id="r_ga6aa8f8635b3a07f02fe26e5cc052a5f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#ga6aa8f8635b3a07f02fe26e5cc052a5f6">SDL_CPUPauseInstruction</a>()&#160;&#160;&#160;  DoACPUPauseInACompilerAndArchitectureSpecificWay</td></tr>
<tr class="memdesc:ga6aa8f8635b3a07f02fe26e5cc052a5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro to insert a CPU-specific "pause" instruction into the program.  <br /></td></tr>
<tr class="separator:ga6aa8f8635b3a07f02fe26e5cc052a5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae63499665b3f82267248d33e774ace12" id="r_gae63499665b3f82267248d33e774ace12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#gae63499665b3f82267248d33e774ace12">SDL::MemoryBarrierRelease</a> ()</td></tr>
<tr class="memdesc:gae63499665b3f82267248d33e774ace12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a memory release barrier (function version).  <br /></td></tr>
<tr class="separator:gae63499665b3f82267248d33e774ace12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd81ade5d5ee905d0ea12d0c6e061668" id="r_gacd81ade5d5ee905d0ea12d0c6e061668"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#gacd81ade5d5ee905d0ea12d0c6e061668">SDL::MemoryBarrierAcquire</a> ()</td></tr>
<tr class="memdesc:gacd81ade5d5ee905d0ea12d0c6e061668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a memory acquire barrier (function version).  <br /></td></tr>
<tr class="separator:gacd81ade5d5ee905d0ea12d0c6e061668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16701ba4af31f536491f1241f3f986e8" id="r_ga16701ba4af31f536491f1241f3f986e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#ga16701ba4af31f536491f1241f3f986e8">SDL::AtomicInt::CompareAndSwap</a> (int oldval, int newval)</td></tr>
<tr class="memdesc:ga16701ba4af31f536491f1241f3f986e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an atomic variable to a new value if it is currently an old value.  <br /></td></tr>
<tr class="separator:ga16701ba4af31f536491f1241f3f986e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac718cfa969aa0ff572975aaaac99b91b" id="r_gac718cfa969aa0ff572975aaaac99b91b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#gac718cfa969aa0ff572975aaaac99b91b">SDL::AtomicInt::Set</a> (int v)</td></tr>
<tr class="memdesc:gac718cfa969aa0ff572975aaaac99b91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an atomic variable to a value.  <br /></td></tr>
<tr class="separator:gac718cfa969aa0ff572975aaaac99b91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cf0b1fbd88d762113275ceceeb812e6" id="r_ga8cf0b1fbd88d762113275ceceeb812e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#ga8cf0b1fbd88d762113275ceceeb812e6">SDL::AtomicInt::Get</a> ()</td></tr>
<tr class="memdesc:ga8cf0b1fbd88d762113275ceceeb812e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of an atomic variable.  <br /></td></tr>
<tr class="separator:ga8cf0b1fbd88d762113275ceceeb812e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga353e1c3c6d3665e1c10e4ae31b4eed7b" id="r_ga353e1c3c6d3665e1c10e4ae31b4eed7b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#ga353e1c3c6d3665e1c10e4ae31b4eed7b">SDL::AtomicInt::Add</a> (int v)</td></tr>
<tr class="memdesc:ga353e1c3c6d3665e1c10e4ae31b4eed7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to an atomic variable.  <br /></td></tr>
<tr class="separator:ga353e1c3c6d3665e1c10e4ae31b4eed7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4ce325df13c6bf5efddd374455516b4" id="r_gab4ce325df13c6bf5efddd374455516b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#gab4ce325df13c6bf5efddd374455516b4">SDL::AtomicInt::AtomicIncRef</a> ()</td></tr>
<tr class="memdesc:gab4ce325df13c6bf5efddd374455516b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment an atomic variable used as a reference count.  <br /></td></tr>
<tr class="separator:gab4ce325df13c6bf5efddd374455516b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a1a156145c772f3b9d2b1bf6ba1e187" id="r_ga4a1a156145c772f3b9d2b1bf6ba1e187"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#ga4a1a156145c772f3b9d2b1bf6ba1e187">SDL::AtomicInt::AtomicDecRef</a> ()</td></tr>
<tr class="memdesc:ga4a1a156145c772f3b9d2b1bf6ba1e187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement an atomic variable used as a reference count.  <br /></td></tr>
<tr class="separator:ga4a1a156145c772f3b9d2b1bf6ba1e187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12f232107f77b856499a2bc3f048d6ce" id="r_ga12f232107f77b856499a2bc3f048d6ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#ga12f232107f77b856499a2bc3f048d6ce">SDL::AtomicU32::CompareAndSwap</a> (<a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> oldval, <a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> newval)</td></tr>
<tr class="memdesc:ga12f232107f77b856499a2bc3f048d6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an atomic variable to a new value if it is currently an old value.  <br /></td></tr>
<tr class="separator:ga12f232107f77b856499a2bc3f048d6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c192a995c272792415d8b191baaedfb" id="r_ga6c192a995c272792415d8b191baaedfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#ga6c192a995c272792415d8b191baaedfb">SDL::AtomicU32::Set</a> (<a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> v)</td></tr>
<tr class="memdesc:ga6c192a995c272792415d8b191baaedfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an atomic variable to a value.  <br /></td></tr>
<tr class="separator:ga6c192a995c272792415d8b191baaedfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae669a7585c18f9fcf51e6ed9debc96e3" id="r_gae669a7585c18f9fcf51e6ed9debc96e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#gae669a7585c18f9fcf51e6ed9debc96e3">SDL::AtomicU32::Get</a> ()</td></tr>
<tr class="memdesc:gae669a7585c18f9fcf51e6ed9debc96e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of an atomic variable.  <br /></td></tr>
<tr class="separator:gae669a7585c18f9fcf51e6ed9debc96e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab43864a06ef7797bbcb638e38207ed88" id="r_gab43864a06ef7797bbcb638e38207ed88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#gab43864a06ef7797bbcb638e38207ed88">SDL::AtomicPointer&lt; T &gt;::CompareAndSwap</a> (T *oldval, T *newval)</td></tr>
<tr class="memdesc:gab43864a06ef7797bbcb638e38207ed88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a pointer to a new value if it is currently an old value.  <br /></td></tr>
<tr class="separator:gab43864a06ef7797bbcb638e38207ed88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44d70519fbb8d71f2cb5b3646d5f0637" id="r_ga44d70519fbb8d71f2cb5b3646d5f0637"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#ga44d70519fbb8d71f2cb5b3646d5f0637">SDL::AtomicPointer&lt; T &gt;::Set</a> (T *v)</td></tr>
<tr class="memdesc:ga44d70519fbb8d71f2cb5b3646d5f0637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a pointer to a value atomically.  <br /></td></tr>
<tr class="separator:ga44d70519fbb8d71f2cb5b3646d5f0637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fa8e313e7f6e6e814114f61ce5fbf65" id="r_ga2fa8e313e7f6e6e814114f61ce5fbf65"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#ga2fa8e313e7f6e6e814114f61ce5fbf65">SDL::AtomicPointer&lt; T &gt;::Get</a> ()</td></tr>
<tr class="memdesc:ga2fa8e313e7f6e6e814114f61ce5fbf65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pointer atomically.  <br /></td></tr>
<tr class="separator:ga2fa8e313e7f6e6e814114f61ce5fbf65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>IMPORTANT: If you are not an expert in concurrent lockless programming, you should not be using any functions in this file. You should be protecting your data structures with full mutexes instead.</p>
<p><em><b>Seriously, here be dragons!</b></em></p>
<p>You can find out a little more about lockless programming and the subtle issues that can arise here: <a href="https://learn.microsoft.com/en-us/windows/win32/dxtecharts/lockless-programming">https://learn.microsoft.com/en-us/windows/win32/dxtecharts/lockless-programming</a></p>
<p>There's also lots of good information here:</p>
<ul>
<li><a href="https://www.1024cores.net/home/lock-free-algorithms">https://www.1024cores.net/home/lock-free-algorithms</a></li>
<li><a href="https://preshing.com/">https://preshing.com/</a></li>
</ul>
<p>These operations may or may not actually be implemented using processor specific atomic operations. When possible they are implemented as true processor specific atomic operations. When that is not possible the are implemented using locks that <em>do</em> use the available atomic operations.</p>
<p>All of the atomic operations that modify memory are full memory barriers. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga36d435d444dc115a5cc11fa7027576ec" name="ga36d435d444dc115a5cc11fa7027576ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36d435d444dc115a5cc11fa7027576ec">&#9670;&#160;</a></span>SDL_CompilerBarrier</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_CompilerBarrier</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;DoCompilerSpecificReadWriteBarrier()</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A compiler barrier prevents the compiler from reordering reads and writes to globally visible variables across the call.</p>
<p>This macro only prevents the compiler from reordering reads and writes, it does not prevent the CPU from reordering reads and writes. However, all of the atomic operations that modify memory are full memory barriers.</p>
<dl class="section user"><dt>Thread safety:</dt><dd>Obviously this macro is safe to use from any thread at any time, but if you find yourself needing this, you are probably dealing with some very sensitive code; be careful!</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga6aa8f8635b3a07f02fe26e5cc052a5f6" name="ga6aa8f8635b3a07f02fe26e5cc052a5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6aa8f8635b3a07f02fe26e5cc052a5f6">&#9670;&#160;</a></span>SDL_CPUPauseInstruction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_CPUPauseInstruction</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;  DoACPUPauseInACompilerAndArchitectureSpecificWay</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This can be useful in busy-wait loops, as it serves as a hint to the CPU as to the program's intent; some CPUs can use this to do more efficient processing. On some platforms, this doesn't do anything, so using this macro might just be a harmless no-op.</p>
<p>Note that if you are busy-waiting, there are often more-efficient approaches with other synchronization primitives: mutexes, semaphores, condition variables, etc.</p>
<dl class="section user"><dt>Thread safety:</dt><dd>This macro is safe to use from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaa33019d94c637a106218dde56b46a20a" name="gaa33019d94c637a106218dde56b46a20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa33019d94c637a106218dde56b46a20a">&#9670;&#160;</a></span>SDL_MemoryBarrierAcquire</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_MemoryBarrierAcquire</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;SDL_MemoryBarrierAcquireFunction()</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please see SDL_MemoryBarrierRelease for the details on what memory barriers are and when to use them.</p>
<p>This is the macro version of this functionality; if possible, <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> will use compiler intrinsics or inline assembly, but some platforms might need to call the function version of this, MemoryBarrierAcquire, to do the heavy lifting. Apps that can use the macro should favor it over the function.</p>
<dl class="section user"><dt>Thread safety:</dt><dd>Obviously this macro is safe to use from any thread at any time, but if you find yourself needing this, you are probably dealing with some very sensitive code; be careful!</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAtomic.html#ga041cb5705236fe51b35cb3d59c1fbba7" title="Insert a memory release barrier (macro version).">SDL_MemoryBarrierRelease</a> </dd>
<dd>
MemoryBarrierAcquire </dd></dl>

</div>
</div>
<a id="ga041cb5705236fe51b35cb3d59c1fbba7" name="ga041cb5705236fe51b35cb3d59c1fbba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga041cb5705236fe51b35cb3d59c1fbba7">&#9670;&#160;</a></span>SDL_MemoryBarrierRelease</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_MemoryBarrierRelease</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;SDL_MemoryBarrierReleaseFunction()</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Memory barriers are designed to prevent reads and writes from being reordered by the compiler and being seen out of order on multi-core CPUs.</p>
<p>A typical pattern would be for thread A to write some data and a flag, and for thread B to read the flag and get the data. In this case you would insert a release barrier between writing the data and the flag, guaranteeing that the data write completes no later than the flag is written, and you would insert an acquire barrier between reading the flag and reading the data, to ensure that all the reads associated with the flag have completed.</p>
<p>In this pattern you should always see a release barrier paired with an acquire barrier and you should gate the data reads/writes with a single flag variable.</p>
<p>For more information on these semantics, take a look at the blog post: <a href="http://preshing.com/20120913/acquire-and-release-semantics">http://preshing.com/20120913/acquire-and-release-semantics</a></p>
<p>This is the macro version of this functionality; if possible, <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> will use compiler intrinsics or inline assembly, but some platforms might need to call the function version of this, MemoryBarrierRelease to do the heavy lifting. Apps that can use the macro should favor it over the function.</p>
<dl class="section user"><dt>Thread safety:</dt><dd>Obviously this macro is safe to use from any thread at any time, but if you find yourself needing this, you are probably dealing with some very sensitive code; be careful!</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAtomic.html#gaa33019d94c637a106218dde56b46a20a" title="Insert a memory acquire barrier (macro version).">SDL_MemoryBarrierAcquire</a> </dd>
<dd>
MemoryBarrierRelease </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga353e1c3c6d3665e1c10e4ae31b4eed7b" name="ga353e1c3c6d3665e1c10e4ae31b4eed7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga353e1c3c6d3665e1c10e4ae31b4eed7b">&#9670;&#160;</a></span>Add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::AtomicInt::Add </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function also acts as a full memory barrier.</p>
<p><em><b>Note: If you don't know what this function is for, you shouldn't use it!</b></em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the desired value to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value of the atomic variable.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAtomic.html#ga4a1a156145c772f3b9d2b1bf6ba1e187" title="Decrement an atomic variable used as a reference count.">AtomicInt.AtomicDecRef</a> </dd>
<dd>
<a class="el" href="group__CategoryAtomic.html#gab4ce325df13c6bf5efddd374455516b4" title="Increment an atomic variable used as a reference count.">AtomicInt.AtomicIncRef</a> </dd></dl>

</div>
</div>
<a id="ga4a1a156145c772f3b9d2b1bf6ba1e187" name="ga4a1a156145c772f3b9d2b1bf6ba1e187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a1a156145c772f3b9d2b1bf6ba1e187">&#9670;&#160;</a></span>AtomicDecRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::AtomicInt::AtomicDecRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><em><b>Note: If you don't know what this macro is for, you shouldn't use it!</b></em></p>
<dl class="section return"><dt>Returns</dt><dd>true if the variable reached zero after decrementing, false otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this macro from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAtomic.html#gab4ce325df13c6bf5efddd374455516b4" title="Increment an atomic variable used as a reference count.">AtomicInt.AtomicIncRef</a> </dd></dl>

</div>
</div>
<a id="gab4ce325df13c6bf5efddd374455516b4" name="gab4ce325df13c6bf5efddd374455516b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4ce325df13c6bf5efddd374455516b4">&#9670;&#160;</a></span>AtomicIncRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::AtomicInt::AtomicIncRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><em><b>Note: If you don't know what this macro is for, you shouldn't use it!</b></em></p>
<dl class="section return"><dt>Returns</dt><dd>the previous value of the atomic variable.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this macro from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAtomic.html#ga4a1a156145c772f3b9d2b1bf6ba1e187" title="Decrement an atomic variable used as a reference count.">AtomicInt.AtomicDecRef</a> </dd></dl>

</div>
</div>
<a id="ga16701ba4af31f536491f1241f3f986e8" name="ga16701ba4af31f536491f1241f3f986e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16701ba4af31f536491f1241f3f986e8">&#9670;&#160;</a></span>CompareAndSwap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::AtomicInt::CompareAndSwap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oldval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><em><b>Note: If you don't know what this function is for, you shouldn't use it!</b></em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldval</td><td>the old value. </td></tr>
    <tr><td class="paramname">newval</td><td>the new value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the atomic variable was set, false otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAtomic.html#ga8cf0b1fbd88d762113275ceceeb812e6" title="Get the value of an atomic variable.">AtomicInt.Get</a> </dd>
<dd>
<a class="el" href="group__CategoryAtomic.html#gac718cfa969aa0ff572975aaaac99b91b" title="Set an atomic variable to a value.">AtomicInt.Set</a> </dd></dl>

</div>
</div>
<a id="gab43864a06ef7797bbcb638e38207ed88" name="gab43864a06ef7797bbcb638e38207ed88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab43864a06ef7797bbcb638e38207ed88">&#9670;&#160;</a></span>CompareAndSwap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSDL_1_1AtomicPointer.html">SDL::AtomicPointer</a>&lt; T &gt;::CompareAndSwap </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>oldval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>newval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><em><b>Note: If you don't know what this function is for, you shouldn't use it!</b></em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldval</td><td>the old pointer value. </td></tr>
    <tr><td class="paramname">newval</td><td>the new pointer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the pointer was set, false otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAtomic.html#ga16701ba4af31f536491f1241f3f986e8" title="Set an atomic variable to a new value if it is currently an old value.">AtomicInt.CompareAndSwap</a> </dd>
<dd>
<a class="el" href="group__CategoryAtomic.html#ga2fa8e313e7f6e6e814114f61ce5fbf65" title="Get the value of a pointer atomically.">AtomicPointer.Get</a> </dd>
<dd>
<a class="el" href="group__CategoryAtomic.html#ga44d70519fbb8d71f2cb5b3646d5f0637" title="Set a pointer to a value atomically.">AtomicPointer.Set</a> </dd></dl>

</div>
</div>
<a id="ga12f232107f77b856499a2bc3f048d6ce" name="ga12f232107f77b856499a2bc3f048d6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12f232107f77b856499a2bc3f048d6ce">&#9670;&#160;</a></span>CompareAndSwap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::AtomicU32::CompareAndSwap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>oldval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>newval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><em><b>Note: If you don't know what this function is for, you shouldn't use it!</b></em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldval</td><td>the old value. </td></tr>
    <tr><td class="paramname">newval</td><td>the new value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the atomic variable was set, false otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAtomic.html#gae669a7585c18f9fcf51e6ed9debc96e3" title="Get the value of an atomic variable.">AtomicU32.Get</a> </dd>
<dd>
<a class="el" href="group__CategoryAtomic.html#ga6c192a995c272792415d8b191baaedfb" title="Set an atomic variable to a value.">AtomicU32.Set</a> </dd></dl>

</div>
</div>
<a id="ga8cf0b1fbd88d762113275ceceeb812e6" name="ga8cf0b1fbd88d762113275ceceeb812e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cf0b1fbd88d762113275ceceeb812e6">&#9670;&#160;</a></span>Get() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::AtomicInt::Get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><em><b>Note: If you don't know what this function is for, you shouldn't use it!</b></em></p>
<dl class="section return"><dt>Returns</dt><dd>the current value of an atomic variable.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAtomic.html#gac718cfa969aa0ff572975aaaac99b91b" title="Set an atomic variable to a value.">AtomicInt.Set</a> </dd></dl>

</div>
</div>
<a id="gae669a7585c18f9fcf51e6ed9debc96e3" name="gae669a7585c18f9fcf51e6ed9debc96e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae669a7585c18f9fcf51e6ed9debc96e3">&#9670;&#160;</a></span>Get() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> SDL::AtomicU32::Get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><em><b>Note: If you don't know what this function is for, you shouldn't use it!</b></em></p>
<dl class="section return"><dt>Returns</dt><dd>the current value of an atomic variable.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAtomic.html#ga6c192a995c272792415d8b191baaedfb" title="Set an atomic variable to a value.">AtomicU32.Set</a> </dd></dl>

</div>
</div>
<a id="ga2fa8e313e7f6e6e814114f61ce5fbf65" name="ga2fa8e313e7f6e6e814114f61ce5fbf65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fa8e313e7f6e6e814114f61ce5fbf65">&#9670;&#160;</a></span>Get() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classSDL_1_1AtomicPointer.html">SDL::AtomicPointer</a>&lt; T &gt;::Get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><em><b>Note: If you don't know what this function is for, you shouldn't use it!</b></em></p>
<dl class="section return"><dt>Returns</dt><dd>the current value of a pointer.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAtomic.html#gab43864a06ef7797bbcb638e38207ed88" title="Set a pointer to a new value if it is currently an old value.">AtomicPointer.CompareAndSwap</a> </dd>
<dd>
<a class="el" href="group__CategoryAtomic.html#ga44d70519fbb8d71f2cb5b3646d5f0637" title="Set a pointer to a value atomically.">AtomicPointer.Set</a> </dd></dl>

</div>
</div>
<a id="gacd81ade5d5ee905d0ea12d0c6e061668" name="gacd81ade5d5ee905d0ea12d0c6e061668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd81ade5d5ee905d0ea12d0c6e061668">&#9670;&#160;</a></span>MemoryBarrierAcquire()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::MemoryBarrierAcquire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Please refer to SDL_MemoryBarrierRelease for details. This is a function version, which might be useful if you need to use this functionality from a scripting language, etc. Also, some of the macro versions call this function behind the scenes, where more heavy lifting can happen inside of <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a>. Generally, though, an app written in C/C++/etc should use the macro version, as it will be more efficient.</p>
<dl class="section user"><dt>Thread safety:</dt><dd>Obviously this function is safe to use from any thread at any time, but if you find yourself needing this, you are probably dealing with some very sensitive code; be careful!</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAtomic.html#gaa33019d94c637a106218dde56b46a20a" title="Insert a memory acquire barrier (macro version).">SDL_MemoryBarrierAcquire</a> </dd></dl>

</div>
</div>
<a id="gae63499665b3f82267248d33e774ace12" name="gae63499665b3f82267248d33e774ace12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae63499665b3f82267248d33e774ace12">&#9670;&#160;</a></span>MemoryBarrierRelease()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::MemoryBarrierRelease </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Please refer to SDL_MemoryBarrierRelease for details. This is a function version, which might be useful if you need to use this functionality from a scripting language, etc. Also, some of the macro versions call this function behind the scenes, where more heavy lifting can happen inside of <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a>. Generally, though, an app written in C/C++/etc should use the macro version, as it will be more efficient.</p>
<dl class="section user"><dt>Thread safety:</dt><dd>Obviously this function is safe to use from any thread at any time, but if you find yourself needing this, you are probably dealing with some very sensitive code; be careful!</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAtomic.html#ga041cb5705236fe51b35cb3d59c1fbba7" title="Insert a memory release barrier (macro version).">SDL_MemoryBarrierRelease</a> </dd></dl>

</div>
</div>
<a id="gac718cfa969aa0ff572975aaaac99b91b" name="gac718cfa969aa0ff572975aaaac99b91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac718cfa969aa0ff572975aaaac99b91b">&#9670;&#160;</a></span>Set() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::AtomicInt::Set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function also acts as a full memory barrier.</p>
<p><em><b>Note: If you don't know what this function is for, you shouldn't use it!</b></em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the desired value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value of the atomic variable.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAtomic.html#ga8cf0b1fbd88d762113275ceceeb812e6" title="Get the value of an atomic variable.">AtomicInt.Get</a> </dd></dl>

</div>
</div>
<a id="ga44d70519fbb8d71f2cb5b3646d5f0637" name="ga44d70519fbb8d71f2cb5b3646d5f0637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44d70519fbb8d71f2cb5b3646d5f0637">&#9670;&#160;</a></span>Set() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classSDL_1_1AtomicPointer.html">SDL::AtomicPointer</a>&lt; T &gt;::Set </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><em><b>Note: If you don't know what this function is for, you shouldn't use it!</b></em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the desired pointer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value of the pointer.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAtomic.html#gab43864a06ef7797bbcb638e38207ed88" title="Set a pointer to a new value if it is currently an old value.">AtomicPointer.CompareAndSwap</a> </dd>
<dd>
<a class="el" href="group__CategoryAtomic.html#ga2fa8e313e7f6e6e814114f61ce5fbf65" title="Get the value of a pointer atomically.">AtomicPointer.Get</a> </dd></dl>

</div>
</div>
<a id="ga6c192a995c272792415d8b191baaedfb" name="ga6c192a995c272792415d8b191baaedfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c192a995c272792415d8b191baaedfb">&#9670;&#160;</a></span>Set() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a> SDL::AtomicU32::Set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa223864b2586e8faf963fdfa230ceaa0">Uint32</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function also acts as a full memory barrier.</p>
<p><em><b>Note: If you don't know what this function is for, you shouldn't use it!</b></em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the desired value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value of the atomic variable.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="Main include header for the SDL3pp library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAtomic.html#gae669a7585c18f9fcf51e6ed9debc96e3" title="Get the value of an atomic variable.">AtomicU32.Get</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
