<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDL3pp: SDL::TextureBase&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SDL3pp
   </div>
   <div id="projectbrief">A slim C++ wrapper for SDL3</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSDL.html">SDL</a></li><li class="navelem"><a class="el" href="structSDL_1_1TextureBase.html">TextureBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structSDL_1_1TextureBase-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SDL::TextureBase&lt; T &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__Categories.html">Categories</a> &raquo; <a class="el" href="group__CategoriesVideo.html">Video</a> &raquo; <a class="el" href="group__CategoryRender.html">2D Accelerated Rendering</a> &#124; <a class="el" href="group__DesignNotes.html">Design notes</a> &raquo; <a class="el" href="group__resource.html">Resource</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>An efficient driver-specific representation of pixel data.  
 <a href="structSDL_1_1TextureBase.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for SDL::TextureBase&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structSDL_1_1TextureBase__inherit__graph.png" border="0" usemap="#aSDL_1_1TextureBase_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aSDL_1_1TextureBase_3_01T_01_4_inherit__map" id="aSDL_1_1TextureBase_3_01T_01_4_inherit__map">
<area shape="rect" title="An efficient driver&#45;specific representation of pixel data." alt="" coords="5,79,179,104"/>
<area shape="rect" title=" " alt="" coords="73,5,111,31"/>
<area shape="poly" title=" " alt="" coords="95,44,95,79,89,79,89,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for SDL::TextureBase&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structSDL_1_1TextureBase__coll__graph.png" border="0" usemap="#aSDL_1_1TextureBase_3_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aSDL_1_1TextureBase_3_01T_01_4_coll__map" id="aSDL_1_1TextureBase_3_01T_01_4_coll__map">
<area shape="rect" title="An efficient driver&#45;specific representation of pixel data." alt="" coords="5,79,179,104"/>
<area shape="rect" title=" " alt="" coords="73,5,111,31"/>
<area shape="poly" title=" " alt="" coords="95,44,95,79,89,79,89,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a26b12859b23ad925ae7bed0c81ab0f46" id="r_a26b12859b23ad925ae7bed0c81ab0f46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#a26b12859b23ad925ae7bed0c81ab0f46">TextureBase</a> (<a class="el" href="group__CategoryVideo.html#ga3c15747c0c3091d37a2f14511aba1c7d">RendererRef</a> renderer, <a class="el" href="structSDL_1_1PixelFormat.html">PixelFormat</a> format, <a class="el" href="group__CategoryRender.html#ga736d13caaeee38a712dfb94180a24f56">TextureAccess</a> access, int w, int h)</td></tr>
<tr class="memdesc:a26b12859b23ad925ae7bed0c81ab0f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a texture for a rendering context.  <br /></td></tr>
<tr class="separator:a26b12859b23ad925ae7bed0c81ab0f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fb768abf109729277163693dfef21e" id="r_ac9fb768abf109729277163693dfef21e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#ac9fb768abf109729277163693dfef21e">TextureBase</a> (<a class="el" href="group__CategoryVideo.html#ga3c15747c0c3091d37a2f14511aba1c7d">RendererRef</a> renderer, <a class="el" href="group__CategorySurface.html#ga2ea8e6016ec594c51738ef06f469d5d2">SurfaceRef</a> surface)</td></tr>
<tr class="memdesc:ac9fb768abf109729277163693dfef21e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a texture from an existing surface.  <br /></td></tr>
<tr class="separator:ac9fb768abf109729277163693dfef21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf253d6d8727fca312e9707681ced937" id="r_adf253d6d8727fca312e9707681ced937"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#adf253d6d8727fca312e9707681ced937">TextureBase</a> (<a class="el" href="group__CategoryVideo.html#ga3c15747c0c3091d37a2f14511aba1c7d">RendererRef</a> renderer, <a class="el" href="group__CategoryProperties.html#gaa5faab1a5ca99f759b68b5800ab0697f">PropertiesRef</a> props)</td></tr>
<tr class="memdesc:adf253d6d8727fca312e9707681ced937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a texture for a rendering context with the specified properties.  <br /></td></tr>
<tr class="separator:adf253d6d8727fca312e9707681ced937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c6cd85f4d05f3dba98306fc44c031a" id="r_a42c6cd85f4d05f3dba98306fc44c031a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategoryProperties.html#gaa5faab1a5ca99f759b68b5800ab0697f">PropertiesRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#a42c6cd85f4d05f3dba98306fc44c031a">GetProperties</a> () const</td></tr>
<tr class="memdesc:a42c6cd85f4d05f3dba98306fc44c031a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the properties associated with a texture.  <br /></td></tr>
<tr class="separator:a42c6cd85f4d05f3dba98306fc44c031a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9e1d066fc334790c62565de16abfb6" id="r_a8b9e1d066fc334790c62565de16abfb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategoryVideo.html#ga3c15747c0c3091d37a2f14511aba1c7d">RendererRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#a8b9e1d066fc334790c62565de16abfb6">GetRenderer</a> () const</td></tr>
<tr class="memdesc:a8b9e1d066fc334790c62565de16abfb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the renderer that created an SDL_Texture.  <br /></td></tr>
<tr class="separator:a8b9e1d066fc334790c62565de16abfb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c2276d3c39fc28b1d185f14f23828b" id="r_ae8c2276d3c39fc28b1d185f14f23828b"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structSDL_1_1FPoint.html">FPoint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#ae8c2276d3c39fc28b1d185f14f23828b">GetSize</a> () const</td></tr>
<tr class="separator:ae8c2276d3c39fc28b1d185f14f23828b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa19f25b26c06046bc117f7813a43f75" id="r_aaa19f25b26c06046bc117f7813a43f75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#aaa19f25b26c06046bc117f7813a43f75">GetSize</a> (<a class="el" href="structSDL_1_1FPoint.html">FPoint</a> *size) const</td></tr>
<tr class="separator:aaa19f25b26c06046bc117f7813a43f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849768b5342e6bb1f6948f6e2c7b4e0a" id="r_a849768b5342e6bb1f6948f6e2c7b4e0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#a849768b5342e6bb1f6948f6e2c7b4e0a">GetSize</a> (float *w, float *h) const</td></tr>
<tr class="memdesc:a849768b5342e6bb1f6948f6e2c7b4e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a texture, as floating point values.  <br /></td></tr>
<tr class="separator:a849768b5342e6bb1f6948f6e2c7b4e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89325d1df6c6c5d0b8bb3500c78b913f" id="r_a89325d1df6c6c5d0b8bb3500c78b913f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#a89325d1df6c6c5d0b8bb3500c78b913f">SetColorAndAlphaMod</a> (<a class="el" href="structSDL_1_1Color.html">Color</a> c)</td></tr>
<tr class="separator:a89325d1df6c6c5d0b8bb3500c78b913f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a00dde2a1f4a8432c15c681e75068cc" id="r_a1a00dde2a1f4a8432c15c681e75068cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#a1a00dde2a1f4a8432c15c681e75068cc">SetColorAndAlphaMod</a> (<a class="el" href="structSDL_1_1FColor.html">FColor</a> c)</td></tr>
<tr class="separator:a1a00dde2a1f4a8432c15c681e75068cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70abd6612312bd12c9a042fedb6c657d" id="r_a70abd6612312bd12c9a042fedb6c657d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structSDL_1_1FColor.html">FColor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#a70abd6612312bd12c9a042fedb6c657d">GetColorAndAlphaMod</a> () const</td></tr>
<tr class="separator:a70abd6612312bd12c9a042fedb6c657d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae310315ba2462c76d195f178489f7fbf" id="r_ae310315ba2462c76d195f178489f7fbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#ae310315ba2462c76d195f178489f7fbf">GetColorAndAlphaMod</a> (<a class="el" href="structSDL_1_1Color.html">Color</a> *c) const</td></tr>
<tr class="separator:ae310315ba2462c76d195f178489f7fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8017ad0db340645b46f5f44d4fff5331" id="r_a8017ad0db340645b46f5f44d4fff5331"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#a8017ad0db340645b46f5f44d4fff5331">GetColorAndAlphaMod</a> (<a class="el" href="structSDL_1_1FColor.html">FColor</a> *c) const</td></tr>
<tr class="separator:a8017ad0db340645b46f5f44d4fff5331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187e90f3e1253dc53223d348f3b591c8" id="r_a187e90f3e1253dc53223d348f3b591c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#a187e90f3e1253dc53223d348f3b591c8">SetColorMod</a> (Uint8 r, Uint8 g, Uint8 b)</td></tr>
<tr class="memdesc:a187e90f3e1253dc53223d348f3b591c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an additional color value multiplied into render copy operations.  <br /></td></tr>
<tr class="separator:a187e90f3e1253dc53223d348f3b591c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af960bb27cc9047ad618ff136cc9cb668" id="r_af960bb27cc9047ad618ff136cc9cb668"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#af960bb27cc9047ad618ff136cc9cb668">SetColorMod</a> (float r, float g, float b)</td></tr>
<tr class="memdesc:af960bb27cc9047ad618ff136cc9cb668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an additional color value multiplied into render copy operations.  <br /></td></tr>
<tr class="separator:af960bb27cc9047ad618ff136cc9cb668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2dd56797426f63d7ff9de7db0113c7" id="r_a6d2dd56797426f63d7ff9de7db0113c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#a6d2dd56797426f63d7ff9de7db0113c7">GetColorMod</a> (Uint8 *r, Uint8 *g, Uint8 *b) const</td></tr>
<tr class="memdesc:a6d2dd56797426f63d7ff9de7db0113c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the additional color value multiplied into render copy operations.  <br /></td></tr>
<tr class="separator:a6d2dd56797426f63d7ff9de7db0113c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f87d581822d704d475c8951f8e5bb18" id="r_a0f87d581822d704d475c8951f8e5bb18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#a0f87d581822d704d475c8951f8e5bb18">GetColorMod</a> (float *r, float *g, float *b) const</td></tr>
<tr class="memdesc:a0f87d581822d704d475c8951f8e5bb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the additional color value multiplied into render copy operations.  <br /></td></tr>
<tr class="separator:a0f87d581822d704d475c8951f8e5bb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e546ebfbdceb484ae174e142e5bf886" id="r_a5e546ebfbdceb484ae174e142e5bf886"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#a5e546ebfbdceb484ae174e142e5bf886">SetAlphaMod</a> (Uint8 alpha)</td></tr>
<tr class="memdesc:a5e546ebfbdceb484ae174e142e5bf886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an additional alpha value multiplied into render copy operations.  <br /></td></tr>
<tr class="separator:a5e546ebfbdceb484ae174e142e5bf886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e406273bf30873feabb11c2de6b567a" id="r_a6e406273bf30873feabb11c2de6b567a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#a6e406273bf30873feabb11c2de6b567a">SetAlphaMod</a> (float alpha)</td></tr>
<tr class="memdesc:a6e406273bf30873feabb11c2de6b567a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an additional alpha value multiplied into render copy operations.  <br /></td></tr>
<tr class="separator:a6e406273bf30873feabb11c2de6b567a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7d66e8309fcf784ffae07c85decae5" id="r_acc7d66e8309fcf784ffae07c85decae5"><td class="memItemLeft" align="right" valign="top">std::optional&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#acc7d66e8309fcf784ffae07c85decae5">GetAlphaMod</a> () const</td></tr>
<tr class="separator:acc7d66e8309fcf784ffae07c85decae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2982c1ed7424b984cccfd8853b2672c" id="r_ae2982c1ed7424b984cccfd8853b2672c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#ae2982c1ed7424b984cccfd8853b2672c">GetAlphaMod</a> (Uint8 *alpha) const</td></tr>
<tr class="memdesc:ae2982c1ed7424b984cccfd8853b2672c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the additional alpha value multiplied into render copy operations.  <br /></td></tr>
<tr class="separator:ae2982c1ed7424b984cccfd8853b2672c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4206de1417b0b360c2a6639ee9d2831e" id="r_a4206de1417b0b360c2a6639ee9d2831e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#a4206de1417b0b360c2a6639ee9d2831e">GetAlphaMod</a> (float *alpha) const</td></tr>
<tr class="memdesc:a4206de1417b0b360c2a6639ee9d2831e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the additional alpha value multiplied into render copy operations.  <br /></td></tr>
<tr class="separator:a4206de1417b0b360c2a6639ee9d2831e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4025ebbafd04fb89e57163fb8b3c8a9a" id="r_a4025ebbafd04fb89e57163fb8b3c8a9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#a4025ebbafd04fb89e57163fb8b3c8a9a">SetBlendMode</a> (<a class="el" href="group__CategoryBlendmode.html#gad02afeb206989ff841629dca2c93e694">BlendMode</a> blendMode)</td></tr>
<tr class="memdesc:a4025ebbafd04fb89e57163fb8b3c8a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the blend mode for a texture, used by SDL_RenderTexture().  <br /></td></tr>
<tr class="separator:a4025ebbafd04fb89e57163fb8b3c8a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3c958172e938068fcf0c765e7b875e" id="r_a4a3c958172e938068fcf0c765e7b875e"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="group__CategoryBlendmode.html#gad02afeb206989ff841629dca2c93e694">BlendMode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#a4a3c958172e938068fcf0c765e7b875e">GetBlendMode</a> () const</td></tr>
<tr class="memdesc:a4a3c958172e938068fcf0c765e7b875e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the blend mode used for texture copy operations.  <br /></td></tr>
<tr class="separator:a4a3c958172e938068fcf0c765e7b875e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ee8437cbeef93d2cafe817bf6df970" id="r_a26ee8437cbeef93d2cafe817bf6df970"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#a26ee8437cbeef93d2cafe817bf6df970">SetScaleMode</a> (<a class="el" href="group__CategorySurface.html#gaed7f0fa288a530b226389e23c38e843d">ScaleMode</a> scaleMode)</td></tr>
<tr class="memdesc:a26ee8437cbeef93d2cafe817bf6df970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scale mode used for texture scale operations.  <br /></td></tr>
<tr class="separator:a26ee8437cbeef93d2cafe817bf6df970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90b3e72433bb962bd7071b8e9ec113d" id="r_ac90b3e72433bb962bd7071b8e9ec113d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="group__CategorySurface.html#gaed7f0fa288a530b226389e23c38e843d">ScaleMode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#ac90b3e72433bb962bd7071b8e9ec113d">GetScaleMode</a> () const</td></tr>
<tr class="memdesc:ac90b3e72433bb962bd7071b8e9ec113d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scale mode used for texture scale operations.  <br /></td></tr>
<tr class="separator:ac90b3e72433bb962bd7071b8e9ec113d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81636b580893caa1f578d7caae0419cf" id="r_a81636b580893caa1f578d7caae0419cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#a81636b580893caa1f578d7caae0419cf">Update</a> (<a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_Rect &gt; rect, const void *pixels, int pitch)</td></tr>
<tr class="memdesc:a81636b580893caa1f578d7caae0419cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the given texture rectangle with new pixel data.  <br /></td></tr>
<tr class="separator:a81636b580893caa1f578d7caae0419cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddf202449e6271ea46e2e1ccfb62f7f" id="r_a7ddf202449e6271ea46e2e1ccfb62f7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#a7ddf202449e6271ea46e2e1ccfb62f7f">UpdateYUV</a> (<a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_Rect &gt; rect, const Uint8 *Yplane, int Ypitch, const Uint8 *Uplane, int Upitch, const Uint8 *Vplane, int Vpitch)</td></tr>
<tr class="memdesc:a7ddf202449e6271ea46e2e1ccfb62f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a rectangle within a planar YV12 or IYUV texture with new pixel data.  <br /></td></tr>
<tr class="separator:a7ddf202449e6271ea46e2e1ccfb62f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03be377c1b2770c7b2d610d280b8ba87" id="r_a03be377c1b2770c7b2d610d280b8ba87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#a03be377c1b2770c7b2d610d280b8ba87">UpdateNV</a> (<a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_Rect &gt; rect, const Uint8 *Yplane, int Ypitch, const Uint8 *UVplane, int UVpitch)</td></tr>
<tr class="memdesc:a03be377c1b2770c7b2d610d280b8ba87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a rectangle within a planar NV12 or NV21 texture with new pixels.  <br /></td></tr>
<tr class="separator:a03be377c1b2770c7b2d610d280b8ba87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22af7ea5864e54b16641a14ee17f6fc" id="r_ae22af7ea5864e54b16641a14ee17f6fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1TextureLock.html">TextureLock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#ae22af7ea5864e54b16641a14ee17f6fc">Lock</a> (<a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_Rect &gt; rect) &amp;</td></tr>
<tr class="memdesc:ae22af7ea5864e54b16641a14ee17f6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a portion of the texture for <b>write-only</b> pixel access.  <br /></td></tr>
<tr class="separator:ae22af7ea5864e54b16641a14ee17f6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64977c5b509bb54fc412ec577c7db2e5" id="r_a64977c5b509bb54fc412ec577c7db2e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1TextureBase.html#a64977c5b509bb54fc412ec577c7db2e5">Destroy</a> ()</td></tr>
<tr class="memdesc:a64977c5b509bb54fc412ec577c7db2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the texture.  <br /></td></tr>
<tr class="separator:a64977c5b509bb54fc412ec577c7db2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt;<br />
struct SDL::TextureBase&lt; T &gt;</div><p>An efficient driver-specific representation of pixel data. </p>
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l01730">1730</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a26b12859b23ad925ae7bed0c81ab0f46" name="a26b12859b23ad925ae7bed0c81ab0f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b12859b23ad925ae7bed0c81ab0f46">&#9670;&#160;</a></span>TextureBase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::TextureBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryVideo.html#ga3c15747c0c3091d37a2f14511aba1c7d">RendererRef</a>&#160;</td>
          <td class="paramname"><em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL_1_1PixelFormat.html">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryRender.html#ga736d13caaeee38a712dfb94180a24f56">TextureAccess</a>&#160;</td>
          <td class="paramname"><em>access</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a texture for a rendering context. </p>
<p>The contents of a texture when first created are not defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderer</td><td>the rendering context. </td></tr>
    <tr><td class="paramname">format</td><td>one of the enumerated values in SDL_PixelFormat. </td></tr>
    <tr><td class="paramname">access</td><td>one of the enumerated values in SDL_TextureAccess. </td></tr>
    <tr><td class="paramname">w</td><td>the width of the texture in pixels. </td></tr>
    <tr><td class="paramname">h</td><td>the height of the texture in pixels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>the created texture is convertible to true on success or false on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1TextureBase.html#ae8c2276d3c39fc28b1d185f14f23828b">GetSize()</a> </dd>
<dd>
<a class="el" href="structSDL_1_1TextureBase.html#a81636b580893caa1f578d7caae0419cf" title="Update the given texture rectangle with new pixel data.">Update()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l01754">1754</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="ac9fb768abf109729277163693dfef21e" name="ac9fb768abf109729277163693dfef21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9fb768abf109729277163693dfef21e">&#9670;&#160;</a></span>TextureBase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::TextureBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryVideo.html#ga3c15747c0c3091d37a2f14511aba1c7d">RendererRef</a>&#160;</td>
          <td class="paramname"><em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategorySurface.html#ga2ea8e6016ec594c51738ef06f469d5d2">SurfaceRef</a>&#160;</td>
          <td class="paramname"><em>surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a texture from an existing surface. </p>
<p>The surface is not modified or freed by this function.</p>
<p>The SDL_TextureAccess hint for the created texture is <code>SDL_TEXTUREACCESS_STATIC</code>.</p>
<p>The pixel format of the created texture may be different from the pixel format of the surface, and can be queried using the SDL_PROP_TEXTURE_FORMAT_NUMBER property.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderer</td><td>the rendering context. </td></tr>
    <tr><td class="paramname">surface</td><td>the SDL_Surface structure containing pixel data used to fill the texture. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>the created texture is convertible to true on success or false on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1TextureBase.html#ae8c2276d3c39fc28b1d185f14f23828b">GetSize()</a> </dd>
<dd>
<a class="el" href="structSDL_1_1TextureBase.html#a81636b580893caa1f578d7caae0419cf" title="Update the given texture rectangle with new pixel data.">Update()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l01788">1788</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="adf253d6d8727fca312e9707681ced937" name="adf253d6d8727fca312e9707681ced937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf253d6d8727fca312e9707681ced937">&#9670;&#160;</a></span>TextureBase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::TextureBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryVideo.html#ga3c15747c0c3091d37a2f14511aba1c7d">RendererRef</a>&#160;</td>
          <td class="paramname"><em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryProperties.html#gaa5faab1a5ca99f759b68b5800ab0697f">PropertiesRef</a>&#160;</td>
          <td class="paramname"><em>props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a texture for a rendering context with the specified properties. </p>
<p>These are the supported properties:</p>
<ul>
<li><code>SDL_PROP_TEXTURE_CREATE_COLORSPACE_NUMBER</code>: an SDL_Colorspace value describing the texture colorspace, defaults to SDL_COLORSPACE_SRGB_LINEAR for floating point textures, SDL_COLORSPACE_HDR10 for 10-bit textures, SDL_COLORSPACE_SRGB for other RGB textures and SDL_COLORSPACE_JPEG for YUV textures.</li>
<li><code>SDL_PROP_TEXTURE_CREATE_FORMAT_NUMBER</code>: one of the enumerated values in SDL_PixelFormat, defaults to the best RGBA format for the renderer</li>
<li><code>SDL_PROP_TEXTURE_CREATE_ACCESS_NUMBER</code>: one of the enumerated values in SDL_TextureAccess, defaults to SDL_TEXTUREACCESS_STATIC</li>
<li><code>SDL_PROP_TEXTURE_CREATE_WIDTH_NUMBER</code>: the width of the texture in pixels, required</li>
<li><code>SDL_PROP_TEXTURE_CREATE_HEIGHT_NUMBER</code>: the height of the texture in pixels, required</li>
<li><code>SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT</code>: for HDR10 and floating point textures, this defines the value of 100% diffuse white, with higher values being displayed in the High Dynamic Range headroom. This defaults to 100 for HDR10 textures and 1.0 for floating point textures.</li>
<li><code>SDL_PROP_TEXTURE_CREATE_HDR_HEADROOM_FLOAT</code>: for HDR10 and floating point textures, this defines the maximum dynamic range used by the content, in terms of the SDR white point. This would be equivalent to maxCLL / SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT for HDR10 content. If this is defined, any values outside the range supported by the display will be scaled into the available HDR headroom, otherwise they are clipped.</li>
</ul>
<p>With the direct3d11 renderer:</p>
<ul>
<li><code>SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_POINTER</code>: the ID3D11Texture2D associated with the texture, if you want to wrap an existing texture.</li>
<li><code>SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_U_POINTER</code>: the ID3D11Texture2D associated with the U plane of a YUV texture, if you want to wrap an existing texture.</li>
<li><code>SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_V_POINTER</code>: the ID3D11Texture2D associated with the V plane of a YUV texture, if you want to wrap an existing texture.</li>
</ul>
<p>With the direct3d12 renderer:</p>
<ul>
<li><code>SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_POINTER</code>: the ID3D12Resource associated with the texture, if you want to wrap an existing texture.</li>
<li><code>SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_U_POINTER</code>: the ID3D12Resource associated with the U plane of a YUV texture, if you want to wrap an existing texture.</li>
<li><code>SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_V_POINTER</code>: the ID3D12Resource associated with the V plane of a YUV texture, if you want to wrap an existing texture.</li>
</ul>
<p>With the metal renderer:</p>
<ul>
<li><code>SDL_PROP_TEXTURE_CREATE_METAL_PIXELBUFFER_POINTER</code>: the CVPixelBufferRef associated with the texture, if you want to create a texture from an existing pixel buffer.</li>
</ul>
<p>With the opengl renderer:</p>
<ul>
<li><code>SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_NUMBER</code>: the GLuint texture associated with the texture, if you want to wrap an existing texture.</li>
<li><code>SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_UV_NUMBER</code>: the GLuint texture associated with the UV plane of an NV12 texture, if you want to wrap an existing texture.</li>
<li><code>SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_U_NUMBER</code>: the GLuint texture associated with the U plane of a YUV texture, if you want to wrap an existing texture.</li>
<li><code>SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_V_NUMBER</code>: the GLuint texture associated with the V plane of a YUV texture, if you want to wrap an existing texture.</li>
</ul>
<p>With the opengles2 renderer:</p>
<ul>
<li><code>SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER</code>: the GLuint texture associated with the texture, if you want to wrap an existing texture.</li>
<li><code>SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER</code>: the GLuint texture associated with the texture, if you want to wrap an existing texture.</li>
<li><code>SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_UV_NUMBER</code>: the GLuint texture associated with the UV plane of an NV12 texture, if you want to wrap an existing texture.</li>
<li><code>SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_U_NUMBER</code>: the GLuint texture associated with the U plane of a YUV texture, if you want to wrap an existing texture.</li>
<li><code>SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_V_NUMBER</code>: the GLuint texture associated with the V plane of a YUV texture, if you want to wrap an existing texture.</li>
</ul>
<p>With the vulkan renderer:</p>
<ul>
<li><code>SDL_PROP_TEXTURE_CREATE_VULKAN_TEXTURE_NUMBER</code>: the VkImage with layout VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL associated with the texture, if you want to wrap an existing texture.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderer</td><td>the rendering context. </td></tr>
    <tr><td class="paramname">props</td><td>the properties to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>the created texture is convertible to true on success or false on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_CreateProperties </dd>
<dd>
SDL_CreateTexture </dd>
<dd>
SDL_CreateTextureFromSurface </dd>
<dd>
SDL_DestroyTexture </dd>
<dd>
SDL_GetTextureSize </dd>
<dd>
SDL_UpdateTexture </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l01903">1903</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a64977c5b509bb54fc412ec577c7db2e5" name="a64977c5b509bb54fc412ec577c7db2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64977c5b509bb54fc412ec577c7db2e5">&#9670;&#160;</a></span>Destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::Destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the texture. </p>
<p>This object becomes empty after the call.</p>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_CreateTexture </dd>
<dd>
SDL_CreateTextureFromSurface </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02504">2504</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="acc7d66e8309fcf784ffae07c85decae5" name="acc7d66e8309fcf784ffae07c85decae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7d66e8309fcf784ffae07c85decae5">&#9670;&#160;</a></span>GetAlphaMod() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; float &gt; <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::GetAlphaMod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02234">2234</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="a4206de1417b0b360c2a6639ee9d2831e" name="a4206de1417b0b360c2a6639ee9d2831e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4206de1417b0b360c2a6639ee9d2831e">&#9670;&#160;</a></span>GetAlphaMod() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::GetAlphaMod </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the additional alpha value multiplied into render copy operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>a pointer filled in with the current alpha value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02267">2267</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="ae2982c1ed7424b984cccfd8853b2672c" name="ae2982c1ed7424b984cccfd8853b2672c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2982c1ed7424b984cccfd8853b2672c">&#9670;&#160;</a></span>GetAlphaMod() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::GetAlphaMod </td>
          <td>(</td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the additional alpha value multiplied into render copy operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>a pointer filled in with the current alpha value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02251">2251</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="a4a3c958172e938068fcf0c765e7b875e" name="a4a3c958172e938068fcf0c765e7b875e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a3c958172e938068fcf0c765e7b875e">&#9670;&#160;</a></span>GetBlendMode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="group__CategoryBlendmode.html#gad02afeb206989ff841629dca2c93e694">BlendMode</a> &gt; <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::GetBlendMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the blend mode used for texture copy operations. </p>
<dl class="section return"><dt>Returns</dt><dd>the current SDL_BlendMode on success or std::nullopt on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_SetTextureBlendMode </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02305">2305</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="a70abd6612312bd12c9a042fedb6c657d" name="a70abd6612312bd12c9a042fedb6c657d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70abd6612312bd12c9a042fedb6c657d">&#9670;&#160;</a></span>GetColorAndAlphaMod() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structSDL_1_1FColor.html">FColor</a> &gt; <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::GetColorAndAlphaMod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02054">2054</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="ae310315ba2462c76d195f178489f7fbf" name="ae310315ba2462c76d195f178489f7fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae310315ba2462c76d195f178489f7fbf">&#9670;&#160;</a></span>GetColorAndAlphaMod() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::GetColorAndAlphaMod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1Color.html">Color</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02060">2060</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="a8017ad0db340645b46f5f44d4fff5331" name="a8017ad0db340645b46f5f44d4fff5331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8017ad0db340645b46f5f44d4fff5331">&#9670;&#160;</a></span>GetColorAndAlphaMod() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::GetColorAndAlphaMod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1FColor.html">FColor</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02066">2066</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="a0f87d581822d704d475c8951f8e5bb18" name="a0f87d581822d704d475c8951f8e5bb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f87d581822d704d475c8951f8e5bb18">&#9670;&#160;</a></span>GetColorMod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::GetColorMod </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the additional color value multiplied into render copy operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>a pointer filled in with the current red color value. </td></tr>
    <tr><td class="paramname">g</td><td>a pointer filled in with the current green color value. </td></tr>
    <tr><td class="paramname">b</td><td>a pointer filled in with the current blue color value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_GetTextureAlphaModFloat </dd>
<dd>
SDL_GetTextureColorMod </dd>
<dd>
SDL_SetTextureColorModFloat </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02173">2173</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="a6d2dd56797426f63d7ff9de7db0113c7" name="a6d2dd56797426f63d7ff9de7db0113c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d2dd56797426f63d7ff9de7db0113c7">&#9670;&#160;</a></span>GetColorMod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::GetColorMod </td>
          <td>(</td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the additional color value multiplied into render copy operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>a pointer filled in with the current red color value. </td></tr>
    <tr><td class="paramname">g</td><td>a pointer filled in with the current green color value. </td></tr>
    <tr><td class="paramname">b</td><td>a pointer filled in with the current blue color value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_GetTextureAlphaMod </dd>
<dd>
SDL_GetTextureColorModFloat </dd>
<dd>
SDL_SetTextureColorMod </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02151">2151</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="a42c6cd85f4d05f3dba98306fc44c031a" name="a42c6cd85f4d05f3dba98306fc44c031a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c6cd85f4d05f3dba98306fc44c031a">&#9670;&#160;</a></span>GetProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategoryProperties.html#gaa5faab1a5ca99f759b68b5800ab0697f">PropertiesRef</a> <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::GetProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the properties associated with a texture. </p>
<p>The following read-only properties are provided by <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a>:</p>
<ul>
<li><code>SDL_PROP_TEXTURE_COLORSPACE_NUMBER</code>: an SDL_Colorspace value describing the texture colorspace.</li>
<li><code>SDL_PROP_TEXTURE_FORMAT_NUMBER</code>: one of the enumerated values in SDL_PixelFormat.</li>
<li><code>SDL_PROP_TEXTURE_ACCESS_NUMBER</code>: one of the enumerated values in SDL_TextureAccess.</li>
<li><code>SDL_PROP_TEXTURE_WIDTH_NUMBER</code>: the width of the texture in pixels.</li>
<li><code>SDL_PROP_TEXTURE_HEIGHT_NUMBER</code>: the height of the texture in pixels.</li>
<li><code>SDL_PROP_TEXTURE_SDR_WHITE_POINT_FLOAT</code>: for HDR10 and floating point textures, this defines the value of 100% diffuse white, with higher values being displayed in the High Dynamic Range headroom. This defaults to 100 for HDR10 textures and 1.0 for other textures.</li>
<li><code>SDL_PROP_TEXTURE_HDR_HEADROOM_FLOAT</code>: for HDR10 and floating point textures, this defines the maximum dynamic range used by the content, in terms of the SDR white point. If this is defined, any values outside the range supported by the display will be scaled into the available HDR headroom, otherwise they are clipped. This defaults to 1.0 for SDR textures, 4.0 for HDR10 textures, and no default for floating point textures.</li>
</ul>
<p>With the direct3d11 renderer:</p>
<ul>
<li><code>SDL_PROP_TEXTURE_D3D11_TEXTURE_POINTER</code>: the ID3D11Texture2D associated with the texture</li>
<li><code>SDL_PROP_TEXTURE_D3D11_TEXTURE_U_POINTER</code>: the ID3D11Texture2D associated with the U plane of a YUV texture</li>
<li><code>SDL_PROP_TEXTURE_D3D11_TEXTURE_V_POINTER</code>: the ID3D11Texture2D associated with the V plane of a YUV texture</li>
</ul>
<p>With the direct3d12 renderer:</p>
<ul>
<li><code>SDL_PROP_TEXTURE_D3D12_TEXTURE_POINTER</code>: the ID3D12Resource associated with the texture</li>
<li><code>SDL_PROP_TEXTURE_D3D12_TEXTURE_U_POINTER</code>: the ID3D12Resource associated with the U plane of a YUV texture</li>
<li><code>SDL_PROP_TEXTURE_D3D12_TEXTURE_V_POINTER</code>: the ID3D12Resource associated with the V plane of a YUV texture</li>
</ul>
<p>With the vulkan renderer:</p>
<ul>
<li><code>SDL_PROP_TEXTURE_VULKAN_TEXTURE_NUMBER</code>: the VkImage associated with the texture</li>
</ul>
<p>With the opengl renderer:</p>
<ul>
<li><code>SDL_PROP_TEXTURE_OPENGL_TEXTURE_NUMBER</code>: the GLuint texture associated with the texture</li>
<li><code>SDL_PROP_TEXTURE_OPENGL_TEXTURE_UV_NUMBER</code>: the GLuint texture associated with the UV plane of an NV12 texture</li>
<li><code>SDL_PROP_TEXTURE_OPENGL_TEXTURE_U_NUMBER</code>: the GLuint texture associated with the U plane of a YUV texture</li>
<li><code>SDL_PROP_TEXTURE_OPENGL_TEXTURE_V_NUMBER</code>: the GLuint texture associated with the V plane of a YUV texture</li>
<li><code>SDL_PROP_TEXTURE_OPENGL_TEXTURE_TARGET_NUMBER</code>: the GLenum for the texture target (<code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_RECTANGLE_ARB</code>, etc)</li>
<li><code>SDL_PROP_TEXTURE_OPENGL_TEX_W_FLOAT</code>: the texture coordinate width of the texture (0.0 - 1.0)</li>
<li><code>SDL_PROP_TEXTURE_OPENGL_TEX_H_FLOAT</code>: the texture coordinate height of the texture (0.0 - 1.0)</li>
</ul>
<p>With the opengles2 renderer:</p>
<ul>
<li><code>SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_NUMBER</code>: the GLuint texture associated with the texture</li>
<li><code>SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_UV_NUMBER</code>: the GLuint texture associated with the UV plane of an NV12 texture</li>
<li><code>SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_U_NUMBER</code>: the GLuint texture associated with the U plane of a YUV texture</li>
<li><code>SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_V_NUMBER</code>: the GLuint texture associated with the V plane of a YUV texture</li>
<li><code>SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_TARGET_NUMBER</code>: the GLenum for the texture target (<code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_EXTERNAL_OES</code>, etc)</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a valid property ID on success or 0 on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l01993">1993</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="a8b9e1d066fc334790c62565de16abfb6" name="a8b9e1d066fc334790c62565de16abfb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9e1d066fc334790c62565de16abfb6">&#9670;&#160;</a></span>GetRenderer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategoryVideo.html#ga3c15747c0c3091d37a2f14511aba1c7d">RendererRef</a> <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::GetRenderer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the renderer that created an SDL_Texture. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the SDL_Renderer that created the texture, or NULL on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02008">2008</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="ac90b3e72433bb962bd7071b8e9ec113d" name="ac90b3e72433bb962bd7071b8e9ec113d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90b3e72433bb962bd7071b8e9ec113d">&#9670;&#160;</a></span>GetScaleMode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="group__CategorySurface.html#gaed7f0fa288a530b226389e23c38e843d">ScaleMode</a> &gt; <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::GetScaleMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the scale mode used for texture scale operations. </p>
<dl class="section return"><dt>Returns</dt><dd>the current scale mode on success or std::nullopt on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_SetTextureScaleMode </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02347">2347</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="ae8c2276d3c39fc28b1d185f14f23828b" name="ae8c2276d3c39fc28b1d185f14f23828b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c2276d3c39fc28b1d185f14f23828b">&#9670;&#160;</a></span>GetSize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structSDL_1_1FPoint.html">FPoint</a> &gt; <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::GetSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02013">2013</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="a849768b5342e6bb1f6948f6e2c7b4e0a" name="a849768b5342e6bb1f6948f6e2c7b4e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849768b5342e6bb1f6948f6e2c7b4e0a">&#9670;&#160;</a></span>GetSize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::GetSize </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of a texture, as floating point values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>a pointer filled in with the width of the texture in pixels. This argument can be NULL if you don't need this information. </td></tr>
    <tr><td class="paramname">h</td><td>a pointer filled in with the height of the texture in pixels. This argument can be NULL if you don't need this information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02039">2039</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="aaa19f25b26c06046bc117f7813a43f75" name="aaa19f25b26c06046bc117f7813a43f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa19f25b26c06046bc117f7813a43f75">&#9670;&#160;</a></span>GetSize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::GetSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1FPoint.html">FPoint</a> *&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02019">2019</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="ae22af7ea5864e54b16641a14ee17f6fc" name="ae22af7ea5864e54b16641a14ee17f6fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22af7ea5864e54b16641a14ee17f6fc">&#9670;&#160;</a></span>Lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1TextureLock.html">TextureLock</a> <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::Lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_Rect &gt;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock a portion of the texture for <b>write-only</b> pixel access. </p>
<p>As an optimization, the pixels made available for editing don't necessarily contain the old texture data. This is a write-only operation, and if you need to keep a copy of the texture data you should do that at the application level.</p>
<p>You must use SDL_UnlockTexture() to unlock the pixels and apply any changes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>an SDL_Rect structure representing the area to lock for access; NULL to lock the entire texture. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSDL_1_1TextureLock.html" title="Locks a Texture for access to its pixels.">TextureLock</a> on success or false if the texture is not valid or was not created with <code>SDL_TEXTUREACCESS_STREAMING</code>; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>TextureLock.UnlockTexture </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02942">2942</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="a6e406273bf30873feabb11c2de6b567a" name="a6e406273bf30873feabb11c2de6b567a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e406273bf30873feabb11c2de6b567a">&#9670;&#160;</a></span>SetAlphaMod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::SetAlphaMod </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an additional alpha value multiplied into render copy operations. </p>
<p>When this texture is rendered, during the copy operation the source alpha value is modulated by this alpha value according to the following formula:</p>
<p><code>srcA = srcA * alpha</code></p>
<p>Alpha modulation is not always supported by the renderer; it will return false if alpha modulation is not supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>the source alpha value multiplied into copy operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_GetTextureAlphaModFloat </dd>
<dd>
SDL_SetTextureAlphaMod </dd>
<dd>
SDL_SetTextureColorModFloat </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02229">2229</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="a5e546ebfbdceb484ae174e142e5bf886" name="a5e546ebfbdceb484ae174e142e5bf886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e546ebfbdceb484ae174e142e5bf886">&#9670;&#160;</a></span>SetAlphaMod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::SetAlphaMod </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an additional alpha value multiplied into render copy operations. </p>
<p>When this texture is rendered, during the copy operation the source alpha value is modulated by this alpha value according to the following formula:</p>
<p><code>srcA = srcA * (alpha / 255)</code></p>
<p>Alpha modulation is not always supported by the renderer; it will return false if alpha modulation is not supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>the source alpha value multiplied into copy operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_GetTextureAlphaMod </dd>
<dd>
SDL_SetTextureAlphaModFloat </dd>
<dd>
SDL_SetTextureColorMod </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02201">2201</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="a4025ebbafd04fb89e57163fb8b3c8a9a" name="a4025ebbafd04fb89e57163fb8b3c8a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4025ebbafd04fb89e57163fb8b3c8a9a">&#9670;&#160;</a></span>SetBlendMode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::SetBlendMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryBlendmode.html#gad02afeb206989ff841629dca2c93e694">BlendMode</a>&#160;</td>
          <td class="paramname"><em>blendMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the blend mode for a texture, used by SDL_RenderTexture(). </p>
<p>If the blend mode is not supported, the closest supported mode is chosen and this function returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blendMode</td><td>the SDL_BlendMode to use for texture blending. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_GetTextureBlendMode </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02288">2288</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="a89325d1df6c6c5d0b8bb3500c78b913f" name="a89325d1df6c6c5d0b8bb3500c78b913f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89325d1df6c6c5d0b8bb3500c78b913f">&#9670;&#160;</a></span>SetColorAndAlphaMod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::SetColorAndAlphaMod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02044">2044</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="a1a00dde2a1f4a8432c15c681e75068cc" name="a1a00dde2a1f4a8432c15c681e75068cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a00dde2a1f4a8432c15c681e75068cc">&#9670;&#160;</a></span>SetColorAndAlphaMod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::SetColorAndAlphaMod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL_1_1FColor.html">FColor</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02049">2049</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="af960bb27cc9047ad618ff136cc9cb668" name="af960bb27cc9047ad618ff136cc9cb668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af960bb27cc9047ad618ff136cc9cb668">&#9670;&#160;</a></span>SetColorMod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::SetColorMod </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an additional color value multiplied into render copy operations. </p>
<p>When this texture is rendered, during the copy operation each source color channel is modulated by the appropriate color value according to the following formula:</p>
<p><code>srcC = srcC * color</code></p>
<p><a class="el" href="structSDL_1_1Color.html" title="A structure that represents a color as RGBA components.">Color</a> modulation is not always supported by the renderer; it will return false if color modulation is not supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the red color value multiplied into copy operations. </td></tr>
    <tr><td class="paramname">g</td><td>the green color value multiplied into copy operations. </td></tr>
    <tr><td class="paramname">b</td><td>the blue color value multiplied into copy operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_GetTextureColorModFloat </dd>
<dd>
SDL_SetTextureAlphaModFloat </dd>
<dd>
SDL_SetTextureColorMod </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02129">2129</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="a187e90f3e1253dc53223d348f3b591c8" name="a187e90f3e1253dc53223d348f3b591c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187e90f3e1253dc53223d348f3b591c8">&#9670;&#160;</a></span>SetColorMod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::SetColorMod </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an additional color value multiplied into render copy operations. </p>
<p>When this texture is rendered, during the copy operation each source color channel is modulated by the appropriate color value according to the following formula:</p>
<p><code>srcC = srcC * (color / 255)</code></p>
<p><a class="el" href="structSDL_1_1Color.html" title="A structure that represents a color as RGBA components.">Color</a> modulation is not always supported by the renderer; it will return false if color modulation is not supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the red color value multiplied into copy operations. </td></tr>
    <tr><td class="paramname">g</td><td>the green color value multiplied into copy operations. </td></tr>
    <tr><td class="paramname">b</td><td>the blue color value multiplied into copy operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_GetTextureColorMod </dd>
<dd>
SDL_SetTextureAlphaMod </dd>
<dd>
SDL_SetTextureColorModFloat </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02098">2098</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="a26ee8437cbeef93d2cafe817bf6df970" name="a26ee8437cbeef93d2cafe817bf6df970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ee8437cbeef93d2cafe817bf6df970">&#9670;&#160;</a></span>SetScaleMode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::SetScaleMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategorySurface.html#gaed7f0fa288a530b226389e23c38e843d">ScaleMode</a>&#160;</td>
          <td class="paramname"><em>scaleMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the scale mode used for texture scale operations. </p>
<p>The default texture scale mode is SDL_SCALEMODE_LINEAR.</p>
<p>If the scale mode is not supported, the closest supported mode is chosen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleMode</td><td>the SDL_ScaleMode to use for texture scaling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_GetTextureScaleMode </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02330">2330</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="a81636b580893caa1f578d7caae0419cf" name="a81636b580893caa1f578d7caae0419cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81636b580893caa1f578d7caae0419cf">&#9670;&#160;</a></span>Update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::Update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_Rect &gt;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pitch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the given texture rectangle with new pixel data. </p>
<p>The pixel data must be in the pixel format of the texture, which can be queried using the SDL_PROP_TEXTURE_FORMAT_NUMBER property.</p>
<p>This is a fairly slow function, intended for use with static textures that do not change often.</p>
<p>If the texture is intended to be updated often, it is preferred to create the texture as streaming and use the locking functions referenced below. While this function will work with streaming textures, for optimization reasons you may not get the pixels back if you lock the texture afterward.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>an SDL_Rect structure representing the area to update, or NULL to update the entire texture. </td></tr>
    <tr><td class="paramname">pixels</td><td>the raw pixel data in the format of the texture. </td></tr>
    <tr><td class="paramname">pitch</td><td>the number of bytes in a row of pixel data, including padding between lines. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_LockTexture </dd>
<dd>
SDL_UnlockTexture </dd>
<dd>
SDL_UpdateNVTexture </dd>
<dd>
SDL_UpdateYUVTexture </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02386">2386</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="a03be377c1b2770c7b2d610d280b8ba87" name="a03be377c1b2770c7b2d610d280b8ba87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03be377c1b2770c7b2d610d280b8ba87">&#9670;&#160;</a></span>UpdateNV()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::UpdateNV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_Rect &gt;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Uint8 *&#160;</td>
          <td class="paramname"><em>Yplane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Ypitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Uint8 *&#160;</td>
          <td class="paramname"><em>UVplane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>UVpitch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update a rectangle within a planar NV12 or NV21 texture with new pixels. </p>
<p>You can use SDL_UpdateTexture() as long as your pixel data is a contiguous block of NV12/21 planes in the proper order, but this function is available if your pixel data is not contiguous.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>a pointer to the rectangle of pixels to update, or NULL to update the entire texture. </td></tr>
    <tr><td class="paramname">Yplane</td><td>the raw pixel data for the Y plane. </td></tr>
    <tr><td class="paramname">Ypitch</td><td>the number of bytes between rows of pixel data for the Y plane. </td></tr>
    <tr><td class="paramname">UVplane</td><td>the raw pixel data for the UV plane. </td></tr>
    <tr><td class="paramname">UVpitch</td><td>the number of bytes between rows of pixel data for the UV plane. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_UpdateTexture </dd>
<dd>
SDL_UpdateYUVTexture </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02457">2457</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<a id="a7ddf202449e6271ea46e2e1ccfb62f7f" name="a7ddf202449e6271ea46e2e1ccfb62f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ddf202449e6271ea46e2e1ccfb62f7f">&#9670;&#160;</a></span>UpdateYUV()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Texture * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1TextureBase.html">SDL::TextureBase</a>&lt; T &gt;::UpdateYUV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">OptionalRef</a>&lt; const SDL_Rect &gt;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Uint8 *&#160;</td>
          <td class="paramname"><em>Yplane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Ypitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Uint8 *&#160;</td>
          <td class="paramname"><em>Uplane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Upitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Uint8 *&#160;</td>
          <td class="paramname"><em>Vplane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Vpitch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update a rectangle within a planar YV12 or IYUV texture with new pixel data. </p>
<p>You can use SDL_UpdateTexture() as long as your pixel data is a contiguous block of Y and U/V planes in the proper order, but this function is available if your pixel data is not contiguous.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>a pointer to the rectangle of pixels to update, or NULL to update the entire texture. </td></tr>
    <tr><td class="paramname">Yplane</td><td>the raw pixel data for the Y plane. </td></tr>
    <tr><td class="paramname">Ypitch</td><td>the number of bytes between rows of pixel data for the Y plane. </td></tr>
    <tr><td class="paramname">Uplane</td><td>the raw pixel data for the U plane. </td></tr>
    <tr><td class="paramname">Upitch</td><td>the number of bytes between rows of pixel data for the U plane. </td></tr>
    <tr><td class="paramname">Vplane</td><td>the raw pixel data for the V plane. </td></tr>
    <tr><td class="paramname">Vpitch</td><td>the number of bytes between rows of pixel data for the V plane. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function should only be called on the main thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="structSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_UpdateNVTexture </dd>
<dd>
SDL_UpdateTexture </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__render_8h_source.html#l02420">2420</a> of file <a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>SDL3pp/<a class="el" href="SDL3pp__render_8h_source.html">SDL3pp_render.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
