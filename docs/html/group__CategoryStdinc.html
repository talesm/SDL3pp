<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDL3pp: Standard Library Functionality</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SDL3pp
   </div>
   <div id="projectbrief">A slim C++ wrapper for SDL3</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Standard Library Functionality<div class="ingroups"><a class="el" href="group__Categories.html">Categories</a> &raquo; <a class="el" href="group__CategoriesAdditionalFunctionality.html">Additional Functionality</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> provides its own implementation of some of the most important C runtime functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1Time.html">SDL::Time</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> times are signed, 64-bit integers representing nanoseconds since the Unix epoch (Jan 1, 1970).  <a href="classSDL_1_1Time.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1EnvironmentRef.html">SDL::EnvironmentRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread-safe set of environment variables.  <a href="structSDL_1_1EnvironmentRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1EnvironmentUnsafe.html">SDL::EnvironmentUnsafe</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsafe Handle to environment.  <a href="structSDL_1_1EnvironmentUnsafe.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1Environment.html">SDL::Environment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to an owned environment.  <a href="structSDL_1_1Environment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1Random.html">SDL::Random</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A independent pseudo random state.  <a href="classSDL_1_1Random.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IConvRef.html">SDL::IConvRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque handle representing string encoding conversion state.  <a href="structSDL_1_1IConvRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IConvUnsafe.html">SDL::IConvUnsafe</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsafe Handle to iConv.  <a href="structSDL_1_1IConvUnsafe.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IConv.html">SDL::IConv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to an owned iConv.  <a href="structSDL_1_1IConv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga2b35b3812c6652e64796f5af95bf43e6" id="r_ga2b35b3812c6652e64796f5af95bf43e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga2b35b3812c6652e64796f5af95bf43e6">SDL_NOLONGLONG</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga2b35b3812c6652e64796f5af95bf43e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Don't let <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> use "long long" C types.  <br /></td></tr>
<tr class="separator:ga2b35b3812c6652e64796f5af95bf43e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30ef3920f62e49c277e95a80c8f306ac" id="r_ga30ef3920f62e49c277e95a80c8f306ac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga30ef3920f62e49c277e95a80c8f306ac">SDL_SIZE_MAX</a>&#160;&#160;&#160;SIZE_MAX</td></tr>
<tr class="memdesc:ga30ef3920f62e49c277e95a80c8f306ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The largest value that a <code>size_t</code> can hold for the target platform.  <br /></td></tr>
<tr class="separator:ga30ef3920f62e49c277e95a80c8f306ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6450d7299f093c95c1bfa8186fa4c866" id="r_ga6450d7299f093c95c1bfa8186fa4c866"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga6450d7299f093c95c1bfa8186fa4c866">SDL_STRINGIFY_ARG</a>(arg)&#160;&#160;&#160;#arg</td></tr>
<tr class="memdesc:ga6450d7299f093c95c1bfa8186fa4c866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro useful for building other macros with strings in them.  <br /></td></tr>
<tr class="separator:ga6450d7299f093c95c1bfa8186fa4c866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff2300e33654fc4e321c53de366f700a" id="r_gaff2300e33654fc4e321c53de366f700a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaff2300e33654fc4e321c53de366f700a">SDL_SINT64_C</a>(c)&#160;&#160;&#160;c##LL /* or whatever the current compiler uses. */</td></tr>
<tr class="memdesc:gaff2300e33654fc4e321c53de366f700a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the 64 bit integer suffix to a signed integer literal.  <br /></td></tr>
<tr class="separator:gaff2300e33654fc4e321c53de366f700a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04f4178023c83926428200578ff69184" id="r_ga04f4178023c83926428200578ff69184"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga04f4178023c83926428200578ff69184">SDL_UINT64_C</a>(c)&#160;&#160;&#160;c##ULL /* or whatever the current compiler uses. */</td></tr>
<tr class="memdesc:ga04f4178023c83926428200578ff69184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the 64 bit integer suffix to an unsigned integer literal.  <br /></td></tr>
<tr class="separator:ga04f4178023c83926428200578ff69184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa679b0c4343b25d2a2fa8f6c18ff6e54" id="r_gaa679b0c4343b25d2a2fa8f6c18ff6e54"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa679b0c4343b25d2a2fa8f6c18ff6e54">SDL_FLT_EPSILON</a>&#160;&#160;&#160;1.1920928955078125e-07F /* 0x0.000002p0 */</td></tr>
<tr class="memdesc:gaa679b0c4343b25d2a2fa8f6c18ff6e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epsilon constant, used for comparing floating-point numbers.  <br /></td></tr>
<tr class="separator:gaa679b0c4343b25d2a2fa8f6c18ff6e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad520b6fa62d69fe36edadb0925196aa" id="r_gaad520b6fa62d69fe36edadb0925196aa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaad520b6fa62d69fe36edadb0925196aa">SDL_INIT_INTERFACE</a>(iface)</td></tr>
<tr class="memdesc:gaad520b6fa62d69fe36edadb0925196aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro to initialize an <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> interface.  <br /></td></tr>
<tr class="separator:gaad520b6fa62d69fe36edadb0925196aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa20b552293de849b3c1c7576cb158e9e" id="r_gaa20b552293de849b3c1c7576cb158e9e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa20b552293de849b3c1c7576cb158e9e">SDL_copyp</a>(dst,  src)</td></tr>
<tr class="memdesc:gaa20b552293de849b3c1c7576cb158e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro to copy memory between objects, with basic type checking.  <br /></td></tr>
<tr class="separator:gaa20b552293de849b3c1c7576cb158e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada422bea61b05ed228c4f42e4aea2144" id="r_gada422bea61b05ed228c4f42e4aea2144"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gada422bea61b05ed228c4f42e4aea2144">SDL_ICONV_ERROR</a>&#160;&#160;&#160;(size_t)-1</td></tr>
<tr class="memdesc:gada422bea61b05ed228c4f42e4aea2144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic error.  <br /></td></tr>
<tr class="separator:gada422bea61b05ed228c4f42e4aea2144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8147462b96bda427f0b41125e645b9ab" id="r_ga8147462b96bda427f0b41125e645b9ab"><td class="memItemLeft" align="right" valign="top"><a id="ga8147462b96bda427f0b41125e645b9ab" name="ga8147462b96bda427f0b41125e645b9ab"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SDL_ICONV_E2BIG</b>&#160;&#160;&#160;(size_t)-2</td></tr>
<tr class="memdesc:ga8147462b96bda427f0b41125e645b9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output buffer was too small. <br /></td></tr>
<tr class="separator:ga8147462b96bda427f0b41125e645b9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc8b6997623c449e7ed53a605faa9eb0" id="r_gadc8b6997623c449e7ed53a605faa9eb0"><td class="memItemLeft" align="right" valign="top"><a id="gadc8b6997623c449e7ed53a605faa9eb0" name="gadc8b6997623c449e7ed53a605faa9eb0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SDL_ICONV_EILSEQ</b>&#160;&#160;&#160;(size_t)-3</td></tr>
<tr class="memdesc:gadc8b6997623c449e7ed53a605faa9eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid input sequence was encountered. <br /></td></tr>
<tr class="separator:gadc8b6997623c449e7ed53a605faa9eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03d30a2857731df69d31ffa802424a9e" id="r_ga03d30a2857731df69d31ffa802424a9e"><td class="memItemLeft" align="right" valign="top"><a id="ga03d30a2857731df69d31ffa802424a9e" name="ga03d30a2857731df69d31ffa802424a9e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SDL_ICONV_EINVAL</b>&#160;&#160;&#160;(size_t)-4</td></tr>
<tr class="memdesc:ga03d30a2857731df69d31ffa802424a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incomplete input sequence was encountered. <br /></td></tr>
<tr class="separator:ga03d30a2857731df69d31ffa802424a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga773e5f83e392495ad8abab8d71aa84c6" id="r_ga773e5f83e392495ad8abab8d71aa84c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga773e5f83e392495ad8abab8d71aa84c6">SDL_iconv_utf8_locale</a>(S)&#160;&#160;&#160;  SDL_iconv_string(&quot;&quot;, &quot;UTF-8&quot;, S, SDL_strlen(S) + 1)</td></tr>
<tr class="memdesc:ga773e5f83e392495ad8abab8d71aa84c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a UTF-8 string to the current locale's character encoding.  <br /></td></tr>
<tr class="separator:ga773e5f83e392495ad8abab8d71aa84c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59cd43c02306558671fe05c23284ab3b" id="r_ga59cd43c02306558671fe05c23284ab3b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga59cd43c02306558671fe05c23284ab3b">SDL_iconv_utf8_ucs2</a>(S)&#160;&#160;&#160;  (Uint16*)SDL_iconv_string(&quot;UCS-2&quot;, &quot;UTF-8&quot;, S, SDL_strlen(S) + 1)</td></tr>
<tr class="memdesc:ga59cd43c02306558671fe05c23284ab3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a UTF-8 string to UCS-2.  <br /></td></tr>
<tr class="separator:ga59cd43c02306558671fe05c23284ab3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdced7c8985d280d87e659f583a5479e" id="r_gacdced7c8985d280d87e659f583a5479e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gacdced7c8985d280d87e659f583a5479e">SDL_iconv_utf8_ucs4</a>(S)&#160;&#160;&#160;  (Uint32*)SDL_iconv_string(&quot;UCS-4&quot;, &quot;UTF-8&quot;, S, SDL_strlen(S) + 1)</td></tr>
<tr class="memdesc:gacdced7c8985d280d87e659f583a5479e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a UTF-8 string to UCS-4.  <br /></td></tr>
<tr class="separator:gacdced7c8985d280d87e659f583a5479e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaf3cc7fc7c497cbd3f16ddcd85a8fb5" id="r_gafaf3cc7fc7c497cbd3f16ddcd85a8fb5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gafaf3cc7fc7c497cbd3f16ddcd85a8fb5">SDL_iconv_wchar_utf8</a>(S)</td></tr>
<tr class="memdesc:gafaf3cc7fc7c497cbd3f16ddcd85a8fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a wchar_t string to UTF-8.  <br /></td></tr>
<tr class="separator:gafaf3cc7fc7c497cbd3f16ddcd85a8fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga3d946d3193f4374bec115170e4e5152a" id="r_ga3d946d3193f4374bec115170e4e5152a"><td class="memItemLeft" align="right" valign="top"><a id="ga3d946d3193f4374bec115170e4e5152a" name="ga3d946d3193f4374bec115170e4e5152a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::Seconds</b> = std::chrono::duration&lt; float &gt;</td></tr>
<tr class="memdesc:ga3d946d3193f4374bec115170e4e5152a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duration in seconds (float). <br /></td></tr>
<tr class="separator:ga3d946d3193f4374bec115170e4e5152a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70b3f6375d1dd34a431d52b44f1c0034" id="r_ga70b3f6375d1dd34a431d52b44f1c0034"><td class="memItemLeft" align="right" valign="top"><a id="ga70b3f6375d1dd34a431d52b44f1c0034" name="ga70b3f6375d1dd34a431d52b44f1c0034"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::Nanoseconds</b> = std::chrono::nanoseconds</td></tr>
<tr class="memdesc:ga70b3f6375d1dd34a431d52b44f1c0034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duration in Nanoseconds (Sint64). <br /></td></tr>
<tr class="separator:ga70b3f6375d1dd34a431d52b44f1c0034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20e849be3a477a832c3f5b49aa71f793" id="r_ga20e849be3a477a832c3f5b49aa71f793"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">SDL::malloc_func</a> = SDL_malloc_func</td></tr>
<tr class="memdesc:ga20e849be3a477a832c3f5b49aa71f793"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback used to implement <a class="el" href="group__CategoryStdinc.html#ga48fe5521cb77ff8e4ae442bc8387be70" title="Allocate uninitialized memory.">malloc()</a>.  <br /></td></tr>
<tr class="separator:ga20e849be3a477a832c3f5b49aa71f793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f2714c0d9540b5e1e85ed5503c59215" id="r_ga4f2714c0d9540b5e1e85ed5503c59215"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">SDL::calloc_func</a> = SDL_calloc_func</td></tr>
<tr class="memdesc:ga4f2714c0d9540b5e1e85ed5503c59215"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback used to implement <a class="el" href="group__CategoryStdinc.html#gab24b3e9482f5a1c26602b83f2de05d09" title="Allocate a zero-initialized array.">calloc()</a>.  <br /></td></tr>
<tr class="separator:ga4f2714c0d9540b5e1e85ed5503c59215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0d42a4ebfbbe5ab7908f55ba0560ecb" id="r_gaa0d42a4ebfbbe5ab7908f55ba0560ecb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">SDL::realloc_func</a> = SDL_realloc_func</td></tr>
<tr class="memdesc:gaa0d42a4ebfbbe5ab7908f55ba0560ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback used to implement <a class="el" href="group__CategoryStdinc.html#gab8208c1b381e6a96b07b5facff79c27b" title="Change the size of allocated memory.">realloc()</a>.  <br /></td></tr>
<tr class="separator:gaa0d42a4ebfbbe5ab7908f55ba0560ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80cbbb5b121c8f78d44a66deaa573127" id="r_ga80cbbb5b121c8f78d44a66deaa573127"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">SDL::free_func</a> = SDL_free_func</td></tr>
<tr class="memdesc:ga80cbbb5b121c8f78d44a66deaa573127"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback used to implement <a class="el" href="group__CategoryStdinc.html#gadfa01257ca1f966fffb72f002db27fa6" title="Free allocated memory.">free()</a>.  <br /></td></tr>
<tr class="separator:ga80cbbb5b121c8f78d44a66deaa573127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc94be94823c25031d6dd9210ef3e81a" id="r_gabc94be94823c25031d6dd9210ef3e81a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gabc94be94823c25031d6dd9210ef3e81a">SDL::CompareCallback</a> = SDL_CompareCallback</td></tr>
<tr class="memdesc:gabc94be94823c25031d6dd9210ef3e81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback used with <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> sorting and binary search functions.  <br /></td></tr>
<tr class="separator:gabc94be94823c25031d6dd9210ef3e81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5c634ea2ae9a102fa58cd7beac9f478" id="r_gab5c634ea2ae9a102fa58cd7beac9f478"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab5c634ea2ae9a102fa58cd7beac9f478">SDL::CompareCallback_r</a> = SDL_CompareCallback_r</td></tr>
<tr class="memdesc:gab5c634ea2ae9a102fa58cd7beac9f478"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback used with <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> sorting and binary search functions.  <br /></td></tr>
<tr class="separator:gab5c634ea2ae9a102fa58cd7beac9f478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dc5ada5f1f8fe87900b8fa72e94abca" id="r_ga7dc5ada5f1f8fe87900b8fa72e94abca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga7dc5ada5f1f8fe87900b8fa72e94abca">SDL::CompareCB</a> = std::function&lt; int(const void *, const void *)&gt;</td></tr>
<tr class="memdesc:ga7dc5ada5f1f8fe87900b8fa72e94abca"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback used with <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> sorting and binary search functions.  <br /></td></tr>
<tr class="separator:ga7dc5ada5f1f8fe87900b8fa72e94abca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga379a3713730374c4737a2bfb2004fab7" id="r_ga379a3713730374c4737a2bfb2004fab7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga379a3713730374c4737a2bfb2004fab7">SDL::FunctionPointer</a> = SDL_FunctionPointer</td></tr>
<tr class="memdesc:ga379a3713730374c4737a2bfb2004fab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic function pointer.  <br /></td></tr>
<tr class="separator:ga379a3713730374c4737a2bfb2004fab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga20b4cc6c53a1dbd7789ee90af065b5f9" id="r_ga20b4cc6c53a1dbd7789ee90af065b5f9"><td class="memTemplParams" colspan="2">template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:ga20b4cc6c53a1dbd7789ee90af065b5f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga20b4cc6c53a1dbd7789ee90af065b5f9">SDL::arraysize</a> (const T(&amp;array)[N])</td></tr>
<tr class="memdesc:ga20b4cc6c53a1dbd7789ee90af065b5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of elements in a static array.  <br /></td></tr>
<tr class="separator:ga20b4cc6c53a1dbd7789ee90af065b5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa932b3872f6162d7257c924b184e5381" id="r_gaa932b3872f6162d7257c924b184e5381"><td class="memItemLeft" align="right" valign="top">constexpr Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa932b3872f6162d7257c924b184e5381">SDL::FourCC</a> (Uint8 a, Uint8 b, Uint8 c, Uint8 d)</td></tr>
<tr class="memdesc:gaa932b3872f6162d7257c924b184e5381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a four character code as a Uint32.  <br /></td></tr>
<tr class="separator:gaa932b3872f6162d7257c924b184e5381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ddf634aaa1781606490dbc710d2c182" id="r_ga7ddf634aaa1781606490dbc710d2c182"><td class="memItemLeft" align="right" valign="top"><a id="ga7ddf634aaa1781606490dbc710d2c182" name="ga7ddf634aaa1781606490dbc710d2c182"></a>
constexpr float&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::ToSeconds</b> (<a class="el" href="group__CategoryStdinc.html#ga3d946d3193f4374bec115170e4e5152a">Seconds</a> duration)</td></tr>
<tr class="memdesc:ga7ddf634aaa1781606490dbc710d2c182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a time duration to seconds (float). <br /></td></tr>
<tr class="separator:ga7ddf634aaa1781606490dbc710d2c182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga826f3a4e90205fda831df93e431881ac" id="r_ga826f3a4e90205fda831df93e431881ac"><td class="memItemLeft" align="right" valign="top"><a id="ga826f3a4e90205fda831df93e431881ac" name="ga826f3a4e90205fda831df93e431881ac"></a>
constexpr <a class="el" href="group__CategoryStdinc.html#ga3d946d3193f4374bec115170e4e5152a">Seconds</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::FromSeconds</b> (float duration)</td></tr>
<tr class="memdesc:ga826f3a4e90205fda831df93e431881ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a float to seconds representation. <br /></td></tr>
<tr class="separator:ga826f3a4e90205fda831df93e431881ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeef0207236cd1a18f3c3287904fb847a" id="r_gaeef0207236cd1a18f3c3287904fb847a"><td class="memItemLeft" align="right" valign="top"><a id="gaeef0207236cd1a18f3c3287904fb847a" name="gaeef0207236cd1a18f3c3287904fb847a"></a>
constexpr Sint64&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::ToNS</b> (std::chrono::nanoseconds duration)</td></tr>
<tr class="memdesc:gaeef0207236cd1a18f3c3287904fb847a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a time duration to nanoseconds (Sint64);. <br /></td></tr>
<tr class="separator:gaeef0207236cd1a18f3c3287904fb847a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad30b4d080eea68663b6b7326840886e" id="r_gaad30b4d080eea68663b6b7326840886e"><td class="memItemLeft" align="right" valign="top"><a id="gaad30b4d080eea68663b6b7326840886e" name="gaad30b4d080eea68663b6b7326840886e"></a>
constexpr <a class="el" href="group__CategoryStdinc.html#ga70b3f6375d1dd34a431d52b44f1c0034">Nanoseconds</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::FromNS</b> (Sint64 duration)</td></tr>
<tr class="memdesc:gaad30b4d080eea68663b6b7326840886e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Sint64 to nanoseconds representation. <br /></td></tr>
<tr class="separator:gaad30b4d080eea68663b6b7326840886e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48fe5521cb77ff8e4ae442bc8387be70" id="r_ga48fe5521cb77ff8e4ae442bc8387be70"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga48fe5521cb77ff8e4ae442bc8387be70">SDL::malloc</a> (size_t size)</td></tr>
<tr class="memdesc:ga48fe5521cb77ff8e4ae442bc8387be70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate uninitialized memory.  <br /></td></tr>
<tr class="separator:ga48fe5521cb77ff8e4ae442bc8387be70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab24b3e9482f5a1c26602b83f2de05d09" id="r_gab24b3e9482f5a1c26602b83f2de05d09"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab24b3e9482f5a1c26602b83f2de05d09">SDL::calloc</a> (size_t nmemb, size_t size)</td></tr>
<tr class="memdesc:gab24b3e9482f5a1c26602b83f2de05d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a zero-initialized array.  <br /></td></tr>
<tr class="separator:gab24b3e9482f5a1c26602b83f2de05d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8208c1b381e6a96b07b5facff79c27b" id="r_gab8208c1b381e6a96b07b5facff79c27b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab8208c1b381e6a96b07b5facff79c27b">SDL::realloc</a> (void *mem, size_t size)</td></tr>
<tr class="memdesc:gab8208c1b381e6a96b07b5facff79c27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the size of allocated memory.  <br /></td></tr>
<tr class="separator:gab8208c1b381e6a96b07b5facff79c27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfa01257ca1f966fffb72f002db27fa6" id="r_gadfa01257ca1f966fffb72f002db27fa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gadfa01257ca1f966fffb72f002db27fa6">SDL::free</a> (void *mem)</td></tr>
<tr class="memdesc:gadfa01257ca1f966fffb72f002db27fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free allocated memory.  <br /></td></tr>
<tr class="separator:gadfa01257ca1f966fffb72f002db27fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6325f645ab936554e7aaa2e4d977d9d7" id="r_ga6325f645ab936554e7aaa2e4d977d9d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga6325f645ab936554e7aaa2e4d977d9d7">SDL::GetOriginalMemoryFunctions</a> (<a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a> *<a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a>, <a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a> *<a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a>, <a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a> *<a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a>, <a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a> *<a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a>)</td></tr>
<tr class="memdesc:ga6325f645ab936554e7aaa2e4d977d9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the original set of <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> memory functions.  <br /></td></tr>
<tr class="separator:ga6325f645ab936554e7aaa2e4d977d9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab331691e9cf41b2fd9063b80910ea6b0" id="r_gab331691e9cf41b2fd9063b80910ea6b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab331691e9cf41b2fd9063b80910ea6b0">SDL::GetMemoryFunctions</a> (<a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a> *<a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a>, <a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a> *<a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a>, <a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a> *<a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a>, <a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a> *<a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a>)</td></tr>
<tr class="memdesc:gab331691e9cf41b2fd9063b80910ea6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current set of <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> memory functions.  <br /></td></tr>
<tr class="separator:gab331691e9cf41b2fd9063b80910ea6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga048ad88f068e4b9b9f81703377d3d1a9" id="r_ga048ad88f068e4b9b9f81703377d3d1a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga048ad88f068e4b9b9f81703377d3d1a9">SDL::SetMemoryFunctions</a> (<a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a> <a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a>, <a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a> <a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a>, <a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a> <a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a>, <a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a> <a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a>)</td></tr>
<tr class="memdesc:ga048ad88f068e4b9b9f81703377d3d1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a>'s memory allocation functions with a custom set.  <br /></td></tr>
<tr class="separator:ga048ad88f068e4b9b9f81703377d3d1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3c9f70ddeadaecb2afeee2b3be34733" id="r_gae3c9f70ddeadaecb2afeee2b3be34733"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae3c9f70ddeadaecb2afeee2b3be34733">SDL::aligned_alloc</a> (size_t alignment, size_t size)</td></tr>
<tr class="memdesc:gae3c9f70ddeadaecb2afeee2b3be34733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory aligned to a specific alignment.  <br /></td></tr>
<tr class="separator:gae3c9f70ddeadaecb2afeee2b3be34733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf1efed697d82742be084a1871c95aa2" id="r_gaaf1efed697d82742be084a1871c95aa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaaf1efed697d82742be084a1871c95aa2">SDL::aligned_free</a> (void *mem)</td></tr>
<tr class="memdesc:gaaf1efed697d82742be084a1871c95aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated by <a class="el" href="group__CategoryStdinc.html#gae3c9f70ddeadaecb2afeee2b3be34733" title="Allocate memory aligned to a specific alignment.">aligned_alloc()</a>.  <br /></td></tr>
<tr class="separator:gaaf1efed697d82742be084a1871c95aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae51ea510815eaec3a9b288754a805206" id="r_gae51ea510815eaec3a9b288754a805206"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae51ea510815eaec3a9b288754a805206">SDL::GetNumAllocations</a> ()</td></tr>
<tr class="memdesc:gae51ea510815eaec3a9b288754a805206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of outstanding (unfreed) allocations.  <br /></td></tr>
<tr class="separator:gae51ea510815eaec3a9b288754a805206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc9e4411ee1c8072c58cbfa0566a5660" id="r_gafc9e4411ee1c8072c58cbfa0566a5660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSDL_1_1EnvironmentRef.html">EnvironmentRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gafc9e4411ee1c8072c58cbfa0566a5660">SDL::GetEnvironment</a> ()</td></tr>
<tr class="memdesc:gafc9e4411ee1c8072c58cbfa0566a5660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the process environment.  <br /></td></tr>
<tr class="separator:gafc9e4411ee1c8072c58cbfa0566a5660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97502b219bb63f4be0f31868fecc9120" id="r_ga97502b219bb63f4be0f31868fecc9120"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga97502b219bb63f4be0f31868fecc9120">SDL::getenv</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> name)</td></tr>
<tr class="memdesc:ga97502b219bb63f4be0f31868fecc9120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a variable in the environment.  <br /></td></tr>
<tr class="separator:ga97502b219bb63f4be0f31868fecc9120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a55c001e123a53e424cbc460ec4b1b6" id="r_ga8a55c001e123a53e424cbc460ec4b1b6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8a55c001e123a53e424cbc460ec4b1b6">SDL::getenv_unsafe</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> name)</td></tr>
<tr class="memdesc:ga8a55c001e123a53e424cbc460ec4b1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a variable in the environment.  <br /></td></tr>
<tr class="separator:ga8a55c001e123a53e424cbc460ec4b1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97da5abe6c940c70b73fc9465cf8e75e" id="r_ga97da5abe6c940c70b73fc9465cf8e75e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga97da5abe6c940c70b73fc9465cf8e75e">SDL::setenv_unsafe</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> name, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> value, int overwrite)</td></tr>
<tr class="memdesc:ga97da5abe6c940c70b73fc9465cf8e75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a variable in the environment.  <br /></td></tr>
<tr class="separator:ga97da5abe6c940c70b73fc9465cf8e75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dc726179e2ae431d7db8164099e333a" id="r_ga7dc726179e2ae431d7db8164099e333a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga7dc726179e2ae431d7db8164099e333a">SDL::unsetenv_unsafe</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> name)</td></tr>
<tr class="memdesc:ga7dc726179e2ae431d7db8164099e333a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a variable from the environment.  <br /></td></tr>
<tr class="separator:ga7dc726179e2ae431d7db8164099e333a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab52a0ec3d96fb4c04972b1b322f75857" id="r_gab52a0ec3d96fb4c04972b1b322f75857"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab52a0ec3d96fb4c04972b1b322f75857">SDL::qsort</a> (void *base, size_t nmemb, size_t size, <a class="el" href="group__CategoryStdinc.html#gabc94be94823c25031d6dd9210ef3e81a">CompareCallback</a> compare)</td></tr>
<tr class="memdesc:gab52a0ec3d96fb4c04972b1b322f75857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an array.  <br /></td></tr>
<tr class="separator:gab52a0ec3d96fb4c04972b1b322f75857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada62aea13b8eceffa3e57359e124e541" id="r_gada62aea13b8eceffa3e57359e124e541"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gada62aea13b8eceffa3e57359e124e541">SDL::bsearch</a> (const void *key, const void *base, size_t nmemb, size_t size, <a class="el" href="group__CategoryStdinc.html#gabc94be94823c25031d6dd9210ef3e81a">CompareCallback</a> compare)</td></tr>
<tr class="memdesc:gada62aea13b8eceffa3e57359e124e541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a binary search on a previously sorted array.  <br /></td></tr>
<tr class="separator:gada62aea13b8eceffa3e57359e124e541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3b0083aa5cb6236224048d437834dd2" id="r_gaa3b0083aa5cb6236224048d437834dd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa3b0083aa5cb6236224048d437834dd2">SDL::qsort_r</a> (void *base, size_t nmemb, size_t size, <a class="el" href="group__CategoryStdinc.html#gab5c634ea2ae9a102fa58cd7beac9f478">CompareCallback_r</a> compare, void *userdata)</td></tr>
<tr class="memdesc:gaa3b0083aa5cb6236224048d437834dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an array, passing a userdata pointer to the compare function.  <br /></td></tr>
<tr class="separator:gaa3b0083aa5cb6236224048d437834dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga702a78756e29c4f8babdb6df497d36fa" id="r_ga702a78756e29c4f8babdb6df497d36fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga702a78756e29c4f8babdb6df497d36fa">SDL::qsort_r</a> (void *base, size_t nmemb, size_t size, <a class="el" href="group__CategoryStdinc.html#ga7dc5ada5f1f8fe87900b8fa72e94abca">CompareCB</a> compare)</td></tr>
<tr class="memdesc:ga702a78756e29c4f8babdb6df497d36fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an array, passing a userdata pointer to the compare function.  <br /></td></tr>
<tr class="separator:ga702a78756e29c4f8babdb6df497d36fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf22f982867b4598c8caa2de8f5a9e0e4" id="r_gaf22f982867b4598c8caa2de8f5a9e0e4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaf22f982867b4598c8caa2de8f5a9e0e4">SDL::bsearch_r</a> (const void *key, const void *base, size_t nmemb, size_t size, <a class="el" href="group__CategoryStdinc.html#gab5c634ea2ae9a102fa58cd7beac9f478">CompareCallback_r</a> compare, void *userdata)</td></tr>
<tr class="memdesc:gaf22f982867b4598c8caa2de8f5a9e0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a binary search on a previously sorted array, passing a userdata pointer to the compare function.  <br /></td></tr>
<tr class="separator:gaf22f982867b4598c8caa2de8f5a9e0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23c5948242cf76d2bcbc0a52c6c53ed8" id="r_ga23c5948242cf76d2bcbc0a52c6c53ed8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga23c5948242cf76d2bcbc0a52c6c53ed8">SDL::bsearch_r</a> (const void *key, const void *base, size_t nmemb, size_t size, <a class="el" href="group__CategoryStdinc.html#ga7dc5ada5f1f8fe87900b8fa72e94abca">CompareCB</a> compare)</td></tr>
<tr class="memdesc:ga23c5948242cf76d2bcbc0a52c6c53ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a binary search on a previously sorted array, passing a userdata pointer to the compare function.  <br /></td></tr>
<tr class="separator:ga23c5948242cf76d2bcbc0a52c6c53ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab188f3aa930df339c851b95bf2c4030b" id="r_gab188f3aa930df339c851b95bf2c4030b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab188f3aa930df339c851b95bf2c4030b">SDL::abs</a> (int x)</td></tr>
<tr class="memdesc:gab188f3aa930df339c851b95bf2c4030b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of <code>x</code>.  <br /></td></tr>
<tr class="separator:gab188f3aa930df339c851b95bf2c4030b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd53991e26e130aa47ac47f23f187ac3" id="r_gadd53991e26e130aa47ac47f23f187ac3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gadd53991e26e130aa47ac47f23f187ac3">SDL::abs</a> (double x)</td></tr>
<tr class="memdesc:gadd53991e26e130aa47ac47f23f187ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of <code>x</code>  <br /></td></tr>
<tr class="separator:gadd53991e26e130aa47ac47f23f187ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac002154c442e2a92fb84a60c454cecf8" id="r_gac002154c442e2a92fb84a60c454cecf8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gac002154c442e2a92fb84a60c454cecf8">SDL::abs</a> (float x)</td></tr>
<tr class="memdesc:gac002154c442e2a92fb84a60c454cecf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of <code>x</code>  <br /></td></tr>
<tr class="separator:gac002154c442e2a92fb84a60c454cecf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37591dc3dcb6bb89de19a61acdec4ef3" id="r_ga37591dc3dcb6bb89de19a61acdec4ef3"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ga37591dc3dcb6bb89de19a61acdec4ef3"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga37591dc3dcb6bb89de19a61acdec4ef3">SDL::min</a> (T x, U y)</td></tr>
<tr class="memdesc:ga37591dc3dcb6bb89de19a61acdec4ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lesser of two values.  <br /></td></tr>
<tr class="separator:ga37591dc3dcb6bb89de19a61acdec4ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74fda1cb69f4e000dc8a42aba05136a0" id="r_ga74fda1cb69f4e000dc8a42aba05136a0"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ga74fda1cb69f4e000dc8a42aba05136a0"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga74fda1cb69f4e000dc8a42aba05136a0">SDL::max</a> (T x, U y)</td></tr>
<tr class="memdesc:ga74fda1cb69f4e000dc8a42aba05136a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greater of two values.  <br /></td></tr>
<tr class="separator:ga74fda1cb69f4e000dc8a42aba05136a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac38a0101c9805315f8ba8872ba4d258" id="r_gaac38a0101c9805315f8ba8872ba4d258"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class V &gt; </td></tr>
<tr class="memitem:gaac38a0101c9805315f8ba8872ba4d258"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaac38a0101c9805315f8ba8872ba4d258">SDL::clamp</a> (T x, U a, V b)</td></tr>
<tr class="memdesc:gaac38a0101c9805315f8ba8872ba4d258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a value clamped to a range.  <br /></td></tr>
<tr class="separator:gaac38a0101c9805315f8ba8872ba4d258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79256765fa0f219b5947721d1d920041" id="r_ga79256765fa0f219b5947721d1d920041"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga79256765fa0f219b5947721d1d920041">SDL::isalpha</a> (int x)</td></tr>
<tr class="memdesc:ga79256765fa0f219b5947721d1d920041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if a character is alphabetic (a letter).  <br /></td></tr>
<tr class="separator:ga79256765fa0f219b5947721d1d920041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc3565e81c3ab6ba0e66f9030c056969" id="r_gafc3565e81c3ab6ba0e66f9030c056969"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gafc3565e81c3ab6ba0e66f9030c056969">SDL::isalnum</a> (int x)</td></tr>
<tr class="memdesc:gafc3565e81c3ab6ba0e66f9030c056969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if a character is alphabetic (a letter) or a number.  <br /></td></tr>
<tr class="separator:gafc3565e81c3ab6ba0e66f9030c056969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6936f2d259cb2959c3d73e8bb66cf0d" id="r_gab6936f2d259cb2959c3d73e8bb66cf0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab6936f2d259cb2959c3d73e8bb66cf0d">SDL::isblank</a> (int x)</td></tr>
<tr class="memdesc:gab6936f2d259cb2959c3d73e8bb66cf0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is blank (a space or tab).  <br /></td></tr>
<tr class="separator:gab6936f2d259cb2959c3d73e8bb66cf0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga901f942513d4469f8722185f0cee85bd" id="r_ga901f942513d4469f8722185f0cee85bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga901f942513d4469f8722185f0cee85bd">SDL::iscntrl</a> (int x)</td></tr>
<tr class="memdesc:ga901f942513d4469f8722185f0cee85bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is a control character.  <br /></td></tr>
<tr class="separator:ga901f942513d4469f8722185f0cee85bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c4d5430375fa896b58aa1e5a23cd30f" id="r_ga3c4d5430375fa896b58aa1e5a23cd30f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga3c4d5430375fa896b58aa1e5a23cd30f">SDL::isdigit</a> (int x)</td></tr>
<tr class="memdesc:ga3c4d5430375fa896b58aa1e5a23cd30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is a numeric digit.  <br /></td></tr>
<tr class="separator:ga3c4d5430375fa896b58aa1e5a23cd30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73d02f4f146603a906c35d50197f6fd6" id="r_ga73d02f4f146603a906c35d50197f6fd6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga73d02f4f146603a906c35d50197f6fd6">SDL::isxdigit</a> (int x)</td></tr>
<tr class="memdesc:ga73d02f4f146603a906c35d50197f6fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is a hexadecimal digit.  <br /></td></tr>
<tr class="separator:ga73d02f4f146603a906c35d50197f6fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1876da5600f8722288dc8641d978fab" id="r_gac1876da5600f8722288dc8641d978fab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gac1876da5600f8722288dc8641d978fab">SDL::ispunct</a> (int x)</td></tr>
<tr class="memdesc:gac1876da5600f8722288dc8641d978fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is a punctuation mark.  <br /></td></tr>
<tr class="separator:gac1876da5600f8722288dc8641d978fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga922904215a42f639a8385470d5e61667" id="r_ga922904215a42f639a8385470d5e61667"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga922904215a42f639a8385470d5e61667">SDL::isspace</a> (int x)</td></tr>
<tr class="memdesc:ga922904215a42f639a8385470d5e61667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is whitespace.  <br /></td></tr>
<tr class="separator:ga922904215a42f639a8385470d5e61667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83e29996414dc34dd0fb76a16669f05f" id="r_ga83e29996414dc34dd0fb76a16669f05f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga83e29996414dc34dd0fb76a16669f05f">SDL::isupper</a> (int x)</td></tr>
<tr class="memdesc:ga83e29996414dc34dd0fb76a16669f05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is upper case.  <br /></td></tr>
<tr class="separator:ga83e29996414dc34dd0fb76a16669f05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9154645a2881fcb9f6c1df5c4d848ef1" id="r_ga9154645a2881fcb9f6c1df5c4d848ef1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga9154645a2881fcb9f6c1df5c4d848ef1">SDL::islower</a> (int x)</td></tr>
<tr class="memdesc:ga9154645a2881fcb9f6c1df5c4d848ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is lower case.  <br /></td></tr>
<tr class="separator:ga9154645a2881fcb9f6c1df5c4d848ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ff81eceb17060ed3c3c7c32a14bf7b8" id="r_ga6ff81eceb17060ed3c3c7c32a14bf7b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga6ff81eceb17060ed3c3c7c32a14bf7b8">SDL::isprint</a> (int x)</td></tr>
<tr class="memdesc:ga6ff81eceb17060ed3c3c7c32a14bf7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is "printable".  <br /></td></tr>
<tr class="separator:ga6ff81eceb17060ed3c3c7c32a14bf7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28e4c655a653424f510993ddec5b02b4" id="r_ga28e4c655a653424f510993ddec5b02b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga28e4c655a653424f510993ddec5b02b4">SDL::isgraph</a> (int x)</td></tr>
<tr class="memdesc:ga28e4c655a653424f510993ddec5b02b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is any "printable" except space.  <br /></td></tr>
<tr class="separator:ga28e4c655a653424f510993ddec5b02b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa66528bfccd7f5a86ed7554d049d1930" id="r_gaa66528bfccd7f5a86ed7554d049d1930"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa66528bfccd7f5a86ed7554d049d1930">SDL::toupper</a> (int x)</td></tr>
<tr class="memdesc:gaa66528bfccd7f5a86ed7554d049d1930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert low-ASCII English letters to uppercase.  <br /></td></tr>
<tr class="separator:gaa66528bfccd7f5a86ed7554d049d1930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f89764775d85be34bed2bc447d543a" id="r_ga77f89764775d85be34bed2bc447d543a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga77f89764775d85be34bed2bc447d543a">SDL::tolower</a> (int x)</td></tr>
<tr class="memdesc:ga77f89764775d85be34bed2bc447d543a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert low-ASCII English letters to lowercase.  <br /></td></tr>
<tr class="separator:ga77f89764775d85be34bed2bc447d543a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31ee6fbdefd2ca34bbde4c8652069e66" id="r_ga31ee6fbdefd2ca34bbde4c8652069e66"><td class="memItemLeft" align="right" valign="top">Uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga31ee6fbdefd2ca34bbde4c8652069e66">SDL::crc16</a> (Uint16 crc, const void *data, size_t len)</td></tr>
<tr class="memdesc:ga31ee6fbdefd2ca34bbde4c8652069e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a CRC-16 value.  <br /></td></tr>
<tr class="separator:ga31ee6fbdefd2ca34bbde4c8652069e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc8b8bc6d26dd888c3fed721ddb1cd2e" id="r_gacc8b8bc6d26dd888c3fed721ddb1cd2e"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gacc8b8bc6d26dd888c3fed721ddb1cd2e">SDL::crc32</a> (Uint32 crc, const void *data, size_t len)</td></tr>
<tr class="memdesc:gacc8b8bc6d26dd888c3fed721ddb1cd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a CRC-32 value.  <br /></td></tr>
<tr class="separator:gacc8b8bc6d26dd888c3fed721ddb1cd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa75ce9d0d0b590cd55fce1604bb40824" id="r_gaa75ce9d0d0b590cd55fce1604bb40824"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa75ce9d0d0b590cd55fce1604bb40824">SDL::murmur3_32</a> (const void *data, size_t len, Uint32 seed)</td></tr>
<tr class="memdesc:gaa75ce9d0d0b590cd55fce1604bb40824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a 32-bit MurmurHash3 value for a block of data.  <br /></td></tr>
<tr class="separator:gaa75ce9d0d0b590cd55fce1604bb40824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe27508f0dcd3fb7902725b46f1c7e15" id="r_gafe27508f0dcd3fb7902725b46f1c7e15"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gafe27508f0dcd3fb7902725b46f1c7e15">SDL::memcpy</a> (void *dst, const void *src, size_t len)</td></tr>
<tr class="memdesc:gafe27508f0dcd3fb7902725b46f1c7e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy non-overlapping memory.  <br /></td></tr>
<tr class="separator:gafe27508f0dcd3fb7902725b46f1c7e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga166c29b5162d190b0002720452a5ef43" id="r_ga166c29b5162d190b0002720452a5ef43"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga166c29b5162d190b0002720452a5ef43">SDL::memmove</a> (void *dst, const void *src, size_t len)</td></tr>
<tr class="memdesc:ga166c29b5162d190b0002720452a5ef43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy memory ranges that might overlap.  <br /></td></tr>
<tr class="separator:ga166c29b5162d190b0002720452a5ef43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a6487beb5a07d1110c8afe1fe030446" id="r_ga5a6487beb5a07d1110c8afe1fe030446"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga5a6487beb5a07d1110c8afe1fe030446">SDL::memset</a> (void *dst, int c, size_t len)</td></tr>
<tr class="memdesc:ga5a6487beb5a07d1110c8afe1fe030446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize all bytes of buffer of memory to a specific value.  <br /></td></tr>
<tr class="separator:ga5a6487beb5a07d1110c8afe1fe030446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e06e75cea4ef203bf1f3c967f8bff54" id="r_ga8e06e75cea4ef203bf1f3c967f8bff54"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8e06e75cea4ef203bf1f3c967f8bff54">SDL::memset4</a> (void *dst, Uint32 val, size_t dwords)</td></tr>
<tr class="memdesc:ga8e06e75cea4ef203bf1f3c967f8bff54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize all 32-bit words of buffer of memory to a specific value.  <br /></td></tr>
<tr class="separator:ga8e06e75cea4ef203bf1f3c967f8bff54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d65aa4051722f968f6fde80d47d761f" id="r_ga4d65aa4051722f968f6fde80d47d761f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga4d65aa4051722f968f6fde80d47d761f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga4d65aa4051722f968f6fde80d47d761f">SDL::zero</a> (T &amp;x)</td></tr>
<tr class="memdesc:ga4d65aa4051722f968f6fde80d47d761f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear an object's memory to zero.  <br /></td></tr>
<tr class="separator:ga4d65aa4051722f968f6fde80d47d761f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0fc530b6aa46072077289b0a200c21c" id="r_gab0fc530b6aa46072077289b0a200c21c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gab0fc530b6aa46072077289b0a200c21c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab0fc530b6aa46072077289b0a200c21c">SDL::zerop</a> (T *x)</td></tr>
<tr class="memdesc:gab0fc530b6aa46072077289b0a200c21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear an object's memory to zero, using a pointer.  <br /></td></tr>
<tr class="separator:gab0fc530b6aa46072077289b0a200c21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51ba04c3b473e95c7808a55669162521" id="r_ga51ba04c3b473e95c7808a55669162521"><td class="memTemplParams" colspan="2">template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:ga51ba04c3b473e95c7808a55669162521"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga51ba04c3b473e95c7808a55669162521">SDL::zeroa</a> (T(&amp;x)[N])</td></tr>
<tr class="memdesc:ga51ba04c3b473e95c7808a55669162521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear an array's memory to zero.  <br /></td></tr>
<tr class="separator:ga51ba04c3b473e95c7808a55669162521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1713911979192a927ee8202ad4ed478b" id="r_ga1713911979192a927ee8202ad4ed478b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga1713911979192a927ee8202ad4ed478b">SDL::memcmp</a> (const void *s1, const void *s2, size_t len)</td></tr>
<tr class="memdesc:ga1713911979192a927ee8202ad4ed478b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two buffers of memory.  <br /></td></tr>
<tr class="separator:ga1713911979192a927ee8202ad4ed478b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaba3e78b66aee106f48c80864156f0a" id="r_gafaba3e78b66aee106f48c80864156f0a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gafaba3e78b66aee106f48c80864156f0a">SDL::wcslen</a> (const wchar_t *wstr)</td></tr>
<tr class="memdesc:gafaba3e78b66aee106f48c80864156f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#gafaba3e78b66aee106f48c80864156f0a" title="This works exactly like wcslen() but doesn&#39;t require access to a C runtime.">wcslen()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:gafaba3e78b66aee106f48c80864156f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83f6331afec19491a73e0f711d7b3faf" id="r_ga83f6331afec19491a73e0f711d7b3faf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga83f6331afec19491a73e0f711d7b3faf">SDL::wcsnlen</a> (const wchar_t *wstr, size_t maxlen)</td></tr>
<tr class="memdesc:ga83f6331afec19491a73e0f711d7b3faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga83f6331afec19491a73e0f711d7b3faf" title="This works exactly like wcsnlen() but doesn&#39;t require access to a C runtime.">wcsnlen()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga83f6331afec19491a73e0f711d7b3faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa4a6075598ac1d2db01c28f76bf8c08" id="r_gaaa4a6075598ac1d2db01c28f76bf8c08"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaaa4a6075598ac1d2db01c28f76bf8c08">SDL::wcslcpy</a> (wchar_t *dst, const wchar_t *src, size_t maxlen)</td></tr>
<tr class="memdesc:gaaa4a6075598ac1d2db01c28f76bf8c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a wide string.  <br /></td></tr>
<tr class="separator:gaaa4a6075598ac1d2db01c28f76bf8c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeebfd8bdc9570592d8c1a5083f5d6893" id="r_gaeebfd8bdc9570592d8c1a5083f5d6893"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaeebfd8bdc9570592d8c1a5083f5d6893">SDL::wcslcat</a> (wchar_t *dst, const wchar_t *src, size_t maxlen)</td></tr>
<tr class="memdesc:gaeebfd8bdc9570592d8c1a5083f5d6893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate wide strings.  <br /></td></tr>
<tr class="separator:gaeebfd8bdc9570592d8c1a5083f5d6893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26f89af82ddb65cb934e2c3dc6abb807" id="r_ga26f89af82ddb65cb934e2c3dc6abb807"><td class="memItemLeft" align="right" valign="top">wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga26f89af82ddb65cb934e2c3dc6abb807">SDL::wcsdup</a> (const wchar_t *wstr)</td></tr>
<tr class="memdesc:ga26f89af82ddb65cb934e2c3dc6abb807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a copy of a wide string.  <br /></td></tr>
<tr class="separator:ga26f89af82ddb65cb934e2c3dc6abb807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad864d11d477fc831eb7fcd5a40fbe615" id="r_gad864d11d477fc831eb7fcd5a40fbe615"><td class="memItemLeft" align="right" valign="top">wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gad864d11d477fc831eb7fcd5a40fbe615">SDL::wcsstr</a> (const wchar_t *haystack, const wchar_t *needle)</td></tr>
<tr class="memdesc:gad864d11d477fc831eb7fcd5a40fbe615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a wide string for the first instance of a specific substring.  <br /></td></tr>
<tr class="separator:gad864d11d477fc831eb7fcd5a40fbe615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc794d23fc0f8b51d4abbcf226e6d7c7" id="r_gacc794d23fc0f8b51d4abbcf226e6d7c7"><td class="memItemLeft" align="right" valign="top">wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gacc794d23fc0f8b51d4abbcf226e6d7c7">SDL::wcsnstr</a> (const wchar_t *haystack, const wchar_t *needle, size_t maxlen)</td></tr>
<tr class="memdesc:gacc794d23fc0f8b51d4abbcf226e6d7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a wide string, up to n wide chars, for the first instance of a specific substring.  <br /></td></tr>
<tr class="separator:gacc794d23fc0f8b51d4abbcf226e6d7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9edc1299fb56e51101501e09aaaa5b1f" id="r_ga9edc1299fb56e51101501e09aaaa5b1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga9edc1299fb56e51101501e09aaaa5b1f">SDL::wcscmp</a> (const wchar_t *str1, const wchar_t *str2)</td></tr>
<tr class="memdesc:ga9edc1299fb56e51101501e09aaaa5b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two null-terminated wide strings.  <br /></td></tr>
<tr class="separator:ga9edc1299fb56e51101501e09aaaa5b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00de271aaf6fd8a464c34b16f7b419ff" id="r_ga00de271aaf6fd8a464c34b16f7b419ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga00de271aaf6fd8a464c34b16f7b419ff">SDL::wcsncmp</a> (const wchar_t *str1, const wchar_t *str2, size_t maxlen)</td></tr>
<tr class="memdesc:ga00de271aaf6fd8a464c34b16f7b419ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two wide strings up to a number of wchar_t values.  <br /></td></tr>
<tr class="separator:ga00de271aaf6fd8a464c34b16f7b419ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae24c494fab206e9aa27dfd9c04b35e81" id="r_gae24c494fab206e9aa27dfd9c04b35e81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae24c494fab206e9aa27dfd9c04b35e81">SDL::wcscasecmp</a> (const wchar_t *str1, const wchar_t *str2)</td></tr>
<tr class="memdesc:gae24c494fab206e9aa27dfd9c04b35e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two null-terminated wide strings, case-insensitively.  <br /></td></tr>
<tr class="separator:gae24c494fab206e9aa27dfd9c04b35e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf1b8559eb793e57181bf418af47d555" id="r_gaaf1b8559eb793e57181bf418af47d555"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaaf1b8559eb793e57181bf418af47d555">SDL::wcsncasecmp</a> (const wchar_t *str1, const wchar_t *str2, size_t maxlen)</td></tr>
<tr class="memdesc:gaaf1b8559eb793e57181bf418af47d555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two wide strings, case-insensitively, up to a number of wchar_t.  <br /></td></tr>
<tr class="separator:gaaf1b8559eb793e57181bf418af47d555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0408a155d55fa0fc2d0198de99ca0dc4" id="r_ga0408a155d55fa0fc2d0198de99ca0dc4"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga0408a155d55fa0fc2d0198de99ca0dc4">SDL::wcstol</a> (const wchar_t *str, wchar_t **endp, int base)</td></tr>
<tr class="memdesc:ga0408a155d55fa0fc2d0198de99ca0dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>long</code> from a wide string.  <br /></td></tr>
<tr class="separator:ga0408a155d55fa0fc2d0198de99ca0dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93de03cd7e1369ba80c5746761bac939" id="r_ga93de03cd7e1369ba80c5746761bac939"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga93de03cd7e1369ba80c5746761bac939">SDL::strlen</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> str)</td></tr>
<tr class="memdesc:ga93de03cd7e1369ba80c5746761bac939"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga93de03cd7e1369ba80c5746761bac939" title="This works exactly like strlen() but doesn&#39;t require access to a C runtime.">strlen()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga93de03cd7e1369ba80c5746761bac939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga929593393da0025b602c5b4560bce5bf" id="r_ga929593393da0025b602c5b4560bce5bf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga929593393da0025b602c5b4560bce5bf">SDL::strnlen</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> str, size_t maxlen)</td></tr>
<tr class="memdesc:ga929593393da0025b602c5b4560bce5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga929593393da0025b602c5b4560bce5bf" title="This works exactly like strnlen() but doesn&#39;t require access to a C runtime.">strnlen()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga929593393da0025b602c5b4560bce5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga598ecc44c77a20ab4de3a96eda46ea76" id="r_ga598ecc44c77a20ab4de3a96eda46ea76"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga598ecc44c77a20ab4de3a96eda46ea76">SDL::strlcpy</a> (char *dst, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> src, size_t maxlen)</td></tr>
<tr class="memdesc:ga598ecc44c77a20ab4de3a96eda46ea76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a string.  <br /></td></tr>
<tr class="separator:ga598ecc44c77a20ab4de3a96eda46ea76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ae726c47fde58d11167345dfda765a4" id="r_ga8ae726c47fde58d11167345dfda765a4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8ae726c47fde58d11167345dfda765a4">SDL::utf8strlcpy</a> (char *dst, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> src, size_t dst_bytes)</td></tr>
<tr class="memdesc:ga8ae726c47fde58d11167345dfda765a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an UTF-8 string.  <br /></td></tr>
<tr class="separator:ga8ae726c47fde58d11167345dfda765a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga503a37a91faa4ed9374b9dd9db03049c" id="r_ga503a37a91faa4ed9374b9dd9db03049c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga503a37a91faa4ed9374b9dd9db03049c">SDL::strlcat</a> (char *dst, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> src, size_t maxlen)</td></tr>
<tr class="memdesc:ga503a37a91faa4ed9374b9dd9db03049c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate strings.  <br /></td></tr>
<tr class="separator:ga503a37a91faa4ed9374b9dd9db03049c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga046b80783770b59a2cf8b4311230fbbd" id="r_ga046b80783770b59a2cf8b4311230fbbd"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga046b80783770b59a2cf8b4311230fbbd">SDL::strdup</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> str)</td></tr>
<tr class="memdesc:ga046b80783770b59a2cf8b4311230fbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a copy of a string.  <br /></td></tr>
<tr class="separator:ga046b80783770b59a2cf8b4311230fbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53e0a0ce55852f1320bc292f72dc1398" id="r_ga53e0a0ce55852f1320bc292f72dc1398"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga53e0a0ce55852f1320bc292f72dc1398">SDL::strndup</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> str, size_t maxlen)</td></tr>
<tr class="memdesc:ga53e0a0ce55852f1320bc292f72dc1398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a copy of a string, up to n characters.  <br /></td></tr>
<tr class="separator:ga53e0a0ce55852f1320bc292f72dc1398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b6d922e9310ca993a82b84e692e8a5" id="r_ga32b6d922e9310ca993a82b84e692e8a5"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga32b6d922e9310ca993a82b84e692e8a5">SDL::strrev</a> (char *str)</td></tr>
<tr class="memdesc:ga32b6d922e9310ca993a82b84e692e8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse a string's contents.  <br /></td></tr>
<tr class="separator:ga32b6d922e9310ca993a82b84e692e8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fe290f18ce6025c454f0b62729c0662" id="r_ga7fe290f18ce6025c454f0b62729c0662"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga7fe290f18ce6025c454f0b62729c0662">SDL::strupr</a> (char *str)</td></tr>
<tr class="memdesc:ga7fe290f18ce6025c454f0b62729c0662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to uppercase.  <br /></td></tr>
<tr class="separator:ga7fe290f18ce6025c454f0b62729c0662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15eaa2ac05317f734e1f022cfc916201" id="r_ga15eaa2ac05317f734e1f022cfc916201"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga15eaa2ac05317f734e1f022cfc916201">SDL::strlwr</a> (char *str)</td></tr>
<tr class="memdesc:ga15eaa2ac05317f734e1f022cfc916201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to lowercase.  <br /></td></tr>
<tr class="separator:ga15eaa2ac05317f734e1f022cfc916201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga451b842c63a514775080900ae67150da" id="r_ga451b842c63a514775080900ae67150da"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga451b842c63a514775080900ae67150da">SDL::strchr</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> str, int c)</td></tr>
<tr class="memdesc:ga451b842c63a514775080900ae67150da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a string for the first instance of a specific byte.  <br /></td></tr>
<tr class="separator:ga451b842c63a514775080900ae67150da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf67863ed8e432e74c417116a532ef24b" id="r_gaf67863ed8e432e74c417116a532ef24b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaf67863ed8e432e74c417116a532ef24b">SDL::strrchr</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> str, int c)</td></tr>
<tr class="memdesc:gaf67863ed8e432e74c417116a532ef24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a string for the last instance of a specific byte.  <br /></td></tr>
<tr class="separator:gaf67863ed8e432e74c417116a532ef24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ef7c9322f6766ee71172d34493ee792" id="r_ga3ef7c9322f6766ee71172d34493ee792"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga3ef7c9322f6766ee71172d34493ee792">SDL::strstr</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> haystack, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> needle)</td></tr>
<tr class="memdesc:ga3ef7c9322f6766ee71172d34493ee792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a string for the first instance of a specific substring.  <br /></td></tr>
<tr class="separator:ga3ef7c9322f6766ee71172d34493ee792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21c1bce04f407d4dab36722078978a9b" id="r_ga21c1bce04f407d4dab36722078978a9b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga21c1bce04f407d4dab36722078978a9b">SDL::strnstr</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> haystack, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> needle, size_t maxlen)</td></tr>
<tr class="memdesc:ga21c1bce04f407d4dab36722078978a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a string, up to n bytes, for the first instance of a specific substring.  <br /></td></tr>
<tr class="separator:ga21c1bce04f407d4dab36722078978a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d413500b6dc7d885777ecb0873c823e" id="r_ga0d413500b6dc7d885777ecb0873c823e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga0d413500b6dc7d885777ecb0873c823e">SDL::strcasestr</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> haystack, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> needle)</td></tr>
<tr class="memdesc:ga0d413500b6dc7d885777ecb0873c823e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a UTF-8 string for the first instance of a specific substring, case-insensitively.  <br /></td></tr>
<tr class="separator:ga0d413500b6dc7d885777ecb0873c823e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dc2ad6fd692f32f1304e9b1872881a2" id="r_ga8dc2ad6fd692f32f1304e9b1872881a2"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8dc2ad6fd692f32f1304e9b1872881a2">SDL::strtok_r</a> (char *str, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> delim, char **saveptr)</td></tr>
<tr class="memdesc:ga8dc2ad6fd692f32f1304e9b1872881a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga8dc2ad6fd692f32f1304e9b1872881a2" title="This works exactly like strtok_r() but doesn&#39;t require access to a C runtime.">strtok_r()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga8dc2ad6fd692f32f1304e9b1872881a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81767a08005a153d60b63896c58c106f" id="r_ga81767a08005a153d60b63896c58c106f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga81767a08005a153d60b63896c58c106f">SDL::utf8strlen</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> str)</td></tr>
<tr class="memdesc:ga81767a08005a153d60b63896c58c106f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of codepoints in a UTF-8 string.  <br /></td></tr>
<tr class="separator:ga81767a08005a153d60b63896c58c106f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82960b752efedfdd3cbfcf166d06161e" id="r_ga82960b752efedfdd3cbfcf166d06161e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga82960b752efedfdd3cbfcf166d06161e">SDL::utf8strnlen</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> str, size_t bytes)</td></tr>
<tr class="memdesc:ga82960b752efedfdd3cbfcf166d06161e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of codepoints in a UTF-8 string, up to n bytes.  <br /></td></tr>
<tr class="separator:ga82960b752efedfdd3cbfcf166d06161e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0d19dc9f116d9f492fd4d17296f0c4b" id="r_gac0d19dc9f116d9f492fd4d17296f0c4b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gac0d19dc9f116d9f492fd4d17296f0c4b">SDL::itoa</a> (int value, char *str, int radix)</td></tr>
<tr class="memdesc:gac0d19dc9f116d9f492fd4d17296f0c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an integer into a string.  <br /></td></tr>
<tr class="separator:gac0d19dc9f116d9f492fd4d17296f0c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ca0851c2d9980695748c979e2d15608" id="r_ga6ca0851c2d9980695748c979e2d15608"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga6ca0851c2d9980695748c979e2d15608">SDL::uitoa</a> (unsigned int value, char *str, int radix)</td></tr>
<tr class="memdesc:ga6ca0851c2d9980695748c979e2d15608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an unsigned integer into a string.  <br /></td></tr>
<tr class="separator:ga6ca0851c2d9980695748c979e2d15608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee263ca33e533bf8acdd33b20e2323cf" id="r_gaee263ca33e533bf8acdd33b20e2323cf"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaee263ca33e533bf8acdd33b20e2323cf">SDL::ltoa</a> (long value, char *str, int radix)</td></tr>
<tr class="memdesc:gaee263ca33e533bf8acdd33b20e2323cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a long integer into a string.  <br /></td></tr>
<tr class="separator:gaee263ca33e533bf8acdd33b20e2323cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2450290efea2bebff1f164a6c4a04d38" id="r_ga2450290efea2bebff1f164a6c4a04d38"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga2450290efea2bebff1f164a6c4a04d38">SDL::ultoa</a> (unsigned long value, char *str, int radix)</td></tr>
<tr class="memdesc:ga2450290efea2bebff1f164a6c4a04d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an unsigned long integer into a string.  <br /></td></tr>
<tr class="separator:ga2450290efea2bebff1f164a6c4a04d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga756fd0202aa809d537fc01e28b0c7564" id="r_ga756fd0202aa809d537fc01e28b0c7564"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga756fd0202aa809d537fc01e28b0c7564">SDL::atoi</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> str)</td></tr>
<tr class="memdesc:ga756fd0202aa809d537fc01e28b0c7564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an <code>int</code> from a string.  <br /></td></tr>
<tr class="separator:ga756fd0202aa809d537fc01e28b0c7564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeecdd7ec80c303a7474d59b641a892f7" id="r_gaeecdd7ec80c303a7474d59b641a892f7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaeecdd7ec80c303a7474d59b641a892f7">SDL::atof</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> str)</td></tr>
<tr class="memdesc:gaeecdd7ec80c303a7474d59b641a892f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>double</code> from a string.  <br /></td></tr>
<tr class="separator:gaeecdd7ec80c303a7474d59b641a892f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf270570877b7a6ccaea59ba90b428043" id="r_gaf270570877b7a6ccaea59ba90b428043"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaf270570877b7a6ccaea59ba90b428043">SDL::strtol</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> str, char **endp, int base)</td></tr>
<tr class="memdesc:gaf270570877b7a6ccaea59ba90b428043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>long</code> from a string.  <br /></td></tr>
<tr class="separator:gaf270570877b7a6ccaea59ba90b428043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3869ab21242a2a6fb41be41b382d2af2" id="r_ga3869ab21242a2a6fb41be41b382d2af2"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga3869ab21242a2a6fb41be41b382d2af2">SDL::strtoul</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> str, char **endp, int base)</td></tr>
<tr class="memdesc:ga3869ab21242a2a6fb41be41b382d2af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an <code>unsigned long</code> from a string.  <br /></td></tr>
<tr class="separator:ga3869ab21242a2a6fb41be41b382d2af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga062de74e1950744ad5556cc815c58036" id="r_ga062de74e1950744ad5556cc815c58036"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga062de74e1950744ad5556cc815c58036">SDL::strtod</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> str, char **endp)</td></tr>
<tr class="memdesc:ga062de74e1950744ad5556cc815c58036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>double</code> from a string.  <br /></td></tr>
<tr class="separator:ga062de74e1950744ad5556cc815c58036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63d50d9f0b71b04e9b038f0bc71e54c3" id="r_ga63d50d9f0b71b04e9b038f0bc71e54c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga63d50d9f0b71b04e9b038f0bc71e54c3">SDL::strcmp</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> str1, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> str2)</td></tr>
<tr class="memdesc:ga63d50d9f0b71b04e9b038f0bc71e54c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two null-terminated UTF-8 strings.  <br /></td></tr>
<tr class="separator:ga63d50d9f0b71b04e9b038f0bc71e54c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2caad6bed5796e9524d07c21d4701af9" id="r_ga2caad6bed5796e9524d07c21d4701af9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga2caad6bed5796e9524d07c21d4701af9">SDL::strncmp</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> str1, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> str2, size_t maxlen)</td></tr>
<tr class="memdesc:ga2caad6bed5796e9524d07c21d4701af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two UTF-8 strings up to a number of bytes.  <br /></td></tr>
<tr class="separator:ga2caad6bed5796e9524d07c21d4701af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga932cf2487365b3a3a6fd6e37a7eddff7" id="r_ga932cf2487365b3a3a6fd6e37a7eddff7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga932cf2487365b3a3a6fd6e37a7eddff7">SDL::strcasecmp</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> str1, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> str2)</td></tr>
<tr class="memdesc:ga932cf2487365b3a3a6fd6e37a7eddff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two null-terminated UTF-8 strings, case-insensitively.  <br /></td></tr>
<tr class="separator:ga932cf2487365b3a3a6fd6e37a7eddff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37191be89f79920285c912c0544150e8" id="r_ga37191be89f79920285c912c0544150e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga37191be89f79920285c912c0544150e8">SDL::strncasecmp</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> str1, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> str2, size_t maxlen)</td></tr>
<tr class="memdesc:ga37191be89f79920285c912c0544150e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two UTF-8 strings, case-insensitively, up to a number of bytes.  <br /></td></tr>
<tr class="separator:ga37191be89f79920285c912c0544150e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3838c531e1c9bbee29cdf5f4ccb60b4" id="r_gae3838c531e1c9bbee29cdf5f4ccb60b4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae3838c531e1c9bbee29cdf5f4ccb60b4">SDL::strpbrk</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> str, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> breakset)</td></tr>
<tr class="memdesc:gae3838c531e1c9bbee29cdf5f4ccb60b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches a string for the first occurence of any character contained in a breakset, and returns a pointer from the string to that character.  <br /></td></tr>
<tr class="separator:gae3838c531e1c9bbee29cdf5f4ccb60b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5ecf11cf256372f67e10fafdd79141e" id="r_gaa5ecf11cf256372f67e10fafdd79141e"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa5ecf11cf256372f67e10fafdd79141e">SDL::StepUTF8</a> (const char **pstr, size_t *pslen)</td></tr>
<tr class="memdesc:gaa5ecf11cf256372f67e10fafdd79141e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a UTF-8 string, one Unicode codepoint at a time.  <br /></td></tr>
<tr class="separator:gaa5ecf11cf256372f67e10fafdd79141e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa1607ee6b5fddfb7d22eb518dbe59a4" id="r_gaaa1607ee6b5fddfb7d22eb518dbe59a4"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaaa1607ee6b5fddfb7d22eb518dbe59a4">SDL::StepBackUTF8</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> start, const char **pstr)</td></tr>
<tr class="memdesc:gaaa1607ee6b5fddfb7d22eb518dbe59a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a UTF-8 string in reverse, one Unicode codepoint at a time.  <br /></td></tr>
<tr class="separator:gaaa1607ee6b5fddfb7d22eb518dbe59a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga032867626ec7d90baa207d817fdbddcf" id="r_ga032867626ec7d90baa207d817fdbddcf"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga032867626ec7d90baa207d817fdbddcf">SDL::UCS4ToUTF8</a> (Uint32 codepoint, char *dst)</td></tr>
<tr class="memdesc:ga032867626ec7d90baa207d817fdbddcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a single Unicode codepoint to UTF-8.  <br /></td></tr>
<tr class="separator:ga032867626ec7d90baa207d817fdbddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga592054168270da087e8630cac0df2530" id="r_ga592054168270da087e8630cac0df2530"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga592054168270da087e8630cac0df2530">SDL::sscanf</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> text, SDL_SCANF_FORMAT_STRING const char *fmt,...)</td></tr>
<tr class="memdesc:ga592054168270da087e8630cac0df2530"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga592054168270da087e8630cac0df2530" title="This works exactly like sscanf() but doesn&#39;t require access to a C runtime.">sscanf()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga592054168270da087e8630cac0df2530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1c131187ea64c08ed8abb3d04551072" id="r_gac1c131187ea64c08ed8abb3d04551072"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gac1c131187ea64c08ed8abb3d04551072">SDL::vsscanf</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> text, SDL_SCANF_FORMAT_STRING const char *fmt, va_list ap)</td></tr>
<tr class="memdesc:gac1c131187ea64c08ed8abb3d04551072"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#gac1c131187ea64c08ed8abb3d04551072" title="This works exactly like vsscanf() but doesn&#39;t require access to a C runtime.">vsscanf()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:gac1c131187ea64c08ed8abb3d04551072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57b48f04ae9e3949774b9f0c9dc0c151" id="r_ga57b48f04ae9e3949774b9f0c9dc0c151"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga57b48f04ae9e3949774b9f0c9dc0c151">SDL::snprintf</a> (char *text, size_t maxlen, SDL_PRINTF_FORMAT_STRING const char *fmt,...)</td></tr>
<tr class="memdesc:ga57b48f04ae9e3949774b9f0c9dc0c151"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga57b48f04ae9e3949774b9f0c9dc0c151" title="This works exactly like snprintf() but doesn&#39;t require access to a C runtime.">snprintf()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga57b48f04ae9e3949774b9f0c9dc0c151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90fbec4327cabf79747426483a3f24cd" id="r_ga90fbec4327cabf79747426483a3f24cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga90fbec4327cabf79747426483a3f24cd">SDL::swprintf</a> (wchar_t *text, size_t maxlen, SDL_PRINTF_FORMAT_STRING const wchar_t *fmt,...)</td></tr>
<tr class="memdesc:ga90fbec4327cabf79747426483a3f24cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga90fbec4327cabf79747426483a3f24cd" title="This works exactly like swprintf() but doesn&#39;t require access to a C runtime.">swprintf()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga90fbec4327cabf79747426483a3f24cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4402ec18128560a4643446630b3a4633" id="r_ga4402ec18128560a4643446630b3a4633"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga4402ec18128560a4643446630b3a4633">SDL::vsnprintf</a> (char *text, size_t maxlen, SDL_PRINTF_FORMAT_STRING const char *fmt, va_list ap)</td></tr>
<tr class="memdesc:ga4402ec18128560a4643446630b3a4633"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga4402ec18128560a4643446630b3a4633" title="This works exactly like vsnprintf() but doesn&#39;t require access to a C runtime.">vsnprintf()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga4402ec18128560a4643446630b3a4633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83409fe8ca79edcf997ebfcda6226a5a" id="r_ga83409fe8ca79edcf997ebfcda6226a5a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga83409fe8ca79edcf997ebfcda6226a5a">SDL::vswprintf</a> (wchar_t *text, size_t maxlen, SDL_PRINTF_FORMAT_STRING const wchar_t *fmt, va_list ap)</td></tr>
<tr class="memdesc:ga83409fe8ca79edcf997ebfcda6226a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga83409fe8ca79edcf997ebfcda6226a5a" title="This works exactly like vswprintf() but doesn&#39;t require access to a C runtime.">vswprintf()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga83409fe8ca79edcf997ebfcda6226a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e5aac7458286e05c61d71278f59215" id="r_ga12e5aac7458286e05c61d71278f59215"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga12e5aac7458286e05c61d71278f59215">SDL::asprintf</a> (char **strp, SDL_PRINTF_FORMAT_STRING const char *fmt,...)</td></tr>
<tr class="memdesc:ga12e5aac7458286e05c61d71278f59215"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga12e5aac7458286e05c61d71278f59215" title="This works exactly like asprintf() but doesn&#39;t require access to a C runtime.">asprintf()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga12e5aac7458286e05c61d71278f59215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd658aed3baf56ca11c8148de5cd9480" id="r_gabd658aed3baf56ca11c8148de5cd9480"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gabd658aed3baf56ca11c8148de5cd9480">SDL::vasprintf</a> (char **strp, SDL_PRINTF_FORMAT_STRING const char *fmt, va_list ap)</td></tr>
<tr class="memdesc:gabd658aed3baf56ca11c8148de5cd9480"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#gabd658aed3baf56ca11c8148de5cd9480" title="This works exactly like vasprintf() but doesn&#39;t require access to a C runtime.">vasprintf()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:gabd658aed3baf56ca11c8148de5cd9480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85fc72ab5435901400efdaebc1187630" id="r_ga85fc72ab5435901400efdaebc1187630"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga85fc72ab5435901400efdaebc1187630">SDL::srand</a> (Uint64 seed)</td></tr>
<tr class="memdesc:ga85fc72ab5435901400efdaebc1187630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seeds the pseudo-random number generator.  <br /></td></tr>
<tr class="separator:ga85fc72ab5435901400efdaebc1187630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0d119f7b42130eb3a652f7e243c8cf7" id="r_gaa0d119f7b42130eb3a652f7e243c8cf7"><td class="memItemLeft" align="right" valign="top">Sint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa0d119f7b42130eb3a652f7e243c8cf7">SDL::rand</a> (Sint32 n)</td></tr>
<tr class="memdesc:gaa0d119f7b42130eb3a652f7e243c8cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pseudo-random number less than n for positive n.  <br /></td></tr>
<tr class="separator:gaa0d119f7b42130eb3a652f7e243c8cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab0a933463eebe63f34b3acec7e96c6e" id="r_gaab0a933463eebe63f34b3acec7e96c6e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaab0a933463eebe63f34b3acec7e96c6e">SDL::randf</a> ()</td></tr>
<tr class="memdesc:gaab0a933463eebe63f34b3acec7e96c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a uniform pseudo-random floating point number less than 1.0.  <br /></td></tr>
<tr class="separator:gaab0a933463eebe63f34b3acec7e96c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6517052066ab937273e6a89c7d1eca8" id="r_gae6517052066ab937273e6a89c7d1eca8"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae6517052066ab937273e6a89c7d1eca8">SDL::rand_bits</a> ()</td></tr>
<tr class="memdesc:gae6517052066ab937273e6a89c7d1eca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate 32 pseudo-random bits.  <br /></td></tr>
<tr class="separator:gae6517052066ab937273e6a89c7d1eca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f6543d319422a6044570b59cc6377b4" id="r_ga9f6543d319422a6044570b59cc6377b4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga9f6543d319422a6044570b59cc6377b4">SDL::acos</a> (double x)</td></tr>
<tr class="memdesc:ga9f6543d319422a6044570b59cc6377b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc cosine of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga9f6543d319422a6044570b59cc6377b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cb5c957259b2c7dea56281b8a8e0b2e" id="r_ga8cb5c957259b2c7dea56281b8a8e0b2e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8cb5c957259b2c7dea56281b8a8e0b2e">SDL::acos</a> (float x)</td></tr>
<tr class="memdesc:ga8cb5c957259b2c7dea56281b8a8e0b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc cosine of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga8cb5c957259b2c7dea56281b8a8e0b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga316a2eed1e595c002830ee628c1b4963" id="r_ga316a2eed1e595c002830ee628c1b4963"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga316a2eed1e595c002830ee628c1b4963">SDL::asin</a> (double x)</td></tr>
<tr class="memdesc:ga316a2eed1e595c002830ee628c1b4963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc sine of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga316a2eed1e595c002830ee628c1b4963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0b3b75a8c4e13c1de7bffdf67d1f4df" id="r_gaf0b3b75a8c4e13c1de7bffdf67d1f4df"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaf0b3b75a8c4e13c1de7bffdf67d1f4df">SDL::asin</a> (float x)</td></tr>
<tr class="memdesc:gaf0b3b75a8c4e13c1de7bffdf67d1f4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc sine of <code>x</code>.  <br /></td></tr>
<tr class="separator:gaf0b3b75a8c4e13c1de7bffdf67d1f4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11d0eaba28baba36fc8050f8541c8ee5" id="r_ga11d0eaba28baba36fc8050f8541c8ee5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga11d0eaba28baba36fc8050f8541c8ee5">SDL::atan</a> (double x)</td></tr>
<tr class="memdesc:ga11d0eaba28baba36fc8050f8541c8ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc tangent of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga11d0eaba28baba36fc8050f8541c8ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac79b3402c34e7ee5cfb6b99e61cb2986" id="r_gac79b3402c34e7ee5cfb6b99e61cb2986"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gac79b3402c34e7ee5cfb6b99e61cb2986">SDL::atan</a> (float x)</td></tr>
<tr class="memdesc:gac79b3402c34e7ee5cfb6b99e61cb2986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc tangent of <code>x</code>.  <br /></td></tr>
<tr class="separator:gac79b3402c34e7ee5cfb6b99e61cb2986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0884b892c70d428cf50522d9791eb61" id="r_gae0884b892c70d428cf50522d9791eb61"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae0884b892c70d428cf50522d9791eb61">SDL::atan2</a> (double y, double x)</td></tr>
<tr class="memdesc:gae0884b892c70d428cf50522d9791eb61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc tangent of <code>y / x</code>, using the signs of x and y to adjust the result's quadrant.  <br /></td></tr>
<tr class="separator:gae0884b892c70d428cf50522d9791eb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6e37f048360d49896fe3562d15e0b26" id="r_gab6e37f048360d49896fe3562d15e0b26"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab6e37f048360d49896fe3562d15e0b26">SDL::atan2</a> (float y, float x)</td></tr>
<tr class="memdesc:gab6e37f048360d49896fe3562d15e0b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc tangent of <code>y / x</code>, using the signs of x and y to adjust the result's quadrant.  <br /></td></tr>
<tr class="separator:gab6e37f048360d49896fe3562d15e0b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1567a1e6b1738fabc6252d7c52f03321" id="r_ga1567a1e6b1738fabc6252d7c52f03321"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga1567a1e6b1738fabc6252d7c52f03321">SDL::ceil</a> (double x)</td></tr>
<tr class="memdesc:ga1567a1e6b1738fabc6252d7c52f03321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the ceiling of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga1567a1e6b1738fabc6252d7c52f03321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14a86ff5b6deee415e336ecfde3689c9" id="r_ga14a86ff5b6deee415e336ecfde3689c9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga14a86ff5b6deee415e336ecfde3689c9">SDL::ceil</a> (float x)</td></tr>
<tr class="memdesc:ga14a86ff5b6deee415e336ecfde3689c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the ceiling of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga14a86ff5b6deee415e336ecfde3689c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga476595ece87ed3441c672348366f0adb" id="r_ga476595ece87ed3441c672348366f0adb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga476595ece87ed3441c672348366f0adb">SDL::copysign</a> (double x, double y)</td></tr>
<tr class="memdesc:ga476595ece87ed3441c672348366f0adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the sign of one floating-point value to another.  <br /></td></tr>
<tr class="separator:ga476595ece87ed3441c672348366f0adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10134c20bebfe5922fcaefbbcbcaa76d" id="r_ga10134c20bebfe5922fcaefbbcbcaa76d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga10134c20bebfe5922fcaefbbcbcaa76d">SDL::copysign</a> (float x, float y)</td></tr>
<tr class="memdesc:ga10134c20bebfe5922fcaefbbcbcaa76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the sign of one floating-point value to another.  <br /></td></tr>
<tr class="separator:ga10134c20bebfe5922fcaefbbcbcaa76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf8c80d673a05784387fa5e349a9f6dd" id="r_gadf8c80d673a05784387fa5e349a9f6dd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gadf8c80d673a05784387fa5e349a9f6dd">SDL::cos</a> (double x)</td></tr>
<tr class="memdesc:gadf8c80d673a05784387fa5e349a9f6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine of <code>x</code>.  <br /></td></tr>
<tr class="separator:gadf8c80d673a05784387fa5e349a9f6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ecee7c57e3bee13c46f57de66705aaa" id="r_ga6ecee7c57e3bee13c46f57de66705aaa"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga6ecee7c57e3bee13c46f57de66705aaa">SDL::cos</a> (float x)</td></tr>
<tr class="memdesc:ga6ecee7c57e3bee13c46f57de66705aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga6ecee7c57e3bee13c46f57de66705aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e4417a78f0393e80fa7645a534a53a3" id="r_ga3e4417a78f0393e80fa7645a534a53a3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga3e4417a78f0393e80fa7645a534a53a3">SDL::exp</a> (double x)</td></tr>
<tr class="memdesc:ga3e4417a78f0393e80fa7645a534a53a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga3e4417a78f0393e80fa7645a534a53a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28dae763363f8a8f6ee6cc850dd609e0" id="r_ga28dae763363f8a8f6ee6cc850dd609e0"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga28dae763363f8a8f6ee6cc850dd609e0">SDL::exp</a> (float x)</td></tr>
<tr class="memdesc:ga28dae763363f8a8f6ee6cc850dd609e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga28dae763363f8a8f6ee6cc850dd609e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5d99939c5dffc37035e51300236316a" id="r_gaa5d99939c5dffc37035e51300236316a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa5d99939c5dffc37035e51300236316a">SDL::floor</a> (double x)</td></tr>
<tr class="memdesc:gaa5d99939c5dffc37035e51300236316a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the floor of <code>x</code>.  <br /></td></tr>
<tr class="separator:gaa5d99939c5dffc37035e51300236316a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93fb9063f992d37b5163a32f0e952998" id="r_ga93fb9063f992d37b5163a32f0e952998"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga93fb9063f992d37b5163a32f0e952998">SDL::floor</a> (float x)</td></tr>
<tr class="memdesc:ga93fb9063f992d37b5163a32f0e952998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the floor of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga93fb9063f992d37b5163a32f0e952998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb64b2b465e001720dce40bacec1b937" id="r_gaeb64b2b465e001720dce40bacec1b937"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaeb64b2b465e001720dce40bacec1b937">SDL::trunc</a> (double x)</td></tr>
<tr class="memdesc:gaeb64b2b465e001720dce40bacec1b937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate <code>x</code> to an integer.  <br /></td></tr>
<tr class="separator:gaeb64b2b465e001720dce40bacec1b937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga673e5ecaed895190e52c8265b89e17d8" id="r_ga673e5ecaed895190e52c8265b89e17d8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga673e5ecaed895190e52c8265b89e17d8">SDL::trunc</a> (float x)</td></tr>
<tr class="memdesc:ga673e5ecaed895190e52c8265b89e17d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate <code>x</code> to an integer.  <br /></td></tr>
<tr class="separator:ga673e5ecaed895190e52c8265b89e17d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcd6b0192bc061852ef8ef56272bf98d" id="r_gafcd6b0192bc061852ef8ef56272bf98d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gafcd6b0192bc061852ef8ef56272bf98d">SDL::fmod</a> (double x, double y)</td></tr>
<tr class="memdesc:gafcd6b0192bc061852ef8ef56272bf98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floating-point remainder of <code>x / y</code>  <br /></td></tr>
<tr class="separator:gafcd6b0192bc061852ef8ef56272bf98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcca080a3eb842e163500d93841db224" id="r_gabcca080a3eb842e163500d93841db224"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gabcca080a3eb842e163500d93841db224">SDL::fmod</a> (float x, float y)</td></tr>
<tr class="memdesc:gabcca080a3eb842e163500d93841db224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floating-point remainder of <code>x / y</code>  <br /></td></tr>
<tr class="separator:gabcca080a3eb842e163500d93841db224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga918f0e70e6e67f724c445eba4b514a21" id="r_ga918f0e70e6e67f724c445eba4b514a21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga918f0e70e6e67f724c445eba4b514a21">SDL::isinf</a> (double x)</td></tr>
<tr class="memdesc:ga918f0e70e6e67f724c445eba4b514a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the value is infinity.  <br /></td></tr>
<tr class="separator:ga918f0e70e6e67f724c445eba4b514a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab688d31019c357f1b5c24ce2fcc598cb" id="r_gab688d31019c357f1b5c24ce2fcc598cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab688d31019c357f1b5c24ce2fcc598cb">SDL::isinf</a> (float x)</td></tr>
<tr class="memdesc:gab688d31019c357f1b5c24ce2fcc598cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the value is infinity.  <br /></td></tr>
<tr class="separator:gab688d31019c357f1b5c24ce2fcc598cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2221269e7ded0fb89af37aea9132e0b8" id="r_ga2221269e7ded0fb89af37aea9132e0b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga2221269e7ded0fb89af37aea9132e0b8">SDL::isnan</a> (double x)</td></tr>
<tr class="memdesc:ga2221269e7ded0fb89af37aea9132e0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the value is NaN.  <br /></td></tr>
<tr class="separator:ga2221269e7ded0fb89af37aea9132e0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4da556b52f202a3e9dcb506033ee86f3" id="r_ga4da556b52f202a3e9dcb506033ee86f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga4da556b52f202a3e9dcb506033ee86f3">SDL::isnan</a> (float x)</td></tr>
<tr class="memdesc:ga4da556b52f202a3e9dcb506033ee86f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the value is NaN.  <br /></td></tr>
<tr class="separator:ga4da556b52f202a3e9dcb506033ee86f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01c25ea063ceb75d5caf6ca1119a3bc1" id="r_ga01c25ea063ceb75d5caf6ca1119a3bc1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga01c25ea063ceb75d5caf6ca1119a3bc1">SDL::log</a> (double x)</td></tr>
<tr class="memdesc:ga01c25ea063ceb75d5caf6ca1119a3bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga01c25ea063ceb75d5caf6ca1119a3bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd852bed14a8611cd305ede0abfcf2f3" id="r_gabd852bed14a8611cd305ede0abfcf2f3"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gabd852bed14a8611cd305ede0abfcf2f3">SDL::log</a> (float x)</td></tr>
<tr class="memdesc:gabd852bed14a8611cd305ede0abfcf2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of <code>x</code>.  <br /></td></tr>
<tr class="separator:gabd852bed14a8611cd305ede0abfcf2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdf9d94c27153da5d01b604342b49024" id="r_gacdf9d94c27153da5d01b604342b49024"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gacdf9d94c27153da5d01b604342b49024">SDL::log10</a> (double x)</td></tr>
<tr class="memdesc:gacdf9d94c27153da5d01b604342b49024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the base-10 logarithm of <code>x</code>.  <br /></td></tr>
<tr class="separator:gacdf9d94c27153da5d01b604342b49024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga469bfdfde9d6d0a1193cf60f4cc4ab73" id="r_ga469bfdfde9d6d0a1193cf60f4cc4ab73"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga469bfdfde9d6d0a1193cf60f4cc4ab73">SDL::log10</a> (float x)</td></tr>
<tr class="memdesc:ga469bfdfde9d6d0a1193cf60f4cc4ab73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the base-10 logarithm of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga469bfdfde9d6d0a1193cf60f4cc4ab73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c97858f63954904f2037d7bc81b2681" id="r_ga4c97858f63954904f2037d7bc81b2681"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga4c97858f63954904f2037d7bc81b2681">SDL::modf</a> (double x, double *y)</td></tr>
<tr class="memdesc:ga4c97858f63954904f2037d7bc81b2681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split <code>x</code> into integer and fractional parts.  <br /></td></tr>
<tr class="separator:ga4c97858f63954904f2037d7bc81b2681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a30a1c10942df28de78ce3f482dec53" id="r_ga5a30a1c10942df28de78ce3f482dec53"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga5a30a1c10942df28de78ce3f482dec53">SDL::modf</a> (float x, float *y)</td></tr>
<tr class="memdesc:ga5a30a1c10942df28de78ce3f482dec53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split <code>x</code> into integer and fractional parts.  <br /></td></tr>
<tr class="separator:ga5a30a1c10942df28de78ce3f482dec53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cfca7e593d97a56d7fca043af3ac2ce" id="r_ga6cfca7e593d97a56d7fca043af3ac2ce"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga6cfca7e593d97a56d7fca043af3ac2ce">SDL::pow</a> (double x, double y)</td></tr>
<tr class="memdesc:ga6cfca7e593d97a56d7fca043af3ac2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise <code>x</code> to the power <code>y</code>  <br /></td></tr>
<tr class="separator:ga6cfca7e593d97a56d7fca043af3ac2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3b22877237dc964d05f19e5d7c93659" id="r_gac3b22877237dc964d05f19e5d7c93659"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gac3b22877237dc964d05f19e5d7c93659">SDL::pow</a> (float x, float y)</td></tr>
<tr class="memdesc:gac3b22877237dc964d05f19e5d7c93659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise <code>x</code> to the power <code>y</code>  <br /></td></tr>
<tr class="separator:gac3b22877237dc964d05f19e5d7c93659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58af56b2a9898c045c8ec62ec531c8e5" id="r_ga58af56b2a9898c045c8ec62ec531c8e5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga58af56b2a9898c045c8ec62ec531c8e5">SDL::round</a> (double x)</td></tr>
<tr class="memdesc:ga58af56b2a9898c045c8ec62ec531c8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round <code>x</code> to the nearest integer.  <br /></td></tr>
<tr class="separator:ga58af56b2a9898c045c8ec62ec531c8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cf5cc4c422423a6f36915a012c13046" id="r_ga7cf5cc4c422423a6f36915a012c13046"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga7cf5cc4c422423a6f36915a012c13046">SDL::round</a> (float x)</td></tr>
<tr class="memdesc:ga7cf5cc4c422423a6f36915a012c13046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round <code>x</code> to the nearest integer.  <br /></td></tr>
<tr class="separator:ga7cf5cc4c422423a6f36915a012c13046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70024c43f89714b01cc1ff00baa682e0" id="r_ga70024c43f89714b01cc1ff00baa682e0"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga70024c43f89714b01cc1ff00baa682e0">SDL::lround</a> (double x)</td></tr>
<tr class="memdesc:ga70024c43f89714b01cc1ff00baa682e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round <code>x</code> to the nearest integer representable as a long.  <br /></td></tr>
<tr class="separator:ga70024c43f89714b01cc1ff00baa682e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3e2740784189b12f7e3bd55d125827b" id="r_gae3e2740784189b12f7e3bd55d125827b"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae3e2740784189b12f7e3bd55d125827b">SDL::lround</a> (float x)</td></tr>
<tr class="memdesc:gae3e2740784189b12f7e3bd55d125827b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round <code>x</code> to the nearest integer representable as a long.  <br /></td></tr>
<tr class="separator:gae3e2740784189b12f7e3bd55d125827b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2438009a4b8a2f4a9155a168f6cd8303" id="r_ga2438009a4b8a2f4a9155a168f6cd8303"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga2438009a4b8a2f4a9155a168f6cd8303">SDL::scalbn</a> (double x, int n)</td></tr>
<tr class="memdesc:ga2438009a4b8a2f4a9155a168f6cd8303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale <code>x</code> by an integer power of two.  <br /></td></tr>
<tr class="separator:ga2438009a4b8a2f4a9155a168f6cd8303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae36990a63f3564168b682ea67c6635d6" id="r_gae36990a63f3564168b682ea67c6635d6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae36990a63f3564168b682ea67c6635d6">SDL::scalbn</a> (float x, int n)</td></tr>
<tr class="memdesc:gae36990a63f3564168b682ea67c6635d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale <code>x</code> by an integer power of two.  <br /></td></tr>
<tr class="separator:gae36990a63f3564168b682ea67c6635d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88bf16c79b920ce54e0ae909b2948663" id="r_ga88bf16c79b920ce54e0ae909b2948663"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga88bf16c79b920ce54e0ae909b2948663">SDL::sin</a> (double x)</td></tr>
<tr class="memdesc:ga88bf16c79b920ce54e0ae909b2948663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sine of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga88bf16c79b920ce54e0ae909b2948663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc96ee832d85a8d1484467de4d9c83a6" id="r_gafc96ee832d85a8d1484467de4d9c83a6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gafc96ee832d85a8d1484467de4d9c83a6">SDL::sin</a> (float x)</td></tr>
<tr class="memdesc:gafc96ee832d85a8d1484467de4d9c83a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sine of <code>x</code>.  <br /></td></tr>
<tr class="separator:gafc96ee832d85a8d1484467de4d9c83a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8415b71ce1045874d7b55210806ff3c8" id="r_ga8415b71ce1045874d7b55210806ff3c8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8415b71ce1045874d7b55210806ff3c8">SDL::sqrt</a> (double x)</td></tr>
<tr class="memdesc:ga8415b71ce1045874d7b55210806ff3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga8415b71ce1045874d7b55210806ff3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7a01c3316e3a227f2b2aae71b5ecc55" id="r_gaf7a01c3316e3a227f2b2aae71b5ecc55"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaf7a01c3316e3a227f2b2aae71b5ecc55">SDL::sqrt</a> (float x)</td></tr>
<tr class="memdesc:gaf7a01c3316e3a227f2b2aae71b5ecc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of <code>x</code>.  <br /></td></tr>
<tr class="separator:gaf7a01c3316e3a227f2b2aae71b5ecc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88b5a6adb928a623a97598a7a154432c" id="r_ga88b5a6adb928a623a97598a7a154432c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga88b5a6adb928a623a97598a7a154432c">SDL::tan</a> (double x)</td></tr>
<tr class="memdesc:ga88b5a6adb928a623a97598a7a154432c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga88b5a6adb928a623a97598a7a154432c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d01d4f175aeac4ea274982f4fa5a503" id="r_ga3d01d4f175aeac4ea274982f4fa5a503"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga3d01d4f175aeac4ea274982f4fa5a503">SDL::tan</a> (float x)</td></tr>
<tr class="memdesc:ga3d01d4f175aeac4ea274982f4fa5a503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga3d01d4f175aeac4ea274982f4fa5a503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae765b6ec212ab3234f6645eb3c53978a" id="r_gae765b6ec212ab3234f6645eb3c53978a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategoryOwnPtr.html#gad344fd7da4e765054e86e182363639c7">OwnPtr</a>&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae765b6ec212ab3234f6645eb3c53978a">SDL::iconv_string</a> (<a class="el" href="classSDL_1_1StringParam.html">StringParam</a> tocode, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> fromcode, <a class="el" href="classSDL_1_1StringParam.html">StringParam</a> inbuf, size_t inbytesleft)</td></tr>
<tr class="memdesc:gae765b6ec212ab3234f6645eb3c53978a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to convert a string's encoding in one call.  <br /></td></tr>
<tr class="separator:gae765b6ec212ab3234f6645eb3c53978a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eff841be311c6243e4c36bc358e017f" id="r_ga5eff841be311c6243e4c36bc358e017f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga5eff841be311c6243e4c36bc358e017f">SDL::size_mul_check_overflow</a> (size_t a, size_t b, size_t *ret)</td></tr>
<tr class="memdesc:ga5eff841be311c6243e4c36bc358e017f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two integers, checking for overflow.  <br /></td></tr>
<tr class="separator:ga5eff841be311c6243e4c36bc358e017f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a8cffac163d32a70c2a38ed43b8aed6" id="r_ga6a8cffac163d32a70c2a38ed43b8aed6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga6a8cffac163d32a70c2a38ed43b8aed6">SDL::size_add_check_overflow</a> (size_t a, size_t b, size_t *ret)</td></tr>
<tr class="memdesc:ga6a8cffac163d32a70c2a38ed43b8aed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two integers, checking for overflow.  <br /></td></tr>
<tr class="separator:ga6a8cffac163d32a70c2a38ed43b8aed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed4b27374b499c00ef1b3ca5175f8f04" id="r_gaed4b27374b499c00ef1b3ca5175f8f04"><td class="memItemLeft" align="right" valign="top"><a id="gaed4b27374b499c00ef1b3ca5175f8f04" name="gaed4b27374b499c00ef1b3ca5175f8f04"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::EnvironmentUnsafe::EnvironmentUnsafe</b> (<a class="el" href="structSDL_1_1Environment.html">Environment</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:gaed4b27374b499c00ef1b3ca5175f8f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="structSDL_1_1EnvironmentUnsafe.html" title="Unsafe Handle to environment.">EnvironmentUnsafe</a> from <a class="el" href="structSDL_1_1Environment.html" title="Handle to an owned environment.">Environment</a>. <br /></td></tr>
<tr class="separator:gaed4b27374b499c00ef1b3ca5175f8f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga943cff85afc03892d4b0387e8459a13d" id="r_ga943cff85afc03892d4b0387e8459a13d"><td class="memItemLeft" align="right" valign="top"><a id="ga943cff85afc03892d4b0387e8459a13d" name="ga943cff85afc03892d4b0387e8459a13d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::IConvUnsafe::IConvUnsafe</b> (<a class="el" href="structSDL_1_1IConv.html">IConv</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:ga943cff85afc03892d4b0387e8459a13d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="structSDL_1_1IConvUnsafe.html" title="Unsafe Handle to iConv.">IConvUnsafe</a> from <a class="el" href="structSDL_1_1IConv.html" title="Handle to an owned iConv.">IConv</a>. <br /></td></tr>
<tr class="separator:ga943cff85afc03892d4b0387e8459a13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gae6b74b465947579b91be104605e6fd07" id="r_gae6b74b465947579b91be104605e6fd07"><td class="memItemLeft" align="right" valign="top"><a id="gae6b74b465947579b91be104605e6fd07" name="gae6b74b465947579b91be104605e6fd07"></a>
constexpr Sint8&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::MAX_SINT8</b> = SDL_MAX_SINT8</td></tr>
<tr class="separator:gae6b74b465947579b91be104605e6fd07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0be570d5911603656223dabf1c5cdb49" id="r_ga0be570d5911603656223dabf1c5cdb49"><td class="memItemLeft" align="right" valign="top"><a id="ga0be570d5911603656223dabf1c5cdb49" name="ga0be570d5911603656223dabf1c5cdb49"></a>
constexpr Sint8&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::MIN_SINT8</b> = SDL_MIN_SINT8</td></tr>
<tr class="separator:ga0be570d5911603656223dabf1c5cdb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87d50024de748e71f14de8af0b8780c9" id="r_ga87d50024de748e71f14de8af0b8780c9"><td class="memItemLeft" align="right" valign="top"><a id="ga87d50024de748e71f14de8af0b8780c9" name="ga87d50024de748e71f14de8af0b8780c9"></a>
constexpr Uint8&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::MAX_UINT8</b> = SDL_MAX_UINT8</td></tr>
<tr class="separator:ga87d50024de748e71f14de8af0b8780c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3dcfab370a63411100eacc70a866b2c" id="r_gac3dcfab370a63411100eacc70a866b2c"><td class="memItemLeft" align="right" valign="top"><a id="gac3dcfab370a63411100eacc70a866b2c" name="gac3dcfab370a63411100eacc70a866b2c"></a>
constexpr Uint8&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::MIN_UINT8</b> = SDL_MIN_UINT8</td></tr>
<tr class="separator:gac3dcfab370a63411100eacc70a866b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85b1122eb7e054c0bbb0e9730838e375" id="r_ga85b1122eb7e054c0bbb0e9730838e375"><td class="memItemLeft" align="right" valign="top"><a id="ga85b1122eb7e054c0bbb0e9730838e375" name="ga85b1122eb7e054c0bbb0e9730838e375"></a>
constexpr Sint16&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::MAX_SINT16</b> = SDL_MAX_SINT16</td></tr>
<tr class="separator:ga85b1122eb7e054c0bbb0e9730838e375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b469c74f6f1b72ddb47a6761b2776c8" id="r_ga2b469c74f6f1b72ddb47a6761b2776c8"><td class="memItemLeft" align="right" valign="top"><a id="ga2b469c74f6f1b72ddb47a6761b2776c8" name="ga2b469c74f6f1b72ddb47a6761b2776c8"></a>
constexpr Sint16&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::MIN_SINT16</b> = SDL_MIN_SINT16</td></tr>
<tr class="separator:ga2b469c74f6f1b72ddb47a6761b2776c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95b8d501a05cde82e0c9b3bd5c6f50dc" id="r_ga95b8d501a05cde82e0c9b3bd5c6f50dc"><td class="memItemLeft" align="right" valign="top"><a id="ga95b8d501a05cde82e0c9b3bd5c6f50dc" name="ga95b8d501a05cde82e0c9b3bd5c6f50dc"></a>
constexpr Uint16&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::MAX_UINT16</b> = SDL_MAX_UINT16</td></tr>
<tr class="separator:ga95b8d501a05cde82e0c9b3bd5c6f50dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga177c634c8f2ae69978474a9c1e8b8a7f" id="r_ga177c634c8f2ae69978474a9c1e8b8a7f"><td class="memItemLeft" align="right" valign="top"><a id="ga177c634c8f2ae69978474a9c1e8b8a7f" name="ga177c634c8f2ae69978474a9c1e8b8a7f"></a>
constexpr Uint16&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::MIN_UINT16</b> = SDL_MIN_UINT16</td></tr>
<tr class="separator:ga177c634c8f2ae69978474a9c1e8b8a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf027ee3339a63e76791763a7e0db35ac" id="r_gaf027ee3339a63e76791763a7e0db35ac"><td class="memItemLeft" align="right" valign="top"><a id="gaf027ee3339a63e76791763a7e0db35ac" name="gaf027ee3339a63e76791763a7e0db35ac"></a>
constexpr Sint32&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::MAX_SINT32</b> = SDL_MAX_SINT32</td></tr>
<tr class="separator:gaf027ee3339a63e76791763a7e0db35ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dbab3c1d458db3c263d27b6e86ac6c6" id="r_ga6dbab3c1d458db3c263d27b6e86ac6c6"><td class="memItemLeft" align="right" valign="top"><a id="ga6dbab3c1d458db3c263d27b6e86ac6c6" name="ga6dbab3c1d458db3c263d27b6e86ac6c6"></a>
constexpr Sint32&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::MIN_SINT32</b> = SDL_MIN_SINT32</td></tr>
<tr class="separator:ga6dbab3c1d458db3c263d27b6e86ac6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f391d1719e11e472b770a1511478458" id="r_ga3f391d1719e11e472b770a1511478458"><td class="memItemLeft" align="right" valign="top"><a id="ga3f391d1719e11e472b770a1511478458" name="ga3f391d1719e11e472b770a1511478458"></a>
constexpr Uint32&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::MAX_UINT32</b> = SDL_MAX_UINT32</td></tr>
<tr class="separator:ga3f391d1719e11e472b770a1511478458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea113b6d39e254cb015e04423544d8c0" id="r_gaea113b6d39e254cb015e04423544d8c0"><td class="memItemLeft" align="right" valign="top"><a id="gaea113b6d39e254cb015e04423544d8c0" name="gaea113b6d39e254cb015e04423544d8c0"></a>
constexpr Uint8&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::MIN_UINT32</b> = SDL_MIN_UINT32</td></tr>
<tr class="separator:gaea113b6d39e254cb015e04423544d8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1e929f53d64d0fff3907381798eaf9d" id="r_gaa1e929f53d64d0fff3907381798eaf9d"><td class="memItemLeft" align="right" valign="top"><a id="gaa1e929f53d64d0fff3907381798eaf9d" name="gaa1e929f53d64d0fff3907381798eaf9d"></a>
constexpr Sint64&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::MAX_SINT64</b> = SDL_MAX_SINT64</td></tr>
<tr class="separator:gaa1e929f53d64d0fff3907381798eaf9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c7306beb927b53b650633c3132bd02e" id="r_ga8c7306beb927b53b650633c3132bd02e"><td class="memItemLeft" align="right" valign="top"><a id="ga8c7306beb927b53b650633c3132bd02e" name="ga8c7306beb927b53b650633c3132bd02e"></a>
constexpr Sint64&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::MIN_SINT64</b> = SDL_MIN_SINT64</td></tr>
<tr class="separator:ga8c7306beb927b53b650633c3132bd02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e65228f817d9f425d4089bc53233002" id="r_ga5e65228f817d9f425d4089bc53233002"><td class="memItemLeft" align="right" valign="top"><a id="ga5e65228f817d9f425d4089bc53233002" name="ga5e65228f817d9f425d4089bc53233002"></a>
constexpr Uint64&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::MAX_UINT64</b> = SDL_MAX_UINT64</td></tr>
<tr class="separator:ga5e65228f817d9f425d4089bc53233002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga566123592c777849589b83a104aab026" id="r_ga566123592c777849589b83a104aab026"><td class="memItemLeft" align="right" valign="top"><a id="ga566123592c777849589b83a104aab026" name="ga566123592c777849589b83a104aab026"></a>
constexpr Uint8&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::MIN_UINT64</b> = SDL_MIN_UINT64</td></tr>
<tr class="separator:ga566123592c777849589b83a104aab026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacdab1f45d681b4d768287d999fbe747" id="r_gaacdab1f45d681b4d768287d999fbe747"><td class="memItemLeft" align="right" valign="top"><a id="gaacdab1f45d681b4d768287d999fbe747" name="gaacdab1f45d681b4d768287d999fbe747"></a>
constexpr <a class="el" href="classSDL_1_1Time.html">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::MAX_TIME</b> = <a class="el" href="classSDL_1_1Time.html#aef14fc81403f1036d3aac0242d460837">Time::FromNS</a>(SDL_MAX_TIME)</td></tr>
<tr class="separator:gaacdab1f45d681b4d768287d999fbe747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab53f781fca968ecab9d52f035a77b040" id="r_gab53f781fca968ecab9d52f035a77b040"><td class="memItemLeft" align="right" valign="top"><a id="gab53f781fca968ecab9d52f035a77b040" name="gab53f781fca968ecab9d52f035a77b040"></a>
constexpr <a class="el" href="classSDL_1_1Time.html">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SDL::MIN_TIME</b> = <a class="el" href="classSDL_1_1Time.html#aef14fc81403f1036d3aac0242d460837">Time::FromNS</a>(SDL_MIN_TIME)</td></tr>
<tr class="separator:gab53f781fca968ecab9d52f035a77b040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga225b1359489202f60aa60f936b02887b" id="r_ga225b1359489202f60aa60f936b02887b"><td class="memItemLeft" align="right" valign="top">constexpr Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga225b1359489202f60aa60f936b02887b">SDL::INVALID_UNICODE_CODEPOINT</a> = SDL_INVALID_UNICODE_CODEPOINT</td></tr>
<tr class="memdesc:ga225b1359489202f60aa60f936b02887b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Unicode REPLACEMENT CHARACTER codepoint.  <br /></td></tr>
<tr class="separator:ga225b1359489202f60aa60f936b02887b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga912f78e2db3c323780c18a973369ff93" id="r_ga912f78e2db3c323780c18a973369ff93"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga912f78e2db3c323780c18a973369ff93">SDL::PI_D</a> = SDL_PI_D</td></tr>
<tr class="memdesc:ga912f78e2db3c323780c18a973369ff93"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of Pi, as a double-precision floating point literal.  <br /></td></tr>
<tr class="separator:ga912f78e2db3c323780c18a973369ff93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5e09344042b57279887d6cb38cb6c67" id="r_gad5e09344042b57279887d6cb38cb6c67"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gad5e09344042b57279887d6cb38cb6c67">SDL::PI_F</a> = SDL_PI_F</td></tr>
<tr class="memdesc:gad5e09344042b57279887d6cb38cb6c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of Pi, as a single-precision floating point literal.  <br /></td></tr>
<tr class="separator:gad5e09344042b57279887d6cb38cb6c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Using these functions allows an app to have access to common C functionality without depending on a specific C runtime (or a C runtime at all). More importantly, the <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> implementations work identically across platforms, so apps can avoid surprises like <a class="el" href="group__CategoryStdinc.html#ga57b48f04ae9e3949774b9f0c9dc0c151" title="This works exactly like snprintf() but doesn&#39;t require access to a C runtime.">snprintf()</a> behaving differently between Windows and Linux builds, or <a class="el" href="group__CategoryStdinc.html#gac0d19dc9f116d9f492fd4d17296f0c4b" title="Convert an integer into a string.">itoa()</a> only existing on some platforms.</p>
<p>For many of the most common functions, like SDL_memcpy, <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> might just call through to the usual C runtime behind the scenes, if it makes sense to do so (if it's faster and always available/reliable on a given platform), reducing library size and offering the most optimized option.</p>
<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> also offers other C-runtime-adjacent functionality in this header that either isn't, strictly speaking, part of any C runtime standards, like SDL_crc32() and SDL_reinterpret_cast, etc. It also offers a few better options, like SDL_strlcpy(), which functions as a safer form of strcpy(). </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaa20b552293de849b3c1c7576cb158e9e" name="gaa20b552293de849b3c1c7576cb158e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa20b552293de849b3c1c7576cb158e9e">&#9670;&#160;</a></span>SDL_copyp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_copyp</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dst, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">src&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  {                                                                            \</div>
<div class="line">    SDL_COMPILE_TIME_ASSERT(<a class="code hl_define" href="group__CategoryStdinc.html#gaa20b552293de849b3c1c7576cb158e9e">SDL_copyp</a>, <span class="keyword">sizeof</span>(*(dst)) == <span class="keyword">sizeof</span>(*(src)));      \</div>
<div class="line">  }                                                                            \</div>
<div class="line">  SDL_memcpy((dst), (src), <span class="keyword">sizeof</span>(*(src)))</div>
<div class="ttc" id="agroup__CategoryStdinc_html_gaa20b552293de849b3c1c7576cb158e9e"><div class="ttname"><a href="group__CategoryStdinc.html#gaa20b552293de849b3c1c7576cb158e9e">SDL_copyp</a></div><div class="ttdeci">#define SDL_copyp(dst, src)</div><div class="ttdoc">A macro to copy memory between objects, with basic type checking.</div><div class="ttdef"><b>Definition</b> SDL3pp_stdinc.h:2029</div></div>
</div><!-- fragment --><p>memcpy and memmove do not care where you copy memory to and from, which can lead to bugs. This macro aims to avoid most of those bugs by making sure that the source and destination are both pointers to objects that are the same size. It does not check that the objects are the same <em>type</em>, just that the copy will not overflow either object.</p>
<p>The size check happens at compile time, and the compiler will throw an error if the objects are different sizes.</p>
<p>Generally this is intended to copy a single object, not an array.</p>
<p>This macro looks like it double-evaluates its parameters, but the extras them are in <code>sizeof</code> sections, which generate no code nor side-effects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>a pointer to the destination object. Must not be nullptr. </td></tr>
    <tr><td class="paramname">src</td><td>a pointer to the source object. Must not be nullptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaa679b0c4343b25d2a2fa8f6c18ff6e54" name="gaa679b0c4343b25d2a2fa8f6c18ff6e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa679b0c4343b25d2a2fa8f6c18ff6e54">&#9670;&#160;</a></span>SDL_FLT_EPSILON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_FLT_EPSILON&#160;&#160;&#160;1.1920928955078125e-07F /* 0x0.000002p0 */</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equals by default to platform-defined <code>FLT_EPSILON</code>, or <code>1.1920928955078125e-07F</code> if that's not available.</p>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gada422bea61b05ed228c4f42e4aea2144" name="gada422bea61b05ed228c4f42e4aea2144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada422bea61b05ed228c4f42e4aea2144">&#9670;&#160;</a></span>SDL_ICONV_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_ICONV_ERROR&#160;&#160;&#160;(size_t)-1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check GetError()? </p>

</div>
</div>
<a id="ga773e5f83e392495ad8abab8d71aa84c6" name="ga773e5f83e392495ad8abab8d71aa84c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga773e5f83e392495ad8abab8d71aa84c6">&#9670;&#160;</a></span>SDL_iconv_utf8_locale</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_iconv_utf8_locale</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">S</td><td>)</td>
          <td>&#160;&#160;&#160;  SDL_iconv_string(&quot;&quot;, &quot;UTF-8&quot;, S, SDL_strlen(S) + 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a helper macro that might be more clear than calling iconv_string directly. However, it double-evaluates its parameter, so do not use an expression with side-effects here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>the string to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new string, converted to the new encoding, or nullptr on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga59cd43c02306558671fe05c23284ab3b" name="ga59cd43c02306558671fe05c23284ab3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59cd43c02306558671fe05c23284ab3b">&#9670;&#160;</a></span>SDL_iconv_utf8_ucs2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_iconv_utf8_ucs2</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">S</td><td>)</td>
          <td>&#160;&#160;&#160;  (Uint16*)SDL_iconv_string(&quot;UCS-2&quot;, &quot;UTF-8&quot;, S, SDL_strlen(S) + 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a helper macro that might be more clear than calling iconv_string directly. However, it double-evaluates its parameter, so do not use an expression with side-effects here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>the string to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new string, converted to the new encoding, or nullptr on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gacdced7c8985d280d87e659f583a5479e" name="gacdced7c8985d280d87e659f583a5479e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdced7c8985d280d87e659f583a5479e">&#9670;&#160;</a></span>SDL_iconv_utf8_ucs4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_iconv_utf8_ucs4</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">S</td><td>)</td>
          <td>&#160;&#160;&#160;  (Uint32*)SDL_iconv_string(&quot;UCS-4&quot;, &quot;UTF-8&quot;, S, SDL_strlen(S) + 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a helper macro that might be more clear than calling iconv_string directly. However, it double-evaluates its parameter, so do not use an expression with side-effects here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>the string to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new string, converted to the new encoding, or nullptr on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gafaf3cc7fc7c497cbd3f16ddcd85a8fb5" name="gafaf3cc7fc7c497cbd3f16ddcd85a8fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaf3cc7fc7c497cbd3f16ddcd85a8fb5">&#9670;&#160;</a></span>SDL_iconv_wchar_utf8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_iconv_wchar_utf8</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">S</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  SDL_iconv_string(                                                            \</div>
<div class="line">    <span class="stringliteral">&quot;UTF-8&quot;</span>, <span class="stringliteral">&quot;WCHAR_T&quot;</span>, (<span class="keywordtype">char</span>*)S, (SDL_wcslen(S) + 1) * <span class="keyword">sizeof</span>(<span class="keywordtype">wchar_t</span>))</div>
</div><!-- fragment --><p>This is a helper macro that might be more clear than calling iconv_string directly. However, it double-evaluates its parameter, so do not use an expression with side-effects here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>the string to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new string, converted to the new encoding, or nullptr on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaad520b6fa62d69fe36edadb0925196aa" name="gaad520b6fa62d69fe36edadb0925196aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad520b6fa62d69fe36edadb0925196aa">&#9670;&#160;</a></span>SDL_INIT_INTERFACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_INIT_INTERFACE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iface</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                         \</div>
<div class="line">    SDL_zerop(iface);                                                          \</div>
<div class="line">    (iface)-&gt;version = <span class="keyword">sizeof</span>(*(iface));                                       \</div>
<div class="line">  } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment --><p>This macro will initialize an <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> interface structure and should be called before you fill out the fields with your implementation.</p>
<p>You can use it like this:</p>
<div class="fragment"><div class="line">IOStreamInterface iface;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__CategoryStdinc.html#gaad520b6fa62d69fe36edadb0925196aa">SDL_INIT_INTERFACE</a>(&amp;iface);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fill in the interface function pointers with your implementation</span></div>
<div class="line">iface.seek = ...</div>
<div class="line"> </div>
<div class="line">stream = IOStreamRef.IOStreamRef(&amp;iface, <span class="keyword">nullptr</span>);</div>
<div class="ttc" id="agroup__CategoryStdinc_html_gaad520b6fa62d69fe36edadb0925196aa"><div class="ttname"><a href="group__CategoryStdinc.html#gaad520b6fa62d69fe36edadb0925196aa">SDL_INIT_INTERFACE</a></div><div class="ttdeci">#define SDL_INIT_INTERFACE(iface)</div><div class="ttdoc">A macro to initialize an SDL interface.</div><div class="ttdef"><b>Definition</b> SDL3pp_stdinc.h:384</div></div>
</div><!-- fragment --><p>If you are using designated initializers, you can use the size of the interface as the version, e.g.</p>
<div class="fragment"><div class="line">IOStreamInterface iface = {</div>
<div class="line">    .version = <span class="keyword">sizeof</span>(iface),</div>
<div class="line">    .seek = ...</div>
<div class="line">};</div>
<div class="line">stream = IOStreamRef.IOStreamRef(&amp;iface, <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this macro from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>IOStreamInterface </dd>
<dd>
StorageInterface </dd>
<dd>
VirtualJoystickDesc </dd></dl>

</div>
</div>
<a id="ga2b35b3812c6652e64796f5af95bf43e6" name="ga2b35b3812c6652e64796f5af95bf43e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b35b3812c6652e64796f5af95bf43e6">&#9670;&#160;</a></span>SDL_NOLONGLONG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_NOLONGLONG&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> will define this if it believes the compiler doesn't understand the "long long" syntax for C datatypes. This can happen on older compilers.</p>
<p>If <em>your</em> compiler doesn't support "long long" but <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> doesn't know it, it is safe to define this yourself to build against the <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> headers.</p>
<p>If this is defined, it will remove access to some C runtime support functions, like SDL_ulltoa and SDL_strtoll that refer to this datatype explicitly. The rest of <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> will still be available.</p>
<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a>'s own source code cannot be built with a compiler that has this defined, for various technical reasons. </p>

</div>
</div>
<a id="gaff2300e33654fc4e321c53de366f700a" name="gaff2300e33654fc4e321c53de366f700a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff2300e33654fc4e321c53de366f700a">&#9670;&#160;</a></span>SDL_SINT64_C</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_SINT64_C</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td>&#160;&#160;&#160;c##LL /* or whatever the current compiler uses. */</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This helps compilers that might believe a integer literal larger than 0xFFFFFFFF is overflowing a 32-bit value. Use <code><a class="el" href="group__CategoryStdinc.html#gaff2300e33654fc4e321c53de366f700a" title="Append the 64 bit integer suffix to a signed integer literal.">SDL_SINT64_C(0xFFFFFFFF1)</a></code> instead of <code>0xFFFFFFFF1</code> by itself.</p>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga04f4178023c83926428200578ff69184" title="Append the 64 bit integer suffix to an unsigned integer literal.">SDL_UINT64_C</a> </dd></dl>

</div>
</div>
<a id="ga30ef3920f62e49c277e95a80c8f306ac" name="ga30ef3920f62e49c277e95a80c8f306ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30ef3920f62e49c277e95a80c8f306ac">&#9670;&#160;</a></span>SDL_SIZE_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_SIZE_MAX&#160;&#160;&#160;SIZE_MAX</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>size_t</code> is generally the same size as a pointer in modern times, but this can get weird on very old and very esoteric machines. For example, on a 16-bit Intel 286, you might have a 32-bit "far" pointer (16-bit segment plus 16-bit offset), but <code>size_t</code> is 16 bits, because it can only deal with the offset into an individual segment.</p>
<p>In modern times, it's generally expected to cover an entire linear address space. But be careful!</p>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga6450d7299f093c95c1bfa8186fa4c866" name="ga6450d7299f093c95c1bfa8186fa4c866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6450d7299f093c95c1bfa8186fa4c866">&#9670;&#160;</a></span>SDL_STRINGIFY_ARG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_STRINGIFY_ARG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg</td><td>)</td>
          <td>&#160;&#160;&#160;#arg</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define LOG_ERROR(X) OutputDebugString(SDL_STRINGIFY_ARG(__FUNCTION__) &quot;: &quot; X</span></div>
<div class="line"><span class="stringliteral">&quot;@n&quot;</span>)`</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>the text to turn into a string literal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga04f4178023c83926428200578ff69184" name="ga04f4178023c83926428200578ff69184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04f4178023c83926428200578ff69184">&#9670;&#160;</a></span>SDL_UINT64_C</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_UINT64_C</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td>&#160;&#160;&#160;c##ULL /* or whatever the current compiler uses. */</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This helps compilers that might believe a integer literal larger than 0xFFFFFFFF is overflowing a 32-bit value. Use <code><a class="el" href="group__CategoryStdinc.html#ga04f4178023c83926428200578ff69184" title="Append the 64 bit integer suffix to an unsigned integer literal.">SDL_UINT64_C(0xFFFFFFFF1)</a></code> instead of <code>0xFFFFFFFF1</code> by itself.</p>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gaff2300e33654fc4e321c53de366f700a" title="Append the 64 bit integer suffix to a signed integer literal.">SDL_SINT64_C</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga4f2714c0d9540b5e1e85ed5503c59215" name="ga4f2714c0d9540b5e1e85ed5503c59215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f2714c0d9540b5e1e85ed5503c59215">&#9670;&#160;</a></span>calloc_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">SDL::calloc_func</a> = typedef SDL_calloc_func</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> will always ensure that the passed <code>nmemb</code> and <code>size</code> are both greater than 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nmemb</td><td>the number of elements in the array. </td></tr>
    <tr><td class="paramname">size</td><td>the size of each element of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated array, or nullptr if allocation failed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It should be safe to call this callback from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gab24b3e9482f5a1c26602b83f2de05d09" title="Allocate a zero-initialized array.">calloc</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga6325f645ab936554e7aaa2e4d977d9d7" title="Get the original set of SDL memory functions.">GetOriginalMemoryFunctions</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gab331691e9cf41b2fd9063b80910ea6b0" title="Get the current set of SDL memory functions.">GetMemoryFunctions</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga048ad88f068e4b9b9f81703377d3d1a9" title="Replace SDL&#39;s memory allocation functions with a custom set.">SetMemoryFunctions</a> </dd></dl>

</div>
</div>
<a id="gabc94be94823c25031d6dd9210ef3e81a" name="gabc94be94823c25031d6dd9210ef3e81a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc94be94823c25031d6dd9210ef3e81a">&#9670;&#160;</a></span>CompareCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryStdinc.html#gabc94be94823c25031d6dd9210ef3e81a">SDL::CompareCallback</a> = typedef SDL_CompareCallback</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>a pointer to the first element being compared. </td></tr>
    <tr><td class="paramname">b</td><td>a pointer to the second element being compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if <code>a</code> should be sorted before <code>b</code>, 1 if <code>b</code> should be sorted before <code>a</code>, 0 if they are equal. If two elements are equal, their order in the sorted array is undefined.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This callback is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gada62aea13b8eceffa3e57359e124e541" title="Perform a binary search on a previously sorted array.">bsearch</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gab52a0ec3d96fb4c04972b1b322f75857" title="Sort an array.">qsort</a> </dd></dl>

</div>
</div>
<a id="gab5c634ea2ae9a102fa58cd7beac9f478" name="gab5c634ea2ae9a102fa58cd7beac9f478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5c634ea2ae9a102fa58cd7beac9f478">&#9670;&#160;</a></span>CompareCallback_r</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryStdinc.html#gab5c634ea2ae9a102fa58cd7beac9f478">SDL::CompareCallback_r</a> = typedef SDL_CompareCallback_r</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userdata</td><td>the <code>userdata</code> pointer passed to the sort function. </td></tr>
    <tr><td class="paramname">a</td><td>a pointer to the first element being compared. </td></tr>
    <tr><td class="paramname">b</td><td>a pointer to the second element being compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if <code>a</code> should be sorted before <code>b</code>, 1 if <code>b</code> should be sorted before <code>a</code>, 0 if they are equal. If two elements are equal, their order in the sorted array is undefined.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This callback is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gaa3b0083aa5cb6236224048d437834dd2" title="Sort an array, passing a userdata pointer to the compare function.">qsort_r</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaf22f982867b4598c8caa2de8f5a9e0e4" title="Perform a binary search on a previously sorted array, passing a userdata pointer to the compare funct...">bsearch_r</a> </dd></dl>

</div>
</div>
<a id="ga7dc5ada5f1f8fe87900b8fa72e94abca" name="ga7dc5ada5f1f8fe87900b8fa72e94abca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dc5ada5f1f8fe87900b8fa72e94abca">&#9670;&#160;</a></span>CompareCB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryStdinc.html#ga7dc5ada5f1f8fe87900b8fa72e94abca">SDL::CompareCB</a> = typedef std::function&lt;int(const void*, const void*)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>a pointer to the first element being compared. </td></tr>
    <tr><td class="paramname">b</td><td>a pointer to the second element being compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if <code>a</code> should be sorted before <code>b</code>, 1 if <code>b</code> should be sorted before <code>a</code>, 0 if they are equal. If two elements are equal, their order in the sorted array is undefined.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This callback is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gaa3b0083aa5cb6236224048d437834dd2" title="Sort an array, passing a userdata pointer to the compare function.">qsort_r</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaf22f982867b4598c8caa2de8f5a9e0e4" title="Perform a binary search on a previously sorted array, passing a userdata pointer to the compare funct...">bsearch_r</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gab5c634ea2ae9a102fa58cd7beac9f478" title="A callback used with SDL sorting and binary search functions.">CompareCallback_r</a> </dd></dl>

</div>
</div>
<a id="ga80cbbb5b121c8f78d44a66deaa573127" name="ga80cbbb5b121c8f78d44a66deaa573127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80cbbb5b121c8f78d44a66deaa573127">&#9670;&#160;</a></span>free_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">SDL::free_func</a> = typedef SDL_free_func</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> will always ensure that the passed <code>mem</code> is a non-nullptr pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>a pointer to allocated memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It should be safe to call this callback from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gadfa01257ca1f966fffb72f002db27fa6" title="Free allocated memory.">free</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga6325f645ab936554e7aaa2e4d977d9d7" title="Get the original set of SDL memory functions.">GetOriginalMemoryFunctions</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gab331691e9cf41b2fd9063b80910ea6b0" title="Get the current set of SDL memory functions.">GetMemoryFunctions</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga048ad88f068e4b9b9f81703377d3d1a9" title="Replace SDL&#39;s memory allocation functions with a custom set.">SetMemoryFunctions</a> </dd></dl>

</div>
</div>
<a id="ga379a3713730374c4737a2bfb2004fab7" name="ga379a3713730374c4737a2bfb2004fab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga379a3713730374c4737a2bfb2004fab7">&#9670;&#160;</a></span>FunctionPointer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryStdinc.html#ga379a3713730374c4737a2bfb2004fab7">SDL::FunctionPointer</a> = typedef SDL_FunctionPointer</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In theory, generic function pointers should use this, instead of <code>void *</code>, since some platforms could treat code addresses differently than data addresses. Although in current times no popular platforms make this distinction, it is more correct and portable to use the correct type for a generic pointer.</p>
<p>If for some reason you need to force this typedef to be an actual <code>void *</code>, perhaps to work around a compiler or existing code, you can define <code>SDL_FUNCTION_POINTER_IS_VOID_POINTER</code> before including any <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> headers.</p>
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga20e849be3a477a832c3f5b49aa71f793" name="ga20e849be3a477a832c3f5b49aa71f793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20e849be3a477a832c3f5b49aa71f793">&#9670;&#160;</a></span>malloc_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">SDL::malloc_func</a> = typedef SDL_malloc_func</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> will always ensure that the passed <code>size</code> is greater than 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the size to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory, or nullptr if allocation failed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It should be safe to call this callback from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga48fe5521cb77ff8e4ae442bc8387be70" title="Allocate uninitialized memory.">malloc</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga6325f645ab936554e7aaa2e4d977d9d7" title="Get the original set of SDL memory functions.">GetOriginalMemoryFunctions</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gab331691e9cf41b2fd9063b80910ea6b0" title="Get the current set of SDL memory functions.">GetMemoryFunctions</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga048ad88f068e4b9b9f81703377d3d1a9" title="Replace SDL&#39;s memory allocation functions with a custom set.">SetMemoryFunctions</a> </dd></dl>

</div>
</div>
<a id="gaa0d42a4ebfbbe5ab7908f55ba0560ecb" name="gaa0d42a4ebfbbe5ab7908f55ba0560ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">&#9670;&#160;</a></span>realloc_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">SDL::realloc_func</a> = typedef SDL_realloc_func</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> will always ensure that the passed <code>size</code> is greater than 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>a pointer to allocated memory to reallocate, or nullptr. </td></tr>
    <tr><td class="paramname">size</td><td>the new size of the memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly allocated memory, or nullptr if allocation failed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It should be safe to call this callback from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gab8208c1b381e6a96b07b5facff79c27b" title="Change the size of allocated memory.">realloc</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga6325f645ab936554e7aaa2e4d977d9d7" title="Get the original set of SDL memory functions.">GetOriginalMemoryFunctions</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gab331691e9cf41b2fd9063b80910ea6b0" title="Get the current set of SDL memory functions.">GetMemoryFunctions</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga048ad88f068e4b9b9f81703377d3d1a9" title="Replace SDL&#39;s memory allocation functions with a custom set.">SetMemoryFunctions</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gadd53991e26e130aa47ac47f23f187ac3" name="gadd53991e26e130aa47ac47f23f187ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd53991e26e130aa47ac47f23f187ac3">&#9670;&#160;</a></span>abs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::abs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>0 &lt;= y &lt;= INF</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value to use as the magnitude. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the absolute value of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gab188f3aa930df339c851b95bf2c4030b" title="Compute the absolute value of x.">abs</a> </dd></dl>

</div>
</div>
<a id="gac002154c442e2a92fb84a60c454cecf8" name="gac002154c442e2a92fb84a60c454cecf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac002154c442e2a92fb84a60c454cecf8">&#9670;&#160;</a></span>abs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::abs </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>0 &lt;= y &lt;= INF</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value to use as the magnitude. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the absolute value of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gab188f3aa930df339c851b95bf2c4030b" title="Compute the absolute value of x.">abs</a> </dd></dl>

</div>
</div>
<a id="gab188f3aa930df339c851b95bf2c4030b" name="gab188f3aa930df339c851b95bf2c4030b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab188f3aa930df339c851b95bf2c4030b">&#9670;&#160;</a></span>abs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::abs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>an integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the absolute value of x.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga9f6543d319422a6044570b59cc6377b4" name="ga9f6543d319422a6044570b59cc6377b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f6543d319422a6044570b59cc6377b4">&#9670;&#160;</a></span>acos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::acos </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of <code>y = acos(x)</code> is <code>x = cos(y)</code>.</p>
<p>Domain: <code>-1 &lt;= x &lt;= 1</code></p>
<p>Range: <code>0 &lt;= y &lt;= Pi</code></p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc cosine of <code>x</code>, in radians.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga316a2eed1e595c002830ee628c1b4963" title="Compute the arc sine of x.">asin</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gadf8c80d673a05784387fa5e349a9f6dd" title="Compute the cosine of x.">cos</a> </dd></dl>

</div>
</div>
<a id="ga8cb5c957259b2c7dea56281b8a8e0b2e" name="ga8cb5c957259b2c7dea56281b8a8e0b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cb5c957259b2c7dea56281b8a8e0b2e">&#9670;&#160;</a></span>acos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::acos </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of <code>y = acos(x)</code> is <code>x = cos(y)</code>.</p>
<p>Domain: <code>-1 &lt;= x &lt;= 1</code></p>
<p>Range: <code>0 &lt;= y &lt;= Pi</code></p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc cosine of <code>x</code>, in radians.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga316a2eed1e595c002830ee628c1b4963" title="Compute the arc sine of x.">asin</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gadf8c80d673a05784387fa5e349a9f6dd" title="Compute the cosine of x.">cos</a> </dd></dl>

</div>
</div>
<a id="gae3c9f70ddeadaecb2afeee2b3be34733" name="gae3c9f70ddeadaecb2afeee2b3be34733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3c9f70ddeadaecb2afeee2b3be34733">&#9670;&#160;</a></span>aligned_alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::aligned_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The memory returned by this function must be freed with <a class="el" href="group__CategoryStdinc.html#gaaf1efed697d82742be084a1871c95aa2" title="Free memory allocated by aligned_alloc().">aligned_free()</a>, <em>not</em> <a class="el" href="group__CategoryStdinc.html#gadfa01257ca1f966fffb72f002db27fa6" title="Free allocated memory.">free()</a>.</p>
<p>If <code>alignment</code> is less than the size of <code>void *</code>, it will be increased to match that.</p>
<p>The returned memory address will be a multiple of the alignment value, and the size of the memory allocated will be a multiple of the alignment value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alignment</td><td>the alignment of the memory. </td></tr>
    <tr><td class="paramname">size</td><td>the size to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the aligned memory, or nullptr if allocation failed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gaaf1efed697d82742be084a1871c95aa2" title="Free memory allocated by aligned_alloc().">aligned_free</a> </dd></dl>

</div>
</div>
<a id="gaaf1efed697d82742be084a1871c95aa2" name="gaaf1efed697d82742be084a1871c95aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf1efed697d82742be084a1871c95aa2">&#9670;&#160;</a></span>aligned_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::aligned_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The pointer is no longer valid after this call and cannot be dereferenced anymore.</p>
<p>If <code>mem</code> is nullptr, this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>a pointer previously returned by <a class="el" href="group__CategoryStdinc.html#gae3c9f70ddeadaecb2afeee2b3be34733" title="Allocate memory aligned to a specific alignment.">aligned_alloc()</a>, or nullptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gae3c9f70ddeadaecb2afeee2b3be34733" title="Allocate memory aligned to a specific alignment.">aligned_alloc</a> </dd></dl>

</div>
</div>
<a id="ga20b4cc6c53a1dbd7789ee90af065b5f9" name="ga20b4cc6c53a1dbd7789ee90af065b5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20b4cc6c53a1dbd7789ee90af065b5f9">&#9670;&#160;</a></span>arraysize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t SDL::arraysize </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will compile but return incorrect results for a pointer to an array; it has to be an array the compiler knows the size of.</p>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga316a2eed1e595c002830ee628c1b4963" name="ga316a2eed1e595c002830ee628c1b4963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga316a2eed1e595c002830ee628c1b4963">&#9670;&#160;</a></span>asin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::asin </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of <code>y = asin(x)</code> is <code>x = sin(y)</code>.</p>
<p>Domain: <code>-1 &lt;= x &lt;= 1</code></p>
<p>Range: <code>-Pi/2 &lt;= y &lt;= Pi/2</code></p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc sine of <code>x</code>, in radians.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga9f6543d319422a6044570b59cc6377b4" title="Compute the arc cosine of x.">acos</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga88bf16c79b920ce54e0ae909b2948663" title="Compute the sine of x.">sin</a> </dd></dl>

</div>
</div>
<a id="gaf0b3b75a8c4e13c1de7bffdf67d1f4df" name="gaf0b3b75a8c4e13c1de7bffdf67d1f4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0b3b75a8c4e13c1de7bffdf67d1f4df">&#9670;&#160;</a></span>asin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::asin </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of <code>y = asin(x)</code> is <code>x = sin(y)</code>.</p>
<p>Domain: <code>-1 &lt;= x &lt;= 1</code></p>
<p>Range: <code>-Pi/2 &lt;= y &lt;= Pi/2</code></p>
<p>This function operates on single-precision floating point values, use asin for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc sine of <code>x</code>, in radians.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga9f6543d319422a6044570b59cc6377b4" title="Compute the arc cosine of x.">acos</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga88bf16c79b920ce54e0ae909b2948663" title="Compute the sine of x.">sin</a> </dd></dl>

</div>
</div>
<a id="ga12e5aac7458286e05c61d71278f59215" name="ga12e5aac7458286e05c61d71278f59215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12e5aac7458286e05c61d71278f59215">&#9670;&#160;</a></span>asprintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::asprintf </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>strp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_PRINTF_FORMAT_STRING const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Functions identically to <a class="el" href="group__CategoryStdinc.html#ga57b48f04ae9e3949774b9f0c9dc0c151" title="This works exactly like snprintf() but doesn&#39;t require access to a C runtime.">snprintf()</a>, except it allocates a buffer large enough to hold the output string on behalf of the caller.</p>
<p>On success, this function returns the number of bytes (not characters) comprising the output string, not counting the null-terminator character, and sets <code>*strp</code> to the newly-allocated string.</p>
<p>On error, this function returns a negative number, and the value of <code>*strp</code> is undefined.</p>
<p>The returned string is owned by the caller, and should be passed to free when no longer needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strp</td><td>on output, is set to the new string. Must not be nullptr. </td></tr>
    <tr><td class="paramname">fmt</td><td>a printf-style format string. Must not be nullptr. </td></tr>
    <tr><td class="paramname">...</td><td>a list of values to be used with the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes in the newly-allocated string, not counting the null-terminator char, or a negative value on error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga11d0eaba28baba36fc8050f8541c8ee5" name="ga11d0eaba28baba36fc8050f8541c8ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11d0eaba28baba36fc8050f8541c8ee5">&#9670;&#160;</a></span>atan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::atan </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of <code>y = atan(x)</code> is <code>x = tan(y)</code>.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-Pi/2 &lt;= y &lt;= Pi/2</code></p>
<p>To calculate the arc tangent of y / x, use atan2.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc tangent of of <code>x</code> in radians, or 0 if <code>x = 0</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gae0884b892c70d428cf50522d9791eb61" title="Compute the arc tangent of y / x, using the signs of x and y to adjust the result&#39;s quadrant.">atan2</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga88b5a6adb928a623a97598a7a154432c" title="Compute the tangent of x.">tan</a> </dd></dl>

</div>
</div>
<a id="gac79b3402c34e7ee5cfb6b99e61cb2986" name="gac79b3402c34e7ee5cfb6b99e61cb2986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac79b3402c34e7ee5cfb6b99e61cb2986">&#9670;&#160;</a></span>atan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::atan </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of <code>y = atan(x)</code> is <code>x = tan(y)</code>.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-Pi/2 &lt;= y &lt;= Pi/2</code></p>
<p>To calculate the arc tangent of y / x, use atan2f.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc tangent of of <code>x</code> in radians, or 0 if <code>x = 0</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gae0884b892c70d428cf50522d9791eb61" title="Compute the arc tangent of y / x, using the signs of x and y to adjust the result&#39;s quadrant.">atan2</a> </dd></dl>

</div>
</div>
<a id="gae0884b892c70d428cf50522d9791eb61" name="gae0884b892c70d428cf50522d9791eb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0884b892c70d428cf50522d9791eb61">&#9670;&#160;</a></span>atan2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::atan2 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of <code>z = atan2(x, y)</code> is <code>y = x tan(z)</code>, where the quadrant of z is determined based on the signs of x and y.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= INF</code></p>
<p>Range: <code>-Pi &lt;= y &lt;= Pi</code></p>
<p>This function operates on double-precision floating point values, use atan2f for single-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>floating point value of the numerator (y coordinate). </td></tr>
    <tr><td class="paramname">x</td><td>floating point value of the denominator (x coordinate). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc tangent of of <code>y / x</code> in radians, or, if <code>x = 0</code>, either <code>-Pi/2</code>, <code>0</code>, or <code>Pi/2</code>, depending on the value of <code>y</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga11d0eaba28baba36fc8050f8541c8ee5" title="Compute the arc tangent of x.">atan</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga88b5a6adb928a623a97598a7a154432c" title="Compute the tangent of x.">tan</a> </dd></dl>

</div>
</div>
<a id="gab6e37f048360d49896fe3562d15e0b26" name="gab6e37f048360d49896fe3562d15e0b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6e37f048360d49896fe3562d15e0b26">&#9670;&#160;</a></span>atan2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::atan2 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of <code>z = atan2(x, y)</code> is <code>y = x tan(z)</code>, where the quadrant of z is determined based on the signs of x and y.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= INF</code></p>
<p>Range: <code>-Pi &lt;= y &lt;= Pi</code></p>
<p>This function operates on single-precision floating point values, use atan2 for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>floating point value of the numerator (y coordinate). </td></tr>
    <tr><td class="paramname">x</td><td>floating point value of the denominator (x coordinate). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc tangent of of <code>y / x</code> in radians, or, if <code>x = 0</code>, either <code>-Pi/2</code>, <code>0</code>, or <code>Pi/2</code>, depending on the value of <code>y</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga11d0eaba28baba36fc8050f8541c8ee5" title="Compute the arc tangent of x.">atan</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga88b5a6adb928a623a97598a7a154432c" title="Compute the tangent of x.">tan</a> </dd></dl>

</div>
</div>
<a id="gaeecdd7ec80c303a7474d59b641a892f7" name="gaeecdd7ec80c303a7474d59b641a892f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeecdd7ec80c303a7474d59b641a892f7">&#9670;&#160;</a></span>atof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::atof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The result of calling <code>atof(str)</code> is equivalent to <code>strtod(str,
nullptr)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to read. Must not be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed <code>double</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga756fd0202aa809d537fc01e28b0c7564" title="Parse an int from a string.">atoi</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaf270570877b7a6ccaea59ba90b428043" title="Parse a long from a string.">strtol</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga3869ab21242a2a6fb41be41b382d2af2" title="Parse an unsigned long from a string.">strtoul</a> </dd>
<dd>
SDL_strtoll </dd>
<dd>
SDL_strtoull </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga062de74e1950744ad5556cc815c58036" title="Parse a double from a string.">strtod</a> </dd></dl>

</div>
</div>
<a id="ga756fd0202aa809d537fc01e28b0c7564" name="ga756fd0202aa809d537fc01e28b0c7564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga756fd0202aa809d537fc01e28b0c7564">&#9670;&#160;</a></span>atoi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::atoi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The result of calling <code>atoi(str)</code> is equivalent to <code>(int)strtol(str, nullptr, 10)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to read. Must not be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed <code>int</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gaeecdd7ec80c303a7474d59b641a892f7" title="Parse a double from a string.">atof</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaf270570877b7a6ccaea59ba90b428043" title="Parse a long from a string.">strtol</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga3869ab21242a2a6fb41be41b382d2af2" title="Parse an unsigned long from a string.">strtoul</a> </dd>
<dd>
SDL_strtoll </dd>
<dd>
SDL_strtoull </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga062de74e1950744ad5556cc815c58036" title="Parse a double from a string.">strtod</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gac0d19dc9f116d9f492fd4d17296f0c4b" title="Convert an integer into a string.">itoa</a> </dd></dl>

</div>
</div>
<a id="gada62aea13b8eceffa3e57359e124e541" name="gada62aea13b8eceffa3e57359e124e541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada62aea13b8eceffa3e57359e124e541">&#9670;&#160;</a></span>bsearch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::bsearch </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gabc94be94823c25031d6dd9210ef3e81a">CompareCallback</a>&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For example:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *string;</div>
<div class="line">} data;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> SDLCALL compare(<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> data *A = (<span class="keyword">const</span> data *)a;</div>
<div class="line">    <span class="keyword">const</span> data *B = (<span class="keyword">const</span> data *)b;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (A-&gt;n &lt; B-&gt;n) {</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (B-&gt;n &lt; A-&gt;n) {</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">data values[] = {</div>
<div class="line">    { 1, <span class="stringliteral">&quot;first&quot;</span> }, { 2, <span class="stringliteral">&quot;second&quot;</span> }, { 3, <span class="stringliteral">&quot;third&quot;</span> }</div>
<div class="line">};</div>
<div class="line">data key = { 2, <span class="keyword">nullptr</span> };</div>
<div class="line"> </div>
<div class="line">data *result = <a class="code hl_function" href="group__CategoryStdinc.html#gada62aea13b8eceffa3e57359e124e541">bsearch</a>(&amp;key, values, <a class="code hl_function" href="group__CategoryStdinc.html#ga20b4cc6c53a1dbd7789ee90af065b5f9">arraysize</a>(values), <span class="keyword">sizeof</span>(values[0]),</div>
<div class="line">compare);</div>
<div class="ttc" id="agroup__CategoryStdinc_html_ga20b4cc6c53a1dbd7789ee90af065b5f9"><div class="ttname"><a href="group__CategoryStdinc.html#ga20b4cc6c53a1dbd7789ee90af065b5f9">SDL::arraysize</a></div><div class="ttdeci">constexpr std::size_t arraysize(const T(&amp;array)[N])</div><div class="ttdoc">The number of elements in a static array.</div><div class="ttdef"><b>Definition</b> SDL3pp_stdinc.h:102</div></div>
<div class="ttc" id="agroup__CategoryStdinc_html_gada62aea13b8eceffa3e57359e124e541"><div class="ttname"><a href="group__CategoryStdinc.html#gada62aea13b8eceffa3e57359e124e541">SDL::bsearch</a></div><div class="ttdeci">void * bsearch(const void *key, const void *base, size_t nmemb, size_t size, CompareCallback compare)</div><div class="ttdoc">Perform a binary search on a previously sorted array.</div><div class="ttdef"><b>Definition</b> SDL3pp_stdinc.h:1234</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a pointer to a key equal to the element being searched for. </td></tr>
    <tr><td class="paramname">base</td><td>a pointer to the start of the array. </td></tr>
    <tr><td class="paramname">nmemb</td><td>the number of elements in the array. </td></tr>
    <tr><td class="paramname">size</td><td>the size of the elements in the array. </td></tr>
    <tr><td class="paramname">compare</td><td>a function used to compare elements in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the matching element in the array, or nullptr if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gaf22f982867b4598c8caa2de8f5a9e0e4" title="Perform a binary search on a previously sorted array, passing a userdata pointer to the compare funct...">bsearch_r</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gab52a0ec3d96fb4c04972b1b322f75857" title="Sort an array.">qsort</a> </dd></dl>

</div>
</div>
<a id="gaf22f982867b4598c8caa2de8f5a9e0e4" name="gaf22f982867b4598c8caa2de8f5a9e0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf22f982867b4598c8caa2de8f5a9e0e4">&#9670;&#160;</a></span>bsearch_r() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::bsearch_r </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gab5c634ea2ae9a102fa58cd7beac9f478">CompareCallback_r</a>&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For example:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> {</div>
<div class="line">    sort_increasing,</div>
<div class="line">    sort_decreasing,</div>
<div class="line">} sort_method;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *string;</div>
<div class="line">} data;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> SDLCALL compare(<span class="keyword">const</span> <span class="keywordtype">void</span> *userdata, <span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)</div>
<div class="line">{</div>
<div class="line">    sort_method method = (sort_method)(uintptr_t)userdata;</div>
<div class="line">    <span class="keyword">const</span> data *A = (<span class="keyword">const</span> data *)a;</div>
<div class="line">    <span class="keyword">const</span> data *B = (<span class="keyword">const</span> data *)b;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (A-&gt;key &lt; B-&gt;key) {</div>
<div class="line">        <span class="keywordflow">return</span> (method == sort_increasing) ? -1 : 1;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (B-&gt;key &lt; A-&gt;key) {</div>
<div class="line">        <span class="keywordflow">return</span> (method == sort_increasing) ? 1 : -1;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">data values[] = {</div>
<div class="line">    { 1, <span class="stringliteral">&quot;first&quot;</span> }, { 2, <span class="stringliteral">&quot;second&quot;</span> }, { 3, <span class="stringliteral">&quot;third&quot;</span> }</div>
<div class="line">};</div>
<div class="line">data key = { 2, <span class="keyword">nullptr</span> };</div>
<div class="line"> </div>
<div class="line">data *result = <a class="code hl_function" href="group__CategoryStdinc.html#gaf22f982867b4598c8caa2de8f5a9e0e4">bsearch_r</a>(&amp;key, values, <a class="code hl_function" href="group__CategoryStdinc.html#ga20b4cc6c53a1dbd7789ee90af065b5f9">arraysize</a>(values), <span class="keyword">sizeof</span>(values[0]),</div>
<div class="line">compare, (<span class="keyword">const</span> <span class="keywordtype">void</span> *)(uintptr_t)sort_increasing);</div>
<div class="ttc" id="agroup__CategoryStdinc_html_gaf22f982867b4598c8caa2de8f5a9e0e4"><div class="ttname"><a href="group__CategoryStdinc.html#gaf22f982867b4598c8caa2de8f5a9e0e4">SDL::bsearch_r</a></div><div class="ttdeci">void * bsearch_r(const void *key, const void *base, size_t nmemb, size_t size, CompareCallback_r compare, void *userdata)</div><div class="ttdoc">Perform a binary search on a previously sorted array, passing a userdata pointer to the compare funct...</div><div class="ttdef"><b>Definition</b> SDL3pp_stdinc.h:1459</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a pointer to a key equal to the element being searched for. </td></tr>
    <tr><td class="paramname">base</td><td>a pointer to the start of the array. </td></tr>
    <tr><td class="paramname">nmemb</td><td>the number of elements in the array. </td></tr>
    <tr><td class="paramname">size</td><td>the size of the elements in the array. </td></tr>
    <tr><td class="paramname">compare</td><td>a function used to compare elements in the array. </td></tr>
    <tr><td class="paramname">userdata</td><td>a pointer to pass to the compare function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the matching element in the array, or nullptr if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gada62aea13b8eceffa3e57359e124e541" title="Perform a binary search on a previously sorted array.">bsearch</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaa3b0083aa5cb6236224048d437834dd2" title="Sort an array, passing a userdata pointer to the compare function.">qsort_r</a> </dd></dl>

</div>
</div>
<a id="ga23c5948242cf76d2bcbc0a52c6c53ed8" name="ga23c5948242cf76d2bcbc0a52c6c53ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23c5948242cf76d2bcbc0a52c6c53ed8">&#9670;&#160;</a></span>bsearch_r() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::bsearch_r </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga7dc5ada5f1f8fe87900b8fa72e94abca">CompareCB</a>&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For example:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> {</div>
<div class="line">    sort_increasing,</div>
<div class="line">    sort_decreasing,</div>
<div class="line">} sort_method;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *string;</div>
<div class="line">} data;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> SDLCALL compare(<span class="keyword">const</span> <span class="keywordtype">void</span> *userdata, <span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)</div>
<div class="line">{</div>
<div class="line">    sort_method method = (sort_method)(uintptr_t)userdata;</div>
<div class="line">    <span class="keyword">const</span> data *A = (<span class="keyword">const</span> data *)a;</div>
<div class="line">    <span class="keyword">const</span> data *B = (<span class="keyword">const</span> data *)b;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (A-&gt;key &lt; B-&gt;key) {</div>
<div class="line">        <span class="keywordflow">return</span> (method == sort_increasing) ? -1 : 1;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (B-&gt;key &lt; A-&gt;key) {</div>
<div class="line">        <span class="keywordflow">return</span> (method == sort_increasing) ? 1 : -1;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">data values[] = {</div>
<div class="line">    { 1, <span class="stringliteral">&quot;first&quot;</span> }, { 2, <span class="stringliteral">&quot;second&quot;</span> }, { 3, <span class="stringliteral">&quot;third&quot;</span> }</div>
<div class="line">};</div>
<div class="line">data key = { 2, <span class="keyword">nullptr</span> };</div>
<div class="line"> </div>
<div class="line">data *result = <a class="code hl_function" href="group__CategoryStdinc.html#gaf22f982867b4598c8caa2de8f5a9e0e4">bsearch_r</a>(&amp;key, values, <a class="code hl_function" href="group__CategoryStdinc.html#ga20b4cc6c53a1dbd7789ee90af065b5f9">arraysize</a>(values), <span class="keyword">sizeof</span>(values[0]),</div>
<div class="line">compare, (<span class="keyword">const</span> <span class="keywordtype">void</span> *)(uintptr_t)sort_increasing);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a pointer to a key equal to the element being searched for. </td></tr>
    <tr><td class="paramname">base</td><td>a pointer to the start of the array. </td></tr>
    <tr><td class="paramname">nmemb</td><td>the number of elements in the array. </td></tr>
    <tr><td class="paramname">size</td><td>the size of the elements in the array. </td></tr>
    <tr><td class="paramname">compare</td><td>a function used to compare elements in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the matching element in the array, or nullptr if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gada62aea13b8eceffa3e57359e124e541" title="Perform a binary search on a previously sorted array.">bsearch</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaa3b0083aa5cb6236224048d437834dd2" title="Sort an array, passing a userdata pointer to the compare function.">qsort_r</a> </dd></dl>

</div>
</div>
<a id="gab24b3e9482f5a1c26602b83f2de05d09" name="gab24b3e9482f5a1c26602b83f2de05d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab24b3e9482f5a1c26602b83f2de05d09">&#9670;&#160;</a></span>calloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::calloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The memory returned by this function must be freed with <a class="el" href="group__CategoryStdinc.html#gadfa01257ca1f966fffb72f002db27fa6" title="Free allocated memory.">free()</a>.</p>
<p>If either of <code>nmemb</code> or <code>size</code> is 0, they will both be set to 1.</p>
<p>If the allocation is successful, the returned pointer is guaranteed to be aligned to either the <em>fundamental alignment</em> (<code>alignof(max_align_t)</code> in C11 and later) or <code>2 * sizeof(void *)</code>, whichever is smaller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nmemb</td><td>the number of elements in the array. </td></tr>
    <tr><td class="paramname">size</td><td>the size of each element of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated array, or nullptr if allocation failed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gadfa01257ca1f966fffb72f002db27fa6" title="Free allocated memory.">free</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga48fe5521cb77ff8e4ae442bc8387be70" title="Allocate uninitialized memory.">malloc</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gab8208c1b381e6a96b07b5facff79c27b" title="Change the size of allocated memory.">realloc</a> </dd></dl>

</div>
</div>
<a id="ga1567a1e6b1738fabc6252d7c52f03321" name="ga1567a1e6b1738fabc6252d7c52f03321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1567a1e6b1738fabc6252d7c52f03321">&#9670;&#160;</a></span>ceil() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::ceil </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The ceiling of <code>x</code> is the smallest integer <code>y</code> such that <code>y &gt; x</code>, i.e <code>x</code> rounded up to the nearest integer.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ceiling of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gaa5d99939c5dffc37035e51300236316a" title="Compute the floor of x.">floor</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaeb64b2b465e001720dce40bacec1b937" title="Truncate x to an integer.">trunc</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga58af56b2a9898c045c8ec62ec531c8e5" title="Round x to the nearest integer.">round</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga70024c43f89714b01cc1ff00baa682e0" title="Round x to the nearest integer representable as a long.">lround</a> </dd></dl>

</div>
</div>
<a id="ga14a86ff5b6deee415e336ecfde3689c9" name="ga14a86ff5b6deee415e336ecfde3689c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14a86ff5b6deee415e336ecfde3689c9">&#9670;&#160;</a></span>ceil() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::ceil </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The ceiling of <code>x</code> is the smallest integer <code>y</code> such that <code>y &gt; x</code>, i.e <code>x</code> rounded up to the nearest integer.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ceiling of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gaa5d99939c5dffc37035e51300236316a" title="Compute the floor of x.">floor</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaeb64b2b465e001720dce40bacec1b937" title="Truncate x to an integer.">trunc</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga58af56b2a9898c045c8ec62ec531c8e5" title="Round x to the nearest integer.">round</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga70024c43f89714b01cc1ff00baa682e0" title="Round x to the nearest integer representable as a long.">lround</a> </dd></dl>

</div>
</div>
<a id="gaac38a0101c9805315f8ba8872ba4d258" name="gaac38a0101c9805315f8ba8872ba4d258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac38a0101c9805315f8ba8872ba4d258">&#9670;&#160;</a></span>clamp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T SDL::clamp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If <code>x</code> is outside the range a values between <code>a</code> and <code>b</code>, the returned value will be <code>a</code> or <code>b</code> as appropriate. Otherwise, <code>x</code> is returned.</p>
<p>This function will produce incorrect results if <code>b</code> is less than <code>a</code>.</p>
<p>This is a helper function that might be more clear than writing out the comparisons directly, and works with any type that can be compared with the <code>&lt;</code> and <code>&gt;</code> operators. However, it double-evaluates all its parameters, so do not use expressions with side-effects here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to compare. </td></tr>
    <tr><td class="paramname">a</td><td>the low end value. </td></tr>
    <tr><td class="paramname">b</td><td>the high end value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x, clamped between a and b.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga476595ece87ed3441c672348366f0adb" name="ga476595ece87ed3441c672348366f0adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga476595ece87ed3441c672348366f0adb">&#9670;&#160;</a></span>copysign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::copysign </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of copysign is that <code>copysign(x, y) = abs(x) * sign(y)</code>.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= f</code></p>
<p>Range: <code>-INF &lt;= z &lt;= INF</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value to use as the magnitude. </td></tr>
    <tr><td class="paramname">y</td><td>floating point value to use as the sign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the floating point value with the sign of y and the magnitude of x.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gab188f3aa930df339c851b95bf2c4030b" title="Compute the absolute value of x.">abs</a> </dd></dl>

</div>
</div>
<a id="ga10134c20bebfe5922fcaefbbcbcaa76d" name="ga10134c20bebfe5922fcaefbbcbcaa76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10134c20bebfe5922fcaefbbcbcaa76d">&#9670;&#160;</a></span>copysign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::copysign </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of copysign is that <code>copysign(x, y) = abs(x) * sign(y)</code>.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= f</code></p>
<p>Range: <code>-INF &lt;= z &lt;= INF</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value to use as the magnitude. </td></tr>
    <tr><td class="paramname">y</td><td>floating point value to use as the sign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the floating point value with the sign of y and the magnitude of x.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gab188f3aa930df339c851b95bf2c4030b" title="Compute the absolute value of x.">abs</a> </dd></dl>

</div>
</div>
<a id="gadf8c80d673a05784387fa5e349a9f6dd" name="gadf8c80d673a05784387fa5e349a9f6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf8c80d673a05784387fa5e349a9f6dd">&#9670;&#160;</a></span>cos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::cos </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-1 &lt;= y &lt;= 1</code></p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value, in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cosine of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga9f6543d319422a6044570b59cc6377b4" title="Compute the arc cosine of x.">acos</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga88bf16c79b920ce54e0ae909b2948663" title="Compute the sine of x.">sin</a> </dd></dl>

</div>
</div>
<a id="ga6ecee7c57e3bee13c46f57de66705aaa" name="ga6ecee7c57e3bee13c46f57de66705aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ecee7c57e3bee13c46f57de66705aaa">&#9670;&#160;</a></span>cos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::cos </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-1 &lt;= y &lt;= 1</code></p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value, in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cosine of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga9f6543d319422a6044570b59cc6377b4" title="Compute the arc cosine of x.">acos</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga88bf16c79b920ce54e0ae909b2948663" title="Compute the sine of x.">sin</a> </dd></dl>

</div>
</div>
<a id="ga31ee6fbdefd2ca34bbde4c8652069e66" name="ga31ee6fbdefd2ca34bbde4c8652069e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31ee6fbdefd2ca34bbde4c8652069e66">&#9670;&#160;</a></span>crc16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint16 SDL::crc16 </td>
          <td>(</td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>crc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">https://en.wikipedia.org/wiki/Cyclic_redundancy_check</a></p>
<p>This function can be called multiple times, to stream data to be checksummed in blocks. Each call must provide the previous CRC-16 return value to be updated with the next block. The first call to this function for a set of blocks should pass in a zero CRC value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crc</td><td>the current checksum for this data set, or 0 for a new data set. </td></tr>
    <tr><td class="paramname">data</td><td>a new block of data to add to the checksum. </td></tr>
    <tr><td class="paramname">len</td><td>the size, in bytes, of the new block of data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a CRC-16 checksum value of all blocks in the data set.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gacc8b8bc6d26dd888c3fed721ddb1cd2e" name="gacc8b8bc6d26dd888c3fed721ddb1cd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc8b8bc6d26dd888c3fed721ddb1cd2e">&#9670;&#160;</a></span>crc32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 SDL::crc32 </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>crc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">https://en.wikipedia.org/wiki/Cyclic_redundancy_check</a></p>
<p>This function can be called multiple times, to stream data to be checksummed in blocks. Each call must provide the previous CRC-32 return value to be updated with the next block. The first call to this function for a set of blocks should pass in a zero CRC value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crc</td><td>the current checksum for this data set, or 0 for a new data set. </td></tr>
    <tr><td class="paramname">data</td><td>a new block of data to add to the checksum. </td></tr>
    <tr><td class="paramname">len</td><td>the size, in bytes, of the new block of data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a CRC-32 checksum value of all blocks in the data set.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga3e4417a78f0393e80fa7645a534a53a3" name="ga3e4417a78f0393e80fa7645a534a53a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e4417a78f0393e80fa7645a534a53a3">&#9670;&#160;</a></span>exp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::exp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of <code>y = exp(x)</code> is <code>y = e^x</code>, where <code>e</code> is the base of the natural logarithm. The inverse is the natural logarithm, <a class="el" href="group__CategoryStdinc.html#ga01c25ea063ceb75d5caf6ca1119a3bc1" title="Compute the natural logarithm of x.">log()</a>.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>0 &lt;= y &lt;= INF</code></p>
<p>The output will overflow if <code>exp(x)</code> is too large to be represented.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of <code>e^x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga01c25ea063ceb75d5caf6ca1119a3bc1" title="Compute the natural logarithm of x.">log</a> </dd></dl>

</div>
</div>
<a id="ga28dae763363f8a8f6ee6cc850dd609e0" name="ga28dae763363f8a8f6ee6cc850dd609e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28dae763363f8a8f6ee6cc850dd609e0">&#9670;&#160;</a></span>exp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::exp </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of <code>y = exp(x)</code> is <code>y = e^x</code>, where <code>e</code> is the base of the natural logarithm. The inverse is the natural logarithm, <a class="el" href="group__CategoryStdinc.html#ga01c25ea063ceb75d5caf6ca1119a3bc1" title="Compute the natural logarithm of x.">log()</a>.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>0 &lt;= y &lt;= INF</code></p>
<p>The output will overflow if <code>exp(x)</code> is too large to be represented.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of <code>e^x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga01c25ea063ceb75d5caf6ca1119a3bc1" title="Compute the natural logarithm of x.">log</a> </dd></dl>

</div>
</div>
<a id="gaa5d99939c5dffc37035e51300236316a" name="gaa5d99939c5dffc37035e51300236316a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5d99939c5dffc37035e51300236316a">&#9670;&#160;</a></span>floor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::floor </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The floor of <code>x</code> is the largest integer <code>y</code> such that <code>y &gt; x</code>, i.e <code>x</code> rounded down to the nearest integer.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the floor of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga1567a1e6b1738fabc6252d7c52f03321" title="Compute the ceiling of x.">ceil</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaeb64b2b465e001720dce40bacec1b937" title="Truncate x to an integer.">trunc</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga58af56b2a9898c045c8ec62ec531c8e5" title="Round x to the nearest integer.">round</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga70024c43f89714b01cc1ff00baa682e0" title="Round x to the nearest integer representable as a long.">lround</a> </dd></dl>

</div>
</div>
<a id="ga93fb9063f992d37b5163a32f0e952998" name="ga93fb9063f992d37b5163a32f0e952998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93fb9063f992d37b5163a32f0e952998">&#9670;&#160;</a></span>floor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::floor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The floor of <code>x</code> is the largest integer <code>y</code> such that <code>y &gt; x</code>, i.e <code>x</code> rounded down to the nearest integer.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the floor of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga1567a1e6b1738fabc6252d7c52f03321" title="Compute the ceiling of x.">ceil</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaeb64b2b465e001720dce40bacec1b937" title="Truncate x to an integer.">trunc</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga58af56b2a9898c045c8ec62ec531c8e5" title="Round x to the nearest integer.">round</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga70024c43f89714b01cc1ff00baa682e0" title="Round x to the nearest integer representable as a long.">lround</a> </dd></dl>

</div>
</div>
<a id="gafcd6b0192bc061852ef8ef56272bf98d" name="gafcd6b0192bc061852ef8ef56272bf98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcd6b0192bc061852ef8ef56272bf98d">&#9670;&#160;</a></span>fmod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::fmod </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divides <code>x</code> by <code>y</code>, and returns the remainder.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= INF</code>, <code>y != 0</code></p>
<p>Range: <code>-y &lt;= z &lt;= y</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the numerator. </td></tr>
    <tr><td class="paramname">y</td><td>the denominator. Must not be 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the remainder of <code>x / y</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga4c97858f63954904f2037d7bc81b2681" title="Split x into integer and fractional parts.">modf</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaeb64b2b465e001720dce40bacec1b937" title="Truncate x to an integer.">trunc</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga1567a1e6b1738fabc6252d7c52f03321" title="Compute the ceiling of x.">ceil</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaa5d99939c5dffc37035e51300236316a" title="Compute the floor of x.">floor</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga58af56b2a9898c045c8ec62ec531c8e5" title="Round x to the nearest integer.">round</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga70024c43f89714b01cc1ff00baa682e0" title="Round x to the nearest integer representable as a long.">lround</a> </dd></dl>

</div>
</div>
<a id="gabcca080a3eb842e163500d93841db224" name="gabcca080a3eb842e163500d93841db224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcca080a3eb842e163500d93841db224">&#9670;&#160;</a></span>fmod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::fmod </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divides <code>x</code> by <code>y</code>, and returns the remainder.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= INF</code>, <code>y != 0</code></p>
<p>Range: <code>-y &lt;= z &lt;= y</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the numerator. </td></tr>
    <tr><td class="paramname">y</td><td>the denominator. Must not be 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the remainder of <code>x / y</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gaeb64b2b465e001720dce40bacec1b937" title="Truncate x to an integer.">trunc</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga4c97858f63954904f2037d7bc81b2681" title="Split x into integer and fractional parts.">modf</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga1567a1e6b1738fabc6252d7c52f03321" title="Compute the ceiling of x.">ceil</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaa5d99939c5dffc37035e51300236316a" title="Compute the floor of x.">floor</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga58af56b2a9898c045c8ec62ec531c8e5" title="Round x to the nearest integer.">round</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga70024c43f89714b01cc1ff00baa682e0" title="Round x to the nearest integer representable as a long.">lround</a> </dd></dl>

</div>
</div>
<a id="gaa932b3872f6162d7257c924b184e5381" name="gaa932b3872f6162d7257c924b184e5381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa932b3872f6162d7257c924b184e5381">&#9670;&#160;</a></span>FourCC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Uint32 SDL::FourCC </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first ASCII character. </td></tr>
    <tr><td class="paramname">b</td><td>the second ASCII character. </td></tr>
    <tr><td class="paramname">c</td><td>the third ASCII character. </td></tr>
    <tr><td class="paramname">d</td><td>the fourth ASCII character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the four characters converted into a Uint32, one character per-byte.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this macro from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gadfa01257ca1f966fffb72f002db27fa6" name="gadfa01257ca1f966fffb72f002db27fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfa01257ca1f966fffb72f002db27fa6">&#9670;&#160;</a></span>free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The pointer is no longer valid after this call and cannot be dereferenced anymore.</p>
<p>If <code>mem</code> is nullptr, this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>a pointer to allocated memory, or nullptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga48fe5521cb77ff8e4ae442bc8387be70" title="Allocate uninitialized memory.">malloc</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gab24b3e9482f5a1c26602b83f2de05d09" title="Allocate a zero-initialized array.">calloc</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gab8208c1b381e6a96b07b5facff79c27b" title="Change the size of allocated memory.">realloc</a> </dd></dl>

</div>
</div>
<a id="ga97502b219bb63f4be0f31868fecc9120" name="ga97502b219bb63f4be0f31868fecc9120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97502b219bb63f4be0f31868fecc9120">&#9670;&#160;</a></span>getenv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * SDL::getenv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function uses <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a>'s cached copy of the environment and is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the variable to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the value of the variable or nullptr if it can't be found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga8a55c001e123a53e424cbc460ec4b1b6" name="ga8a55c001e123a53e424cbc460ec4b1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a55c001e123a53e424cbc460ec4b1b6">&#9670;&#160;</a></span>getenv_unsafe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * SDL::getenv_unsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function bypasses <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a>'s cached copy of the environment and is not thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the variable to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the value of the variable or nullptr if it can't be found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe, consider using <a class="el" href="group__CategoryStdinc.html#ga97502b219bb63f4be0f31868fecc9120" title="Get the value of a variable in the environment.">getenv()</a> instead.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga97502b219bb63f4be0f31868fecc9120" title="Get the value of a variable in the environment.">getenv</a> </dd></dl>

</div>
</div>
<a id="gafc9e4411ee1c8072c58cbfa0566a5660" name="gafc9e4411ee1c8072c58cbfa0566a5660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc9e4411ee1c8072c58cbfa0566a5660">&#9670;&#160;</a></span>GetEnvironment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSDL_1_1EnvironmentRef.html">EnvironmentRef</a> SDL::GetEnvironment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is initialized at application start and is not affected by setenv() and unsetenv() calls after that point. Use <a class="el" href="structSDL_1_1EnvironmentRef.html#ae1f456248fc1c89c2c486671d75d25c8" title="Set the value of a variable in the environment.">EnvironmentRef.SetVariable()</a> and <a class="el" href="structSDL_1_1EnvironmentRef.html#a2b6d72ef09306d457e4a4ee1e8a114d9" title="Clear a variable from the environment.">EnvironmentRef.UnsetVariable()</a> if you want to modify this environment, or <a class="el" href="group__CategoryStdinc.html#ga97da5abe6c940c70b73fc9465cf8e75e" title="Set the value of a variable in the environment.">setenv_unsafe()</a> or <a class="el" href="group__CategoryStdinc.html#ga7dc726179e2ae431d7db8164099e333a" title="Clear a variable from the environment.">unsetenv_unsafe()</a> if you want changes to persist in the C runtime environment after <a class="el" href="group__CategoryInit.html#gac0812d3287da34e3d6b228677440a24c" title="Clean up all initialized subsystems.">Quit()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the environment for the process or nullptr on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1EnvironmentRef.html#af38b4128673800ba9e46e954a9b38998" title="Get the value of a variable in the environment.">EnvironmentRef.GetVariable</a> </dd>
<dd>
<a class="el" href="structSDL_1_1EnvironmentRef.html#ab6a4e611b554cb8b580bccfb33596e05" title="Get all variables in the environment.">EnvironmentRef.GetVariables</a> </dd>
<dd>
<a class="el" href="structSDL_1_1EnvironmentRef.html#ae1f456248fc1c89c2c486671d75d25c8" title="Set the value of a variable in the environment.">EnvironmentRef.SetVariable</a> </dd>
<dd>
<a class="el" href="structSDL_1_1EnvironmentRef.html#a2b6d72ef09306d457e4a4ee1e8a114d9" title="Clear a variable from the environment.">EnvironmentRef.UnsetVariable</a> </dd></dl>

</div>
</div>
<a id="gab331691e9cf41b2fd9063b80910ea6b0" name="gab331691e9cf41b2fd9063b80910ea6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab331691e9cf41b2fd9063b80910ea6b0">&#9670;&#160;</a></span>GetMemoryFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GetMemoryFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a> *&#160;</td>
          <td class="paramname"><em>malloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a> *&#160;</td>
          <td class="paramname"><em>calloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a> *&#160;</td>
          <td class="paramname"><em>realloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a> *&#160;</td>
          <td class="paramname"><em>free_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">malloc_func</td><td>filled with malloc function. </td></tr>
    <tr><td class="paramname">calloc_func</td><td>filled with calloc function. </td></tr>
    <tr><td class="paramname">realloc_func</td><td>filled with realloc function. </td></tr>
    <tr><td class="paramname">free_func</td><td>filled with free function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This does not hold a lock, so do not call this in the unlikely event of a background thread calling SetMemoryFunctions simultaneously.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga048ad88f068e4b9b9f81703377d3d1a9" title="Replace SDL&#39;s memory allocation functions with a custom set.">SetMemoryFunctions</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga6325f645ab936554e7aaa2e4d977d9d7" title="Get the original set of SDL memory functions.">GetOriginalMemoryFunctions</a> </dd></dl>

</div>
</div>
<a id="gae51ea510815eaec3a9b288754a805206" name="gae51ea510815eaec3a9b288754a805206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae51ea510815eaec3a9b288754a805206">&#9670;&#160;</a></span>GetNumAllocations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::GetNumAllocations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of allocations or -1 if allocation counting is disabled.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga6325f645ab936554e7aaa2e4d977d9d7" name="ga6325f645ab936554e7aaa2e4d977d9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6325f645ab936554e7aaa2e4d977d9d7">&#9670;&#160;</a></span>GetOriginalMemoryFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GetOriginalMemoryFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a> *&#160;</td>
          <td class="paramname"><em>malloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a> *&#160;</td>
          <td class="paramname"><em>calloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a> *&#160;</td>
          <td class="paramname"><em>realloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a> *&#160;</td>
          <td class="paramname"><em>free_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is what malloc and friends will use by default, if there has been no call to SetMemoryFunctions. This is not necessarily using the C runtime's <code>malloc</code> functions behind the scenes! Different platforms and build configurations might do any number of unexpected things.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">malloc_func</td><td>filled with malloc function. </td></tr>
    <tr><td class="paramname">calloc_func</td><td>filled with calloc function. </td></tr>
    <tr><td class="paramname">realloc_func</td><td>filled with realloc function. </td></tr>
    <tr><td class="paramname">free_func</td><td>filled with free function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gae765b6ec212ab3234f6645eb3c53978a" name="gae765b6ec212ab3234f6645eb3c53978a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae765b6ec212ab3234f6645eb3c53978a">&#9670;&#160;</a></span>iconv_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategoryOwnPtr.html#gad344fd7da4e765054e86e182363639c7">OwnPtr</a>&lt; char &gt; SDL::iconv_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>tocode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>fromcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>inbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inbytesleft</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function converts a buffer or string between encodings in one pass.</p>
<p>The string does not need to be nullptr-terminated; this function operates on the number of bytes specified in <code>inbytesleft</code> whether there is a nullptr character anywhere in the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tocode</td><td>the character encoding of the output string. Examples are "UTF-8", "UCS-4", etc. </td></tr>
    <tr><td class="paramname">fromcode</td><td>the character encoding of data in <code>inbuf</code>. </td></tr>
    <tr><td class="paramname">inbuf</td><td>the string to convert to a different encoding. </td></tr>
    <tr><td class="paramname">inbytesleft</td><td>the size of the input string <em>in bytes</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new string, converted to the new encoding, or nullptr on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1IConvRef.html#a4cf6627b23a7b24a7b7dfda30e8426a7" title="Copy constructor.">IConvRef.IConvRef</a> </dd>
<dd>
<a class="el" href="structSDL_1_1IConvRef.html#a1986bf1e484c1388ea3508010b7cb763" title="This function converts text between encodings, reading from and writing to a buffer.">IConvRef.iconv</a> </dd></dl>

</div>
</div>
<a id="gafc3565e81c3ab6ba0e66f9030c056969" name="gafc3565e81c3ab6ba0e66f9030c056969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc3565e81c3ab6ba0e66f9030c056969">&#9670;&#160;</a></span>isalnum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isalnum </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values for English 'a-z', 'A-Z', and '0-9' as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga79256765fa0f219b5947721d1d920041" name="ga79256765fa0f219b5947721d1d920041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79256765fa0f219b5947721d1d920041">&#9670;&#160;</a></span>isalpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isalpha </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values for English 'a-z' and 'A-Z' as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gab6936f2d259cb2959c3d73e8bb66cf0d" name="gab6936f2d259cb2959c3d73e8bb66cf0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6936f2d259cb2959c3d73e8bb66cf0d">&#9670;&#160;</a></span>isblank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isblank </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values 0x20 (space) or 0x9 (tab) as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga901f942513d4469f8722185f0cee85bd" name="ga901f942513d4469f8722185f0cee85bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga901f942513d4469f8722185f0cee85bd">&#9670;&#160;</a></span>iscntrl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::iscntrl </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values 0 through 0x1F, and 0x7F, as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga3c4d5430375fa896b58aa1e5a23cd30f" name="ga3c4d5430375fa896b58aa1e5a23cd30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c4d5430375fa896b58aa1e5a23cd30f">&#9670;&#160;</a></span>isdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isdigit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values '0' (0x30) through '9' (0x39), as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga28e4c655a653424f510993ddec5b02b4" name="ga28e4c655a653424f510993ddec5b02b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28e4c655a653424f510993ddec5b02b4">&#9670;&#160;</a></span>isgraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isgraph </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Be advised that "printable" has a definition that goes back to text terminals from the dawn of computing, making this a sort of special case function that is not suitable for Unicode (or most any) text management.</p>
<p><b>WARNING</b>: Regardless of system locale, this is equivalent to &lsquo;(isprint(x)) &amp;&amp; ((x) != &rsquo; ')`.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga6ff81eceb17060ed3c3c7c32a14bf7b8" title="Report if a character is &quot;printable&quot;.">isprint</a> </dd></dl>

</div>
</div>
<a id="ga918f0e70e6e67f724c445eba4b514a21" name="ga918f0e70e6e67f724c445eba4b514a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga918f0e70e6e67f724c445eba4b514a21">&#9670;&#160;</a></span>isinf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isinf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>double-precision floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if the value is infinity, 0 otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gab688d31019c357f1b5c24ce2fcc598cb" name="gab688d31019c357f1b5c24ce2fcc598cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab688d31019c357f1b5c24ce2fcc598cb">&#9670;&#160;</a></span>isinf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isinf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if the value is infinity, 0 otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga9154645a2881fcb9f6c1df5c4d848ef1" name="ga9154645a2881fcb9f6c1df5c4d848ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9154645a2881fcb9f6c1df5c4d848ef1">&#9670;&#160;</a></span>islower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::islower </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values 'a' through 'z' as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga2221269e7ded0fb89af37aea9132e0b8" name="ga2221269e7ded0fb89af37aea9132e0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2221269e7ded0fb89af37aea9132e0b8">&#9670;&#160;</a></span>isnan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isnan </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>double-precision floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if the value is NaN, 0 otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga4da556b52f202a3e9dcb506033ee86f3" name="ga4da556b52f202a3e9dcb506033ee86f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4da556b52f202a3e9dcb506033ee86f3">&#9670;&#160;</a></span>isnan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isnan </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if the value is NaN, 0 otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga6ff81eceb17060ed3c3c7c32a14bf7b8" name="ga6ff81eceb17060ed3c3c7c32a14bf7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ff81eceb17060ed3c3c7c32a14bf7b8">&#9670;&#160;</a></span>isprint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isprint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Be advised that "printable" has a definition that goes back to text terminals from the dawn of computing, making this a sort of special case function that is not suitable for Unicode (or most any) text management.</p>
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values ' ' (0x20) through '~' (0x7E) as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gac1876da5600f8722288dc8641d978fab" name="gac1876da5600f8722288dc8641d978fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1876da5600f8722288dc8641d978fab">&#9670;&#160;</a></span>ispunct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::ispunct </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this is equivalent to <code>((isgraph(x)) &amp;&amp; (!isalnum(x)))</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga28e4c655a653424f510993ddec5b02b4" title="Report if a character is any &quot;printable&quot; except space.">isgraph</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gafc3565e81c3ab6ba0e66f9030c056969" title="Query if a character is alphabetic (a letter) or a number.">isalnum</a> </dd></dl>

</div>
</div>
<a id="ga922904215a42f639a8385470d5e61667" name="ga922904215a42f639a8385470d5e61667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga922904215a42f639a8385470d5e61667">&#9670;&#160;</a></span>isspace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isspace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only treat the following ASCII values as true:</p>
<ul>
<li>space (0x20)</li>
<li>tab (0x09)</li>
<li>newline (0x0A)</li>
<li>vertical tab (0x0B)</li>
<li>form feed (0x0C)</li>
<li>return (0x0D)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga83e29996414dc34dd0fb76a16669f05f" name="ga83e29996414dc34dd0fb76a16669f05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83e29996414dc34dd0fb76a16669f05f">&#9670;&#160;</a></span>isupper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isupper </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values 'A' through 'Z' as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga73d02f4f146603a906c35d50197f6fd6" name="ga73d02f4f146603a906c35d50197f6fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73d02f4f146603a906c35d50197f6fd6">&#9670;&#160;</a></span>isxdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isxdigit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values 'A' through 'F', 'a' through 'f', and '0' through '9', as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gac0d19dc9f116d9f492fd4d17296f0c4b" name="gac0d19dc9f116d9f492fd4d17296f0c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0d19dc9f116d9f492fd4d17296f0c4b">&#9670;&#160;</a></span>itoa()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::itoa </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This requires a radix to specified for string format. Specifying 10 produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2 to 36.</p>
<p>Note that this function will overflow a buffer if <code>str</code> is not large enough to hold the output! It may be safer to use snprintf to clamp output, or asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate much more space than you expect to use (and don't forget possible negative signs, null terminator bytes, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the integer to convert. </td></tr>
    <tr><td class="paramname">str</td><td>the buffer to write the string into. </td></tr>
    <tr><td class="paramname">radix</td><td>the radix to use for string generation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>str</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga6ca0851c2d9980695748c979e2d15608" title="Convert an unsigned integer into a string.">uitoa</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaee263ca33e533bf8acdd33b20e2323cf" title="Convert a long integer into a string.">ltoa</a> </dd>
<dd>
SDL_lltoa </dd></dl>

</div>
</div>
<a id="ga01c25ea063ceb75d5caf6ca1119a3bc1" name="ga01c25ea063ceb75d5caf6ca1119a3bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01c25ea063ceb75d5caf6ca1119a3bc1">&#9670;&#160;</a></span>log() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::log </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>0 &lt; x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<p>It is an error for <code>x</code> to be less than or equal to 0.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. Must be greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the natural logarithm of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gacdf9d94c27153da5d01b604342b49024" title="Compute the base-10 logarithm of x.">log10</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga3e4417a78f0393e80fa7645a534a53a3" title="Compute the exponential of x.">exp</a> </dd></dl>

</div>
</div>
<a id="gabd852bed14a8611cd305ede0abfcf2f3" name="gabd852bed14a8611cd305ede0abfcf2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd852bed14a8611cd305ede0abfcf2f3">&#9670;&#160;</a></span>log() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::log </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>0 &lt; x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<p>It is an error for <code>x</code> to be less than or equal to 0.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. Must be greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the natural logarithm of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gacdf9d94c27153da5d01b604342b49024" title="Compute the base-10 logarithm of x.">log10</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga3e4417a78f0393e80fa7645a534a53a3" title="Compute the exponential of x.">exp</a> </dd></dl>

</div>
</div>
<a id="gacdf9d94c27153da5d01b604342b49024" name="gacdf9d94c27153da5d01b604342b49024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdf9d94c27153da5d01b604342b49024">&#9670;&#160;</a></span>log10() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::log10 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>0 &lt; x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<p>It is an error for <code>x</code> to be less than or equal to 0.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. Must be greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the logarithm of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga01c25ea063ceb75d5caf6ca1119a3bc1" title="Compute the natural logarithm of x.">log</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga6cfca7e593d97a56d7fca043af3ac2ce" title="Raise x to the power y">pow</a> </dd></dl>

</div>
</div>
<a id="ga469bfdfde9d6d0a1193cf60f4cc4ab73" name="ga469bfdfde9d6d0a1193cf60f4cc4ab73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga469bfdfde9d6d0a1193cf60f4cc4ab73">&#9670;&#160;</a></span>log10() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::log10 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>0 &lt; x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<p>It is an error for <code>x</code> to be less than or equal to 0.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. Must be greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the logarithm of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga01c25ea063ceb75d5caf6ca1119a3bc1" title="Compute the natural logarithm of x.">log</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga6cfca7e593d97a56d7fca043af3ac2ce" title="Raise x to the power y">pow</a> </dd></dl>

</div>
</div>
<a id="ga70024c43f89714b01cc1ff00baa682e0" name="ga70024c43f89714b01cc1ff00baa682e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70024c43f89714b01cc1ff00baa682e0">&#9670;&#160;</a></span>lround() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long SDL::lround </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rounds <code>x</code> to the nearest integer. Values halfway between integers will be rounded away from zero.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>MIN_LONG &lt;= y &lt;= MAX_LONG</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nearest integer to <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga58af56b2a9898c045c8ec62ec531c8e5" title="Round x to the nearest integer.">round</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaa5d99939c5dffc37035e51300236316a" title="Compute the floor of x.">floor</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga1567a1e6b1738fabc6252d7c52f03321" title="Compute the ceiling of x.">ceil</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaeb64b2b465e001720dce40bacec1b937" title="Truncate x to an integer.">trunc</a> </dd></dl>

</div>
</div>
<a id="gae3e2740784189b12f7e3bd55d125827b" name="gae3e2740784189b12f7e3bd55d125827b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3e2740784189b12f7e3bd55d125827b">&#9670;&#160;</a></span>lround() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long SDL::lround </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rounds <code>x</code> to the nearest integer. Values halfway between integers will be rounded away from zero.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>MIN_LONG &lt;= y &lt;= MAX_LONG</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nearest integer to <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga58af56b2a9898c045c8ec62ec531c8e5" title="Round x to the nearest integer.">round</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaa5d99939c5dffc37035e51300236316a" title="Compute the floor of x.">floor</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga1567a1e6b1738fabc6252d7c52f03321" title="Compute the ceiling of x.">ceil</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaeb64b2b465e001720dce40bacec1b937" title="Truncate x to an integer.">trunc</a> </dd></dl>

</div>
</div>
<a id="gaee263ca33e533bf8acdd33b20e2323cf" name="gaee263ca33e533bf8acdd33b20e2323cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee263ca33e533bf8acdd33b20e2323cf">&#9670;&#160;</a></span>ltoa()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::ltoa </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This requires a radix to specified for string format. Specifying 10 produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2 to 36.</p>
<p>Note that this function will overflow a buffer if <code>str</code> is not large enough to hold the output! It may be safer to use snprintf to clamp output, or asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate much more space than you expect to use (and don't forget possible negative signs, null terminator bytes, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the long integer to convert. </td></tr>
    <tr><td class="paramname">str</td><td>the buffer to write the string into. </td></tr>
    <tr><td class="paramname">radix</td><td>the radix to use for string generation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>str</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga2450290efea2bebff1f164a6c4a04d38" title="Convert an unsigned long integer into a string.">ultoa</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gac0d19dc9f116d9f492fd4d17296f0c4b" title="Convert an integer into a string.">itoa</a> </dd>
<dd>
SDL_lltoa </dd></dl>

</div>
</div>
<a id="ga48fe5521cb77ff8e4ae442bc8387be70" name="ga48fe5521cb77ff8e4ae442bc8387be70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48fe5521cb77ff8e4ae442bc8387be70">&#9670;&#160;</a></span>malloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The allocated memory returned by this function must be freed with <a class="el" href="group__CategoryStdinc.html#gadfa01257ca1f966fffb72f002db27fa6" title="Free allocated memory.">free()</a>.</p>
<p>If <code>size</code> is 0, it will be set to 1.</p>
<p>If the allocation is successful, the returned pointer is guaranteed to be aligned to either the <em>fundamental alignment</em> (<code>alignof(max_align_t)</code> in C11 and later) or <code>2 * sizeof(void *)</code>, whichever is smaller. Use <a class="el" href="group__CategoryStdinc.html#gae3c9f70ddeadaecb2afeee2b3be34733" title="Allocate memory aligned to a specific alignment.">aligned_alloc()</a> if you need to allocate memory aligned to an alignment greater than this guarantee.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the size to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory, or nullptr if allocation failed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gadfa01257ca1f966fffb72f002db27fa6" title="Free allocated memory.">free</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gab24b3e9482f5a1c26602b83f2de05d09" title="Allocate a zero-initialized array.">calloc</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gab8208c1b381e6a96b07b5facff79c27b" title="Change the size of allocated memory.">realloc</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gae3c9f70ddeadaecb2afeee2b3be34733" title="Allocate memory aligned to a specific alignment.">aligned_alloc</a> </dd></dl>

</div>
</div>
<a id="ga74fda1cb69f4e000dc8a42aba05136a0" name="ga74fda1cb69f4e000dc8a42aba05136a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74fda1cb69f4e000dc8a42aba05136a0">&#9670;&#160;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T SDL::max </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a helper function that might be more clear than writing out the comparisons directly, and works with any type that can be compared with the <code>&gt;</code> operator. However, it double-evaluates both its parameters, so do not use expressions with side-effects here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the first value to compare. </td></tr>
    <tr><td class="paramname">y</td><td>the second value to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the lesser of <code>x</code> and <code>y</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga1713911979192a927ee8202ad4ed478b" name="ga1713911979192a927ee8202ad4ed478b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1713911979192a927ee8202ad4ed478b">&#9670;&#160;</a></span>memcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::memcmp </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>the first buffer to compare. nullptr is not permitted! </td></tr>
    <tr><td class="paramname">s2</td><td>the second buffer to compare. nullptr is not permitted! </td></tr>
    <tr><td class="paramname">len</td><td>the number of bytes to compare between the buffers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if s1 is "less than" s2, greater than zero if s1 is "greater than" s2, and zero if the buffers match exactly for <code>len</code> bytes.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gafe27508f0dcd3fb7902725b46f1c7e15" name="gafe27508f0dcd3fb7902725b46f1c7e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe27508f0dcd3fb7902725b46f1c7e15">&#9670;&#160;</a></span>memcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The memory regions must not overlap. If they do, use <a class="el" href="group__CategoryStdinc.html#ga166c29b5162d190b0002720452a5ef43" title="Copy memory ranges that might overlap.">memmove()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination memory region. Must not be nullptr, and must not overlap with <code>src</code>. </td></tr>
    <tr><td class="paramname">src</td><td>The source memory region. Must not be nullptr, and must not overlap with <code>dst</code>. </td></tr>
    <tr><td class="paramname">len</td><td>The length in bytes of both <code>dst</code> and <code>src</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>dst</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga166c29b5162d190b0002720452a5ef43" title="Copy memory ranges that might overlap.">memmove</a> </dd></dl>

</div>
</div>
<a id="ga166c29b5162d190b0002720452a5ef43" name="ga166c29b5162d190b0002720452a5ef43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga166c29b5162d190b0002720452a5ef43">&#9670;&#160;</a></span>memmove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::memmove </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>It is okay for the memory regions to overlap. If you are confident that the regions never overlap, using <a class="el" href="group__CategoryStdinc.html#gafe27508f0dcd3fb7902725b46f1c7e15" title="Copy non-overlapping memory.">memcpy()</a> may improve performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination memory region. Must not be nullptr. </td></tr>
    <tr><td class="paramname">src</td><td>The source memory region. Must not be nullptr. </td></tr>
    <tr><td class="paramname">len</td><td>The length in bytes of both <code>dst</code> and <code>src</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>dst</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gafe27508f0dcd3fb7902725b46f1c7e15" title="Copy non-overlapping memory.">memcpy</a> </dd></dl>

</div>
</div>
<a id="ga5a6487beb5a07d1110c8afe1fe030446" name="ga5a6487beb5a07d1110c8afe1fe030446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a6487beb5a07d1110c8afe1fe030446">&#9670;&#160;</a></span>memset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will set <code>len</code> bytes, pointed to by <code>dst</code>, to the value specified in <code>c</code>.</p>
<p>Despite <code>c</code> being an <code>int</code> instead of a <code>char</code>, this only operates on bytes; <code>c</code> must be a value between 0 and 255, inclusive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>the destination memory region. Must not be nullptr. </td></tr>
    <tr><td class="paramname">c</td><td>the byte value to set. </td></tr>
    <tr><td class="paramname">len</td><td>the length, in bytes, to set in <code>dst</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>dst</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga8e06e75cea4ef203bf1f3c967f8bff54" name="ga8e06e75cea4ef203bf1f3c967f8bff54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e06e75cea4ef203bf1f3c967f8bff54">&#9670;&#160;</a></span>memset4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::memset4 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dwords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will set a buffer of <code>dwords</code> Uint32 values, pointed to by <code>dst</code>, to the value specified in <code>val</code>.</p>
<p>Unlike memset, this sets 32-bit values, not bytes, so it's not limited to a range of 0-255.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>the destination memory region. Must not be nullptr. </td></tr>
    <tr><td class="paramname">val</td><td>the Uint32 value to set. </td></tr>
    <tr><td class="paramname">dwords</td><td>the number of Uint32 values to set in <code>dst</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>dst</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga37591dc3dcb6bb89de19a61acdec4ef3" name="ga37591dc3dcb6bb89de19a61acdec4ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37591dc3dcb6bb89de19a61acdec4ef3">&#9670;&#160;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T SDL::min </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a helper macro that might be more clear than writing out the comparisons directly, and works with any type that can be compared with the <code>&lt;</code> operator. However, it double-evaluates both its parameters, so do not use expressions with side-effects here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the first value to compare. </td></tr>
    <tr><td class="paramname">y</td><td>the second value to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the lesser of <code>x</code> and <code>y</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga4c97858f63954904f2037d7bc81b2681" name="ga4c97858f63954904f2037d7bc81b2681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c97858f63954904f2037d7bc81b2681">&#9670;&#160;</a></span>modf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::modf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
    <tr><td class="paramname">y</td><td>output pointer to store the integer part of <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the fractional part of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gaeb64b2b465e001720dce40bacec1b937" title="Truncate x to an integer.">trunc</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gafcd6b0192bc061852ef8ef56272bf98d" title="Return the floating-point remainder of x / y">fmod</a> </dd></dl>

</div>
</div>
<a id="ga5a30a1c10942df28de78ce3f482dec53" name="ga5a30a1c10942df28de78ce3f482dec53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a30a1c10942df28de78ce3f482dec53">&#9670;&#160;</a></span>modf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::modf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
    <tr><td class="paramname">y</td><td>output pointer to store the integer part of <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the fractional part of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gaeb64b2b465e001720dce40bacec1b937" title="Truncate x to an integer.">trunc</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gafcd6b0192bc061852ef8ef56272bf98d" title="Return the floating-point remainder of x / y">fmod</a> </dd></dl>

</div>
</div>
<a id="gaa75ce9d0d0b590cd55fce1604bb40824" name="gaa75ce9d0d0b590cd55fce1604bb40824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa75ce9d0d0b590cd55fce1604bb40824">&#9670;&#160;</a></span>murmur3_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 SDL::murmur3_32 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a href="https://en.wikipedia.org/wiki/MurmurHash">https://en.wikipedia.org/wiki/MurmurHash</a></p>
<p>A seed may be specified, which changes the final results consistently, but this does not work like crc16 and crc32: you can't feed a previous result from this function back into itself as the next seed value to calculate a hash in chunks; it won't produce the same hash as it would if the same data was provided in a single call.</p>
<p>If you aren't sure what to provide for a seed, zero is fine. Murmur3 is not cryptographically secure, so it shouldn't be used for hashing top-secret data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the data to be hashed. </td></tr>
    <tr><td class="paramname">len</td><td>the size of data, in bytes. </td></tr>
    <tr><td class="paramname">seed</td><td>a value that alters the final hash value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a Murmur3 32-bit hash value.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga6cfca7e593d97a56d7fca043af3ac2ce" name="ga6cfca7e593d97a56d7fca043af3ac2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cfca7e593d97a56d7fca043af3ac2ce">&#9670;&#160;</a></span>pow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::pow </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= z &lt;= INF</code></p>
<p>If <code>y</code> is the base of the natural logarithm (e), consider using exp instead.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the base. </td></tr>
    <tr><td class="paramname">y</td><td>the exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> raised to the power <code>y</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga3e4417a78f0393e80fa7645a534a53a3" title="Compute the exponential of x.">exp</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga01c25ea063ceb75d5caf6ca1119a3bc1" title="Compute the natural logarithm of x.">log</a> </dd></dl>

</div>
</div>
<a id="gac3b22877237dc964d05f19e5d7c93659" name="gac3b22877237dc964d05f19e5d7c93659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3b22877237dc964d05f19e5d7c93659">&#9670;&#160;</a></span>pow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::pow </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= z &lt;= INF</code></p>
<p>If <code>y</code> is the base of the natural logarithm (e), consider using exp instead.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the base. </td></tr>
    <tr><td class="paramname">y</td><td>the exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> raised to the power <code>y</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga3e4417a78f0393e80fa7645a534a53a3" title="Compute the exponential of x.">exp</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga01c25ea063ceb75d5caf6ca1119a3bc1" title="Compute the natural logarithm of x.">log</a> </dd></dl>

</div>
</div>
<a id="gab52a0ec3d96fb4c04972b1b322f75857" name="gab52a0ec3d96fb4c04972b1b322f75857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab52a0ec3d96fb4c04972b1b322f75857">&#9670;&#160;</a></span>qsort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::qsort </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gabc94be94823c25031d6dd9210ef3e81a">CompareCallback</a>&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For example:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *string;</div>
<div class="line">} data;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> SDLCALL compare(<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> data *A = (<span class="keyword">const</span> data *)a;</div>
<div class="line">    <span class="keyword">const</span> data *B = (<span class="keyword">const</span> data *)b;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (A-&gt;n &lt; B-&gt;n) {</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (B-&gt;n &lt; A-&gt;n) {</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">data values[] = {</div>
<div class="line">    { 3, <span class="stringliteral">&quot;third&quot;</span> }, { 1, <span class="stringliteral">&quot;first&quot;</span> }, { 2, <span class="stringliteral">&quot;second&quot;</span> }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__CategoryStdinc.html#gab52a0ec3d96fb4c04972b1b322f75857">qsort</a>(values, <a class="code hl_function" href="group__CategoryStdinc.html#ga20b4cc6c53a1dbd7789ee90af065b5f9">arraysize</a>(values), <span class="keyword">sizeof</span>(values[0]), compare);</div>
<div class="ttc" id="agroup__CategoryStdinc_html_gab52a0ec3d96fb4c04972b1b322f75857"><div class="ttname"><a href="group__CategoryStdinc.html#gab52a0ec3d96fb4c04972b1b322f75857">SDL::qsort</a></div><div class="ttdeci">void qsort(void *base, size_t nmemb, size_t size, CompareCallback compare)</div><div class="ttdoc">Sort an array.</div><div class="ttdef"><b>Definition</b> SDL3pp_stdinc.h:1177</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>a pointer to the start of the array. </td></tr>
    <tr><td class="paramname">nmemb</td><td>the number of elements in the array. </td></tr>
    <tr><td class="paramname">size</td><td>the size of the elements in the array. </td></tr>
    <tr><td class="paramname">compare</td><td>a function used to compare elements in the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gada62aea13b8eceffa3e57359e124e541" title="Perform a binary search on a previously sorted array.">bsearch</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaa3b0083aa5cb6236224048d437834dd2" title="Sort an array, passing a userdata pointer to the compare function.">qsort_r</a> </dd></dl>

</div>
</div>
<a id="gaa3b0083aa5cb6236224048d437834dd2" name="gaa3b0083aa5cb6236224048d437834dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3b0083aa5cb6236224048d437834dd2">&#9670;&#160;</a></span>qsort_r() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::qsort_r </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gab5c634ea2ae9a102fa58cd7beac9f478">CompareCallback_r</a>&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For example:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> {</div>
<div class="line">    sort_increasing,</div>
<div class="line">    sort_decreasing,</div>
<div class="line">} sort_method;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *string;</div>
<div class="line">} data;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> SDLCALL compare(<span class="keyword">const</span> <span class="keywordtype">void</span> *userdata, <span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)</div>
<div class="line">{</div>
<div class="line">    sort_method method = (sort_method)(uintptr_t)userdata;</div>
<div class="line">    <span class="keyword">const</span> data *A = (<span class="keyword">const</span> data *)a;</div>
<div class="line">    <span class="keyword">const</span> data *B = (<span class="keyword">const</span> data *)b;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (A-&gt;key &lt; B-&gt;key) {</div>
<div class="line">        <span class="keywordflow">return</span> (method == sort_increasing) ? -1 : 1;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (B-&gt;key &lt; A-&gt;key) {</div>
<div class="line">        <span class="keywordflow">return</span> (method == sort_increasing) ? 1 : -1;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">data values[] = {</div>
<div class="line">    { 3, <span class="stringliteral">&quot;third&quot;</span> }, { 1, <span class="stringliteral">&quot;first&quot;</span> }, { 2, <span class="stringliteral">&quot;second&quot;</span> }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__CategoryStdinc.html#gaa3b0083aa5cb6236224048d437834dd2">qsort_r</a>(values, <a class="code hl_function" href="group__CategoryStdinc.html#ga20b4cc6c53a1dbd7789ee90af065b5f9">arraysize</a>(values), <span class="keyword">sizeof</span>(values[0]), compare, (<span class="keyword">const</span> <span class="keywordtype">void</span></div>
<div class="line">*)(uintptr_t)sort_increasing);</div>
<div class="ttc" id="agroup__CategoryStdinc_html_gaa3b0083aa5cb6236224048d437834dd2"><div class="ttname"><a href="group__CategoryStdinc.html#gaa3b0083aa5cb6236224048d437834dd2">SDL::qsort_r</a></div><div class="ttdeci">void qsort_r(void *base, size_t nmemb, size_t size, CompareCallback_r compare, void *userdata)</div><div class="ttdoc">Sort an array, passing a userdata pointer to the compare function.</div><div class="ttdef"><b>Definition</b> SDL3pp_stdinc.h:1329</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>a pointer to the start of the array. </td></tr>
    <tr><td class="paramname">nmemb</td><td>the number of elements in the array. </td></tr>
    <tr><td class="paramname">size</td><td>the size of the elements in the array. </td></tr>
    <tr><td class="paramname">compare</td><td>a function used to compare elements in the array. </td></tr>
    <tr><td class="paramname">userdata</td><td>a pointer to pass to the compare function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gaf22f982867b4598c8caa2de8f5a9e0e4" title="Perform a binary search on a previously sorted array, passing a userdata pointer to the compare funct...">bsearch_r</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gab52a0ec3d96fb4c04972b1b322f75857" title="Sort an array.">qsort</a> </dd></dl>

</div>
</div>
<a id="ga702a78756e29c4f8babdb6df497d36fa" name="ga702a78756e29c4f8babdb6df497d36fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga702a78756e29c4f8babdb6df497d36fa">&#9670;&#160;</a></span>qsort_r() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::qsort_r </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga7dc5ada5f1f8fe87900b8fa72e94abca">CompareCB</a>&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For example:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> {</div>
<div class="line">    sort_increasing,</div>
<div class="line">    sort_decreasing,</div>
<div class="line">} sort_method;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *string;</div>
<div class="line">} data;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> SDLCALL compare(<span class="keyword">const</span> <span class="keywordtype">void</span> *userdata, <span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)</div>
<div class="line">{</div>
<div class="line">    sort_method method = (sort_method)(uintptr_t)userdata;</div>
<div class="line">    <span class="keyword">const</span> data *A = (<span class="keyword">const</span> data *)a;</div>
<div class="line">    <span class="keyword">const</span> data *B = (<span class="keyword">const</span> data *)b;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (A-&gt;key &lt; B-&gt;key) {</div>
<div class="line">        <span class="keywordflow">return</span> (method == sort_increasing) ? -1 : 1;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (B-&gt;key &lt; A-&gt;key) {</div>
<div class="line">        <span class="keywordflow">return</span> (method == sort_increasing) ? 1 : -1;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">data values[] = {</div>
<div class="line">    { 3, <span class="stringliteral">&quot;third&quot;</span> }, { 1, <span class="stringliteral">&quot;first&quot;</span> }, { 2, <span class="stringliteral">&quot;second&quot;</span> }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__CategoryStdinc.html#gaa3b0083aa5cb6236224048d437834dd2">qsort_r</a>(values, <a class="code hl_function" href="group__CategoryStdinc.html#ga20b4cc6c53a1dbd7789ee90af065b5f9">arraysize</a>(values), <span class="keyword">sizeof</span>(values[0]), compare, (<span class="keyword">const</span> <span class="keywordtype">void</span></div>
<div class="line">*)(uintptr_t)sort_increasing);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>a pointer to the start of the array. </td></tr>
    <tr><td class="paramname">nmemb</td><td>the number of elements in the array. </td></tr>
    <tr><td class="paramname">size</td><td>the size of the elements in the array. </td></tr>
    <tr><td class="paramname">compare</td><td>a function used to compare elements in the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gaf22f982867b4598c8caa2de8f5a9e0e4" title="Perform a binary search on a previously sorted array, passing a userdata pointer to the compare funct...">bsearch_r</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gab52a0ec3d96fb4c04972b1b322f75857" title="Sort an array.">qsort</a> </dd></dl>

</div>
</div>
<a id="gaa0d119f7b42130eb3a652f7e243c8cf7" name="gaa0d119f7b42130eb3a652f7e243c8cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0d119f7b42130eb3a652f7e243c8cf7">&#9670;&#160;</a></span>rand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sint32 SDL::rand </td>
          <td>(</td>
          <td class="paramtype">Sint32&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The method used is faster and of better quality than <code><a class="el" href="group__CategoryStdinc.html#gaa0d119f7b42130eb3a652f7e243c8cf7" title="Generate a pseudo-random number less than n for positive n.">rand()</a> % n</code>. Odds are roughly 99.9% even for n = 1 million. Evenness is better for smaller n, and much worse as n gets bigger.</p>
<p>Example: to simulate a d6 use <code>rand(6) + 1</code> The +1 converts 0..5 to 1..6</p>
<p>If you want to generate a pseudo-random number in the full range of Sint32, you should use: (Sint32)<a class="el" href="group__CategoryStdinc.html#gae6517052066ab937273e6a89c7d1eca8" title="Generate 32 pseudo-random bits.">rand_bits()</a></p>
<p>If you want reproducible output, be sure to initialize with <a class="el" href="group__CategoryStdinc.html#ga85fc72ab5435901400efdaebc1187630" title="Seeds the pseudo-random number generator.">srand()</a> first.</p>
<p>There are no guarantees as to the quality of the random sequence produced, and this should not be used for security (cryptography, passwords) or where money is on the line (loot-boxes, casinos). There are many random number libraries available with different characteristics and you should pick one of those to meet any serious needs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of possible outcomes. n must be positive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a random value in the range of [0 .. n-1].</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>All calls should be made from a single thread</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga85fc72ab5435901400efdaebc1187630" title="Seeds the pseudo-random number generator.">srand</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaab0a933463eebe63f34b3acec7e96c6e" title="Generate a uniform pseudo-random floating point number less than 1.0.">randf</a> </dd></dl>

</div>
</div>
<a id="gae6517052066ab937273e6a89c7d1eca8" name="gae6517052066ab937273e6a89c7d1eca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6517052066ab937273e6a89c7d1eca8">&#9670;&#160;</a></span>rand_bits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 SDL::rand_bits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You likely want to use <a class="el" href="group__CategoryStdinc.html#gaa0d119f7b42130eb3a652f7e243c8cf7" title="Generate a pseudo-random number less than n for positive n.">rand()</a> to get a pseudo-random number instead.</p>
<p>There are no guarantees as to the quality of the random sequence produced, and this should not be used for security (cryptography, passwords) or where money is on the line (loot-boxes, casinos). There are many random number libraries available with different characteristics and you should pick one of those to meet any serious needs.</p>
<dl class="section return"><dt>Returns</dt><dd>a random value in the range of [0-MAX_UINT32].</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>All calls should be made from a single thread</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gaa0d119f7b42130eb3a652f7e243c8cf7" title="Generate a pseudo-random number less than n for positive n.">rand</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaab0a933463eebe63f34b3acec7e96c6e" title="Generate a uniform pseudo-random floating point number less than 1.0.">randf</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga85fc72ab5435901400efdaebc1187630" title="Seeds the pseudo-random number generator.">srand</a> </dd></dl>

</div>
</div>
<a id="gaab0a933463eebe63f34b3acec7e96c6e" name="gaab0a933463eebe63f34b3acec7e96c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab0a933463eebe63f34b3acec7e96c6e">&#9670;&#160;</a></span>randf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::randf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If you want reproducible output, be sure to initialize with <a class="el" href="group__CategoryStdinc.html#ga85fc72ab5435901400efdaebc1187630" title="Seeds the pseudo-random number generator.">srand()</a> first.</p>
<p>There are no guarantees as to the quality of the random sequence produced, and this should not be used for security (cryptography, passwords) or where money is on the line (loot-boxes, casinos). There are many random number libraries available with different characteristics and you should pick one of those to meet any serious needs.</p>
<dl class="section return"><dt>Returns</dt><dd>a random value in the range of [0.0, 1.0).</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>All calls should be made from a single thread</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga85fc72ab5435901400efdaebc1187630" title="Seeds the pseudo-random number generator.">srand</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaa0d119f7b42130eb3a652f7e243c8cf7" title="Generate a pseudo-random number less than n for positive n.">rand</a> </dd></dl>

</div>
</div>
<a id="gab8208c1b381e6a96b07b5facff79c27b" name="gab8208c1b381e6a96b07b5facff79c27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8208c1b381e6a96b07b5facff79c27b">&#9670;&#160;</a></span>realloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The memory returned by this function must be freed with <a class="el" href="group__CategoryStdinc.html#gadfa01257ca1f966fffb72f002db27fa6" title="Free allocated memory.">free()</a>.</p>
<p>If <code>size</code> is 0, it will be set to 1. Note that this is unlike some other C runtime <code>realloc</code> implementations, which may treat <code>realloc(mem, 0)</code> the same way as <code>free(mem)</code>.</p>
<p>If <code>mem</code> is nullptr, the behavior of this function is equivalent to <a class="el" href="group__CategoryStdinc.html#ga48fe5521cb77ff8e4ae442bc8387be70" title="Allocate uninitialized memory.">malloc()</a>. Otherwise, the function can have one of three possible outcomes:</p>
<ul>
<li>If it returns the same pointer as <code>mem</code>, it means that <code>mem</code> was resized in place without freeing.</li>
<li>If it returns a different non-nullptr pointer, it means that <code>mem</code> was freed and cannot be dereferenced anymore.</li>
<li>If it returns nullptr (indicating failure), then <code>mem</code> will remain valid and must still be freed with <a class="el" href="group__CategoryStdinc.html#gadfa01257ca1f966fffb72f002db27fa6" title="Free allocated memory.">free()</a>.</li>
</ul>
<p>If the allocation is successfully resized, the returned pointer is guaranteed to be aligned to either the <em>fundamental alignment</em> (<code>alignof(max_align_t)</code> in C11 and later) or <code>2 * sizeof(void *)</code>, whichever is smaller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>a pointer to allocated memory to reallocate, or nullptr. </td></tr>
    <tr><td class="paramname">size</td><td>the new size of the memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly allocated memory, or nullptr if allocation failed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gadfa01257ca1f966fffb72f002db27fa6" title="Free allocated memory.">free</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga48fe5521cb77ff8e4ae442bc8387be70" title="Allocate uninitialized memory.">malloc</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gab24b3e9482f5a1c26602b83f2de05d09" title="Allocate a zero-initialized array.">calloc</a> </dd></dl>

</div>
</div>
<a id="ga58af56b2a9898c045c8ec62ec531c8e5" name="ga58af56b2a9898c045c8ec62ec531c8e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58af56b2a9898c045c8ec62ec531c8e5">&#9670;&#160;</a></span>round() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::round </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rounds <code>x</code> to the nearest integer. Values halfway between integers will be rounded away from zero.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nearest integer to <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga70024c43f89714b01cc1ff00baa682e0" title="Round x to the nearest integer representable as a long.">lround</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaa5d99939c5dffc37035e51300236316a" title="Compute the floor of x.">floor</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga1567a1e6b1738fabc6252d7c52f03321" title="Compute the ceiling of x.">ceil</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaeb64b2b465e001720dce40bacec1b937" title="Truncate x to an integer.">trunc</a> </dd></dl>

</div>
</div>
<a id="ga7cf5cc4c422423a6f36915a012c13046" name="ga7cf5cc4c422423a6f36915a012c13046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cf5cc4c422423a6f36915a012c13046">&#9670;&#160;</a></span>round() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::round </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rounds <code>x</code> to the nearest integer. Values halfway between integers will be rounded away from zero.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nearest integer to <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga70024c43f89714b01cc1ff00baa682e0" title="Round x to the nearest integer representable as a long.">lround</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaa5d99939c5dffc37035e51300236316a" title="Compute the floor of x.">floor</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga1567a1e6b1738fabc6252d7c52f03321" title="Compute the ceiling of x.">ceil</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaeb64b2b465e001720dce40bacec1b937" title="Truncate x to an integer.">trunc</a> </dd></dl>

</div>
</div>
<a id="ga2438009a4b8a2f4a9155a168f6cd8303" name="ga2438009a4b8a2f4a9155a168f6cd8303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2438009a4b8a2f4a9155a168f6cd8303">&#9670;&#160;</a></span>scalbn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::scalbn </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies <code>x</code> by the <code>n</code>th power of the floating point radix (always 2).</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>n</code> integer</p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value to be scaled. </td></tr>
    <tr><td class="paramname">n</td><td>integer exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x * 2^n</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga6cfca7e593d97a56d7fca043af3ac2ce" title="Raise x to the power y">pow</a> </dd></dl>

</div>
</div>
<a id="gae36990a63f3564168b682ea67c6635d6" name="gae36990a63f3564168b682ea67c6635d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae36990a63f3564168b682ea67c6635d6">&#9670;&#160;</a></span>scalbn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::scalbn </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies <code>x</code> by the <code>n</code>th power of the floating point radix (always 2).</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>n</code> integer</p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value to be scaled. </td></tr>
    <tr><td class="paramname">n</td><td>integer exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x * 2^n</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga6cfca7e593d97a56d7fca043af3ac2ce" title="Raise x to the power y">pow</a> </dd></dl>

</div>
</div>
<a id="ga97da5abe6c940c70b73fc9465cf8e75e" name="ga97da5abe6c940c70b73fc9465cf8e75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97da5abe6c940c70b73fc9465cf8e75e">&#9670;&#160;</a></span>setenv_unsafe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::setenv_unsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>overwrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the variable to set. </td></tr>
    <tr><td class="paramname">value</td><td>the value of the variable to set. </td></tr>
    <tr><td class="paramname">overwrite</td><td>1 to overwrite the variable if it exists, 0 to return success without setting the variable if it already exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe, consider using <a class="el" href="structSDL_1_1EnvironmentRef.html#ae1f456248fc1c89c2c486671d75d25c8" title="Set the value of a variable in the environment.">EnvironmentRef.SetVariable()</a> instead.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1EnvironmentRef.html#ae1f456248fc1c89c2c486671d75d25c8" title="Set the value of a variable in the environment.">EnvironmentRef.SetVariable</a> </dd></dl>

</div>
</div>
<a id="ga048ad88f068e4b9b9f81703377d3d1a9" name="ga048ad88f068e4b9b9f81703377d3d1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga048ad88f068e4b9b9f81703377d3d1a9">&#9670;&#160;</a></span>SetMemoryFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::SetMemoryFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a>&#160;</td>
          <td class="paramname"><em>malloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a>&#160;</td>
          <td class="paramname"><em>calloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a>&#160;</td>
          <td class="paramname"><em>realloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a>&#160;</td>
          <td class="paramname"><em>free_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>It is not safe to call this function once any allocations have been made, as future calls to free will use the new allocator, even if they came from an malloc made with the old one!</p>
<p>If used, usually this needs to be the first call made into the <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> library, if not the very first thing done at program startup time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">malloc_func</td><td>custom malloc function. </td></tr>
    <tr><td class="paramname">calloc_func</td><td>custom calloc function. </td></tr>
    <tr><td class="paramname">realloc_func</td><td>custom realloc function. </td></tr>
    <tr><td class="paramname">free_func</td><td>custom free function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSDL_1_1Error.html" title="An exception that returns GetError()">Error</a></td><td>on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread, but one should not replace the memory functions once any allocations are made!</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gab331691e9cf41b2fd9063b80910ea6b0" title="Get the current set of SDL memory functions.">GetMemoryFunctions</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga6325f645ab936554e7aaa2e4d977d9d7" title="Get the original set of SDL memory functions.">GetOriginalMemoryFunctions</a> </dd></dl>

</div>
</div>
<a id="ga88bf16c79b920ce54e0ae909b2948663" name="ga88bf16c79b920ce54e0ae909b2948663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88bf16c79b920ce54e0ae909b2948663">&#9670;&#160;</a></span>sin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::sin </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-1 &lt;= y &lt;= 1</code></p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value, in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sine of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga316a2eed1e595c002830ee628c1b4963" title="Compute the arc sine of x.">asin</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gadf8c80d673a05784387fa5e349a9f6dd" title="Compute the cosine of x.">cos</a> </dd></dl>

</div>
</div>
<a id="gafc96ee832d85a8d1484467de4d9c83a6" name="gafc96ee832d85a8d1484467de4d9c83a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc96ee832d85a8d1484467de4d9c83a6">&#9670;&#160;</a></span>sin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::sin </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-1 &lt;= y &lt;= 1</code></p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value, in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sine of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga316a2eed1e595c002830ee628c1b4963" title="Compute the arc sine of x.">asin</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gadf8c80d673a05784387fa5e349a9f6dd" title="Compute the cosine of x.">cos</a> </dd></dl>

</div>
</div>
<a id="ga6a8cffac163d32a70c2a38ed43b8aed6" name="ga6a8cffac163d32a70c2a38ed43b8aed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a8cffac163d32a70c2a38ed43b8aed6">&#9670;&#160;</a></span>size_add_check_overflow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::size_add_check_overflow </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If <code>a + b</code> would overflow, return false.</p>
<p>Otherwise store <code>a + b</code> via ret and return true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first addend. </td></tr>
    <tr><td class="paramname">b</td><td>the second addend. </td></tr>
    <tr><td class="paramname">ret</td><td>on non-overflow output, stores the addition result, may not be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false on overflow, true if result is added without overflow.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga5eff841be311c6243e4c36bc358e017f" name="ga5eff841be311c6243e4c36bc358e017f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5eff841be311c6243e4c36bc358e017f">&#9670;&#160;</a></span>size_mul_check_overflow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::size_mul_check_overflow </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If <code>a * b</code> would overflow, return false.</p>
<p>Otherwise store <code>a * b</code> via ret and return true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the multiplicand. </td></tr>
    <tr><td class="paramname">b</td><td>the multiplier. </td></tr>
    <tr><td class="paramname">ret</td><td>on non-overflow output, stores the multiplication result, may not be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false on overflow, true if result is multiplied without overflow.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga57b48f04ae9e3949774b9f0c9dc0c151" name="ga57b48f04ae9e3949774b9f0c9dc0c151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57b48f04ae9e3949774b9f0c9dc0c151">&#9670;&#160;</a></span>snprintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::snprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_PRINTF_FORMAT_STRING const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Format a string of up to <code>maxlen</code>-1 bytes, converting each '' item with values provided through variable arguments.</p>
<p>While some C runtimes differ on how to deal with too-large strings, this function null-terminates the output, by treating the null-terminator as part of the <code>maxlen</code> count. Note that if <code>maxlen</code> is zero, however, no bytes will be written at all.</p>
<p>This function returns the number of <em>bytes</em> (not <em>characters</em>) that should be written, excluding the null-terminator character. If this returns a number &gt;= <code>maxlen</code>, it means the output string was truncated. A negative return value means an error occurred.</p>
<p>Referencing the output string's pointer with a format item is undefined behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>the buffer to write the string into. Must not be nullptr. </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum bytes to write, including the null-terminator. </td></tr>
    <tr><td class="paramname">fmt</td><td>a printf-style format string. Must not be nullptr. </td></tr>
    <tr><td class="paramname">...</td><td>a list of values to be used with the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that should be written, not counting the null-terminator char, or a negative value on error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga8415b71ce1045874d7b55210806ff3c8" name="ga8415b71ce1045874d7b55210806ff3c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8415b71ce1045874d7b55210806ff3c8">&#9670;&#160;</a></span>sqrt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::sqrt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>0 &lt;= x &lt;= INF</code></p>
<p>Range: <code>0 &lt;= y &lt;= INF</code></p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. Must be greater than or equal to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>square root of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaf7a01c3316e3a227f2b2aae71b5ecc55" name="gaf7a01c3316e3a227f2b2aae71b5ecc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7a01c3316e3a227f2b2aae71b5ecc55">&#9670;&#160;</a></span>sqrt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::sqrt </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>0 &lt;= x &lt;= INF</code></p>
<p>Range: <code>0 &lt;= y &lt;= INF</code></p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. Must be greater than or equal to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>square root of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga85fc72ab5435901400efdaebc1187630" name="ga85fc72ab5435901400efdaebc1187630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85fc72ab5435901400efdaebc1187630">&#9670;&#160;</a></span>srand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::srand </td>
          <td>(</td>
          <td class="paramtype">Uint64&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reusing the seed number will cause <a class="el" href="group__CategoryStdinc.html#gaa0d119f7b42130eb3a652f7e243c8cf7" title="Generate a pseudo-random number less than n for positive n.">rand()</a> to repeat the same stream of 'random' numbers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>the value to use as a random number seed, or 0 to use <a class="el" href="group__CategoryTimer.html#ga5c6c04d58e7ea399a1f66c48dc1f0861" title="Get the current value of the high resolution counter.">GetPerformanceCounter()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This should be called on the same thread that calls <a class="el" href="group__CategoryStdinc.html#gaa0d119f7b42130eb3a652f7e243c8cf7" title="Generate a pseudo-random number less than n for positive n.">rand()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gaa0d119f7b42130eb3a652f7e243c8cf7" title="Generate a pseudo-random number less than n for positive n.">rand</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gae6517052066ab937273e6a89c7d1eca8" title="Generate 32 pseudo-random bits.">rand_bits</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaab0a933463eebe63f34b3acec7e96c6e" title="Generate a uniform pseudo-random floating point number less than 1.0.">randf</a> </dd></dl>

</div>
</div>
<a id="ga592054168270da087e8630cac0df2530" name="ga592054168270da087e8630cac0df2530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga592054168270da087e8630cac0df2530">&#9670;&#160;</a></span>sscanf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::sscanf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_SCANF_FORMAT_STRING const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scan a string, matching a format string, converting each '' item and storing it to pointers provided through variable arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>the string to scan. Must not be nullptr. </td></tr>
    <tr><td class="paramname">fmt</td><td>a printf-style format string. Must not be nullptr. </td></tr>
    <tr><td class="paramname">...</td><td>a list of pointers to values to be filled in with scanned items. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of items that matched the format string.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaaa1607ee6b5fddfb7d22eb518dbe59a4" name="gaaa1607ee6b5fddfb7d22eb518dbe59a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa1607ee6b5fddfb7d22eb518dbe59a4">&#9670;&#160;</a></span>StepBackUTF8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 SDL::StepBackUTF8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>pstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will go to the start of the previous Unicode codepoint in the string, move <code>*pstr</code> to that location and return that codepoint.</p>
<p>If <code>*pstr</code> is already at the start of the string), it will not advance <code>*pstr</code> at all.</p>
<p>Generally this function is called in a loop until it returns zero, adjusting its parameter each iteration.</p>
<p>If an invalid UTF-8 sequence is encountered, this function returns INVALID_UNICODE_CODEPOINT.</p>
<p>Several things can generate invalid UTF-8 sequences, including overlong encodings, the use of UTF-16 surrogate values, and truncated data. Please refer to <a href="https://www.ietf.org/rfc/rfc3629.txt">RFC3629</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>a pointer to the beginning of the UTF-8 string. </td></tr>
    <tr><td class="paramname">pstr</td><td>a pointer to a UTF-8 string pointer to be read and adjusted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous Unicode codepoint in the string.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaa5ecf11cf256372f67e10fafdd79141e" name="gaa5ecf11cf256372f67e10fafdd79141e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5ecf11cf256372f67e10fafdd79141e">&#9670;&#160;</a></span>StepUTF8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 SDL::StepUTF8 </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>pstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pslen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will return the first Unicode codepoint in the UTF-8 encoded string in <code>*pstr</code>, and then advance <code>*pstr</code> past any consumed bytes before returning.</p>
<p>It will not access more than <code>*pslen</code> bytes from the string. <code>*pslen</code> will be adjusted, as well, subtracting the number of bytes consumed.</p>
<p><code>pslen</code> is allowed to be nullptr, in which case the string <em>must</em> be nullptr-terminated, as the function will blindly read until it sees the nullptr char.</p>
<p>if <code>*pslen</code> is zero, it assumes the end of string is reached and returns a zero codepoint regardless of the contents of the string buffer.</p>
<p>If the resulting codepoint is zero (a nullptr terminator), or <code>*pslen</code> is zero, it will not advance <code>*pstr</code> or <code>*pslen</code> at all.</p>
<p>Generally this function is called in a loop until it returns zero, adjusting its parameters each iteration.</p>
<p>If an invalid UTF-8 sequence is encountered, this function returns INVALID_UNICODE_CODEPOINT and advances the string/length by one byte (which is to say, a multibyte sequence might produce several INVALID_UNICODE_CODEPOINT returns before it syncs to the next valid UTF-8 sequence).</p>
<p>Several things can generate invalid UTF-8 sequences, including overlong encodings, the use of UTF-16 surrogate values, and truncated data. Please refer to <a href="https://www.ietf.org/rfc/rfc3629.txt">RFC3629</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pstr</td><td>a pointer to a UTF-8 string pointer to be read and adjusted. </td></tr>
    <tr><td class="paramname">pslen</td><td>a pointer to the number of bytes in the string, to be read and adjusted. nullptr is allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first Unicode codepoint in the string.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga932cf2487365b3a3a6fd6e37a7eddff7" name="ga932cf2487365b3a3a6fd6e37a7eddff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga932cf2487365b3a3a6fd6e37a7eddff7">&#9670;&#160;</a></span>strcasecmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::strcasecmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will work with Unicode strings, using a technique called "case-folding" to handle the vast majority of case-sensitive human languages regardless of system locale. It can deal with expanding values: a German Eszett character can compare against two ASCII 's' chars and be considered a match, for example. A notable exception: it does not handle the Turkish 'i' character; human language is complicated!</p>
<p>Since this handles Unicode, it expects the string to be well-formed UTF-8 and not a null-terminated string of arbitrary bytes. Bytes that are not valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT CHARACTER), which is to say two strings of random bits may turn out to match if they convert to the same amount of replacement characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. nullptr is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. nullptr is not permitted! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga0d413500b6dc7d885777ecb0873c823e" name="ga0d413500b6dc7d885777ecb0873c823e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d413500b6dc7d885777ecb0873c823e">&#9670;&#160;</a></span>strcasestr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strcasestr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will work with Unicode strings, using a technique called "case-folding" to handle the vast majority of case-sensitive human languages regardless of system locale. It can deal with expanding values: a German Eszett character can compare against two ASCII 's' chars and be considered a match, for example. A notable exception: it does not handle the Turkish 'i' character; human language is complicated!</p>
<p>Since this handles Unicode, it expects the strings to be well-formed UTF-8 and not a null-terminated string of arbitrary bytes. Bytes that are not valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT CHARACTER), which is to say two strings of random bits may turn out to match if they convert to the same amount of replacement characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>the string to search. Must not be nullptr. </td></tr>
    <tr><td class="paramname">needle</td><td>the string to search for. Must not be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first instance of <code>needle</code> in the string, or nullptr if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga451b842c63a514775080900ae67150da" name="ga451b842c63a514775080900ae67150da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga451b842c63a514775080900ae67150da">&#9670;&#160;</a></span>strchr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The search ends once it finds the requested byte value, or a null terminator byte to end the string.</p>
<p>Note that this looks for <em>bytes</em>, not <em>characters</em>, so you cannot match against a Unicode codepoint &gt; 255, regardless of character encoding.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to search. Must not be nullptr. </td></tr>
    <tr><td class="paramname">c</td><td>the byte value to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first instance of <code>c</code> in the string, or nullptr if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga63d50d9f0b71b04e9b038f0bc71e54c3" name="ga63d50d9f0b71b04e9b038f0bc71e54c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63d50d9f0b71b04e9b038f0bc71e54c3">&#9670;&#160;</a></span>strcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::strcmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Due to the nature of UTF-8 encoding, this will work with Unicode strings, since effectively this function just compares bytes until it hits a null-terminating character. Also due to the nature of UTF-8, this can be used with <a class="el" href="group__CategoryStdinc.html#gab52a0ec3d96fb4c04972b1b322f75857" title="Sort an array.">qsort()</a> to put strings in (roughly) alphabetical order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. nullptr is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. nullptr is not permitted! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga046b80783770b59a2cf8b4311230fbbd" name="ga046b80783770b59a2cf8b4311230fbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga046b80783770b59a2cf8b4311230fbbd">&#9670;&#160;</a></span>strdup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strdup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This allocates enough space for a null-terminated copy of <code>str</code>, using malloc, and then makes a copy of the string into this space.</p>
<p>The returned string is owned by the caller, and should be passed to free when no longer needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly-allocated string.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga503a37a91faa4ed9374b9dd9db03049c" name="ga503a37a91faa4ed9374b9dd9db03049c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga503a37a91faa4ed9374b9dd9db03049c">&#9670;&#160;</a></span>strlcat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::strlcat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function appends up to <code>maxlen</code> - strlen(dst) - 1 characters from <code>src</code> to the end of the string in <code>dst</code>, then appends a null terminator.</p>
<p><code>src</code> and <code>dst</code> must not overlap.</p>
<p>If <code>maxlen</code> - strlen(dst) - 1 is less than or equal to 0, then <code>dst</code> is unmodified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination buffer already containing the first null-terminated string. Must not be nullptr and must not overlap with <code>src</code>. </td></tr>
    <tr><td class="paramname">src</td><td>The second null-terminated string. Must not be nullptr, and must not overlap with <code>dst</code>. </td></tr>
    <tr><td class="paramname">maxlen</td><td>The length (in characters) of the destination buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in characters, excluding the null terminator) of the string in <code>dst</code> plus the length of <code>src</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga598ecc44c77a20ab4de3a96eda46ea76" title="Copy a string.">strlcpy</a> </dd></dl>

</div>
</div>
<a id="ga598ecc44c77a20ab4de3a96eda46ea76" name="ga598ecc44c77a20ab4de3a96eda46ea76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga598ecc44c77a20ab4de3a96eda46ea76">&#9670;&#160;</a></span>strlcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::strlcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function copies up to <code>maxlen</code> - 1 characters from <code>src</code> to <code>dst</code>, then appends a null terminator.</p>
<p>If <code>maxlen</code> is 0, no characters are copied and no null terminator is written.</p>
<p>If you want to copy an UTF-8 string but need to ensure that multi-byte sequences are not truncated, consider using <a class="el" href="group__CategoryStdinc.html#ga8ae726c47fde58d11167345dfda765a4" title="Copy an UTF-8 string.">utf8strlcpy()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination buffer. Must not be nullptr, and must not overlap with <code>src</code>. </td></tr>
    <tr><td class="paramname">src</td><td>The null-terminated string to copy. Must not be nullptr, and must not overlap with <code>dst</code>. </td></tr>
    <tr><td class="paramname">maxlen</td><td>The length (in characters) of the destination buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in characters, excluding the null terminator) of <code>src</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga503a37a91faa4ed9374b9dd9db03049c" title="Concatenate strings.">strlcat</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga8ae726c47fde58d11167345dfda765a4" title="Copy an UTF-8 string.">utf8strlcpy</a> </dd></dl>

</div>
</div>
<a id="ga93de03cd7e1369ba80c5746761bac939" name="ga93de03cd7e1369ba80c5746761bac939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93de03cd7e1369ba80c5746761bac939">&#9670;&#160;</a></span>strlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::strlen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts the bytes in <code>str</code>, excluding the null terminator.</p>
<p>If you need the length of a UTF-8 string, consider using <a class="el" href="group__CategoryStdinc.html#ga81767a08005a153d60b63896c58c106f" title="Count the number of codepoints in a UTF-8 string.">utf8strlen()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to read. Must not be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in bytes, excluding the null terminator) of <code>src</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga929593393da0025b602c5b4560bce5bf" title="This works exactly like strnlen() but doesn&#39;t require access to a C runtime.">strnlen</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga81767a08005a153d60b63896c58c106f" title="Count the number of codepoints in a UTF-8 string.">utf8strlen</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga82960b752efedfdd3cbfcf166d06161e" title="Count the number of codepoints in a UTF-8 string, up to n bytes.">utf8strnlen</a> </dd></dl>

</div>
</div>
<a id="ga15eaa2ac05317f734e1f022cfc916201" name="ga15eaa2ac05317f734e1f022cfc916201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15eaa2ac05317f734e1f022cfc916201">&#9670;&#160;</a></span>strlwr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strlwr </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only convert ASCII values 'A' through 'Z' to lowercase.</p>
<p>This function operates on a null-terminated string of bytes&ndash;even if it is malformed UTF-8!&ndash;and converts ASCII characters 'A' through 'Z' to their lowercase equivalents in-place, returning the original <code>str</code> pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert in-place. Can not be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <code>str</code> pointer passed into this function.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga7fe290f18ce6025c454f0b62729c0662" title="Convert a string to uppercase.">strupr</a> </dd></dl>

</div>
</div>
<a id="ga37191be89f79920285c912c0544150e8" name="ga37191be89f79920285c912c0544150e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37191be89f79920285c912c0544150e8">&#9670;&#160;</a></span>strncasecmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::strncasecmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will work with Unicode strings, using a technique called "case-folding" to handle the vast majority of case-sensitive human languages regardless of system locale. It can deal with expanding values: a German Eszett character can compare against two ASCII 's' chars and be considered a match, for example. A notable exception: it does not handle the Turkish 'i' character; human language is complicated!</p>
<p>Since this handles Unicode, it expects the string to be well-formed UTF-8 and not a null-terminated string of arbitrary bytes. Bytes that are not valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT CHARACTER), which is to say two strings of random bits may turn out to match if they convert to the same amount of replacement characters.</p>
<p>Note that while this function is intended to be used with UTF-8, <code>maxlen</code> specifies a <em>byte</em> limit! If the limit lands in the middle of a multi-byte UTF-8 sequence, it may convert a portion of the final character to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not to overflow a buffer.</p>
<p><code>maxlen</code> specifies a maximum number of bytes to compare; if the strings match to this number of bytes (or both have matched to a null-terminator character before this number of bytes), they will be considered equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. nullptr is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. nullptr is not permitted! </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum number of bytes to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga2caad6bed5796e9524d07c21d4701af9" name="ga2caad6bed5796e9524d07c21d4701af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2caad6bed5796e9524d07c21d4701af9">&#9670;&#160;</a></span>strncmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::strncmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Due to the nature of UTF-8 encoding, this will work with Unicode strings, since effectively this function just compares bytes until it hits a null-terminating character. Also due to the nature of UTF-8, this can be used with <a class="el" href="group__CategoryStdinc.html#gab52a0ec3d96fb4c04972b1b322f75857" title="Sort an array.">qsort()</a> to put strings in (roughly) alphabetical order.</p>
<p>Note that while this function is intended to be used with UTF-8, it is doing a bytewise comparison, and <code>maxlen</code> specifies a <em>byte</em> limit! If the limit lands in the middle of a multi-byte UTF-8 sequence, it will only compare a portion of the final character.</p>
<p><code>maxlen</code> specifies a maximum number of bytes to compare; if the strings match to this number of bytes (or both have matched to a null-terminator character before this number of bytes), they will be considered equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. nullptr is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. nullptr is not permitted! </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum number of <em>bytes</em> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga53e0a0ce55852f1320bc292f72dc1398" name="ga53e0a0ce55852f1320bc292f72dc1398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53e0a0ce55852f1320bc292f72dc1398">&#9670;&#160;</a></span>strndup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strndup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This allocates enough space for a null-terminated copy of <code>str</code>, up to <code>maxlen</code> bytes, using malloc, and then makes a copy of the string into this space.</p>
<p>If the string is longer than <code>maxlen</code> bytes, the returned string will be <code>maxlen</code> bytes long, plus a null-terminator character that isn't included in the count.</p>
<p>The returned string is owned by the caller, and should be passed to free when no longer needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to copy. </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum length of the copied string, not counting the null-terminator character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly-allocated string.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga929593393da0025b602c5b4560bce5bf" name="ga929593393da0025b602c5b4560bce5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga929593393da0025b602c5b4560bce5bf">&#9670;&#160;</a></span>strnlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::strnlen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts up to a maximum of <code>maxlen</code> bytes in <code>str</code>, excluding the null terminator.</p>
<p>If you need the length of a UTF-8 string, consider using <a class="el" href="group__CategoryStdinc.html#ga82960b752efedfdd3cbfcf166d06161e" title="Count the number of codepoints in a UTF-8 string, up to n bytes.">utf8strnlen()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to read. Must not be nullptr. </td></tr>
    <tr><td class="paramname">maxlen</td><td>The maximum amount of bytes to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in bytes, excluding the null terminator) of <code>src</code> but never more than <code>maxlen</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga93de03cd7e1369ba80c5746761bac939" title="This works exactly like strlen() but doesn&#39;t require access to a C runtime.">strlen</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga81767a08005a153d60b63896c58c106f" title="Count the number of codepoints in a UTF-8 string.">utf8strlen</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga82960b752efedfdd3cbfcf166d06161e" title="Count the number of codepoints in a UTF-8 string, up to n bytes.">utf8strnlen</a> </dd></dl>

</div>
</div>
<a id="ga21c1bce04f407d4dab36722078978a9b" name="ga21c1bce04f407d4dab36722078978a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21c1bce04f407d4dab36722078978a9b">&#9670;&#160;</a></span>strnstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strnstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The search ends once it finds the requested substring, or a null terminator byte to end the string, or <code>maxlen</code> bytes have been examined. It is possible to use this function on a string without a null terminator.</p>
<p>Note that this looks for strings of <em>bytes</em>, not <em>characters</em>, so it's legal to search for malformed and incomplete UTF-8 sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>the string to search. Must not be nullptr. </td></tr>
    <tr><td class="paramname">needle</td><td>the string to search for. Must not be nullptr. </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum number of bytes to search in <code>haystack</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first instance of <code>needle</code> in the string, or nullptr if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gae3838c531e1c9bbee29cdf5f4ccb60b4" name="gae3838c531e1c9bbee29cdf5f4ccb60b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3838c531e1c9bbee29cdf5f4ccb60b4">&#9670;&#160;</a></span>strpbrk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strpbrk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>breakset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to be searched. Must not be nullptr, and must not overlap with <code>breakset</code>. </td></tr>
    <tr><td class="paramname">breakset</td><td>A null-terminated string containing the list of characters to look for. Must not be nullptr, and must not overlap with <code>str</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the location, in str, of the first occurence of a character present in the breakset, or nullptr if none is found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaf67863ed8e432e74c417116a532ef24b" name="gaf67863ed8e432e74c417116a532ef24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf67863ed8e432e74c417116a532ef24b">&#9670;&#160;</a></span>strrchr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strrchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The search must go until it finds a null terminator byte to end the string.</p>
<p>Note that this looks for <em>bytes</em>, not <em>characters</em>, so you cannot match against a Unicode codepoint &gt; 255, regardless of character encoding.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to search. Must not be nullptr. </td></tr>
    <tr><td class="paramname">c</td><td>the byte value to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the last instance of <code>c</code> in the string, or nullptr if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga32b6d922e9310ca993a82b84e692e8a5" name="ga32b6d922e9310ca993a82b84e692e8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32b6d922e9310ca993a82b84e692e8a5">&#9670;&#160;</a></span>strrev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strrev </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This reverses a null-terminated string in-place. Only the content of the string is reversed; the null-terminator character remains at the end of the reversed string.</p>
<p><b>WARNING</b>: This function reverses the <em>bytes</em> of the string, not the codepoints. If <code>str</code> is a UTF-8 string with Unicode codepoints &gt; 127, this will ruin the string data. You should only use this function on strings that are completely comprised of low ASCII characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to reverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>str</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga3ef7c9322f6766ee71172d34493ee792" name="ga3ef7c9322f6766ee71172d34493ee792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ef7c9322f6766ee71172d34493ee792">&#9670;&#160;</a></span>strstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The search ends once it finds the requested substring, or a null terminator byte to end the string.</p>
<p>Note that this looks for strings of <em>bytes</em>, not <em>characters</em>, so it's legal to search for malformed and incomplete UTF-8 sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>the string to search. Must not be nullptr. </td></tr>
    <tr><td class="paramname">needle</td><td>the string to search for. Must not be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first instance of <code>needle</code> in the string, or nullptr if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga062de74e1950744ad5556cc815c58036" name="ga062de74e1950744ad5556cc815c58036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga062de74e1950744ad5556cc815c58036">&#9670;&#160;</a></span>strtod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::strtod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function makes fewer guarantees than the C runtime <code>strtod</code>:</p>
<ul>
<li>Only decimal notation is guaranteed to be supported. The handling of scientific and hexadecimal notation is unspecified.</li>
<li>Whether or not INF and NAN can be parsed is unspecified.</li>
<li>The precision of the result is unspecified.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the null-terminated string to read. Must not be nullptr. </td></tr>
    <tr><td class="paramname">endp</td><td>if not nullptr, the address of the first invalid character (i.e. the next character after the parsed number) will be written to this pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed <code>double</code>, or 0 if no number could be parsed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga756fd0202aa809d537fc01e28b0c7564" title="Parse an int from a string.">atoi</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaeecdd7ec80c303a7474d59b641a892f7" title="Parse a double from a string.">atof</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaf270570877b7a6ccaea59ba90b428043" title="Parse a long from a string.">strtol</a> </dd>
<dd>
SDL_strtoll </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga3869ab21242a2a6fb41be41b382d2af2" title="Parse an unsigned long from a string.">strtoul</a> </dd>
<dd>
SDL_strtoull </dd></dl>

</div>
</div>
<a id="ga8dc2ad6fd692f32f1304e9b1872881a2" name="ga8dc2ad6fd692f32f1304e9b1872881a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dc2ad6fd692f32f1304e9b1872881a2">&#9670;&#160;</a></span>strtok_r()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strtok_r </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>saveptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Break a string up into a series of tokens.</p>
<p>To start tokenizing a new string, <code>str</code> should be the non-nullptr address of the string to start tokenizing. Future calls to get the next token from the same string should specify a nullptr.</p>
<p>Note that this function will overwrite pieces of <code>str</code> with null chars to split it into tokens. This function cannot be used with const/read-only strings!</p>
<p><code>saveptr</code> just needs to point to a <code>char *</code> that can be overwritten; <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> will use this to save tokenizing state between calls. It is initialized if <code>str</code> is non-nullptr, and used to resume tokenizing when <code>str</code> is nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to tokenize, or nullptr to continue tokenizing. </td></tr>
    <tr><td class="paramname">delim</td><td>the delimiter string that separates tokens. </td></tr>
    <tr><td class="paramname">saveptr</td><td>pointer to a char *, used for ongoing state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the next token, or nullptr if no tokens remain.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaf270570877b7a6ccaea59ba90b428043" name="gaf270570877b7a6ccaea59ba90b428043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf270570877b7a6ccaea59ba90b428043">&#9670;&#160;</a></span>strtol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long SDL::strtol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If <code>str</code> starts with whitespace, then those whitespace characters are skipped before attempting to parse the number.</p>
<p>If the parsed number does not fit inside a <code>long</code>, the result is clamped to the minimum and maximum representable <code>long</code> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to read. Must not be nullptr. </td></tr>
    <tr><td class="paramname">endp</td><td>If not nullptr, the address of the first invalid character (i.e. the next character after the parsed number) will be written to this pointer. </td></tr>
    <tr><td class="paramname">base</td><td>The base of the integer to read. Supported values are 0 and 2 to 36 inclusive. If 0, the base will be inferred from the number's prefix (0x for hexadecimal, 0 for octal, decimal otherwise). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed <code>long</code>, or 0 if no number could be parsed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga756fd0202aa809d537fc01e28b0c7564" title="Parse an int from a string.">atoi</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaeecdd7ec80c303a7474d59b641a892f7" title="Parse a double from a string.">atof</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga3869ab21242a2a6fb41be41b382d2af2" title="Parse an unsigned long from a string.">strtoul</a> </dd>
<dd>
SDL_strtoll </dd>
<dd>
SDL_strtoull </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga062de74e1950744ad5556cc815c58036" title="Parse a double from a string.">strtod</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaee263ca33e533bf8acdd33b20e2323cf" title="Convert a long integer into a string.">ltoa</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga0408a155d55fa0fc2d0198de99ca0dc4" title="Parse a long from a wide string.">wcstol</a> </dd></dl>

</div>
</div>
<a id="ga3869ab21242a2a6fb41be41b382d2af2" name="ga3869ab21242a2a6fb41be41b382d2af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3869ab21242a2a6fb41be41b382d2af2">&#9670;&#160;</a></span>strtoul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long SDL::strtoul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If <code>str</code> starts with whitespace, then those whitespace characters are skipped before attempting to parse the number.</p>
<p>If the parsed number does not fit inside an <code>unsigned long</code>, the result is clamped to the maximum representable <code>unsigned long</code> value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to read. Must not be nullptr. </td></tr>
    <tr><td class="paramname">endp</td><td>If not nullptr, the address of the first invalid character (i.e. the next character after the parsed number) will be written to this pointer. </td></tr>
    <tr><td class="paramname">base</td><td>The base of the integer to read. Supported values are 0 and 2 to 36 inclusive. If 0, the base will be inferred from the number's prefix (0x for hexadecimal, 0 for octal, decimal otherwise). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed <code>unsigned long</code>, or 0 if no number could be parsed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga756fd0202aa809d537fc01e28b0c7564" title="Parse an int from a string.">atoi</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaeecdd7ec80c303a7474d59b641a892f7" title="Parse a double from a string.">atof</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaf270570877b7a6ccaea59ba90b428043" title="Parse a long from a string.">strtol</a> </dd>
<dd>
SDL_strtoll </dd>
<dd>
SDL_strtoull </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga062de74e1950744ad5556cc815c58036" title="Parse a double from a string.">strtod</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga2450290efea2bebff1f164a6c4a04d38" title="Convert an unsigned long integer into a string.">ultoa</a> </dd></dl>

</div>
</div>
<a id="ga7fe290f18ce6025c454f0b62729c0662" name="ga7fe290f18ce6025c454f0b62729c0662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fe290f18ce6025c454f0b62729c0662">&#9670;&#160;</a></span>strupr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strupr </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only convert ASCII values 'A' through 'Z' to uppercase.</p>
<p>This function operates on a null-terminated string of bytes&ndash;even if it is malformed UTF-8!&ndash;and converts ASCII characters 'a' through 'z' to their uppercase equivalents in-place, returning the original <code>str</code> pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert in-place. Can not be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <code>str</code> pointer passed into this function.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga15eaa2ac05317f734e1f022cfc916201" title="Convert a string to lowercase.">strlwr</a> </dd></dl>

</div>
</div>
<a id="ga90fbec4327cabf79747426483a3f24cd" name="ga90fbec4327cabf79747426483a3f24cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90fbec4327cabf79747426483a3f24cd">&#9670;&#160;</a></span>swprintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::swprintf </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_PRINTF_FORMAT_STRING const wchar_t *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Format a wide string of up to <code>maxlen</code>-1 wchar_t values, converting each '' item with values provided through variable arguments.</p>
<p>While some C runtimes differ on how to deal with too-large strings, this function null-terminates the output, by treating the null-terminator as part of the <code>maxlen</code> count. Note that if <code>maxlen</code> is zero, however, no wide characters will be written at all.</p>
<p>This function returns the number of <em>wide characters</em> (not <em>codepoints</em>) that should be written, excluding the null-terminator character. If this returns a number &gt;= <code>maxlen</code>, it means the output string was truncated. A negative return value means an error occurred.</p>
<p>Referencing the output string's pointer with a format item is undefined behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>the buffer to write the wide string into. Must not be nullptr. </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum wchar_t values to write, including the null-terminator. </td></tr>
    <tr><td class="paramname">fmt</td><td>a printf-style format string. Must not be nullptr. </td></tr>
    <tr><td class="paramname">...</td><td>a list of values to be used with the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of wide characters that should be written, not counting the null-terminator char, or a negative value on error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga88b5a6adb928a623a97598a7a154432c" name="ga88b5a6adb928a623a97598a7a154432c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88b5a6adb928a623a97598a7a154432c">&#9670;&#160;</a></span>tan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::tan </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value, in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tangent of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga88bf16c79b920ce54e0ae909b2948663" title="Compute the sine of x.">sin</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gadf8c80d673a05784387fa5e349a9f6dd" title="Compute the cosine of x.">cos</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga11d0eaba28baba36fc8050f8541c8ee5" title="Compute the arc tangent of x.">atan</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gae0884b892c70d428cf50522d9791eb61" title="Compute the arc tangent of y / x, using the signs of x and y to adjust the result&#39;s quadrant.">atan2</a> </dd></dl>

</div>
</div>
<a id="ga3d01d4f175aeac4ea274982f4fa5a503" name="ga3d01d4f175aeac4ea274982f4fa5a503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d01d4f175aeac4ea274982f4fa5a503">&#9670;&#160;</a></span>tan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::tan </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<p>This function operates on single-precision floating point values, use tan for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value, in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tangent of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga88bf16c79b920ce54e0ae909b2948663" title="Compute the sine of x.">sin</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gadf8c80d673a05784387fa5e349a9f6dd" title="Compute the cosine of x.">cos</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga11d0eaba28baba36fc8050f8541c8ee5" title="Compute the arc tangent of x.">atan</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gae0884b892c70d428cf50522d9791eb61" title="Compute the arc tangent of y / x, using the signs of x and y to adjust the result&#39;s quadrant.">atan2</a> </dd></dl>

</div>
</div>
<a id="ga77f89764775d85be34bed2bc447d543a" name="ga77f89764775d85be34bed2bc447d543a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77f89764775d85be34bed2bc447d543a">&#9670;&#160;</a></span>tolower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::tolower </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only convert ASCII values 'A' through 'Z' to lowercase.</p>
<p>This function returns the lowercase equivalent of <code>x</code>. If a character cannot be converted, or is already lowercase, this function returns <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lowercase version of x, or x if no conversion available.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaa66528bfccd7f5a86ed7554d049d1930" name="gaa66528bfccd7f5a86ed7554d049d1930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa66528bfccd7f5a86ed7554d049d1930">&#9670;&#160;</a></span>toupper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::toupper </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only convert ASCII values 'a' through 'z' to uppercase.</p>
<p>This function returns the uppercase equivalent of <code>x</code>. If a character cannot be converted, or is already uppercase, this function returns <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>capitalized version of x, or x if no conversion available.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaeb64b2b465e001720dce40bacec1b937" name="gaeb64b2b465e001720dce40bacec1b937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb64b2b465e001720dce40bacec1b937">&#9670;&#160;</a></span>trunc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::trunc </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rounds <code>x</code> to the next closest integer to 0. This is equivalent to removing the fractional part of <code>x</code>, leaving only the integer part.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> truncated to an integer.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gafcd6b0192bc061852ef8ef56272bf98d" title="Return the floating-point remainder of x / y">fmod</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga1567a1e6b1738fabc6252d7c52f03321" title="Compute the ceiling of x.">ceil</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaa5d99939c5dffc37035e51300236316a" title="Compute the floor of x.">floor</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga58af56b2a9898c045c8ec62ec531c8e5" title="Round x to the nearest integer.">round</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga70024c43f89714b01cc1ff00baa682e0" title="Round x to the nearest integer representable as a long.">lround</a> </dd></dl>

</div>
</div>
<a id="ga673e5ecaed895190e52c8265b89e17d8" name="ga673e5ecaed895190e52c8265b89e17d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga673e5ecaed895190e52c8265b89e17d8">&#9670;&#160;</a></span>trunc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::trunc </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rounds <code>x</code> to the next closest integer to 0. This is equivalent to removing the fractional part of <code>x</code>, leaving only the integer part.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> truncated to an integer.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gafcd6b0192bc061852ef8ef56272bf98d" title="Return the floating-point remainder of x / y">fmod</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga1567a1e6b1738fabc6252d7c52f03321" title="Compute the ceiling of x.">ceil</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaa5d99939c5dffc37035e51300236316a" title="Compute the floor of x.">floor</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga58af56b2a9898c045c8ec62ec531c8e5" title="Round x to the nearest integer.">round</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga70024c43f89714b01cc1ff00baa682e0" title="Round x to the nearest integer representable as a long.">lround</a> </dd></dl>

</div>
</div>
<a id="ga032867626ec7d90baa207d817fdbddcf" name="ga032867626ec7d90baa207d817fdbddcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga032867626ec7d90baa207d817fdbddcf">&#9670;&#160;</a></span>UCS4ToUTF8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::UCS4ToUTF8 </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>codepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The buffer pointed to by <code>dst</code> must be at least 4 bytes long, as this function may generate between 1 and 4 bytes of output.</p>
<p>This function returns the first byte <em>after</em> the newly-written UTF-8 sequence, which is useful for encoding multiple codepoints in a loop, or knowing where to write a nullptr-terminator character to end the string (in either case, plan to have a buffer of <em>more</em> than 4 bytes!).</p>
<p>If <code>codepoint</code> is an invalid value (outside the Unicode range, or a UTF-16 surrogate value, etc), this will use U+FFFD (REPLACEMENT CHARACTER) for the codepoint instead, and not set an error.</p>
<p>If <code>dst</code> is nullptr, this returns nullptr immediately without writing to the pointer and without setting an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codepoint</td><td>a Unicode codepoint to convert to UTF-8. </td></tr>
    <tr><td class="paramname">dst</td><td>the location to write the encoded UTF-8. Must point to at least 4 bytes! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first byte past the newly-written UTF-8 sequence.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga6ca0851c2d9980695748c979e2d15608" name="ga6ca0851c2d9980695748c979e2d15608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ca0851c2d9980695748c979e2d15608">&#9670;&#160;</a></span>uitoa()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::uitoa </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This requires a radix to specified for string format. Specifying 10 produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2 to 36.</p>
<p>Note that this function will overflow a buffer if <code>str</code> is not large enough to hold the output! It may be safer to use snprintf to clamp output, or asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate much more space than you expect to use (and don't forget null terminator bytes, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the unsigned integer to convert. </td></tr>
    <tr><td class="paramname">str</td><td>the buffer to write the string into. </td></tr>
    <tr><td class="paramname">radix</td><td>the radix to use for string generation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>str</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gac0d19dc9f116d9f492fd4d17296f0c4b" title="Convert an integer into a string.">itoa</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga2450290efea2bebff1f164a6c4a04d38" title="Convert an unsigned long integer into a string.">ultoa</a> </dd>
<dd>
SDL_ulltoa </dd></dl>

</div>
</div>
<a id="ga2450290efea2bebff1f164a6c4a04d38" name="ga2450290efea2bebff1f164a6c4a04d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2450290efea2bebff1f164a6c4a04d38">&#9670;&#160;</a></span>ultoa()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::ultoa </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This requires a radix to specified for string format. Specifying 10 produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2 to 36.</p>
<p>Note that this function will overflow a buffer if <code>str</code> is not large enough to hold the output! It may be safer to use snprintf to clamp output, or asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate much more space than you expect to use (and don't forget null terminator bytes, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the unsigned long integer to convert. </td></tr>
    <tr><td class="paramname">str</td><td>the buffer to write the string into. </td></tr>
    <tr><td class="paramname">radix</td><td>the radix to use for string generation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>str</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gaee263ca33e533bf8acdd33b20e2323cf" title="Convert a long integer into a string.">ltoa</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga6ca0851c2d9980695748c979e2d15608" title="Convert an unsigned integer into a string.">uitoa</a> </dd>
<dd>
SDL_ulltoa </dd></dl>

</div>
</div>
<a id="ga7dc726179e2ae431d7db8164099e333a" name="ga7dc726179e2ae431d7db8164099e333a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dc726179e2ae431d7db8164099e333a">&#9670;&#160;</a></span>unsetenv_unsafe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::unsetenv_unsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the variable to unset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe, consider using <a class="el" href="structSDL_1_1EnvironmentRef.html#a2b6d72ef09306d457e4a4ee1e8a114d9" title="Clear a variable from the environment.">EnvironmentRef.UnsetVariable()</a> instead.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1EnvironmentRef.html#a2b6d72ef09306d457e4a4ee1e8a114d9" title="Clear a variable from the environment.">EnvironmentRef.UnsetVariable</a> </dd></dl>

</div>
</div>
<a id="ga8ae726c47fde58d11167345dfda765a4" name="ga8ae726c47fde58d11167345dfda765a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ae726c47fde58d11167345dfda765a4">&#9670;&#160;</a></span>utf8strlcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::utf8strlcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dst_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function copies up to <code>dst_bytes</code> - 1 bytes from <code>src</code> to <code>dst</code> while also ensuring that the string written to <code>dst</code> does not end in a truncated multi-byte sequence. Finally, it appends a null terminator.</p>
<p><code>src</code> and <code>dst</code> must not overlap.</p>
<p>Note that unlike <a class="el" href="group__CategoryStdinc.html#ga598ecc44c77a20ab4de3a96eda46ea76" title="Copy a string.">strlcpy()</a>, this function returns the number of bytes written, not the length of <code>src</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination buffer. Must not be nullptr, and must not overlap with <code>src</code>. </td></tr>
    <tr><td class="paramname">src</td><td>The null-terminated UTF-8 string to copy. Must not be nullptr, and must not overlap with <code>dst</code>. </td></tr>
    <tr><td class="paramname">dst_bytes</td><td>The length (in bytes) of the destination buffer. Must not be 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written, excluding the null terminator.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga598ecc44c77a20ab4de3a96eda46ea76" title="Copy a string.">strlcpy</a> </dd></dl>

</div>
</div>
<a id="ga81767a08005a153d60b63896c58c106f" name="ga81767a08005a153d60b63896c58c106f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81767a08005a153d60b63896c58c106f">&#9670;&#160;</a></span>utf8strlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::utf8strlen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts the <em>codepoints</em>, not <em>bytes</em>, in <code>str</code>, excluding the null terminator.</p>
<p>If you need to count the bytes in a string instead, consider using <a class="el" href="group__CategoryStdinc.html#ga93de03cd7e1369ba80c5746761bac939" title="This works exactly like strlen() but doesn&#39;t require access to a C runtime.">strlen()</a>.</p>
<p>Since this handles Unicode, it expects the strings to be well-formed UTF-8 and not a null-terminated string of arbitrary bytes. Bytes that are not valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the count by several replacement characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated UTF-8 string to read. Must not be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (in codepoints, excluding the null terminator) of <code>src</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga82960b752efedfdd3cbfcf166d06161e" title="Count the number of codepoints in a UTF-8 string, up to n bytes.">utf8strnlen</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga93de03cd7e1369ba80c5746761bac939" title="This works exactly like strlen() but doesn&#39;t require access to a C runtime.">strlen</a> </dd></dl>

</div>
</div>
<a id="ga82960b752efedfdd3cbfcf166d06161e" name="ga82960b752efedfdd3cbfcf166d06161e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82960b752efedfdd3cbfcf166d06161e">&#9670;&#160;</a></span>utf8strnlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::utf8strnlen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts the <em>codepoints</em>, not <em>bytes</em>, in <code>str</code>, excluding the null terminator.</p>
<p>If you need to count the bytes in a string instead, consider using <a class="el" href="group__CategoryStdinc.html#ga929593393da0025b602c5b4560bce5bf" title="This works exactly like strnlen() but doesn&#39;t require access to a C runtime.">strnlen()</a>.</p>
<p>The counting stops at <code>bytes</code> bytes (not codepoints!). This seems counterintuitive, but makes it easy to express the total size of the string's buffer.</p>
<p>Since this handles Unicode, it expects the strings to be well-formed UTF-8 and not a null-terminated string of arbitrary bytes. Bytes that are not valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the count by several replacement characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated UTF-8 string to read. Must not be nullptr. </td></tr>
    <tr><td class="paramname">bytes</td><td>The maximum amount of bytes to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (in codepoints, excluding the null terminator) of <code>src</code> but never more than <code>maxlen</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga81767a08005a153d60b63896c58c106f" title="Count the number of codepoints in a UTF-8 string.">utf8strlen</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga929593393da0025b602c5b4560bce5bf" title="This works exactly like strnlen() but doesn&#39;t require access to a C runtime.">strnlen</a> </dd></dl>

</div>
</div>
<a id="gabd658aed3baf56ca11c8148de5cd9480" name="gabd658aed3baf56ca11c8148de5cd9480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd658aed3baf56ca11c8148de5cd9480">&#9670;&#160;</a></span>vasprintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::vasprintf </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>strp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_PRINTF_FORMAT_STRING const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Functions identically to <a class="el" href="group__CategoryStdinc.html#ga12e5aac7458286e05c61d71278f59215" title="This works exactly like asprintf() but doesn&#39;t require access to a C runtime.">asprintf()</a>, except it takes a <code>va_list</code> instead of using <code>...</code> variable arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strp</td><td>on output, is set to the new string. Must not be nullptr. </td></tr>
    <tr><td class="paramname">fmt</td><td>a printf-style format string. Must not be nullptr. </td></tr>
    <tr><td class="paramname">ap</td><td>a <code>va_list</code> values to be used with the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes in the newly-allocated string, not counting the null-terminator char, or a negative value on error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga4402ec18128560a4643446630b3a4633" name="ga4402ec18128560a4643446630b3a4633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4402ec18128560a4643446630b3a4633">&#9670;&#160;</a></span>vsnprintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::vsnprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_PRINTF_FORMAT_STRING const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Functions identically to <a class="el" href="group__CategoryStdinc.html#ga57b48f04ae9e3949774b9f0c9dc0c151" title="This works exactly like snprintf() but doesn&#39;t require access to a C runtime.">snprintf()</a>, except it takes a <code>va_list</code> instead of using <code>...</code> variable arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>the buffer to write the string into. Must not be nullptr. </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum bytes to write, including the null-terminator. </td></tr>
    <tr><td class="paramname">fmt</td><td>a printf-style format string. Must not be nullptr. </td></tr>
    <tr><td class="paramname">ap</td><td>a <code>va_list</code> values to be used with the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that should be written, not counting the null-terminator char, or a negative value on error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gac1c131187ea64c08ed8abb3d04551072" name="gac1c131187ea64c08ed8abb3d04551072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1c131187ea64c08ed8abb3d04551072">&#9670;&#160;</a></span>vsscanf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::vsscanf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParam.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_SCANF_FORMAT_STRING const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Functions identically to <a class="el" href="group__CategoryStdinc.html#ga592054168270da087e8630cac0df2530" title="This works exactly like sscanf() but doesn&#39;t require access to a C runtime.">sscanf()</a>, except it takes a <code>va_list</code> instead of using <code>...</code> variable arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>the string to scan. Must not be nullptr. </td></tr>
    <tr><td class="paramname">fmt</td><td>a printf-style format string. Must not be nullptr. </td></tr>
    <tr><td class="paramname">ap</td><td>a <code>va_list</code> of pointers to values to be filled in with scanned items. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of items that matched the format string.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga83409fe8ca79edcf997ebfcda6226a5a" name="ga83409fe8ca79edcf997ebfcda6226a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83409fe8ca79edcf997ebfcda6226a5a">&#9670;&#160;</a></span>vswprintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::vswprintf </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_PRINTF_FORMAT_STRING const wchar_t *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Functions identically to <a class="el" href="group__CategoryStdinc.html#ga90fbec4327cabf79747426483a3f24cd" title="This works exactly like swprintf() but doesn&#39;t require access to a C runtime.">swprintf()</a>, except it takes a <code>va_list</code> instead of using <code>...</code> variable arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>the buffer to write the string into. Must not be nullptr. </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum wide characters to write, including the null-terminator. </td></tr>
    <tr><td class="paramname">fmt</td><td>a printf-style format wide string. Must not be nullptr. </td></tr>
    <tr><td class="paramname">ap</td><td>a <code>va_list</code> values to be used with the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of wide characters that should be written, not counting the null-terminator char, or a negative value on error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gae24c494fab206e9aa27dfd9c04b35e81" name="gae24c494fab206e9aa27dfd9c04b35e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae24c494fab206e9aa27dfd9c04b35e81">&#9670;&#160;</a></span>wcscasecmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::wcscasecmp </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will work with Unicode strings, using a technique called "case-folding" to handle the vast majority of case-sensitive human languages regardless of system locale. It can deal with expanding values: a German Eszett character can compare against two ASCII 's' chars and be considered a match, for example. A notable exception: it does not handle the Turkish 'i' character; human language is complicated!</p>
<p>Depending on your platform, "wchar_t" might be 2 bytes, and expected to be UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this handles Unicode, it expects the string to be well-formed and not a null-terminated string of arbitrary bytes. Characters that are not valid UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT CHARACTER), which is to say two strings of random bits may turn out to match if they convert to the same amount of replacement characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. nullptr is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. nullptr is not permitted! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga9edc1299fb56e51101501e09aaaa5b1f" name="ga9edc1299fb56e51101501e09aaaa5b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9edc1299fb56e51101501e09aaaa5b1f">&#9670;&#160;</a></span>wcscmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::wcscmp </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This only compares wchar_t values until it hits a null-terminating character; it does not care if the string is well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size), or uses valid Unicode values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. nullptr is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. nullptr is not permitted! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga26f89af82ddb65cb934e2c3dc6abb807" name="ga26f89af82ddb65cb934e2c3dc6abb807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26f89af82ddb65cb934e2c3dc6abb807">&#9670;&#160;</a></span>wcsdup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t * SDL::wcsdup </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>wstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This allocates enough space for a null-terminated copy of <code>wstr</code>, using malloc, and then makes a copy of the string into this space.</p>
<p>The returned string is owned by the caller, and should be passed to free when no longer needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstr</td><td>the string to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly-allocated wide string.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaeebfd8bdc9570592d8c1a5083f5d6893" name="gaeebfd8bdc9570592d8c1a5083f5d6893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeebfd8bdc9570592d8c1a5083f5d6893">&#9670;&#160;</a></span>wcslcat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::wcslcat </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function appends up to <code>maxlen</code> - wcslen(dst) - 1 wide characters from <code>src</code> to the end of the wide string in <code>dst</code>, then appends a null terminator.</p>
<p><code>src</code> and <code>dst</code> must not overlap.</p>
<p>If <code>maxlen</code> - wcslen(dst) - 1 is less than or equal to 0, then <code>dst</code> is unmodified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination buffer already containing the first null-terminated wide string. Must not be nullptr and must not overlap with <code>src</code>. </td></tr>
    <tr><td class="paramname">src</td><td>The second null-terminated wide string. Must not be nullptr, and must not overlap with <code>dst</code>. </td></tr>
    <tr><td class="paramname">maxlen</td><td>The length (in wide characters) of the destination buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in wide characters, excluding the null terminator) of the string in <code>dst</code> plus the length of <code>src</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gaaa4a6075598ac1d2db01c28f76bf8c08" title="Copy a wide string.">wcslcpy</a> </dd></dl>

</div>
</div>
<a id="gaaa4a6075598ac1d2db01c28f76bf8c08" name="gaaa4a6075598ac1d2db01c28f76bf8c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa4a6075598ac1d2db01c28f76bf8c08">&#9670;&#160;</a></span>wcslcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::wcslcpy </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function copies <code>maxlen</code> - 1 wide characters from <code>src</code> to <code>dst</code>, then appends a null terminator.</p>
<p><code>src</code> and <code>dst</code> must not overlap.</p>
<p>If <code>maxlen</code> is 0, no wide characters are copied and no null terminator is written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination buffer. Must not be nullptr, and must not overlap with <code>src</code>. </td></tr>
    <tr><td class="paramname">src</td><td>The null-terminated wide string to copy. Must not be nullptr, and must not overlap with <code>dst</code>. </td></tr>
    <tr><td class="paramname">maxlen</td><td>The length (in wide characters) of the destination buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in wide characters, excluding the null terminator) of <code>src</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gaeebfd8bdc9570592d8c1a5083f5d6893" title="Concatenate wide strings.">wcslcat</a> </dd></dl>

</div>
</div>
<a id="gafaba3e78b66aee106f48c80864156f0a" name="gafaba3e78b66aee106f48c80864156f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaba3e78b66aee106f48c80864156f0a">&#9670;&#160;</a></span>wcslen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::wcslen </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>wstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts the number of wchar_t values in <code>wstr</code>, excluding the null terminator.</p>
<p>Like strlen only counts bytes and not codepoints in a UTF-8 string, this counts wchar_t values in a string, even if the string's encoding is of variable width, like UTF-16.</p>
<p>Also be aware that wchar_t is different sizes on different platforms (4 bytes on Linux, 2 on Windows, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstr</td><td>The null-terminated wide string to read. Must not be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in wchar_t values, excluding the null terminator) of <code>wstr</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga83f6331afec19491a73e0f711d7b3faf" title="This works exactly like wcsnlen() but doesn&#39;t require access to a C runtime.">wcsnlen</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga81767a08005a153d60b63896c58c106f" title="Count the number of codepoints in a UTF-8 string.">utf8strlen</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga82960b752efedfdd3cbfcf166d06161e" title="Count the number of codepoints in a UTF-8 string, up to n bytes.">utf8strnlen</a> </dd></dl>

</div>
</div>
<a id="gaaf1b8559eb793e57181bf418af47d555" name="gaaf1b8559eb793e57181bf418af47d555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf1b8559eb793e57181bf418af47d555">&#9670;&#160;</a></span>wcsncasecmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::wcsncasecmp </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will work with Unicode strings, using a technique called "case-folding" to handle the vast majority of case-sensitive human languages regardless of system locale. It can deal with expanding values: a German Eszett character can compare against two ASCII 's' chars and be considered a match, for example. A notable exception: it does not handle the Turkish 'i' character; human language is complicated!</p>
<p>Depending on your platform, "wchar_t" might be 2 bytes, and expected to be UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this handles Unicode, it expects the string to be well-formed and not a null-terminated string of arbitrary bytes. Characters that are not valid UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT CHARACTER), which is to say two strings of random bits may turn out to match if they convert to the same amount of replacement characters.</p>
<p>Note that while this function might deal with variable-sized characters, <code>maxlen</code> specifies a <em>wchar</em> limit! If the limit lands in the middle of a multi-byte UTF-16 sequence, it may convert a portion of the final character to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not to overflow a buffer.</p>
<p><code>maxlen</code> specifies a maximum number of wchar_t values to compare; if the strings match to this number of wchar_t (or both have matched to a null-terminator character before this number of bytes), they will be considered equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. nullptr is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. nullptr is not permitted! </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum number of wchar_t values to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga00de271aaf6fd8a464c34b16f7b419ff" name="ga00de271aaf6fd8a464c34b16f7b419ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00de271aaf6fd8a464c34b16f7b419ff">&#9670;&#160;</a></span>wcsncmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::wcsncmp </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This only compares wchar_t values; it does not care if the string is well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size), or uses valid Unicode values.</p>
<p>Note that while this function is intended to be used with UTF-16 (or UTF-32, depending on your platform's definition of wchar_t), it is comparing raw wchar_t values and not Unicode codepoints: <code>maxlen</code> specifies a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16 sequence, it will only compare a portion of the final character.</p>
<p><code>maxlen</code> specifies a maximum number of wchar_t to compare; if the strings match to this number of wide chars (or both have matched to a null-terminator character before this count), they will be considered equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. nullptr is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. nullptr is not permitted! </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum number of wchar_t to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga83f6331afec19491a73e0f711d7b3faf" name="ga83f6331afec19491a73e0f711d7b3faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83f6331afec19491a73e0f711d7b3faf">&#9670;&#160;</a></span>wcsnlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::wcsnlen </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>wstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts up to a maximum of <code>maxlen</code> wchar_t values in <code>wstr</code>, excluding the null terminator.</p>
<p>Like strnlen only counts bytes and not codepoints in a UTF-8 string, this counts wchar_t values in a string, even if the string's encoding is of variable width, like UTF-16.</p>
<p>Also be aware that wchar_t is different sizes on different platforms (4 bytes on Linux, 2 on Windows, etc).</p>
<p>Also, <code>maxlen</code> is a count of wide characters, not bytes!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstr</td><td>The null-terminated wide string to read. Must not be nullptr. </td></tr>
    <tr><td class="paramname">maxlen</td><td>The maximum amount of wide characters to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in wide characters, excluding the null terminator) of <code>wstr</code> but never more than <code>maxlen</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gafaba3e78b66aee106f48c80864156f0a" title="This works exactly like wcslen() but doesn&#39;t require access to a C runtime.">wcslen</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga81767a08005a153d60b63896c58c106f" title="Count the number of codepoints in a UTF-8 string.">utf8strlen</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga82960b752efedfdd3cbfcf166d06161e" title="Count the number of codepoints in a UTF-8 string, up to n bytes.">utf8strnlen</a> </dd></dl>

</div>
</div>
<a id="gacc794d23fc0f8b51d4abbcf226e6d7c7" name="gacc794d23fc0f8b51d4abbcf226e6d7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc794d23fc0f8b51d4abbcf226e6d7c7">&#9670;&#160;</a></span>wcsnstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t * SDL::wcsnstr </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The search ends once it finds the requested substring, or a null terminator value to end the string, or <code>maxlen</code> wide character have been examined. It is possible to use this function on a wide string without a null terminator.</p>
<p>Note that this looks for strings of <em>wide characters</em>, not <em>codepoints</em>, so it's legal to search for malformed and incomplete UTF-16 sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>the wide string to search. Must not be nullptr. </td></tr>
    <tr><td class="paramname">needle</td><td>the wide string to search for. Must not be nullptr. </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum number of wide characters to search in <code>haystack</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first instance of <code>needle</code> in the string, or nullptr if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gad864d11d477fc831eb7fcd5a40fbe615" name="gad864d11d477fc831eb7fcd5a40fbe615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad864d11d477fc831eb7fcd5a40fbe615">&#9670;&#160;</a></span>wcsstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t * SDL::wcsstr </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The search ends once it finds the requested substring, or a null terminator byte to end the string.</p>
<p>Note that this looks for strings of <em>wide characters</em>, not <em>codepoints</em>, so it's legal to search for malformed and incomplete UTF-16 sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>the wide string to search. Must not be nullptr. </td></tr>
    <tr><td class="paramname">needle</td><td>the wide string to search for. Must not be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first instance of <code>needle</code> in the string, or nullptr if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga0408a155d55fa0fc2d0198de99ca0dc4" name="ga0408a155d55fa0fc2d0198de99ca0dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0408a155d55fa0fc2d0198de99ca0dc4">&#9670;&#160;</a></span>wcstol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long SDL::wcstol </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t **&#160;</td>
          <td class="paramname"><em>endp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If <code>str</code> starts with whitespace, then those whitespace characters are skipped before attempting to parse the number.</p>
<p>If the parsed number does not fit inside a <code>long</code>, the result is clamped to the minimum and maximum representable <code>long</code> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated wide string to read. Must not be nullptr. </td></tr>
    <tr><td class="paramname">endp</td><td>If not nullptr, the address of the first invalid wide character (i.e. the next character after the parsed number) will be written to this pointer. </td></tr>
    <tr><td class="paramname">base</td><td>The base of the integer to read. Supported values are 0 and 2 to 36 inclusive. If 0, the base will be inferred from the number's prefix (0x for hexadecimal, 0 for octal, decimal otherwise). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed <code>long</code>, or 0 if no number could be parsed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gaf270570877b7a6ccaea59ba90b428043" title="Parse a long from a string.">strtol</a> </dd></dl>

</div>
</div>
<a id="ga4d65aa4051722f968f6fde80d47d761f" name="ga4d65aa4051722f968f6fde80d47d761f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d65aa4051722f968f6fde80d47d761f">&#9670;&#160;</a></span>zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::zero </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is wrapper over memset that handles calculating the object size, so there's no chance of copy/paste errors, and the code is cleaner.</p>
<p>This requires an object, not a pointer to an object, nor an array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the object to clear.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this macro from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gab0fc530b6aa46072077289b0a200c21c" title="Clear an object&#39;s memory to zero, using a pointer.">zerop</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga51ba04c3b473e95c7808a55669162521" title="Clear an array&#39;s memory to zero.">zeroa</a> </dd></dl>

</div>
</div>
<a id="ga51ba04c3b473e95c7808a55669162521" name="ga51ba04c3b473e95c7808a55669162521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51ba04c3b473e95c7808a55669162521">&#9670;&#160;</a></span>zeroa()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::zeroa </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>x</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is wrapper over memset that handles calculating the array size, so there's no chance of copy/paste errors, and the code is cleaner.</p>
<p>This requires an array, not an object, nor a pointer to an object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>an array to clear.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga4d65aa4051722f968f6fde80d47d761f" title="Clear an object&#39;s memory to zero.">zero</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga51ba04c3b473e95c7808a55669162521" title="Clear an array&#39;s memory to zero.">zeroa</a> </dd></dl>

</div>
</div>
<a id="gab0fc530b6aa46072077289b0a200c21c" name="gab0fc530b6aa46072077289b0a200c21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0fc530b6aa46072077289b0a200c21c">&#9670;&#160;</a></span>zerop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::zerop </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is wrapper over memset that handles calculating the object size, so there's no chance of copy/paste errors, and the code is cleaner.</p>
<p>This requires a pointer to an object, not an object itself, nor an array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>a pointer to the object to clear.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this macro from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga4d65aa4051722f968f6fde80d47d761f" title="Clear an object&#39;s memory to zero.">zero</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga51ba04c3b473e95c7808a55669162521" title="Clear an array&#39;s memory to zero.">zeroa</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga225b1359489202f60aa60f936b02887b" name="ga225b1359489202f60aa60f936b02887b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga225b1359489202f60aa60f936b02887b">&#9670;&#160;</a></span>INVALID_UNICODE_CODEPOINT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Uint32 SDL::INVALID_UNICODE_CODEPOINT = SDL_INVALID_UNICODE_CODEPOINT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="group__CategoryStdinc.html#gaa5ecf11cf256372f67e10fafdd79141e" title="Decode a UTF-8 string, one Unicode codepoint at a time.">StepUTF8()</a> and <a class="el" href="group__CategoryStdinc.html#gaaa1607ee6b5fddfb7d22eb518dbe59a4" title="Decode a UTF-8 string in reverse, one Unicode codepoint at a time.">StepBackUTF8()</a> report this codepoint when they encounter a UTF-8 string with encoding errors.</p>
<p>This tends to render as something like a question mark in most places.</p>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gaaa1607ee6b5fddfb7d22eb518dbe59a4" title="Decode a UTF-8 string in reverse, one Unicode codepoint at a time.">StepBackUTF8</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaa5ecf11cf256372f67e10fafdd79141e" title="Decode a UTF-8 string, one Unicode codepoint at a time.">StepUTF8</a> </dd></dl>

</div>
</div>
<a id="ga912f78e2db3c323780c18a973369ff93" name="ga912f78e2db3c323780c18a973369ff93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga912f78e2db3c323780c18a973369ff93">&#9670;&#160;</a></span>PI_D</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double SDL::PI_D = SDL_PI_D</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gad5e09344042b57279887d6cb38cb6c67" title="The value of Pi, as a single-precision floating point literal.">PI_F</a> </dd></dl>

</div>
</div>
<a id="gad5e09344042b57279887d6cb38cb6c67" name="gad5e09344042b57279887d6cb38cb6c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5e09344042b57279887d6cb38cb6c67">&#9670;&#160;</a></span>PI_F</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float SDL::PI_F = SDL_PI_F</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga912f78e2db3c323780c18a973369ff93" title="The value of Pi, as a double-precision floating point literal.">PI_D</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
