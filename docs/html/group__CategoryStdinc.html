<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDL3pp: Standard Library Functionality</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SDL3pp
   </div>
   <div id="projectbrief">A slim C++ wrapper for SDL3</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__CategoryStdinc.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Standard Library Functionality<div class="ingroups"><a class="el" href="group__Categories.html">Categories</a> &raquo; <a class="el" href="group__CategoriesAdditionalFunctionality.html">Additional Functionality</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> provides its own implementation of some of the most important C runtime functions.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Standard Library Functionality:</div>
<div class="dyncontent">
<div class="center"><img src="group__CategoryStdinc.png" border="0" usemap="#agroup____CategoryStdinc" alt=""/></div>
<map name="agroup____CategoryStdinc" id="agroup____CategoryStdinc">
<area shape="rect" href="group__CategoriesAdditionalFunctionality.html" title=" " alt="" coords="5,22,181,47"/>
<area shape="rect" title="SDL provides its own implementation of some of the most important C runtime functions." alt="" coords="231,22,448,47"/>
<area shape="rect" href="group__resource.html" title="A Resource is a type where its memory is controlled by SDL, usually with functions like SDL_Create*()..." alt="" coords="645,22,728,47"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1EnvironmentBase.html">SDL::EnvironmentBase&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread-safe set of environment variables.  <a href="structSDL_1_1EnvironmentBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1ObjectDeleter_3_01SDL__Environment_01_4.html">SDL::ObjectDeleter&lt; SDL_Environment &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IConvBase.html">SDL::IConvBase&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque handle representing string encoding conversion state.  <a href="structSDL_1_1IConvBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1ObjectDeleter_3_01SDL__iconv__data__t_01_4.html">SDL::ObjectDeleter&lt; SDL_iconv_data_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga61951c691e5b53e2c5261c8f3536531e" id="r_ga61951c691e5b53e2c5261c8f3536531e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga61951c691e5b53e2c5261c8f3536531e">SDL::EnvironmentRef</a> = <a class="el" href="structSDL_1_1EnvironmentBase.html">EnvironmentBase</a>&lt; <a class="el" href="classSDL_1_1ObjectRef.html">ObjectRef</a>&lt; <a class="el" href="classSDL_1_1OptionalRef.html">SDL_Environment</a> &gt; &gt;</td></tr>
<tr class="separator:ga61951c691e5b53e2c5261c8f3536531e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedb86e9b9bb1aca04f73942d06b1d98f" id="r_gaedb86e9b9bb1aca04f73942d06b1d98f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaedb86e9b9bb1aca04f73942d06b1d98f">SDL::Environment</a> = <a class="el" href="structSDL_1_1EnvironmentBase.html">EnvironmentBase</a>&lt; <a class="el" href="classSDL_1_1ObjectUnique.html">ObjectUnique</a>&lt; <a class="el" href="classSDL_1_1OptionalRef.html">SDL_Environment</a> &gt; &gt;</td></tr>
<tr class="separator:gaedb86e9b9bb1aca04f73942d06b1d98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d2eecfc83ea54cacb89f4fec27fa0b0" id="r_ga3d2eecfc83ea54cacb89f4fec27fa0b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga3d2eecfc83ea54cacb89f4fec27fa0b0">SDL::IConvRef</a> = <a class="el" href="structSDL_1_1IConvBase.html">IConvBase</a>&lt; <a class="el" href="classSDL_1_1ObjectRef.html">ObjectRef</a>&lt; <a class="el" href="classSDL_1_1OptionalRef.html">SDL_iconv_data_t</a> &gt; &gt;</td></tr>
<tr class="separator:ga3d2eecfc83ea54cacb89f4fec27fa0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95fcbc65252fd494d78ce162e1340bea" id="r_ga95fcbc65252fd494d78ce162e1340bea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga95fcbc65252fd494d78ce162e1340bea">SDL::IConv</a> = <a class="el" href="structSDL_1_1IConvBase.html">IConvBase</a>&lt; <a class="el" href="classSDL_1_1ObjectUnique.html">ObjectUnique</a>&lt; <a class="el" href="classSDL_1_1OptionalRef.html">SDL_iconv_data_t</a> &gt; &gt;</td></tr>
<tr class="separator:ga95fcbc65252fd494d78ce162e1340bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cdca510cc08a5569b9e76462e19242f" id="r_ga4cdca510cc08a5569b9e76462e19242f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga4cdca510cc08a5569b9e76462e19242f">SDL::Time</a> = <a class="el" href="classSDL_1_1OptionalRef.html">SDL_Time</a></td></tr>
<tr class="memdesc:ga4cdca510cc08a5569b9e76462e19242f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> times are signed, 64-bit integers representing nanoseconds since the Unix epoch (Jan 1, 1970).  <br /></td></tr>
<tr class="separator:ga4cdca510cc08a5569b9e76462e19242f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20e849be3a477a832c3f5b49aa71f793" id="r_ga20e849be3a477a832c3f5b49aa71f793"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">SDL::malloc_func</a> = <a class="el" href="classSDL_1_1OptionalRef.html">SDL_malloc_func</a></td></tr>
<tr class="memdesc:ga20e849be3a477a832c3f5b49aa71f793"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback used to implement SDL_malloc().  <br /></td></tr>
<tr class="separator:ga20e849be3a477a832c3f5b49aa71f793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f2714c0d9540b5e1e85ed5503c59215" id="r_ga4f2714c0d9540b5e1e85ed5503c59215"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">SDL::calloc_func</a> = <a class="el" href="classSDL_1_1OptionalRef.html">SDL_calloc_func</a></td></tr>
<tr class="memdesc:ga4f2714c0d9540b5e1e85ed5503c59215"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback used to implement SDL_calloc().  <br /></td></tr>
<tr class="separator:ga4f2714c0d9540b5e1e85ed5503c59215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0d42a4ebfbbe5ab7908f55ba0560ecb" id="r_gaa0d42a4ebfbbe5ab7908f55ba0560ecb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">SDL::realloc_func</a> = <a class="el" href="classSDL_1_1OptionalRef.html">SDL_realloc_func</a></td></tr>
<tr class="memdesc:gaa0d42a4ebfbbe5ab7908f55ba0560ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback used to implement SDL_realloc().  <br /></td></tr>
<tr class="separator:gaa0d42a4ebfbbe5ab7908f55ba0560ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80cbbb5b121c8f78d44a66deaa573127" id="r_ga80cbbb5b121c8f78d44a66deaa573127"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">SDL::free_func</a> = <a class="el" href="classSDL_1_1OptionalRef.html">SDL_free_func</a></td></tr>
<tr class="memdesc:ga80cbbb5b121c8f78d44a66deaa573127"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback used to implement SDL_free().  <br /></td></tr>
<tr class="separator:ga80cbbb5b121c8f78d44a66deaa573127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc94be94823c25031d6dd9210ef3e81a" id="r_gabc94be94823c25031d6dd9210ef3e81a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gabc94be94823c25031d6dd9210ef3e81a">SDL::CompareCallback</a> = <a class="el" href="classSDL_1_1OptionalRef.html">SDL_CompareCallback</a></td></tr>
<tr class="memdesc:gabc94be94823c25031d6dd9210ef3e81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback used with <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> sorting and binary search functions.  <br /></td></tr>
<tr class="separator:gabc94be94823c25031d6dd9210ef3e81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5c634ea2ae9a102fa58cd7beac9f478" id="r_gab5c634ea2ae9a102fa58cd7beac9f478"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab5c634ea2ae9a102fa58cd7beac9f478">SDL::CompareCallback_r</a> = <a class="el" href="classSDL_1_1OptionalRef.html">SDL_CompareCallback_r</a></td></tr>
<tr class="memdesc:gab5c634ea2ae9a102fa58cd7beac9f478"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback used with <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> sorting and binary search functions.  <br /></td></tr>
<tr class="separator:gab5c634ea2ae9a102fa58cd7beac9f478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga379a3713730374c4737a2bfb2004fab7" id="r_ga379a3713730374c4737a2bfb2004fab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga379a3713730374c4737a2bfb2004fab7">SDL::FunctionPointer</a> = <a class="el" href="classSDL_1_1OptionalRef.html">SDL_FunctionPointer</a></td></tr>
<tr class="memdesc:ga379a3713730374c4737a2bfb2004fab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic function pointer.  <br /></td></tr>
<tr class="separator:ga379a3713730374c4737a2bfb2004fab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa932b3872f6162d7257c924b184e5381" id="r_gaa932b3872f6162d7257c924b184e5381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">constexpr</a> <a class="el" href="classSDL_1_1OptionalRef.html">Uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa932b3872f6162d7257c924b184e5381">SDL::FourCC</a> (<a class="el" href="classSDL_1_1OptionalRef.html">Uint8</a> <a class="el" href="classSDL_1_1OptionalRef.html">a</a>, <a class="el" href="classSDL_1_1OptionalRef.html">Uint8</a> <a class="el" href="classSDL_1_1OptionalRef.html">b</a>, <a class="el" href="classSDL_1_1OptionalRef.html">Uint8</a> <a class="el" href="classSDL_1_1OptionalRef.html">c</a>, <a class="el" href="classSDL_1_1OptionalRef.html">Uint8</a> <a class="el" href="classSDL_1_1OptionalRef.html">d</a>)</td></tr>
<tr class="memdesc:gaa932b3872f6162d7257c924b184e5381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a four character code as a Uint32.  <br /></td></tr>
<tr class="separator:gaa932b3872f6162d7257c924b184e5381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48fe5521cb77ff8e4ae442bc8387be70" id="r_ga48fe5521cb77ff8e4ae442bc8387be70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga48fe5521cb77ff8e4ae442bc8387be70">SDL::malloc</a> (<a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> size)</td></tr>
<tr class="memdesc:ga48fe5521cb77ff8e4ae442bc8387be70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate uninitialized memory.  <br /></td></tr>
<tr class="separator:ga48fe5521cb77ff8e4ae442bc8387be70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab24b3e9482f5a1c26602b83f2de05d09" id="r_gab24b3e9482f5a1c26602b83f2de05d09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab24b3e9482f5a1c26602b83f2de05d09">SDL::calloc</a> (<a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">nmemb</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> size)</td></tr>
<tr class="memdesc:gab24b3e9482f5a1c26602b83f2de05d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a zero-initialized array.  <br /></td></tr>
<tr class="separator:gab24b3e9482f5a1c26602b83f2de05d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8208c1b381e6a96b07b5facff79c27b" id="r_gab8208c1b381e6a96b07b5facff79c27b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab8208c1b381e6a96b07b5facff79c27b">SDL::realloc</a> (<a class="el" href="classSDL_1_1OptionalRef.html">void</a> *<a class="el" href="classSDL_1_1OptionalRef.html">mem</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> size)</td></tr>
<tr class="memdesc:gab8208c1b381e6a96b07b5facff79c27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the size of allocated memory.  <br /></td></tr>
<tr class="separator:gab8208c1b381e6a96b07b5facff79c27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfa01257ca1f966fffb72f002db27fa6" id="r_gadfa01257ca1f966fffb72f002db27fa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gadfa01257ca1f966fffb72f002db27fa6">SDL::free</a> (<a class="el" href="classSDL_1_1OptionalRef.html">void</a> *<a class="el" href="classSDL_1_1OptionalRef.html">mem</a>)</td></tr>
<tr class="memdesc:gadfa01257ca1f966fffb72f002db27fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free allocated memory.  <br /></td></tr>
<tr class="separator:gadfa01257ca1f966fffb72f002db27fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6325f645ab936554e7aaa2e4d977d9d7" id="r_ga6325f645ab936554e7aaa2e4d977d9d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga6325f645ab936554e7aaa2e4d977d9d7">SDL::GetOriginalMemoryFunctions</a> (<a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a> *<a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a>, <a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a> *<a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a>, <a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a> *<a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a>, <a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a> *<a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a>)</td></tr>
<tr class="memdesc:ga6325f645ab936554e7aaa2e4d977d9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the original set of <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> memory functions.  <br /></td></tr>
<tr class="separator:ga6325f645ab936554e7aaa2e4d977d9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab331691e9cf41b2fd9063b80910ea6b0" id="r_gab331691e9cf41b2fd9063b80910ea6b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab331691e9cf41b2fd9063b80910ea6b0">SDL::GetMemoryFunctions</a> (<a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a> *<a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a>, <a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a> *<a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a>, <a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a> *<a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a>, <a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a> *<a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a>)</td></tr>
<tr class="memdesc:gab331691e9cf41b2fd9063b80910ea6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current set of <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> memory functions.  <br /></td></tr>
<tr class="separator:gab331691e9cf41b2fd9063b80910ea6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga953e2e3777cf98a58ebbf96ee66bdddb" id="r_ga953e2e3777cf98a58ebbf96ee66bdddb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga953e2e3777cf98a58ebbf96ee66bdddb">SDL::SetMemoryFunctions</a> (<a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a> <a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a>, <a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a> <a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a>, <a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a> <a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a>, <a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a> <a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a>)</td></tr>
<tr class="memdesc:ga953e2e3777cf98a58ebbf96ee66bdddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a>'s memory allocation functions with a custom set.  <br /></td></tr>
<tr class="separator:ga953e2e3777cf98a58ebbf96ee66bdddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3c9f70ddeadaecb2afeee2b3be34733" id="r_gae3c9f70ddeadaecb2afeee2b3be34733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae3c9f70ddeadaecb2afeee2b3be34733">SDL::aligned_alloc</a> (<a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">alignment</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> size)</td></tr>
<tr class="memdesc:gae3c9f70ddeadaecb2afeee2b3be34733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory aligned to a specific alignment.  <br /></td></tr>
<tr class="separator:gae3c9f70ddeadaecb2afeee2b3be34733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf1efed697d82742be084a1871c95aa2" id="r_gaaf1efed697d82742be084a1871c95aa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaaf1efed697d82742be084a1871c95aa2">SDL::aligned_free</a> (<a class="el" href="classSDL_1_1OptionalRef.html">void</a> *<a class="el" href="classSDL_1_1OptionalRef.html">mem</a>)</td></tr>
<tr class="memdesc:gaaf1efed697d82742be084a1871c95aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated by SDL_aligned_alloc().  <br /></td></tr>
<tr class="separator:gaaf1efed697d82742be084a1871c95aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae51ea510815eaec3a9b288754a805206" id="r_gae51ea510815eaec3a9b288754a805206"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae51ea510815eaec3a9b288754a805206">SDL::GetNumAllocations</a> ()</td></tr>
<tr class="memdesc:gae51ea510815eaec3a9b288754a805206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of outstanding (unfreed) allocations.  <br /></td></tr>
<tr class="separator:gae51ea510815eaec3a9b288754a805206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc9e4411ee1c8072c58cbfa0566a5660" id="r_gafc9e4411ee1c8072c58cbfa0566a5660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategoryStdinc.html#ga61951c691e5b53e2c5261c8f3536531e">EnvironmentRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gafc9e4411ee1c8072c58cbfa0566a5660">SDL::GetEnvironment</a> ()</td></tr>
<tr class="memdesc:gafc9e4411ee1c8072c58cbfa0566a5660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the process environment.  <br /></td></tr>
<tr class="separator:gafc9e4411ee1c8072c58cbfa0566a5660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97502b219bb63f4be0f31868fecc9120" id="r_ga97502b219bb63f4be0f31868fecc9120"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga97502b219bb63f4be0f31868fecc9120">SDL::getenv</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">name</a>)</td></tr>
<tr class="memdesc:ga97502b219bb63f4be0f31868fecc9120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a variable in the environment.  <br /></td></tr>
<tr class="separator:ga97502b219bb63f4be0f31868fecc9120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a55c001e123a53e424cbc460ec4b1b6" id="r_ga8a55c001e123a53e424cbc460ec4b1b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8a55c001e123a53e424cbc460ec4b1b6">SDL::getenv_unsafe</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">name</a>)</td></tr>
<tr class="memdesc:ga8a55c001e123a53e424cbc460ec4b1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a variable in the environment.  <br /></td></tr>
<tr class="separator:ga8a55c001e123a53e424cbc460ec4b1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97da5abe6c940c70b73fc9465cf8e75e" id="r_ga97da5abe6c940c70b73fc9465cf8e75e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga97da5abe6c940c70b73fc9465cf8e75e">SDL::setenv_unsafe</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">name</a>, <a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> value, <a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">overwrite</a>)</td></tr>
<tr class="memdesc:ga97da5abe6c940c70b73fc9465cf8e75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a variable in the environment.  <br /></td></tr>
<tr class="separator:ga97da5abe6c940c70b73fc9465cf8e75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dc726179e2ae431d7db8164099e333a" id="r_ga7dc726179e2ae431d7db8164099e333a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga7dc726179e2ae431d7db8164099e333a">SDL::unsetenv_unsafe</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">name</a>)</td></tr>
<tr class="memdesc:ga7dc726179e2ae431d7db8164099e333a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a variable from the environment.  <br /></td></tr>
<tr class="separator:ga7dc726179e2ae431d7db8164099e333a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab52a0ec3d96fb4c04972b1b322f75857" id="r_gab52a0ec3d96fb4c04972b1b322f75857"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab52a0ec3d96fb4c04972b1b322f75857">SDL::qsort</a> (<a class="el" href="classSDL_1_1OptionalRef.html">void</a> *<a class="el" href="classSDL_1_1OptionalRef.html">base</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">nmemb</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> size, <a class="el" href="group__CategoryStdinc.html#gabc94be94823c25031d6dd9210ef3e81a">CompareCallback</a> <a class="el" href="classSDL_1_1OptionalRef.html">compare</a>)</td></tr>
<tr class="memdesc:gab52a0ec3d96fb4c04972b1b322f75857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an array.  <br /></td></tr>
<tr class="separator:gab52a0ec3d96fb4c04972b1b322f75857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada62aea13b8eceffa3e57359e124e541" id="r_gada62aea13b8eceffa3e57359e124e541"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gada62aea13b8eceffa3e57359e124e541">SDL::bsearch</a> (<a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *<a class="el" href="classSDL_1_1OptionalRef.html">key</a>, <a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *<a class="el" href="classSDL_1_1OptionalRef.html">base</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">nmemb</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> size, <a class="el" href="group__CategoryStdinc.html#gabc94be94823c25031d6dd9210ef3e81a">CompareCallback</a> <a class="el" href="classSDL_1_1OptionalRef.html">compare</a>)</td></tr>
<tr class="memdesc:gada62aea13b8eceffa3e57359e124e541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a binary search on a previously sorted array.  <br /></td></tr>
<tr class="separator:gada62aea13b8eceffa3e57359e124e541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3b0083aa5cb6236224048d437834dd2" id="r_gaa3b0083aa5cb6236224048d437834dd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa3b0083aa5cb6236224048d437834dd2">SDL::qsort_r</a> (<a class="el" href="classSDL_1_1OptionalRef.html">void</a> *<a class="el" href="classSDL_1_1OptionalRef.html">base</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">nmemb</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> size, <a class="el" href="group__CategoryStdinc.html#gab5c634ea2ae9a102fa58cd7beac9f478">CompareCallback_r</a> <a class="el" href="classSDL_1_1OptionalRef.html">compare</a>, <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *<a class="el" href="classSDL_1_1OptionalRef.html">userdata</a>)</td></tr>
<tr class="memdesc:gaa3b0083aa5cb6236224048d437834dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an array, passing a userdata pointer to the compare function.  <br /></td></tr>
<tr class="separator:gaa3b0083aa5cb6236224048d437834dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf22f982867b4598c8caa2de8f5a9e0e4" id="r_gaf22f982867b4598c8caa2de8f5a9e0e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaf22f982867b4598c8caa2de8f5a9e0e4">SDL::bsearch_r</a> (<a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *<a class="el" href="classSDL_1_1OptionalRef.html">key</a>, <a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *<a class="el" href="classSDL_1_1OptionalRef.html">base</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">nmemb</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> size, <a class="el" href="group__CategoryStdinc.html#gab5c634ea2ae9a102fa58cd7beac9f478">CompareCallback_r</a> <a class="el" href="classSDL_1_1OptionalRef.html">compare</a>, <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *<a class="el" href="classSDL_1_1OptionalRef.html">userdata</a>)</td></tr>
<tr class="memdesc:gaf22f982867b4598c8caa2de8f5a9e0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a binary search on a previously sorted array, passing a userdata pointer to the compare function.  <br /></td></tr>
<tr class="separator:gaf22f982867b4598c8caa2de8f5a9e0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab188f3aa930df339c851b95bf2c4030b" id="r_gab188f3aa930df339c851b95bf2c4030b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab188f3aa930df339c851b95bf2c4030b">SDL::abs</a> (<a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:gab188f3aa930df339c851b95bf2c4030b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of <code>x</code>.  <br /></td></tr>
<tr class="separator:gab188f3aa930df339c851b95bf2c4030b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79256765fa0f219b5947721d1d920041" id="r_ga79256765fa0f219b5947721d1d920041"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga79256765fa0f219b5947721d1d920041">SDL::isalpha</a> (<a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga79256765fa0f219b5947721d1d920041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if a character is alphabetic (a letter).  <br /></td></tr>
<tr class="separator:ga79256765fa0f219b5947721d1d920041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc3565e81c3ab6ba0e66f9030c056969" id="r_gafc3565e81c3ab6ba0e66f9030c056969"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gafc3565e81c3ab6ba0e66f9030c056969">SDL::isalnum</a> (<a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:gafc3565e81c3ab6ba0e66f9030c056969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if a character is alphabetic (a letter) or a number.  <br /></td></tr>
<tr class="separator:gafc3565e81c3ab6ba0e66f9030c056969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6936f2d259cb2959c3d73e8bb66cf0d" id="r_gab6936f2d259cb2959c3d73e8bb66cf0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab6936f2d259cb2959c3d73e8bb66cf0d">SDL::isblank</a> (<a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:gab6936f2d259cb2959c3d73e8bb66cf0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is blank (a space or tab).  <br /></td></tr>
<tr class="separator:gab6936f2d259cb2959c3d73e8bb66cf0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga901f942513d4469f8722185f0cee85bd" id="r_ga901f942513d4469f8722185f0cee85bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga901f942513d4469f8722185f0cee85bd">SDL::iscntrl</a> (<a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga901f942513d4469f8722185f0cee85bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is a control character.  <br /></td></tr>
<tr class="separator:ga901f942513d4469f8722185f0cee85bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c4d5430375fa896b58aa1e5a23cd30f" id="r_ga3c4d5430375fa896b58aa1e5a23cd30f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga3c4d5430375fa896b58aa1e5a23cd30f">SDL::isdigit</a> (<a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga3c4d5430375fa896b58aa1e5a23cd30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is a numeric digit.  <br /></td></tr>
<tr class="separator:ga3c4d5430375fa896b58aa1e5a23cd30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73d02f4f146603a906c35d50197f6fd6" id="r_ga73d02f4f146603a906c35d50197f6fd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga73d02f4f146603a906c35d50197f6fd6">SDL::isxdigit</a> (<a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga73d02f4f146603a906c35d50197f6fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is a hexadecimal digit.  <br /></td></tr>
<tr class="separator:ga73d02f4f146603a906c35d50197f6fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1876da5600f8722288dc8641d978fab" id="r_gac1876da5600f8722288dc8641d978fab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gac1876da5600f8722288dc8641d978fab">SDL::ispunct</a> (<a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:gac1876da5600f8722288dc8641d978fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is a punctuation mark.  <br /></td></tr>
<tr class="separator:gac1876da5600f8722288dc8641d978fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga922904215a42f639a8385470d5e61667" id="r_ga922904215a42f639a8385470d5e61667"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga922904215a42f639a8385470d5e61667">SDL::isspace</a> (<a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga922904215a42f639a8385470d5e61667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is whitespace.  <br /></td></tr>
<tr class="separator:ga922904215a42f639a8385470d5e61667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83e29996414dc34dd0fb76a16669f05f" id="r_ga83e29996414dc34dd0fb76a16669f05f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga83e29996414dc34dd0fb76a16669f05f">SDL::isupper</a> (<a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga83e29996414dc34dd0fb76a16669f05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is upper case.  <br /></td></tr>
<tr class="separator:ga83e29996414dc34dd0fb76a16669f05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9154645a2881fcb9f6c1df5c4d848ef1" id="r_ga9154645a2881fcb9f6c1df5c4d848ef1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga9154645a2881fcb9f6c1df5c4d848ef1">SDL::islower</a> (<a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga9154645a2881fcb9f6c1df5c4d848ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is lower case.  <br /></td></tr>
<tr class="separator:ga9154645a2881fcb9f6c1df5c4d848ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ff81eceb17060ed3c3c7c32a14bf7b8" id="r_ga6ff81eceb17060ed3c3c7c32a14bf7b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga6ff81eceb17060ed3c3c7c32a14bf7b8">SDL::isprint</a> (<a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga6ff81eceb17060ed3c3c7c32a14bf7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is "printable".  <br /></td></tr>
<tr class="separator:ga6ff81eceb17060ed3c3c7c32a14bf7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28e4c655a653424f510993ddec5b02b4" id="r_ga28e4c655a653424f510993ddec5b02b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga28e4c655a653424f510993ddec5b02b4">SDL::isgraph</a> (<a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga28e4c655a653424f510993ddec5b02b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is any "printable" except space.  <br /></td></tr>
<tr class="separator:ga28e4c655a653424f510993ddec5b02b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa66528bfccd7f5a86ed7554d049d1930" id="r_gaa66528bfccd7f5a86ed7554d049d1930"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa66528bfccd7f5a86ed7554d049d1930">SDL::toupper</a> (<a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:gaa66528bfccd7f5a86ed7554d049d1930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert low-ASCII English letters to uppercase.  <br /></td></tr>
<tr class="separator:gaa66528bfccd7f5a86ed7554d049d1930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f89764775d85be34bed2bc447d543a" id="r_ga77f89764775d85be34bed2bc447d543a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga77f89764775d85be34bed2bc447d543a">SDL::tolower</a> (<a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga77f89764775d85be34bed2bc447d543a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert low-ASCII English letters to lowercase.  <br /></td></tr>
<tr class="separator:ga77f89764775d85be34bed2bc447d543a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31ee6fbdefd2ca34bbde4c8652069e66" id="r_ga31ee6fbdefd2ca34bbde4c8652069e66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">Uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga31ee6fbdefd2ca34bbde4c8652069e66">SDL::crc16</a> (<a class="el" href="classSDL_1_1OptionalRef.html">Uint16</a> <a class="el" href="classSDL_1_1OptionalRef.html">crc</a>, <a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *data, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">len</a>)</td></tr>
<tr class="memdesc:ga31ee6fbdefd2ca34bbde4c8652069e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a CRC-16 value.  <br /></td></tr>
<tr class="separator:ga31ee6fbdefd2ca34bbde4c8652069e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc8b8bc6d26dd888c3fed721ddb1cd2e" id="r_gacc8b8bc6d26dd888c3fed721ddb1cd2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">Uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gacc8b8bc6d26dd888c3fed721ddb1cd2e">SDL::crc32</a> (<a class="el" href="classSDL_1_1OptionalRef.html">Uint32</a> <a class="el" href="classSDL_1_1OptionalRef.html">crc</a>, <a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *data, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">len</a>)</td></tr>
<tr class="memdesc:gacc8b8bc6d26dd888c3fed721ddb1cd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a CRC-32 value.  <br /></td></tr>
<tr class="separator:gacc8b8bc6d26dd888c3fed721ddb1cd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa75ce9d0d0b590cd55fce1604bb40824" id="r_gaa75ce9d0d0b590cd55fce1604bb40824"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">Uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa75ce9d0d0b590cd55fce1604bb40824">SDL::murmur3_32</a> (<a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *data, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">len</a>, <a class="el" href="classSDL_1_1OptionalRef.html">Uint32</a> <a class="el" href="classSDL_1_1OptionalRef.html">seed</a>)</td></tr>
<tr class="memdesc:gaa75ce9d0d0b590cd55fce1604bb40824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a 32-bit MurmurHash3 value for a block of data.  <br /></td></tr>
<tr class="separator:gaa75ce9d0d0b590cd55fce1604bb40824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe27508f0dcd3fb7902725b46f1c7e15" id="r_gafe27508f0dcd3fb7902725b46f1c7e15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gafe27508f0dcd3fb7902725b46f1c7e15">SDL::memcpy</a> (<a class="el" href="classSDL_1_1OptionalRef.html">void</a> *<a class="el" href="classSDL_1_1OptionalRef.html">dst</a>, <a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *<a class="el" href="classSDL_1_1OptionalRef.html">src</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">len</a>)</td></tr>
<tr class="memdesc:gafe27508f0dcd3fb7902725b46f1c7e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy non-overlapping memory.  <br /></td></tr>
<tr class="separator:gafe27508f0dcd3fb7902725b46f1c7e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga166c29b5162d190b0002720452a5ef43" id="r_ga166c29b5162d190b0002720452a5ef43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga166c29b5162d190b0002720452a5ef43">SDL::memmove</a> (<a class="el" href="classSDL_1_1OptionalRef.html">void</a> *<a class="el" href="classSDL_1_1OptionalRef.html">dst</a>, <a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *<a class="el" href="classSDL_1_1OptionalRef.html">src</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">len</a>)</td></tr>
<tr class="memdesc:ga166c29b5162d190b0002720452a5ef43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy memory ranges that might overlap.  <br /></td></tr>
<tr class="separator:ga166c29b5162d190b0002720452a5ef43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a6487beb5a07d1110c8afe1fe030446" id="r_ga5a6487beb5a07d1110c8afe1fe030446"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga5a6487beb5a07d1110c8afe1fe030446">SDL::memset</a> (<a class="el" href="classSDL_1_1OptionalRef.html">void</a> *<a class="el" href="classSDL_1_1OptionalRef.html">dst</a>, <a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">c</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">len</a>)</td></tr>
<tr class="memdesc:ga5a6487beb5a07d1110c8afe1fe030446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize all bytes of buffer of memory to a specific value.  <br /></td></tr>
<tr class="separator:ga5a6487beb5a07d1110c8afe1fe030446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e06e75cea4ef203bf1f3c967f8bff54" id="r_ga8e06e75cea4ef203bf1f3c967f8bff54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8e06e75cea4ef203bf1f3c967f8bff54">SDL::memset4</a> (<a class="el" href="classSDL_1_1OptionalRef.html">void</a> *<a class="el" href="classSDL_1_1OptionalRef.html">dst</a>, <a class="el" href="classSDL_1_1OptionalRef.html">Uint32</a> <a class="el" href="classSDL_1_1OptionalRef.html">val</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">dwords</a>)</td></tr>
<tr class="memdesc:ga8e06e75cea4ef203bf1f3c967f8bff54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize all 32-bit words of buffer of memory to a specific value.  <br /></td></tr>
<tr class="separator:ga8e06e75cea4ef203bf1f3c967f8bff54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1713911979192a927ee8202ad4ed478b" id="r_ga1713911979192a927ee8202ad4ed478b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga1713911979192a927ee8202ad4ed478b">SDL::memcmp</a> (<a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *<a class="el" href="classSDL_1_1OptionalRef.html">s1</a>, <a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *<a class="el" href="classSDL_1_1OptionalRef.html">s2</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">len</a>)</td></tr>
<tr class="memdesc:ga1713911979192a927ee8202ad4ed478b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two buffers of memory.  <br /></td></tr>
<tr class="separator:ga1713911979192a927ee8202ad4ed478b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaba3e78b66aee106f48c80864156f0a" id="r_gafaba3e78b66aee106f48c80864156f0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gafaba3e78b66aee106f48c80864156f0a">SDL::wcslen</a> (<a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">wstr</a>)</td></tr>
<tr class="memdesc:gafaba3e78b66aee106f48c80864156f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#gafaba3e78b66aee106f48c80864156f0a" title="This works exactly like wcslen() but doesn&#39;t require access to a C runtime.">wcslen()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:gafaba3e78b66aee106f48c80864156f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83f6331afec19491a73e0f711d7b3faf" id="r_ga83f6331afec19491a73e0f711d7b3faf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga83f6331afec19491a73e0f711d7b3faf">SDL::wcsnlen</a> (<a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">wstr</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">maxlen</a>)</td></tr>
<tr class="memdesc:ga83f6331afec19491a73e0f711d7b3faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga83f6331afec19491a73e0f711d7b3faf" title="This works exactly like wcsnlen() but doesn&#39;t require access to a C runtime.">wcsnlen()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga83f6331afec19491a73e0f711d7b3faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa4a6075598ac1d2db01c28f76bf8c08" id="r_gaaa4a6075598ac1d2db01c28f76bf8c08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaaa4a6075598ac1d2db01c28f76bf8c08">SDL::wcslcpy</a> (<a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">dst</a>, <a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">src</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">maxlen</a>)</td></tr>
<tr class="memdesc:gaaa4a6075598ac1d2db01c28f76bf8c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a wide string.  <br /></td></tr>
<tr class="separator:gaaa4a6075598ac1d2db01c28f76bf8c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeebfd8bdc9570592d8c1a5083f5d6893" id="r_gaeebfd8bdc9570592d8c1a5083f5d6893"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaeebfd8bdc9570592d8c1a5083f5d6893">SDL::wcslcat</a> (<a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">dst</a>, <a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">src</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">maxlen</a>)</td></tr>
<tr class="memdesc:gaeebfd8bdc9570592d8c1a5083f5d6893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate wide strings.  <br /></td></tr>
<tr class="separator:gaeebfd8bdc9570592d8c1a5083f5d6893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26f89af82ddb65cb934e2c3dc6abb807" id="r_ga26f89af82ddb65cb934e2c3dc6abb807"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga26f89af82ddb65cb934e2c3dc6abb807">SDL::wcsdup</a> (<a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">wstr</a>)</td></tr>
<tr class="memdesc:ga26f89af82ddb65cb934e2c3dc6abb807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a copy of a wide string.  <br /></td></tr>
<tr class="separator:ga26f89af82ddb65cb934e2c3dc6abb807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad864d11d477fc831eb7fcd5a40fbe615" id="r_gad864d11d477fc831eb7fcd5a40fbe615"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gad864d11d477fc831eb7fcd5a40fbe615">SDL::wcsstr</a> (<a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">haystack</a>, <a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">needle</a>)</td></tr>
<tr class="memdesc:gad864d11d477fc831eb7fcd5a40fbe615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a wide string for the first instance of a specific substring.  <br /></td></tr>
<tr class="separator:gad864d11d477fc831eb7fcd5a40fbe615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc794d23fc0f8b51d4abbcf226e6d7c7" id="r_gacc794d23fc0f8b51d4abbcf226e6d7c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gacc794d23fc0f8b51d4abbcf226e6d7c7">SDL::wcsnstr</a> (<a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">haystack</a>, <a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">needle</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">maxlen</a>)</td></tr>
<tr class="memdesc:gacc794d23fc0f8b51d4abbcf226e6d7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a wide string, up to n wide chars, for the first instance of a specific substring.  <br /></td></tr>
<tr class="separator:gacc794d23fc0f8b51d4abbcf226e6d7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9edc1299fb56e51101501e09aaaa5b1f" id="r_ga9edc1299fb56e51101501e09aaaa5b1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga9edc1299fb56e51101501e09aaaa5b1f">SDL::wcscmp</a> (<a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">str1</a>, <a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">str2</a>)</td></tr>
<tr class="memdesc:ga9edc1299fb56e51101501e09aaaa5b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two null-terminated wide strings.  <br /></td></tr>
<tr class="separator:ga9edc1299fb56e51101501e09aaaa5b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00de271aaf6fd8a464c34b16f7b419ff" id="r_ga00de271aaf6fd8a464c34b16f7b419ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga00de271aaf6fd8a464c34b16f7b419ff">SDL::wcsncmp</a> (<a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">str1</a>, <a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">str2</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">maxlen</a>)</td></tr>
<tr class="memdesc:ga00de271aaf6fd8a464c34b16f7b419ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two wide strings up to a number of wchar_t values.  <br /></td></tr>
<tr class="separator:ga00de271aaf6fd8a464c34b16f7b419ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae24c494fab206e9aa27dfd9c04b35e81" id="r_gae24c494fab206e9aa27dfd9c04b35e81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae24c494fab206e9aa27dfd9c04b35e81">SDL::wcscasecmp</a> (<a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">str1</a>, <a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">str2</a>)</td></tr>
<tr class="memdesc:gae24c494fab206e9aa27dfd9c04b35e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two null-terminated wide strings, case-insensitively.  <br /></td></tr>
<tr class="separator:gae24c494fab206e9aa27dfd9c04b35e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf1b8559eb793e57181bf418af47d555" id="r_gaaf1b8559eb793e57181bf418af47d555"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaaf1b8559eb793e57181bf418af47d555">SDL::wcsncasecmp</a> (<a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">str1</a>, <a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">str2</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">maxlen</a>)</td></tr>
<tr class="memdesc:gaaf1b8559eb793e57181bf418af47d555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two wide strings, case-insensitively, up to a number of wchar_t.  <br /></td></tr>
<tr class="separator:gaaf1b8559eb793e57181bf418af47d555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0408a155d55fa0fc2d0198de99ca0dc4" id="r_ga0408a155d55fa0fc2d0198de99ca0dc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga0408a155d55fa0fc2d0198de99ca0dc4">SDL::wcstol</a> (<a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">str</a>, <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> **<a class="el" href="classSDL_1_1OptionalRef.html">endp</a>, <a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">base</a>)</td></tr>
<tr class="memdesc:ga0408a155d55fa0fc2d0198de99ca0dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>long</code> from a wide string.  <br /></td></tr>
<tr class="separator:ga0408a155d55fa0fc2d0198de99ca0dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93de03cd7e1369ba80c5746761bac939" id="r_ga93de03cd7e1369ba80c5746761bac939"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga93de03cd7e1369ba80c5746761bac939">SDL::strlen</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str</a>)</td></tr>
<tr class="memdesc:ga93de03cd7e1369ba80c5746761bac939"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga93de03cd7e1369ba80c5746761bac939" title="This works exactly like strlen() but doesn&#39;t require access to a C runtime.">strlen()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga93de03cd7e1369ba80c5746761bac939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga929593393da0025b602c5b4560bce5bf" id="r_ga929593393da0025b602c5b4560bce5bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga929593393da0025b602c5b4560bce5bf">SDL::strnlen</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">maxlen</a>)</td></tr>
<tr class="memdesc:ga929593393da0025b602c5b4560bce5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga929593393da0025b602c5b4560bce5bf" title="This works exactly like strnlen() but doesn&#39;t require access to a C runtime.">strnlen()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga929593393da0025b602c5b4560bce5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga598ecc44c77a20ab4de3a96eda46ea76" id="r_ga598ecc44c77a20ab4de3a96eda46ea76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga598ecc44c77a20ab4de3a96eda46ea76">SDL::strlcpy</a> (<a class="el" href="classSDL_1_1OptionalRef.html">char</a> *<a class="el" href="classSDL_1_1OptionalRef.html">dst</a>, <a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">src</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">maxlen</a>)</td></tr>
<tr class="memdesc:ga598ecc44c77a20ab4de3a96eda46ea76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a string.  <br /></td></tr>
<tr class="separator:ga598ecc44c77a20ab4de3a96eda46ea76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ae726c47fde58d11167345dfda765a4" id="r_ga8ae726c47fde58d11167345dfda765a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8ae726c47fde58d11167345dfda765a4">SDL::utf8strlcpy</a> (<a class="el" href="classSDL_1_1OptionalRef.html">char</a> *<a class="el" href="classSDL_1_1OptionalRef.html">dst</a>, <a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">src</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">dst_bytes</a>)</td></tr>
<tr class="memdesc:ga8ae726c47fde58d11167345dfda765a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an UTF-8 string.  <br /></td></tr>
<tr class="separator:ga8ae726c47fde58d11167345dfda765a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga503a37a91faa4ed9374b9dd9db03049c" id="r_ga503a37a91faa4ed9374b9dd9db03049c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga503a37a91faa4ed9374b9dd9db03049c">SDL::strlcat</a> (<a class="el" href="classSDL_1_1OptionalRef.html">char</a> *<a class="el" href="classSDL_1_1OptionalRef.html">dst</a>, <a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">src</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">maxlen</a>)</td></tr>
<tr class="memdesc:ga503a37a91faa4ed9374b9dd9db03049c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate strings.  <br /></td></tr>
<tr class="separator:ga503a37a91faa4ed9374b9dd9db03049c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga046b80783770b59a2cf8b4311230fbbd" id="r_ga046b80783770b59a2cf8b4311230fbbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga046b80783770b59a2cf8b4311230fbbd">SDL::strdup</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str</a>)</td></tr>
<tr class="memdesc:ga046b80783770b59a2cf8b4311230fbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a copy of a string.  <br /></td></tr>
<tr class="separator:ga046b80783770b59a2cf8b4311230fbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53e0a0ce55852f1320bc292f72dc1398" id="r_ga53e0a0ce55852f1320bc292f72dc1398"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga53e0a0ce55852f1320bc292f72dc1398">SDL::strndup</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">maxlen</a>)</td></tr>
<tr class="memdesc:ga53e0a0ce55852f1320bc292f72dc1398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a copy of a string, up to n characters.  <br /></td></tr>
<tr class="separator:ga53e0a0ce55852f1320bc292f72dc1398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b6d922e9310ca993a82b84e692e8a5" id="r_ga32b6d922e9310ca993a82b84e692e8a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga32b6d922e9310ca993a82b84e692e8a5">SDL::strrev</a> (<a class="el" href="classSDL_1_1OptionalRef.html">char</a> *<a class="el" href="classSDL_1_1OptionalRef.html">str</a>)</td></tr>
<tr class="memdesc:ga32b6d922e9310ca993a82b84e692e8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse a string's contents.  <br /></td></tr>
<tr class="separator:ga32b6d922e9310ca993a82b84e692e8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fe290f18ce6025c454f0b62729c0662" id="r_ga7fe290f18ce6025c454f0b62729c0662"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga7fe290f18ce6025c454f0b62729c0662">SDL::strupr</a> (<a class="el" href="classSDL_1_1OptionalRef.html">char</a> *<a class="el" href="classSDL_1_1OptionalRef.html">str</a>)</td></tr>
<tr class="memdesc:ga7fe290f18ce6025c454f0b62729c0662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to uppercase.  <br /></td></tr>
<tr class="separator:ga7fe290f18ce6025c454f0b62729c0662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15eaa2ac05317f734e1f022cfc916201" id="r_ga15eaa2ac05317f734e1f022cfc916201"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga15eaa2ac05317f734e1f022cfc916201">SDL::strlwr</a> (<a class="el" href="classSDL_1_1OptionalRef.html">char</a> *<a class="el" href="classSDL_1_1OptionalRef.html">str</a>)</td></tr>
<tr class="memdesc:ga15eaa2ac05317f734e1f022cfc916201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to lowercase.  <br /></td></tr>
<tr class="separator:ga15eaa2ac05317f734e1f022cfc916201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga451b842c63a514775080900ae67150da" id="r_ga451b842c63a514775080900ae67150da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga451b842c63a514775080900ae67150da">SDL::strchr</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str</a>, <a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">c</a>)</td></tr>
<tr class="memdesc:ga451b842c63a514775080900ae67150da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a string for the first instance of a specific byte.  <br /></td></tr>
<tr class="separator:ga451b842c63a514775080900ae67150da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf67863ed8e432e74c417116a532ef24b" id="r_gaf67863ed8e432e74c417116a532ef24b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaf67863ed8e432e74c417116a532ef24b">SDL::strrchr</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str</a>, <a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">c</a>)</td></tr>
<tr class="memdesc:gaf67863ed8e432e74c417116a532ef24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a string for the last instance of a specific byte.  <br /></td></tr>
<tr class="separator:gaf67863ed8e432e74c417116a532ef24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ef7c9322f6766ee71172d34493ee792" id="r_ga3ef7c9322f6766ee71172d34493ee792"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga3ef7c9322f6766ee71172d34493ee792">SDL::strstr</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">haystack</a>, <a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">needle</a>)</td></tr>
<tr class="memdesc:ga3ef7c9322f6766ee71172d34493ee792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a string for the first instance of a specific substring.  <br /></td></tr>
<tr class="separator:ga3ef7c9322f6766ee71172d34493ee792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21c1bce04f407d4dab36722078978a9b" id="r_ga21c1bce04f407d4dab36722078978a9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga21c1bce04f407d4dab36722078978a9b">SDL::strnstr</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">haystack</a>, <a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">needle</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">maxlen</a>)</td></tr>
<tr class="memdesc:ga21c1bce04f407d4dab36722078978a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a string, up to n bytes, for the first instance of a specific substring.  <br /></td></tr>
<tr class="separator:ga21c1bce04f407d4dab36722078978a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d413500b6dc7d885777ecb0873c823e" id="r_ga0d413500b6dc7d885777ecb0873c823e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga0d413500b6dc7d885777ecb0873c823e">SDL::strcasestr</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">haystack</a>, <a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">needle</a>)</td></tr>
<tr class="memdesc:ga0d413500b6dc7d885777ecb0873c823e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a UTF-8 string for the first instance of a specific substring, case-insensitively.  <br /></td></tr>
<tr class="separator:ga0d413500b6dc7d885777ecb0873c823e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dc2ad6fd692f32f1304e9b1872881a2" id="r_ga8dc2ad6fd692f32f1304e9b1872881a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8dc2ad6fd692f32f1304e9b1872881a2">SDL::strtok_r</a> (<a class="el" href="classSDL_1_1OptionalRef.html">char</a> *<a class="el" href="classSDL_1_1OptionalRef.html">str</a>, <a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">delim</a>, <a class="el" href="classSDL_1_1OptionalRef.html">char</a> **<a class="el" href="classSDL_1_1OptionalRef.html">saveptr</a>)</td></tr>
<tr class="memdesc:ga8dc2ad6fd692f32f1304e9b1872881a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga8dc2ad6fd692f32f1304e9b1872881a2" title="This works exactly like strtok_r() but doesn&#39;t require access to a C runtime.">strtok_r()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga8dc2ad6fd692f32f1304e9b1872881a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81767a08005a153d60b63896c58c106f" id="r_ga81767a08005a153d60b63896c58c106f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga81767a08005a153d60b63896c58c106f">SDL::utf8strlen</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str</a>)</td></tr>
<tr class="memdesc:ga81767a08005a153d60b63896c58c106f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of codepoints in a UTF-8 string.  <br /></td></tr>
<tr class="separator:ga81767a08005a153d60b63896c58c106f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82960b752efedfdd3cbfcf166d06161e" id="r_ga82960b752efedfdd3cbfcf166d06161e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga82960b752efedfdd3cbfcf166d06161e">SDL::utf8strnlen</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">bytes</a>)</td></tr>
<tr class="memdesc:ga82960b752efedfdd3cbfcf166d06161e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of codepoints in a UTF-8 string, up to n bytes.  <br /></td></tr>
<tr class="separator:ga82960b752efedfdd3cbfcf166d06161e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0d19dc9f116d9f492fd4d17296f0c4b" id="r_gac0d19dc9f116d9f492fd4d17296f0c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gac0d19dc9f116d9f492fd4d17296f0c4b">SDL::itoa</a> (<a class="el" href="classSDL_1_1OptionalRef.html">int</a> value, <a class="el" href="classSDL_1_1OptionalRef.html">char</a> *<a class="el" href="classSDL_1_1OptionalRef.html">str</a>, <a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">radix</a>)</td></tr>
<tr class="memdesc:gac0d19dc9f116d9f492fd4d17296f0c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an integer into a string.  <br /></td></tr>
<tr class="separator:gac0d19dc9f116d9f492fd4d17296f0c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ca0851c2d9980695748c979e2d15608" id="r_ga6ca0851c2d9980695748c979e2d15608"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga6ca0851c2d9980695748c979e2d15608">SDL::uitoa</a> (<a class="el" href="classSDL_1_1OptionalRef.html">unsigned</a> <a class="el" href="classSDL_1_1OptionalRef.html">int</a> value, <a class="el" href="classSDL_1_1OptionalRef.html">char</a> *<a class="el" href="classSDL_1_1OptionalRef.html">str</a>, <a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">radix</a>)</td></tr>
<tr class="memdesc:ga6ca0851c2d9980695748c979e2d15608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an unsigned integer into a string.  <br /></td></tr>
<tr class="separator:ga6ca0851c2d9980695748c979e2d15608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee263ca33e533bf8acdd33b20e2323cf" id="r_gaee263ca33e533bf8acdd33b20e2323cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaee263ca33e533bf8acdd33b20e2323cf">SDL::ltoa</a> (<a class="el" href="classSDL_1_1OptionalRef.html">long</a> value, <a class="el" href="classSDL_1_1OptionalRef.html">char</a> *<a class="el" href="classSDL_1_1OptionalRef.html">str</a>, <a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">radix</a>)</td></tr>
<tr class="memdesc:gaee263ca33e533bf8acdd33b20e2323cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a long integer into a string.  <br /></td></tr>
<tr class="separator:gaee263ca33e533bf8acdd33b20e2323cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2450290efea2bebff1f164a6c4a04d38" id="r_ga2450290efea2bebff1f164a6c4a04d38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga2450290efea2bebff1f164a6c4a04d38">SDL::ultoa</a> (<a class="el" href="classSDL_1_1OptionalRef.html">unsigned</a> <a class="el" href="classSDL_1_1OptionalRef.html">long</a> value, <a class="el" href="classSDL_1_1OptionalRef.html">char</a> *<a class="el" href="classSDL_1_1OptionalRef.html">str</a>, <a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">radix</a>)</td></tr>
<tr class="memdesc:ga2450290efea2bebff1f164a6c4a04d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an unsigned long integer into a string.  <br /></td></tr>
<tr class="separator:ga2450290efea2bebff1f164a6c4a04d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddf03e9ff5a5c6ef2af0435fc32514b2" id="r_gaddf03e9ff5a5c6ef2af0435fc32514b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaddf03e9ff5a5c6ef2af0435fc32514b2">SDL::lltoa</a> (<a class="el" href="classSDL_1_1OptionalRef.html">long</a> <a class="el" href="classSDL_1_1OptionalRef.html">long</a> value, <a class="el" href="classSDL_1_1OptionalRef.html">char</a> *<a class="el" href="classSDL_1_1OptionalRef.html">str</a>, <a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">radix</a>)</td></tr>
<tr class="memdesc:gaddf03e9ff5a5c6ef2af0435fc32514b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a long long integer into a string.  <br /></td></tr>
<tr class="separator:gaddf03e9ff5a5c6ef2af0435fc32514b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac72cec45a7c35aeb116880203c1b03d9" id="r_gac72cec45a7c35aeb116880203c1b03d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gac72cec45a7c35aeb116880203c1b03d9">SDL::ulltoa</a> (<a class="el" href="classSDL_1_1OptionalRef.html">unsigned</a> <a class="el" href="classSDL_1_1OptionalRef.html">long</a> <a class="el" href="classSDL_1_1OptionalRef.html">long</a> value, <a class="el" href="classSDL_1_1OptionalRef.html">char</a> *<a class="el" href="classSDL_1_1OptionalRef.html">str</a>, <a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">radix</a>)</td></tr>
<tr class="memdesc:gac72cec45a7c35aeb116880203c1b03d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an unsigned long long integer into a string.  <br /></td></tr>
<tr class="separator:gac72cec45a7c35aeb116880203c1b03d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga756fd0202aa809d537fc01e28b0c7564" id="r_ga756fd0202aa809d537fc01e28b0c7564"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga756fd0202aa809d537fc01e28b0c7564">SDL::atoi</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str</a>)</td></tr>
<tr class="memdesc:ga756fd0202aa809d537fc01e28b0c7564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an <code>int</code> from a string.  <br /></td></tr>
<tr class="separator:ga756fd0202aa809d537fc01e28b0c7564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeecdd7ec80c303a7474d59b641a892f7" id="r_gaeecdd7ec80c303a7474d59b641a892f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaeecdd7ec80c303a7474d59b641a892f7">SDL::atof</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str</a>)</td></tr>
<tr class="memdesc:gaeecdd7ec80c303a7474d59b641a892f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>double</code> from a string.  <br /></td></tr>
<tr class="separator:gaeecdd7ec80c303a7474d59b641a892f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf270570877b7a6ccaea59ba90b428043" id="r_gaf270570877b7a6ccaea59ba90b428043"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaf270570877b7a6ccaea59ba90b428043">SDL::strtol</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str</a>, <a class="el" href="classSDL_1_1OptionalRef.html">char</a> **<a class="el" href="classSDL_1_1OptionalRef.html">endp</a>, <a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">base</a>)</td></tr>
<tr class="memdesc:gaf270570877b7a6ccaea59ba90b428043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>long</code> from a string.  <br /></td></tr>
<tr class="separator:gaf270570877b7a6ccaea59ba90b428043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3869ab21242a2a6fb41be41b382d2af2" id="r_ga3869ab21242a2a6fb41be41b382d2af2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">unsigned</a> <a class="el" href="classSDL_1_1OptionalRef.html">long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga3869ab21242a2a6fb41be41b382d2af2">SDL::strtoul</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str</a>, <a class="el" href="classSDL_1_1OptionalRef.html">char</a> **<a class="el" href="classSDL_1_1OptionalRef.html">endp</a>, <a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">base</a>)</td></tr>
<tr class="memdesc:ga3869ab21242a2a6fb41be41b382d2af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an <code>unsigned long</code> from a string.  <br /></td></tr>
<tr class="separator:ga3869ab21242a2a6fb41be41b382d2af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8211e3f409a3cc03272664dd24a5ebd0" id="r_ga8211e3f409a3cc03272664dd24a5ebd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">long</a> <a class="el" href="classSDL_1_1OptionalRef.html">long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8211e3f409a3cc03272664dd24a5ebd0">SDL::strtoll</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str</a>, <a class="el" href="classSDL_1_1OptionalRef.html">char</a> **<a class="el" href="classSDL_1_1OptionalRef.html">endp</a>, <a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">base</a>)</td></tr>
<tr class="memdesc:ga8211e3f409a3cc03272664dd24a5ebd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>long long</code> from a string.  <br /></td></tr>
<tr class="separator:ga8211e3f409a3cc03272664dd24a5ebd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca9ab3ab2d4ecbb7002814ae587227af" id="r_gaca9ab3ab2d4ecbb7002814ae587227af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">unsigned</a> <a class="el" href="classSDL_1_1OptionalRef.html">long</a> <a class="el" href="classSDL_1_1OptionalRef.html">long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaca9ab3ab2d4ecbb7002814ae587227af">SDL::strtoull</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str</a>, <a class="el" href="classSDL_1_1OptionalRef.html">char</a> **<a class="el" href="classSDL_1_1OptionalRef.html">endp</a>, <a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">base</a>)</td></tr>
<tr class="memdesc:gaca9ab3ab2d4ecbb7002814ae587227af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an <code>unsigned long long</code> from a string.  <br /></td></tr>
<tr class="separator:gaca9ab3ab2d4ecbb7002814ae587227af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga062de74e1950744ad5556cc815c58036" id="r_ga062de74e1950744ad5556cc815c58036"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga062de74e1950744ad5556cc815c58036">SDL::strtod</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str</a>, <a class="el" href="classSDL_1_1OptionalRef.html">char</a> **<a class="el" href="classSDL_1_1OptionalRef.html">endp</a>)</td></tr>
<tr class="memdesc:ga062de74e1950744ad5556cc815c58036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>double</code> from a string.  <br /></td></tr>
<tr class="separator:ga062de74e1950744ad5556cc815c58036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63d50d9f0b71b04e9b038f0bc71e54c3" id="r_ga63d50d9f0b71b04e9b038f0bc71e54c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga63d50d9f0b71b04e9b038f0bc71e54c3">SDL::strcmp</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str1</a>, <a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str2</a>)</td></tr>
<tr class="memdesc:ga63d50d9f0b71b04e9b038f0bc71e54c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two null-terminated UTF-8 strings.  <br /></td></tr>
<tr class="separator:ga63d50d9f0b71b04e9b038f0bc71e54c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2caad6bed5796e9524d07c21d4701af9" id="r_ga2caad6bed5796e9524d07c21d4701af9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga2caad6bed5796e9524d07c21d4701af9">SDL::strncmp</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str1</a>, <a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str2</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">maxlen</a>)</td></tr>
<tr class="memdesc:ga2caad6bed5796e9524d07c21d4701af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two UTF-8 strings up to a number of bytes.  <br /></td></tr>
<tr class="separator:ga2caad6bed5796e9524d07c21d4701af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga932cf2487365b3a3a6fd6e37a7eddff7" id="r_ga932cf2487365b3a3a6fd6e37a7eddff7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga932cf2487365b3a3a6fd6e37a7eddff7">SDL::strcasecmp</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str1</a>, <a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str2</a>)</td></tr>
<tr class="memdesc:ga932cf2487365b3a3a6fd6e37a7eddff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two null-terminated UTF-8 strings, case-insensitively.  <br /></td></tr>
<tr class="separator:ga932cf2487365b3a3a6fd6e37a7eddff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37191be89f79920285c912c0544150e8" id="r_ga37191be89f79920285c912c0544150e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga37191be89f79920285c912c0544150e8">SDL::strncasecmp</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str1</a>, <a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str2</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">maxlen</a>)</td></tr>
<tr class="memdesc:ga37191be89f79920285c912c0544150e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two UTF-8 strings, case-insensitively, up to a number of bytes.  <br /></td></tr>
<tr class="separator:ga37191be89f79920285c912c0544150e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3838c531e1c9bbee29cdf5f4ccb60b4" id="r_gae3838c531e1c9bbee29cdf5f4ccb60b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae3838c531e1c9bbee29cdf5f4ccb60b4">SDL::strpbrk</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">str</a>, <a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">breakset</a>)</td></tr>
<tr class="memdesc:gae3838c531e1c9bbee29cdf5f4ccb60b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches a string for the first occurence of any character contained in a breakset, and returns a pointer from the string to that character.  <br /></td></tr>
<tr class="separator:gae3838c531e1c9bbee29cdf5f4ccb60b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5ecf11cf256372f67e10fafdd79141e" id="r_gaa5ecf11cf256372f67e10fafdd79141e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">Uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa5ecf11cf256372f67e10fafdd79141e">SDL::StepUTF8</a> (<a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">char</a> **<a class="el" href="classSDL_1_1OptionalRef.html">pstr</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">pslen</a>)</td></tr>
<tr class="memdesc:gaa5ecf11cf256372f67e10fafdd79141e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a UTF-8 string, one Unicode codepoint at a time.  <br /></td></tr>
<tr class="separator:gaa5ecf11cf256372f67e10fafdd79141e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa1607ee6b5fddfb7d22eb518dbe59a4" id="r_gaaa1607ee6b5fddfb7d22eb518dbe59a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">Uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaaa1607ee6b5fddfb7d22eb518dbe59a4">SDL::StepBackUTF8</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">start</a>, <a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">char</a> **<a class="el" href="classSDL_1_1OptionalRef.html">pstr</a>)</td></tr>
<tr class="memdesc:gaaa1607ee6b5fddfb7d22eb518dbe59a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a UTF-8 string in reverse, one Unicode codepoint at a time.  <br /></td></tr>
<tr class="separator:gaaa1607ee6b5fddfb7d22eb518dbe59a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga032867626ec7d90baa207d817fdbddcf" id="r_ga032867626ec7d90baa207d817fdbddcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga032867626ec7d90baa207d817fdbddcf">SDL::UCS4ToUTF8</a> (<a class="el" href="classSDL_1_1OptionalRef.html">Uint32</a> <a class="el" href="classSDL_1_1OptionalRef.html">codepoint</a>, <a class="el" href="classSDL_1_1OptionalRef.html">char</a> *<a class="el" href="classSDL_1_1OptionalRef.html">dst</a>)</td></tr>
<tr class="memdesc:ga032867626ec7d90baa207d817fdbddcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a single Unicode codepoint to UTF-8.  <br /></td></tr>
<tr class="separator:ga032867626ec7d90baa207d817fdbddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85fc72ab5435901400efdaebc1187630" id="r_ga85fc72ab5435901400efdaebc1187630"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga85fc72ab5435901400efdaebc1187630">SDL::srand</a> (<a class="el" href="classSDL_1_1OptionalRef.html">Uint64</a> <a class="el" href="classSDL_1_1OptionalRef.html">seed</a>)</td></tr>
<tr class="memdesc:ga85fc72ab5435901400efdaebc1187630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seeds the pseudo-random number generator.  <br /></td></tr>
<tr class="separator:ga85fc72ab5435901400efdaebc1187630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0d119f7b42130eb3a652f7e243c8cf7" id="r_gaa0d119f7b42130eb3a652f7e243c8cf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">Sint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa0d119f7b42130eb3a652f7e243c8cf7">SDL::rand</a> (<a class="el" href="classSDL_1_1OptionalRef.html">Sint32</a> <a class="el" href="classSDL_1_1OptionalRef.html">n</a>)</td></tr>
<tr class="memdesc:gaa0d119f7b42130eb3a652f7e243c8cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pseudo-random number less than n for positive n.  <br /></td></tr>
<tr class="separator:gaa0d119f7b42130eb3a652f7e243c8cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab0a933463eebe63f34b3acec7e96c6e" id="r_gaab0a933463eebe63f34b3acec7e96c6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaab0a933463eebe63f34b3acec7e96c6e">SDL::randf</a> ()</td></tr>
<tr class="memdesc:gaab0a933463eebe63f34b3acec7e96c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a uniform pseudo-random floating point number less than 1.0.  <br /></td></tr>
<tr class="separator:gaab0a933463eebe63f34b3acec7e96c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6517052066ab937273e6a89c7d1eca8" id="r_gae6517052066ab937273e6a89c7d1eca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">Uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae6517052066ab937273e6a89c7d1eca8">SDL::rand_bits</a> ()</td></tr>
<tr class="memdesc:gae6517052066ab937273e6a89c7d1eca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate 32 pseudo-random bits.  <br /></td></tr>
<tr class="separator:gae6517052066ab937273e6a89c7d1eca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88a7882cb74660c593be8127ed18fb3b" id="r_ga88a7882cb74660c593be8127ed18fb3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">Sint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga88a7882cb74660c593be8127ed18fb3b">SDL::rand_r</a> (<a class="el" href="classSDL_1_1OptionalRef.html">Uint64</a> *<a class="el" href="classSDL_1_1OptionalRef.html">state</a>, <a class="el" href="classSDL_1_1OptionalRef.html">Sint32</a> <a class="el" href="classSDL_1_1OptionalRef.html">n</a>)</td></tr>
<tr class="memdesc:ga88a7882cb74660c593be8127ed18fb3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pseudo-random number less than n for positive n.  <br /></td></tr>
<tr class="separator:ga88a7882cb74660c593be8127ed18fb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bc84a2bf06f414f7d3f9bbbe9ee6bf9" id="r_ga6bc84a2bf06f414f7d3f9bbbe9ee6bf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga6bc84a2bf06f414f7d3f9bbbe9ee6bf9">SDL::randf_r</a> (<a class="el" href="classSDL_1_1OptionalRef.html">Uint64</a> *<a class="el" href="classSDL_1_1OptionalRef.html">state</a>)</td></tr>
<tr class="memdesc:ga6bc84a2bf06f414f7d3f9bbbe9ee6bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a uniform pseudo-random floating point number less than 1.0.  <br /></td></tr>
<tr class="separator:ga6bc84a2bf06f414f7d3f9bbbe9ee6bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fa067963ccb1728fb4e81abe36c46c6" id="r_ga5fa067963ccb1728fb4e81abe36c46c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">Uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga5fa067963ccb1728fb4e81abe36c46c6">SDL::rand_bits_r</a> (<a class="el" href="classSDL_1_1OptionalRef.html">Uint64</a> *<a class="el" href="classSDL_1_1OptionalRef.html">state</a>)</td></tr>
<tr class="memdesc:ga5fa067963ccb1728fb4e81abe36c46c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate 32 pseudo-random bits.  <br /></td></tr>
<tr class="separator:ga5fa067963ccb1728fb4e81abe36c46c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f6543d319422a6044570b59cc6377b4" id="r_ga9f6543d319422a6044570b59cc6377b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga9f6543d319422a6044570b59cc6377b4">SDL::acos</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga9f6543d319422a6044570b59cc6377b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc cosine of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga9f6543d319422a6044570b59cc6377b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e3b6760100280cb4cb51fcee4b3a2ff" id="r_ga8e3b6760100280cb4cb51fcee4b3a2ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8e3b6760100280cb4cb51fcee4b3a2ff">SDL::acosf</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga8e3b6760100280cb4cb51fcee4b3a2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc cosine of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga8e3b6760100280cb4cb51fcee4b3a2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga316a2eed1e595c002830ee628c1b4963" id="r_ga316a2eed1e595c002830ee628c1b4963"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga316a2eed1e595c002830ee628c1b4963">SDL::asin</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga316a2eed1e595c002830ee628c1b4963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc sine of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga316a2eed1e595c002830ee628c1b4963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga093ee4582ee6f6c02ab22c77718f56a8" id="r_ga093ee4582ee6f6c02ab22c77718f56a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga093ee4582ee6f6c02ab22c77718f56a8">SDL::asinf</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga093ee4582ee6f6c02ab22c77718f56a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc sine of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga093ee4582ee6f6c02ab22c77718f56a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11d0eaba28baba36fc8050f8541c8ee5" id="r_ga11d0eaba28baba36fc8050f8541c8ee5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga11d0eaba28baba36fc8050f8541c8ee5">SDL::atan</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga11d0eaba28baba36fc8050f8541c8ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc tangent of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga11d0eaba28baba36fc8050f8541c8ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19e239deb9997e2ff33bbfdbaec436b2" id="r_ga19e239deb9997e2ff33bbfdbaec436b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga19e239deb9997e2ff33bbfdbaec436b2">SDL::atanf</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga19e239deb9997e2ff33bbfdbaec436b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc tangent of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga19e239deb9997e2ff33bbfdbaec436b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0884b892c70d428cf50522d9791eb61" id="r_gae0884b892c70d428cf50522d9791eb61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae0884b892c70d428cf50522d9791eb61">SDL::atan2</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">y</a>, <a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:gae0884b892c70d428cf50522d9791eb61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc tangent of <code>y / x</code>, using the signs of x and y to adjust the result's quadrant.  <br /></td></tr>
<tr class="separator:gae0884b892c70d428cf50522d9791eb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1be31240212288c0d7556cf80340b93" id="r_gaf1be31240212288c0d7556cf80340b93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaf1be31240212288c0d7556cf80340b93">SDL::atan2f</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">y</a>, <a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:gaf1be31240212288c0d7556cf80340b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc tangent of <code>y / x</code>, using the signs of x and y to adjust the result's quadrant.  <br /></td></tr>
<tr class="separator:gaf1be31240212288c0d7556cf80340b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1567a1e6b1738fabc6252d7c52f03321" id="r_ga1567a1e6b1738fabc6252d7c52f03321"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga1567a1e6b1738fabc6252d7c52f03321">SDL::ceil</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga1567a1e6b1738fabc6252d7c52f03321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the ceiling of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga1567a1e6b1738fabc6252d7c52f03321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5962b17a629d7f973898e35e1818646f" id="r_ga5962b17a629d7f973898e35e1818646f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga5962b17a629d7f973898e35e1818646f">SDL::ceilf</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga5962b17a629d7f973898e35e1818646f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the ceiling of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga5962b17a629d7f973898e35e1818646f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga476595ece87ed3441c672348366f0adb" id="r_ga476595ece87ed3441c672348366f0adb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga476595ece87ed3441c672348366f0adb">SDL::copysign</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>, <a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">y</a>)</td></tr>
<tr class="memdesc:ga476595ece87ed3441c672348366f0adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the sign of one floating-point value to another.  <br /></td></tr>
<tr class="separator:ga476595ece87ed3441c672348366f0adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b8d2ae3c91e681437f9b8bad0d332dd" id="r_ga0b8d2ae3c91e681437f9b8bad0d332dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga0b8d2ae3c91e681437f9b8bad0d332dd">SDL::copysignf</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>, <a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">y</a>)</td></tr>
<tr class="memdesc:ga0b8d2ae3c91e681437f9b8bad0d332dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the sign of one floating-point value to another.  <br /></td></tr>
<tr class="separator:ga0b8d2ae3c91e681437f9b8bad0d332dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf8c80d673a05784387fa5e349a9f6dd" id="r_gadf8c80d673a05784387fa5e349a9f6dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gadf8c80d673a05784387fa5e349a9f6dd">SDL::cos</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:gadf8c80d673a05784387fa5e349a9f6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine of <code>x</code>.  <br /></td></tr>
<tr class="separator:gadf8c80d673a05784387fa5e349a9f6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga343b62c85d5c6bc9627fdad943860921" id="r_ga343b62c85d5c6bc9627fdad943860921"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga343b62c85d5c6bc9627fdad943860921">SDL::cosf</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga343b62c85d5c6bc9627fdad943860921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga343b62c85d5c6bc9627fdad943860921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e4417a78f0393e80fa7645a534a53a3" id="r_ga3e4417a78f0393e80fa7645a534a53a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga3e4417a78f0393e80fa7645a534a53a3">SDL::exp</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga3e4417a78f0393e80fa7645a534a53a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga3e4417a78f0393e80fa7645a534a53a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c6a34f6bfb50b176f502a6133880aa8" id="r_ga5c6a34f6bfb50b176f502a6133880aa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga5c6a34f6bfb50b176f502a6133880aa8">SDL::expf</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga5c6a34f6bfb50b176f502a6133880aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga5c6a34f6bfb50b176f502a6133880aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae57cb7c976b8596bb9ff76f3402a2488" id="r_gae57cb7c976b8596bb9ff76f3402a2488"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae57cb7c976b8596bb9ff76f3402a2488">SDL::fabs</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:gae57cb7c976b8596bb9ff76f3402a2488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of <code>x</code>  <br /></td></tr>
<tr class="separator:gae57cb7c976b8596bb9ff76f3402a2488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8952f2171107539c5cddb95fe5efec28" id="r_ga8952f2171107539c5cddb95fe5efec28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8952f2171107539c5cddb95fe5efec28">SDL::fabsf</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga8952f2171107539c5cddb95fe5efec28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of <code>x</code>  <br /></td></tr>
<tr class="separator:ga8952f2171107539c5cddb95fe5efec28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5d99939c5dffc37035e51300236316a" id="r_gaa5d99939c5dffc37035e51300236316a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa5d99939c5dffc37035e51300236316a">SDL::floor</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:gaa5d99939c5dffc37035e51300236316a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the floor of <code>x</code>.  <br /></td></tr>
<tr class="separator:gaa5d99939c5dffc37035e51300236316a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8438f2959083ee7e897f7f3ef03ca3b8" id="r_ga8438f2959083ee7e897f7f3ef03ca3b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8438f2959083ee7e897f7f3ef03ca3b8">SDL::floorf</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga8438f2959083ee7e897f7f3ef03ca3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the floor of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga8438f2959083ee7e897f7f3ef03ca3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb64b2b465e001720dce40bacec1b937" id="r_gaeb64b2b465e001720dce40bacec1b937"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaeb64b2b465e001720dce40bacec1b937">SDL::trunc</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:gaeb64b2b465e001720dce40bacec1b937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate <code>x</code> to an integer.  <br /></td></tr>
<tr class="separator:gaeb64b2b465e001720dce40bacec1b937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6b046a5844394a19061a8544376ffac" id="r_gae6b046a5844394a19061a8544376ffac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae6b046a5844394a19061a8544376ffac">SDL::truncf</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:gae6b046a5844394a19061a8544376ffac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate <code>x</code> to an integer.  <br /></td></tr>
<tr class="separator:gae6b046a5844394a19061a8544376ffac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcd6b0192bc061852ef8ef56272bf98d" id="r_gafcd6b0192bc061852ef8ef56272bf98d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gafcd6b0192bc061852ef8ef56272bf98d">SDL::fmod</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>, <a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">y</a>)</td></tr>
<tr class="memdesc:gafcd6b0192bc061852ef8ef56272bf98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floating-point remainder of <code>x / y</code>  <br /></td></tr>
<tr class="separator:gafcd6b0192bc061852ef8ef56272bf98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab12a77026e20d3235fab10d708ed80a6" id="r_gab12a77026e20d3235fab10d708ed80a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab12a77026e20d3235fab10d708ed80a6">SDL::fmodf</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>, <a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">y</a>)</td></tr>
<tr class="memdesc:gab12a77026e20d3235fab10d708ed80a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floating-point remainder of <code>x / y</code>  <br /></td></tr>
<tr class="separator:gab12a77026e20d3235fab10d708ed80a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga918f0e70e6e67f724c445eba4b514a21" id="r_ga918f0e70e6e67f724c445eba4b514a21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga918f0e70e6e67f724c445eba4b514a21">SDL::isinf</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga918f0e70e6e67f724c445eba4b514a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the value is infinity.  <br /></td></tr>
<tr class="separator:ga918f0e70e6e67f724c445eba4b514a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59c45f83103aa3fdc57244124dea7d5d" id="r_ga59c45f83103aa3fdc57244124dea7d5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga59c45f83103aa3fdc57244124dea7d5d">SDL::isinff</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga59c45f83103aa3fdc57244124dea7d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the value is infinity.  <br /></td></tr>
<tr class="separator:ga59c45f83103aa3fdc57244124dea7d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2221269e7ded0fb89af37aea9132e0b8" id="r_ga2221269e7ded0fb89af37aea9132e0b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga2221269e7ded0fb89af37aea9132e0b8">SDL::isnan</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga2221269e7ded0fb89af37aea9132e0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the value is NaN.  <br /></td></tr>
<tr class="separator:ga2221269e7ded0fb89af37aea9132e0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga945938b6b96f7b17c1916fe9d357a315" id="r_ga945938b6b96f7b17c1916fe9d357a315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga945938b6b96f7b17c1916fe9d357a315">SDL::isnanf</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga945938b6b96f7b17c1916fe9d357a315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the value is NaN.  <br /></td></tr>
<tr class="separator:ga945938b6b96f7b17c1916fe9d357a315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01c25ea063ceb75d5caf6ca1119a3bc1" id="r_ga01c25ea063ceb75d5caf6ca1119a3bc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga01c25ea063ceb75d5caf6ca1119a3bc1">SDL::log</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga01c25ea063ceb75d5caf6ca1119a3bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga01c25ea063ceb75d5caf6ca1119a3bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3482b1fa8e624f0f7e73ce89c0d5efb" id="r_gab3482b1fa8e624f0f7e73ce89c0d5efb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab3482b1fa8e624f0f7e73ce89c0d5efb">SDL::logf</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:gab3482b1fa8e624f0f7e73ce89c0d5efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of <code>x</code>.  <br /></td></tr>
<tr class="separator:gab3482b1fa8e624f0f7e73ce89c0d5efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdf9d94c27153da5d01b604342b49024" id="r_gacdf9d94c27153da5d01b604342b49024"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gacdf9d94c27153da5d01b604342b49024">SDL::log10</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:gacdf9d94c27153da5d01b604342b49024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the base-10 logarithm of <code>x</code>.  <br /></td></tr>
<tr class="separator:gacdf9d94c27153da5d01b604342b49024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8d69e4fc64b4c002aeffdf894aaa64f" id="r_gaa8d69e4fc64b4c002aeffdf894aaa64f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa8d69e4fc64b4c002aeffdf894aaa64f">SDL::log10f</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:gaa8d69e4fc64b4c002aeffdf894aaa64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the base-10 logarithm of <code>x</code>.  <br /></td></tr>
<tr class="separator:gaa8d69e4fc64b4c002aeffdf894aaa64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c97858f63954904f2037d7bc81b2681" id="r_ga4c97858f63954904f2037d7bc81b2681"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga4c97858f63954904f2037d7bc81b2681">SDL::modf</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>, <a class="el" href="classSDL_1_1OptionalRef.html">double</a> *<a class="el" href="classSDL_1_1OptionalRef.html">y</a>)</td></tr>
<tr class="memdesc:ga4c97858f63954904f2037d7bc81b2681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split <code>x</code> into integer and fractional parts.  <br /></td></tr>
<tr class="separator:ga4c97858f63954904f2037d7bc81b2681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0108470ee7d88fa093ddf12185060c10" id="r_ga0108470ee7d88fa093ddf12185060c10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga0108470ee7d88fa093ddf12185060c10">SDL::modff</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>, <a class="el" href="classSDL_1_1OptionalRef.html">float</a> *<a class="el" href="classSDL_1_1OptionalRef.html">y</a>)</td></tr>
<tr class="memdesc:ga0108470ee7d88fa093ddf12185060c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split <code>x</code> into integer and fractional parts.  <br /></td></tr>
<tr class="separator:ga0108470ee7d88fa093ddf12185060c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cfca7e593d97a56d7fca043af3ac2ce" id="r_ga6cfca7e593d97a56d7fca043af3ac2ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga6cfca7e593d97a56d7fca043af3ac2ce">SDL::pow</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>, <a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">y</a>)</td></tr>
<tr class="memdesc:ga6cfca7e593d97a56d7fca043af3ac2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise <code>x</code> to the power <code>y</code>  <br /></td></tr>
<tr class="separator:ga6cfca7e593d97a56d7fca043af3ac2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga652fc1da140490bb87abbbf05ccfe8fa" id="r_ga652fc1da140490bb87abbbf05ccfe8fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga652fc1da140490bb87abbbf05ccfe8fa">SDL::powf</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>, <a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">y</a>)</td></tr>
<tr class="memdesc:ga652fc1da140490bb87abbbf05ccfe8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise <code>x</code> to the power <code>y</code>  <br /></td></tr>
<tr class="separator:ga652fc1da140490bb87abbbf05ccfe8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58af56b2a9898c045c8ec62ec531c8e5" id="r_ga58af56b2a9898c045c8ec62ec531c8e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga58af56b2a9898c045c8ec62ec531c8e5">SDL::round</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga58af56b2a9898c045c8ec62ec531c8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round <code>x</code> to the nearest integer.  <br /></td></tr>
<tr class="separator:ga58af56b2a9898c045c8ec62ec531c8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cb3bb70b04800302620c3ebb81e901f" id="r_ga9cb3bb70b04800302620c3ebb81e901f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga9cb3bb70b04800302620c3ebb81e901f">SDL::roundf</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga9cb3bb70b04800302620c3ebb81e901f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round <code>x</code> to the nearest integer.  <br /></td></tr>
<tr class="separator:ga9cb3bb70b04800302620c3ebb81e901f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70024c43f89714b01cc1ff00baa682e0" id="r_ga70024c43f89714b01cc1ff00baa682e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga70024c43f89714b01cc1ff00baa682e0">SDL::lround</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga70024c43f89714b01cc1ff00baa682e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round <code>x</code> to the nearest integer representable as a long.  <br /></td></tr>
<tr class="separator:ga70024c43f89714b01cc1ff00baa682e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6878a0c3b6b75b7c15851c3dfe3d85df" id="r_ga6878a0c3b6b75b7c15851c3dfe3d85df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga6878a0c3b6b75b7c15851c3dfe3d85df">SDL::lroundf</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga6878a0c3b6b75b7c15851c3dfe3d85df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round <code>x</code> to the nearest integer representable as a long.  <br /></td></tr>
<tr class="separator:ga6878a0c3b6b75b7c15851c3dfe3d85df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2438009a4b8a2f4a9155a168f6cd8303" id="r_ga2438009a4b8a2f4a9155a168f6cd8303"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga2438009a4b8a2f4a9155a168f6cd8303">SDL::scalbn</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>, <a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">n</a>)</td></tr>
<tr class="memdesc:ga2438009a4b8a2f4a9155a168f6cd8303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale <code>x</code> by an integer power of two.  <br /></td></tr>
<tr class="separator:ga2438009a4b8a2f4a9155a168f6cd8303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52e712f14d91d7ecf74bd687a5458a6d" id="r_ga52e712f14d91d7ecf74bd687a5458a6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga52e712f14d91d7ecf74bd687a5458a6d">SDL::scalbnf</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>, <a class="el" href="classSDL_1_1OptionalRef.html">int</a> <a class="el" href="classSDL_1_1OptionalRef.html">n</a>)</td></tr>
<tr class="memdesc:ga52e712f14d91d7ecf74bd687a5458a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale <code>x</code> by an integer power of two.  <br /></td></tr>
<tr class="separator:ga52e712f14d91d7ecf74bd687a5458a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88bf16c79b920ce54e0ae909b2948663" id="r_ga88bf16c79b920ce54e0ae909b2948663"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga88bf16c79b920ce54e0ae909b2948663">SDL::sin</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga88bf16c79b920ce54e0ae909b2948663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sine of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga88bf16c79b920ce54e0ae909b2948663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab41ffcc72f47ca7757cdaa4a0844dd7c" id="r_gab41ffcc72f47ca7757cdaa4a0844dd7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab41ffcc72f47ca7757cdaa4a0844dd7c">SDL::sinf</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:gab41ffcc72f47ca7757cdaa4a0844dd7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sine of <code>x</code>.  <br /></td></tr>
<tr class="separator:gab41ffcc72f47ca7757cdaa4a0844dd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8415b71ce1045874d7b55210806ff3c8" id="r_ga8415b71ce1045874d7b55210806ff3c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8415b71ce1045874d7b55210806ff3c8">SDL::sqrt</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga8415b71ce1045874d7b55210806ff3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga8415b71ce1045874d7b55210806ff3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7c7e59d49d88aa05125fd347beeed63" id="r_gaf7c7e59d49d88aa05125fd347beeed63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaf7c7e59d49d88aa05125fd347beeed63">SDL::sqrtf</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:gaf7c7e59d49d88aa05125fd347beeed63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of <code>x</code>.  <br /></td></tr>
<tr class="separator:gaf7c7e59d49d88aa05125fd347beeed63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88b5a6adb928a623a97598a7a154432c" id="r_ga88b5a6adb928a623a97598a7a154432c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga88b5a6adb928a623a97598a7a154432c">SDL::tan</a> (<a class="el" href="classSDL_1_1OptionalRef.html">double</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:ga88b5a6adb928a623a97598a7a154432c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga88b5a6adb928a623a97598a7a154432c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf14c09ac379c8fa038a9fab209b9d4d7" id="r_gaf14c09ac379c8fa038a9fab209b9d4d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaf14c09ac379c8fa038a9fab209b9d4d7">SDL::tanf</a> (<a class="el" href="classSDL_1_1OptionalRef.html">float</a> <a class="el" href="classSDL_1_1OptionalRef.html">x</a>)</td></tr>
<tr class="memdesc:gaf14c09ac379c8fa038a9fab209b9d4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of <code>x</code>.  <br /></td></tr>
<tr class="separator:gaf14c09ac379c8fa038a9fab209b9d4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8101a1c19844c8cb72600a9aa6238327" id="r_ga8101a1c19844c8cb72600a9aa6238327"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8101a1c19844c8cb72600a9aa6238327">SDL::iconv_string</a> (<a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">tocode</a>, <a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">fromcode</a>, <a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a> <a class="el" href="classSDL_1_1OptionalRef.html">inbuf</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">inbytesleft</a>)</td></tr>
<tr class="memdesc:ga8101a1c19844c8cb72600a9aa6238327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to convert a string's encoding in one call.  <br /></td></tr>
<tr class="separator:ga8101a1c19844c8cb72600a9aa6238327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eff841be311c6243e4c36bc358e017f" id="r_ga5eff841be311c6243e4c36bc358e017f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga5eff841be311c6243e4c36bc358e017f">SDL::size_mul_check_overflow</a> (<a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">a</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">b</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">ret</a>)</td></tr>
<tr class="memdesc:ga5eff841be311c6243e4c36bc358e017f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two integers, checking for overflow.  <br /></td></tr>
<tr class="separator:ga5eff841be311c6243e4c36bc358e017f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a8cffac163d32a70c2a38ed43b8aed6" id="r_ga6a8cffac163d32a70c2a38ed43b8aed6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDL_1_1OptionalRef.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga6a8cffac163d32a70c2a38ed43b8aed6">SDL::size_add_check_overflow</a> (<a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">a</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> <a class="el" href="classSDL_1_1OptionalRef.html">b</a>, <a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> *<a class="el" href="classSDL_1_1OptionalRef.html">ret</a>)</td></tr>
<tr class="memdesc:ga6a8cffac163d32a70c2a38ed43b8aed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two integers, checking for overflow.  <br /></td></tr>
<tr class="separator:ga6a8cffac163d32a70c2a38ed43b8aed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> provides its own implementation of some of the most important C runtime functions. </p>
<p>Using these functions allows an app to have access to common C functionality without depending on a specific C runtime (or a C runtime at all). More importantly, the <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> implementations work identically across platforms, so apps can avoid surprises like snprintf() behaving differently between Windows and Linux builds, or <a class="el" href="group__CategoryStdinc.html#gac0d19dc9f116d9f492fd4d17296f0c4b" title="Convert an integer into a string.">itoa()</a> only existing on some platforms.</p>
<p>For many of the most common functions, like SDL_memcpy, <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> might just call through to the usual C runtime behind the scenes, if it makes sense to do so (if it's faster and always available/reliable on a given platform), reducing library size and offering the most optimized option.</p>
<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> also offers other C-runtime-adjacent functionality in this header that either isn't, strictly speaking, part of any C runtime standards, like SDL_crc32() and SDL_reinterpret_cast, etc. It also offers a few better options, like SDL_strlcpy(), which functions as a safer form of strcpy(). </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga4f2714c0d9540b5e1e85ed5503c59215" name="ga4f2714c0d9540b5e1e85ed5503c59215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f2714c0d9540b5e1e85ed5503c59215">&#9670;&#160;</a></span>calloc_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">using</a> <a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">SDL::calloc_func</a> = <a class="el" href="classSDL_1_1OptionalRef.html">typedef</a> <a class="el" href="classSDL_1_1OptionalRef.html">SDL_calloc_func</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback used to implement SDL_calloc(). </p>
<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> will always ensure that the passed <code>nmemb</code> and <code>size</code> are both greater than 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nmemb</td><td>the number of elements in the array. </td></tr>
    <tr><td class="paramname">size</td><td>the size of each element of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated array, or NULL if allocation failed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It should be safe to call this callback from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_calloc </dd>
<dd>
SDL_GetOriginalMemoryFunctions </dd>
<dd>
SDL_GetMemoryFunctions </dd>
<dd>
SDL_SetMemoryFunctions </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00241">241</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gabc94be94823c25031d6dd9210ef3e81a" name="gabc94be94823c25031d6dd9210ef3e81a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc94be94823c25031d6dd9210ef3e81a">&#9670;&#160;</a></span>CompareCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">using</a> <a class="el" href="group__CategoryStdinc.html#gabc94be94823c25031d6dd9210ef3e81a">SDL::CompareCallback</a> = <a class="el" href="classSDL_1_1OptionalRef.html">typedef</a> <a class="el" href="classSDL_1_1OptionalRef.html">SDL_CompareCallback</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback used with <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> sorting and binary search functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>a pointer to the first element being compared. </td></tr>
    <tr><td class="paramname">b</td><td>a pointer to the second element being compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if <code>a</code> should be sorted before <code>b</code>, 1 if <code>b</code> should be sorted before <code>a</code>, 0 if they are equal. If two elements are equal, their order in the sorted array is undefined.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This callback is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_bsearch </dd>
<dd>
SDL_qsort </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00695">695</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gab5c634ea2ae9a102fa58cd7beac9f478" name="gab5c634ea2ae9a102fa58cd7beac9f478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5c634ea2ae9a102fa58cd7beac9f478">&#9670;&#160;</a></span>CompareCallback_r</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">using</a> <a class="el" href="group__CategoryStdinc.html#gab5c634ea2ae9a102fa58cd7beac9f478">SDL::CompareCallback_r</a> = <a class="el" href="classSDL_1_1OptionalRef.html">typedef</a> <a class="el" href="classSDL_1_1OptionalRef.html">SDL_CompareCallback_r</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback used with <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> sorting and binary search functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userdata</td><td>the <code>userdata</code> pointer passed to the sort function. </td></tr>
    <tr><td class="paramname">a</td><td>a pointer to the first element being compared. </td></tr>
    <tr><td class="paramname">b</td><td>a pointer to the second element being compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if <code>a</code> should be sorted before <code>b</code>, 1 if <code>b</code> should be sorted before <code>a</code>, 0 if they are equal. If two elements are equal, their order in the sorted array is undefined.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This callback is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_qsort_r </dd>
<dd>
SDL_bsearch_r </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00822">822</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaedb86e9b9bb1aca04f73942d06b1d98f" name="gaedb86e9b9bb1aca04f73942d06b1d98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedb86e9b9bb1aca04f73942d06b1d98f">&#9670;&#160;</a></span>Environment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">using</a> <a class="el" href="group__CategoryStdinc.html#gaedb86e9b9bb1aca04f73942d06b1d98f">SDL::Environment</a> = <a class="el" href="classSDL_1_1OptionalRef.html">typedef</a> <a class="el" href="structSDL_1_1EnvironmentBase.html">EnvironmentBase</a>&lt;<a class="el" href="classSDL_1_1ObjectUnique.html">ObjectUnique</a>&lt;<a class="el" href="classSDL_1_1OptionalRef.html">SDL_Environment</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00049">49</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga61951c691e5b53e2c5261c8f3536531e" name="ga61951c691e5b53e2c5261c8f3536531e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61951c691e5b53e2c5261c8f3536531e">&#9670;&#160;</a></span>EnvironmentRef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">using</a> <a class="el" href="group__CategoryStdinc.html#ga61951c691e5b53e2c5261c8f3536531e">SDL::EnvironmentRef</a> = <a class="el" href="classSDL_1_1OptionalRef.html">typedef</a> <a class="el" href="structSDL_1_1EnvironmentBase.html">EnvironmentBase</a>&lt;<a class="el" href="classSDL_1_1ObjectRef.html">ObjectRef</a>&lt;<a class="el" href="classSDL_1_1OptionalRef.html">SDL_Environment</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00041">41</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga80cbbb5b121c8f78d44a66deaa573127" name="ga80cbbb5b121c8f78d44a66deaa573127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80cbbb5b121c8f78d44a66deaa573127">&#9670;&#160;</a></span>free_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">using</a> <a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">SDL::free_func</a> = <a class="el" href="classSDL_1_1OptionalRef.html">typedef</a> <a class="el" href="classSDL_1_1OptionalRef.html">SDL_free_func</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback used to implement SDL_free(). </p>
<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> will always ensure that the passed <code>mem</code> is a non-NULL pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>a pointer to allocated memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It should be safe to call this callback from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_free </dd>
<dd>
SDL_GetOriginalMemoryFunctions </dd>
<dd>
SDL_GetMemoryFunctions </dd>
<dd>
SDL_SetMemoryFunctions </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00280">280</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga379a3713730374c4737a2bfb2004fab7" name="ga379a3713730374c4737a2bfb2004fab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga379a3713730374c4737a2bfb2004fab7">&#9670;&#160;</a></span>FunctionPointer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">using</a> <a class="el" href="group__CategoryStdinc.html#ga379a3713730374c4737a2bfb2004fab7">SDL::FunctionPointer</a> = <a class="el" href="classSDL_1_1OptionalRef.html">typedef</a> <a class="el" href="classSDL_1_1OptionalRef.html">SDL_FunctionPointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic function pointer. </p>
<p>In theory, generic function pointers should use this, instead of <code>void *</code>, since some platforms could treat code addresses differently than data addresses. Although in current times no popular platforms make this distinction, it is more correct and portable to use the correct type for a generic pointer.</p>
<p>If for some reason you need to force this typedef to be an actual <code>void *</code>, perhaps to work around a compiler or existing code, you can define <code>SDL_FUNCTION_POINTER_IS_VOID_POINTER</code> before including any <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> headers.</p>
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l04562">4562</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga95fcbc65252fd494d78ce162e1340bea" name="ga95fcbc65252fd494d78ce162e1340bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95fcbc65252fd494d78ce162e1340bea">&#9670;&#160;</a></span>IConv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">using</a> <a class="el" href="group__CategoryStdinc.html#ga95fcbc65252fd494d78ce162e1340bea">SDL::IConv</a> = <a class="el" href="classSDL_1_1OptionalRef.html">typedef</a> <a class="el" href="structSDL_1_1IConvBase.html">IConvBase</a>&lt;<a class="el" href="classSDL_1_1ObjectUnique.html">ObjectUnique</a>&lt;<a class="el" href="classSDL_1_1OptionalRef.html">SDL_iconv_data_t</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00063">63</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga3d2eecfc83ea54cacb89f4fec27fa0b0" name="ga3d2eecfc83ea54cacb89f4fec27fa0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d2eecfc83ea54cacb89f4fec27fa0b0">&#9670;&#160;</a></span>IConvRef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">using</a> <a class="el" href="group__CategoryStdinc.html#ga3d2eecfc83ea54cacb89f4fec27fa0b0">SDL::IConvRef</a> = <a class="el" href="classSDL_1_1OptionalRef.html">typedef</a> <a class="el" href="structSDL_1_1IConvBase.html">IConvBase</a>&lt;<a class="el" href="classSDL_1_1ObjectRef.html">ObjectRef</a>&lt;<a class="el" href="classSDL_1_1OptionalRef.html">SDL_iconv_data_t</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00055">55</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga20e849be3a477a832c3f5b49aa71f793" name="ga20e849be3a477a832c3f5b49aa71f793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20e849be3a477a832c3f5b49aa71f793">&#9670;&#160;</a></span>malloc_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">using</a> <a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">SDL::malloc_func</a> = <a class="el" href="classSDL_1_1OptionalRef.html">typedef</a> <a class="el" href="classSDL_1_1OptionalRef.html">SDL_malloc_func</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback used to implement SDL_malloc(). </p>
<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> will always ensure that the passed <code>size</code> is greater than 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the size to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory, or NULL if allocation failed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It should be safe to call this callback from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_malloc </dd>
<dd>
SDL_GetOriginalMemoryFunctions </dd>
<dd>
SDL_GetMemoryFunctions </dd>
<dd>
SDL_SetMemoryFunctions </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00220">220</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaa0d42a4ebfbbe5ab7908f55ba0560ecb" name="gaa0d42a4ebfbbe5ab7908f55ba0560ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">&#9670;&#160;</a></span>realloc_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">using</a> <a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">SDL::realloc_func</a> = <a class="el" href="classSDL_1_1OptionalRef.html">typedef</a> <a class="el" href="classSDL_1_1OptionalRef.html">SDL_realloc_func</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback used to implement SDL_realloc(). </p>
<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> will always ensure that the passed <code>size</code> is greater than 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>a pointer to allocated memory to reallocate, or NULL. </td></tr>
    <tr><td class="paramname">size</td><td>the new size of the memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly allocated memory, or NULL if allocation failed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It should be safe to call this callback from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_realloc </dd>
<dd>
SDL_GetOriginalMemoryFunctions </dd>
<dd>
SDL_GetMemoryFunctions </dd>
<dd>
SDL_SetMemoryFunctions </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00262">262</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga4cdca510cc08a5569b9e76462e19242f" name="ga4cdca510cc08a5569b9e76462e19242f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cdca510cc08a5569b9e76462e19242f">&#9670;&#160;</a></span>Time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">using</a> <a class="el" href="group__CategoryStdinc.html#ga4cdca510cc08a5569b9e76462e19242f">SDL::Time</a> = <a class="el" href="classSDL_1_1OptionalRef.html">typedef</a> <a class="el" href="classSDL_1_1OptionalRef.html">SDL_Time</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> times are signed, 64-bit integers representing nanoseconds since the Unix epoch (Jan 1, 1970). </p>
<p>They can be converted between POSIX time_t values with SDL_NS_TO_SECONDS() and SDL_SECONDS_TO_NS(), and between Windows FILETIME values with SDL_TimeToWindows() and SDL_TimeFromWindows().</p>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_MAX_SINT64 </dd>
<dd>
SDL_MIN_SINT64 </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00097">97</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab188f3aa930df339c851b95bf2c4030b" name="gab188f3aa930df339c851b95bf2c4030b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab188f3aa930df339c851b95bf2c4030b">&#9670;&#160;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the absolute value of <code>x</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>an integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the absolute value of x.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00962">962</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga9f6543d319422a6044570b59cc6377b4" name="ga9f6543d319422a6044570b59cc6377b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f6543d319422a6044570b59cc6377b4">&#9670;&#160;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::acos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the arc cosine of <code>x</code>. </p>
<p>The definition of <code>y = <a class="el" href="group__CategoryStdinc.html#ga9f6543d319422a6044570b59cc6377b4" title="Compute the arc cosine of x.">acos(x)</a></code> is <code>x = <a class="el" href="group__CategoryStdinc.html#gadf8c80d673a05784387fa5e349a9f6dd" title="Compute the cosine of x.">cos(y)</a></code>.</p>
<p>Domain: <code>-1 &lt;= x &lt;= 1</code></p>
<p>Range: <code>0 &lt;= y &lt;= Pi</code></p>
<p>This function operates on double-precision floating point values, use SDL_acosf for single-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc cosine of <code>x</code>, in radians.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_acosf </dd>
<dd>
SDL_asin </dd>
<dd>
SDL_cos </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03098">3098</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga8e3b6760100280cb4cb51fcee4b3a2ff" name="ga8e3b6760100280cb4cb51fcee4b3a2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e3b6760100280cb4cb51fcee4b3a2ff">&#9670;&#160;</a></span>acosf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::acosf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the arc cosine of <code>x</code>. </p>
<p>The definition of <code>y = <a class="el" href="group__CategoryStdinc.html#ga9f6543d319422a6044570b59cc6377b4" title="Compute the arc cosine of x.">acos(x)</a></code> is <code>x = <a class="el" href="group__CategoryStdinc.html#gadf8c80d673a05784387fa5e349a9f6dd" title="Compute the cosine of x.">cos(y)</a></code>.</p>
<p>Domain: <code>-1 &lt;= x &lt;= 1</code></p>
<p>Range: <code>0 &lt;= y &lt;= Pi</code></p>
<p>This function operates on single-precision floating point values, use SDL_acos for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc cosine of <code>x</code>, in radians.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_acos </dd>
<dd>
SDL_asinf </dd>
<dd>
SDL_cosf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03128">3128</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gae3c9f70ddeadaecb2afeee2b3be34733" name="gae3c9f70ddeadaecb2afeee2b3be34733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3c9f70ddeadaecb2afeee2b3be34733">&#9670;&#160;</a></span>aligned_alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> * SDL::aligned_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory aligned to a specific alignment. </p>
<p>The memory returned by this function must be freed with SDL_aligned_free(), <em>not</em> SDL_free().</p>
<p>If <code>alignment</code> is less than the size of <code>void *</code>, it will be increased to match that.</p>
<p>The returned memory address will be a multiple of the alignment value, and the size of the memory allocated will be a multiple of the alignment value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alignment</td><td>the alignment of the memory. </td></tr>
    <tr><td class="paramname">size</td><td>the size to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the aligned memory, or NULL if allocation failed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_aligned_free </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00390">390</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaaf1efed697d82742be084a1871c95aa2" name="gaaf1efed697d82742be084a1871c95aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf1efed697d82742be084a1871c95aa2">&#9670;&#160;</a></span>aligned_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> SDL::aligned_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free memory allocated by SDL_aligned_alloc(). </p>
<p>The pointer is no longer valid after this call and cannot be dereferenced anymore.</p>
<p>If <code>mem</code> is NULL, this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>a pointer previously returned by SDL_aligned_alloc(), or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_aligned_alloc </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00411">411</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga316a2eed1e595c002830ee628c1b4963" name="ga316a2eed1e595c002830ee628c1b4963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga316a2eed1e595c002830ee628c1b4963">&#9670;&#160;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::asin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the arc sine of <code>x</code>. </p>
<p>The definition of <code>y = <a class="el" href="group__CategoryStdinc.html#ga316a2eed1e595c002830ee628c1b4963" title="Compute the arc sine of x.">asin(x)</a></code> is <code>x = <a class="el" href="group__CategoryStdinc.html#ga88bf16c79b920ce54e0ae909b2948663" title="Compute the sine of x.">sin(y)</a></code>.</p>
<p>Domain: <code>-1 &lt;= x &lt;= 1</code></p>
<p>Range: <code>-Pi/2 &lt;= y &lt;= Pi/2</code></p>
<p>This function operates on double-precision floating point values, use SDL_asinf for single-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc sine of <code>x</code>, in radians.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_asinf </dd>
<dd>
SDL_acos </dd>
<dd>
SDL_sin </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03158">3158</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga093ee4582ee6f6c02ab22c77718f56a8" name="ga093ee4582ee6f6c02ab22c77718f56a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga093ee4582ee6f6c02ab22c77718f56a8">&#9670;&#160;</a></span>asinf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::asinf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the arc sine of <code>x</code>. </p>
<p>The definition of <code>y = <a class="el" href="group__CategoryStdinc.html#ga316a2eed1e595c002830ee628c1b4963" title="Compute the arc sine of x.">asin(x)</a></code> is <code>x = <a class="el" href="group__CategoryStdinc.html#ga88bf16c79b920ce54e0ae909b2948663" title="Compute the sine of x.">sin(y)</a></code>.</p>
<p>Domain: <code>-1 &lt;= x &lt;= 1</code></p>
<p>Range: <code>-Pi/2 &lt;= y &lt;= Pi/2</code></p>
<p>This function operates on single-precision floating point values, use SDL_asin for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc sine of <code>x</code>, in radians.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_asin </dd>
<dd>
SDL_acosf </dd>
<dd>
SDL_sinf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03188">3188</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga11d0eaba28baba36fc8050f8541c8ee5" name="ga11d0eaba28baba36fc8050f8541c8ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11d0eaba28baba36fc8050f8541c8ee5">&#9670;&#160;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::atan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the arc tangent of <code>x</code>. </p>
<p>The definition of <code>y = <a class="el" href="group__CategoryStdinc.html#ga11d0eaba28baba36fc8050f8541c8ee5" title="Compute the arc tangent of x.">atan(x)</a></code> is <code>x = <a class="el" href="group__CategoryStdinc.html#ga88b5a6adb928a623a97598a7a154432c" title="Compute the tangent of x.">tan(y)</a></code>.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-Pi/2 &lt;= y &lt;= Pi/2</code></p>
<p>This function operates on double-precision floating point values, use SDL_atanf for single-precision floats.</p>
<p>To calculate the arc tangent of y / x, use SDL_atan2.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc tangent of of <code>x</code> in radians, or 0 if <code>x = 0</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_atanf </dd>
<dd>
SDL_atan2 </dd>
<dd>
SDL_tan </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03220">3220</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gae0884b892c70d428cf50522d9791eb61" name="gae0884b892c70d428cf50522d9791eb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0884b892c70d428cf50522d9791eb61">&#9670;&#160;</a></span>atan2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::atan2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the arc tangent of <code>y / x</code>, using the signs of x and y to adjust the result's quadrant. </p>
<p>The definition of <code>z = <a class="el" href="group__CategoryStdinc.html#gae0884b892c70d428cf50522d9791eb61" title="Compute the arc tangent of y / x, using the signs of x and y to adjust the result&#39;s quadrant.">atan2(x, y)</a></code> is <code>y = x <a class="el" href="group__CategoryStdinc.html#ga88b5a6adb928a623a97598a7a154432c" title="Compute the tangent of x.">tan(z)</a></code>, where the quadrant of z is determined based on the signs of x and y.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= INF</code></p>
<p>Range: <code>-Pi/2 &lt;= y &lt;= Pi/2</code></p>
<p>This function operates on double-precision floating point values, use SDL_atan2f for single-precision floats.</p>
<p>To calculate the arc tangent of a single value, use SDL_atan.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>floating point value of the numerator (y coordinate). </td></tr>
    <tr><td class="paramname">x</td><td>floating point value of the denominator (x coordinate). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc tangent of of <code>y / x</code> in radians, or, if <code>x = 0</code>, either <code>-Pi/2</code>, <code>0</code>, or <code>Pi/2</code>, depending on the value of <code>y</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_atan2f </dd>
<dd>
SDL_atan </dd>
<dd>
SDL_tan </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03288">3288</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaf1be31240212288c0d7556cf80340b93" name="gaf1be31240212288c0d7556cf80340b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1be31240212288c0d7556cf80340b93">&#9670;&#160;</a></span>atan2f()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::atan2f </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the arc tangent of <code>y / x</code>, using the signs of x and y to adjust the result's quadrant. </p>
<p>The definition of <code>z = <a class="el" href="group__CategoryStdinc.html#gae0884b892c70d428cf50522d9791eb61" title="Compute the arc tangent of y / x, using the signs of x and y to adjust the result&#39;s quadrant.">atan2(x, y)</a></code> is <code>y = x <a class="el" href="group__CategoryStdinc.html#ga88b5a6adb928a623a97598a7a154432c" title="Compute the tangent of x.">tan(z)</a></code>, where the quadrant of z is determined based on the signs of x and y.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= INF</code></p>
<p>Range: <code>-Pi/2 &lt;= y &lt;= Pi/2</code></p>
<p>This function operates on single-precision floating point values, use SDL_atan2 for double-precision floats.</p>
<p>To calculate the arc tangent of a single value, use SDL_atanf.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>floating point value of the numerator (y coordinate). </td></tr>
    <tr><td class="paramname">x</td><td>floating point value of the denominator (x coordinate). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc tangent of of <code>y / x</code> in radians, or, if <code>x = 0</code>, either <code>-Pi/2</code>, <code>0</code>, or <code>Pi/2</code>, depending on the value of <code>y</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_atan2f </dd>
<dd>
SDL_atan </dd>
<dd>
SDL_tan </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03324">3324</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga19e239deb9997e2ff33bbfdbaec436b2" name="ga19e239deb9997e2ff33bbfdbaec436b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19e239deb9997e2ff33bbfdbaec436b2">&#9670;&#160;</a></span>atanf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::atanf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the arc tangent of <code>x</code>. </p>
<p>The definition of <code>y = <a class="el" href="group__CategoryStdinc.html#ga11d0eaba28baba36fc8050f8541c8ee5" title="Compute the arc tangent of x.">atan(x)</a></code> is <code>x = <a class="el" href="group__CategoryStdinc.html#ga88b5a6adb928a623a97598a7a154432c" title="Compute the tangent of x.">tan(y)</a></code>.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-Pi/2 &lt;= y &lt;= Pi/2</code></p>
<p>This function operates on single-precision floating point values, use SDL_atan for dboule-precision floats.</p>
<p>To calculate the arc tangent of y / x, use SDL_atan2f.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc tangent of of <code>x</code> in radians, or 0 if <code>x = 0</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_atan </dd>
<dd>
SDL_atan2f </dd>
<dd>
SDL_tanf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03252">3252</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaeecdd7ec80c303a7474d59b641a892f7" name="gaeecdd7ec80c303a7474d59b641a892f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeecdd7ec80c303a7474d59b641a892f7">&#9670;&#160;</a></span>atof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::atof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a <code>double</code> from a string. </p>
<p>The result of calling <code>SDL_atof(str)</code> is equivalent to <code>SDL_strtod(str,
NULL)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to read. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed <code>double</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_atoi </dd>
<dd>
SDL_strtol </dd>
<dd>
SDL_strtoul </dd>
<dd>
SDL_strtoll </dd>
<dd>
SDL_strtoull </dd>
<dd>
SDL_strtod </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02439">2439</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga756fd0202aa809d537fc01e28b0c7564" name="ga756fd0202aa809d537fc01e28b0c7564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga756fd0202aa809d537fc01e28b0c7564">&#9670;&#160;</a></span>atoi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::atoi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse an <code>int</code> from a string. </p>
<p>The result of calling <code>SDL_atoi(str)</code> is equivalent to <code>(int)SDL_strtol(str, NULL, 10)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to read. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed <code>int</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_atof </dd>
<dd>
SDL_strtol </dd>
<dd>
SDL_strtoul </dd>
<dd>
SDL_strtoll </dd>
<dd>
SDL_strtoull </dd>
<dd>
SDL_strtod </dd>
<dd>
SDL_itoa </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02417">2417</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gada62aea13b8eceffa3e57359e124e541" name="gada62aea13b8eceffa3e57359e124e541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada62aea13b8eceffa3e57359e124e541">&#9670;&#160;</a></span>bsearch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> * SDL::bsearch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gabc94be94823c25031d6dd9210ef3e81a">CompareCallback</a>&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a binary search on a previously sorted array. </p>
<p>For example:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">      <span class="keywordtype">int</span> <a class="code hl_class" href="classSDL_1_1OptionalRef.html">key</a>;</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code hl_class" href="classSDL_1_1OptionalRef.html">string</a>;</div>
<div class="line">  } data;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> SDLCALL compare(<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)</div>
<div class="line">  {</div>
<div class="line">      <span class="keyword">const</span> data *A = (<span class="keyword">const</span> data *)a;</div>
<div class="line">      <span class="keyword">const</span> data *B = (<span class="keyword">const</span> data *)b;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">if</span> (A-&gt;n &lt; B-&gt;n) {</div>
<div class="line">          <span class="keywordflow">return</span> -1;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (B-&gt;n &lt; A-&gt;n) {</div>
<div class="line">          <span class="keywordflow">return</span> 1;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keywordflow">return</span> 0;</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  data values[] = {</div>
<div class="line">      { 1, <span class="stringliteral">&quot;first&quot;</span> }, { 2, <span class="stringliteral">&quot;second&quot;</span> }, { 3, <span class="stringliteral">&quot;third&quot;</span> }</div>
<div class="line">  };</div>
<div class="line">  data key = { 2, NULL };</div>
<div class="line"> </div>
<div class="line">  data *result = SDL_bsearch(&amp;key, values, SDL_arraysize(values),</div>
<div class="line">*<span class="keyword">sizeof</span>(values[0]), compare);</div>
<div class="ttc" id="aclassSDL_1_1OptionalRef_html"><div class="ttname"><a href="classSDL_1_1OptionalRef.html">SDL::OptionalRef</a></div><div class="ttdoc">Shim to get optional-like interface for references.</div><div class="ttdef"><b>Definition</b> <a href="SDL3pp__optionalRef_8h_source.html#l00014">SDL3pp_optionalRef.h:15</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a pointer to a key equal to the element being searched for. </td></tr>
    <tr><td class="paramname">base</td><td>a pointer to the start of the array. </td></tr>
    <tr><td class="paramname">nmemb</td><td>the number of elements in the array. </td></tr>
    <tr><td class="paramname">size</td><td>the size of the elements in the array. </td></tr>
    <tr><td class="paramname">compare</td><td>a function used to compare elements in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the matching element in the array, or NULL if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_bsearch_r </dd>
<dd>
SDL_qsort </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00798">798</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaf22f982867b4598c8caa2de8f5a9e0e4" name="gaf22f982867b4598c8caa2de8f5a9e0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf22f982867b4598c8caa2de8f5a9e0e4">&#9670;&#160;</a></span>bsearch_r()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> * SDL::bsearch_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gab5c634ea2ae9a102fa58cd7beac9f478">CompareCallback_r</a>&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a binary search on a previously sorted array, passing a userdata pointer to the compare function. </p>
<p>For example:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> <span class="keyword">enum</span> {</div>
<div class="line">      <a class="code hl_class" href="classSDL_1_1OptionalRef.html">sort_increasing</a>,</div>
<div class="line">      <a class="code hl_class" href="classSDL_1_1OptionalRef.html">sort_decreasing</a>,</div>
<div class="line">  } sort_method;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">      <span class="keywordtype">int</span> key;</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">char</span> *string;</div>
<div class="line">  } data;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> SDLCALL compare(<span class="keyword">const</span> <span class="keywordtype">void</span> *userdata, <span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)</div>
<div class="line">  {</div>
<div class="line">      sort_method method = (sort_method)(uintptr_t)userdata;</div>
<div class="line">      <span class="keyword">const</span> data *A = (<span class="keyword">const</span> data *)a;</div>
<div class="line">      <span class="keyword">const</span> data *B = (<span class="keyword">const</span> data *)b;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">if</span> (A-&gt;key &lt; B-&gt;key) {</div>
<div class="line">          <span class="keywordflow">return</span> (method == sort_increasing) ? -1 : 1;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (B-&gt;key &lt; A-&gt;key) {</div>
<div class="line">          <span class="keywordflow">return</span> (method == sort_increasing) ? 1 : -1;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keywordflow">return</span> 0;</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  data values[] = {</div>
<div class="line">      { 1, <span class="stringliteral">&quot;first&quot;</span> }, { 2, <span class="stringliteral">&quot;second&quot;</span> }, { 3, <span class="stringliteral">&quot;third&quot;</span> }</div>
<div class="line">  };</div>
<div class="line">  data key = { 2, NULL };</div>
<div class="line"> </div>
<div class="line">  data *result = SDL_bsearch_r(&amp;key, values, SDL_arraysize(values),</div>
<div class="line">*<span class="keyword">sizeof</span>(values[0]), compare, (<span class="keyword">const</span> <span class="keywordtype">void</span> *)(uintptr_t)sort_increasing);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a pointer to a key equal to the element being searched for. </td></tr>
    <tr><td class="paramname">base</td><td>a pointer to the start of the array. </td></tr>
    <tr><td class="paramname">nmemb</td><td>the number of elements in the array. </td></tr>
    <tr><td class="paramname">size</td><td>the size of the elements in the array. </td></tr>
    <tr><td class="paramname">compare</td><td>a function used to compare elements in the array. </td></tr>
    <tr><td class="paramname">userdata</td><td>a pointer to pass to the compare function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the matching element in the array, or NULL if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_bsearch </dd>
<dd>
SDL_qsort_r </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00942">942</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gab24b3e9482f5a1c26602b83f2de05d09" name="gab24b3e9482f5a1c26602b83f2de05d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab24b3e9482f5a1c26602b83f2de05d09">&#9670;&#160;</a></span>calloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> * SDL::calloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a zero-initialized array. </p>
<p>The memory returned by this function must be freed with SDL_free().</p>
<p>If either of <code>nmemb</code> or <code>size</code> is 0, they will both be set to 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nmemb</td><td>the number of elements in the array. </td></tr>
    <tr><td class="paramname">size</td><td>the size of each element of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated array, or NULL if allocation failed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_free </dd>
<dd>
SDL_malloc </dd>
<dd>
SDL_realloc </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00143">143</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga1567a1e6b1738fabc6252d7c52f03321" name="ga1567a1e6b1738fabc6252d7c52f03321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1567a1e6b1738fabc6252d7c52f03321">&#9670;&#160;</a></span>ceil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::ceil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the ceiling of <code>x</code>. </p>
<p>The ceiling of <code>x</code> is the smallest integer <code>y</code> such that <code>y &gt; x</code>, i.e <code>x</code> rounded up to the nearest integer.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<p>This function operates on double-precision floating point values, use SDL_ceilf for single-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ceiling of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_ceilf </dd>
<dd>
SDL_floor </dd>
<dd>
SDL_trunc </dd>
<dd>
SDL_round </dd>
<dd>
SDL_lround </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03352">3352</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga5962b17a629d7f973898e35e1818646f" name="ga5962b17a629d7f973898e35e1818646f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5962b17a629d7f973898e35e1818646f">&#9670;&#160;</a></span>ceilf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::ceilf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the ceiling of <code>x</code>. </p>
<p>The ceiling of <code>x</code> is the smallest integer <code>y</code> such that <code>y &gt; x</code>, i.e <code>x</code> rounded up to the nearest integer.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<p>This function operates on single-precision floating point values, use SDL_ceil for double-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ceiling of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_ceil </dd>
<dd>
SDL_floorf </dd>
<dd>
SDL_truncf </dd>
<dd>
SDL_roundf </dd>
<dd>
SDL_lroundf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03380">3380</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga476595ece87ed3441c672348366f0adb" name="ga476595ece87ed3441c672348366f0adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga476595ece87ed3441c672348366f0adb">&#9670;&#160;</a></span>copysign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::copysign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the sign of one floating-point value to another. </p>
<p>The definition of copysign is that <code><a class="el" href="group__CategoryStdinc.html#ga476595ece87ed3441c672348366f0adb" title="Copy the sign of one floating-point value to another.">copysign(x, y)</a> = <a class="el" href="group__CategoryStdinc.html#gab188f3aa930df339c851b95bf2c4030b" title="Compute the absolute value of x.">abs(x)</a> * sign(y)</code>.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= f</code></p>
<p>Range: <code>-INF &lt;= z &lt;= INF</code></p>
<p>This function operates on double-precision floating point values, use SDL_copysignf for single-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value to use as the magnitude. </td></tr>
    <tr><td class="paramname">y</td><td>floating point value to use as the sign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the floating point value with the sign of y and the magnitude of x.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_copysignf </dd>
<dd>
SDL_fabs </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03406">3406</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga0b8d2ae3c91e681437f9b8bad0d332dd" name="ga0b8d2ae3c91e681437f9b8bad0d332dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b8d2ae3c91e681437f9b8bad0d332dd">&#9670;&#160;</a></span>copysignf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::copysignf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the sign of one floating-point value to another. </p>
<p>The definition of copysign is that <code><a class="el" href="group__CategoryStdinc.html#ga476595ece87ed3441c672348366f0adb" title="Copy the sign of one floating-point value to another.">copysign(x, y)</a> = <a class="el" href="group__CategoryStdinc.html#gab188f3aa930df339c851b95bf2c4030b" title="Compute the absolute value of x.">abs(x)</a> * sign(y)</code>.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= f</code></p>
<p>Range: <code>-INF &lt;= z &lt;= INF</code></p>
<p>This function operates on single-precision floating point values, use SDL_copysign for double-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value to use as the magnitude. </td></tr>
    <tr><td class="paramname">y</td><td>floating point value to use as the sign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the floating point value with the sign of y and the magnitude of x.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_copysignf </dd>
<dd>
SDL_fabsf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03432">3432</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gadf8c80d673a05784387fa5e349a9f6dd" name="gadf8c80d673a05784387fa5e349a9f6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf8c80d673a05784387fa5e349a9f6dd">&#9670;&#160;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::cos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cosine of <code>x</code>. </p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-1 &lt;= y &lt;= 1</code></p>
<p>This function operates on double-precision floating point values, use SDL_cosf for single-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value, in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cosine of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_cosf </dd>
<dd>
SDL_acos </dd>
<dd>
SDL_sin </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03460">3460</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga343b62c85d5c6bc9627fdad943860921" name="ga343b62c85d5c6bc9627fdad943860921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga343b62c85d5c6bc9627fdad943860921">&#9670;&#160;</a></span>cosf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::cosf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cosine of <code>x</code>. </p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-1 &lt;= y &lt;= 1</code></p>
<p>This function operates on single-precision floating point values, use SDL_cos for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value, in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cosine of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_cos </dd>
<dd>
SDL_acosf </dd>
<dd>
SDL_sinf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03488">3488</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga31ee6fbdefd2ca34bbde4c8652069e66" name="ga31ee6fbdefd2ca34bbde4c8652069e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31ee6fbdefd2ca34bbde4c8652069e66">&#9670;&#160;</a></span>crc16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">Uint16</a> SDL::crc16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">Uint16</a>&#160;</td>
          <td class="paramname"><em>crc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a CRC-16 value. </p>
<p><a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">https://en.wikipedia.org/wiki/Cyclic_redundancy_check</a></p>
<p>This function can be called multiple times, to stream data to be checksummed in blocks. Each call must provide the previous CRC-16 return value to be updated with the next block. The first call to this function for a set of blocks should pass in a zero CRC value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crc</td><td>the current checksum for this data set, or 0 for a new data set. </td></tr>
    <tr><td class="paramname">data</td><td>a new block of data to add to the checksum. </td></tr>
    <tr><td class="paramname">len</td><td>the size, in bytes, of the new block of data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a CRC-16 checksum value of all blocks in the data set.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01219">1219</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gacc8b8bc6d26dd888c3fed721ddb1cd2e" name="gacc8b8bc6d26dd888c3fed721ddb1cd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc8b8bc6d26dd888c3fed721ddb1cd2e">&#9670;&#160;</a></span>crc32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">Uint32</a> SDL::crc32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">Uint32</a>&#160;</td>
          <td class="paramname"><em>crc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a CRC-32 value. </p>
<p><a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">https://en.wikipedia.org/wiki/Cyclic_redundancy_check</a></p>
<p>This function can be called multiple times, to stream data to be checksummed in blocks. Each call must provide the previous CRC-32 return value to be updated with the next block. The first call to this function for a set of blocks should pass in a zero CRC value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crc</td><td>the current checksum for this data set, or 0 for a new data set. </td></tr>
    <tr><td class="paramname">data</td><td>a new block of data to add to the checksum. </td></tr>
    <tr><td class="paramname">len</td><td>the size, in bytes, of the new block of data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a CRC-32 checksum value of all blocks in the data set.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01243">1243</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga3e4417a78f0393e80fa7645a534a53a3" name="ga3e4417a78f0393e80fa7645a534a53a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e4417a78f0393e80fa7645a534a53a3">&#9670;&#160;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the exponential of <code>x</code>. </p>
<p>The definition of <code>y = <a class="el" href="group__CategoryStdinc.html#ga3e4417a78f0393e80fa7645a534a53a3" title="Compute the exponential of x.">exp(x)</a></code> is <code>y = e^x</code>, where <code>e</code> is the base of the natural logarithm. The inverse is the natural logarithm, SDL_log.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>0 &lt;= y &lt;= INF</code></p>
<p>The output will overflow if <code><a class="el" href="group__CategoryStdinc.html#ga3e4417a78f0393e80fa7645a534a53a3" title="Compute the exponential of x.">exp(x)</a></code> is too large to be represented.</p>
<p>This function operates on double-precision floating point values, use SDL_expf for single-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of <code>e^x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_expf </dd>
<dd>
SDL_log </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03520">3520</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga5c6a34f6bfb50b176f502a6133880aa8" name="ga5c6a34f6bfb50b176f502a6133880aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c6a34f6bfb50b176f502a6133880aa8">&#9670;&#160;</a></span>expf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::expf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the exponential of <code>x</code>. </p>
<p>The definition of <code>y = <a class="el" href="group__CategoryStdinc.html#ga3e4417a78f0393e80fa7645a534a53a3" title="Compute the exponential of x.">exp(x)</a></code> is <code>y = e^x</code>, where <code>e</code> is the base of the natural logarithm. The inverse is the natural logarithm, SDL_logf.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>0 &lt;= y &lt;= INF</code></p>
<p>The output will overflow if <code><a class="el" href="group__CategoryStdinc.html#ga3e4417a78f0393e80fa7645a534a53a3" title="Compute the exponential of x.">exp(x)</a></code> is too large to be represented.</p>
<p>This function operates on single-precision floating point values, use SDL_exp for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of <code>e^x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_exp </dd>
<dd>
SDL_logf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03552">3552</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gae57cb7c976b8596bb9ff76f3402a2488" name="gae57cb7c976b8596bb9ff76f3402a2488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae57cb7c976b8596bb9ff76f3402a2488">&#9670;&#160;</a></span>fabs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::fabs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the absolute value of <code>x</code> </p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>0 &lt;= y &lt;= INF</code></p>
<p>This function operates on double-precision floating point values, use SDL_copysignf for single-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value to use as the magnitude. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the absolute value of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_fabsf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03573">3573</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga8952f2171107539c5cddb95fe5efec28" name="ga8952f2171107539c5cddb95fe5efec28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8952f2171107539c5cddb95fe5efec28">&#9670;&#160;</a></span>fabsf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::fabsf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the absolute value of <code>x</code> </p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>0 &lt;= y &lt;= INF</code></p>
<p>This function operates on single-precision floating point values, use SDL_copysignf for double-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value to use as the magnitude. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the absolute value of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_fabs </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03594">3594</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaa5d99939c5dffc37035e51300236316a" name="gaa5d99939c5dffc37035e51300236316a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5d99939c5dffc37035e51300236316a">&#9670;&#160;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::floor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the floor of <code>x</code>. </p>
<p>The floor of <code>x</code> is the largest integer <code>y</code> such that <code>y &gt; x</code>, i.e <code>x</code> rounded down to the nearest integer.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<p>This function operates on double-precision floating point values, use SDL_floorf for single-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the floor of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_floorf </dd>
<dd>
SDL_ceil </dd>
<dd>
SDL_trunc </dd>
<dd>
SDL_round </dd>
<dd>
SDL_lround </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03622">3622</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga8438f2959083ee7e897f7f3ef03ca3b8" name="ga8438f2959083ee7e897f7f3ef03ca3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8438f2959083ee7e897f7f3ef03ca3b8">&#9670;&#160;</a></span>floorf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::floorf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the floor of <code>x</code>. </p>
<p>The floor of <code>x</code> is the largest integer <code>y</code> such that <code>y &gt; x</code>, i.e <code>x</code> rounded down to the nearest integer.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<p>This function operates on single-precision floating point values, use SDL_floorf for double-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the floor of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_floor </dd>
<dd>
SDL_ceilf </dd>
<dd>
SDL_truncf </dd>
<dd>
SDL_roundf </dd>
<dd>
SDL_lroundf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03650">3650</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gafcd6b0192bc061852ef8ef56272bf98d" name="gafcd6b0192bc061852ef8ef56272bf98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcd6b0192bc061852ef8ef56272bf98d">&#9670;&#160;</a></span>fmod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::fmod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the floating-point remainder of <code>x / y</code> </p>
<p>Divides <code>x</code> by <code>y</code>, and returns the remainder.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= INF</code>, <code>y != 0</code></p>
<p>Range: <code>-y &lt;= z &lt;= y</code></p>
<p>This function operates on double-precision floating point values, use SDL_fmodf for single-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the numerator. </td></tr>
    <tr><td class="paramname">y</td><td>the denominator. Must not be 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the remainder of <code>x / y</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_fmodf </dd>
<dd>
SDL_modf </dd>
<dd>
SDL_trunc </dd>
<dd>
SDL_ceil </dd>
<dd>
SDL_floor </dd>
<dd>
SDL_round </dd>
<dd>
SDL_lround </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03738">3738</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gab12a77026e20d3235fab10d708ed80a6" name="gab12a77026e20d3235fab10d708ed80a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab12a77026e20d3235fab10d708ed80a6">&#9670;&#160;</a></span>fmodf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::fmodf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the floating-point remainder of <code>x / y</code> </p>
<p>Divides <code>x</code> by <code>y</code>, and returns the remainder.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= INF</code>, <code>y != 0</code></p>
<p>Range: <code>-y &lt;= z &lt;= y</code></p>
<p>This function operates on single-precision floating point values, use SDL_fmod for single-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the numerator. </td></tr>
    <tr><td class="paramname">y</td><td>the denominator. Must not be 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the remainder of <code>x / y</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_fmod </dd>
<dd>
SDL_truncf </dd>
<dd>
SDL_modff </dd>
<dd>
SDL_ceilf </dd>
<dd>
SDL_floorf </dd>
<dd>
SDL_roundf </dd>
<dd>
SDL_lroundf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03768">3768</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaa932b3872f6162d7257c924b184e5381" name="gaa932b3872f6162d7257c924b184e5381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa932b3872f6162d7257c924b184e5381">&#9670;&#160;</a></span>FourCC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">constexpr</a> <a class="el" href="classSDL_1_1OptionalRef.html">Uint32</a> SDL::FourCC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">Uint8</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">Uint8</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">Uint8</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">Uint8</a>&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define a four character code as a Uint32. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first ASCII character. </td></tr>
    <tr><td class="paramname">b</td><td>the second ASCII character. </td></tr>
    <tr><td class="paramname">c</td><td>the third ASCII character. </td></tr>
    <tr><td class="paramname">d</td><td>the fourth ASCII character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the four characters converted into a Uint32, one character per-byte.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this macro from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00079">79</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gadfa01257ca1f966fffb72f002db27fa6" name="gadfa01257ca1f966fffb72f002db27fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfa01257ca1f966fffb72f002db27fa6">&#9670;&#160;</a></span>free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> SDL::free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free allocated memory. </p>
<p>The pointer is no longer valid after this call and cannot be dereferenced anymore.</p>
<p>If <code>mem</code> is NULL, this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>a pointer to allocated memory, or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_malloc </dd>
<dd>
SDL_calloc </dd>
<dd>
SDL_realloc </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00201">201</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga97502b219bb63f4be0f31868fecc9120" name="ga97502b219bb63f4be0f31868fecc9120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97502b219bb63f4be0f31868fecc9120">&#9670;&#160;</a></span>getenv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">char</a> * SDL::getenv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of a variable in the environment. </p>
<p>This function uses <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a>'s cached copy of the environment and is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the variable to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the value of the variable or NULL if it can't be found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00618">618</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga8a55c001e123a53e424cbc460ec4b1b6" name="ga8a55c001e123a53e424cbc460ec4b1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a55c001e123a53e424cbc460ec4b1b6">&#9670;&#160;</a></span>getenv_unsafe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">char</a> * SDL::getenv_unsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of a variable in the environment. </p>
<p>This function bypasses <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a>'s cached copy of the environment and is not thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the variable to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the value of the variable or NULL if it can't be found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe, consider using SDL_getenv() instead.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_getenv </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00637">637</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gafc9e4411ee1c8072c58cbfa0566a5660" name="gafc9e4411ee1c8072c58cbfa0566a5660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc9e4411ee1c8072c58cbfa0566a5660">&#9670;&#160;</a></span>GetEnvironment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategoryStdinc.html#ga61951c691e5b53e2c5261c8f3536531e">EnvironmentRef</a> SDL::GetEnvironment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the process environment. </p>
<p>This is initialized at application start and is not affected by setenv() and unsetenv() calls after that point. Use SDL_SetEnvironmentVariable() and SDL_UnsetEnvironmentVariable() if you want to modify this environment, or SDL_setenv_unsafe() or SDL_unsetenv_unsafe() if you want changes to persist in the C runtime environment after SDL_Quit().</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the environment for the process or NULL on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>GetVariable() </dd>
<dd>
GetVariables() </dd>
<dd>
SetVariable() </dd>
<dd>
UnsetVariable() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00603">603</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gab331691e9cf41b2fd9063b80910ea6b0" name="gab331691e9cf41b2fd9063b80910ea6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab331691e9cf41b2fd9063b80910ea6b0">&#9670;&#160;</a></span>GetMemoryFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> SDL::GetMemoryFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a> *&#160;</td>
          <td class="paramname"><em>malloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a> *&#160;</td>
          <td class="paramname"><em>calloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a> *&#160;</td>
          <td class="paramname"><em>realloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a> *&#160;</td>
          <td class="paramname"><em>free_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current set of <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> memory functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">malloc_func</td><td>filled with malloc function. </td></tr>
    <tr><td class="paramname">calloc_func</td><td>filled with calloc function. </td></tr>
    <tr><td class="paramname">realloc_func</td><td>filled with realloc function. </td></tr>
    <tr><td class="paramname">free_func</td><td>filled with free function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This does not hold a lock, so do not call this in the unlikely event of a background thread calling SDL_SetMemoryFunctions simultaneously.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_SetMemoryFunctions </dd>
<dd>
SDL_GetOriginalMemoryFunctions </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00325">325</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gae51ea510815eaec3a9b288754a805206" name="gae51ea510815eaec3a9b288754a805206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae51ea510815eaec3a9b288754a805206">&#9670;&#160;</a></span>GetNumAllocations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::GetNumAllocations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of outstanding (unfreed) allocations. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of allocations or -1 if allocation counting is disabled.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00423">423</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga6325f645ab936554e7aaa2e4d977d9d7" name="ga6325f645ab936554e7aaa2e4d977d9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6325f645ab936554e7aaa2e4d977d9d7">&#9670;&#160;</a></span>GetOriginalMemoryFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> SDL::GetOriginalMemoryFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a> *&#160;</td>
          <td class="paramname"><em>malloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a> *&#160;</td>
          <td class="paramname"><em>calloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a> *&#160;</td>
          <td class="paramname"><em>realloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a> *&#160;</td>
          <td class="paramname"><em>free_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the original set of <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> memory functions. </p>
<p>This is what SDL_malloc and friends will use by default, if there has been no call to SDL_SetMemoryFunctions. This is not necessarily using the C runtime's <code>malloc</code> functions behind the scenes! Different platforms and build configurations might do any number of unexpected things.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">malloc_func</td><td>filled with malloc function. </td></tr>
    <tr><td class="paramname">calloc_func</td><td>filled with calloc function. </td></tr>
    <tr><td class="paramname">realloc_func</td><td>filled with realloc function. </td></tr>
    <tr><td class="paramname">free_func</td><td>filled with free function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00299">299</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga8101a1c19844c8cb72600a9aa6238327" name="ga8101a1c19844c8cb72600a9aa6238327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8101a1c19844c8cb72600a9aa6238327">&#9670;&#160;</a></span>iconv_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> * SDL::iconv_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>tocode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>fromcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>inbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>inbytesleft</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to convert a string's encoding in one call. </p>
<p>This function converts a buffer or string between encodings in one pass.</p>
<p>The string does not need to be NULL-terminated; this function operates on the number of bytes specified in <code>inbytesleft</code> whether there is a NULL character anywhere in the buffer.</p>
<p>The returned string is owned by the caller, and should be passed to SDL_free when no longer needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tocode</td><td>the character encoding of the output string. Examples are "UTF-8", "UCS-4", etc. </td></tr>
    <tr><td class="paramname">fromcode</td><td>the character encoding of data in <code>inbuf</code>. </td></tr>
    <tr><td class="paramname">inbuf</td><td>the string to convert to a different encoding. </td></tr>
    <tr><td class="paramname">inbytesleft</td><td>the size of the input string <em>in bytes</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new string, converted to the new encoding, or NULL on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_iconv_open </dd>
<dd>
SDL_iconv_close </dd>
<dd>
SDL_iconv </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l04495">4495</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gafc3565e81c3ab6ba0e66f9030c056969" name="gafc3565e81c3ab6ba0e66f9030c056969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc3565e81c3ab6ba0e66f9030c056969">&#9670;&#160;</a></span>isalnum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::isalnum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query if a character is alphabetic (a letter) or a number. </p>
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values for English 'a-z', 'A-Z', and '0-9' as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00992">992</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga79256765fa0f219b5947721d1d920041" name="ga79256765fa0f219b5947721d1d920041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79256765fa0f219b5947721d1d920041">&#9670;&#160;</a></span>isalpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::isalpha </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query if a character is alphabetic (a letter). </p>
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values for English 'a-z' and 'A-Z' as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00977">977</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gab6936f2d259cb2959c3d73e8bb66cf0d" name="gab6936f2d259cb2959c3d73e8bb66cf0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6936f2d259cb2959c3d73e8bb66cf0d">&#9670;&#160;</a></span>isblank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::isblank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report if a character is blank (a space or tab). </p>
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values 0x20 (space) or 0x9 (tab) as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01007">1007</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga901f942513d4469f8722185f0cee85bd" name="ga901f942513d4469f8722185f0cee85bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga901f942513d4469f8722185f0cee85bd">&#9670;&#160;</a></span>iscntrl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::iscntrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report if a character is a control character. </p>
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values 0 through 0x1F, and 0x7F, as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01022">1022</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga3c4d5430375fa896b58aa1e5a23cd30f" name="ga3c4d5430375fa896b58aa1e5a23cd30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c4d5430375fa896b58aa1e5a23cd30f">&#9670;&#160;</a></span>isdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::isdigit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report if a character is a numeric digit. </p>
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values '0' (0x30) through '9' (0x39), as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01037">1037</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga28e4c655a653424f510993ddec5b02b4" name="ga28e4c655a653424f510993ddec5b02b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28e4c655a653424f510993ddec5b02b4">&#9670;&#160;</a></span>isgraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::isgraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report if a character is any "printable" except space. </p>
<p>Be advised that "printable" has a definition that goes back to text terminals from the dawn of computing, making this a sort of special case function that is not suitable for Unicode (or most any) text management.</p>
<p><b>WARNING</b>: Regardless of system locale, this is equivalent to &lsquo;(SDL_isprint(x)) &amp;&amp; ((x) != &rsquo; ')`.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_isprint </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01162">1162</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga918f0e70e6e67f724c445eba4b514a21" name="ga918f0e70e6e67f724c445eba4b514a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga918f0e70e6e67f724c445eba4b514a21">&#9670;&#160;</a></span>isinf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::isinf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether the value is infinity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>double-precision floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if the value is infinity, 0 otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_isinff </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03782">3782</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga59c45f83103aa3fdc57244124dea7d5d" name="ga59c45f83103aa3fdc57244124dea7d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59c45f83103aa3fdc57244124dea7d5d">&#9670;&#160;</a></span>isinff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::isinff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether the value is infinity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if the value is infinity, 0 otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_isinf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03796">3796</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga9154645a2881fcb9f6c1df5c4d848ef1" name="ga9154645a2881fcb9f6c1df5c4d848ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9154645a2881fcb9f6c1df5c4d848ef1">&#9670;&#160;</a></span>islower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::islower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report if a character is lower case. </p>
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values 'a' through 'z' as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01122">1122</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga2221269e7ded0fb89af37aea9132e0b8" name="ga2221269e7ded0fb89af37aea9132e0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2221269e7ded0fb89af37aea9132e0b8">&#9670;&#160;</a></span>isnan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::isnan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether the value is NaN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>double-precision floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if the value is NaN, 0 otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_isnanf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03810">3810</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga945938b6b96f7b17c1916fe9d357a315" name="ga945938b6b96f7b17c1916fe9d357a315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga945938b6b96f7b17c1916fe9d357a315">&#9670;&#160;</a></span>isnanf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::isnanf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether the value is NaN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if the value is NaN, 0 otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_isnan </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03824">3824</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga6ff81eceb17060ed3c3c7c32a14bf7b8" name="ga6ff81eceb17060ed3c3c7c32a14bf7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ff81eceb17060ed3c3c7c32a14bf7b8">&#9670;&#160;</a></span>isprint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::isprint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report if a character is "printable". </p>
<p>Be advised that "printable" has a definition that goes back to text terminals from the dawn of computing, making this a sort of special case function that is not suitable for Unicode (or most any) text management.</p>
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values ' ' (0x20) through '~' (0x7E) as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01141">1141</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gac1876da5600f8722288dc8641d978fab" name="gac1876da5600f8722288dc8641d978fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1876da5600f8722288dc8641d978fab">&#9670;&#160;</a></span>ispunct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::ispunct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report if a character is a punctuation mark. </p>
<p><b>WARNING</b>: Regardless of system locale, this is equivalent to <code>((SDL_isgraph(x)) &amp;&amp; (!SDL_isalnum(x)))</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_isgraph </dd>
<dd>
SDL_isalnum </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01070">1070</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga922904215a42f639a8385470d5e61667" name="ga922904215a42f639a8385470d5e61667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga922904215a42f639a8385470d5e61667">&#9670;&#160;</a></span>isspace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::isspace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report if a character is whitespace. </p>
<p><b>WARNING</b>: Regardless of system locale, this will only treat the following ASCII values as true:</p>
<ul>
<li>space (0x20)</li>
<li>tab (0x09)</li>
<li>newline (0x0A)</li>
<li>vertical tab (0x0B)</li>
<li>form feed (0x0C)</li>
<li>return (0x0D)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01092">1092</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga83e29996414dc34dd0fb76a16669f05f" name="ga83e29996414dc34dd0fb76a16669f05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83e29996414dc34dd0fb76a16669f05f">&#9670;&#160;</a></span>isupper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::isupper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report if a character is upper case. </p>
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values 'A' through 'Z' as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01107">1107</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga73d02f4f146603a906c35d50197f6fd6" name="ga73d02f4f146603a906c35d50197f6fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73d02f4f146603a906c35d50197f6fd6">&#9670;&#160;</a></span>isxdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::isxdigit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report if a character is a hexadecimal digit. </p>
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values 'A' through 'F', 'a' through 'f', and '0' through '9', as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01052">1052</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gac0d19dc9f116d9f492fd4d17296f0c4b" name="gac0d19dc9f116d9f492fd4d17296f0c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0d19dc9f116d9f492fd4d17296f0c4b">&#9670;&#160;</a></span>itoa()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> * SDL::itoa </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an integer into a string. </p>
<p>This requires a radix to specified for string format. Specifying 10 produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2 to 36.</p>
<p>Note that this function will overflow a buffer if <code>str</code> is not large enough to hold the output! It may be safer to use SDL_snprintf to clamp output, or SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate much more space than you expect to use (and don't forget possible negative signs, null terminator bytes, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the integer to convert. </td></tr>
    <tr><td class="paramname">str</td><td>the buffer to write the string into. </td></tr>
    <tr><td class="paramname">radix</td><td>the radix to use for string generation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>str</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_uitoa </dd>
<dd>
SDL_ltoa </dd>
<dd>
SDL_lltoa </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02236">2236</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaddf03e9ff5a5c6ef2af0435fc32514b2" name="gaddf03e9ff5a5c6ef2af0435fc32514b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddf03e9ff5a5c6ef2af0435fc32514b2">&#9670;&#160;</a></span>lltoa()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> * SDL::lltoa </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">long</a> <a class="el" href="classSDL_1_1OptionalRef.html">long</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a long long integer into a string. </p>
<p>This requires a radix to specified for string format. Specifying 10 produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2 to 36.</p>
<p>Note that this function will overflow a buffer if <code>str</code> is not large enough to hold the output! It may be safer to use SDL_snprintf to clamp output, or SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate much more space than you expect to use (and don't forget possible negative signs, null terminator bytes, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the long long integer to convert. </td></tr>
    <tr><td class="paramname">str</td><td>the buffer to write the string into. </td></tr>
    <tr><td class="paramname">radix</td><td>the radix to use for string generation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>str</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_ulltoa </dd>
<dd>
SDL_itoa </dd>
<dd>
SDL_ltoa </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02360">2360</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga01c25ea063ceb75d5caf6ca1119a3bc1" name="ga01c25ea063ceb75d5caf6ca1119a3bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01c25ea063ceb75d5caf6ca1119a3bc1">&#9670;&#160;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the natural logarithm of <code>x</code>. </p>
<p>Domain: <code>0 &lt; x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<p>It is an error for <code>x</code> to be less than or equal to 0.</p>
<p>This function operates on double-precision floating point values, use SDL_logf for single-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. Must be greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the natural logarithm of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_logf </dd>
<dd>
SDL_log10 </dd>
<dd>
SDL_exp </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03854">3854</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gacdf9d94c27153da5d01b604342b49024" name="gacdf9d94c27153da5d01b604342b49024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdf9d94c27153da5d01b604342b49024">&#9670;&#160;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::log10 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the base-10 logarithm of <code>x</code>. </p>
<p>Domain: <code>0 &lt; x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<p>It is an error for <code>x</code> to be less than or equal to 0.</p>
<p>This function operates on double-precision floating point values, use SDL_log10f for single-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. Must be greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the logarithm of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_log10f </dd>
<dd>
SDL_log </dd>
<dd>
SDL_pow </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03913">3913</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaa8d69e4fc64b4c002aeffdf894aaa64f" name="gaa8d69e4fc64b4c002aeffdf894aaa64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8d69e4fc64b4c002aeffdf894aaa64f">&#9670;&#160;</a></span>log10f()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::log10f </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the base-10 logarithm of <code>x</code>. </p>
<p>Domain: <code>0 &lt; x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<p>It is an error for <code>x</code> to be less than or equal to 0.</p>
<p>This function operates on single-precision floating point values, use SDL_log10 for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. Must be greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the logarithm of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_log10 </dd>
<dd>
SDL_logf </dd>
<dd>
SDL_powf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03943">3943</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gab3482b1fa8e624f0f7e73ce89c0d5efb" name="gab3482b1fa8e624f0f7e73ce89c0d5efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3482b1fa8e624f0f7e73ce89c0d5efb">&#9670;&#160;</a></span>logf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::logf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the natural logarithm of <code>x</code>. </p>
<p>Domain: <code>0 &lt; x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<p>It is an error for <code>x</code> to be less than or equal to 0.</p>
<p>This function operates on single-precision floating point values, use SDL_log for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. Must be greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the natural logarithm of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_log </dd>
<dd>
SDL_expf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03883">3883</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga70024c43f89714b01cc1ff00baa682e0" name="ga70024c43f89714b01cc1ff00baa682e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70024c43f89714b01cc1ff00baa682e0">&#9670;&#160;</a></span>lround()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">long</a> SDL::lround </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round <code>x</code> to the nearest integer representable as a long. </p>
<p>Rounds <code>x</code> to the nearest integer. Values halfway between integers will be rounded away from zero.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>MIN_LONG &lt;= y &lt;= MAX_LONG</code></p>
<p>This function operates on double-precision floating point values, use SDL_lround for single-precision floats. To get the result as a floating-point type, use SDL_round.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nearest integer to <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_lroundf </dd>
<dd>
SDL_round </dd>
<dd>
SDL_floor </dd>
<dd>
SDL_ceil </dd>
<dd>
SDL_trunc </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l04134">4134</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga6878a0c3b6b75b7c15851c3dfe3d85df" name="ga6878a0c3b6b75b7c15851c3dfe3d85df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6878a0c3b6b75b7c15851c3dfe3d85df">&#9670;&#160;</a></span>lroundf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">long</a> SDL::lroundf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round <code>x</code> to the nearest integer representable as a long. </p>
<p>Rounds <code>x</code> to the nearest integer. Values halfway between integers will be rounded away from zero.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>MIN_LONG &lt;= y &lt;= MAX_LONG</code></p>
<p>This function operates on single-precision floating point values, use SDL_lroundf for double-precision floats. To get the result as a floating-point type, use SDL_roundf,</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nearest integer to <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_lround </dd>
<dd>
SDL_roundf </dd>
<dd>
SDL_floorf </dd>
<dd>
SDL_ceilf </dd>
<dd>
SDL_truncf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l04163">4163</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaee263ca33e533bf8acdd33b20e2323cf" name="gaee263ca33e533bf8acdd33b20e2323cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee263ca33e533bf8acdd33b20e2323cf">&#9670;&#160;</a></span>ltoa()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> * SDL::ltoa </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">long</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a long integer into a string. </p>
<p>This requires a radix to specified for string format. Specifying 10 produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2 to 36.</p>
<p>Note that this function will overflow a buffer if <code>str</code> is not large enough to hold the output! It may be safer to use SDL_snprintf to clamp output, or SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate much more space than you expect to use (and don't forget possible negative signs, null terminator bytes, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the long integer to convert. </td></tr>
    <tr><td class="paramname">str</td><td>the buffer to write the string into. </td></tr>
    <tr><td class="paramname">radix</td><td>the radix to use for string generation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>str</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_ultoa </dd>
<dd>
SDL_itoa </dd>
<dd>
SDL_lltoa </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02298">2298</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga48fe5521cb77ff8e4ae442bc8387be70" name="ga48fe5521cb77ff8e4ae442bc8387be70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48fe5521cb77ff8e4ae442bc8387be70">&#9670;&#160;</a></span>malloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> * SDL::malloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate uninitialized memory. </p>
<p>The allocated memory returned by this function must be freed with SDL_free().</p>
<p>If <code>size</code> is 0, it will be set to 1.</p>
<p>If you want to allocate memory aligned to a specific alignment, consider using SDL_aligned_alloc().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the size to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory, or NULL if allocation failed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_free </dd>
<dd>
SDL_calloc </dd>
<dd>
SDL_realloc </dd>
<dd>
SDL_aligned_alloc </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00122">122</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga1713911979192a927ee8202ad4ed478b" name="ga1713911979192a927ee8202ad4ed478b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1713911979192a927ee8202ad4ed478b">&#9670;&#160;</a></span>memcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::memcmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two buffers of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>the first buffer to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">s2</td><td>the second buffer to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">len</td><td>the number of bytes to compare between the buffers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if s1 is "less than" s2, greater than zero if s1 is "greater than" s2, and zero if the buffers match exactly for <code>len</code> bytes.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01382">1382</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gafe27508f0dcd3fb7902725b46f1c7e15" name="gafe27508f0dcd3fb7902725b46f1c7e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe27508f0dcd3fb7902725b46f1c7e15">&#9670;&#160;</a></span>memcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> * SDL::memcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy non-overlapping memory. </p>
<p>The memory regions must not overlap. If they do, use SDL_memmove() instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination memory region. Must not be NULL, and must not overlap with <code>src</code>. </td></tr>
    <tr><td class="paramname">src</td><td>The source memory region. Must not be NULL, and must not overlap with <code>dst</code>. </td></tr>
    <tr><td class="paramname">len</td><td>The length in bytes of both <code>dst</code> and <code>src</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>dst</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_memmove </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01295">1295</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga166c29b5162d190b0002720452a5ef43" name="ga166c29b5162d190b0002720452a5ef43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga166c29b5162d190b0002720452a5ef43">&#9670;&#160;</a></span>memmove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> * SDL::memmove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy memory ranges that might overlap. </p>
<p>It is okay for the memory regions to overlap. If you are confident that the regions never overlap, using SDL_memcpy() may improve performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination memory region. Must not be NULL. </td></tr>
    <tr><td class="paramname">src</td><td>The source memory region. Must not be NULL. </td></tr>
    <tr><td class="paramname">len</td><td>The length in bytes of both <code>dst</code> and <code>src</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>dst</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_memcpy </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01317">1317</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga5a6487beb5a07d1110c8afe1fe030446" name="ga5a6487beb5a07d1110c8afe1fe030446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a6487beb5a07d1110c8afe1fe030446">&#9670;&#160;</a></span>memset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> * SDL::memset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize all bytes of buffer of memory to a specific value. </p>
<p>This function will set <code>len</code> bytes, pointed to by <code>dst</code>, to the value specified in <code>c</code>.</p>
<p>Despite <code>c</code> being an <code>int</code> instead of a <code>char</code>, this only operates on bytes; <code>c</code> must be a value between 0 and 255, inclusive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>the destination memory region. Must not be NULL. </td></tr>
    <tr><td class="paramname">c</td><td>the byte value to set. </td></tr>
    <tr><td class="paramname">len</td><td>the length, in bytes, to set in <code>dst</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>dst</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01340">1340</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga8e06e75cea4ef203bf1f3c967f8bff54" name="ga8e06e75cea4ef203bf1f3c967f8bff54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e06e75cea4ef203bf1f3c967f8bff54">&#9670;&#160;</a></span>memset4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> * SDL::memset4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">Uint32</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>dwords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize all 32-bit words of buffer of memory to a specific value. </p>
<p>This function will set a buffer of <code>dwords</code> Uint32 values, pointed to by <code>dst</code>, to the value specified in <code>val</code>.</p>
<p>Unlike SDL_memset, this sets 32-bit values, not bytes, so it's not limited to a range of 0-255.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>the destination memory region. Must not be NULL. </td></tr>
    <tr><td class="paramname">val</td><td>the Uint32 value to set. </td></tr>
    <tr><td class="paramname">dwords</td><td>the number of Uint32 values to set in <code>dst</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>dst</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01363">1363</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga4c97858f63954904f2037d7bc81b2681" name="ga4c97858f63954904f2037d7bc81b2681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c97858f63954904f2037d7bc81b2681">&#9670;&#160;</a></span>modf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::modf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split <code>x</code> into integer and fractional parts. </p>
<p>This function operates on double-precision floating point values, use SDL_modff for single-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
    <tr><td class="paramname">y</td><td>output pointer to store the integer part of <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the fractional part of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_modff </dd>
<dd>
SDL_trunc </dd>
<dd>
SDL_fmod </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03963">3963</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga0108470ee7d88fa093ddf12185060c10" name="ga0108470ee7d88fa093ddf12185060c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0108470ee7d88fa093ddf12185060c10">&#9670;&#160;</a></span>modff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::modff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split <code>x</code> into integer and fractional parts. </p>
<p>This function operates on single-precision floating point values, use SDL_modf for double-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
    <tr><td class="paramname">y</td><td>output pointer to store the integer part of <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the fractional part of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_modf </dd>
<dd>
SDL_truncf </dd>
<dd>
SDL_fmodf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03983">3983</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaa75ce9d0d0b590cd55fce1604bb40824" name="gaa75ce9d0d0b590cd55fce1604bb40824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa75ce9d0d0b590cd55fce1604bb40824">&#9670;&#160;</a></span>murmur3_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">Uint32</a> SDL::murmur3_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">Uint32</a>&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a 32-bit MurmurHash3 value for a block of data. </p>
<p><a href="https://en.wikipedia.org/wiki/MurmurHash">https://en.wikipedia.org/wiki/MurmurHash</a></p>
<p>A seed may be specified, which changes the final results consistently, but this does not work like SDL_crc16 and SDL_crc32: you can't feed a previous result from this function back into itself as the next seed value to calculate a hash in chunks; it won't produce the same hash as it would if the same data was provided in a single call.</p>
<p>If you aren't sure what to provide for a seed, zero is fine. Murmur3 is not cryptographically secure, so it shouldn't be used for hashing top-secret data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the data to be hashed. </td></tr>
    <tr><td class="paramname">len</td><td>the size of data, in bytes. </td></tr>
    <tr><td class="paramname">seed</td><td>a value that alters the final hash value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a Murmur3 32-bit hash value.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01272">1272</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga6cfca7e593d97a56d7fca043af3ac2ce" name="ga6cfca7e593d97a56d7fca043af3ac2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cfca7e593d97a56d7fca043af3ac2ce">&#9670;&#160;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raise <code>x</code> to the power <code>y</code> </p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= z &lt;= INF</code></p>
<p>If <code>y</code> is the base of the natural logarithm (e), consider using SDL_exp instead.</p>
<p>This function operates on double-precision floating point values, use SDL_powf for single-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the base. </td></tr>
    <tr><td class="paramname">y</td><td>the exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> raised to the power <code>y</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_powf </dd>
<dd>
SDL_exp </dd>
<dd>
SDL_log </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l04015">4015</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga652fc1da140490bb87abbbf05ccfe8fa" name="ga652fc1da140490bb87abbbf05ccfe8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga652fc1da140490bb87abbbf05ccfe8fa">&#9670;&#160;</a></span>powf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::powf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raise <code>x</code> to the power <code>y</code> </p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= z &lt;= INF</code></p>
<p>If <code>y</code> is the base of the natural logarithm (e), consider using SDL_exp instead.</p>
<p>This function operates on single-precision floating point values, use SDL_powf for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the base. </td></tr>
    <tr><td class="paramname">y</td><td>the exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> raised to the power <code>y</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_pow </dd>
<dd>
SDL_expf </dd>
<dd>
SDL_logf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l04047">4047</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gab52a0ec3d96fb4c04972b1b322f75857" name="gab52a0ec3d96fb4c04972b1b322f75857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab52a0ec3d96fb4c04972b1b322f75857">&#9670;&#160;</a></span>qsort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> SDL::qsort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gabc94be94823c25031d6dd9210ef3e81a">CompareCallback</a>&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort an array. </p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_class" href="classSDL_1_1OptionalRef.html">key</a>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code hl_class" href="classSDL_1_1OptionalRef.html">string</a>;</div>
<div class="line">} data;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> SDLCALL compare(<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> data *A = (<span class="keyword">const</span> data *)a;</div>
<div class="line">    <span class="keyword">const</span> data *B = (<span class="keyword">const</span> data *)b;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (A-&gt;n &lt; B-&gt;n) {</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (B-&gt;n &lt; A-&gt;n) {</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">data values[] = {</div>
<div class="line">    { 3, <span class="stringliteral">&quot;third&quot;</span> }, { 1, <span class="stringliteral">&quot;first&quot;</span> }, { 2, <span class="stringliteral">&quot;second&quot;</span> }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">SDL_qsort(values, SDL_arraysize(values), <span class="keyword">sizeof</span>(values[0]), compare);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>a pointer to the start of the array. </td></tr>
    <tr><td class="paramname">nmemb</td><td>the number of elements in the array. </td></tr>
    <tr><td class="paramname">size</td><td>the size of the elements in the array. </td></tr>
    <tr><td class="paramname">compare</td><td>a function used to compare elements in the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_bsearch </dd>
<dd>
SDL_qsort_r </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00741">741</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaa3b0083aa5cb6236224048d437834dd2" name="gaa3b0083aa5cb6236224048d437834dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3b0083aa5cb6236224048d437834dd2">&#9670;&#160;</a></span>qsort_r()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> SDL::qsort_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gab5c634ea2ae9a102fa58cd7beac9f478">CompareCallback_r</a>&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort an array, passing a userdata pointer to the compare function. </p>
<p>For example:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> <span class="keyword">enum</span> {</div>
<div class="line">      <a class="code hl_class" href="classSDL_1_1OptionalRef.html">sort_increasing</a>,</div>
<div class="line">      <a class="code hl_class" href="classSDL_1_1OptionalRef.html">sort_decreasing</a>,</div>
<div class="line">  } sort_method;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">      <span class="keywordtype">int</span> key;</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">char</span> *string;</div>
<div class="line">  } data;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> SDLCALL compare(<span class="keyword">const</span> <span class="keywordtype">void</span> *userdata, <span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)</div>
<div class="line">  {</div>
<div class="line">      sort_method method = (sort_method)(uintptr_t)userdata;</div>
<div class="line">      <span class="keyword">const</span> data *A = (<span class="keyword">const</span> data *)a;</div>
<div class="line">      <span class="keyword">const</span> data *B = (<span class="keyword">const</span> data *)b;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">if</span> (A-&gt;key &lt; B-&gt;key) {</div>
<div class="line">          <span class="keywordflow">return</span> (method == sort_increasing) ? -1 : 1;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (B-&gt;key &lt; A-&gt;key) {</div>
<div class="line">          <span class="keywordflow">return</span> (method == sort_increasing) ? 1 : -1;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keywordflow">return</span> 0;</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  data values[] = {</div>
<div class="line">      { 3, <span class="stringliteral">&quot;third&quot;</span> }, { 1, <span class="stringliteral">&quot;first&quot;</span> }, { 2, <span class="stringliteral">&quot;second&quot;</span> }</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  SDL_qsort_r(values, SDL_arraysize(values), <span class="keyword">sizeof</span>(values[0]), compare, (<span class="keyword">const</span></div>
<div class="line">*<span class="keywordtype">void</span> *)(uintptr_t)sort_increasing);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>a pointer to the start of the array. </td></tr>
    <tr><td class="paramname">nmemb</td><td>the number of elements in the array. </td></tr>
    <tr><td class="paramname">size</td><td>the size of the elements in the array. </td></tr>
    <tr><td class="paramname">compare</td><td>a function used to compare elements in the array. </td></tr>
    <tr><td class="paramname">userdata</td><td>a pointer to pass to the compare function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_bsearch_r </dd>
<dd>
SDL_qsort </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00876">876</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaa0d119f7b42130eb3a652f7e243c8cf7" name="gaa0d119f7b42130eb3a652f7e243c8cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0d119f7b42130eb3a652f7e243c8cf7">&#9670;&#160;</a></span>rand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">Sint32</a> SDL::rand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">Sint32</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a pseudo-random number less than n for positive n. </p>
<p>The method used is faster and of better quality than <code><a class="el" href="group__CategoryStdinc.html#gaa0d119f7b42130eb3a652f7e243c8cf7" title="Generate a pseudo-random number less than n for positive n.">rand()</a> % n</code>. Odds are roughly 99.9% even for n = 1 million. Evenness is better for smaller n, and much worse as n gets bigger.</p>
<p>Example: to simulate a d6 use <code>SDL_rand(6) + 1</code> The +1 converts 0..5 to 1..6</p>
<p>If you want to generate a pseudo-random number in the full range of Sint32, you should use: (Sint32)SDL_rand_bits()</p>
<p>If you want reproducible output, be sure to initialize with SDL_srand() first.</p>
<p>There are no guarantees as to the quality of the random sequence produced, and this should not be used for security (cryptography, passwords) or where money is on the line (loot-boxes, casinos). There are many random number libraries available with different characteristics and you should pick one of those to meet any serious needs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of possible outcomes. n must be positive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a random value in the range of [0 .. n-1].</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>All calls should be made from a single thread</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_srand </dd>
<dd>
SDL_randf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02935">2935</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gae6517052066ab937273e6a89c7d1eca8" name="gae6517052066ab937273e6a89c7d1eca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6517052066ab937273e6a89c7d1eca8">&#9670;&#160;</a></span>rand_bits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">Uint32</a> SDL::rand_bits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate 32 pseudo-random bits. </p>
<p>You likely want to use SDL_rand() to get a psuedo-random number instead.</p>
<p>There are no guarantees as to the quality of the random sequence produced, and this should not be used for security (cryptography, passwords) or where money is on the line (loot-boxes, casinos). There are many random number libraries available with different characteristics and you should pick one of those to meet any serious needs.</p>
<dl class="section return"><dt>Returns</dt><dd>a random value in the range of [0-SDL_MAX_UINT32].</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>All calls should be made from a single thread</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_rand </dd>
<dd>
SDL_randf </dd>
<dd>
SDL_srand </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02981">2981</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga5fa067963ccb1728fb4e81abe36c46c6" name="ga5fa067963ccb1728fb4e81abe36c46c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fa067963ccb1728fb4e81abe36c46c6">&#9670;&#160;</a></span>rand_bits_r()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">Uint32</a> SDL::rand_bits_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">Uint64</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate 32 pseudo-random bits. </p>
<p>You likely want to use SDL_rand_r() to get a psuedo-random number instead.</p>
<p>There are no guarantees as to the quality of the random sequence produced, and this should not be used for security (cryptography, passwords) or where money is on the line (loot-boxes, casinos). There are many random number libraries available with different characteristics and you should pick one of those to meet any serious needs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>a pointer to the current random number state, this may not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a random value in the range of [0-SDL_MAX_UINT32].</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is thread-safe, as long as the state pointer isn't shared between threads.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_rand_r </dd>
<dd>
SDL_randf_r </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03068">3068</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga88a7882cb74660c593be8127ed18fb3b" name="ga88a7882cb74660c593be8127ed18fb3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88a7882cb74660c593be8127ed18fb3b">&#9670;&#160;</a></span>rand_r()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">Sint32</a> SDL::rand_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">Uint64</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">Sint32</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a pseudo-random number less than n for positive n. </p>
<p>The method used is faster and of better quality than <code><a class="el" href="group__CategoryStdinc.html#gaa0d119f7b42130eb3a652f7e243c8cf7" title="Generate a pseudo-random number less than n for positive n.">rand()</a> % n</code>. Odds are roughly 99.9% even for n = 1 million. Evenness is better for smaller n, and much worse as n gets bigger.</p>
<p>Example: to simulate a d6 use <code>SDL_rand_r(state, 6) + 1</code> The +1 converts 0..5 to 1..6</p>
<p>If you want to generate a pseudo-random number in the full range of Sint32, you should use: (Sint32)SDL_rand_bits_r(state)</p>
<p>There are no guarantees as to the quality of the random sequence produced, and this should not be used for security (cryptography, passwords) or where money is on the line (loot-boxes, casinos). There are many random number libraries available with different characteristics and you should pick one of those to meet any serious needs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>a pointer to the current random number state, this may not be NULL. </td></tr>
    <tr><td class="paramname">n</td><td>the number of possible outcomes. n must be positive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a random value in the range of [0 .. n-1].</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is thread-safe, as long as the state pointer isn't shared between threads.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_rand </dd>
<dd>
SDL_rand_bits_r </dd>
<dd>
SDL_randf_r </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03016">3016</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaab0a933463eebe63f34b3acec7e96c6e" name="gaab0a933463eebe63f34b3acec7e96c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab0a933463eebe63f34b3acec7e96c6e">&#9670;&#160;</a></span>randf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::randf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a uniform pseudo-random floating point number less than 1.0. </p>
<p>If you want reproducible output, be sure to initialize with SDL_srand() first.</p>
<p>There are no guarantees as to the quality of the random sequence produced, and this should not be used for security (cryptography, passwords) or where money is on the line (loot-boxes, casinos). There are many random number libraries available with different characteristics and you should pick one of those to meet any serious needs.</p>
<dl class="section return"><dt>Returns</dt><dd>a random value in the range of [0.0, 1.0).</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>All calls should be made from a single thread</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_srand </dd>
<dd>
SDL_rand </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02958">2958</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga6bc84a2bf06f414f7d3f9bbbe9ee6bf9" name="ga6bc84a2bf06f414f7d3f9bbbe9ee6bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bc84a2bf06f414f7d3f9bbbe9ee6bf9">&#9670;&#160;</a></span>randf_r()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::randf_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">Uint64</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a uniform pseudo-random floating point number less than 1.0. </p>
<p>If you want reproducible output, be sure to initialize with SDL_srand() first.</p>
<p>There are no guarantees as to the quality of the random sequence produced, and this should not be used for security (cryptography, passwords) or where money is on the line (loot-boxes, casinos). There are many random number libraries available with different characteristics and you should pick one of those to meet any serious needs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>a pointer to the current random number state, this may not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a random value in the range of [0.0, 1.0).</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is thread-safe, as long as the state pointer isn't shared between threads.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_rand_bits_r </dd>
<dd>
SDL_rand_r </dd>
<dd>
SDL_randf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03043">3043</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gab8208c1b381e6a96b07b5facff79c27b" name="gab8208c1b381e6a96b07b5facff79c27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8208c1b381e6a96b07b5facff79c27b">&#9670;&#160;</a></span>realloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> * SDL::realloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the size of allocated memory. </p>
<p>The memory returned by this function must be freed with SDL_free().</p>
<p>If <code>size</code> is 0, it will be set to 1. Note that this is unlike some other C runtime <code>realloc</code> implementations, which may treat <code>realloc(mem, 0)</code> the same way as <code>free(mem)</code>.</p>
<p>If <code>mem</code> is NULL, the behavior of this function is equivalent to SDL_malloc(). Otherwise, the function can have one of three possible outcomes:</p>
<ul>
<li>If it returns the same pointer as <code>mem</code>, it means that <code>mem</code> was resized in place without freeing.</li>
<li>If it returns a different non-NULL pointer, it means that <code>mem</code> was freed and cannot be dereferenced anymore.</li>
<li>If it returns NULL (indicating failure), then <code>mem</code> will remain valid and must still be freed with SDL_free().</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>a pointer to allocated memory to reallocate, or NULL. </td></tr>
    <tr><td class="paramname">size</td><td>the new size of the memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly allocated memory, or NULL if allocation failed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_free </dd>
<dd>
SDL_malloc </dd>
<dd>
SDL_calloc </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00181">181</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga58af56b2a9898c045c8ec62ec531c8e5" name="ga58af56b2a9898c045c8ec62ec531c8e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58af56b2a9898c045c8ec62ec531c8e5">&#9670;&#160;</a></span>round()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::round </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round <code>x</code> to the nearest integer. </p>
<p>Rounds <code>x</code> to the nearest integer. Values halfway between integers will be rounded away from zero.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<p>This function operates on double-precision floating point values, use SDL_roundf for single-precision floats. To get the result as an integer type, use SDL_lround.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nearest integer to <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_roundf </dd>
<dd>
SDL_lround </dd>
<dd>
SDL_floor </dd>
<dd>
SDL_ceil </dd>
<dd>
SDL_trunc </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l04076">4076</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga9cb3bb70b04800302620c3ebb81e901f" name="ga9cb3bb70b04800302620c3ebb81e901f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cb3bb70b04800302620c3ebb81e901f">&#9670;&#160;</a></span>roundf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::roundf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round <code>x</code> to the nearest integer. </p>
<p>Rounds <code>x</code> to the nearest integer. Values halfway between integers will be rounded away from zero.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<p>This function operates on double-precision floating point values, use SDL_roundf for single-precision floats. To get the result as an integer type, use SDL_lroundf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nearest integer to <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_round </dd>
<dd>
SDL_lroundf </dd>
<dd>
SDL_floorf </dd>
<dd>
SDL_ceilf </dd>
<dd>
SDL_truncf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l04105">4105</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga2438009a4b8a2f4a9155a168f6cd8303" name="ga2438009a4b8a2f4a9155a168f6cd8303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2438009a4b8a2f4a9155a168f6cd8303">&#9670;&#160;</a></span>scalbn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::scalbn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale <code>x</code> by an integer power of two. </p>
<p>Multiplies <code>x</code> by the <code>n</code>th power of the floating point radix (always 2).</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>n</code> integer</p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<p>This function operates on double-precision floating point values, use SDL_scalbnf for single-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value to be scaled. </td></tr>
    <tr><td class="paramname">n</td><td>integer exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x * 2^n</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_scalbnf </dd>
<dd>
SDL_pow </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l04188">4188</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga52e712f14d91d7ecf74bd687a5458a6d" name="ga52e712f14d91d7ecf74bd687a5458a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52e712f14d91d7ecf74bd687a5458a6d">&#9670;&#160;</a></span>scalbnf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::scalbnf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale <code>x</code> by an integer power of two. </p>
<p>Multiplies <code>x</code> by the <code>n</code>th power of the floating point radix (always 2).</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>n</code> integer</p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<p>This function operates on single-precision floating point values, use SDL_scalbn for double-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value to be scaled. </td></tr>
    <tr><td class="paramname">n</td><td>integer exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x * 2^n</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_scalbn </dd>
<dd>
SDL_powf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l04213">4213</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga97da5abe6c940c70b73fc9465cf8e75e" name="ga97da5abe6c940c70b73fc9465cf8e75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97da5abe6c940c70b73fc9465cf8e75e">&#9670;&#160;</a></span>setenv_unsafe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::setenv_unsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>overwrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of a variable in the environment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the variable to set. </td></tr>
    <tr><td class="paramname">value</td><td>the value of the variable to set. </td></tr>
    <tr><td class="paramname">overwrite</td><td>1 to overwrite the variable if it exists, 0 to return success without setting the variable if it already exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe, consider using SDL_SetEnvironmentVariable() instead.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_SetEnvironmentVariable </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00658">658</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga953e2e3777cf98a58ebbf96ee66bdddb" name="ga953e2e3777cf98a58ebbf96ee66bdddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga953e2e3777cf98a58ebbf96ee66bdddb">&#9670;&#160;</a></span>SetMemoryFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">bool</a> SDL::SetMemoryFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a>&#160;</td>
          <td class="paramname"><em>malloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a>&#160;</td>
          <td class="paramname"><em>calloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a>&#160;</td>
          <td class="paramname"><em>realloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a>&#160;</td>
          <td class="paramname"><em>free_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a>'s memory allocation functions with a custom set. </p>
<p>It is not safe to call this function once any allocations have been made, as future calls to SDL_free will use the new allocator, even if they came from an SDL_malloc made with the old one!</p>
<p>If used, usually this needs to be the first call made into the <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> library, if not the very first thing done at program startup time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">malloc_func</td><td>custom malloc function. </td></tr>
    <tr><td class="paramname">calloc_func</td><td>custom calloc function. </td></tr>
    <tr><td class="paramname">realloc_func</td><td>custom realloc function. </td></tr>
    <tr><td class="paramname">free_func</td><td>custom free function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread, but one should not replace the memory functions once any allocations are made!</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_GetMemoryFunctions </dd>
<dd>
SDL_GetOriginalMemoryFunctions </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00359">359</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga88bf16c79b920ce54e0ae909b2948663" name="ga88bf16c79b920ce54e0ae909b2948663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88bf16c79b920ce54e0ae909b2948663">&#9670;&#160;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::sin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sine of <code>x</code>. </p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-1 &lt;= y &lt;= 1</code></p>
<p>This function operates on double-precision floating point values, use SDL_sinf for single-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value, in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sine of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_sinf </dd>
<dd>
SDL_asin </dd>
<dd>
SDL_cos </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l04241">4241</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gab41ffcc72f47ca7757cdaa4a0844dd7c" name="gab41ffcc72f47ca7757cdaa4a0844dd7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab41ffcc72f47ca7757cdaa4a0844dd7c">&#9670;&#160;</a></span>sinf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::sinf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sine of <code>x</code>. </p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-1 &lt;= y &lt;= 1</code></p>
<p>This function operates on single-precision floating point values, use SDL_sin for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value, in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sine of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_sin </dd>
<dd>
SDL_asinf </dd>
<dd>
SDL_cosf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l04269">4269</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga6a8cffac163d32a70c2a38ed43b8aed6" name="ga6a8cffac163d32a70c2a38ed43b8aed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a8cffac163d32a70c2a38ed43b8aed6">&#9670;&#160;</a></span>size_add_check_overflow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">bool</a> SDL::size_add_check_overflow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> *&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add two integers, checking for overflow. </p>
<p>If <code>a + b</code> would overflow, return false.</p>
<p>Otherwise store <code>a + b</code> via ret and return true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first addend. </td></tr>
    <tr><td class="paramname">b</td><td>the second addend. </td></tr>
    <tr><td class="paramname">ret</td><td>on non-overflow output, stores the addition result, may not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false on overflow, true if result is added without overflow.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l04542">4542</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga5eff841be311c6243e4c36bc358e017f" name="ga5eff841be311c6243e4c36bc358e017f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5eff841be311c6243e4c36bc358e017f">&#9670;&#160;</a></span>size_mul_check_overflow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">bool</a> SDL::size_mul_check_overflow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> *&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two integers, checking for overflow. </p>
<p>If <code>a * b</code> would overflow, return false.</p>
<p>Otherwise store <code>a * b</code> via ret and return true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the multiplicand. </td></tr>
    <tr><td class="paramname">b</td><td>the multiplier. </td></tr>
    <tr><td class="paramname">ret</td><td>on non-overflow output, stores the multiplication result, may not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false on overflow, true if result is multiplied without overflow.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l04520">4520</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga8415b71ce1045874d7b55210806ff3c8" name="ga8415b71ce1045874d7b55210806ff3c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8415b71ce1045874d7b55210806ff3c8">&#9670;&#160;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the square root of <code>x</code>. </p>
<p>Domain: <code>0 &lt;= x &lt;= INF</code></p>
<p>Range: <code>0 &lt;= y &lt;= INF</code></p>
<p>This function operates on double-precision floating point values, use SDL_sqrtf for single-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. Must be greater than or equal to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>square root of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_sqrtf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l04295">4295</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaf7c7e59d49d88aa05125fd347beeed63" name="gaf7c7e59d49d88aa05125fd347beeed63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7c7e59d49d88aa05125fd347beeed63">&#9670;&#160;</a></span>sqrtf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::sqrtf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the square root of <code>x</code>. </p>
<p>Domain: <code>0 &lt;= x &lt;= INF</code></p>
<p>Range: <code>0 &lt;= y &lt;= INF</code></p>
<p>This function operates on single-precision floating point values, use SDL_sqrt for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. Must be greater than or equal to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>square root of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_sqrt </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l04321">4321</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga85fc72ab5435901400efdaebc1187630" name="ga85fc72ab5435901400efdaebc1187630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85fc72ab5435901400efdaebc1187630">&#9670;&#160;</a></span>srand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">void</a> SDL::srand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">Uint64</a>&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seeds the pseudo-random number generator. </p>
<p>Reusing the seed number will cause SDL_rand_*() to repeat the same stream of 'random' numbers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>the value to use as a random number seed, or 0 to use SDL_GetPerformanceCounter().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This should be called on the same thread that calls SDL_rand*()</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_rand </dd>
<dd>
SDL_rand_bits </dd>
<dd>
SDL_randf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02901">2901</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaaa1607ee6b5fddfb7d22eb518dbe59a4" name="gaaa1607ee6b5fddfb7d22eb518dbe59a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa1607ee6b5fddfb7d22eb518dbe59a4">&#9670;&#160;</a></span>StepBackUTF8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">Uint32</a> SDL::StepBackUTF8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">char</a> **&#160;</td>
          <td class="paramname"><em>pstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode a UTF-8 string in reverse, one Unicode codepoint at a time. </p>
<p>This will go to the start of the previous Unicode codepoint in the string, move <code>*pstr</code> to that location and return that codepoint.</p>
<p>If <code>*pstr</code> is already at the start of the string), it will not advance <code>*pstr</code> at all.</p>
<p>Generally this function is called in a loop until it returns zero, adjusting its parameter each iteration.</p>
<p>If an invalid UTF-8 sequence is encountered, this function returns SDL_INVALID_UNICODE_CODEPOINT.</p>
<p>Several things can generate invalid UTF-8 sequences, including overlong encodings, the use of UTF-16 surrogate values, and truncated data. Please refer to <a href="https://www.ietf.org/rfc/rfc3629.txt">RFC3629</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>a pointer to the beginning of the UTF-8 string. </td></tr>
    <tr><td class="paramname">pstr</td><td>a pointer to a UTF-8 string pointer to be read and adjusted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous Unicode codepoint in the string.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02846">2846</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaa5ecf11cf256372f67e10fafdd79141e" name="gaa5ecf11cf256372f67e10fafdd79141e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5ecf11cf256372f67e10fafdd79141e">&#9670;&#160;</a></span>StepUTF8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">Uint32</a> SDL::StepUTF8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">char</a> **&#160;</td>
          <td class="paramname"><em>pstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> *&#160;</td>
          <td class="paramname"><em>pslen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode a UTF-8 string, one Unicode codepoint at a time. </p>
<p>This will return the first Unicode codepoint in the UTF-8 encoded string in <code>*pstr</code>, and then advance <code>*pstr</code> past any consumed bytes before returning.</p>
<p>It will not access more than <code>*pslen</code> bytes from the string. <code>*pslen</code> will be adjusted, as well, subtracting the number of bytes consumed.</p>
<p><code>pslen</code> is allowed to be NULL, in which case the string <em>must</em> be NULL-terminated, as the function will blindly read until it sees the NULL char.</p>
<p>if <code>*pslen</code> is zero, it assumes the end of string is reached and returns a zero codepoint regardless of the contents of the string buffer.</p>
<p>If the resulting codepoint is zero (a NULL terminator), or <code>*pslen</code> is zero, it will not advance <code>*pstr</code> or <code>*pslen</code> at all.</p>
<p>Generally this function is called in a loop until it returns zero, adjusting its parameters each iteration.</p>
<p>If an invalid UTF-8 sequence is encountered, this function returns SDL_INVALID_UNICODE_CODEPOINT and advances the string/length by one byte (which is to say, a multibyte sequence might produce several SDL_INVALID_UNICODE_CODEPOINT returns before it syncs to the next valid UTF-8 sequence).</p>
<p>Several things can generate invalid UTF-8 sequences, including overlong encodings, the use of UTF-16 surrogate values, and truncated data. Please refer to <a href="https://www.ietf.org/rfc/rfc3629.txt">RFC3629</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pstr</td><td>a pointer to a UTF-8 string pointer to be read and adjusted. </td></tr>
    <tr><td class="paramname">pslen</td><td>a pointer to the number of bytes in the string, to be read and adjusted. NULL is allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first Unicode codepoint in the string.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02812">2812</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga932cf2487365b3a3a6fd6e37a7eddff7" name="ga932cf2487365b3a3a6fd6e37a7eddff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga932cf2487365b3a3a6fd6e37a7eddff7">&#9670;&#160;</a></span>strcasecmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::strcasecmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two null-terminated UTF-8 strings, case-insensitively. </p>
<p>This will work with Unicode strings, using a technique called "case-folding" to handle the vast majority of case-sensitive human languages regardless of system locale. It can deal with expanding values: a German Eszett character can compare against two ASCII 's' chars and be considered a match, for example. A notable exception: it does not handle the Turkish 'i' character; human language is complicated!</p>
<p>Since this handles Unicode, it expects the string to be well-formed UTF-8 and not a null-terminated string of arbitrary bytes. Bytes that are not valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT CHARACTER), which is to say two strings of random bits may turn out to match if they convert to the same amount of replacement characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. NULL is not permitted! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02701">2701</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga0d413500b6dc7d885777ecb0873c823e" name="ga0d413500b6dc7d885777ecb0873c823e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d413500b6dc7d885777ecb0873c823e">&#9670;&#160;</a></span>strcasestr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> * SDL::strcasestr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search a UTF-8 string for the first instance of a specific substring, case-insensitively. </p>
<p>This will work with Unicode strings, using a technique called "case-folding" to handle the vast majority of case-sensitive human languages regardless of system locale. It can deal with expanding values: a German Eszett character can compare against two ASCII 's' chars and be considered a match, for example. A notable exception: it does not handle the Turkish 'i' character; human language is complicated!</p>
<p>Since this handles Unicode, it expects the strings to be well-formed UTF-8 and not a null-terminated string of arbitrary bytes. Bytes that are not valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT CHARACTER), which is to say two strings of random bits may turn out to match if they convert to the same amount of replacement characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>the string to search. Must not be NULL. </td></tr>
    <tr><td class="paramname">needle</td><td>the string to search for. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first instance of <code>needle</code> in the string, or NULL if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02109">2109</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga451b842c63a514775080900ae67150da" name="ga451b842c63a514775080900ae67150da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga451b842c63a514775080900ae67150da">&#9670;&#160;</a></span>strchr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> * SDL::strchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search a string for the first instance of a specific byte. </p>
<p>The search ends once it finds the requested byte value, or a null terminator byte to end the string.</p>
<p>Note that this looks for <em>bytes</em>, not <em>characters</em>, so you cannot match against a Unicode codepoint &gt; 255, regardless of character encoding.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to search. Must not be NULL. </td></tr>
    <tr><td class="paramname">c</td><td>the byte value to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first instance of <code>c</code> in the string, or NULL if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02013">2013</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga63d50d9f0b71b04e9b038f0bc71e54c3" name="ga63d50d9f0b71b04e9b038f0bc71e54c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63d50d9f0b71b04e9b038f0bc71e54c3">&#9670;&#160;</a></span>strcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::strcmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two null-terminated UTF-8 strings. </p>
<p>Due to the nature of UTF-8 encoding, this will work with Unicode strings, since effectively this function just compares bytes until it hits a null-terminating character. Also due to the nature of UTF-8, this can be used with SDL_qsort() to put strings in (roughly) alphabetical order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. NULL is not permitted! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02637">2637</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga046b80783770b59a2cf8b4311230fbbd" name="ga046b80783770b59a2cf8b4311230fbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga046b80783770b59a2cf8b4311230fbbd">&#9670;&#160;</a></span>strdup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> * SDL::strdup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a copy of a string. </p>
<p>This allocates enough space for a null-terminated copy of <code>str</code>, using SDL_malloc, and then makes a copy of the string into this space.</p>
<p>The returned string is owned by the caller, and should be passed to SDL_free when no longer needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly-allocated string.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01902">1902</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga503a37a91faa4ed9374b9dd9db03049c" name="ga503a37a91faa4ed9374b9dd9db03049c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga503a37a91faa4ed9374b9dd9db03049c">&#9670;&#160;</a></span>strlcat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> SDL::strlcat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate strings. </p>
<p>This function appends up to <code>maxlen</code> - SDL_strlen(dst) - 1 characters from <code>src</code> to the end of the string in <code>dst</code>, then appends a null terminator.</p>
<p><code>src</code> and <code>dst</code> must not overlap.</p>
<p>If <code>maxlen</code> - SDL_strlen(dst) - 1 is less than or equal to 0, then <code>dst</code> is unmodified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination buffer already containing the first null-terminated string. Must not be NULL and must not overlap with <code>src</code>. </td></tr>
    <tr><td class="paramname">src</td><td>The second null-terminated string. Must not be NULL, and must not overlap with <code>dst</code>. </td></tr>
    <tr><td class="paramname">maxlen</td><td>The length (in characters) of the destination buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in characters, excluding the null terminator) of the string in <code>dst</code> plus the length of <code>src</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_strlcpy </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01881">1881</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga598ecc44c77a20ab4de3a96eda46ea76" name="ga598ecc44c77a20ab4de3a96eda46ea76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga598ecc44c77a20ab4de3a96eda46ea76">&#9670;&#160;</a></span>strlcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> SDL::strlcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a string. </p>
<p>This function copies up to <code>maxlen</code> - 1 characters from <code>src</code> to <code>dst</code>, then appends a null terminator.</p>
<p>If <code>maxlen</code> is 0, no characters are copied and no null terminator is written.</p>
<p>If you want to copy an UTF-8 string but need to ensure that multi-byte sequences are not truncated, consider using SDL_utf8strlcpy().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination buffer. Must not be NULL, and must not overlap with <code>src</code>. </td></tr>
    <tr><td class="paramname">src</td><td>The null-terminated string to copy. Must not be NULL, and must not overlap with <code>dst</code>. </td></tr>
    <tr><td class="paramname">maxlen</td><td>The length (in characters) of the destination buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in characters, excluding the null terminator) of <code>src</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_strlcat </dd>
<dd>
SDL_utf8strlcpy </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01819">1819</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga93de03cd7e1369ba80c5746761bac939" name="ga93de03cd7e1369ba80c5746761bac939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93de03cd7e1369ba80c5746761bac939">&#9670;&#160;</a></span>strlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> SDL::strlen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This works exactly like <a class="el" href="group__CategoryStdinc.html#ga93de03cd7e1369ba80c5746761bac939" title="This works exactly like strlen() but doesn&#39;t require access to a C runtime.">strlen()</a> but doesn't require access to a C runtime. </p>
<p>Counts the bytes in <code>str</code>, excluding the null terminator.</p>
<p>If you need the length of a UTF-8 string, consider using SDL_utf8strlen().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to read. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in bytes, excluding the null terminator) of <code>src</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_strnlen </dd>
<dd>
SDL_utf8strlen </dd>
<dd>
SDL_utf8strnlen </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01763">1763</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga15eaa2ac05317f734e1f022cfc916201" name="ga15eaa2ac05317f734e1f022cfc916201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15eaa2ac05317f734e1f022cfc916201">&#9670;&#160;</a></span>strlwr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> * SDL::strlwr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a string to lowercase. </p>
<p><b>WARNING</b>: Regardless of system locale, this will only convert ASCII values 'A' through 'Z' to lowercase.</p>
<p>This function operates on a null-terminated string of bytes&ndash;even if it is malformed UTF-8!&ndash;and converts ASCII characters 'A' through 'Z' to their lowercase equivalents in-place, returning the original <code>str</code> pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert in-place. Can not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <code>str</code> pointer passed into this function.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_strupr </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01993">1993</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga37191be89f79920285c912c0544150e8" name="ga37191be89f79920285c912c0544150e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37191be89f79920285c912c0544150e8">&#9670;&#160;</a></span>strncasecmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::strncasecmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two UTF-8 strings, case-insensitively, up to a number of bytes. </p>
<p>This will work with Unicode strings, using a technique called "case-folding" to handle the vast majority of case-sensitive human languages regardless of system locale. It can deal with expanding values: a German Eszett character can compare against two ASCII 's' chars and be considered a match, for example. A notable exception: it does not handle the Turkish 'i' character; human language is complicated!</p>
<p>Since this handles Unicode, it expects the string to be well-formed UTF-8 and not a null-terminated string of arbitrary bytes. Bytes that are not valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT CHARACTER), which is to say two strings of random bits may turn out to match if they convert to the same amount of replacement characters.</p>
<p>Note that while this function is intended to be used with UTF-8, <code>maxlen</code> specifies a <em>byte</em> limit! If the limit lands in the middle of a multi-byte UTF-8 sequence, it may convert a portion of the final character to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not to overflow a buffer.</p>
<p><code>maxlen</code> specifies a maximum number of bytes to compare; if the strings match to this number of bytes (or both have matched to a null-terminator character before this number of bytes), they will be considered equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum number of bytes to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02743">2743</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga2caad6bed5796e9524d07c21d4701af9" name="ga2caad6bed5796e9524d07c21d4701af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2caad6bed5796e9524d07c21d4701af9">&#9670;&#160;</a></span>strncmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::strncmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two UTF-8 strings up to a number of bytes. </p>
<p>Due to the nature of UTF-8 encoding, this will work with Unicode strings, since effectively this function just compares bytes until it hits a null-terminating character. Also due to the nature of UTF-8, this can be used with SDL_qsort() to put strings in (roughly) alphabetical order.</p>
<p>Note that while this function is intended to be used with UTF-8, it is doing a bytewise comparison, and <code>maxlen</code> specifies a <em>byte</em> limit! If the limit lands in the middle of a multi-byte UTF-8 sequence, it will only compare a portion of the final character.</p>
<p><code>maxlen</code> specifies a maximum number of bytes to compare; if the strings match to this number of bytes (or both have matched to a null-terminator character before this number of bytes), they will be considered equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum number of <em>bytes</em> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02670">2670</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga53e0a0ce55852f1320bc292f72dc1398" name="ga53e0a0ce55852f1320bc292f72dc1398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53e0a0ce55852f1320bc292f72dc1398">&#9670;&#160;</a></span>strndup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> * SDL::strndup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a copy of a string, up to n characters. </p>
<p>This allocates enough space for a null-terminated copy of <code>str</code>, up to <code>maxlen</code> bytes, using SDL_malloc, and then makes a copy of the string into this space.</p>
<p>If the string is longer than <code>maxlen</code> bytes, the returned string will be <code>maxlen</code> bytes long, plus a null-terminator character that isn't included in the count.</p>
<p>The returned string is owned by the caller, and should be passed to SDL_free when no longer needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to copy. </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum length of the copied string, not counting the null-terminator character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly-allocated string.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01927">1927</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga929593393da0025b602c5b4560bce5bf" name="ga929593393da0025b602c5b4560bce5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga929593393da0025b602c5b4560bce5bf">&#9670;&#160;</a></span>strnlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> SDL::strnlen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This works exactly like <a class="el" href="group__CategoryStdinc.html#ga929593393da0025b602c5b4560bce5bf" title="This works exactly like strnlen() but doesn&#39;t require access to a C runtime.">strnlen()</a> but doesn't require access to a C runtime. </p>
<p>Counts up to a maximum of <code>maxlen</code> bytes in <code>str</code>, excluding the null terminator.</p>
<p>If you need the length of a UTF-8 string, consider using SDL_utf8strnlen().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to read. Must not be NULL. </td></tr>
    <tr><td class="paramname">maxlen</td><td>The maximum amount of bytes to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in bytes, excluding the null terminator) of <code>src</code> but never more than <code>maxlen</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_strlen </dd>
<dd>
SDL_utf8strlen </dd>
<dd>
SDL_utf8strnlen </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01787">1787</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga21c1bce04f407d4dab36722078978a9b" name="ga21c1bce04f407d4dab36722078978a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21c1bce04f407d4dab36722078978a9b">&#9670;&#160;</a></span>strnstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> * SDL::strnstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search a string, up to n bytes, for the first instance of a specific substring. </p>
<p>The search ends once it finds the requested substring, or a null terminator byte to end the string, or <code>maxlen</code> bytes have been examined. It is possible to use this function on a string without a null terminator.</p>
<p>Note that this looks for strings of <em>bytes</em>, not <em>characters</em>, so it's legal to search for malformed and incomplete UTF-8 sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>the string to search. Must not be NULL. </td></tr>
    <tr><td class="paramname">needle</td><td>the string to search for. Must not be NULL. </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum number of bytes to search in <code>haystack</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first instance of <code>needle</code> in the string, or NULL if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02078">2078</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gae3838c531e1c9bbee29cdf5f4ccb60b4" name="gae3838c531e1c9bbee29cdf5f4ccb60b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3838c531e1c9bbee29cdf5f4ccb60b4">&#9670;&#160;</a></span>strpbrk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> * SDL::strpbrk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>breakset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches a string for the first occurence of any character contained in a breakset, and returns a pointer from the string to that character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to be searched. Must not be NULL, and must not overlap with <code>breakset</code>. </td></tr>
    <tr><td class="paramname">breakset</td><td>A null-terminated string containing the list of characters to look for. Must not be NULL, and must not overlap with <code>str</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the location, in str, of the first occurence of a character present in the breakset, or NULL if none is found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02764">2764</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaf67863ed8e432e74c417116a532ef24b" name="gaf67863ed8e432e74c417116a532ef24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf67863ed8e432e74c417116a532ef24b">&#9670;&#160;</a></span>strrchr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> * SDL::strrchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search a string for the last instance of a specific byte. </p>
<p>The search must go until it finds a null terminator byte to end the string.</p>
<p>Note that this looks for <em>bytes</em>, not <em>characters</em>, so you cannot match against a Unicode codepoint &gt; 255, regardless of character encoding.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to search. Must not be NULL. </td></tr>
    <tr><td class="paramname">c</td><td>the byte value to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the last instance of <code>c</code> in the string, or NULL if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02032">2032</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga32b6d922e9310ca993a82b84e692e8a5" name="ga32b6d922e9310ca993a82b84e692e8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32b6d922e9310ca993a82b84e692e8a5">&#9670;&#160;</a></span>strrev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> * SDL::strrev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse a string's contents. </p>
<p>This reverses a null-terminated string in-place. Only the content of the string is reversed; the null-terminator character remains at the end of the reversed string.</p>
<p><b>WARNING</b>: This function reverses the <em>bytes</em> of the string, not the codepoints. If <code>str</code> is a UTF-8 string with Unicode codepoints &gt; 127, this will ruin the string data. You should only use this function on strings that are completely comprised of low ASCII characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to reverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>str</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01951">1951</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga3ef7c9322f6766ee71172d34493ee792" name="ga3ef7c9322f6766ee71172d34493ee792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ef7c9322f6766ee71172d34493ee792">&#9670;&#160;</a></span>strstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> * SDL::strstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search a string for the first instance of a specific substring. </p>
<p>The search ends once it finds the requested substring, or a null terminator byte to end the string.</p>
<p>Note that this looks for strings of <em>bytes</em>, not <em>characters</em>, so it's legal to search for malformed and incomplete UTF-8 sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>the string to search. Must not be NULL. </td></tr>
    <tr><td class="paramname">needle</td><td>the string to search for. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first instance of <code>needle</code> in the string, or NULL if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02052">2052</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga062de74e1950744ad5556cc815c58036" name="ga062de74e1950744ad5556cc815c58036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga062de74e1950744ad5556cc815c58036">&#9670;&#160;</a></span>strtod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::strtod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> **&#160;</td>
          <td class="paramname"><em>endp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a <code>double</code> from a string. </p>
<p>This function makes fewer guarantees than the C runtime <code>strtod</code>:</p>
<ul>
<li>Only decimal notation is guaranteed to be supported. The handling of scientific and hexadecimal notation is unspecified.</li>
<li>Whether or not INF and NAN can be parsed is unspecified.</li>
<li>The precision of the result is unspecified.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the null-terminated string to read. Must not be NULL. </td></tr>
    <tr><td class="paramname">endp</td><td>if not NULL, the address of the first invalid character (i.e. the next character after the parsed number) will be written to this pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed <code>double</code>, or 0 if no number could be parsed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_atoi </dd>
<dd>
SDL_atof </dd>
<dd>
SDL_strtol </dd>
<dd>
SDL_strtoll </dd>
<dd>
SDL_strtoul </dd>
<dd>
SDL_strtoull </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02614">2614</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga8dc2ad6fd692f32f1304e9b1872881a2" name="ga8dc2ad6fd692f32f1304e9b1872881a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dc2ad6fd692f32f1304e9b1872881a2">&#9670;&#160;</a></span>strtok_r()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> * SDL::strtok_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> **&#160;</td>
          <td class="paramname"><em>saveptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This works exactly like <a class="el" href="group__CategoryStdinc.html#ga8dc2ad6fd692f32f1304e9b1872881a2" title="This works exactly like strtok_r() but doesn&#39;t require access to a C runtime.">strtok_r()</a> but doesn't require access to a C runtime. </p>
<p>Break a string up into a series of tokens.</p>
<p>To start tokenizing a new string, <code>str</code> should be the non-NULL address of the string to start tokenizing. Future calls to get the next token from the same string should specify a NULL.</p>
<p>Note that this function will overwrite pieces of <code>str</code> with null chars to split it into tokens. This function cannot be used with const/read-only strings!</p>
<p><code>saveptr</code> just needs to point to a <code>char *</code> that can be overwritten; <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> will use this to save tokenizing state between calls. It is initialized if <code>str</code> is non-NULL, and used to resume tokenizing when <code>str</code> is NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to tokenize, or NULL to continue tokenizing. </td></tr>
    <tr><td class="paramname">delim</td><td>the delimiter string that separates tokens. </td></tr>
    <tr><td class="paramname">saveptr</td><td>pointer to a char *, used for ongoing state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the next token, or NULL if no tokens remain.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02141">2141</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaf270570877b7a6ccaea59ba90b428043" name="gaf270570877b7a6ccaea59ba90b428043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf270570877b7a6ccaea59ba90b428043">&#9670;&#160;</a></span>strtol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">long</a> SDL::strtol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> **&#160;</td>
          <td class="paramname"><em>endp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a <code>long</code> from a string. </p>
<p>If <code>str</code> starts with whitespace, then those whitespace characters are skipped before attempting to parse the number.</p>
<p>If the parsed number does not fit inside a <code>long</code>, the result is clamped to the minimum and maximum representable <code>long</code> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to read. Must not be NULL. </td></tr>
    <tr><td class="paramname">endp</td><td>If not NULL, the address of the first invalid character (i.e. the next character after the parsed number) will be written to this pointer. </td></tr>
    <tr><td class="paramname">base</td><td>The base of the integer to read. Supported values are 0 and 2 to 36 inclusive. If 0, the base will be inferred from the number's prefix (0x for hexadecimal, 0 for octal, decimal otherwise). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed <code>long</code>, or 0 if no number could be parsed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_atoi </dd>
<dd>
SDL_atof </dd>
<dd>
SDL_strtoul </dd>
<dd>
SDL_strtoll </dd>
<dd>
SDL_strtoull </dd>
<dd>
SDL_strtod </dd>
<dd>
SDL_ltoa </dd>
<dd>
SDL_wcstol </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02473">2473</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga8211e3f409a3cc03272664dd24a5ebd0" name="ga8211e3f409a3cc03272664dd24a5ebd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8211e3f409a3cc03272664dd24a5ebd0">&#9670;&#160;</a></span>strtoll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">long</a> <a class="el" href="classSDL_1_1OptionalRef.html">long</a> SDL::strtoll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> **&#160;</td>
          <td class="paramname"><em>endp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a <code>long long</code> from a string. </p>
<p>If <code>str</code> starts with whitespace, then those whitespace characters are skipped before attempting to parse the number.</p>
<p>If the parsed number does not fit inside a <code>long long</code>, the result is clamped to the minimum and maximum representable <code>long long</code> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to read. Must not be NULL. </td></tr>
    <tr><td class="paramname">endp</td><td>If not NULL, the address of the first invalid character (i.e. the next character after the parsed number) will be written to this pointer. </td></tr>
    <tr><td class="paramname">base</td><td>The base of the integer to read. Supported values are 0 and 2 to 36 inclusive. If 0, the base will be inferred from the number's prefix (0x for hexadecimal, 0 for octal, decimal otherwise). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed <code>long long</code>, or 0 if no number could be parsed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_atoi </dd>
<dd>
SDL_atof </dd>
<dd>
SDL_strtol </dd>
<dd>
SDL_strtoul </dd>
<dd>
SDL_strtoull </dd>
<dd>
SDL_strtod </dd>
<dd>
SDL_lltoa </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02545">2545</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga3869ab21242a2a6fb41be41b382d2af2" name="ga3869ab21242a2a6fb41be41b382d2af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3869ab21242a2a6fb41be41b382d2af2">&#9670;&#160;</a></span>strtoul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">unsigned</a> <a class="el" href="classSDL_1_1OptionalRef.html">long</a> SDL::strtoul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> **&#160;</td>
          <td class="paramname"><em>endp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse an <code>unsigned long</code> from a string. </p>
<p>If <code>str</code> starts with whitespace, then those whitespace characters are skipped before attempting to parse the number.</p>
<p>If the parsed number does not fit inside an <code>unsigned long</code>, the result is clamped to the maximum representable <code>unsigned long</code> value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to read. Must not be NULL. </td></tr>
    <tr><td class="paramname">endp</td><td>If not NULL, the address of the first invalid character (i.e. the next character after the parsed number) will be written to this pointer. </td></tr>
    <tr><td class="paramname">base</td><td>The base of the integer to read. Supported values are 0 and 2 to 36 inclusive. If 0, the base will be inferred from the number's prefix (0x for hexadecimal, 0 for octal, decimal otherwise). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed <code>unsigned long</code>, or 0 if no number could be parsed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_atoi </dd>
<dd>
SDL_atof </dd>
<dd>
SDL_strtol </dd>
<dd>
SDL_strtoll </dd>
<dd>
SDL_strtoull </dd>
<dd>
SDL_strtod </dd>
<dd>
SDL_ultoa </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02509">2509</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaca9ab3ab2d4ecbb7002814ae587227af" name="gaca9ab3ab2d4ecbb7002814ae587227af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca9ab3ab2d4ecbb7002814ae587227af">&#9670;&#160;</a></span>strtoull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">unsigned</a> <a class="el" href="classSDL_1_1OptionalRef.html">long</a> <a class="el" href="classSDL_1_1OptionalRef.html">long</a> SDL::strtoull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> **&#160;</td>
          <td class="paramname"><em>endp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse an <code>unsigned long long</code> from a string. </p>
<p>If <code>str</code> starts with whitespace, then those whitespace characters are skipped before attempting to parse the number.</p>
<p>If the parsed number does not fit inside an <code>unsigned long long</code>, the result is clamped to the maximum representable <code>unsigned long long</code> value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to read. Must not be NULL. </td></tr>
    <tr><td class="paramname">endp</td><td>If not NULL, the address of the first invalid character (i.e. the next character after the parsed number) will be written to this pointer. </td></tr>
    <tr><td class="paramname">base</td><td>The base of the integer to read. Supported values are 0 and 2 to 36 inclusive. If 0, the base will be inferred from the number's prefix (0x for hexadecimal, 0 for octal, decimal otherwise). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed <code>unsigned long long</code>, or 0 if no number could be parsed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_atoi </dd>
<dd>
SDL_atof </dd>
<dd>
SDL_strtol </dd>
<dd>
SDL_strtoll </dd>
<dd>
SDL_strtoul </dd>
<dd>
SDL_strtod </dd>
<dd>
SDL_ulltoa </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02582">2582</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga7fe290f18ce6025c454f0b62729c0662" name="ga7fe290f18ce6025c454f0b62729c0662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fe290f18ce6025c454f0b62729c0662">&#9670;&#160;</a></span>strupr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> * SDL::strupr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a string to uppercase. </p>
<p><b>WARNING</b>: Regardless of system locale, this will only convert ASCII values 'A' through 'Z' to uppercase.</p>
<p>This function operates on a null-terminated string of bytes&ndash;even if it is malformed UTF-8!&ndash;and converts ASCII characters 'a' through 'z' to their uppercase equivalents in-place, returning the original <code>str</code> pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert in-place. Can not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <code>str</code> pointer passed into this function.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_strlwr </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01972">1972</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga88b5a6adb928a623a97598a7a154432c" name="ga88b5a6adb928a623a97598a7a154432c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88b5a6adb928a623a97598a7a154432c">&#9670;&#160;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::tan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the tangent of <code>x</code>. </p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<p>This function operates on double-precision floating point values, use SDL_tanf for single-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value, in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tangent of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_tanf </dd>
<dd>
SDL_sin </dd>
<dd>
SDL_cos </dd>
<dd>
SDL_atan </dd>
<dd>
SDL_atan2 </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l04351">4351</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaf14c09ac379c8fa038a9fab209b9d4d7" name="gaf14c09ac379c8fa038a9fab209b9d4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf14c09ac379c8fa038a9fab209b9d4d7">&#9670;&#160;</a></span>tanf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::tanf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the tangent of <code>x</code>. </p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<p>This function operates on single-precision floating point values, use SDL_tanf for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value, in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tangent of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_tan </dd>
<dd>
SDL_sinf </dd>
<dd>
SDL_cosf </dd>
<dd>
SDL_atanf </dd>
<dd>
SDL_atan2f </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l04381">4381</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga77f89764775d85be34bed2bc447d543a" name="ga77f89764775d85be34bed2bc447d543a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77f89764775d85be34bed2bc447d543a">&#9670;&#160;</a></span>tolower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::tolower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert low-ASCII English letters to lowercase. </p>
<p><b>WARNING</b>: Regardless of system locale, this will only convert ASCII values 'A' through 'Z' to lowercase.</p>
<p>This function returns the lowercase equivalent of <code>x</code>. If a character cannot be converted, or is already lowercase, this function returns <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lowercase version of x, or x if no conversion available.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01198">1198</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaa66528bfccd7f5a86ed7554d049d1930" name="gaa66528bfccd7f5a86ed7554d049d1930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa66528bfccd7f5a86ed7554d049d1930">&#9670;&#160;</a></span>toupper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::toupper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert low-ASCII English letters to uppercase. </p>
<p><b>WARNING</b>: Regardless of system locale, this will only convert ASCII values 'a' through 'z' to uppercase.</p>
<p>This function returns the uppercase equivalent of <code>x</code>. If a character cannot be converted, or is already uppercase, this function returns <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>capitalized version of x, or x if no conversion available.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01180">1180</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaeb64b2b465e001720dce40bacec1b937" name="gaeb64b2b465e001720dce40bacec1b937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb64b2b465e001720dce40bacec1b937">&#9670;&#160;</a></span>trunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">double</a> SDL::trunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncate <code>x</code> to an integer. </p>
<p>Rounds <code>x</code> to the next closest integer to 0. This is equivalent to removing the fractional part of <code>x</code>, leaving only the integer part.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<p>This function operates on double-precision floating point values, use SDL_truncf for single-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> truncated to an integer.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_truncf </dd>
<dd>
SDL_fmod </dd>
<dd>
SDL_ceil </dd>
<dd>
SDL_floor </dd>
<dd>
SDL_round </dd>
<dd>
SDL_lround </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03679">3679</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gae6b046a5844394a19061a8544376ffac" name="gae6b046a5844394a19061a8544376ffac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6b046a5844394a19061a8544376ffac">&#9670;&#160;</a></span>truncf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">float</a> SDL::truncf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">float</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncate <code>x</code> to an integer. </p>
<p>Rounds <code>x</code> to the next closest integer to 0. This is equivalent to removing the fractional part of <code>x</code>, leaving only the integer part.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<p>This function operates on single-precision floating point values, use SDL_truncf for double-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> truncated to an integer.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_trunc </dd>
<dd>
SDL_fmodf </dd>
<dd>
SDL_ceilf </dd>
<dd>
SDL_floorf </dd>
<dd>
SDL_roundf </dd>
<dd>
SDL_lroundf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l03708">3708</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga032867626ec7d90baa207d817fdbddcf" name="ga032867626ec7d90baa207d817fdbddcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga032867626ec7d90baa207d817fdbddcf">&#9670;&#160;</a></span>UCS4ToUTF8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> * SDL::UCS4ToUTF8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">Uint32</a>&#160;</td>
          <td class="paramname"><em>codepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a single Unicode codepoint to UTF-8. </p>
<p>The buffer pointed to by <code>dst</code> must be at least 4 bytes long, as this function may generate between 1 and 4 bytes of output.</p>
<p>This function returns the first byte <em>after</em> the newly-written UTF-8 sequence, which is useful for encoding multiple codepoints in a loop, or knowing where to write a NULL-terminator character to end the string (in either case, plan to have a buffer of <em>more</em> than 4 bytes!).</p>
<p>If <code>codepoint</code> is an invalid value (outside the Unicode range, or a UTF-16 surrogate value, etc), this will use U+FFFD (REPLACEMENT CHARACTER) for the codepoint instead, and not set an error.</p>
<p>If <code>dst</code> is NULL, this returns NULL immediately without writing to the pointer and without setting an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codepoint</td><td>a Unicode codepoint to convert to UTF-8. </td></tr>
    <tr><td class="paramname">dst</td><td>the location to write the encoded UTF-8. Must point to at least 4 bytes! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first byte past the newly-written UTF-8 sequence.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02878">2878</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga6ca0851c2d9980695748c979e2d15608" name="ga6ca0851c2d9980695748c979e2d15608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ca0851c2d9980695748c979e2d15608">&#9670;&#160;</a></span>uitoa()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> * SDL::uitoa </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">unsigned</a> <a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an unsigned integer into a string. </p>
<p>This requires a radix to specified for string format. Specifying 10 produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2 to 36.</p>
<p>Note that this function will overflow a buffer if <code>str</code> is not large enough to hold the output! It may be safer to use SDL_snprintf to clamp output, or SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate much more space than you expect to use (and don't forget null terminator bytes, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the unsigned integer to convert. </td></tr>
    <tr><td class="paramname">str</td><td>the buffer to write the string into. </td></tr>
    <tr><td class="paramname">radix</td><td>the radix to use for string generation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>str</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_itoa </dd>
<dd>
SDL_ultoa </dd>
<dd>
SDL_ulltoa </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02267">2267</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gac72cec45a7c35aeb116880203c1b03d9" name="gac72cec45a7c35aeb116880203c1b03d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac72cec45a7c35aeb116880203c1b03d9">&#9670;&#160;</a></span>ulltoa()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> * SDL::ulltoa </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">unsigned</a> <a class="el" href="classSDL_1_1OptionalRef.html">long</a> <a class="el" href="classSDL_1_1OptionalRef.html">long</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an unsigned long long integer into a string. </p>
<p>This requires a radix to specified for string format. Specifying 10 produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2 to 36.</p>
<p>Note that this function will overflow a buffer if <code>str</code> is not large enough to hold the output! It may be safer to use SDL_snprintf to clamp output, or SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate much more space than you expect to use (and don't forget null terminator bytes, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the unsigned long long integer to convert. </td></tr>
    <tr><td class="paramname">str</td><td>the buffer to write the string into. </td></tr>
    <tr><td class="paramname">radix</td><td>the radix to use for string generation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>str</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_lltoa </dd>
<dd>
SDL_uitoa </dd>
<dd>
SDL_ultoa </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02391">2391</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga2450290efea2bebff1f164a6c4a04d38" name="ga2450290efea2bebff1f164a6c4a04d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2450290efea2bebff1f164a6c4a04d38">&#9670;&#160;</a></span>ultoa()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> * SDL::ultoa </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">unsigned</a> <a class="el" href="classSDL_1_1OptionalRef.html">long</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an unsigned long integer into a string. </p>
<p>This requires a radix to specified for string format. Specifying 10 produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2 to 36.</p>
<p>Note that this function will overflow a buffer if <code>str</code> is not large enough to hold the output! It may be safer to use SDL_snprintf to clamp output, or SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate much more space than you expect to use (and don't forget null terminator bytes, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the unsigned long integer to convert. </td></tr>
    <tr><td class="paramname">str</td><td>the buffer to write the string into. </td></tr>
    <tr><td class="paramname">radix</td><td>the radix to use for string generation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>str</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_ltoa </dd>
<dd>
SDL_uitoa </dd>
<dd>
SDL_ulltoa </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02329">2329</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga7dc726179e2ae431d7db8164099e333a" name="ga7dc726179e2ae431d7db8164099e333a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dc726179e2ae431d7db8164099e333a">&#9670;&#160;</a></span>unsetenv_unsafe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::unsetenv_unsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear a variable from the environment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the variable to unset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe, consider using SDL_UnsetEnvironmentVariable() instead.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_UnsetEnvironmentVariable </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l00676">676</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga8ae726c47fde58d11167345dfda765a4" name="ga8ae726c47fde58d11167345dfda765a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ae726c47fde58d11167345dfda765a4">&#9670;&#160;</a></span>utf8strlcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> SDL::utf8strlcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">char</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>dst_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy an UTF-8 string. </p>
<p>This function copies up to <code>dst_bytes</code> - 1 bytes from <code>src</code> to <code>dst</code> while also ensuring that the string written to <code>dst</code> does not end in a truncated multi-byte sequence. Finally, it appends a null terminator.</p>
<p><code>src</code> and <code>dst</code> must not overlap.</p>
<p>Note that unlike SDL_strlcpy(), this function returns the number of bytes written, not the length of <code>src</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination buffer. Must not be NULL, and must not overlap with <code>src</code>. </td></tr>
    <tr><td class="paramname">src</td><td>The null-terminated UTF-8 string to copy. Must not be NULL, and must not overlap with <code>dst</code>. </td></tr>
    <tr><td class="paramname">dst_bytes</td><td>The length (in bytes) of the destination buffer. Must not be 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written, excluding the null terminator.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_strlcpy </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01850">1850</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga81767a08005a153d60b63896c58c106f" name="ga81767a08005a153d60b63896c58c106f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81767a08005a153d60b63896c58c106f">&#9670;&#160;</a></span>utf8strlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> SDL::utf8strlen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of codepoints in a UTF-8 string. </p>
<p>Counts the <em>codepoints</em>, not <em>bytes</em>, in <code>str</code>, excluding the null terminator.</p>
<p>If you need to count the bytes in a string instead, consider using SDL_strlen().</p>
<p>Since this handles Unicode, it expects the strings to be well-formed UTF-8 and not a null-terminated string of arbitrary bytes. Bytes that are not valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the count by several replacement characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated UTF-8 string to read. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (in codepoints, excluding the null terminator) of <code>src</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_utf8strnlen </dd>
<dd>
SDL_strlen </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02172">2172</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga82960b752efedfdd3cbfcf166d06161e" name="ga82960b752efedfdd3cbfcf166d06161e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82960b752efedfdd3cbfcf166d06161e">&#9670;&#160;</a></span>utf8strnlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> SDL::utf8strnlen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSDL.html#a45d670c7ee9fe78ad2950c1da8664ba1">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of codepoints in a UTF-8 string, up to n bytes. </p>
<p>Counts the <em>codepoints</em>, not <em>bytes</em>, in <code>str</code>, excluding the null terminator.</p>
<p>If you need to count the bytes in a string instead, consider using SDL_strnlen().</p>
<p>The counting stops at <code>bytes</code> bytes (not codepoints!). This seems counterintuitive, but makes it easy to express the total size of the string's buffer.</p>
<p>Since this handles Unicode, it expects the strings to be well-formed UTF-8 and not a null-terminated string of arbitrary bytes. Bytes that are not valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the count by several replacement characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated UTF-8 string to read. Must not be NULL. </td></tr>
    <tr><td class="paramname">bytes</td><td>The maximum amount of bytes to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (in codepoints, excluding the null terminator) of <code>src</code> but never more than <code>maxlen</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_utf8strlen </dd>
<dd>
SDL_strnlen </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l02205">2205</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gae24c494fab206e9aa27dfd9c04b35e81" name="gae24c494fab206e9aa27dfd9c04b35e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae24c494fab206e9aa27dfd9c04b35e81">&#9670;&#160;</a></span>wcscasecmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::wcscasecmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two null-terminated wide strings, case-insensitively. </p>
<p>This will work with Unicode strings, using a technique called "case-folding" to handle the vast majority of case-sensitive human languages regardless of system locale. It can deal with expanding values: a German Eszett character can compare against two ASCII 's' chars and be considered a match, for example. A notable exception: it does not handle the Turkish 'i' character; human language is complicated!</p>
<p>Depending on your platform, "wchar_t" might be 2 bytes, and expected to be UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this handles Unicode, it expects the string to be well-formed and not a null-terminated string of arbitrary bytes. Characters that are not valid UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT CHARACTER), which is to say two strings of random bits may turn out to match if they convert to the same amount of replacement characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. NULL is not permitted! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01665">1665</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga9edc1299fb56e51101501e09aaaa5b1f" name="ga9edc1299fb56e51101501e09aaaa5b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9edc1299fb56e51101501e09aaaa5b1f">&#9670;&#160;</a></span>wcscmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::wcscmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two null-terminated wide strings. </p>
<p>This only compares wchar_t values until it hits a null-terminating character; it does not care if the string is well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size), or uses valid Unicode values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. NULL is not permitted! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01598">1598</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga26f89af82ddb65cb934e2c3dc6abb807" name="ga26f89af82ddb65cb934e2c3dc6abb807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26f89af82ddb65cb934e2c3dc6abb807">&#9670;&#160;</a></span>wcsdup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> * SDL::wcsdup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td>
          <td class="paramname"><em>wstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a copy of a wide string. </p>
<p>This allocates enough space for a null-terminated copy of <code>wstr</code>, using SDL_malloc, and then makes a copy of the string into this space.</p>
<p>The returned string is owned by the caller, and should be passed to SDL_free when no longer needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstr</td><td>the string to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly-allocated wide string.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01526">1526</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaeebfd8bdc9570592d8c1a5083f5d6893" name="gaeebfd8bdc9570592d8c1a5083f5d6893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeebfd8bdc9570592d8c1a5083f5d6893">&#9670;&#160;</a></span>wcslcat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> SDL::wcslcat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate wide strings. </p>
<p>This function appends up to <code>maxlen</code> - SDL_wcslen(dst) - 1 wide characters from <code>src</code> to the end of the wide string in <code>dst</code>, then appends a null terminator.</p>
<p><code>src</code> and <code>dst</code> must not overlap.</p>
<p>If <code>maxlen</code> - SDL_wcslen(dst) - 1 is less than or equal to 0, then <code>dst</code> is unmodified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination buffer already containing the first null-terminated wide string. Must not be NULL and must not overlap with <code>src</code>. </td></tr>
    <tr><td class="paramname">src</td><td>The second null-terminated wide string. Must not be NULL, and must not overlap with <code>dst</code>. </td></tr>
    <tr><td class="paramname">maxlen</td><td>The length (in wide characters) of the destination buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in wide characters, excluding the null terminator) of the string in <code>dst</code> plus the length of <code>src</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_wcslcpy </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01505">1505</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaaa4a6075598ac1d2db01c28f76bf8c08" name="gaaa4a6075598ac1d2db01c28f76bf8c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa4a6075598ac1d2db01c28f76bf8c08">&#9670;&#160;</a></span>wcslcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> SDL::wcslcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a wide string. </p>
<p>This function copies <code>maxlen</code> - 1 wide characters from <code>src</code> to <code>dst</code>, then appends a null terminator.</p>
<p><code>src</code> and <code>dst</code> must not overlap.</p>
<p>If <code>maxlen</code> is 0, no wide characters are copied and no null terminator is written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination buffer. Must not be NULL, and must not overlap with <code>src</code>. </td></tr>
    <tr><td class="paramname">src</td><td>The null-terminated wide string to copy. Must not be NULL, and must not overlap with <code>dst</code>. </td></tr>
    <tr><td class="paramname">maxlen</td><td>The length (in wide characters) of the destination buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in wide characters, excluding the null terminator) of <code>src</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_wcslcat </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01473">1473</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gafaba3e78b66aee106f48c80864156f0a" name="gafaba3e78b66aee106f48c80864156f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaba3e78b66aee106f48c80864156f0a">&#9670;&#160;</a></span>wcslen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> SDL::wcslen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td>
          <td class="paramname"><em>wstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This works exactly like <a class="el" href="group__CategoryStdinc.html#gafaba3e78b66aee106f48c80864156f0a" title="This works exactly like wcslen() but doesn&#39;t require access to a C runtime.">wcslen()</a> but doesn't require access to a C runtime. </p>
<p>Counts the number of wchar_t values in <code>wstr</code>, excluding the null terminator.</p>
<p>Like SDL_strlen only counts bytes and not codepoints in a UTF-8 string, this counts wchar_t values in a string, even if the string's encoding is of variable width, like UTF-16.</p>
<p>Also be aware that wchar_t is different sizes on different platforms (4 bytes on Linux, 2 on Windows, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstr</td><td>The null-terminated wide string to read. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in wchar_t values, excluding the null terminator) of <code>wstr</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_wcsnlen </dd>
<dd>
SDL_utf8strlen </dd>
<dd>
SDL_utf8strnlen </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01412">1412</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gaaf1b8559eb793e57181bf418af47d555" name="gaaf1b8559eb793e57181bf418af47d555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf1b8559eb793e57181bf418af47d555">&#9670;&#160;</a></span>wcsncasecmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::wcsncasecmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td>
          <td class="paramname"><em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two wide strings, case-insensitively, up to a number of wchar_t. </p>
<p>This will work with Unicode strings, using a technique called "case-folding" to handle the vast majority of case-sensitive human languages regardless of system locale. It can deal with expanding values: a German Eszett character can compare against two ASCII 's' chars and be considered a match, for example. A notable exception: it does not handle the Turkish 'i' character; human language is complicated!</p>
<p>Depending on your platform, "wchar_t" might be 2 bytes, and expected to be UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this handles Unicode, it expects the string to be well-formed and not a null-terminated string of arbitrary bytes. Characters that are not valid UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT CHARACTER), which is to say two strings of random bits may turn out to match if they convert to the same amount of replacement characters.</p>
<p>Note that while this function might deal with variable-sized characters, <code>maxlen</code> specifies a <em>wchar</em> limit! If the limit lands in the middle of a multi-byte UTF-16 sequence, it may convert a portion of the final character to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not to overflow a buffer.</p>
<p><code>maxlen</code> specifies a maximum number of wchar_t values to compare; if the strings match to this number of wchar_t (or both have matched to a null-terminator character before this number of bytes), they will be considered equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum number of wchar_t values to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01710">1710</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga00de271aaf6fd8a464c34b16f7b419ff" name="ga00de271aaf6fd8a464c34b16f7b419ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00de271aaf6fd8a464c34b16f7b419ff">&#9670;&#160;</a></span>wcsncmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">int</a> SDL::wcsncmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td>
          <td class="paramname"><em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two wide strings up to a number of wchar_t values. </p>
<p>This only compares wchar_t values; it does not care if the string is well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size), or uses valid Unicode values.</p>
<p>Note that while this function is intended to be used with UTF-16 (or UTF-32, depending on your platform's definition of wchar_t), it is comparing raw wchar_t values and not Unicode codepoints: <code>maxlen</code> specifies a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16 sequence, it will only compare a portion of the final character.</p>
<p><code>maxlen</code> specifies a maximum number of wchar_t to compare; if the strings match to this number of wide chars (or both have matched to a null-terminator character before this count), they will be considered equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum number of wchar_t to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01632">1632</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga83f6331afec19491a73e0f711d7b3faf" name="ga83f6331afec19491a73e0f711d7b3faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83f6331afec19491a73e0f711d7b3faf">&#9670;&#160;</a></span>wcsnlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a> SDL::wcsnlen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td>
          <td class="paramname"><em>wstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This works exactly like <a class="el" href="group__CategoryStdinc.html#ga83f6331afec19491a73e0f711d7b3faf" title="This works exactly like wcsnlen() but doesn&#39;t require access to a C runtime.">wcsnlen()</a> but doesn't require access to a C runtime. </p>
<p>Counts up to a maximum of <code>maxlen</code> wchar_t values in <code>wstr</code>, excluding the null terminator.</p>
<p>Like SDL_strnlen only counts bytes and not codepoints in a UTF-8 string, this counts wchar_t values in a string, even if the string's encoding is of variable width, like UTF-16.</p>
<p>Also be aware that wchar_t is different sizes on different platforms (4 bytes on Linux, 2 on Windows, etc).</p>
<p>Also, <code>maxlen</code> is a count of wide characters, not bytes!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstr</td><td>The null-terminated wide string to read. Must not be NULL. </td></tr>
    <tr><td class="paramname">maxlen</td><td>The maximum amount of wide characters to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in wide characters, excluding the null terminator) of <code>wstr</code> but never more than <code>maxlen</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_wcslen </dd>
<dd>
SDL_utf8strlen </dd>
<dd>
SDL_utf8strnlen </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01443">1443</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gacc794d23fc0f8b51d4abbcf226e6d7c7" name="gacc794d23fc0f8b51d4abbcf226e6d7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc794d23fc0f8b51d4abbcf226e6d7c7">&#9670;&#160;</a></span>wcsnstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> * SDL::wcsnstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">size_t</a>&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search a wide string, up to n wide chars, for the first instance of a specific substring. </p>
<p>The search ends once it finds the requested substring, or a null terminator value to end the string, or <code>maxlen</code> wide character have been examined. It is possible to use this function on a wide string without a null terminator.</p>
<p>Note that this looks for strings of <em>wide characters</em>, not <em>codepoints</em>, so it's legal to search for malformed and incomplete UTF-16 sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>the wide string to search. Must not be NULL. </td></tr>
    <tr><td class="paramname">needle</td><td>the wide string to search for. Must not be NULL. </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum number of wide characters to search in <code>haystack</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first instance of <code>needle</code> in the string, or NULL if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01574">1574</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="gad864d11d477fc831eb7fcd5a40fbe615" name="gad864d11d477fc831eb7fcd5a40fbe615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad864d11d477fc831eb7fcd5a40fbe615">&#9670;&#160;</a></span>wcsstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> * SDL::wcsstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search a wide string for the first instance of a specific substring. </p>
<p>The search ends once it finds the requested substring, or a null terminator byte to end the string.</p>
<p>Note that this looks for strings of <em>wide characters</em>, not <em>codepoints</em>, so it's legal to search for malformed and incomplete UTF-16 sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>the wide string to search. Must not be NULL. </td></tr>
    <tr><td class="paramname">needle</td><td>the wide string to search for. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first instance of <code>needle</code> in the string, or NULL if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01546">1546</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
<a id="ga0408a155d55fa0fc2d0198de99ca0dc4" name="ga0408a155d55fa0fc2d0198de99ca0dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0408a155d55fa0fc2d0198de99ca0dc4">&#9670;&#160;</a></span>wcstol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDL_1_1OptionalRef.html">long</a> SDL::wcstol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">const</a> <a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">wchar_t</a> **&#160;</td>
          <td class="paramname"><em>endp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1OptionalRef.html">int</a>&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a <code>long</code> from a wide string. </p>
<p>If <code>str</code> starts with whitespace, then those whitespace characters are skipped before attempting to parse the number.</p>
<p>If the parsed number does not fit inside a <code>long</code>, the result is clamped to the minimum and maximum representable <code>long</code> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated wide string to read. Must not be NULL. </td></tr>
    <tr><td class="paramname">endp</td><td>If not NULL, the address of the first invalid wide character (i.e. the next character after the parsed number) will be written to this pointer. </td></tr>
    <tr><td class="paramname">base</td><td>The base of the integer to read. Supported values are 0 and 2 to 36 inclusive. If 0, the base will be inferred from the number's prefix (0x for hexadecimal, 0 for octal, decimal otherwise). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed <code>long</code>, or 0 if no number could be parsed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_strtol </dd></dl>

<p class="definition">Definition at line <a class="el" href="SDL3pp__stdinc_8h_source.html#l01740">1740</a> of file <a class="el" href="SDL3pp__stdinc_8h_source.html">SDL3pp_stdinc.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
