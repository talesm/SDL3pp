<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDL3pp: Standard Library Functionality</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SDL3pp
   </div>
   <div id="projectbrief">A slim C++ wrapper for SDL3</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Standard Library Functionality<div class="ingroups"><a class="el" href="group__Categories.html">Categories</a> &raquo; <a class="el" href="group__CategoriesAdditionalFunctionality.html">Additional Functionality</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> provides its own implementation of some of the most important C runtime functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1EnvironmentBase.html">SDL::EnvironmentBase&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread-safe set of environment variables.  <a href="structSDL_1_1EnvironmentBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1IConvBase.html">SDL::IConvBase&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque handle representing string encoding conversion state.  <a href="structSDL_1_1IConvBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1Random.html">SDL::Random</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A independent pseudo random state.  <a href="classSDL_1_1Random.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga61951c691e5b53e2c5261c8f3536531e" id="r_ga61951c691e5b53e2c5261c8f3536531e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga61951c691e5b53e2c5261c8f3536531e">SDL::EnvironmentRef</a> = <a class="el" href="structSDL_1_1EnvironmentBase.html">EnvironmentBase</a>&lt; <a class="el" href="classSDL_1_1ObjectRef.html">ObjectRef</a>&lt; SDL_Environment &gt; &gt;</td></tr>
<tr class="memdesc:ga61951c691e5b53e2c5261c8f3536531e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to a non owning environment.  <br /></td></tr>
<tr class="separator:ga61951c691e5b53e2c5261c8f3536531e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedb86e9b9bb1aca04f73942d06b1d98f" id="r_gaedb86e9b9bb1aca04f73942d06b1d98f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaedb86e9b9bb1aca04f73942d06b1d98f">SDL::Environment</a> = <a class="el" href="structSDL_1_1EnvironmentBase.html">EnvironmentBase</a>&lt; <a class="el" href="classSDL_1_1ObjectUnique.html">ObjectUnique</a>&lt; SDL_Environment &gt; &gt;</td></tr>
<tr class="memdesc:gaedb86e9b9bb1aca04f73942d06b1d98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to an owning environment.  <br /></td></tr>
<tr class="separator:gaedb86e9b9bb1aca04f73942d06b1d98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d2eecfc83ea54cacb89f4fec27fa0b0" id="r_ga3d2eecfc83ea54cacb89f4fec27fa0b0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga3d2eecfc83ea54cacb89f4fec27fa0b0">SDL::IConvRef</a> = <a class="el" href="structSDL_1_1IConvBase.html">IConvBase</a>&lt; <a class="el" href="classSDL_1_1ObjectRef.html">ObjectRef</a>&lt; SDL_iconv_data_t &gt; &gt;</td></tr>
<tr class="memdesc:ga3d2eecfc83ea54cacb89f4fec27fa0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to a non owning iconv.  <br /></td></tr>
<tr class="separator:ga3d2eecfc83ea54cacb89f4fec27fa0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95fcbc65252fd494d78ce162e1340bea" id="r_ga95fcbc65252fd494d78ce162e1340bea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga95fcbc65252fd494d78ce162e1340bea">SDL::IConv</a> = <a class="el" href="structSDL_1_1IConvBase.html">IConvBase</a>&lt; <a class="el" href="classSDL_1_1ObjectUnique.html">ObjectUnique</a>&lt; SDL_iconv_data_t &gt; &gt;</td></tr>
<tr class="memdesc:ga95fcbc65252fd494d78ce162e1340bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to an owning iconv.  <br /></td></tr>
<tr class="separator:ga95fcbc65252fd494d78ce162e1340bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cdca510cc08a5569b9e76462e19242f" id="r_ga4cdca510cc08a5569b9e76462e19242f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga4cdca510cc08a5569b9e76462e19242f">SDL::Time</a> = SDL_Time</td></tr>
<tr class="memdesc:ga4cdca510cc08a5569b9e76462e19242f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> times are signed, 64-bit integers representing nanoseconds since the Unix epoch (Jan 1, 1970).  <br /></td></tr>
<tr class="separator:ga4cdca510cc08a5569b9e76462e19242f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20e849be3a477a832c3f5b49aa71f793" id="r_ga20e849be3a477a832c3f5b49aa71f793"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">SDL::malloc_func</a> = SDL_malloc_func</td></tr>
<tr class="memdesc:ga20e849be3a477a832c3f5b49aa71f793"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback used to implement SDL_malloc().  <br /></td></tr>
<tr class="separator:ga20e849be3a477a832c3f5b49aa71f793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f2714c0d9540b5e1e85ed5503c59215" id="r_ga4f2714c0d9540b5e1e85ed5503c59215"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">SDL::calloc_func</a> = SDL_calloc_func</td></tr>
<tr class="memdesc:ga4f2714c0d9540b5e1e85ed5503c59215"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback used to implement SDL_calloc().  <br /></td></tr>
<tr class="separator:ga4f2714c0d9540b5e1e85ed5503c59215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0d42a4ebfbbe5ab7908f55ba0560ecb" id="r_gaa0d42a4ebfbbe5ab7908f55ba0560ecb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">SDL::realloc_func</a> = SDL_realloc_func</td></tr>
<tr class="memdesc:gaa0d42a4ebfbbe5ab7908f55ba0560ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback used to implement SDL_realloc().  <br /></td></tr>
<tr class="separator:gaa0d42a4ebfbbe5ab7908f55ba0560ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80cbbb5b121c8f78d44a66deaa573127" id="r_ga80cbbb5b121c8f78d44a66deaa573127"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">SDL::free_func</a> = SDL_free_func</td></tr>
<tr class="memdesc:ga80cbbb5b121c8f78d44a66deaa573127"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback used to implement SDL_free().  <br /></td></tr>
<tr class="separator:ga80cbbb5b121c8f78d44a66deaa573127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc94be94823c25031d6dd9210ef3e81a" id="r_gabc94be94823c25031d6dd9210ef3e81a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gabc94be94823c25031d6dd9210ef3e81a">SDL::CompareCallback</a> = SDL_CompareCallback</td></tr>
<tr class="memdesc:gabc94be94823c25031d6dd9210ef3e81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback used with <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> sorting and binary search functions.  <br /></td></tr>
<tr class="separator:gabc94be94823c25031d6dd9210ef3e81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5c634ea2ae9a102fa58cd7beac9f478" id="r_gab5c634ea2ae9a102fa58cd7beac9f478"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab5c634ea2ae9a102fa58cd7beac9f478">SDL::CompareCallback_r</a> = SDL_CompareCallback_r</td></tr>
<tr class="memdesc:gab5c634ea2ae9a102fa58cd7beac9f478"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback used with <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> sorting and binary search functions.  <br /></td></tr>
<tr class="separator:gab5c634ea2ae9a102fa58cd7beac9f478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga379a3713730374c4737a2bfb2004fab7" id="r_ga379a3713730374c4737a2bfb2004fab7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga379a3713730374c4737a2bfb2004fab7">SDL::FunctionPointer</a> = SDL_FunctionPointer</td></tr>
<tr class="memdesc:ga379a3713730374c4737a2bfb2004fab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic function pointer.  <br /></td></tr>
<tr class="separator:ga379a3713730374c4737a2bfb2004fab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa932b3872f6162d7257c924b184e5381" id="r_gaa932b3872f6162d7257c924b184e5381"><td class="memItemLeft" align="right" valign="top">constexpr Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa932b3872f6162d7257c924b184e5381">SDL::FourCC</a> (Uint8 a, Uint8 b, Uint8 c, Uint8 d)</td></tr>
<tr class="memdesc:gaa932b3872f6162d7257c924b184e5381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a four character code as a Uint32.  <br /></td></tr>
<tr class="separator:gaa932b3872f6162d7257c924b184e5381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48fe5521cb77ff8e4ae442bc8387be70" id="r_ga48fe5521cb77ff8e4ae442bc8387be70"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga48fe5521cb77ff8e4ae442bc8387be70">SDL::malloc</a> (size_t size)</td></tr>
<tr class="memdesc:ga48fe5521cb77ff8e4ae442bc8387be70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate uninitialized memory.  <br /></td></tr>
<tr class="separator:ga48fe5521cb77ff8e4ae442bc8387be70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab24b3e9482f5a1c26602b83f2de05d09" id="r_gab24b3e9482f5a1c26602b83f2de05d09"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab24b3e9482f5a1c26602b83f2de05d09">SDL::calloc</a> (size_t nmemb, size_t size)</td></tr>
<tr class="memdesc:gab24b3e9482f5a1c26602b83f2de05d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a zero-initialized array.  <br /></td></tr>
<tr class="separator:gab24b3e9482f5a1c26602b83f2de05d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8208c1b381e6a96b07b5facff79c27b" id="r_gab8208c1b381e6a96b07b5facff79c27b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab8208c1b381e6a96b07b5facff79c27b">SDL::realloc</a> (void *mem, size_t size)</td></tr>
<tr class="memdesc:gab8208c1b381e6a96b07b5facff79c27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the size of allocated memory.  <br /></td></tr>
<tr class="separator:gab8208c1b381e6a96b07b5facff79c27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfa01257ca1f966fffb72f002db27fa6" id="r_gadfa01257ca1f966fffb72f002db27fa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gadfa01257ca1f966fffb72f002db27fa6">SDL::free</a> (void *mem)</td></tr>
<tr class="memdesc:gadfa01257ca1f966fffb72f002db27fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free allocated memory.  <br /></td></tr>
<tr class="separator:gadfa01257ca1f966fffb72f002db27fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6325f645ab936554e7aaa2e4d977d9d7" id="r_ga6325f645ab936554e7aaa2e4d977d9d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga6325f645ab936554e7aaa2e4d977d9d7">SDL::GetOriginalMemoryFunctions</a> (<a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a> *<a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a>, <a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a> *<a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a>, <a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a> *<a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a>, <a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a> *<a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a>)</td></tr>
<tr class="memdesc:ga6325f645ab936554e7aaa2e4d977d9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the original set of <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> memory functions.  <br /></td></tr>
<tr class="separator:ga6325f645ab936554e7aaa2e4d977d9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab331691e9cf41b2fd9063b80910ea6b0" id="r_gab331691e9cf41b2fd9063b80910ea6b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab331691e9cf41b2fd9063b80910ea6b0">SDL::GetMemoryFunctions</a> (<a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a> *<a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a>, <a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a> *<a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a>, <a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a> *<a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a>, <a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a> *<a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a>)</td></tr>
<tr class="memdesc:gab331691e9cf41b2fd9063b80910ea6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current set of <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> memory functions.  <br /></td></tr>
<tr class="separator:gab331691e9cf41b2fd9063b80910ea6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga953e2e3777cf98a58ebbf96ee66bdddb" id="r_ga953e2e3777cf98a58ebbf96ee66bdddb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga953e2e3777cf98a58ebbf96ee66bdddb">SDL::SetMemoryFunctions</a> (<a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a> <a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a>, <a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a> <a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a>, <a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a> <a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a>, <a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a> <a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a>)</td></tr>
<tr class="memdesc:ga953e2e3777cf98a58ebbf96ee66bdddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a>'s memory allocation functions with a custom set.  <br /></td></tr>
<tr class="separator:ga953e2e3777cf98a58ebbf96ee66bdddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3c9f70ddeadaecb2afeee2b3be34733" id="r_gae3c9f70ddeadaecb2afeee2b3be34733"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae3c9f70ddeadaecb2afeee2b3be34733">SDL::aligned_alloc</a> (size_t alignment, size_t size)</td></tr>
<tr class="memdesc:gae3c9f70ddeadaecb2afeee2b3be34733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory aligned to a specific alignment.  <br /></td></tr>
<tr class="separator:gae3c9f70ddeadaecb2afeee2b3be34733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf1efed697d82742be084a1871c95aa2" id="r_gaaf1efed697d82742be084a1871c95aa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaaf1efed697d82742be084a1871c95aa2">SDL::aligned_free</a> (void *mem)</td></tr>
<tr class="memdesc:gaaf1efed697d82742be084a1871c95aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated by SDL_aligned_alloc().  <br /></td></tr>
<tr class="separator:gaaf1efed697d82742be084a1871c95aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae51ea510815eaec3a9b288754a805206" id="r_gae51ea510815eaec3a9b288754a805206"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae51ea510815eaec3a9b288754a805206">SDL::GetNumAllocations</a> ()</td></tr>
<tr class="memdesc:gae51ea510815eaec3a9b288754a805206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of outstanding (unfreed) allocations.  <br /></td></tr>
<tr class="separator:gae51ea510815eaec3a9b288754a805206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc9e4411ee1c8072c58cbfa0566a5660" id="r_gafc9e4411ee1c8072c58cbfa0566a5660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CategoryStdinc.html#ga61951c691e5b53e2c5261c8f3536531e">EnvironmentRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gafc9e4411ee1c8072c58cbfa0566a5660">SDL::GetEnvironment</a> ()</td></tr>
<tr class="memdesc:gafc9e4411ee1c8072c58cbfa0566a5660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the process environment.  <br /></td></tr>
<tr class="separator:gafc9e4411ee1c8072c58cbfa0566a5660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97502b219bb63f4be0f31868fecc9120" id="r_ga97502b219bb63f4be0f31868fecc9120"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga97502b219bb63f4be0f31868fecc9120">SDL::getenv</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> name)</td></tr>
<tr class="memdesc:ga97502b219bb63f4be0f31868fecc9120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a variable in the environment.  <br /></td></tr>
<tr class="separator:ga97502b219bb63f4be0f31868fecc9120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a55c001e123a53e424cbc460ec4b1b6" id="r_ga8a55c001e123a53e424cbc460ec4b1b6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8a55c001e123a53e424cbc460ec4b1b6">SDL::getenv_unsafe</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> name)</td></tr>
<tr class="memdesc:ga8a55c001e123a53e424cbc460ec4b1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a variable in the environment.  <br /></td></tr>
<tr class="separator:ga8a55c001e123a53e424cbc460ec4b1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97da5abe6c940c70b73fc9465cf8e75e" id="r_ga97da5abe6c940c70b73fc9465cf8e75e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga97da5abe6c940c70b73fc9465cf8e75e">SDL::setenv_unsafe</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> name, <a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> value, int overwrite)</td></tr>
<tr class="memdesc:ga97da5abe6c940c70b73fc9465cf8e75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a variable in the environment.  <br /></td></tr>
<tr class="separator:ga97da5abe6c940c70b73fc9465cf8e75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dc726179e2ae431d7db8164099e333a" id="r_ga7dc726179e2ae431d7db8164099e333a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga7dc726179e2ae431d7db8164099e333a">SDL::unsetenv_unsafe</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> name)</td></tr>
<tr class="memdesc:ga7dc726179e2ae431d7db8164099e333a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a variable from the environment.  <br /></td></tr>
<tr class="separator:ga7dc726179e2ae431d7db8164099e333a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab52a0ec3d96fb4c04972b1b322f75857" id="r_gab52a0ec3d96fb4c04972b1b322f75857"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab52a0ec3d96fb4c04972b1b322f75857">SDL::qsort</a> (void *base, size_t nmemb, size_t size, <a class="el" href="group__CategoryStdinc.html#gabc94be94823c25031d6dd9210ef3e81a">CompareCallback</a> compare)</td></tr>
<tr class="memdesc:gab52a0ec3d96fb4c04972b1b322f75857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an array.  <br /></td></tr>
<tr class="separator:gab52a0ec3d96fb4c04972b1b322f75857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada62aea13b8eceffa3e57359e124e541" id="r_gada62aea13b8eceffa3e57359e124e541"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gada62aea13b8eceffa3e57359e124e541">SDL::bsearch</a> (const void *key, const void *base, size_t nmemb, size_t size, <a class="el" href="group__CategoryStdinc.html#gabc94be94823c25031d6dd9210ef3e81a">CompareCallback</a> compare)</td></tr>
<tr class="memdesc:gada62aea13b8eceffa3e57359e124e541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a binary search on a previously sorted array.  <br /></td></tr>
<tr class="separator:gada62aea13b8eceffa3e57359e124e541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3b0083aa5cb6236224048d437834dd2" id="r_gaa3b0083aa5cb6236224048d437834dd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa3b0083aa5cb6236224048d437834dd2">SDL::qsort_r</a> (void *base, size_t nmemb, size_t size, <a class="el" href="group__CategoryStdinc.html#gab5c634ea2ae9a102fa58cd7beac9f478">CompareCallback_r</a> compare, void *userdata)</td></tr>
<tr class="memdesc:gaa3b0083aa5cb6236224048d437834dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an array, passing a userdata pointer to the compare function.  <br /></td></tr>
<tr class="separator:gaa3b0083aa5cb6236224048d437834dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf22f982867b4598c8caa2de8f5a9e0e4" id="r_gaf22f982867b4598c8caa2de8f5a9e0e4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaf22f982867b4598c8caa2de8f5a9e0e4">SDL::bsearch_r</a> (const void *key, const void *base, size_t nmemb, size_t size, <a class="el" href="group__CategoryStdinc.html#gab5c634ea2ae9a102fa58cd7beac9f478">CompareCallback_r</a> compare, void *userdata)</td></tr>
<tr class="memdesc:gaf22f982867b4598c8caa2de8f5a9e0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a binary search on a previously sorted array, passing a userdata pointer to the compare function.  <br /></td></tr>
<tr class="separator:gaf22f982867b4598c8caa2de8f5a9e0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab188f3aa930df339c851b95bf2c4030b" id="r_gab188f3aa930df339c851b95bf2c4030b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab188f3aa930df339c851b95bf2c4030b">SDL::abs</a> (int x)</td></tr>
<tr class="memdesc:gab188f3aa930df339c851b95bf2c4030b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of <code>x</code>.  <br /></td></tr>
<tr class="separator:gab188f3aa930df339c851b95bf2c4030b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79256765fa0f219b5947721d1d920041" id="r_ga79256765fa0f219b5947721d1d920041"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga79256765fa0f219b5947721d1d920041">SDL::isalpha</a> (int x)</td></tr>
<tr class="memdesc:ga79256765fa0f219b5947721d1d920041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if a character is alphabetic (a letter).  <br /></td></tr>
<tr class="separator:ga79256765fa0f219b5947721d1d920041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc3565e81c3ab6ba0e66f9030c056969" id="r_gafc3565e81c3ab6ba0e66f9030c056969"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gafc3565e81c3ab6ba0e66f9030c056969">SDL::isalnum</a> (int x)</td></tr>
<tr class="memdesc:gafc3565e81c3ab6ba0e66f9030c056969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if a character is alphabetic (a letter) or a number.  <br /></td></tr>
<tr class="separator:gafc3565e81c3ab6ba0e66f9030c056969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6936f2d259cb2959c3d73e8bb66cf0d" id="r_gab6936f2d259cb2959c3d73e8bb66cf0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab6936f2d259cb2959c3d73e8bb66cf0d">SDL::isblank</a> (int x)</td></tr>
<tr class="memdesc:gab6936f2d259cb2959c3d73e8bb66cf0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is blank (a space or tab).  <br /></td></tr>
<tr class="separator:gab6936f2d259cb2959c3d73e8bb66cf0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga901f942513d4469f8722185f0cee85bd" id="r_ga901f942513d4469f8722185f0cee85bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga901f942513d4469f8722185f0cee85bd">SDL::iscntrl</a> (int x)</td></tr>
<tr class="memdesc:ga901f942513d4469f8722185f0cee85bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is a control character.  <br /></td></tr>
<tr class="separator:ga901f942513d4469f8722185f0cee85bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c4d5430375fa896b58aa1e5a23cd30f" id="r_ga3c4d5430375fa896b58aa1e5a23cd30f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga3c4d5430375fa896b58aa1e5a23cd30f">SDL::isdigit</a> (int x)</td></tr>
<tr class="memdesc:ga3c4d5430375fa896b58aa1e5a23cd30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is a numeric digit.  <br /></td></tr>
<tr class="separator:ga3c4d5430375fa896b58aa1e5a23cd30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73d02f4f146603a906c35d50197f6fd6" id="r_ga73d02f4f146603a906c35d50197f6fd6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga73d02f4f146603a906c35d50197f6fd6">SDL::isxdigit</a> (int x)</td></tr>
<tr class="memdesc:ga73d02f4f146603a906c35d50197f6fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is a hexadecimal digit.  <br /></td></tr>
<tr class="separator:ga73d02f4f146603a906c35d50197f6fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1876da5600f8722288dc8641d978fab" id="r_gac1876da5600f8722288dc8641d978fab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gac1876da5600f8722288dc8641d978fab">SDL::ispunct</a> (int x)</td></tr>
<tr class="memdesc:gac1876da5600f8722288dc8641d978fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is a punctuation mark.  <br /></td></tr>
<tr class="separator:gac1876da5600f8722288dc8641d978fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga922904215a42f639a8385470d5e61667" id="r_ga922904215a42f639a8385470d5e61667"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga922904215a42f639a8385470d5e61667">SDL::isspace</a> (int x)</td></tr>
<tr class="memdesc:ga922904215a42f639a8385470d5e61667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is whitespace.  <br /></td></tr>
<tr class="separator:ga922904215a42f639a8385470d5e61667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83e29996414dc34dd0fb76a16669f05f" id="r_ga83e29996414dc34dd0fb76a16669f05f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga83e29996414dc34dd0fb76a16669f05f">SDL::isupper</a> (int x)</td></tr>
<tr class="memdesc:ga83e29996414dc34dd0fb76a16669f05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is upper case.  <br /></td></tr>
<tr class="separator:ga83e29996414dc34dd0fb76a16669f05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9154645a2881fcb9f6c1df5c4d848ef1" id="r_ga9154645a2881fcb9f6c1df5c4d848ef1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga9154645a2881fcb9f6c1df5c4d848ef1">SDL::islower</a> (int x)</td></tr>
<tr class="memdesc:ga9154645a2881fcb9f6c1df5c4d848ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is lower case.  <br /></td></tr>
<tr class="separator:ga9154645a2881fcb9f6c1df5c4d848ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ff81eceb17060ed3c3c7c32a14bf7b8" id="r_ga6ff81eceb17060ed3c3c7c32a14bf7b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga6ff81eceb17060ed3c3c7c32a14bf7b8">SDL::isprint</a> (int x)</td></tr>
<tr class="memdesc:ga6ff81eceb17060ed3c3c7c32a14bf7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is "printable".  <br /></td></tr>
<tr class="separator:ga6ff81eceb17060ed3c3c7c32a14bf7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28e4c655a653424f510993ddec5b02b4" id="r_ga28e4c655a653424f510993ddec5b02b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga28e4c655a653424f510993ddec5b02b4">SDL::isgraph</a> (int x)</td></tr>
<tr class="memdesc:ga28e4c655a653424f510993ddec5b02b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if a character is any "printable" except space.  <br /></td></tr>
<tr class="separator:ga28e4c655a653424f510993ddec5b02b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa66528bfccd7f5a86ed7554d049d1930" id="r_gaa66528bfccd7f5a86ed7554d049d1930"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa66528bfccd7f5a86ed7554d049d1930">SDL::toupper</a> (int x)</td></tr>
<tr class="memdesc:gaa66528bfccd7f5a86ed7554d049d1930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert low-ASCII English letters to uppercase.  <br /></td></tr>
<tr class="separator:gaa66528bfccd7f5a86ed7554d049d1930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f89764775d85be34bed2bc447d543a" id="r_ga77f89764775d85be34bed2bc447d543a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga77f89764775d85be34bed2bc447d543a">SDL::tolower</a> (int x)</td></tr>
<tr class="memdesc:ga77f89764775d85be34bed2bc447d543a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert low-ASCII English letters to lowercase.  <br /></td></tr>
<tr class="separator:ga77f89764775d85be34bed2bc447d543a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31ee6fbdefd2ca34bbde4c8652069e66" id="r_ga31ee6fbdefd2ca34bbde4c8652069e66"><td class="memItemLeft" align="right" valign="top">Uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga31ee6fbdefd2ca34bbde4c8652069e66">SDL::crc16</a> (Uint16 crc, const void *data, size_t len)</td></tr>
<tr class="memdesc:ga31ee6fbdefd2ca34bbde4c8652069e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a CRC-16 value.  <br /></td></tr>
<tr class="separator:ga31ee6fbdefd2ca34bbde4c8652069e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc8b8bc6d26dd888c3fed721ddb1cd2e" id="r_gacc8b8bc6d26dd888c3fed721ddb1cd2e"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gacc8b8bc6d26dd888c3fed721ddb1cd2e">SDL::crc32</a> (Uint32 crc, const void *data, size_t len)</td></tr>
<tr class="memdesc:gacc8b8bc6d26dd888c3fed721ddb1cd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a CRC-32 value.  <br /></td></tr>
<tr class="separator:gacc8b8bc6d26dd888c3fed721ddb1cd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa75ce9d0d0b590cd55fce1604bb40824" id="r_gaa75ce9d0d0b590cd55fce1604bb40824"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa75ce9d0d0b590cd55fce1604bb40824">SDL::murmur3_32</a> (const void *data, size_t len, Uint32 seed)</td></tr>
<tr class="memdesc:gaa75ce9d0d0b590cd55fce1604bb40824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a 32-bit MurmurHash3 value for a block of data.  <br /></td></tr>
<tr class="separator:gaa75ce9d0d0b590cd55fce1604bb40824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe27508f0dcd3fb7902725b46f1c7e15" id="r_gafe27508f0dcd3fb7902725b46f1c7e15"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gafe27508f0dcd3fb7902725b46f1c7e15">SDL::memcpy</a> (void *dst, const void *src, size_t len)</td></tr>
<tr class="memdesc:gafe27508f0dcd3fb7902725b46f1c7e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy non-overlapping memory.  <br /></td></tr>
<tr class="separator:gafe27508f0dcd3fb7902725b46f1c7e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga166c29b5162d190b0002720452a5ef43" id="r_ga166c29b5162d190b0002720452a5ef43"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga166c29b5162d190b0002720452a5ef43">SDL::memmove</a> (void *dst, const void *src, size_t len)</td></tr>
<tr class="memdesc:ga166c29b5162d190b0002720452a5ef43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy memory ranges that might overlap.  <br /></td></tr>
<tr class="separator:ga166c29b5162d190b0002720452a5ef43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a6487beb5a07d1110c8afe1fe030446" id="r_ga5a6487beb5a07d1110c8afe1fe030446"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga5a6487beb5a07d1110c8afe1fe030446">SDL::memset</a> (void *dst, int c, size_t len)</td></tr>
<tr class="memdesc:ga5a6487beb5a07d1110c8afe1fe030446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize all bytes of buffer of memory to a specific value.  <br /></td></tr>
<tr class="separator:ga5a6487beb5a07d1110c8afe1fe030446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e06e75cea4ef203bf1f3c967f8bff54" id="r_ga8e06e75cea4ef203bf1f3c967f8bff54"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8e06e75cea4ef203bf1f3c967f8bff54">SDL::memset4</a> (void *dst, Uint32 val, size_t dwords)</td></tr>
<tr class="memdesc:ga8e06e75cea4ef203bf1f3c967f8bff54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize all 32-bit words of buffer of memory to a specific value.  <br /></td></tr>
<tr class="separator:ga8e06e75cea4ef203bf1f3c967f8bff54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1713911979192a927ee8202ad4ed478b" id="r_ga1713911979192a927ee8202ad4ed478b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga1713911979192a927ee8202ad4ed478b">SDL::memcmp</a> (const void *s1, const void *s2, size_t len)</td></tr>
<tr class="memdesc:ga1713911979192a927ee8202ad4ed478b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two buffers of memory.  <br /></td></tr>
<tr class="separator:ga1713911979192a927ee8202ad4ed478b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaba3e78b66aee106f48c80864156f0a" id="r_gafaba3e78b66aee106f48c80864156f0a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gafaba3e78b66aee106f48c80864156f0a">SDL::wcslen</a> (const wchar_t *wstr)</td></tr>
<tr class="memdesc:gafaba3e78b66aee106f48c80864156f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#gafaba3e78b66aee106f48c80864156f0a" title="This works exactly like wcslen() but doesn&#39;t require access to a C runtime.">wcslen()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:gafaba3e78b66aee106f48c80864156f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83f6331afec19491a73e0f711d7b3faf" id="r_ga83f6331afec19491a73e0f711d7b3faf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga83f6331afec19491a73e0f711d7b3faf">SDL::wcsnlen</a> (const wchar_t *wstr, size_t maxlen)</td></tr>
<tr class="memdesc:ga83f6331afec19491a73e0f711d7b3faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga83f6331afec19491a73e0f711d7b3faf" title="This works exactly like wcsnlen() but doesn&#39;t require access to a C runtime.">wcsnlen()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga83f6331afec19491a73e0f711d7b3faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa4a6075598ac1d2db01c28f76bf8c08" id="r_gaaa4a6075598ac1d2db01c28f76bf8c08"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaaa4a6075598ac1d2db01c28f76bf8c08">SDL::wcslcpy</a> (wchar_t *dst, const wchar_t *src, size_t maxlen)</td></tr>
<tr class="memdesc:gaaa4a6075598ac1d2db01c28f76bf8c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a wide string.  <br /></td></tr>
<tr class="separator:gaaa4a6075598ac1d2db01c28f76bf8c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeebfd8bdc9570592d8c1a5083f5d6893" id="r_gaeebfd8bdc9570592d8c1a5083f5d6893"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaeebfd8bdc9570592d8c1a5083f5d6893">SDL::wcslcat</a> (wchar_t *dst, const wchar_t *src, size_t maxlen)</td></tr>
<tr class="memdesc:gaeebfd8bdc9570592d8c1a5083f5d6893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate wide strings.  <br /></td></tr>
<tr class="separator:gaeebfd8bdc9570592d8c1a5083f5d6893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26f89af82ddb65cb934e2c3dc6abb807" id="r_ga26f89af82ddb65cb934e2c3dc6abb807"><td class="memItemLeft" align="right" valign="top">wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga26f89af82ddb65cb934e2c3dc6abb807">SDL::wcsdup</a> (const wchar_t *wstr)</td></tr>
<tr class="memdesc:ga26f89af82ddb65cb934e2c3dc6abb807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a copy of a wide string.  <br /></td></tr>
<tr class="separator:ga26f89af82ddb65cb934e2c3dc6abb807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad864d11d477fc831eb7fcd5a40fbe615" id="r_gad864d11d477fc831eb7fcd5a40fbe615"><td class="memItemLeft" align="right" valign="top">wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gad864d11d477fc831eb7fcd5a40fbe615">SDL::wcsstr</a> (const wchar_t *haystack, const wchar_t *needle)</td></tr>
<tr class="memdesc:gad864d11d477fc831eb7fcd5a40fbe615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a wide string for the first instance of a specific substring.  <br /></td></tr>
<tr class="separator:gad864d11d477fc831eb7fcd5a40fbe615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc794d23fc0f8b51d4abbcf226e6d7c7" id="r_gacc794d23fc0f8b51d4abbcf226e6d7c7"><td class="memItemLeft" align="right" valign="top">wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gacc794d23fc0f8b51d4abbcf226e6d7c7">SDL::wcsnstr</a> (const wchar_t *haystack, const wchar_t *needle, size_t maxlen)</td></tr>
<tr class="memdesc:gacc794d23fc0f8b51d4abbcf226e6d7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a wide string, up to n wide chars, for the first instance of a specific substring.  <br /></td></tr>
<tr class="separator:gacc794d23fc0f8b51d4abbcf226e6d7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9edc1299fb56e51101501e09aaaa5b1f" id="r_ga9edc1299fb56e51101501e09aaaa5b1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga9edc1299fb56e51101501e09aaaa5b1f">SDL::wcscmp</a> (const wchar_t *str1, const wchar_t *str2)</td></tr>
<tr class="memdesc:ga9edc1299fb56e51101501e09aaaa5b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two null-terminated wide strings.  <br /></td></tr>
<tr class="separator:ga9edc1299fb56e51101501e09aaaa5b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00de271aaf6fd8a464c34b16f7b419ff" id="r_ga00de271aaf6fd8a464c34b16f7b419ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga00de271aaf6fd8a464c34b16f7b419ff">SDL::wcsncmp</a> (const wchar_t *str1, const wchar_t *str2, size_t maxlen)</td></tr>
<tr class="memdesc:ga00de271aaf6fd8a464c34b16f7b419ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two wide strings up to a number of wchar_t values.  <br /></td></tr>
<tr class="separator:ga00de271aaf6fd8a464c34b16f7b419ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae24c494fab206e9aa27dfd9c04b35e81" id="r_gae24c494fab206e9aa27dfd9c04b35e81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae24c494fab206e9aa27dfd9c04b35e81">SDL::wcscasecmp</a> (const wchar_t *str1, const wchar_t *str2)</td></tr>
<tr class="memdesc:gae24c494fab206e9aa27dfd9c04b35e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two null-terminated wide strings, case-insensitively.  <br /></td></tr>
<tr class="separator:gae24c494fab206e9aa27dfd9c04b35e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf1b8559eb793e57181bf418af47d555" id="r_gaaf1b8559eb793e57181bf418af47d555"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaaf1b8559eb793e57181bf418af47d555">SDL::wcsncasecmp</a> (const wchar_t *str1, const wchar_t *str2, size_t maxlen)</td></tr>
<tr class="memdesc:gaaf1b8559eb793e57181bf418af47d555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two wide strings, case-insensitively, up to a number of wchar_t.  <br /></td></tr>
<tr class="separator:gaaf1b8559eb793e57181bf418af47d555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0408a155d55fa0fc2d0198de99ca0dc4" id="r_ga0408a155d55fa0fc2d0198de99ca0dc4"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga0408a155d55fa0fc2d0198de99ca0dc4">SDL::wcstol</a> (const wchar_t *str, wchar_t **endp, int base)</td></tr>
<tr class="memdesc:ga0408a155d55fa0fc2d0198de99ca0dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>long</code> from a wide string.  <br /></td></tr>
<tr class="separator:ga0408a155d55fa0fc2d0198de99ca0dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93de03cd7e1369ba80c5746761bac939" id="r_ga93de03cd7e1369ba80c5746761bac939"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga93de03cd7e1369ba80c5746761bac939">SDL::strlen</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str)</td></tr>
<tr class="memdesc:ga93de03cd7e1369ba80c5746761bac939"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga93de03cd7e1369ba80c5746761bac939" title="This works exactly like strlen() but doesn&#39;t require access to a C runtime.">strlen()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga93de03cd7e1369ba80c5746761bac939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga929593393da0025b602c5b4560bce5bf" id="r_ga929593393da0025b602c5b4560bce5bf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga929593393da0025b602c5b4560bce5bf">SDL::strnlen</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str, size_t maxlen)</td></tr>
<tr class="memdesc:ga929593393da0025b602c5b4560bce5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga929593393da0025b602c5b4560bce5bf" title="This works exactly like strnlen() but doesn&#39;t require access to a C runtime.">strnlen()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga929593393da0025b602c5b4560bce5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga598ecc44c77a20ab4de3a96eda46ea76" id="r_ga598ecc44c77a20ab4de3a96eda46ea76"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga598ecc44c77a20ab4de3a96eda46ea76">SDL::strlcpy</a> (char *dst, <a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> src, size_t maxlen)</td></tr>
<tr class="memdesc:ga598ecc44c77a20ab4de3a96eda46ea76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a string.  <br /></td></tr>
<tr class="separator:ga598ecc44c77a20ab4de3a96eda46ea76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ae726c47fde58d11167345dfda765a4" id="r_ga8ae726c47fde58d11167345dfda765a4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8ae726c47fde58d11167345dfda765a4">SDL::utf8strlcpy</a> (char *dst, <a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> src, size_t dst_bytes)</td></tr>
<tr class="memdesc:ga8ae726c47fde58d11167345dfda765a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an UTF-8 string.  <br /></td></tr>
<tr class="separator:ga8ae726c47fde58d11167345dfda765a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga503a37a91faa4ed9374b9dd9db03049c" id="r_ga503a37a91faa4ed9374b9dd9db03049c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga503a37a91faa4ed9374b9dd9db03049c">SDL::strlcat</a> (char *dst, <a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> src, size_t maxlen)</td></tr>
<tr class="memdesc:ga503a37a91faa4ed9374b9dd9db03049c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate strings.  <br /></td></tr>
<tr class="separator:ga503a37a91faa4ed9374b9dd9db03049c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga046b80783770b59a2cf8b4311230fbbd" id="r_ga046b80783770b59a2cf8b4311230fbbd"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga046b80783770b59a2cf8b4311230fbbd">SDL::strdup</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str)</td></tr>
<tr class="memdesc:ga046b80783770b59a2cf8b4311230fbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a copy of a string.  <br /></td></tr>
<tr class="separator:ga046b80783770b59a2cf8b4311230fbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53e0a0ce55852f1320bc292f72dc1398" id="r_ga53e0a0ce55852f1320bc292f72dc1398"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga53e0a0ce55852f1320bc292f72dc1398">SDL::strndup</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str, size_t maxlen)</td></tr>
<tr class="memdesc:ga53e0a0ce55852f1320bc292f72dc1398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a copy of a string, up to n characters.  <br /></td></tr>
<tr class="separator:ga53e0a0ce55852f1320bc292f72dc1398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b6d922e9310ca993a82b84e692e8a5" id="r_ga32b6d922e9310ca993a82b84e692e8a5"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga32b6d922e9310ca993a82b84e692e8a5">SDL::strrev</a> (char *str)</td></tr>
<tr class="memdesc:ga32b6d922e9310ca993a82b84e692e8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse a string's contents.  <br /></td></tr>
<tr class="separator:ga32b6d922e9310ca993a82b84e692e8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fe290f18ce6025c454f0b62729c0662" id="r_ga7fe290f18ce6025c454f0b62729c0662"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga7fe290f18ce6025c454f0b62729c0662">SDL::strupr</a> (char *str)</td></tr>
<tr class="memdesc:ga7fe290f18ce6025c454f0b62729c0662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to uppercase.  <br /></td></tr>
<tr class="separator:ga7fe290f18ce6025c454f0b62729c0662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15eaa2ac05317f734e1f022cfc916201" id="r_ga15eaa2ac05317f734e1f022cfc916201"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga15eaa2ac05317f734e1f022cfc916201">SDL::strlwr</a> (char *str)</td></tr>
<tr class="memdesc:ga15eaa2ac05317f734e1f022cfc916201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to lowercase.  <br /></td></tr>
<tr class="separator:ga15eaa2ac05317f734e1f022cfc916201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga451b842c63a514775080900ae67150da" id="r_ga451b842c63a514775080900ae67150da"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga451b842c63a514775080900ae67150da">SDL::strchr</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str, int c)</td></tr>
<tr class="memdesc:ga451b842c63a514775080900ae67150da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a string for the first instance of a specific byte.  <br /></td></tr>
<tr class="separator:ga451b842c63a514775080900ae67150da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf67863ed8e432e74c417116a532ef24b" id="r_gaf67863ed8e432e74c417116a532ef24b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaf67863ed8e432e74c417116a532ef24b">SDL::strrchr</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str, int c)</td></tr>
<tr class="memdesc:gaf67863ed8e432e74c417116a532ef24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a string for the last instance of a specific byte.  <br /></td></tr>
<tr class="separator:gaf67863ed8e432e74c417116a532ef24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ef7c9322f6766ee71172d34493ee792" id="r_ga3ef7c9322f6766ee71172d34493ee792"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga3ef7c9322f6766ee71172d34493ee792">SDL::strstr</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> haystack, <a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> needle)</td></tr>
<tr class="memdesc:ga3ef7c9322f6766ee71172d34493ee792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a string for the first instance of a specific substring.  <br /></td></tr>
<tr class="separator:ga3ef7c9322f6766ee71172d34493ee792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21c1bce04f407d4dab36722078978a9b" id="r_ga21c1bce04f407d4dab36722078978a9b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga21c1bce04f407d4dab36722078978a9b">SDL::strnstr</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> haystack, <a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> needle, size_t maxlen)</td></tr>
<tr class="memdesc:ga21c1bce04f407d4dab36722078978a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a string, up to n bytes, for the first instance of a specific substring.  <br /></td></tr>
<tr class="separator:ga21c1bce04f407d4dab36722078978a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d413500b6dc7d885777ecb0873c823e" id="r_ga0d413500b6dc7d885777ecb0873c823e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga0d413500b6dc7d885777ecb0873c823e">SDL::strcasestr</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> haystack, <a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> needle)</td></tr>
<tr class="memdesc:ga0d413500b6dc7d885777ecb0873c823e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a UTF-8 string for the first instance of a specific substring, case-insensitively.  <br /></td></tr>
<tr class="separator:ga0d413500b6dc7d885777ecb0873c823e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dc2ad6fd692f32f1304e9b1872881a2" id="r_ga8dc2ad6fd692f32f1304e9b1872881a2"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8dc2ad6fd692f32f1304e9b1872881a2">SDL::strtok_r</a> (char *str, <a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> delim, char **saveptr)</td></tr>
<tr class="memdesc:ga8dc2ad6fd692f32f1304e9b1872881a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga8dc2ad6fd692f32f1304e9b1872881a2" title="This works exactly like strtok_r() but doesn&#39;t require access to a C runtime.">strtok_r()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga8dc2ad6fd692f32f1304e9b1872881a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81767a08005a153d60b63896c58c106f" id="r_ga81767a08005a153d60b63896c58c106f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga81767a08005a153d60b63896c58c106f">SDL::utf8strlen</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str)</td></tr>
<tr class="memdesc:ga81767a08005a153d60b63896c58c106f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of codepoints in a UTF-8 string.  <br /></td></tr>
<tr class="separator:ga81767a08005a153d60b63896c58c106f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82960b752efedfdd3cbfcf166d06161e" id="r_ga82960b752efedfdd3cbfcf166d06161e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga82960b752efedfdd3cbfcf166d06161e">SDL::utf8strnlen</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str, size_t bytes)</td></tr>
<tr class="memdesc:ga82960b752efedfdd3cbfcf166d06161e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of codepoints in a UTF-8 string, up to n bytes.  <br /></td></tr>
<tr class="separator:ga82960b752efedfdd3cbfcf166d06161e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0d19dc9f116d9f492fd4d17296f0c4b" id="r_gac0d19dc9f116d9f492fd4d17296f0c4b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gac0d19dc9f116d9f492fd4d17296f0c4b">SDL::itoa</a> (int value, char *str, int radix)</td></tr>
<tr class="memdesc:gac0d19dc9f116d9f492fd4d17296f0c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an integer into a string.  <br /></td></tr>
<tr class="separator:gac0d19dc9f116d9f492fd4d17296f0c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ca0851c2d9980695748c979e2d15608" id="r_ga6ca0851c2d9980695748c979e2d15608"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga6ca0851c2d9980695748c979e2d15608">SDL::uitoa</a> (unsigned int value, char *str, int radix)</td></tr>
<tr class="memdesc:ga6ca0851c2d9980695748c979e2d15608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an unsigned integer into a string.  <br /></td></tr>
<tr class="separator:ga6ca0851c2d9980695748c979e2d15608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee263ca33e533bf8acdd33b20e2323cf" id="r_gaee263ca33e533bf8acdd33b20e2323cf"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaee263ca33e533bf8acdd33b20e2323cf">SDL::ltoa</a> (long value, char *str, int radix)</td></tr>
<tr class="memdesc:gaee263ca33e533bf8acdd33b20e2323cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a long integer into a string.  <br /></td></tr>
<tr class="separator:gaee263ca33e533bf8acdd33b20e2323cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2450290efea2bebff1f164a6c4a04d38" id="r_ga2450290efea2bebff1f164a6c4a04d38"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga2450290efea2bebff1f164a6c4a04d38">SDL::ultoa</a> (unsigned long value, char *str, int radix)</td></tr>
<tr class="memdesc:ga2450290efea2bebff1f164a6c4a04d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an unsigned long integer into a string.  <br /></td></tr>
<tr class="separator:ga2450290efea2bebff1f164a6c4a04d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga756fd0202aa809d537fc01e28b0c7564" id="r_ga756fd0202aa809d537fc01e28b0c7564"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga756fd0202aa809d537fc01e28b0c7564">SDL::atoi</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str)</td></tr>
<tr class="memdesc:ga756fd0202aa809d537fc01e28b0c7564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an <code>int</code> from a string.  <br /></td></tr>
<tr class="separator:ga756fd0202aa809d537fc01e28b0c7564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeecdd7ec80c303a7474d59b641a892f7" id="r_gaeecdd7ec80c303a7474d59b641a892f7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaeecdd7ec80c303a7474d59b641a892f7">SDL::atof</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str)</td></tr>
<tr class="memdesc:gaeecdd7ec80c303a7474d59b641a892f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>double</code> from a string.  <br /></td></tr>
<tr class="separator:gaeecdd7ec80c303a7474d59b641a892f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf270570877b7a6ccaea59ba90b428043" id="r_gaf270570877b7a6ccaea59ba90b428043"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaf270570877b7a6ccaea59ba90b428043">SDL::strtol</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str, char **endp, int base)</td></tr>
<tr class="memdesc:gaf270570877b7a6ccaea59ba90b428043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>long</code> from a string.  <br /></td></tr>
<tr class="separator:gaf270570877b7a6ccaea59ba90b428043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3869ab21242a2a6fb41be41b382d2af2" id="r_ga3869ab21242a2a6fb41be41b382d2af2"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga3869ab21242a2a6fb41be41b382d2af2">SDL::strtoul</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str, char **endp, int base)</td></tr>
<tr class="memdesc:ga3869ab21242a2a6fb41be41b382d2af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an <code>unsigned long</code> from a string.  <br /></td></tr>
<tr class="separator:ga3869ab21242a2a6fb41be41b382d2af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga062de74e1950744ad5556cc815c58036" id="r_ga062de74e1950744ad5556cc815c58036"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga062de74e1950744ad5556cc815c58036">SDL::strtod</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str, char **endp)</td></tr>
<tr class="memdesc:ga062de74e1950744ad5556cc815c58036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>double</code> from a string.  <br /></td></tr>
<tr class="separator:ga062de74e1950744ad5556cc815c58036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63d50d9f0b71b04e9b038f0bc71e54c3" id="r_ga63d50d9f0b71b04e9b038f0bc71e54c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga63d50d9f0b71b04e9b038f0bc71e54c3">SDL::strcmp</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str1, <a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str2)</td></tr>
<tr class="memdesc:ga63d50d9f0b71b04e9b038f0bc71e54c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two null-terminated UTF-8 strings.  <br /></td></tr>
<tr class="separator:ga63d50d9f0b71b04e9b038f0bc71e54c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2caad6bed5796e9524d07c21d4701af9" id="r_ga2caad6bed5796e9524d07c21d4701af9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga2caad6bed5796e9524d07c21d4701af9">SDL::strncmp</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str1, <a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str2, size_t maxlen)</td></tr>
<tr class="memdesc:ga2caad6bed5796e9524d07c21d4701af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two UTF-8 strings up to a number of bytes.  <br /></td></tr>
<tr class="separator:ga2caad6bed5796e9524d07c21d4701af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga932cf2487365b3a3a6fd6e37a7eddff7" id="r_ga932cf2487365b3a3a6fd6e37a7eddff7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga932cf2487365b3a3a6fd6e37a7eddff7">SDL::strcasecmp</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str1, <a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str2)</td></tr>
<tr class="memdesc:ga932cf2487365b3a3a6fd6e37a7eddff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two null-terminated UTF-8 strings, case-insensitively.  <br /></td></tr>
<tr class="separator:ga932cf2487365b3a3a6fd6e37a7eddff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37191be89f79920285c912c0544150e8" id="r_ga37191be89f79920285c912c0544150e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga37191be89f79920285c912c0544150e8">SDL::strncasecmp</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str1, <a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str2, size_t maxlen)</td></tr>
<tr class="memdesc:ga37191be89f79920285c912c0544150e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two UTF-8 strings, case-insensitively, up to a number of bytes.  <br /></td></tr>
<tr class="separator:ga37191be89f79920285c912c0544150e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3838c531e1c9bbee29cdf5f4ccb60b4" id="r_gae3838c531e1c9bbee29cdf5f4ccb60b4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae3838c531e1c9bbee29cdf5f4ccb60b4">SDL::strpbrk</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> str, <a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> breakset)</td></tr>
<tr class="memdesc:gae3838c531e1c9bbee29cdf5f4ccb60b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches a string for the first occurence of any character contained in a breakset, and returns a pointer from the string to that character.  <br /></td></tr>
<tr class="separator:gae3838c531e1c9bbee29cdf5f4ccb60b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5ecf11cf256372f67e10fafdd79141e" id="r_gaa5ecf11cf256372f67e10fafdd79141e"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa5ecf11cf256372f67e10fafdd79141e">SDL::StepUTF8</a> (const char **pstr, size_t *pslen)</td></tr>
<tr class="memdesc:gaa5ecf11cf256372f67e10fafdd79141e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a UTF-8 string, one Unicode codepoint at a time.  <br /></td></tr>
<tr class="separator:gaa5ecf11cf256372f67e10fafdd79141e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa1607ee6b5fddfb7d22eb518dbe59a4" id="r_gaaa1607ee6b5fddfb7d22eb518dbe59a4"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaaa1607ee6b5fddfb7d22eb518dbe59a4">SDL::StepBackUTF8</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> start, const char **pstr)</td></tr>
<tr class="memdesc:gaaa1607ee6b5fddfb7d22eb518dbe59a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a UTF-8 string in reverse, one Unicode codepoint at a time.  <br /></td></tr>
<tr class="separator:gaaa1607ee6b5fddfb7d22eb518dbe59a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga032867626ec7d90baa207d817fdbddcf" id="r_ga032867626ec7d90baa207d817fdbddcf"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga032867626ec7d90baa207d817fdbddcf">SDL::UCS4ToUTF8</a> (Uint32 codepoint, char *dst)</td></tr>
<tr class="memdesc:ga032867626ec7d90baa207d817fdbddcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a single Unicode codepoint to UTF-8.  <br /></td></tr>
<tr class="separator:ga032867626ec7d90baa207d817fdbddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga592054168270da087e8630cac0df2530" id="r_ga592054168270da087e8630cac0df2530"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga592054168270da087e8630cac0df2530">SDL::sscanf</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> text, SDL_SCANF_FORMAT_STRING const char *fmt,...)</td></tr>
<tr class="memdesc:ga592054168270da087e8630cac0df2530"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga592054168270da087e8630cac0df2530" title="This works exactly like sscanf() but doesn&#39;t require access to a C runtime.">sscanf()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga592054168270da087e8630cac0df2530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1c131187ea64c08ed8abb3d04551072" id="r_gac1c131187ea64c08ed8abb3d04551072"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gac1c131187ea64c08ed8abb3d04551072">SDL::vsscanf</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> text, SDL_SCANF_FORMAT_STRING const char *fmt, va_list ap)</td></tr>
<tr class="memdesc:gac1c131187ea64c08ed8abb3d04551072"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#gac1c131187ea64c08ed8abb3d04551072" title="This works exactly like vsscanf() but doesn&#39;t require access to a C runtime.">vsscanf()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:gac1c131187ea64c08ed8abb3d04551072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57b48f04ae9e3949774b9f0c9dc0c151" id="r_ga57b48f04ae9e3949774b9f0c9dc0c151"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga57b48f04ae9e3949774b9f0c9dc0c151">SDL::snprintf</a> (char *text, size_t maxlen, SDL_PRINTF_FORMAT_STRING const char *fmt,...)</td></tr>
<tr class="memdesc:ga57b48f04ae9e3949774b9f0c9dc0c151"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga57b48f04ae9e3949774b9f0c9dc0c151" title="This works exactly like snprintf() but doesn&#39;t require access to a C runtime.">snprintf()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga57b48f04ae9e3949774b9f0c9dc0c151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90fbec4327cabf79747426483a3f24cd" id="r_ga90fbec4327cabf79747426483a3f24cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga90fbec4327cabf79747426483a3f24cd">SDL::swprintf</a> (wchar_t *text, size_t maxlen, SDL_PRINTF_FORMAT_STRING const wchar_t *fmt,...)</td></tr>
<tr class="memdesc:ga90fbec4327cabf79747426483a3f24cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga90fbec4327cabf79747426483a3f24cd" title="This works exactly like swprintf() but doesn&#39;t require access to a C runtime.">swprintf()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga90fbec4327cabf79747426483a3f24cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4402ec18128560a4643446630b3a4633" id="r_ga4402ec18128560a4643446630b3a4633"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga4402ec18128560a4643446630b3a4633">SDL::vsnprintf</a> (char *text, size_t maxlen, SDL_PRINTF_FORMAT_STRING const char *fmt, va_list ap)</td></tr>
<tr class="memdesc:ga4402ec18128560a4643446630b3a4633"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga4402ec18128560a4643446630b3a4633" title="This works exactly like vsnprintf() but doesn&#39;t require access to a C runtime.">vsnprintf()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga4402ec18128560a4643446630b3a4633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83409fe8ca79edcf997ebfcda6226a5a" id="r_ga83409fe8ca79edcf997ebfcda6226a5a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga83409fe8ca79edcf997ebfcda6226a5a">SDL::vswprintf</a> (wchar_t *text, size_t maxlen, SDL_PRINTF_FORMAT_STRING const wchar_t *fmt, va_list ap)</td></tr>
<tr class="memdesc:ga83409fe8ca79edcf997ebfcda6226a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga83409fe8ca79edcf997ebfcda6226a5a" title="This works exactly like vswprintf() but doesn&#39;t require access to a C runtime.">vswprintf()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga83409fe8ca79edcf997ebfcda6226a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e5aac7458286e05c61d71278f59215" id="r_ga12e5aac7458286e05c61d71278f59215"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga12e5aac7458286e05c61d71278f59215">SDL::asprintf</a> (char **strp, SDL_PRINTF_FORMAT_STRING const char *fmt,...)</td></tr>
<tr class="memdesc:ga12e5aac7458286e05c61d71278f59215"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#ga12e5aac7458286e05c61d71278f59215" title="This works exactly like asprintf() but doesn&#39;t require access to a C runtime.">asprintf()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:ga12e5aac7458286e05c61d71278f59215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd658aed3baf56ca11c8148de5cd9480" id="r_gabd658aed3baf56ca11c8148de5cd9480"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gabd658aed3baf56ca11c8148de5cd9480">SDL::vasprintf</a> (char **strp, SDL_PRINTF_FORMAT_STRING const char *fmt, va_list ap)</td></tr>
<tr class="memdesc:gabd658aed3baf56ca11c8148de5cd9480"><td class="mdescLeft">&#160;</td><td class="mdescRight">This works exactly like <a class="el" href="group__CategoryStdinc.html#gabd658aed3baf56ca11c8148de5cd9480" title="This works exactly like vasprintf() but doesn&#39;t require access to a C runtime.">vasprintf()</a> but doesn't require access to a C runtime.  <br /></td></tr>
<tr class="separator:gabd658aed3baf56ca11c8148de5cd9480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85fc72ab5435901400efdaebc1187630" id="r_ga85fc72ab5435901400efdaebc1187630"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga85fc72ab5435901400efdaebc1187630">SDL::srand</a> (Uint64 seed)</td></tr>
<tr class="memdesc:ga85fc72ab5435901400efdaebc1187630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seeds the pseudo-random number generator.  <br /></td></tr>
<tr class="separator:ga85fc72ab5435901400efdaebc1187630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0d119f7b42130eb3a652f7e243c8cf7" id="r_gaa0d119f7b42130eb3a652f7e243c8cf7"><td class="memItemLeft" align="right" valign="top">Sint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa0d119f7b42130eb3a652f7e243c8cf7">SDL::rand</a> (Sint32 n)</td></tr>
<tr class="memdesc:gaa0d119f7b42130eb3a652f7e243c8cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pseudo-random number less than n for positive n.  <br /></td></tr>
<tr class="separator:gaa0d119f7b42130eb3a652f7e243c8cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab0a933463eebe63f34b3acec7e96c6e" id="r_gaab0a933463eebe63f34b3acec7e96c6e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaab0a933463eebe63f34b3acec7e96c6e">SDL::randf</a> ()</td></tr>
<tr class="memdesc:gaab0a933463eebe63f34b3acec7e96c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a uniform pseudo-random floating point number less than 1.0.  <br /></td></tr>
<tr class="separator:gaab0a933463eebe63f34b3acec7e96c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6517052066ab937273e6a89c7d1eca8" id="r_gae6517052066ab937273e6a89c7d1eca8"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae6517052066ab937273e6a89c7d1eca8">SDL::rand_bits</a> ()</td></tr>
<tr class="memdesc:gae6517052066ab937273e6a89c7d1eca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate 32 pseudo-random bits.  <br /></td></tr>
<tr class="separator:gae6517052066ab937273e6a89c7d1eca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f6543d319422a6044570b59cc6377b4" id="r_ga9f6543d319422a6044570b59cc6377b4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga9f6543d319422a6044570b59cc6377b4">SDL::acos</a> (double x)</td></tr>
<tr class="memdesc:ga9f6543d319422a6044570b59cc6377b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc cosine of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga9f6543d319422a6044570b59cc6377b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e3b6760100280cb4cb51fcee4b3a2ff" id="r_ga8e3b6760100280cb4cb51fcee4b3a2ff"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8e3b6760100280cb4cb51fcee4b3a2ff">SDL::acosf</a> (float x)</td></tr>
<tr class="memdesc:ga8e3b6760100280cb4cb51fcee4b3a2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc cosine of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga8e3b6760100280cb4cb51fcee4b3a2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga316a2eed1e595c002830ee628c1b4963" id="r_ga316a2eed1e595c002830ee628c1b4963"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga316a2eed1e595c002830ee628c1b4963">SDL::asin</a> (double x)</td></tr>
<tr class="memdesc:ga316a2eed1e595c002830ee628c1b4963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc sine of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga316a2eed1e595c002830ee628c1b4963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga093ee4582ee6f6c02ab22c77718f56a8" id="r_ga093ee4582ee6f6c02ab22c77718f56a8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga093ee4582ee6f6c02ab22c77718f56a8">SDL::asinf</a> (float x)</td></tr>
<tr class="memdesc:ga093ee4582ee6f6c02ab22c77718f56a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc sine of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga093ee4582ee6f6c02ab22c77718f56a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11d0eaba28baba36fc8050f8541c8ee5" id="r_ga11d0eaba28baba36fc8050f8541c8ee5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga11d0eaba28baba36fc8050f8541c8ee5">SDL::atan</a> (double x)</td></tr>
<tr class="memdesc:ga11d0eaba28baba36fc8050f8541c8ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc tangent of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga11d0eaba28baba36fc8050f8541c8ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19e239deb9997e2ff33bbfdbaec436b2" id="r_ga19e239deb9997e2ff33bbfdbaec436b2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga19e239deb9997e2ff33bbfdbaec436b2">SDL::atanf</a> (float x)</td></tr>
<tr class="memdesc:ga19e239deb9997e2ff33bbfdbaec436b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc tangent of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga19e239deb9997e2ff33bbfdbaec436b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0884b892c70d428cf50522d9791eb61" id="r_gae0884b892c70d428cf50522d9791eb61"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae0884b892c70d428cf50522d9791eb61">SDL::atan2</a> (double y, double x)</td></tr>
<tr class="memdesc:gae0884b892c70d428cf50522d9791eb61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc tangent of <code>y / x</code>, using the signs of x and y to adjust the result's quadrant.  <br /></td></tr>
<tr class="separator:gae0884b892c70d428cf50522d9791eb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1be31240212288c0d7556cf80340b93" id="r_gaf1be31240212288c0d7556cf80340b93"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaf1be31240212288c0d7556cf80340b93">SDL::atan2f</a> (float y, float x)</td></tr>
<tr class="memdesc:gaf1be31240212288c0d7556cf80340b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arc tangent of <code>y / x</code>, using the signs of x and y to adjust the result's quadrant.  <br /></td></tr>
<tr class="separator:gaf1be31240212288c0d7556cf80340b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1567a1e6b1738fabc6252d7c52f03321" id="r_ga1567a1e6b1738fabc6252d7c52f03321"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga1567a1e6b1738fabc6252d7c52f03321">SDL::ceil</a> (double x)</td></tr>
<tr class="memdesc:ga1567a1e6b1738fabc6252d7c52f03321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the ceiling of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga1567a1e6b1738fabc6252d7c52f03321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5962b17a629d7f973898e35e1818646f" id="r_ga5962b17a629d7f973898e35e1818646f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga5962b17a629d7f973898e35e1818646f">SDL::ceilf</a> (float x)</td></tr>
<tr class="memdesc:ga5962b17a629d7f973898e35e1818646f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the ceiling of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga5962b17a629d7f973898e35e1818646f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga476595ece87ed3441c672348366f0adb" id="r_ga476595ece87ed3441c672348366f0adb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga476595ece87ed3441c672348366f0adb">SDL::copysign</a> (double x, double y)</td></tr>
<tr class="memdesc:ga476595ece87ed3441c672348366f0adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the sign of one floating-point value to another.  <br /></td></tr>
<tr class="separator:ga476595ece87ed3441c672348366f0adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b8d2ae3c91e681437f9b8bad0d332dd" id="r_ga0b8d2ae3c91e681437f9b8bad0d332dd"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga0b8d2ae3c91e681437f9b8bad0d332dd">SDL::copysignf</a> (float x, float y)</td></tr>
<tr class="memdesc:ga0b8d2ae3c91e681437f9b8bad0d332dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the sign of one floating-point value to another.  <br /></td></tr>
<tr class="separator:ga0b8d2ae3c91e681437f9b8bad0d332dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf8c80d673a05784387fa5e349a9f6dd" id="r_gadf8c80d673a05784387fa5e349a9f6dd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gadf8c80d673a05784387fa5e349a9f6dd">SDL::cos</a> (double x)</td></tr>
<tr class="memdesc:gadf8c80d673a05784387fa5e349a9f6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine of <code>x</code>.  <br /></td></tr>
<tr class="separator:gadf8c80d673a05784387fa5e349a9f6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga343b62c85d5c6bc9627fdad943860921" id="r_ga343b62c85d5c6bc9627fdad943860921"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga343b62c85d5c6bc9627fdad943860921">SDL::cosf</a> (float x)</td></tr>
<tr class="memdesc:ga343b62c85d5c6bc9627fdad943860921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga343b62c85d5c6bc9627fdad943860921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e4417a78f0393e80fa7645a534a53a3" id="r_ga3e4417a78f0393e80fa7645a534a53a3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga3e4417a78f0393e80fa7645a534a53a3">SDL::exp</a> (double x)</td></tr>
<tr class="memdesc:ga3e4417a78f0393e80fa7645a534a53a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga3e4417a78f0393e80fa7645a534a53a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c6a34f6bfb50b176f502a6133880aa8" id="r_ga5c6a34f6bfb50b176f502a6133880aa8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga5c6a34f6bfb50b176f502a6133880aa8">SDL::expf</a> (float x)</td></tr>
<tr class="memdesc:ga5c6a34f6bfb50b176f502a6133880aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga5c6a34f6bfb50b176f502a6133880aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae57cb7c976b8596bb9ff76f3402a2488" id="r_gae57cb7c976b8596bb9ff76f3402a2488"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae57cb7c976b8596bb9ff76f3402a2488">SDL::fabs</a> (double x)</td></tr>
<tr class="memdesc:gae57cb7c976b8596bb9ff76f3402a2488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of <code>x</code>  <br /></td></tr>
<tr class="separator:gae57cb7c976b8596bb9ff76f3402a2488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8952f2171107539c5cddb95fe5efec28" id="r_ga8952f2171107539c5cddb95fe5efec28"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8952f2171107539c5cddb95fe5efec28">SDL::fabsf</a> (float x)</td></tr>
<tr class="memdesc:ga8952f2171107539c5cddb95fe5efec28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of <code>x</code>  <br /></td></tr>
<tr class="separator:ga8952f2171107539c5cddb95fe5efec28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5d99939c5dffc37035e51300236316a" id="r_gaa5d99939c5dffc37035e51300236316a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa5d99939c5dffc37035e51300236316a">SDL::floor</a> (double x)</td></tr>
<tr class="memdesc:gaa5d99939c5dffc37035e51300236316a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the floor of <code>x</code>.  <br /></td></tr>
<tr class="separator:gaa5d99939c5dffc37035e51300236316a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8438f2959083ee7e897f7f3ef03ca3b8" id="r_ga8438f2959083ee7e897f7f3ef03ca3b8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8438f2959083ee7e897f7f3ef03ca3b8">SDL::floorf</a> (float x)</td></tr>
<tr class="memdesc:ga8438f2959083ee7e897f7f3ef03ca3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the floor of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga8438f2959083ee7e897f7f3ef03ca3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb64b2b465e001720dce40bacec1b937" id="r_gaeb64b2b465e001720dce40bacec1b937"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaeb64b2b465e001720dce40bacec1b937">SDL::trunc</a> (double x)</td></tr>
<tr class="memdesc:gaeb64b2b465e001720dce40bacec1b937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate <code>x</code> to an integer.  <br /></td></tr>
<tr class="separator:gaeb64b2b465e001720dce40bacec1b937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6b046a5844394a19061a8544376ffac" id="r_gae6b046a5844394a19061a8544376ffac"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gae6b046a5844394a19061a8544376ffac">SDL::truncf</a> (float x)</td></tr>
<tr class="memdesc:gae6b046a5844394a19061a8544376ffac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate <code>x</code> to an integer.  <br /></td></tr>
<tr class="separator:gae6b046a5844394a19061a8544376ffac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcd6b0192bc061852ef8ef56272bf98d" id="r_gafcd6b0192bc061852ef8ef56272bf98d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gafcd6b0192bc061852ef8ef56272bf98d">SDL::fmod</a> (double x, double y)</td></tr>
<tr class="memdesc:gafcd6b0192bc061852ef8ef56272bf98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floating-point remainder of <code>x / y</code>  <br /></td></tr>
<tr class="separator:gafcd6b0192bc061852ef8ef56272bf98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab12a77026e20d3235fab10d708ed80a6" id="r_gab12a77026e20d3235fab10d708ed80a6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab12a77026e20d3235fab10d708ed80a6">SDL::fmodf</a> (float x, float y)</td></tr>
<tr class="memdesc:gab12a77026e20d3235fab10d708ed80a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floating-point remainder of <code>x / y</code>  <br /></td></tr>
<tr class="separator:gab12a77026e20d3235fab10d708ed80a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga918f0e70e6e67f724c445eba4b514a21" id="r_ga918f0e70e6e67f724c445eba4b514a21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga918f0e70e6e67f724c445eba4b514a21">SDL::isinf</a> (double x)</td></tr>
<tr class="memdesc:ga918f0e70e6e67f724c445eba4b514a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the value is infinity.  <br /></td></tr>
<tr class="separator:ga918f0e70e6e67f724c445eba4b514a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59c45f83103aa3fdc57244124dea7d5d" id="r_ga59c45f83103aa3fdc57244124dea7d5d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga59c45f83103aa3fdc57244124dea7d5d">SDL::isinff</a> (float x)</td></tr>
<tr class="memdesc:ga59c45f83103aa3fdc57244124dea7d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the value is infinity.  <br /></td></tr>
<tr class="separator:ga59c45f83103aa3fdc57244124dea7d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2221269e7ded0fb89af37aea9132e0b8" id="r_ga2221269e7ded0fb89af37aea9132e0b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga2221269e7ded0fb89af37aea9132e0b8">SDL::isnan</a> (double x)</td></tr>
<tr class="memdesc:ga2221269e7ded0fb89af37aea9132e0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the value is NaN.  <br /></td></tr>
<tr class="separator:ga2221269e7ded0fb89af37aea9132e0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga945938b6b96f7b17c1916fe9d357a315" id="r_ga945938b6b96f7b17c1916fe9d357a315"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga945938b6b96f7b17c1916fe9d357a315">SDL::isnanf</a> (float x)</td></tr>
<tr class="memdesc:ga945938b6b96f7b17c1916fe9d357a315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the value is NaN.  <br /></td></tr>
<tr class="separator:ga945938b6b96f7b17c1916fe9d357a315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01c25ea063ceb75d5caf6ca1119a3bc1" id="r_ga01c25ea063ceb75d5caf6ca1119a3bc1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga01c25ea063ceb75d5caf6ca1119a3bc1">SDL::log</a> (double x)</td></tr>
<tr class="memdesc:ga01c25ea063ceb75d5caf6ca1119a3bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga01c25ea063ceb75d5caf6ca1119a3bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3482b1fa8e624f0f7e73ce89c0d5efb" id="r_gab3482b1fa8e624f0f7e73ce89c0d5efb"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab3482b1fa8e624f0f7e73ce89c0d5efb">SDL::logf</a> (float x)</td></tr>
<tr class="memdesc:gab3482b1fa8e624f0f7e73ce89c0d5efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of <code>x</code>.  <br /></td></tr>
<tr class="separator:gab3482b1fa8e624f0f7e73ce89c0d5efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdf9d94c27153da5d01b604342b49024" id="r_gacdf9d94c27153da5d01b604342b49024"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gacdf9d94c27153da5d01b604342b49024">SDL::log10</a> (double x)</td></tr>
<tr class="memdesc:gacdf9d94c27153da5d01b604342b49024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the base-10 logarithm of <code>x</code>.  <br /></td></tr>
<tr class="separator:gacdf9d94c27153da5d01b604342b49024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8d69e4fc64b4c002aeffdf894aaa64f" id="r_gaa8d69e4fc64b4c002aeffdf894aaa64f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaa8d69e4fc64b4c002aeffdf894aaa64f">SDL::log10f</a> (float x)</td></tr>
<tr class="memdesc:gaa8d69e4fc64b4c002aeffdf894aaa64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the base-10 logarithm of <code>x</code>.  <br /></td></tr>
<tr class="separator:gaa8d69e4fc64b4c002aeffdf894aaa64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c97858f63954904f2037d7bc81b2681" id="r_ga4c97858f63954904f2037d7bc81b2681"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga4c97858f63954904f2037d7bc81b2681">SDL::modf</a> (double x, double *y)</td></tr>
<tr class="memdesc:ga4c97858f63954904f2037d7bc81b2681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split <code>x</code> into integer and fractional parts.  <br /></td></tr>
<tr class="separator:ga4c97858f63954904f2037d7bc81b2681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0108470ee7d88fa093ddf12185060c10" id="r_ga0108470ee7d88fa093ddf12185060c10"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga0108470ee7d88fa093ddf12185060c10">SDL::modff</a> (float x, float *y)</td></tr>
<tr class="memdesc:ga0108470ee7d88fa093ddf12185060c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split <code>x</code> into integer and fractional parts.  <br /></td></tr>
<tr class="separator:ga0108470ee7d88fa093ddf12185060c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cfca7e593d97a56d7fca043af3ac2ce" id="r_ga6cfca7e593d97a56d7fca043af3ac2ce"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga6cfca7e593d97a56d7fca043af3ac2ce">SDL::pow</a> (double x, double y)</td></tr>
<tr class="memdesc:ga6cfca7e593d97a56d7fca043af3ac2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise <code>x</code> to the power <code>y</code>  <br /></td></tr>
<tr class="separator:ga6cfca7e593d97a56d7fca043af3ac2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga652fc1da140490bb87abbbf05ccfe8fa" id="r_ga652fc1da140490bb87abbbf05ccfe8fa"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga652fc1da140490bb87abbbf05ccfe8fa">SDL::powf</a> (float x, float y)</td></tr>
<tr class="memdesc:ga652fc1da140490bb87abbbf05ccfe8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise <code>x</code> to the power <code>y</code>  <br /></td></tr>
<tr class="separator:ga652fc1da140490bb87abbbf05ccfe8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58af56b2a9898c045c8ec62ec531c8e5" id="r_ga58af56b2a9898c045c8ec62ec531c8e5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga58af56b2a9898c045c8ec62ec531c8e5">SDL::round</a> (double x)</td></tr>
<tr class="memdesc:ga58af56b2a9898c045c8ec62ec531c8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round <code>x</code> to the nearest integer.  <br /></td></tr>
<tr class="separator:ga58af56b2a9898c045c8ec62ec531c8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cb3bb70b04800302620c3ebb81e901f" id="r_ga9cb3bb70b04800302620c3ebb81e901f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga9cb3bb70b04800302620c3ebb81e901f">SDL::roundf</a> (float x)</td></tr>
<tr class="memdesc:ga9cb3bb70b04800302620c3ebb81e901f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round <code>x</code> to the nearest integer.  <br /></td></tr>
<tr class="separator:ga9cb3bb70b04800302620c3ebb81e901f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70024c43f89714b01cc1ff00baa682e0" id="r_ga70024c43f89714b01cc1ff00baa682e0"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga70024c43f89714b01cc1ff00baa682e0">SDL::lround</a> (double x)</td></tr>
<tr class="memdesc:ga70024c43f89714b01cc1ff00baa682e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round <code>x</code> to the nearest integer representable as a long.  <br /></td></tr>
<tr class="separator:ga70024c43f89714b01cc1ff00baa682e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6878a0c3b6b75b7c15851c3dfe3d85df" id="r_ga6878a0c3b6b75b7c15851c3dfe3d85df"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga6878a0c3b6b75b7c15851c3dfe3d85df">SDL::lroundf</a> (float x)</td></tr>
<tr class="memdesc:ga6878a0c3b6b75b7c15851c3dfe3d85df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round <code>x</code> to the nearest integer representable as a long.  <br /></td></tr>
<tr class="separator:ga6878a0c3b6b75b7c15851c3dfe3d85df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2438009a4b8a2f4a9155a168f6cd8303" id="r_ga2438009a4b8a2f4a9155a168f6cd8303"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga2438009a4b8a2f4a9155a168f6cd8303">SDL::scalbn</a> (double x, int n)</td></tr>
<tr class="memdesc:ga2438009a4b8a2f4a9155a168f6cd8303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale <code>x</code> by an integer power of two.  <br /></td></tr>
<tr class="separator:ga2438009a4b8a2f4a9155a168f6cd8303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52e712f14d91d7ecf74bd687a5458a6d" id="r_ga52e712f14d91d7ecf74bd687a5458a6d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga52e712f14d91d7ecf74bd687a5458a6d">SDL::scalbnf</a> (float x, int n)</td></tr>
<tr class="memdesc:ga52e712f14d91d7ecf74bd687a5458a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale <code>x</code> by an integer power of two.  <br /></td></tr>
<tr class="separator:ga52e712f14d91d7ecf74bd687a5458a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88bf16c79b920ce54e0ae909b2948663" id="r_ga88bf16c79b920ce54e0ae909b2948663"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga88bf16c79b920ce54e0ae909b2948663">SDL::sin</a> (double x)</td></tr>
<tr class="memdesc:ga88bf16c79b920ce54e0ae909b2948663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sine of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga88bf16c79b920ce54e0ae909b2948663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab41ffcc72f47ca7757cdaa4a0844dd7c" id="r_gab41ffcc72f47ca7757cdaa4a0844dd7c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gab41ffcc72f47ca7757cdaa4a0844dd7c">SDL::sinf</a> (float x)</td></tr>
<tr class="memdesc:gab41ffcc72f47ca7757cdaa4a0844dd7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sine of <code>x</code>.  <br /></td></tr>
<tr class="separator:gab41ffcc72f47ca7757cdaa4a0844dd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8415b71ce1045874d7b55210806ff3c8" id="r_ga8415b71ce1045874d7b55210806ff3c8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8415b71ce1045874d7b55210806ff3c8">SDL::sqrt</a> (double x)</td></tr>
<tr class="memdesc:ga8415b71ce1045874d7b55210806ff3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga8415b71ce1045874d7b55210806ff3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7c7e59d49d88aa05125fd347beeed63" id="r_gaf7c7e59d49d88aa05125fd347beeed63"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaf7c7e59d49d88aa05125fd347beeed63">SDL::sqrtf</a> (float x)</td></tr>
<tr class="memdesc:gaf7c7e59d49d88aa05125fd347beeed63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of <code>x</code>.  <br /></td></tr>
<tr class="separator:gaf7c7e59d49d88aa05125fd347beeed63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88b5a6adb928a623a97598a7a154432c" id="r_ga88b5a6adb928a623a97598a7a154432c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga88b5a6adb928a623a97598a7a154432c">SDL::tan</a> (double x)</td></tr>
<tr class="memdesc:ga88b5a6adb928a623a97598a7a154432c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of <code>x</code>.  <br /></td></tr>
<tr class="separator:ga88b5a6adb928a623a97598a7a154432c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf14c09ac379c8fa038a9fab209b9d4d7" id="r_gaf14c09ac379c8fa038a9fab209b9d4d7"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#gaf14c09ac379c8fa038a9fab209b9d4d7">SDL::tanf</a> (float x)</td></tr>
<tr class="memdesc:gaf14c09ac379c8fa038a9fab209b9d4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of <code>x</code>.  <br /></td></tr>
<tr class="separator:gaf14c09ac379c8fa038a9fab209b9d4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8101a1c19844c8cb72600a9aa6238327" id="r_ga8101a1c19844c8cb72600a9aa6238327"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga8101a1c19844c8cb72600a9aa6238327">SDL::iconv_string</a> (<a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> tocode, <a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> fromcode, <a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a> inbuf, size_t inbytesleft)</td></tr>
<tr class="memdesc:ga8101a1c19844c8cb72600a9aa6238327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to convert a string's encoding in one call.  <br /></td></tr>
<tr class="separator:ga8101a1c19844c8cb72600a9aa6238327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eff841be311c6243e4c36bc358e017f" id="r_ga5eff841be311c6243e4c36bc358e017f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga5eff841be311c6243e4c36bc358e017f">SDL::size_mul_check_overflow</a> (size_t a, size_t b, size_t *ret)</td></tr>
<tr class="memdesc:ga5eff841be311c6243e4c36bc358e017f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two integers, checking for overflow.  <br /></td></tr>
<tr class="separator:ga5eff841be311c6243e4c36bc358e017f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a8cffac163d32a70c2a38ed43b8aed6" id="r_ga6a8cffac163d32a70c2a38ed43b8aed6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryStdinc.html#ga6a8cffac163d32a70c2a38ed43b8aed6">SDL::size_add_check_overflow</a> (size_t a, size_t b, size_t *ret)</td></tr>
<tr class="memdesc:ga6a8cffac163d32a70c2a38ed43b8aed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two integers, checking for overflow.  <br /></td></tr>
<tr class="separator:ga6a8cffac163d32a70c2a38ed43b8aed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Using these functions allows an app to have access to common C functionality without depending on a specific C runtime (or a C runtime at all). More importantly, the <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> implementations work identically across platforms, so apps can avoid surprises like <a class="el" href="group__CategoryStdinc.html#ga57b48f04ae9e3949774b9f0c9dc0c151" title="This works exactly like snprintf() but doesn&#39;t require access to a C runtime.">snprintf()</a> behaving differently between Windows and Linux builds, or <a class="el" href="group__CategoryStdinc.html#gac0d19dc9f116d9f492fd4d17296f0c4b" title="Convert an integer into a string.">itoa()</a> only existing on some platforms.</p>
<p>For many of the most common functions, like SDL_memcpy, <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> might just call through to the usual C runtime behind the scenes, if it makes sense to do so (if it's faster and always available/reliable on a given platform), reducing library size and offering the most optimized option.</p>
<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> also offers other C-runtime-adjacent functionality in this header that either isn't, strictly speaking, part of any C runtime standards, like SDL_crc32() and SDL_reinterpret_cast, etc. It also offers a few better options, like SDL_strlcpy(), which functions as a safer form of strcpy(). </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga4f2714c0d9540b5e1e85ed5503c59215" name="ga4f2714c0d9540b5e1e85ed5503c59215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f2714c0d9540b5e1e85ed5503c59215">&#9670;&#160;</a></span>calloc_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">SDL::calloc_func</a> = typedef SDL_calloc_func</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> will always ensure that the passed <code>nmemb</code> and <code>size</code> are both greater than 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nmemb</td><td>the number of elements in the array. </td></tr>
    <tr><td class="paramname">size</td><td>the size of each element of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated array, or NULL if allocation failed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It should be safe to call this callback from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_calloc </dd>
<dd>
SDL_GetOriginalMemoryFunctions </dd>
<dd>
SDL_GetMemoryFunctions </dd>
<dd>
SDL_SetMemoryFunctions </dd></dl>

</div>
</div>
<a id="gabc94be94823c25031d6dd9210ef3e81a" name="gabc94be94823c25031d6dd9210ef3e81a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc94be94823c25031d6dd9210ef3e81a">&#9670;&#160;</a></span>CompareCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryStdinc.html#gabc94be94823c25031d6dd9210ef3e81a">SDL::CompareCallback</a> = typedef SDL_CompareCallback</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>a pointer to the first element being compared. </td></tr>
    <tr><td class="paramname">b</td><td>a pointer to the second element being compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if <code>a</code> should be sorted before <code>b</code>, 1 if <code>b</code> should be sorted before <code>a</code>, 0 if they are equal. If two elements are equal, their order in the sorted array is undefined.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This callback is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_bsearch </dd>
<dd>
SDL_qsort </dd></dl>

</div>
</div>
<a id="gab5c634ea2ae9a102fa58cd7beac9f478" name="gab5c634ea2ae9a102fa58cd7beac9f478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5c634ea2ae9a102fa58cd7beac9f478">&#9670;&#160;</a></span>CompareCallback_r</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryStdinc.html#gab5c634ea2ae9a102fa58cd7beac9f478">SDL::CompareCallback_r</a> = typedef SDL_CompareCallback_r</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userdata</td><td>the <code>userdata</code> pointer passed to the sort function. </td></tr>
    <tr><td class="paramname">a</td><td>a pointer to the first element being compared. </td></tr>
    <tr><td class="paramname">b</td><td>a pointer to the second element being compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if <code>a</code> should be sorted before <code>b</code>, 1 if <code>b</code> should be sorted before <code>a</code>, 0 if they are equal. If two elements are equal, their order in the sorted array is undefined.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This callback is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_qsort_r </dd>
<dd>
SDL_bsearch_r </dd></dl>

</div>
</div>
<a id="gaedb86e9b9bb1aca04f73942d06b1d98f" name="gaedb86e9b9bb1aca04f73942d06b1d98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedb86e9b9bb1aca04f73942d06b1d98f">&#9670;&#160;</a></span>Environment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryStdinc.html#gaedb86e9b9bb1aca04f73942d06b1d98f">SDL::Environment</a> = typedef <a class="el" href="structSDL_1_1EnvironmentBase.html">EnvironmentBase</a>&lt;<a class="el" href="classSDL_1_1ObjectUnique.html">ObjectUnique</a>&lt;SDL_Environment&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Category:</dt><dd><a class="el" href="resource.html">Resource</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd>resource </dd>
<dd>
<a class="el" href="structSDL_1_1EnvironmentBase.html" title="A thread-safe set of environment variables.">EnvironmentBase</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga61951c691e5b53e2c5261c8f3536531e" title="Handle to a non owning environment.">EnvironmentRef</a> </dd></dl>

</div>
</div>
<a id="ga61951c691e5b53e2c5261c8f3536531e" name="ga61951c691e5b53e2c5261c8f3536531e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61951c691e5b53e2c5261c8f3536531e">&#9670;&#160;</a></span>EnvironmentRef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryStdinc.html#ga61951c691e5b53e2c5261c8f3536531e">SDL::EnvironmentRef</a> = typedef <a class="el" href="structSDL_1_1EnvironmentBase.html">EnvironmentBase</a>&lt;<a class="el" href="classSDL_1_1ObjectRef.html">ObjectRef</a>&lt;SDL_Environment&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Category:</dt><dd><a class="el" href="resource.html">Resource</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd>resource </dd>
<dd>
<a class="el" href="structSDL_1_1EnvironmentBase.html" title="A thread-safe set of environment variables.">EnvironmentBase</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaedb86e9b9bb1aca04f73942d06b1d98f" title="Handle to an owning environment.">Environment</a> </dd></dl>

</div>
</div>
<a id="ga80cbbb5b121c8f78d44a66deaa573127" name="ga80cbbb5b121c8f78d44a66deaa573127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80cbbb5b121c8f78d44a66deaa573127">&#9670;&#160;</a></span>free_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">SDL::free_func</a> = typedef SDL_free_func</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> will always ensure that the passed <code>mem</code> is a non-NULL pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>a pointer to allocated memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It should be safe to call this callback from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_free </dd>
<dd>
SDL_GetOriginalMemoryFunctions </dd>
<dd>
SDL_GetMemoryFunctions </dd>
<dd>
SDL_SetMemoryFunctions </dd></dl>

</div>
</div>
<a id="ga379a3713730374c4737a2bfb2004fab7" name="ga379a3713730374c4737a2bfb2004fab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga379a3713730374c4737a2bfb2004fab7">&#9670;&#160;</a></span>FunctionPointer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryStdinc.html#ga379a3713730374c4737a2bfb2004fab7">SDL::FunctionPointer</a> = typedef SDL_FunctionPointer</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In theory, generic function pointers should use this, instead of <code>void *</code>, since some platforms could treat code addresses differently than data addresses. Although in current times no popular platforms make this distinction, it is more correct and portable to use the correct type for a generic pointer.</p>
<p>If for some reason you need to force this typedef to be an actual <code>void *</code>, perhaps to work around a compiler or existing code, you can define <code>SDL_FUNCTION_POINTER_IS_VOID_POINTER</code> before including any <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> headers.</p>
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga95fcbc65252fd494d78ce162e1340bea" name="ga95fcbc65252fd494d78ce162e1340bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95fcbc65252fd494d78ce162e1340bea">&#9670;&#160;</a></span>IConv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryStdinc.html#ga95fcbc65252fd494d78ce162e1340bea">SDL::IConv</a> = typedef <a class="el" href="structSDL_1_1IConvBase.html">IConvBase</a>&lt;<a class="el" href="classSDL_1_1ObjectUnique.html">ObjectUnique</a>&lt;SDL_iconv_data_t&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Category:</dt><dd><a class="el" href="resource.html">Resource</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd>resource </dd>
<dd>
<a class="el" href="structSDL_1_1IConvBase.html" title="An opaque handle representing string encoding conversion state.">IConvBase</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga3d2eecfc83ea54cacb89f4fec27fa0b0" title="Handle to a non owning iconv.">IConvRef</a> </dd></dl>

</div>
</div>
<a id="ga3d2eecfc83ea54cacb89f4fec27fa0b0" name="ga3d2eecfc83ea54cacb89f4fec27fa0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d2eecfc83ea54cacb89f4fec27fa0b0">&#9670;&#160;</a></span>IConvRef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryStdinc.html#ga3d2eecfc83ea54cacb89f4fec27fa0b0">SDL::IConvRef</a> = typedef <a class="el" href="structSDL_1_1IConvBase.html">IConvBase</a>&lt;<a class="el" href="classSDL_1_1ObjectRef.html">ObjectRef</a>&lt;SDL_iconv_data_t&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Category:</dt><dd><a class="el" href="resource.html">Resource</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd>resource </dd>
<dd>
<a class="el" href="structSDL_1_1IConvBase.html" title="An opaque handle representing string encoding conversion state.">IConvBase</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga95fcbc65252fd494d78ce162e1340bea" title="Handle to an owning iconv.">IConv</a> </dd></dl>

</div>
</div>
<a id="ga20e849be3a477a832c3f5b49aa71f793" name="ga20e849be3a477a832c3f5b49aa71f793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20e849be3a477a832c3f5b49aa71f793">&#9670;&#160;</a></span>malloc_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">SDL::malloc_func</a> = typedef SDL_malloc_func</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> will always ensure that the passed <code>size</code> is greater than 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the size to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory, or NULL if allocation failed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It should be safe to call this callback from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_malloc </dd>
<dd>
SDL_GetOriginalMemoryFunctions </dd>
<dd>
SDL_GetMemoryFunctions </dd>
<dd>
SDL_SetMemoryFunctions </dd></dl>

</div>
</div>
<a id="gaa0d42a4ebfbbe5ab7908f55ba0560ecb" name="gaa0d42a4ebfbbe5ab7908f55ba0560ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">&#9670;&#160;</a></span>realloc_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">SDL::realloc_func</a> = typedef SDL_realloc_func</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> will always ensure that the passed <code>size</code> is greater than 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>a pointer to allocated memory to reallocate, or NULL. </td></tr>
    <tr><td class="paramname">size</td><td>the new size of the memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly allocated memory, or NULL if allocation failed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It should be safe to call this callback from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This datatype is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_realloc </dd>
<dd>
SDL_GetOriginalMemoryFunctions </dd>
<dd>
SDL_GetMemoryFunctions </dd>
<dd>
SDL_SetMemoryFunctions </dd></dl>

</div>
</div>
<a id="ga4cdca510cc08a5569b9e76462e19242f" name="ga4cdca510cc08a5569b9e76462e19242f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cdca510cc08a5569b9e76462e19242f">&#9670;&#160;</a></span>Time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__CategoryStdinc.html#ga4cdca510cc08a5569b9e76462e19242f">SDL::Time</a> = typedef SDL_Time</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>They can be converted between POSIX time_t values with SDL_NS_TO_SECONDS() and SDL_SECONDS_TO_NS(), and between Windows FILETIME values with SDL_TimeToWindows() and SDL_TimeFromWindows().</p>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_MAX_SINT64 </dd>
<dd>
SDL_MIN_SINT64 </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab188f3aa930df339c851b95bf2c4030b" name="gab188f3aa930df339c851b95bf2c4030b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab188f3aa930df339c851b95bf2c4030b">&#9670;&#160;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::abs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>an integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the absolute value of x.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga9f6543d319422a6044570b59cc6377b4" name="ga9f6543d319422a6044570b59cc6377b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f6543d319422a6044570b59cc6377b4">&#9670;&#160;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::acos </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of <code>y = acos(x)</code> is <code>x = cos(y)</code>.</p>
<p>Domain: <code>-1 &lt;= x &lt;= 1</code></p>
<p>Range: <code>0 &lt;= y &lt;= Pi</code></p>
<p>This function operates on double-precision floating point values, use SDL_acosf for single-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc cosine of <code>x</code>, in radians.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_acosf </dd>
<dd>
SDL_asin </dd>
<dd>
SDL_cos </dd></dl>

</div>
</div>
<a id="ga8e3b6760100280cb4cb51fcee4b3a2ff" name="ga8e3b6760100280cb4cb51fcee4b3a2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e3b6760100280cb4cb51fcee4b3a2ff">&#9670;&#160;</a></span>acosf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::acosf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of <code>y = acos(x)</code> is <code>x = cos(y)</code>.</p>
<p>Domain: <code>-1 &lt;= x &lt;= 1</code></p>
<p>Range: <code>0 &lt;= y &lt;= Pi</code></p>
<p>This function operates on single-precision floating point values, use SDL_acos for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc cosine of <code>x</code>, in radians.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_acos </dd>
<dd>
SDL_asinf </dd>
<dd>
SDL_cosf </dd></dl>

</div>
</div>
<a id="gae3c9f70ddeadaecb2afeee2b3be34733" name="gae3c9f70ddeadaecb2afeee2b3be34733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3c9f70ddeadaecb2afeee2b3be34733">&#9670;&#160;</a></span>aligned_alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::aligned_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The memory returned by this function must be freed with SDL_aligned_free(), <em>not</em> SDL_free().</p>
<p>If <code>alignment</code> is less than the size of <code>void *</code>, it will be increased to match that.</p>
<p>The returned memory address will be a multiple of the alignment value, and the size of the memory allocated will be a multiple of the alignment value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alignment</td><td>the alignment of the memory. </td></tr>
    <tr><td class="paramname">size</td><td>the size to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the aligned memory, or NULL if allocation failed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_aligned_free </dd></dl>

</div>
</div>
<a id="gaaf1efed697d82742be084a1871c95aa2" name="gaaf1efed697d82742be084a1871c95aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf1efed697d82742be084a1871c95aa2">&#9670;&#160;</a></span>aligned_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::aligned_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The pointer is no longer valid after this call and cannot be dereferenced anymore.</p>
<p>If <code>mem</code> is NULL, this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>a pointer previously returned by SDL_aligned_alloc(), or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_aligned_alloc </dd></dl>

</div>
</div>
<a id="ga316a2eed1e595c002830ee628c1b4963" name="ga316a2eed1e595c002830ee628c1b4963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga316a2eed1e595c002830ee628c1b4963">&#9670;&#160;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::asin </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of <code>y = asin(x)</code> is <code>x = sin(y)</code>.</p>
<p>Domain: <code>-1 &lt;= x &lt;= 1</code></p>
<p>Range: <code>-Pi/2 &lt;= y &lt;= Pi/2</code></p>
<p>This function operates on double-precision floating point values, use SDL_asinf for single-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc sine of <code>x</code>, in radians.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_asinf </dd>
<dd>
SDL_acos </dd>
<dd>
SDL_sin </dd></dl>

</div>
</div>
<a id="ga093ee4582ee6f6c02ab22c77718f56a8" name="ga093ee4582ee6f6c02ab22c77718f56a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga093ee4582ee6f6c02ab22c77718f56a8">&#9670;&#160;</a></span>asinf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::asinf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of <code>y = asin(x)</code> is <code>x = sin(y)</code>.</p>
<p>Domain: <code>-1 &lt;= x &lt;= 1</code></p>
<p>Range: <code>-Pi/2 &lt;= y &lt;= Pi/2</code></p>
<p>This function operates on single-precision floating point values, use SDL_asin for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc sine of <code>x</code>, in radians.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_asin </dd>
<dd>
SDL_acosf </dd>
<dd>
SDL_sinf </dd></dl>

</div>
</div>
<a id="ga12e5aac7458286e05c61d71278f59215" name="ga12e5aac7458286e05c61d71278f59215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12e5aac7458286e05c61d71278f59215">&#9670;&#160;</a></span>asprintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::asprintf </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>strp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_PRINTF_FORMAT_STRING const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Functions identically to SDL_snprintf(), except it allocates a buffer large enough to hold the output string on behalf of the caller.</p>
<p>On success, this function returns the number of bytes (not characters) comprising the output string, not counting the null-terminator character, and sets <code>*strp</code> to the newly-allocated string.</p>
<p>On error, this function returns a negative number, and the value of <code>*strp</code> is undefined.</p>
<p>The returned string is owned by the caller, and should be passed to SDL_free when no longer needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strp</td><td>on output, is set to the new string. Must not be NULL. </td></tr>
    <tr><td class="paramname">fmt</td><td>a printf-style format string. Must not be NULL. </td></tr>
    <tr><td class="paramname">...</td><td>a list of values to be used with the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes in the newly-allocated string, not counting the null-terminator char, or a negative value on error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga11d0eaba28baba36fc8050f8541c8ee5" name="ga11d0eaba28baba36fc8050f8541c8ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11d0eaba28baba36fc8050f8541c8ee5">&#9670;&#160;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::atan </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of <code>y = atan(x)</code> is <code>x = tan(y)</code>.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-Pi/2 &lt;= y &lt;= Pi/2</code></p>
<p>This function operates on double-precision floating point values, use SDL_atanf for single-precision floats.</p>
<p>To calculate the arc tangent of y / x, use SDL_atan2.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc tangent of of <code>x</code> in radians, or 0 if <code>x = 0</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_atanf </dd>
<dd>
SDL_atan2 </dd>
<dd>
SDL_tan </dd></dl>

</div>
</div>
<a id="gae0884b892c70d428cf50522d9791eb61" name="gae0884b892c70d428cf50522d9791eb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0884b892c70d428cf50522d9791eb61">&#9670;&#160;</a></span>atan2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::atan2 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of <code>z = atan2(x, y)</code> is <code>y = x tan(z)</code>, where the quadrant of z is determined based on the signs of x and y.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= INF</code></p>
<p>Range: <code>-Pi/2 &lt;= y &lt;= Pi/2</code></p>
<p>This function operates on double-precision floating point values, use SDL_atan2f for single-precision floats.</p>
<p>To calculate the arc tangent of a single value, use SDL_atan.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>floating point value of the numerator (y coordinate). </td></tr>
    <tr><td class="paramname">x</td><td>floating point value of the denominator (x coordinate). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc tangent of of <code>y / x</code> in radians, or, if <code>x = 0</code>, either <code>-Pi/2</code>, <code>0</code>, or <code>Pi/2</code>, depending on the value of <code>y</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_atan2f </dd>
<dd>
SDL_atan </dd>
<dd>
SDL_tan </dd></dl>

</div>
</div>
<a id="gaf1be31240212288c0d7556cf80340b93" name="gaf1be31240212288c0d7556cf80340b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1be31240212288c0d7556cf80340b93">&#9670;&#160;</a></span>atan2f()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::atan2f </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of <code>z = atan2(x, y)</code> is <code>y = x tan(z)</code>, where the quadrant of z is determined based on the signs of x and y.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= INF</code></p>
<p>Range: <code>-Pi/2 &lt;= y &lt;= Pi/2</code></p>
<p>This function operates on single-precision floating point values, use SDL_atan2 for double-precision floats.</p>
<p>To calculate the arc tangent of a single value, use SDL_atanf.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>floating point value of the numerator (y coordinate). </td></tr>
    <tr><td class="paramname">x</td><td>floating point value of the denominator (x coordinate). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc tangent of of <code>y / x</code> in radians, or, if <code>x = 0</code>, either <code>-Pi/2</code>, <code>0</code>, or <code>Pi/2</code>, depending on the value of <code>y</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_atan2f </dd>
<dd>
SDL_atan </dd>
<dd>
SDL_tan </dd></dl>

</div>
</div>
<a id="ga19e239deb9997e2ff33bbfdbaec436b2" name="ga19e239deb9997e2ff33bbfdbaec436b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19e239deb9997e2ff33bbfdbaec436b2">&#9670;&#160;</a></span>atanf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::atanf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of <code>y = atan(x)</code> is <code>x = tan(y)</code>.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-Pi/2 &lt;= y &lt;= Pi/2</code></p>
<p>This function operates on single-precision floating point values, use SDL_atan for dboule-precision floats.</p>
<p>To calculate the arc tangent of y / x, use SDL_atan2f.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arc tangent of of <code>x</code> in radians, or 0 if <code>x = 0</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_atan </dd>
<dd>
SDL_atan2f </dd>
<dd>
SDL_tanf </dd></dl>

</div>
</div>
<a id="gaeecdd7ec80c303a7474d59b641a892f7" name="gaeecdd7ec80c303a7474d59b641a892f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeecdd7ec80c303a7474d59b641a892f7">&#9670;&#160;</a></span>atof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::atof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The result of calling <code>SDL_atof(str)</code> is equivalent to <code>SDL_strtod(str,
NULL)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to read. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed <code>double</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_atoi </dd>
<dd>
SDL_strtol </dd>
<dd>
SDL_strtoul </dd>
<dd>
SDL_strtoll </dd>
<dd>
SDL_strtoull </dd>
<dd>
SDL_strtod </dd></dl>

</div>
</div>
<a id="ga756fd0202aa809d537fc01e28b0c7564" name="ga756fd0202aa809d537fc01e28b0c7564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga756fd0202aa809d537fc01e28b0c7564">&#9670;&#160;</a></span>atoi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::atoi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The result of calling <code>SDL_atoi(str)</code> is equivalent to <code>(int)SDL_strtol(str, NULL, 10)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to read. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed <code>int</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_atof </dd>
<dd>
SDL_strtol </dd>
<dd>
SDL_strtoul </dd>
<dd>
SDL_strtoll </dd>
<dd>
SDL_strtoull </dd>
<dd>
SDL_strtod </dd>
<dd>
SDL_itoa </dd></dl>

</div>
</div>
<a id="gada62aea13b8eceffa3e57359e124e541" name="gada62aea13b8eceffa3e57359e124e541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada62aea13b8eceffa3e57359e124e541">&#9670;&#160;</a></span>bsearch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::bsearch </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gabc94be94823c25031d6dd9210ef3e81a">CompareCallback</a>&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For example:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">      <span class="keywordtype">int</span> key;</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">char</span> *string;</div>
<div class="line">  } data;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> SDLCALL compare(<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)</div>
<div class="line">  {</div>
<div class="line">      <span class="keyword">const</span> data *A = (<span class="keyword">const</span> data *)a;</div>
<div class="line">      <span class="keyword">const</span> data *B = (<span class="keyword">const</span> data *)b;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">if</span> (A-&gt;n &lt; B-&gt;n) {</div>
<div class="line">          <span class="keywordflow">return</span> -1;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (B-&gt;n &lt; A-&gt;n) {</div>
<div class="line">          <span class="keywordflow">return</span> 1;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keywordflow">return</span> 0;</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  data values[] = {</div>
<div class="line">      { 1, <span class="stringliteral">&quot;first&quot;</span> }, { 2, <span class="stringliteral">&quot;second&quot;</span> }, { 3, <span class="stringliteral">&quot;third&quot;</span> }</div>
<div class="line">  };</div>
<div class="line">  data key = { 2, NULL };</div>
<div class="line"> </div>
<div class="line">  data *result = SDL_bsearch(&amp;key, values, SDL_arraysize(values),</div>
<div class="line">*<span class="keyword">sizeof</span>(values[0]), compare);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a pointer to a key equal to the element being searched for. </td></tr>
    <tr><td class="paramname">base</td><td>a pointer to the start of the array. </td></tr>
    <tr><td class="paramname">nmemb</td><td>the number of elements in the array. </td></tr>
    <tr><td class="paramname">size</td><td>the size of the elements in the array. </td></tr>
    <tr><td class="paramname">compare</td><td>a function used to compare elements in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the matching element in the array, or NULL if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_bsearch_r </dd>
<dd>
SDL_qsort </dd></dl>

</div>
</div>
<a id="gaf22f982867b4598c8caa2de8f5a9e0e4" name="gaf22f982867b4598c8caa2de8f5a9e0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf22f982867b4598c8caa2de8f5a9e0e4">&#9670;&#160;</a></span>bsearch_r()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::bsearch_r </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gab5c634ea2ae9a102fa58cd7beac9f478">CompareCallback_r</a>&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For example:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> <span class="keyword">enum</span> {</div>
<div class="line">      sort_increasing,</div>
<div class="line">      sort_decreasing,</div>
<div class="line">  } sort_method;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">      <span class="keywordtype">int</span> key;</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">char</span> *string;</div>
<div class="line">  } data;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> SDLCALL compare(<span class="keyword">const</span> <span class="keywordtype">void</span> *userdata, <span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)</div>
<div class="line">  {</div>
<div class="line">      sort_method method = (sort_method)(uintptr_t)userdata;</div>
<div class="line">      <span class="keyword">const</span> data *A = (<span class="keyword">const</span> data *)a;</div>
<div class="line">      <span class="keyword">const</span> data *B = (<span class="keyword">const</span> data *)b;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">if</span> (A-&gt;key &lt; B-&gt;key) {</div>
<div class="line">          <span class="keywordflow">return</span> (method == sort_increasing) ? -1 : 1;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (B-&gt;key &lt; A-&gt;key) {</div>
<div class="line">          <span class="keywordflow">return</span> (method == sort_increasing) ? 1 : -1;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keywordflow">return</span> 0;</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  data values[] = {</div>
<div class="line">      { 1, <span class="stringliteral">&quot;first&quot;</span> }, { 2, <span class="stringliteral">&quot;second&quot;</span> }, { 3, <span class="stringliteral">&quot;third&quot;</span> }</div>
<div class="line">  };</div>
<div class="line">  data key = { 2, NULL };</div>
<div class="line"> </div>
<div class="line">  data *result = SDL_bsearch_r(&amp;key, values, SDL_arraysize(values),</div>
<div class="line">*<span class="keyword">sizeof</span>(values[0]), compare, (<span class="keyword">const</span> <span class="keywordtype">void</span> *)(uintptr_t)sort_increasing);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a pointer to a key equal to the element being searched for. </td></tr>
    <tr><td class="paramname">base</td><td>a pointer to the start of the array. </td></tr>
    <tr><td class="paramname">nmemb</td><td>the number of elements in the array. </td></tr>
    <tr><td class="paramname">size</td><td>the size of the elements in the array. </td></tr>
    <tr><td class="paramname">compare</td><td>a function used to compare elements in the array. </td></tr>
    <tr><td class="paramname">userdata</td><td>a pointer to pass to the compare function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the matching element in the array, or NULL if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_bsearch </dd>
<dd>
SDL_qsort_r </dd></dl>

</div>
</div>
<a id="gab24b3e9482f5a1c26602b83f2de05d09" name="gab24b3e9482f5a1c26602b83f2de05d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab24b3e9482f5a1c26602b83f2de05d09">&#9670;&#160;</a></span>calloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::calloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The memory returned by this function must be freed with SDL_free().</p>
<p>If either of <code>nmemb</code> or <code>size</code> is 0, they will both be set to 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nmemb</td><td>the number of elements in the array. </td></tr>
    <tr><td class="paramname">size</td><td>the size of each element of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated array, or NULL if allocation failed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_free </dd>
<dd>
SDL_malloc </dd>
<dd>
SDL_realloc </dd></dl>

</div>
</div>
<a id="ga1567a1e6b1738fabc6252d7c52f03321" name="ga1567a1e6b1738fabc6252d7c52f03321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1567a1e6b1738fabc6252d7c52f03321">&#9670;&#160;</a></span>ceil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::ceil </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The ceiling of <code>x</code> is the smallest integer <code>y</code> such that <code>y &gt; x</code>, i.e <code>x</code> rounded up to the nearest integer.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<p>This function operates on double-precision floating point values, use SDL_ceilf for single-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ceiling of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_ceilf </dd>
<dd>
SDL_floor </dd>
<dd>
SDL_trunc </dd>
<dd>
SDL_round </dd>
<dd>
SDL_lround </dd></dl>

</div>
</div>
<a id="ga5962b17a629d7f973898e35e1818646f" name="ga5962b17a629d7f973898e35e1818646f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5962b17a629d7f973898e35e1818646f">&#9670;&#160;</a></span>ceilf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::ceilf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The ceiling of <code>x</code> is the smallest integer <code>y</code> such that <code>y &gt; x</code>, i.e <code>x</code> rounded up to the nearest integer.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<p>This function operates on single-precision floating point values, use SDL_ceil for double-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ceiling of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_ceil </dd>
<dd>
SDL_floorf </dd>
<dd>
SDL_truncf </dd>
<dd>
SDL_roundf </dd>
<dd>
SDL_lroundf </dd></dl>

</div>
</div>
<a id="ga476595ece87ed3441c672348366f0adb" name="ga476595ece87ed3441c672348366f0adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga476595ece87ed3441c672348366f0adb">&#9670;&#160;</a></span>copysign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::copysign </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of copysign is that <code>copysign(x, y) = abs(x) * sign(y)</code>.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= f</code></p>
<p>Range: <code>-INF &lt;= z &lt;= INF</code></p>
<p>This function operates on double-precision floating point values, use SDL_copysignf for single-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value to use as the magnitude. </td></tr>
    <tr><td class="paramname">y</td><td>floating point value to use as the sign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the floating point value with the sign of y and the magnitude of x.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_copysignf </dd>
<dd>
SDL_fabs </dd></dl>

</div>
</div>
<a id="ga0b8d2ae3c91e681437f9b8bad0d332dd" name="ga0b8d2ae3c91e681437f9b8bad0d332dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b8d2ae3c91e681437f9b8bad0d332dd">&#9670;&#160;</a></span>copysignf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::copysignf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of copysign is that <code>copysign(x, y) = abs(x) * sign(y)</code>.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= f</code></p>
<p>Range: <code>-INF &lt;= z &lt;= INF</code></p>
<p>This function operates on single-precision floating point values, use SDL_copysign for double-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value to use as the magnitude. </td></tr>
    <tr><td class="paramname">y</td><td>floating point value to use as the sign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the floating point value with the sign of y and the magnitude of x.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_copysignf </dd>
<dd>
SDL_fabsf </dd></dl>

</div>
</div>
<a id="gadf8c80d673a05784387fa5e349a9f6dd" name="gadf8c80d673a05784387fa5e349a9f6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf8c80d673a05784387fa5e349a9f6dd">&#9670;&#160;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::cos </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-1 &lt;= y &lt;= 1</code></p>
<p>This function operates on double-precision floating point values, use SDL_cosf for single-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value, in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cosine of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_cosf </dd>
<dd>
SDL_acos </dd>
<dd>
SDL_sin </dd></dl>

</div>
</div>
<a id="ga343b62c85d5c6bc9627fdad943860921" name="ga343b62c85d5c6bc9627fdad943860921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga343b62c85d5c6bc9627fdad943860921">&#9670;&#160;</a></span>cosf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::cosf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-1 &lt;= y &lt;= 1</code></p>
<p>This function operates on single-precision floating point values, use SDL_cos for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value, in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cosine of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_cos </dd>
<dd>
SDL_acosf </dd>
<dd>
SDL_sinf </dd></dl>

</div>
</div>
<a id="ga31ee6fbdefd2ca34bbde4c8652069e66" name="ga31ee6fbdefd2ca34bbde4c8652069e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31ee6fbdefd2ca34bbde4c8652069e66">&#9670;&#160;</a></span>crc16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint16 SDL::crc16 </td>
          <td>(</td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>crc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">https://en.wikipedia.org/wiki/Cyclic_redundancy_check</a></p>
<p>This function can be called multiple times, to stream data to be checksummed in blocks. Each call must provide the previous CRC-16 return value to be updated with the next block. The first call to this function for a set of blocks should pass in a zero CRC value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crc</td><td>the current checksum for this data set, or 0 for a new data set. </td></tr>
    <tr><td class="paramname">data</td><td>a new block of data to add to the checksum. </td></tr>
    <tr><td class="paramname">len</td><td>the size, in bytes, of the new block of data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a CRC-16 checksum value of all blocks in the data set.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gacc8b8bc6d26dd888c3fed721ddb1cd2e" name="gacc8b8bc6d26dd888c3fed721ddb1cd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc8b8bc6d26dd888c3fed721ddb1cd2e">&#9670;&#160;</a></span>crc32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 SDL::crc32 </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>crc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">https://en.wikipedia.org/wiki/Cyclic_redundancy_check</a></p>
<p>This function can be called multiple times, to stream data to be checksummed in blocks. Each call must provide the previous CRC-32 return value to be updated with the next block. The first call to this function for a set of blocks should pass in a zero CRC value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crc</td><td>the current checksum for this data set, or 0 for a new data set. </td></tr>
    <tr><td class="paramname">data</td><td>a new block of data to add to the checksum. </td></tr>
    <tr><td class="paramname">len</td><td>the size, in bytes, of the new block of data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a CRC-32 checksum value of all blocks in the data set.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga3e4417a78f0393e80fa7645a534a53a3" name="ga3e4417a78f0393e80fa7645a534a53a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e4417a78f0393e80fa7645a534a53a3">&#9670;&#160;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::exp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of <code>y = exp(x)</code> is <code>y = e^x</code>, where <code>e</code> is the base of the natural logarithm. The inverse is the natural logarithm, SDL_log.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>0 &lt;= y &lt;= INF</code></p>
<p>The output will overflow if <code>exp(x)</code> is too large to be represented.</p>
<p>This function operates on double-precision floating point values, use SDL_expf for single-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of <code>e^x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_expf </dd>
<dd>
SDL_log </dd></dl>

</div>
</div>
<a id="ga5c6a34f6bfb50b176f502a6133880aa8" name="ga5c6a34f6bfb50b176f502a6133880aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c6a34f6bfb50b176f502a6133880aa8">&#9670;&#160;</a></span>expf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::expf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The definition of <code>y = exp(x)</code> is <code>y = e^x</code>, where <code>e</code> is the base of the natural logarithm. The inverse is the natural logarithm, SDL_logf.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>0 &lt;= y &lt;= INF</code></p>
<p>The output will overflow if <code>exp(x)</code> is too large to be represented.</p>
<p>This function operates on single-precision floating point values, use SDL_exp for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of <code>e^x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_exp </dd>
<dd>
SDL_logf </dd></dl>

</div>
</div>
<a id="gae57cb7c976b8596bb9ff76f3402a2488" name="gae57cb7c976b8596bb9ff76f3402a2488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae57cb7c976b8596bb9ff76f3402a2488">&#9670;&#160;</a></span>fabs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::fabs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>0 &lt;= y &lt;= INF</code></p>
<p>This function operates on double-precision floating point values, use SDL_copysignf for single-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value to use as the magnitude. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the absolute value of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_fabsf </dd></dl>

</div>
</div>
<a id="ga8952f2171107539c5cddb95fe5efec28" name="ga8952f2171107539c5cddb95fe5efec28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8952f2171107539c5cddb95fe5efec28">&#9670;&#160;</a></span>fabsf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::fabsf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>0 &lt;= y &lt;= INF</code></p>
<p>This function operates on single-precision floating point values, use SDL_copysignf for double-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value to use as the magnitude. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the absolute value of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_fabs </dd></dl>

</div>
</div>
<a id="gaa5d99939c5dffc37035e51300236316a" name="gaa5d99939c5dffc37035e51300236316a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5d99939c5dffc37035e51300236316a">&#9670;&#160;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::floor </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The floor of <code>x</code> is the largest integer <code>y</code> such that <code>y &gt; x</code>, i.e <code>x</code> rounded down to the nearest integer.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<p>This function operates on double-precision floating point values, use SDL_floorf for single-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the floor of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_floorf </dd>
<dd>
SDL_ceil </dd>
<dd>
SDL_trunc </dd>
<dd>
SDL_round </dd>
<dd>
SDL_lround </dd></dl>

</div>
</div>
<a id="ga8438f2959083ee7e897f7f3ef03ca3b8" name="ga8438f2959083ee7e897f7f3ef03ca3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8438f2959083ee7e897f7f3ef03ca3b8">&#9670;&#160;</a></span>floorf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::floorf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The floor of <code>x</code> is the largest integer <code>y</code> such that <code>y &gt; x</code>, i.e <code>x</code> rounded down to the nearest integer.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<p>This function operates on single-precision floating point values, use SDL_floorf for double-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the floor of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_floor </dd>
<dd>
SDL_ceilf </dd>
<dd>
SDL_truncf </dd>
<dd>
SDL_roundf </dd>
<dd>
SDL_lroundf </dd></dl>

</div>
</div>
<a id="gafcd6b0192bc061852ef8ef56272bf98d" name="gafcd6b0192bc061852ef8ef56272bf98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcd6b0192bc061852ef8ef56272bf98d">&#9670;&#160;</a></span>fmod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::fmod </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divides <code>x</code> by <code>y</code>, and returns the remainder.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= INF</code>, <code>y != 0</code></p>
<p>Range: <code>-y &lt;= z &lt;= y</code></p>
<p>This function operates on double-precision floating point values, use SDL_fmodf for single-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the numerator. </td></tr>
    <tr><td class="paramname">y</td><td>the denominator. Must not be 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the remainder of <code>x / y</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_fmodf </dd>
<dd>
SDL_modf </dd>
<dd>
SDL_trunc </dd>
<dd>
SDL_ceil </dd>
<dd>
SDL_floor </dd>
<dd>
SDL_round </dd>
<dd>
SDL_lround </dd></dl>

</div>
</div>
<a id="gab12a77026e20d3235fab10d708ed80a6" name="gab12a77026e20d3235fab10d708ed80a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab12a77026e20d3235fab10d708ed80a6">&#9670;&#160;</a></span>fmodf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::fmodf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divides <code>x</code> by <code>y</code>, and returns the remainder.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= INF</code>, <code>y != 0</code></p>
<p>Range: <code>-y &lt;= z &lt;= y</code></p>
<p>This function operates on single-precision floating point values, use SDL_fmod for single-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the numerator. </td></tr>
    <tr><td class="paramname">y</td><td>the denominator. Must not be 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the remainder of <code>x / y</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_fmod </dd>
<dd>
SDL_truncf </dd>
<dd>
SDL_modff </dd>
<dd>
SDL_ceilf </dd>
<dd>
SDL_floorf </dd>
<dd>
SDL_roundf </dd>
<dd>
SDL_lroundf </dd></dl>

</div>
</div>
<a id="gaa932b3872f6162d7257c924b184e5381" name="gaa932b3872f6162d7257c924b184e5381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa932b3872f6162d7257c924b184e5381">&#9670;&#160;</a></span>FourCC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Uint32 SDL::FourCC </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first ASCII character. </td></tr>
    <tr><td class="paramname">b</td><td>the second ASCII character. </td></tr>
    <tr><td class="paramname">c</td><td>the third ASCII character. </td></tr>
    <tr><td class="paramname">d</td><td>the fourth ASCII character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the four characters converted into a Uint32, one character per-byte.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this macro from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gadfa01257ca1f966fffb72f002db27fa6" name="gadfa01257ca1f966fffb72f002db27fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfa01257ca1f966fffb72f002db27fa6">&#9670;&#160;</a></span>free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The pointer is no longer valid after this call and cannot be dereferenced anymore.</p>
<p>If <code>mem</code> is NULL, this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>a pointer to allocated memory, or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_malloc </dd>
<dd>
SDL_calloc </dd>
<dd>
SDL_realloc </dd></dl>

</div>
</div>
<a id="ga97502b219bb63f4be0f31868fecc9120" name="ga97502b219bb63f4be0f31868fecc9120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97502b219bb63f4be0f31868fecc9120">&#9670;&#160;</a></span>getenv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * SDL::getenv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function uses <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a>'s cached copy of the environment and is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the variable to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the value of the variable or NULL if it can't be found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga8a55c001e123a53e424cbc460ec4b1b6" name="ga8a55c001e123a53e424cbc460ec4b1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a55c001e123a53e424cbc460ec4b1b6">&#9670;&#160;</a></span>getenv_unsafe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * SDL::getenv_unsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function bypasses <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a>'s cached copy of the environment and is not thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the variable to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the value of the variable or NULL if it can't be found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe, consider using SDL_getenv() instead.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_getenv </dd></dl>

</div>
</div>
<a id="gafc9e4411ee1c8072c58cbfa0566a5660" name="gafc9e4411ee1c8072c58cbfa0566a5660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc9e4411ee1c8072c58cbfa0566a5660">&#9670;&#160;</a></span>GetEnvironment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CategoryStdinc.html#ga61951c691e5b53e2c5261c8f3536531e">EnvironmentRef</a> SDL::GetEnvironment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is initialized at application start and is not affected by setenv() and unsetenv() calls after that point. Use SDL_SetEnvironmentVariable() and SDL_UnsetEnvironmentVariable() if you want to modify this environment, or SDL_setenv_unsafe() or SDL_unsetenv_unsafe() if you want changes to persist in the C runtime environment after SDL_Quit().</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the environment for the process or NULL on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>GetVariable() </dd>
<dd>
GetVariables() </dd>
<dd>
SetVariable() </dd>
<dd>
UnsetVariable() </dd></dl>

</div>
</div>
<a id="gab331691e9cf41b2fd9063b80910ea6b0" name="gab331691e9cf41b2fd9063b80910ea6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab331691e9cf41b2fd9063b80910ea6b0">&#9670;&#160;</a></span>GetMemoryFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GetMemoryFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a> *&#160;</td>
          <td class="paramname"><em>malloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a> *&#160;</td>
          <td class="paramname"><em>calloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a> *&#160;</td>
          <td class="paramname"><em>realloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a> *&#160;</td>
          <td class="paramname"><em>free_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">malloc_func</td><td>filled with malloc function. </td></tr>
    <tr><td class="paramname">calloc_func</td><td>filled with calloc function. </td></tr>
    <tr><td class="paramname">realloc_func</td><td>filled with realloc function. </td></tr>
    <tr><td class="paramname">free_func</td><td>filled with free function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This does not hold a lock, so do not call this in the unlikely event of a background thread calling SDL_SetMemoryFunctions simultaneously.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_SetMemoryFunctions </dd>
<dd>
SDL_GetOriginalMemoryFunctions </dd></dl>

</div>
</div>
<a id="gae51ea510815eaec3a9b288754a805206" name="gae51ea510815eaec3a9b288754a805206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae51ea510815eaec3a9b288754a805206">&#9670;&#160;</a></span>GetNumAllocations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::GetNumAllocations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of allocations or -1 if allocation counting is disabled.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga6325f645ab936554e7aaa2e4d977d9d7" name="ga6325f645ab936554e7aaa2e4d977d9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6325f645ab936554e7aaa2e4d977d9d7">&#9670;&#160;</a></span>GetOriginalMemoryFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::GetOriginalMemoryFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a> *&#160;</td>
          <td class="paramname"><em>malloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a> *&#160;</td>
          <td class="paramname"><em>calloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a> *&#160;</td>
          <td class="paramname"><em>realloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a> *&#160;</td>
          <td class="paramname"><em>free_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is what SDL_malloc and friends will use by default, if there has been no call to SDL_SetMemoryFunctions. This is not necessarily using the C runtime's <code>malloc</code> functions behind the scenes! Different platforms and build configurations might do any number of unexpected things.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">malloc_func</td><td>filled with malloc function. </td></tr>
    <tr><td class="paramname">calloc_func</td><td>filled with calloc function. </td></tr>
    <tr><td class="paramname">realloc_func</td><td>filled with realloc function. </td></tr>
    <tr><td class="paramname">free_func</td><td>filled with free function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga8101a1c19844c8cb72600a9aa6238327" name="ga8101a1c19844c8cb72600a9aa6238327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8101a1c19844c8cb72600a9aa6238327">&#9670;&#160;</a></span>iconv_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::iconv_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>tocode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>fromcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>inbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inbytesleft</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function converts a buffer or string between encodings in one pass.</p>
<p>The string does not need to be NULL-terminated; this function operates on the number of bytes specified in <code>inbytesleft</code> whether there is a NULL character anywhere in the buffer.</p>
<p>The returned string is owned by the caller, and should be passed to SDL_free when no longer needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tocode</td><td>the character encoding of the output string. Examples are "UTF-8", "UCS-4", etc. </td></tr>
    <tr><td class="paramname">fromcode</td><td>the character encoding of data in <code>inbuf</code>. </td></tr>
    <tr><td class="paramname">inbuf</td><td>the string to convert to a different encoding. </td></tr>
    <tr><td class="paramname">inbytesleft</td><td>the size of the input string <em>in bytes</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new string, converted to the new encoding, or NULL on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_iconv_open </dd>
<dd>
SDL_iconv_close </dd>
<dd>
SDL_iconv </dd></dl>

</div>
</div>
<a id="gafc3565e81c3ab6ba0e66f9030c056969" name="gafc3565e81c3ab6ba0e66f9030c056969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc3565e81c3ab6ba0e66f9030c056969">&#9670;&#160;</a></span>isalnum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isalnum </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values for English 'a-z', 'A-Z', and '0-9' as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga79256765fa0f219b5947721d1d920041" name="ga79256765fa0f219b5947721d1d920041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79256765fa0f219b5947721d1d920041">&#9670;&#160;</a></span>isalpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isalpha </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values for English 'a-z' and 'A-Z' as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gab6936f2d259cb2959c3d73e8bb66cf0d" name="gab6936f2d259cb2959c3d73e8bb66cf0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6936f2d259cb2959c3d73e8bb66cf0d">&#9670;&#160;</a></span>isblank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isblank </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values 0x20 (space) or 0x9 (tab) as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga901f942513d4469f8722185f0cee85bd" name="ga901f942513d4469f8722185f0cee85bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga901f942513d4469f8722185f0cee85bd">&#9670;&#160;</a></span>iscntrl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::iscntrl </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values 0 through 0x1F, and 0x7F, as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga3c4d5430375fa896b58aa1e5a23cd30f" name="ga3c4d5430375fa896b58aa1e5a23cd30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c4d5430375fa896b58aa1e5a23cd30f">&#9670;&#160;</a></span>isdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isdigit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values '0' (0x30) through '9' (0x39), as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga28e4c655a653424f510993ddec5b02b4" name="ga28e4c655a653424f510993ddec5b02b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28e4c655a653424f510993ddec5b02b4">&#9670;&#160;</a></span>isgraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isgraph </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Be advised that "printable" has a definition that goes back to text terminals from the dawn of computing, making this a sort of special case function that is not suitable for Unicode (or most any) text management.</p>
<p><b>WARNING</b>: Regardless of system locale, this is equivalent to &lsquo;(SDL_isprint(x)) &amp;&amp; ((x) != &rsquo; ')`.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_isprint </dd></dl>

</div>
</div>
<a id="ga918f0e70e6e67f724c445eba4b514a21" name="ga918f0e70e6e67f724c445eba4b514a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga918f0e70e6e67f724c445eba4b514a21">&#9670;&#160;</a></span>isinf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isinf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>double-precision floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if the value is infinity, 0 otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_isinff </dd></dl>

</div>
</div>
<a id="ga59c45f83103aa3fdc57244124dea7d5d" name="ga59c45f83103aa3fdc57244124dea7d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59c45f83103aa3fdc57244124dea7d5d">&#9670;&#160;</a></span>isinff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isinff </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if the value is infinity, 0 otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_isinf </dd></dl>

</div>
</div>
<a id="ga9154645a2881fcb9f6c1df5c4d848ef1" name="ga9154645a2881fcb9f6c1df5c4d848ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9154645a2881fcb9f6c1df5c4d848ef1">&#9670;&#160;</a></span>islower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::islower </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values 'a' through 'z' as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga2221269e7ded0fb89af37aea9132e0b8" name="ga2221269e7ded0fb89af37aea9132e0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2221269e7ded0fb89af37aea9132e0b8">&#9670;&#160;</a></span>isnan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isnan </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>double-precision floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if the value is NaN, 0 otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_isnanf </dd></dl>

</div>
</div>
<a id="ga945938b6b96f7b17c1916fe9d357a315" name="ga945938b6b96f7b17c1916fe9d357a315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga945938b6b96f7b17c1916fe9d357a315">&#9670;&#160;</a></span>isnanf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isnanf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if the value is NaN, 0 otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_isnan </dd></dl>

</div>
</div>
<a id="ga6ff81eceb17060ed3c3c7c32a14bf7b8" name="ga6ff81eceb17060ed3c3c7c32a14bf7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ff81eceb17060ed3c3c7c32a14bf7b8">&#9670;&#160;</a></span>isprint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isprint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Be advised that "printable" has a definition that goes back to text terminals from the dawn of computing, making this a sort of special case function that is not suitable for Unicode (or most any) text management.</p>
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values ' ' (0x20) through '~' (0x7E) as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gac1876da5600f8722288dc8641d978fab" name="gac1876da5600f8722288dc8641d978fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1876da5600f8722288dc8641d978fab">&#9670;&#160;</a></span>ispunct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::ispunct </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this is equivalent to <code>((SDL_isgraph(x)) &amp;&amp; (!SDL_isalnum(x)))</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_isgraph </dd>
<dd>
SDL_isalnum </dd></dl>

</div>
</div>
<a id="ga922904215a42f639a8385470d5e61667" name="ga922904215a42f639a8385470d5e61667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga922904215a42f639a8385470d5e61667">&#9670;&#160;</a></span>isspace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isspace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only treat the following ASCII values as true:</p>
<ul>
<li>space (0x20)</li>
<li>tab (0x09)</li>
<li>newline (0x0A)</li>
<li>vertical tab (0x0B)</li>
<li>form feed (0x0C)</li>
<li>return (0x0D)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga83e29996414dc34dd0fb76a16669f05f" name="ga83e29996414dc34dd0fb76a16669f05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83e29996414dc34dd0fb76a16669f05f">&#9670;&#160;</a></span>isupper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isupper </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values 'A' through 'Z' as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga73d02f4f146603a906c35d50197f6fd6" name="ga73d02f4f146603a906c35d50197f6fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73d02f4f146603a906c35d50197f6fd6">&#9670;&#160;</a></span>isxdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::isxdigit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only treat ASCII values 'A' through 'F', 'a' through 'f', and '0' through '9', as true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if x falls within the character class, zero otherwise.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gac0d19dc9f116d9f492fd4d17296f0c4b" name="gac0d19dc9f116d9f492fd4d17296f0c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0d19dc9f116d9f492fd4d17296f0c4b">&#9670;&#160;</a></span>itoa()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::itoa </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This requires a radix to specified for string format. Specifying 10 produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2 to 36.</p>
<p>Note that this function will overflow a buffer if <code>str</code> is not large enough to hold the output! It may be safer to use SDL_snprintf to clamp output, or SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate much more space than you expect to use (and don't forget possible negative signs, null terminator bytes, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the integer to convert. </td></tr>
    <tr><td class="paramname">str</td><td>the buffer to write the string into. </td></tr>
    <tr><td class="paramname">radix</td><td>the radix to use for string generation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>str</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_uitoa </dd>
<dd>
SDL_ltoa </dd>
<dd>
SDL_lltoa </dd></dl>

</div>
</div>
<a id="ga01c25ea063ceb75d5caf6ca1119a3bc1" name="ga01c25ea063ceb75d5caf6ca1119a3bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01c25ea063ceb75d5caf6ca1119a3bc1">&#9670;&#160;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::log </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>0 &lt; x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<p>It is an error for <code>x</code> to be less than or equal to 0.</p>
<p>This function operates on double-precision floating point values, use SDL_logf for single-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. Must be greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the natural logarithm of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_logf </dd>
<dd>
SDL_log10 </dd>
<dd>
SDL_exp </dd></dl>

</div>
</div>
<a id="gacdf9d94c27153da5d01b604342b49024" name="gacdf9d94c27153da5d01b604342b49024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdf9d94c27153da5d01b604342b49024">&#9670;&#160;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::log10 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>0 &lt; x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<p>It is an error for <code>x</code> to be less than or equal to 0.</p>
<p>This function operates on double-precision floating point values, use SDL_log10f for single-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. Must be greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the logarithm of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_log10f </dd>
<dd>
SDL_log </dd>
<dd>
SDL_pow </dd></dl>

</div>
</div>
<a id="gaa8d69e4fc64b4c002aeffdf894aaa64f" name="gaa8d69e4fc64b4c002aeffdf894aaa64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8d69e4fc64b4c002aeffdf894aaa64f">&#9670;&#160;</a></span>log10f()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::log10f </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>0 &lt; x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<p>It is an error for <code>x</code> to be less than or equal to 0.</p>
<p>This function operates on single-precision floating point values, use SDL_log10 for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. Must be greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the logarithm of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_log10 </dd>
<dd>
SDL_logf </dd>
<dd>
SDL_powf </dd></dl>

</div>
</div>
<a id="gab3482b1fa8e624f0f7e73ce89c0d5efb" name="gab3482b1fa8e624f0f7e73ce89c0d5efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3482b1fa8e624f0f7e73ce89c0d5efb">&#9670;&#160;</a></span>logf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::logf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>0 &lt; x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<p>It is an error for <code>x</code> to be less than or equal to 0.</p>
<p>This function operates on single-precision floating point values, use SDL_log for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. Must be greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the natural logarithm of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_log </dd>
<dd>
SDL_expf </dd></dl>

</div>
</div>
<a id="ga70024c43f89714b01cc1ff00baa682e0" name="ga70024c43f89714b01cc1ff00baa682e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70024c43f89714b01cc1ff00baa682e0">&#9670;&#160;</a></span>lround()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long SDL::lround </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rounds <code>x</code> to the nearest integer. Values halfway between integers will be rounded away from zero.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>MIN_LONG &lt;= y &lt;= MAX_LONG</code></p>
<p>This function operates on double-precision floating point values, use SDL_lround for single-precision floats. To get the result as a floating-point type, use SDL_round.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nearest integer to <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_lroundf </dd>
<dd>
SDL_round </dd>
<dd>
SDL_floor </dd>
<dd>
SDL_ceil </dd>
<dd>
SDL_trunc </dd></dl>

</div>
</div>
<a id="ga6878a0c3b6b75b7c15851c3dfe3d85df" name="ga6878a0c3b6b75b7c15851c3dfe3d85df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6878a0c3b6b75b7c15851c3dfe3d85df">&#9670;&#160;</a></span>lroundf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long SDL::lroundf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rounds <code>x</code> to the nearest integer. Values halfway between integers will be rounded away from zero.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>MIN_LONG &lt;= y &lt;= MAX_LONG</code></p>
<p>This function operates on single-precision floating point values, use SDL_lroundf for double-precision floats. To get the result as a floating-point type, use SDL_roundf,</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nearest integer to <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_lround </dd>
<dd>
SDL_roundf </dd>
<dd>
SDL_floorf </dd>
<dd>
SDL_ceilf </dd>
<dd>
SDL_truncf </dd></dl>

</div>
</div>
<a id="gaee263ca33e533bf8acdd33b20e2323cf" name="gaee263ca33e533bf8acdd33b20e2323cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee263ca33e533bf8acdd33b20e2323cf">&#9670;&#160;</a></span>ltoa()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::ltoa </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This requires a radix to specified for string format. Specifying 10 produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2 to 36.</p>
<p>Note that this function will overflow a buffer if <code>str</code> is not large enough to hold the output! It may be safer to use SDL_snprintf to clamp output, or SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate much more space than you expect to use (and don't forget possible negative signs, null terminator bytes, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the long integer to convert. </td></tr>
    <tr><td class="paramname">str</td><td>the buffer to write the string into. </td></tr>
    <tr><td class="paramname">radix</td><td>the radix to use for string generation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>str</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_ultoa </dd>
<dd>
SDL_itoa </dd>
<dd>
SDL_lltoa </dd></dl>

</div>
</div>
<a id="ga48fe5521cb77ff8e4ae442bc8387be70" name="ga48fe5521cb77ff8e4ae442bc8387be70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48fe5521cb77ff8e4ae442bc8387be70">&#9670;&#160;</a></span>malloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The allocated memory returned by this function must be freed with SDL_free().</p>
<p>If <code>size</code> is 0, it will be set to 1.</p>
<p>If you want to allocate memory aligned to a specific alignment, consider using SDL_aligned_alloc().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the size to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory, or NULL if allocation failed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_free </dd>
<dd>
SDL_calloc </dd>
<dd>
SDL_realloc </dd>
<dd>
SDL_aligned_alloc </dd></dl>

</div>
</div>
<a id="ga1713911979192a927ee8202ad4ed478b" name="ga1713911979192a927ee8202ad4ed478b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1713911979192a927ee8202ad4ed478b">&#9670;&#160;</a></span>memcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::memcmp </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>the first buffer to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">s2</td><td>the second buffer to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">len</td><td>the number of bytes to compare between the buffers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if s1 is "less than" s2, greater than zero if s1 is "greater than" s2, and zero if the buffers match exactly for <code>len</code> bytes.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gafe27508f0dcd3fb7902725b46f1c7e15" name="gafe27508f0dcd3fb7902725b46f1c7e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe27508f0dcd3fb7902725b46f1c7e15">&#9670;&#160;</a></span>memcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The memory regions must not overlap. If they do, use SDL_memmove() instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination memory region. Must not be NULL, and must not overlap with <code>src</code>. </td></tr>
    <tr><td class="paramname">src</td><td>The source memory region. Must not be NULL, and must not overlap with <code>dst</code>. </td></tr>
    <tr><td class="paramname">len</td><td>The length in bytes of both <code>dst</code> and <code>src</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>dst</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_memmove </dd></dl>

</div>
</div>
<a id="ga166c29b5162d190b0002720452a5ef43" name="ga166c29b5162d190b0002720452a5ef43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga166c29b5162d190b0002720452a5ef43">&#9670;&#160;</a></span>memmove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::memmove </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>It is okay for the memory regions to overlap. If you are confident that the regions never overlap, using SDL_memcpy() may improve performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination memory region. Must not be NULL. </td></tr>
    <tr><td class="paramname">src</td><td>The source memory region. Must not be NULL. </td></tr>
    <tr><td class="paramname">len</td><td>The length in bytes of both <code>dst</code> and <code>src</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>dst</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_memcpy </dd></dl>

</div>
</div>
<a id="ga5a6487beb5a07d1110c8afe1fe030446" name="ga5a6487beb5a07d1110c8afe1fe030446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a6487beb5a07d1110c8afe1fe030446">&#9670;&#160;</a></span>memset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will set <code>len</code> bytes, pointed to by <code>dst</code>, to the value specified in <code>c</code>.</p>
<p>Despite <code>c</code> being an <code>int</code> instead of a <code>char</code>, this only operates on bytes; <code>c</code> must be a value between 0 and 255, inclusive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>the destination memory region. Must not be NULL. </td></tr>
    <tr><td class="paramname">c</td><td>the byte value to set. </td></tr>
    <tr><td class="paramname">len</td><td>the length, in bytes, to set in <code>dst</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>dst</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga8e06e75cea4ef203bf1f3c967f8bff54" name="ga8e06e75cea4ef203bf1f3c967f8bff54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e06e75cea4ef203bf1f3c967f8bff54">&#9670;&#160;</a></span>memset4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::memset4 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dwords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will set a buffer of <code>dwords</code> Uint32 values, pointed to by <code>dst</code>, to the value specified in <code>val</code>.</p>
<p>Unlike SDL_memset, this sets 32-bit values, not bytes, so it's not limited to a range of 0-255.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>the destination memory region. Must not be NULL. </td></tr>
    <tr><td class="paramname">val</td><td>the Uint32 value to set. </td></tr>
    <tr><td class="paramname">dwords</td><td>the number of Uint32 values to set in <code>dst</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>dst</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga4c97858f63954904f2037d7bc81b2681" name="ga4c97858f63954904f2037d7bc81b2681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c97858f63954904f2037d7bc81b2681">&#9670;&#160;</a></span>modf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::modf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function operates on double-precision floating point values, use SDL_modff for single-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
    <tr><td class="paramname">y</td><td>output pointer to store the integer part of <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the fractional part of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_modff </dd>
<dd>
SDL_trunc </dd>
<dd>
SDL_fmod </dd></dl>

</div>
</div>
<a id="ga0108470ee7d88fa093ddf12185060c10" name="ga0108470ee7d88fa093ddf12185060c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0108470ee7d88fa093ddf12185060c10">&#9670;&#160;</a></span>modff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::modff </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function operates on single-precision floating point values, use SDL_modf for double-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
    <tr><td class="paramname">y</td><td>output pointer to store the integer part of <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the fractional part of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_modf </dd>
<dd>
SDL_truncf </dd>
<dd>
SDL_fmodf </dd></dl>

</div>
</div>
<a id="gaa75ce9d0d0b590cd55fce1604bb40824" name="gaa75ce9d0d0b590cd55fce1604bb40824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa75ce9d0d0b590cd55fce1604bb40824">&#9670;&#160;</a></span>murmur3_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 SDL::murmur3_32 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a href="https://en.wikipedia.org/wiki/MurmurHash">https://en.wikipedia.org/wiki/MurmurHash</a></p>
<p>A seed may be specified, which changes the final results consistently, but this does not work like SDL_crc16 and SDL_crc32: you can't feed a previous result from this function back into itself as the next seed value to calculate a hash in chunks; it won't produce the same hash as it would if the same data was provided in a single call.</p>
<p>If you aren't sure what to provide for a seed, zero is fine. Murmur3 is not cryptographically secure, so it shouldn't be used for hashing top-secret data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the data to be hashed. </td></tr>
    <tr><td class="paramname">len</td><td>the size of data, in bytes. </td></tr>
    <tr><td class="paramname">seed</td><td>a value that alters the final hash value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a Murmur3 32-bit hash value.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga6cfca7e593d97a56d7fca043af3ac2ce" name="ga6cfca7e593d97a56d7fca043af3ac2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cfca7e593d97a56d7fca043af3ac2ce">&#9670;&#160;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::pow </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= z &lt;= INF</code></p>
<p>If <code>y</code> is the base of the natural logarithm (e), consider using SDL_exp instead.</p>
<p>This function operates on double-precision floating point values, use SDL_powf for single-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the base. </td></tr>
    <tr><td class="paramname">y</td><td>the exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> raised to the power <code>y</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_powf </dd>
<dd>
SDL_exp </dd>
<dd>
SDL_log </dd></dl>

</div>
</div>
<a id="ga652fc1da140490bb87abbbf05ccfe8fa" name="ga652fc1da140490bb87abbbf05ccfe8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga652fc1da140490bb87abbbf05ccfe8fa">&#9670;&#160;</a></span>powf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::powf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>-INF &lt;= y &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= z &lt;= INF</code></p>
<p>If <code>y</code> is the base of the natural logarithm (e), consider using SDL_exp instead.</p>
<p>This function operates on single-precision floating point values, use SDL_powf for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the base. </td></tr>
    <tr><td class="paramname">y</td><td>the exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> raised to the power <code>y</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_pow </dd>
<dd>
SDL_expf </dd>
<dd>
SDL_logf </dd></dl>

</div>
</div>
<a id="gab52a0ec3d96fb4c04972b1b322f75857" name="gab52a0ec3d96fb4c04972b1b322f75857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab52a0ec3d96fb4c04972b1b322f75857">&#9670;&#160;</a></span>qsort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::qsort </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gabc94be94823c25031d6dd9210ef3e81a">CompareCallback</a>&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For example:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *string;</div>
<div class="line">} data;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> SDLCALL compare(<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> data *A = (<span class="keyword">const</span> data *)a;</div>
<div class="line">    <span class="keyword">const</span> data *B = (<span class="keyword">const</span> data *)b;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (A-&gt;n &lt; B-&gt;n) {</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (B-&gt;n &lt; A-&gt;n) {</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">data values[] = {</div>
<div class="line">    { 3, <span class="stringliteral">&quot;third&quot;</span> }, { 1, <span class="stringliteral">&quot;first&quot;</span> }, { 2, <span class="stringliteral">&quot;second&quot;</span> }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">SDL_qsort(values, SDL_arraysize(values), <span class="keyword">sizeof</span>(values[0]), compare);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>a pointer to the start of the array. </td></tr>
    <tr><td class="paramname">nmemb</td><td>the number of elements in the array. </td></tr>
    <tr><td class="paramname">size</td><td>the size of the elements in the array. </td></tr>
    <tr><td class="paramname">compare</td><td>a function used to compare elements in the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_bsearch </dd>
<dd>
SDL_qsort_r </dd></dl>

</div>
</div>
<a id="gaa3b0083aa5cb6236224048d437834dd2" name="gaa3b0083aa5cb6236224048d437834dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3b0083aa5cb6236224048d437834dd2">&#9670;&#160;</a></span>qsort_r()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::qsort_r </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gab5c634ea2ae9a102fa58cd7beac9f478">CompareCallback_r</a>&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For example:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> <span class="keyword">enum</span> {</div>
<div class="line">      sort_increasing,</div>
<div class="line">      sort_decreasing,</div>
<div class="line">  } sort_method;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">      <span class="keywordtype">int</span> key;</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">char</span> *string;</div>
<div class="line">  } data;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> SDLCALL compare(<span class="keyword">const</span> <span class="keywordtype">void</span> *userdata, <span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)</div>
<div class="line">  {</div>
<div class="line">      sort_method method = (sort_method)(uintptr_t)userdata;</div>
<div class="line">      <span class="keyword">const</span> data *A = (<span class="keyword">const</span> data *)a;</div>
<div class="line">      <span class="keyword">const</span> data *B = (<span class="keyword">const</span> data *)b;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">if</span> (A-&gt;key &lt; B-&gt;key) {</div>
<div class="line">          <span class="keywordflow">return</span> (method == sort_increasing) ? -1 : 1;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (B-&gt;key &lt; A-&gt;key) {</div>
<div class="line">          <span class="keywordflow">return</span> (method == sort_increasing) ? 1 : -1;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keywordflow">return</span> 0;</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  data values[] = {</div>
<div class="line">      { 3, <span class="stringliteral">&quot;third&quot;</span> }, { 1, <span class="stringliteral">&quot;first&quot;</span> }, { 2, <span class="stringliteral">&quot;second&quot;</span> }</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  SDL_qsort_r(values, SDL_arraysize(values), <span class="keyword">sizeof</span>(values[0]), compare, (<span class="keyword">const</span></div>
<div class="line">*<span class="keywordtype">void</span> *)(uintptr_t)sort_increasing);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>a pointer to the start of the array. </td></tr>
    <tr><td class="paramname">nmemb</td><td>the number of elements in the array. </td></tr>
    <tr><td class="paramname">size</td><td>the size of the elements in the array. </td></tr>
    <tr><td class="paramname">compare</td><td>a function used to compare elements in the array. </td></tr>
    <tr><td class="paramname">userdata</td><td>a pointer to pass to the compare function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_bsearch_r </dd>
<dd>
SDL_qsort </dd></dl>

</div>
</div>
<a id="gaa0d119f7b42130eb3a652f7e243c8cf7" name="gaa0d119f7b42130eb3a652f7e243c8cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0d119f7b42130eb3a652f7e243c8cf7">&#9670;&#160;</a></span>rand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sint32 SDL::rand </td>
          <td>(</td>
          <td class="paramtype">Sint32&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The method used is faster and of better quality than <code><a class="el" href="group__CategoryStdinc.html#gaa0d119f7b42130eb3a652f7e243c8cf7" title="Generate a pseudo-random number less than n for positive n.">rand()</a> % n</code>. Odds are roughly 99.9% even for n = 1 million. Evenness is better for smaller n, and much worse as n gets bigger.</p>
<p>Example: to simulate a d6 use <code>rand(6) + 1</code> The +1 converts 0..5 to 1..6</p>
<p>If you want to generate a pseudo-random number in the full range of Sint32, you should use: (Sint32)SDL_rand_bits()</p>
<p>If you want reproducible output, be sure to initialize with <a class="el" href="group__CategoryStdinc.html#ga85fc72ab5435901400efdaebc1187630" title="Seeds the pseudo-random number generator.">srand()</a> first.</p>
<p>There are no guarantees as to the quality of the random sequence produced, and this should not be used for security (cryptography, passwords) or where money is on the line (loot-boxes, casinos). There are many random number libraries available with different characteristics and you should pick one of those to meet any serious needs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of possible outcomes. n must be positive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a random value in the range of [0 .. n-1].</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>All calls should be made from a single thread</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga85fc72ab5435901400efdaebc1187630" title="Seeds the pseudo-random number generator.">srand()</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaab0a933463eebe63f34b3acec7e96c6e" title="Generate a uniform pseudo-random floating point number less than 1.0.">randf()</a> </dd></dl>

</div>
</div>
<a id="gae6517052066ab937273e6a89c7d1eca8" name="gae6517052066ab937273e6a89c7d1eca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6517052066ab937273e6a89c7d1eca8">&#9670;&#160;</a></span>rand_bits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 SDL::rand_bits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You likely want to use <a class="el" href="group__CategoryStdinc.html#gaa0d119f7b42130eb3a652f7e243c8cf7" title="Generate a pseudo-random number less than n for positive n.">rand()</a> to get a pseudo-random number instead.</p>
<p>There are no guarantees as to the quality of the random sequence produced, and this should not be used for security (cryptography, passwords) or where money is on the line (loot-boxes, casinos). There are many random number libraries available with different characteristics and you should pick one of those to meet any serious needs.</p>
<dl class="section return"><dt>Returns</dt><dd>a random value in the range of [0-SDL_MAX_UINT32].</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>All calls should be made from a single thread</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gaa0d119f7b42130eb3a652f7e243c8cf7" title="Generate a pseudo-random number less than n for positive n.">rand()</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaab0a933463eebe63f34b3acec7e96c6e" title="Generate a uniform pseudo-random floating point number less than 1.0.">randf()</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#ga85fc72ab5435901400efdaebc1187630" title="Seeds the pseudo-random number generator.">srand()</a> </dd></dl>

</div>
</div>
<a id="gaab0a933463eebe63f34b3acec7e96c6e" name="gaab0a933463eebe63f34b3acec7e96c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab0a933463eebe63f34b3acec7e96c6e">&#9670;&#160;</a></span>randf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::randf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If you want reproducible output, be sure to initialize with <a class="el" href="group__CategoryStdinc.html#ga85fc72ab5435901400efdaebc1187630" title="Seeds the pseudo-random number generator.">srand()</a> first.</p>
<p>There are no guarantees as to the quality of the random sequence produced, and this should not be used for security (cryptography, passwords) or where money is on the line (loot-boxes, casinos). There are many random number libraries available with different characteristics and you should pick one of those to meet any serious needs.</p>
<dl class="section return"><dt>Returns</dt><dd>a random value in the range of [0.0, 1.0).</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>All calls should be made from a single thread</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#ga85fc72ab5435901400efdaebc1187630" title="Seeds the pseudo-random number generator.">srand()</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaa0d119f7b42130eb3a652f7e243c8cf7" title="Generate a pseudo-random number less than n for positive n.">rand()</a> </dd></dl>

</div>
</div>
<a id="gab8208c1b381e6a96b07b5facff79c27b" name="gab8208c1b381e6a96b07b5facff79c27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8208c1b381e6a96b07b5facff79c27b">&#9670;&#160;</a></span>realloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SDL::realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The memory returned by this function must be freed with SDL_free().</p>
<p>If <code>size</code> is 0, it will be set to 1. Note that this is unlike some other C runtime <code>realloc</code> implementations, which may treat <code>realloc(mem, 0)</code> the same way as <code>free(mem)</code>.</p>
<p>If <code>mem</code> is NULL, the behavior of this function is equivalent to SDL_malloc(). Otherwise, the function can have one of three possible outcomes:</p>
<ul>
<li>If it returns the same pointer as <code>mem</code>, it means that <code>mem</code> was resized in place without freeing.</li>
<li>If it returns a different non-NULL pointer, it means that <code>mem</code> was freed and cannot be dereferenced anymore.</li>
<li>If it returns NULL (indicating failure), then <code>mem</code> will remain valid and must still be freed with SDL_free().</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>a pointer to allocated memory to reallocate, or NULL. </td></tr>
    <tr><td class="paramname">size</td><td>the new size of the memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly allocated memory, or NULL if allocation failed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_free </dd>
<dd>
SDL_malloc </dd>
<dd>
SDL_calloc </dd></dl>

</div>
</div>
<a id="ga58af56b2a9898c045c8ec62ec531c8e5" name="ga58af56b2a9898c045c8ec62ec531c8e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58af56b2a9898c045c8ec62ec531c8e5">&#9670;&#160;</a></span>round()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::round </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rounds <code>x</code> to the nearest integer. Values halfway between integers will be rounded away from zero.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<p>This function operates on double-precision floating point values, use SDL_roundf for single-precision floats. To get the result as an integer type, use SDL_lround.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nearest integer to <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_roundf </dd>
<dd>
SDL_lround </dd>
<dd>
SDL_floor </dd>
<dd>
SDL_ceil </dd>
<dd>
SDL_trunc </dd></dl>

</div>
</div>
<a id="ga9cb3bb70b04800302620c3ebb81e901f" name="ga9cb3bb70b04800302620c3ebb81e901f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cb3bb70b04800302620c3ebb81e901f">&#9670;&#160;</a></span>roundf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::roundf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rounds <code>x</code> to the nearest integer. Values halfway between integers will be rounded away from zero.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<p>This function operates on double-precision floating point values, use SDL_roundf for single-precision floats. To get the result as an integer type, use SDL_lroundf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nearest integer to <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_round </dd>
<dd>
SDL_lroundf </dd>
<dd>
SDL_floorf </dd>
<dd>
SDL_ceilf </dd>
<dd>
SDL_truncf </dd></dl>

</div>
</div>
<a id="ga2438009a4b8a2f4a9155a168f6cd8303" name="ga2438009a4b8a2f4a9155a168f6cd8303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2438009a4b8a2f4a9155a168f6cd8303">&#9670;&#160;</a></span>scalbn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::scalbn </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies <code>x</code> by the <code>n</code>th power of the floating point radix (always 2).</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>n</code> integer</p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<p>This function operates on double-precision floating point values, use SDL_scalbnf for single-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value to be scaled. </td></tr>
    <tr><td class="paramname">n</td><td>integer exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x * 2^n</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_scalbnf </dd>
<dd>
SDL_pow </dd></dl>

</div>
</div>
<a id="ga52e712f14d91d7ecf74bd687a5458a6d" name="ga52e712f14d91d7ecf74bd687a5458a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52e712f14d91d7ecf74bd687a5458a6d">&#9670;&#160;</a></span>scalbnf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::scalbnf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies <code>x</code> by the <code>n</code>th power of the floating point radix (always 2).</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code>, <code>n</code> integer</p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<p>This function operates on single-precision floating point values, use SDL_scalbn for double-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value to be scaled. </td></tr>
    <tr><td class="paramname">n</td><td>integer exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x * 2^n</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_scalbn </dd>
<dd>
SDL_powf </dd></dl>

</div>
</div>
<a id="ga97da5abe6c940c70b73fc9465cf8e75e" name="ga97da5abe6c940c70b73fc9465cf8e75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97da5abe6c940c70b73fc9465cf8e75e">&#9670;&#160;</a></span>setenv_unsafe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::setenv_unsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>overwrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the variable to set. </td></tr>
    <tr><td class="paramname">value</td><td>the value of the variable to set. </td></tr>
    <tr><td class="paramname">overwrite</td><td>1 to overwrite the variable if it exists, 0 to return success without setting the variable if it already exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe, consider using SDL_SetEnvironmentVariable() instead.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_SetEnvironmentVariable </dd></dl>

</div>
</div>
<a id="ga953e2e3777cf98a58ebbf96ee66bdddb" name="ga953e2e3777cf98a58ebbf96ee66bdddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga953e2e3777cf98a58ebbf96ee66bdddb">&#9670;&#160;</a></span>SetMemoryFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::SetMemoryFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga20e849be3a477a832c3f5b49aa71f793">malloc_func</a>&#160;</td>
          <td class="paramname"><em>malloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga4f2714c0d9540b5e1e85ed5503c59215">calloc_func</a>&#160;</td>
          <td class="paramname"><em>calloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#gaa0d42a4ebfbbe5ab7908f55ba0560ecb">realloc_func</a>&#160;</td>
          <td class="paramname"><em>realloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CategoryStdinc.html#ga80cbbb5b121c8f78d44a66deaa573127">free_func</a>&#160;</td>
          <td class="paramname"><em>free_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>It is not safe to call this function once any allocations have been made, as future calls to SDL_free will use the new allocator, even if they came from an SDL_malloc made with the old one!</p>
<p>If used, usually this needs to be the first call made into the <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> library, if not the very first thing done at program startup time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">malloc_func</td><td>custom malloc function. </td></tr>
    <tr><td class="paramname">calloc_func</td><td>custom calloc function. </td></tr>
    <tr><td class="paramname">realloc_func</td><td>custom realloc function. </td></tr>
    <tr><td class="paramname">free_func</td><td>custom free function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure; call SDL_GetError() for more information.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread, but one should not replace the memory functions once any allocations are made!</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_GetMemoryFunctions </dd>
<dd>
SDL_GetOriginalMemoryFunctions </dd></dl>

</div>
</div>
<a id="ga88bf16c79b920ce54e0ae909b2948663" name="ga88bf16c79b920ce54e0ae909b2948663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88bf16c79b920ce54e0ae909b2948663">&#9670;&#160;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::sin </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-1 &lt;= y &lt;= 1</code></p>
<p>This function operates on double-precision floating point values, use SDL_sinf for single-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value, in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sine of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_sinf </dd>
<dd>
SDL_asin </dd>
<dd>
SDL_cos </dd></dl>

</div>
</div>
<a id="gab41ffcc72f47ca7757cdaa4a0844dd7c" name="gab41ffcc72f47ca7757cdaa4a0844dd7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab41ffcc72f47ca7757cdaa4a0844dd7c">&#9670;&#160;</a></span>sinf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::sinf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-1 &lt;= y &lt;= 1</code></p>
<p>This function operates on single-precision floating point values, use SDL_sin for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value, in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sine of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_sin </dd>
<dd>
SDL_asinf </dd>
<dd>
SDL_cosf </dd></dl>

</div>
</div>
<a id="ga6a8cffac163d32a70c2a38ed43b8aed6" name="ga6a8cffac163d32a70c2a38ed43b8aed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a8cffac163d32a70c2a38ed43b8aed6">&#9670;&#160;</a></span>size_add_check_overflow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::size_add_check_overflow </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If <code>a + b</code> would overflow, return false.</p>
<p>Otherwise store <code>a + b</code> via ret and return true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first addend. </td></tr>
    <tr><td class="paramname">b</td><td>the second addend. </td></tr>
    <tr><td class="paramname">ret</td><td>on non-overflow output, stores the addition result, may not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false on overflow, true if result is added without overflow.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga5eff841be311c6243e4c36bc358e017f" name="ga5eff841be311c6243e4c36bc358e017f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5eff841be311c6243e4c36bc358e017f">&#9670;&#160;</a></span>size_mul_check_overflow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SDL::size_mul_check_overflow </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If <code>a * b</code> would overflow, return false.</p>
<p>Otherwise store <code>a * b</code> via ret and return true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the multiplicand. </td></tr>
    <tr><td class="paramname">b</td><td>the multiplier. </td></tr>
    <tr><td class="paramname">ret</td><td>on non-overflow output, stores the multiplication result, may not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false on overflow, true if result is multiplied without overflow.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga57b48f04ae9e3949774b9f0c9dc0c151" name="ga57b48f04ae9e3949774b9f0c9dc0c151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57b48f04ae9e3949774b9f0c9dc0c151">&#9670;&#160;</a></span>snprintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::snprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_PRINTF_FORMAT_STRING const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Format a string of up to <code>maxlen</code>-1 bytes, converting each '' item with values provided through variable arguments.</p>
<p>While some C runtimes differ on how to deal with too-large strings, this function null-terminates the output, by treating the null-terminator as part of the <code>maxlen</code> count. Note that if <code>maxlen</code> is zero, however, no bytes will be written at all.</p>
<p>This function returns the number of <em>bytes</em> (not <em>characters</em>) that should be written, excluding the null-terminator character. If this returns a number &gt;= <code>maxlen</code>, it means the output string was truncated. A negative return value means an error occurred.</p>
<p>Referencing the output string's pointer with a format item is undefined behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>the buffer to write the string into. Must not be NULL. </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum bytes to write, including the null-terminator. </td></tr>
    <tr><td class="paramname">fmt</td><td>a printf-style format string. Must not be NULL. </td></tr>
    <tr><td class="paramname">...</td><td>a list of values to be used with the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that should be written, not counting the null-terminator char, or a negative value on error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga8415b71ce1045874d7b55210806ff3c8" name="ga8415b71ce1045874d7b55210806ff3c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8415b71ce1045874d7b55210806ff3c8">&#9670;&#160;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::sqrt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>0 &lt;= x &lt;= INF</code></p>
<p>Range: <code>0 &lt;= y &lt;= INF</code></p>
<p>This function operates on double-precision floating point values, use SDL_sqrtf for single-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. Must be greater than or equal to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>square root of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_sqrtf </dd></dl>

</div>
</div>
<a id="gaf7c7e59d49d88aa05125fd347beeed63" name="gaf7c7e59d49d88aa05125fd347beeed63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7c7e59d49d88aa05125fd347beeed63">&#9670;&#160;</a></span>sqrtf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::sqrtf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>0 &lt;= x &lt;= INF</code></p>
<p>Range: <code>0 &lt;= y &lt;= INF</code></p>
<p>This function operates on single-precision floating point values, use SDL_sqrt for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. Must be greater than or equal to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>square root of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_sqrt </dd></dl>

</div>
</div>
<a id="ga85fc72ab5435901400efdaebc1187630" name="ga85fc72ab5435901400efdaebc1187630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85fc72ab5435901400efdaebc1187630">&#9670;&#160;</a></span>srand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::srand </td>
          <td>(</td>
          <td class="paramtype">Uint64&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reusing the seed number will cause rand_*() to repeat the same stream of 'random' numbers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>the value to use as a random number seed, or 0 to use SDL_GetPerformanceCounter().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This should be called on the same thread that calls rand*()</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryStdinc.html#gaa0d119f7b42130eb3a652f7e243c8cf7" title="Generate a pseudo-random number less than n for positive n.">rand()</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gae6517052066ab937273e6a89c7d1eca8" title="Generate 32 pseudo-random bits.">rand_bits()</a> </dd>
<dd>
<a class="el" href="group__CategoryStdinc.html#gaab0a933463eebe63f34b3acec7e96c6e" title="Generate a uniform pseudo-random floating point number less than 1.0.">randf()</a> </dd></dl>

</div>
</div>
<a id="ga592054168270da087e8630cac0df2530" name="ga592054168270da087e8630cac0df2530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga592054168270da087e8630cac0df2530">&#9670;&#160;</a></span>sscanf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::sscanf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_SCANF_FORMAT_STRING const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scan a string, matching a format string, converting each '' item and storing it to pointers provided through variable arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>the string to scan. Must not be NULL. </td></tr>
    <tr><td class="paramname">fmt</td><td>a printf-style format string. Must not be NULL. </td></tr>
    <tr><td class="paramname">...</td><td>a list of pointers to values to be filled in with scanned items. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of items that matched the format string.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaaa1607ee6b5fddfb7d22eb518dbe59a4" name="gaaa1607ee6b5fddfb7d22eb518dbe59a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa1607ee6b5fddfb7d22eb518dbe59a4">&#9670;&#160;</a></span>StepBackUTF8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 SDL::StepBackUTF8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>pstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will go to the start of the previous Unicode codepoint in the string, move <code>*pstr</code> to that location and return that codepoint.</p>
<p>If <code>*pstr</code> is already at the start of the string), it will not advance <code>*pstr</code> at all.</p>
<p>Generally this function is called in a loop until it returns zero, adjusting its parameter each iteration.</p>
<p>If an invalid UTF-8 sequence is encountered, this function returns SDL_INVALID_UNICODE_CODEPOINT.</p>
<p>Several things can generate invalid UTF-8 sequences, including overlong encodings, the use of UTF-16 surrogate values, and truncated data. Please refer to <a href="https://www.ietf.org/rfc/rfc3629.txt">RFC3629</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>a pointer to the beginning of the UTF-8 string. </td></tr>
    <tr><td class="paramname">pstr</td><td>a pointer to a UTF-8 string pointer to be read and adjusted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous Unicode codepoint in the string.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaa5ecf11cf256372f67e10fafdd79141e" name="gaa5ecf11cf256372f67e10fafdd79141e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5ecf11cf256372f67e10fafdd79141e">&#9670;&#160;</a></span>StepUTF8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 SDL::StepUTF8 </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>pstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pslen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will return the first Unicode codepoint in the UTF-8 encoded string in <code>*pstr</code>, and then advance <code>*pstr</code> past any consumed bytes before returning.</p>
<p>It will not access more than <code>*pslen</code> bytes from the string. <code>*pslen</code> will be adjusted, as well, subtracting the number of bytes consumed.</p>
<p><code>pslen</code> is allowed to be NULL, in which case the string <em>must</em> be NULL-terminated, as the function will blindly read until it sees the NULL char.</p>
<p>if <code>*pslen</code> is zero, it assumes the end of string is reached and returns a zero codepoint regardless of the contents of the string buffer.</p>
<p>If the resulting codepoint is zero (a NULL terminator), or <code>*pslen</code> is zero, it will not advance <code>*pstr</code> or <code>*pslen</code> at all.</p>
<p>Generally this function is called in a loop until it returns zero, adjusting its parameters each iteration.</p>
<p>If an invalid UTF-8 sequence is encountered, this function returns SDL_INVALID_UNICODE_CODEPOINT and advances the string/length by one byte (which is to say, a multibyte sequence might produce several SDL_INVALID_UNICODE_CODEPOINT returns before it syncs to the next valid UTF-8 sequence).</p>
<p>Several things can generate invalid UTF-8 sequences, including overlong encodings, the use of UTF-16 surrogate values, and truncated data. Please refer to <a href="https://www.ietf.org/rfc/rfc3629.txt">RFC3629</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pstr</td><td>a pointer to a UTF-8 string pointer to be read and adjusted. </td></tr>
    <tr><td class="paramname">pslen</td><td>a pointer to the number of bytes in the string, to be read and adjusted. NULL is allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first Unicode codepoint in the string.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga932cf2487365b3a3a6fd6e37a7eddff7" name="ga932cf2487365b3a3a6fd6e37a7eddff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga932cf2487365b3a3a6fd6e37a7eddff7">&#9670;&#160;</a></span>strcasecmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::strcasecmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will work with Unicode strings, using a technique called "case-folding" to handle the vast majority of case-sensitive human languages regardless of system locale. It can deal with expanding values: a German Eszett character can compare against two ASCII 's' chars and be considered a match, for example. A notable exception: it does not handle the Turkish 'i' character; human language is complicated!</p>
<p>Since this handles Unicode, it expects the string to be well-formed UTF-8 and not a null-terminated string of arbitrary bytes. Bytes that are not valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT CHARACTER), which is to say two strings of random bits may turn out to match if they convert to the same amount of replacement characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. NULL is not permitted! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga0d413500b6dc7d885777ecb0873c823e" name="ga0d413500b6dc7d885777ecb0873c823e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d413500b6dc7d885777ecb0873c823e">&#9670;&#160;</a></span>strcasestr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strcasestr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will work with Unicode strings, using a technique called "case-folding" to handle the vast majority of case-sensitive human languages regardless of system locale. It can deal with expanding values: a German Eszett character can compare against two ASCII 's' chars and be considered a match, for example. A notable exception: it does not handle the Turkish 'i' character; human language is complicated!</p>
<p>Since this handles Unicode, it expects the strings to be well-formed UTF-8 and not a null-terminated string of arbitrary bytes. Bytes that are not valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT CHARACTER), which is to say two strings of random bits may turn out to match if they convert to the same amount of replacement characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>the string to search. Must not be NULL. </td></tr>
    <tr><td class="paramname">needle</td><td>the string to search for. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first instance of <code>needle</code> in the string, or NULL if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga451b842c63a514775080900ae67150da" name="ga451b842c63a514775080900ae67150da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga451b842c63a514775080900ae67150da">&#9670;&#160;</a></span>strchr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The search ends once it finds the requested byte value, or a null terminator byte to end the string.</p>
<p>Note that this looks for <em>bytes</em>, not <em>characters</em>, so you cannot match against a Unicode codepoint &gt; 255, regardless of character encoding.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to search. Must not be NULL. </td></tr>
    <tr><td class="paramname">c</td><td>the byte value to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first instance of <code>c</code> in the string, or NULL if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga63d50d9f0b71b04e9b038f0bc71e54c3" name="ga63d50d9f0b71b04e9b038f0bc71e54c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63d50d9f0b71b04e9b038f0bc71e54c3">&#9670;&#160;</a></span>strcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::strcmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Due to the nature of UTF-8 encoding, this will work with Unicode strings, since effectively this function just compares bytes until it hits a null-terminating character. Also due to the nature of UTF-8, this can be used with SDL_qsort() to put strings in (roughly) alphabetical order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. NULL is not permitted! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga046b80783770b59a2cf8b4311230fbbd" name="ga046b80783770b59a2cf8b4311230fbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga046b80783770b59a2cf8b4311230fbbd">&#9670;&#160;</a></span>strdup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strdup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This allocates enough space for a null-terminated copy of <code>str</code>, using SDL_malloc, and then makes a copy of the string into this space.</p>
<p>The returned string is owned by the caller, and should be passed to SDL_free when no longer needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly-allocated string.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga503a37a91faa4ed9374b9dd9db03049c" name="ga503a37a91faa4ed9374b9dd9db03049c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga503a37a91faa4ed9374b9dd9db03049c">&#9670;&#160;</a></span>strlcat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::strlcat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function appends up to <code>maxlen</code> - SDL_strlen(dst) - 1 characters from <code>src</code> to the end of the string in <code>dst</code>, then appends a null terminator.</p>
<p><code>src</code> and <code>dst</code> must not overlap.</p>
<p>If <code>maxlen</code> - SDL_strlen(dst) - 1 is less than or equal to 0, then <code>dst</code> is unmodified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination buffer already containing the first null-terminated string. Must not be NULL and must not overlap with <code>src</code>. </td></tr>
    <tr><td class="paramname">src</td><td>The second null-terminated string. Must not be NULL, and must not overlap with <code>dst</code>. </td></tr>
    <tr><td class="paramname">maxlen</td><td>The length (in characters) of the destination buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in characters, excluding the null terminator) of the string in <code>dst</code> plus the length of <code>src</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_strlcpy </dd></dl>

</div>
</div>
<a id="ga598ecc44c77a20ab4de3a96eda46ea76" name="ga598ecc44c77a20ab4de3a96eda46ea76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga598ecc44c77a20ab4de3a96eda46ea76">&#9670;&#160;</a></span>strlcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::strlcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function copies up to <code>maxlen</code> - 1 characters from <code>src</code> to <code>dst</code>, then appends a null terminator.</p>
<p>If <code>maxlen</code> is 0, no characters are copied and no null terminator is written.</p>
<p>If you want to copy an UTF-8 string but need to ensure that multi-byte sequences are not truncated, consider using SDL_utf8strlcpy().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination buffer. Must not be NULL, and must not overlap with <code>src</code>. </td></tr>
    <tr><td class="paramname">src</td><td>The null-terminated string to copy. Must not be NULL, and must not overlap with <code>dst</code>. </td></tr>
    <tr><td class="paramname">maxlen</td><td>The length (in characters) of the destination buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in characters, excluding the null terminator) of <code>src</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_strlcat </dd>
<dd>
SDL_utf8strlcpy </dd></dl>

</div>
</div>
<a id="ga93de03cd7e1369ba80c5746761bac939" name="ga93de03cd7e1369ba80c5746761bac939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93de03cd7e1369ba80c5746761bac939">&#9670;&#160;</a></span>strlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::strlen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts the bytes in <code>str</code>, excluding the null terminator.</p>
<p>If you need the length of a UTF-8 string, consider using SDL_utf8strlen().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to read. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in bytes, excluding the null terminator) of <code>src</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_strnlen </dd>
<dd>
SDL_utf8strlen </dd>
<dd>
SDL_utf8strnlen </dd></dl>

</div>
</div>
<a id="ga15eaa2ac05317f734e1f022cfc916201" name="ga15eaa2ac05317f734e1f022cfc916201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15eaa2ac05317f734e1f022cfc916201">&#9670;&#160;</a></span>strlwr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strlwr </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only convert ASCII values 'A' through 'Z' to lowercase.</p>
<p>This function operates on a null-terminated string of bytes&ndash;even if it is malformed UTF-8!&ndash;and converts ASCII characters 'A' through 'Z' to their lowercase equivalents in-place, returning the original <code>str</code> pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert in-place. Can not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <code>str</code> pointer passed into this function.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_strupr </dd></dl>

</div>
</div>
<a id="ga37191be89f79920285c912c0544150e8" name="ga37191be89f79920285c912c0544150e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37191be89f79920285c912c0544150e8">&#9670;&#160;</a></span>strncasecmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::strncasecmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will work with Unicode strings, using a technique called "case-folding" to handle the vast majority of case-sensitive human languages regardless of system locale. It can deal with expanding values: a German Eszett character can compare against two ASCII 's' chars and be considered a match, for example. A notable exception: it does not handle the Turkish 'i' character; human language is complicated!</p>
<p>Since this handles Unicode, it expects the string to be well-formed UTF-8 and not a null-terminated string of arbitrary bytes. Bytes that are not valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT CHARACTER), which is to say two strings of random bits may turn out to match if they convert to the same amount of replacement characters.</p>
<p>Note that while this function is intended to be used with UTF-8, <code>maxlen</code> specifies a <em>byte</em> limit! If the limit lands in the middle of a multi-byte UTF-8 sequence, it may convert a portion of the final character to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not to overflow a buffer.</p>
<p><code>maxlen</code> specifies a maximum number of bytes to compare; if the strings match to this number of bytes (or both have matched to a null-terminator character before this number of bytes), they will be considered equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum number of bytes to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga2caad6bed5796e9524d07c21d4701af9" name="ga2caad6bed5796e9524d07c21d4701af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2caad6bed5796e9524d07c21d4701af9">&#9670;&#160;</a></span>strncmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::strncmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Due to the nature of UTF-8 encoding, this will work with Unicode strings, since effectively this function just compares bytes until it hits a null-terminating character. Also due to the nature of UTF-8, this can be used with SDL_qsort() to put strings in (roughly) alphabetical order.</p>
<p>Note that while this function is intended to be used with UTF-8, it is doing a bytewise comparison, and <code>maxlen</code> specifies a <em>byte</em> limit! If the limit lands in the middle of a multi-byte UTF-8 sequence, it will only compare a portion of the final character.</p>
<p><code>maxlen</code> specifies a maximum number of bytes to compare; if the strings match to this number of bytes (or both have matched to a null-terminator character before this number of bytes), they will be considered equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum number of <em>bytes</em> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga53e0a0ce55852f1320bc292f72dc1398" name="ga53e0a0ce55852f1320bc292f72dc1398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53e0a0ce55852f1320bc292f72dc1398">&#9670;&#160;</a></span>strndup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strndup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This allocates enough space for a null-terminated copy of <code>str</code>, up to <code>maxlen</code> bytes, using SDL_malloc, and then makes a copy of the string into this space.</p>
<p>If the string is longer than <code>maxlen</code> bytes, the returned string will be <code>maxlen</code> bytes long, plus a null-terminator character that isn't included in the count.</p>
<p>The returned string is owned by the caller, and should be passed to SDL_free when no longer needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to copy. </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum length of the copied string, not counting the null-terminator character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly-allocated string.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga929593393da0025b602c5b4560bce5bf" name="ga929593393da0025b602c5b4560bce5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga929593393da0025b602c5b4560bce5bf">&#9670;&#160;</a></span>strnlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::strnlen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts up to a maximum of <code>maxlen</code> bytes in <code>str</code>, excluding the null terminator.</p>
<p>If you need the length of a UTF-8 string, consider using SDL_utf8strnlen().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to read. Must not be NULL. </td></tr>
    <tr><td class="paramname">maxlen</td><td>The maximum amount of bytes to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in bytes, excluding the null terminator) of <code>src</code> but never more than <code>maxlen</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_strlen </dd>
<dd>
SDL_utf8strlen </dd>
<dd>
SDL_utf8strnlen </dd></dl>

</div>
</div>
<a id="ga21c1bce04f407d4dab36722078978a9b" name="ga21c1bce04f407d4dab36722078978a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21c1bce04f407d4dab36722078978a9b">&#9670;&#160;</a></span>strnstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strnstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The search ends once it finds the requested substring, or a null terminator byte to end the string, or <code>maxlen</code> bytes have been examined. It is possible to use this function on a string without a null terminator.</p>
<p>Note that this looks for strings of <em>bytes</em>, not <em>characters</em>, so it's legal to search for malformed and incomplete UTF-8 sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>the string to search. Must not be NULL. </td></tr>
    <tr><td class="paramname">needle</td><td>the string to search for. Must not be NULL. </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum number of bytes to search in <code>haystack</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first instance of <code>needle</code> in the string, or NULL if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gae3838c531e1c9bbee29cdf5f4ccb60b4" name="gae3838c531e1c9bbee29cdf5f4ccb60b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3838c531e1c9bbee29cdf5f4ccb60b4">&#9670;&#160;</a></span>strpbrk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strpbrk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>breakset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to be searched. Must not be NULL, and must not overlap with <code>breakset</code>. </td></tr>
    <tr><td class="paramname">breakset</td><td>A null-terminated string containing the list of characters to look for. Must not be NULL, and must not overlap with <code>str</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the location, in str, of the first occurence of a character present in the breakset, or NULL if none is found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaf67863ed8e432e74c417116a532ef24b" name="gaf67863ed8e432e74c417116a532ef24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf67863ed8e432e74c417116a532ef24b">&#9670;&#160;</a></span>strrchr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strrchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The search must go until it finds a null terminator byte to end the string.</p>
<p>Note that this looks for <em>bytes</em>, not <em>characters</em>, so you cannot match against a Unicode codepoint &gt; 255, regardless of character encoding.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to search. Must not be NULL. </td></tr>
    <tr><td class="paramname">c</td><td>the byte value to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the last instance of <code>c</code> in the string, or NULL if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga32b6d922e9310ca993a82b84e692e8a5" name="ga32b6d922e9310ca993a82b84e692e8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32b6d922e9310ca993a82b84e692e8a5">&#9670;&#160;</a></span>strrev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strrev </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This reverses a null-terminated string in-place. Only the content of the string is reversed; the null-terminator character remains at the end of the reversed string.</p>
<p><b>WARNING</b>: This function reverses the <em>bytes</em> of the string, not the codepoints. If <code>str</code> is a UTF-8 string with Unicode codepoints &gt; 127, this will ruin the string data. You should only use this function on strings that are completely comprised of low ASCII characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to reverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>str</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga3ef7c9322f6766ee71172d34493ee792" name="ga3ef7c9322f6766ee71172d34493ee792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ef7c9322f6766ee71172d34493ee792">&#9670;&#160;</a></span>strstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The search ends once it finds the requested substring, or a null terminator byte to end the string.</p>
<p>Note that this looks for strings of <em>bytes</em>, not <em>characters</em>, so it's legal to search for malformed and incomplete UTF-8 sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>the string to search. Must not be NULL. </td></tr>
    <tr><td class="paramname">needle</td><td>the string to search for. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first instance of <code>needle</code> in the string, or NULL if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga062de74e1950744ad5556cc815c58036" name="ga062de74e1950744ad5556cc815c58036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga062de74e1950744ad5556cc815c58036">&#9670;&#160;</a></span>strtod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::strtod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function makes fewer guarantees than the C runtime <code>strtod</code>:</p>
<ul>
<li>Only decimal notation is guaranteed to be supported. The handling of scientific and hexadecimal notation is unspecified.</li>
<li>Whether or not INF and NAN can be parsed is unspecified.</li>
<li>The precision of the result is unspecified.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the null-terminated string to read. Must not be NULL. </td></tr>
    <tr><td class="paramname">endp</td><td>if not NULL, the address of the first invalid character (i.e. the next character after the parsed number) will be written to this pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed <code>double</code>, or 0 if no number could be parsed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_atoi </dd>
<dd>
SDL_atof </dd>
<dd>
SDL_strtol </dd>
<dd>
SDL_strtoll </dd>
<dd>
SDL_strtoul </dd>
<dd>
SDL_strtoull </dd></dl>

</div>
</div>
<a id="ga8dc2ad6fd692f32f1304e9b1872881a2" name="ga8dc2ad6fd692f32f1304e9b1872881a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dc2ad6fd692f32f1304e9b1872881a2">&#9670;&#160;</a></span>strtok_r()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strtok_r </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>saveptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Break a string up into a series of tokens.</p>
<p>To start tokenizing a new string, <code>str</code> should be the non-NULL address of the string to start tokenizing. Future calls to get the next token from the same string should specify a NULL.</p>
<p>Note that this function will overwrite pieces of <code>str</code> with null chars to split it into tokens. This function cannot be used with const/read-only strings!</p>
<p><code>saveptr</code> just needs to point to a <code>char *</code> that can be overwritten; <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> will use this to save tokenizing state between calls. It is initialized if <code>str</code> is non-NULL, and used to resume tokenizing when <code>str</code> is NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to tokenize, or NULL to continue tokenizing. </td></tr>
    <tr><td class="paramname">delim</td><td>the delimiter string that separates tokens. </td></tr>
    <tr><td class="paramname">saveptr</td><td>pointer to a char *, used for ongoing state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the next token, or NULL if no tokens remain.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaf270570877b7a6ccaea59ba90b428043" name="gaf270570877b7a6ccaea59ba90b428043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf270570877b7a6ccaea59ba90b428043">&#9670;&#160;</a></span>strtol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long SDL::strtol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If <code>str</code> starts with whitespace, then those whitespace characters are skipped before attempting to parse the number.</p>
<p>If the parsed number does not fit inside a <code>long</code>, the result is clamped to the minimum and maximum representable <code>long</code> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to read. Must not be NULL. </td></tr>
    <tr><td class="paramname">endp</td><td>If not NULL, the address of the first invalid character (i.e. the next character after the parsed number) will be written to this pointer. </td></tr>
    <tr><td class="paramname">base</td><td>The base of the integer to read. Supported values are 0 and 2 to 36 inclusive. If 0, the base will be inferred from the number's prefix (0x for hexadecimal, 0 for octal, decimal otherwise). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed <code>long</code>, or 0 if no number could be parsed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_atoi </dd>
<dd>
SDL_atof </dd>
<dd>
SDL_strtoul </dd>
<dd>
SDL_strtoll </dd>
<dd>
SDL_strtoull </dd>
<dd>
SDL_strtod </dd>
<dd>
SDL_ltoa </dd>
<dd>
SDL_wcstol </dd></dl>

</div>
</div>
<a id="ga3869ab21242a2a6fb41be41b382d2af2" name="ga3869ab21242a2a6fb41be41b382d2af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3869ab21242a2a6fb41be41b382d2af2">&#9670;&#160;</a></span>strtoul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long SDL::strtoul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If <code>str</code> starts with whitespace, then those whitespace characters are skipped before attempting to parse the number.</p>
<p>If the parsed number does not fit inside an <code>unsigned long</code>, the result is clamped to the maximum representable <code>unsigned long</code> value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated string to read. Must not be NULL. </td></tr>
    <tr><td class="paramname">endp</td><td>If not NULL, the address of the first invalid character (i.e. the next character after the parsed number) will be written to this pointer. </td></tr>
    <tr><td class="paramname">base</td><td>The base of the integer to read. Supported values are 0 and 2 to 36 inclusive. If 0, the base will be inferred from the number's prefix (0x for hexadecimal, 0 for octal, decimal otherwise). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed <code>unsigned long</code>, or 0 if no number could be parsed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_atoi </dd>
<dd>
SDL_atof </dd>
<dd>
SDL_strtol </dd>
<dd>
SDL_strtoll </dd>
<dd>
SDL_strtoull </dd>
<dd>
SDL_strtod </dd>
<dd>
SDL_ultoa </dd></dl>

</div>
</div>
<a id="ga7fe290f18ce6025c454f0b62729c0662" name="ga7fe290f18ce6025c454f0b62729c0662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fe290f18ce6025c454f0b62729c0662">&#9670;&#160;</a></span>strupr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::strupr </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only convert ASCII values 'A' through 'Z' to uppercase.</p>
<p>This function operates on a null-terminated string of bytes&ndash;even if it is malformed UTF-8!&ndash;and converts ASCII characters 'a' through 'z' to their uppercase equivalents in-place, returning the original <code>str</code> pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert in-place. Can not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <code>str</code> pointer passed into this function.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_strlwr </dd></dl>

</div>
</div>
<a id="ga90fbec4327cabf79747426483a3f24cd" name="ga90fbec4327cabf79747426483a3f24cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90fbec4327cabf79747426483a3f24cd">&#9670;&#160;</a></span>swprintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::swprintf </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_PRINTF_FORMAT_STRING const wchar_t *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Format a wide string of up to <code>maxlen</code>-1 wchar_t values, converting each '' item with values provided through variable arguments.</p>
<p>While some C runtimes differ on how to deal with too-large strings, this function null-terminates the output, by treating the null-terminator as part of the <code>maxlen</code> count. Note that if <code>maxlen</code> is zero, however, no wide characters will be written at all.</p>
<p>This function returns the number of <em>wide characters</em> (not <em>codepoints</em>) that should be written, excluding the null-terminator character. If this returns a number &gt;= <code>maxlen</code>, it means the output string was truncated. A negative return value means an error occurred.</p>
<p>Referencing the output string's pointer with a format item is undefined behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>the buffer to write the wide string into. Must not be NULL. </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum wchar_t values to write, including the null-terminator. </td></tr>
    <tr><td class="paramname">fmt</td><td>a printf-style format string. Must not be NULL. </td></tr>
    <tr><td class="paramname">...</td><td>a list of values to be used with the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of wide characters that should be written, not counting the null-terminator char, or a negative value on error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga88b5a6adb928a623a97598a7a154432c" name="ga88b5a6adb928a623a97598a7a154432c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88b5a6adb928a623a97598a7a154432c">&#9670;&#160;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::tan </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<p>This function operates on double-precision floating point values, use SDL_tanf for single-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value, in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tangent of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_tanf </dd>
<dd>
SDL_sin </dd>
<dd>
SDL_cos </dd>
<dd>
SDL_atan </dd>
<dd>
SDL_atan2 </dd></dl>

</div>
</div>
<a id="gaf14c09ac379c8fa038a9fab209b9d4d7" name="gaf14c09ac379c8fa038a9fab209b9d4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf14c09ac379c8fa038a9fab209b9d4d7">&#9670;&#160;</a></span>tanf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::tanf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code></p>
<p>This function operates on single-precision floating point values, use SDL_tanf for double-precision floats.</p>
<p>This function may use a different approximation across different versions, platforms and configurations. i.e, it can return a different value given the same input on different machines or operating systems, or if <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value, in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tangent of <code>x</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_tan </dd>
<dd>
SDL_sinf </dd>
<dd>
SDL_cosf </dd>
<dd>
SDL_atanf </dd>
<dd>
SDL_atan2f </dd></dl>

</div>
</div>
<a id="ga77f89764775d85be34bed2bc447d543a" name="ga77f89764775d85be34bed2bc447d543a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77f89764775d85be34bed2bc447d543a">&#9670;&#160;</a></span>tolower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::tolower </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only convert ASCII values 'A' through 'Z' to lowercase.</p>
<p>This function returns the lowercase equivalent of <code>x</code>. If a character cannot be converted, or is already lowercase, this function returns <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lowercase version of x, or x if no conversion available.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaa66528bfccd7f5a86ed7554d049d1930" name="gaa66528bfccd7f5a86ed7554d049d1930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa66528bfccd7f5a86ed7554d049d1930">&#9670;&#160;</a></span>toupper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::toupper </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>WARNING</b>: Regardless of system locale, this will only convert ASCII values 'a' through 'z' to uppercase.</p>
<p>This function returns the uppercase equivalent of <code>x</code>. If a character cannot be converted, or is already uppercase, this function returns <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>character value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>capitalized version of x, or x if no conversion available.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaeb64b2b465e001720dce40bacec1b937" name="gaeb64b2b465e001720dce40bacec1b937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb64b2b465e001720dce40bacec1b937">&#9670;&#160;</a></span>trunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SDL::trunc </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rounds <code>x</code> to the next closest integer to 0. This is equivalent to removing the fractional part of <code>x</code>, leaving only the integer part.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<p>This function operates on double-precision floating point values, use SDL_truncf for single-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> truncated to an integer.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_truncf </dd>
<dd>
SDL_fmod </dd>
<dd>
SDL_ceil </dd>
<dd>
SDL_floor </dd>
<dd>
SDL_round </dd>
<dd>
SDL_lround </dd></dl>

</div>
</div>
<a id="gae6b046a5844394a19061a8544376ffac" name="gae6b046a5844394a19061a8544376ffac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6b046a5844394a19061a8544376ffac">&#9670;&#160;</a></span>truncf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SDL::truncf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rounds <code>x</code> to the next closest integer to 0. This is equivalent to removing the fractional part of <code>x</code>, leaving only the integer part.</p>
<p>Domain: <code>-INF &lt;= x &lt;= INF</code></p>
<p>Range: <code>-INF &lt;= y &lt;= INF</code>, y integer</p>
<p>This function operates on single-precision floating point values, use SDL_truncf for double-precision floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> truncated to an integer.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_trunc </dd>
<dd>
SDL_fmodf </dd>
<dd>
SDL_ceilf </dd>
<dd>
SDL_floorf </dd>
<dd>
SDL_roundf </dd>
<dd>
SDL_lroundf </dd></dl>

</div>
</div>
<a id="ga032867626ec7d90baa207d817fdbddcf" name="ga032867626ec7d90baa207d817fdbddcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga032867626ec7d90baa207d817fdbddcf">&#9670;&#160;</a></span>UCS4ToUTF8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::UCS4ToUTF8 </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>codepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The buffer pointed to by <code>dst</code> must be at least 4 bytes long, as this function may generate between 1 and 4 bytes of output.</p>
<p>This function returns the first byte <em>after</em> the newly-written UTF-8 sequence, which is useful for encoding multiple codepoints in a loop, or knowing where to write a NULL-terminator character to end the string (in either case, plan to have a buffer of <em>more</em> than 4 bytes!).</p>
<p>If <code>codepoint</code> is an invalid value (outside the Unicode range, or a UTF-16 surrogate value, etc), this will use U+FFFD (REPLACEMENT CHARACTER) for the codepoint instead, and not set an error.</p>
<p>If <code>dst</code> is NULL, this returns NULL immediately without writing to the pointer and without setting an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codepoint</td><td>a Unicode codepoint to convert to UTF-8. </td></tr>
    <tr><td class="paramname">dst</td><td>the location to write the encoded UTF-8. Must point to at least 4 bytes! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first byte past the newly-written UTF-8 sequence.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga6ca0851c2d9980695748c979e2d15608" name="ga6ca0851c2d9980695748c979e2d15608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ca0851c2d9980695748c979e2d15608">&#9670;&#160;</a></span>uitoa()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::uitoa </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This requires a radix to specified for string format. Specifying 10 produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2 to 36.</p>
<p>Note that this function will overflow a buffer if <code>str</code> is not large enough to hold the output! It may be safer to use SDL_snprintf to clamp output, or SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate much more space than you expect to use (and don't forget null terminator bytes, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the unsigned integer to convert. </td></tr>
    <tr><td class="paramname">str</td><td>the buffer to write the string into. </td></tr>
    <tr><td class="paramname">radix</td><td>the radix to use for string generation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>str</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_itoa </dd>
<dd>
SDL_ultoa </dd>
<dd>
SDL_ulltoa </dd></dl>

</div>
</div>
<a id="ga2450290efea2bebff1f164a6c4a04d38" name="ga2450290efea2bebff1f164a6c4a04d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2450290efea2bebff1f164a6c4a04d38">&#9670;&#160;</a></span>ultoa()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SDL::ultoa </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This requires a radix to specified for string format. Specifying 10 produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2 to 36.</p>
<p>Note that this function will overflow a buffer if <code>str</code> is not large enough to hold the output! It may be safer to use SDL_snprintf to clamp output, or SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate much more space than you expect to use (and don't forget null terminator bytes, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the unsigned long integer to convert. </td></tr>
    <tr><td class="paramname">str</td><td>the buffer to write the string into. </td></tr>
    <tr><td class="paramname">radix</td><td>the radix to use for string generation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>str</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_ltoa </dd>
<dd>
SDL_uitoa </dd>
<dd>
SDL_ulltoa </dd></dl>

</div>
</div>
<a id="ga7dc726179e2ae431d7db8164099e333a" name="ga7dc726179e2ae431d7db8164099e333a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dc726179e2ae431d7db8164099e333a">&#9670;&#160;</a></span>unsetenv_unsafe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::unsetenv_unsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the variable to unset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>This function is not thread safe, consider using SDL_UnsetEnvironmentVariable() instead.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_UnsetEnvironmentVariable </dd></dl>

</div>
</div>
<a id="ga8ae726c47fde58d11167345dfda765a4" name="ga8ae726c47fde58d11167345dfda765a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ae726c47fde58d11167345dfda765a4">&#9670;&#160;</a></span>utf8strlcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::utf8strlcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dst_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function copies up to <code>dst_bytes</code> - 1 bytes from <code>src</code> to <code>dst</code> while also ensuring that the string written to <code>dst</code> does not end in a truncated multi-byte sequence. Finally, it appends a null terminator.</p>
<p><code>src</code> and <code>dst</code> must not overlap.</p>
<p>Note that unlike SDL_strlcpy(), this function returns the number of bytes written, not the length of <code>src</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination buffer. Must not be NULL, and must not overlap with <code>src</code>. </td></tr>
    <tr><td class="paramname">src</td><td>The null-terminated UTF-8 string to copy. Must not be NULL, and must not overlap with <code>dst</code>. </td></tr>
    <tr><td class="paramname">dst_bytes</td><td>The length (in bytes) of the destination buffer. Must not be 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written, excluding the null terminator.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_strlcpy </dd></dl>

</div>
</div>
<a id="ga81767a08005a153d60b63896c58c106f" name="ga81767a08005a153d60b63896c58c106f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81767a08005a153d60b63896c58c106f">&#9670;&#160;</a></span>utf8strlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::utf8strlen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts the <em>codepoints</em>, not <em>bytes</em>, in <code>str</code>, excluding the null terminator.</p>
<p>If you need to count the bytes in a string instead, consider using SDL_strlen().</p>
<p>Since this handles Unicode, it expects the strings to be well-formed UTF-8 and not a null-terminated string of arbitrary bytes. Bytes that are not valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the count by several replacement characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated UTF-8 string to read. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (in codepoints, excluding the null terminator) of <code>src</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_utf8strnlen </dd>
<dd>
SDL_strlen </dd></dl>

</div>
</div>
<a id="ga82960b752efedfdd3cbfcf166d06161e" name="ga82960b752efedfdd3cbfcf166d06161e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82960b752efedfdd3cbfcf166d06161e">&#9670;&#160;</a></span>utf8strnlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::utf8strnlen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts the <em>codepoints</em>, not <em>bytes</em>, in <code>str</code>, excluding the null terminator.</p>
<p>If you need to count the bytes in a string instead, consider using SDL_strnlen().</p>
<p>The counting stops at <code>bytes</code> bytes (not codepoints!). This seems counterintuitive, but makes it easy to express the total size of the string's buffer.</p>
<p>Since this handles Unicode, it expects the strings to be well-formed UTF-8 and not a null-terminated string of arbitrary bytes. Bytes that are not valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the count by several replacement characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated UTF-8 string to read. Must not be NULL. </td></tr>
    <tr><td class="paramname">bytes</td><td>The maximum amount of bytes to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (in codepoints, excluding the null terminator) of <code>src</code> but never more than <code>maxlen</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_utf8strlen </dd>
<dd>
SDL_strnlen </dd></dl>

</div>
</div>
<a id="gabd658aed3baf56ca11c8148de5cd9480" name="gabd658aed3baf56ca11c8148de5cd9480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd658aed3baf56ca11c8148de5cd9480">&#9670;&#160;</a></span>vasprintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::vasprintf </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>strp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_PRINTF_FORMAT_STRING const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Functions identically to SDL_asprintf(), except it takes a <code>va_list</code> instead of using <code>...</code> variable arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strp</td><td>on output, is set to the new string. Must not be NULL. </td></tr>
    <tr><td class="paramname">fmt</td><td>a printf-style format string. Must not be NULL. </td></tr>
    <tr><td class="paramname">ap</td><td>a <code>va_list</code> values to be used with the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes in the newly-allocated string, not counting the null-terminator char, or a negative value on error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga4402ec18128560a4643446630b3a4633" name="ga4402ec18128560a4643446630b3a4633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4402ec18128560a4643446630b3a4633">&#9670;&#160;</a></span>vsnprintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::vsnprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_PRINTF_FORMAT_STRING const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Functions identically to SDL_snprintf(), except it takes a <code>va_list</code> instead of using <code>...</code> variable arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>the buffer to write the string into. Must not be NULL. </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum bytes to write, including the null-terminator. </td></tr>
    <tr><td class="paramname">fmt</td><td>a printf-style format string. Must not be NULL. </td></tr>
    <tr><td class="paramname">ap</td><td>a <code>va_list</code> values to be used with the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that should be written, not counting the null-terminator char, or a negative value on error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gac1c131187ea64c08ed8abb3d04551072" name="gac1c131187ea64c08ed8abb3d04551072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1c131187ea64c08ed8abb3d04551072">&#9670;&#160;</a></span>vsscanf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::vsscanf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSDL_1_1StringParamImpl.html">StringParam</a>&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_SCANF_FORMAT_STRING const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Functions identically to SDL_sscanf(), except it takes a <code>va_list</code> instead of using <code>...</code> variable arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>the string to scan. Must not be NULL. </td></tr>
    <tr><td class="paramname">fmt</td><td>a printf-style format string. Must not be NULL. </td></tr>
    <tr><td class="paramname">ap</td><td>a <code>va_list</code> of pointers to values to be filled in with scanned items. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of items that matched the format string.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga83409fe8ca79edcf997ebfcda6226a5a" name="ga83409fe8ca79edcf997ebfcda6226a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83409fe8ca79edcf997ebfcda6226a5a">&#9670;&#160;</a></span>vswprintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::vswprintf </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_PRINTF_FORMAT_STRING const wchar_t *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Functions identically to SDL_swprintf(), except it takes a <code>va_list</code> instead of using <code>...</code> variable arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>the buffer to write the string into. Must not be NULL. </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum wide characters to write, including the null-terminator. </td></tr>
    <tr><td class="paramname">fmt</td><td>a printf-style format wide string. Must not be NULL. </td></tr>
    <tr><td class="paramname">ap</td><td>a <code>va_list</code> values to be used with the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of wide characters that should be written, not counting the null-terminator char, or a negative value on error.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gae24c494fab206e9aa27dfd9c04b35e81" name="gae24c494fab206e9aa27dfd9c04b35e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae24c494fab206e9aa27dfd9c04b35e81">&#9670;&#160;</a></span>wcscasecmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::wcscasecmp </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will work with Unicode strings, using a technique called "case-folding" to handle the vast majority of case-sensitive human languages regardless of system locale. It can deal with expanding values: a German Eszett character can compare against two ASCII 's' chars and be considered a match, for example. A notable exception: it does not handle the Turkish 'i' character; human language is complicated!</p>
<p>Depending on your platform, "wchar_t" might be 2 bytes, and expected to be UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this handles Unicode, it expects the string to be well-formed and not a null-terminated string of arbitrary bytes. Characters that are not valid UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT CHARACTER), which is to say two strings of random bits may turn out to match if they convert to the same amount of replacement characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. NULL is not permitted! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga9edc1299fb56e51101501e09aaaa5b1f" name="ga9edc1299fb56e51101501e09aaaa5b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9edc1299fb56e51101501e09aaaa5b1f">&#9670;&#160;</a></span>wcscmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::wcscmp </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This only compares wchar_t values until it hits a null-terminating character; it does not care if the string is well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size), or uses valid Unicode values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. NULL is not permitted! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga26f89af82ddb65cb934e2c3dc6abb807" name="ga26f89af82ddb65cb934e2c3dc6abb807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26f89af82ddb65cb934e2c3dc6abb807">&#9670;&#160;</a></span>wcsdup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t * SDL::wcsdup </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>wstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This allocates enough space for a null-terminated copy of <code>wstr</code>, using SDL_malloc, and then makes a copy of the string into this space.</p>
<p>The returned string is owned by the caller, and should be passed to SDL_free when no longer needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstr</td><td>the string to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly-allocated wide string.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaeebfd8bdc9570592d8c1a5083f5d6893" name="gaeebfd8bdc9570592d8c1a5083f5d6893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeebfd8bdc9570592d8c1a5083f5d6893">&#9670;&#160;</a></span>wcslcat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::wcslcat </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function appends up to <code>maxlen</code> - SDL_wcslen(dst) - 1 wide characters from <code>src</code> to the end of the wide string in <code>dst</code>, then appends a null terminator.</p>
<p><code>src</code> and <code>dst</code> must not overlap.</p>
<p>If <code>maxlen</code> - SDL_wcslen(dst) - 1 is less than or equal to 0, then <code>dst</code> is unmodified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination buffer already containing the first null-terminated wide string. Must not be NULL and must not overlap with <code>src</code>. </td></tr>
    <tr><td class="paramname">src</td><td>The second null-terminated wide string. Must not be NULL, and must not overlap with <code>dst</code>. </td></tr>
    <tr><td class="paramname">maxlen</td><td>The length (in wide characters) of the destination buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in wide characters, excluding the null terminator) of the string in <code>dst</code> plus the length of <code>src</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_wcslcpy </dd></dl>

</div>
</div>
<a id="gaaa4a6075598ac1d2db01c28f76bf8c08" name="gaaa4a6075598ac1d2db01c28f76bf8c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa4a6075598ac1d2db01c28f76bf8c08">&#9670;&#160;</a></span>wcslcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::wcslcpy </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function copies <code>maxlen</code> - 1 wide characters from <code>src</code> to <code>dst</code>, then appends a null terminator.</p>
<p><code>src</code> and <code>dst</code> must not overlap.</p>
<p>If <code>maxlen</code> is 0, no wide characters are copied and no null terminator is written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination buffer. Must not be NULL, and must not overlap with <code>src</code>. </td></tr>
    <tr><td class="paramname">src</td><td>The null-terminated wide string to copy. Must not be NULL, and must not overlap with <code>dst</code>. </td></tr>
    <tr><td class="paramname">maxlen</td><td>The length (in wide characters) of the destination buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in wide characters, excluding the null terminator) of <code>src</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_wcslcat </dd></dl>

</div>
</div>
<a id="gafaba3e78b66aee106f48c80864156f0a" name="gafaba3e78b66aee106f48c80864156f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaba3e78b66aee106f48c80864156f0a">&#9670;&#160;</a></span>wcslen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::wcslen </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>wstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts the number of wchar_t values in <code>wstr</code>, excluding the null terminator.</p>
<p>Like SDL_strlen only counts bytes and not codepoints in a UTF-8 string, this counts wchar_t values in a string, even if the string's encoding is of variable width, like UTF-16.</p>
<p>Also be aware that wchar_t is different sizes on different platforms (4 bytes on Linux, 2 on Windows, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstr</td><td>The null-terminated wide string to read. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in wchar_t values, excluding the null terminator) of <code>wstr</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_wcsnlen </dd>
<dd>
SDL_utf8strlen </dd>
<dd>
SDL_utf8strnlen </dd></dl>

</div>
</div>
<a id="gaaf1b8559eb793e57181bf418af47d555" name="gaaf1b8559eb793e57181bf418af47d555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf1b8559eb793e57181bf418af47d555">&#9670;&#160;</a></span>wcsncasecmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::wcsncasecmp </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will work with Unicode strings, using a technique called "case-folding" to handle the vast majority of case-sensitive human languages regardless of system locale. It can deal with expanding values: a German Eszett character can compare against two ASCII 's' chars and be considered a match, for example. A notable exception: it does not handle the Turkish 'i' character; human language is complicated!</p>
<p>Depending on your platform, "wchar_t" might be 2 bytes, and expected to be UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this handles Unicode, it expects the string to be well-formed and not a null-terminated string of arbitrary bytes. Characters that are not valid UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT CHARACTER), which is to say two strings of random bits may turn out to match if they convert to the same amount of replacement characters.</p>
<p>Note that while this function might deal with variable-sized characters, <code>maxlen</code> specifies a <em>wchar</em> limit! If the limit lands in the middle of a multi-byte UTF-16 sequence, it may convert a portion of the final character to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not to overflow a buffer.</p>
<p><code>maxlen</code> specifies a maximum number of wchar_t values to compare; if the strings match to this number of wchar_t (or both have matched to a null-terminator character before this number of bytes), they will be considered equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum number of wchar_t values to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga00de271aaf6fd8a464c34b16f7b419ff" name="ga00de271aaf6fd8a464c34b16f7b419ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00de271aaf6fd8a464c34b16f7b419ff">&#9670;&#160;</a></span>wcsncmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SDL::wcsncmp </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This only compares wchar_t values; it does not care if the string is well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size), or uses valid Unicode values.</p>
<p>Note that while this function is intended to be used with UTF-16 (or UTF-32, depending on your platform's definition of wchar_t), it is comparing raw wchar_t values and not Unicode codepoints: <code>maxlen</code> specifies a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16 sequence, it will only compare a portion of the final character.</p>
<p><code>maxlen</code> specifies a maximum number of wchar_t to compare; if the strings match to this number of wide chars (or both have matched to a null-terminator character before this count), they will be considered equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>the first string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">str2</td><td>the second string to compare. NULL is not permitted! </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum number of wchar_t to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>less than zero if str1 is "less than" str2, greater than zero if str1 is "greater than" str2, and zero if the strings match exactly.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga83f6331afec19491a73e0f711d7b3faf" name="ga83f6331afec19491a73e0f711d7b3faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83f6331afec19491a73e0f711d7b3faf">&#9670;&#160;</a></span>wcsnlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SDL::wcsnlen </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>wstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts up to a maximum of <code>maxlen</code> wchar_t values in <code>wstr</code>, excluding the null terminator.</p>
<p>Like SDL_strnlen only counts bytes and not codepoints in a UTF-8 string, this counts wchar_t values in a string, even if the string's encoding is of variable width, like UTF-16.</p>
<p>Also be aware that wchar_t is different sizes on different platforms (4 bytes on Linux, 2 on Windows, etc).</p>
<p>Also, <code>maxlen</code> is a count of wide characters, not bytes!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstr</td><td>The null-terminated wide string to read. Must not be NULL. </td></tr>
    <tr><td class="paramname">maxlen</td><td>The maximum amount of wide characters to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length (in wide characters, excluding the null terminator) of <code>wstr</code> but never more than <code>maxlen</code>.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_wcslen </dd>
<dd>
SDL_utf8strlen </dd>
<dd>
SDL_utf8strnlen </dd></dl>

</div>
</div>
<a id="gacc794d23fc0f8b51d4abbcf226e6d7c7" name="gacc794d23fc0f8b51d4abbcf226e6d7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc794d23fc0f8b51d4abbcf226e6d7c7">&#9670;&#160;</a></span>wcsnstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t * SDL::wcsnstr </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The search ends once it finds the requested substring, or a null terminator value to end the string, or <code>maxlen</code> wide character have been examined. It is possible to use this function on a wide string without a null terminator.</p>
<p>Note that this looks for strings of <em>wide characters</em>, not <em>codepoints</em>, so it's legal to search for malformed and incomplete UTF-16 sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>the wide string to search. Must not be NULL. </td></tr>
    <tr><td class="paramname">needle</td><td>the wide string to search for. Must not be NULL. </td></tr>
    <tr><td class="paramname">maxlen</td><td>the maximum number of wide characters to search in <code>haystack</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first instance of <code>needle</code> in the string, or NULL if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gad864d11d477fc831eb7fcd5a40fbe615" name="gad864d11d477fc831eb7fcd5a40fbe615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad864d11d477fc831eb7fcd5a40fbe615">&#9670;&#160;</a></span>wcsstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t * SDL::wcsstr </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The search ends once it finds the requested substring, or a null terminator byte to end the string.</p>
<p>Note that this looks for strings of <em>wide characters</em>, not <em>codepoints</em>, so it's legal to search for malformed and incomplete UTF-16 sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>the wide string to search. Must not be NULL. </td></tr>
    <tr><td class="paramname">needle</td><td>the wide string to search for. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first instance of <code>needle</code> in the string, or NULL if not found.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga0408a155d55fa0fc2d0198de99ca0dc4" name="ga0408a155d55fa0fc2d0198de99ca0dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0408a155d55fa0fc2d0198de99ca0dc4">&#9670;&#160;</a></span>wcstol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long SDL::wcstol </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t **&#160;</td>
          <td class="paramname"><em>endp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If <code>str</code> starts with whitespace, then those whitespace characters are skipped before attempting to parse the number.</p>
<p>If the parsed number does not fit inside a <code>long</code>, the result is clamped to the minimum and maximum representable <code>long</code> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The null-terminated wide string to read. Must not be NULL. </td></tr>
    <tr><td class="paramname">endp</td><td>If not NULL, the address of the first invalid wide character (i.e. the next character after the parsed number) will be written to this pointer. </td></tr>
    <tr><td class="paramname">base</td><td>The base of the integer to read. Supported values are 0 and 2 to 36 inclusive. If 0, the base will be inferred from the number's prefix (0x for hexadecimal, 0 for octal, decimal otherwise). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed <code>long</code>, or 0 if no number could be parsed.</dd></dl>
<dl class="section user"><dt>Thread safety:</dt><dd>It is safe to call this function from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SDL_strtol </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
